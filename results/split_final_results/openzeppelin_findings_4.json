[{"title": "Update: Fixed in pull request #70.", "body": "Update: Fixed in pull request #70.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#update:-fixed-in-pull-request-#70.", "labels": ["OpenZeppelin"]}, {"title": "[N01] Inconsistent style", "body": "[N01] Inconsistent style", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#[n01]-inconsistent-style", "labels": ["OpenZeppelin"]}, {"title": "There are some places in the code base, where differences in style affect the readability, making it more difficult to understand the code. Some examples are:", "body": "There are some places in the code base, where differences in style affect the readability, making it more difficult to understand the code. Some examples are:", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#there-are-some-places-in-the-code-base,-where-differences-in-style-affect-the-readability,-making-it-more-difficult-to-understand-the-code.-some-examples-are:", "labels": ["OpenZeppelin"]}, {"title": "The Registry contract uses different styles for docstrings in the entire contract.", "body": "The Registry contract uses different styles for docstrings in the entire contract.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#the-registry-contract-uses-different-styles-for-docstrings-in-the-entire-contract.", "labels": ["OpenZeppelin"]}, {"title": "The SafeGuard contract is emitting an event when queueTransactionWithDescription is called but no events are emitted in other functions dealing with transactions.", "body": "The SafeGuard contract is emitting an event when queueTransactionWithDescription is called but no events are emitted in other functions dealing with transactions.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#the-safeguard-contract-is-emitting-an-event-when-queuetransactionwithdescription-is-called-but-no-events-are-emitted-in-other-functions-dealing-with-transactions.", "labels": ["OpenZeppelin"]}, {"title": "In the SafeGuard contract, sometimes value is used as named parameter and sometimes _value is used.", "body": "In the SafeGuard contract, sometimes value is used as named parameter and sometimes _value is used.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#in-the-safeguard-contract,-sometimes-value-is-used-as-named-parameter-and-sometimes-_value-is-used.", "labels": ["OpenZeppelin"]}, {"title": "Taking into consideration the value a consistent coding style adds to the project\u2019s readability, consider enforcing a standard coding style with help of linter tools, such as Solhint.", "body": "Taking into consideration the value a consistent coding style adds to the project\u2019s readability, consider enforcing a standard coding style with help of linter tools, such as Solhint.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#taking-into-consideration-the-value-a-consistent-coding-style-adds-to-the-project\u2019s-readability,-consider-enforcing-a-standard-coding-style-with-help-of-linter-tools,-such-as-solhint.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR #10 and commit 7fd27df16fc879d990d36a167a0b6e719e578558.", "body": "Notes & Additional Information  [N01] Inconsistent style  There are some places in the code base, where differences in style affect the readability, making it more difficult to understand the code. Some examples are:  The Registry contract uses different styles for docstrings in the entire contract.  The SafeGuard contract is emitting an event when queueTransactionWithDescription is called but no events are emitted in other functions dealing with transactions.  In the SafeGuard contract, sometimes value is used as named parameter and sometimes _value is used.  Taking into consideration the value a consistent coding style adds to the projects readability, consider enforcing a standard coding style with help of linter tools, such as Solhint.    [N02] Missing license  The following contracts within the code base are missing an SPDX license identifier.  The ISafeGuard interface.  The ITimelock interface.  The SafeGuard contract.  To silence compiler warnings and increase consistency across the codebase consider adding a license identifier. While doing it consider referring to spdx.dev guidelines.    [N03] OpenZeppelin Contracts dependency is not pinned  To prevent unexpected behaviors in case breaking changes are released in future updates of the OpenZeppelin Contracts library, consider pinning the version of this dependency in the package.json file.  Update: Fixed in PR #10.  [N04] Solidity compiler version is not pinned  Throughout the code base, consider pinning the version of the Solidity compiler to its latest stable version. This should help prevent introducing unexpected bugs due to incompatible future releases. To choose a specific version, developers should consider both the compilers features needed by the project and the list of known bugs associated with each Solidity compiler version.  Update: Fixed in PR #10.  [N05] Typo  At various instances throughout the code base, the word role is misspelled as rol. One such example is in the docstring within the constructor of the SafeGuard contract.  Consider correcting these typos to improve code readability.  Update: Partially fixed in PR #10. While the spelling of role has been corrected, the comment set admin role the an defined admin address should be set admin role to a defined admin address. Additionally, execute is misspelled in the SafeGuard contract on line 69, line 82, line 96 and line 110 and available is misspelled on line 70, line 83, line 97, line 111. Also, consider replacing informal words such as gonna in SafeGuard contract with formal alternatives such as going to.  [N06] Declare uint as uint256  eta variable in the QueueTransactionWithDescription event of the    [N07] Unused import  The SafeGuard contract imports the console contract but never uses it.To improve readability of the code, consider removing any unused imports.  Update: Fixed in PR #10.  Conclusions  One high and several other minor vulnerabilities have been found and recommendations and fixes have been suggested.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#update:-fixed-in-pr-#10-and-commit-7fd27df16fc879d990d36a167a0b6e719e578558.", "labels": ["OpenZeppelin"]}, {"title": "[N02] Missing license", "body": "[N02] Missing license", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#[n02]-missing-license", "labels": ["OpenZeppelin"]}, {"title": "The following contracts within the code base are missing an SPDX license identifier.", "body": "The following contracts within the code base are missing an SPDX license identifier.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#the-following-contracts-within-the-code-base-are-missing-an-spdx-license-identifier.", "labels": ["OpenZeppelin"]}, {"title": "The ISafeGuard interface.", "body": "The ISafeGuard interface.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#the-isafeguard-interface.", "labels": ["OpenZeppelin"]}, {"title": "The ITimelock interface.", "body": "The ITimelock interface.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#the-itimelock-interface.", "labels": ["OpenZeppelin"]}, {"title": "The SafeGuard contract.", "body": "The SafeGuard contract.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#the-safeguard-contract.", "labels": ["OpenZeppelin"]}, {"title": "To silence compiler warnings and increase consistency across the codebase consider adding a license identifier. While doing it consider referring to spdx.dev guidelines.", "body": "To silence compiler warnings and increase consistency across the codebase consider adding a license identifier. While doing it consider referring to spdx.dev guidelines.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#to-silence-compiler-warnings-and-increase-consistency-across-the-codebase-consider-adding-a-license-identifier.-while-doing-it-consider-referring-to-spdx.dev-guidelines.", "labels": ["OpenZeppelin"]}, {"title": "[N03] OpenZeppelin Contract\u2019s dependency is not pinned", "body": "[N03] OpenZeppelin Contract\u2019s dependency is not pinned", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#[n03]-openzeppelin-contract\u2019s-dependency-is-not-pinned", "labels": ["OpenZeppelin"]}, {"title": "To prevent unexpected behaviors in case breaking changes are released in future updates of the OpenZeppelin Contracts\u2019 library, consider pinning the version of this dependency in the package.json file.", "body": "To prevent unexpected behaviors in case breaking changes are released in future updates of the OpenZeppelin Contracts\u2019 library, consider pinning the version of this dependency in the package.json file.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#to-prevent-unexpected-behaviors-in-case-breaking-changes-are-released-in-future-updates-of-the-openzeppelin-contracts\u2019-library,-consider-pinning-the-version-of-this-dependency-in-the-package.json-file.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR #10.", "body": "[L03] Incorrect interface definition and implementation  The ISafeGuard interface does not define the queueTransactionWithDescription function implemented in the SafeGuard contract, and at the same time, it defines the __abdicate, __queueSetTimelockPendingAdmin and __executeSetTimelockPendingAdmin functions but they are not implemented.  To improve correctness and consistency in the codebase, consider refactoring the ISafeGuard interface to match exactly the SafeGuard implementation.  Update: Fixed in commit 7fd27df16fc879d990d36a167a0b6e719e578558.  [L04] Missing docstrings  Some of the contracts and functions in the code base lack documentation. For example, some functions in the SafeGuard contract.  Additionally, some docstrings use informal language, such as the one above the setTimelock function in the SafeGuard contract.  This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Partially fixed in PR #10. Proper docstrings have been added to various functions throughout the code base. However, in addition to the current changes, consider making the following changes:  Add description as the @param in the docstring above queueTransactionWithDescription function  Add @param in the docstring above the createSafeGuard function in SafeGuardFactory contract  Add @return in docstrings above the functions in SafeGuardFactory contract.  [L05] Useless or repeated code  There are places in the codebase where code is either repeated or not needed. Some examples are:  Lines 29-32 of the Registry contract are useless, because the _add function of the EnumerableSet contract already performs these checks against the values already being set.  Lines 62, 67, 73 and 78 of the SafeGuard contract are all repeating the same exact operation. Consider encapsulating it into an internal function to avoid duplicating code.  Lines 62-63 and 67-68 of SafeGuard are repeated. Consider encapsulating them into a single internal function.  The usage of gasleft to specify how much gas should be forwarded in the call of the function executeTransaction is unnecessary. This is because, at that point of execution, the entire gas left will be used to continue the execution. If this is not for expliciteness, consider removing the gas parameter from the call.  Consider applying the suggested fixed to produce a cleaner code and improve consistency and modularity over the codebase.  Update: Fixed in PR #10 and commit 7fd27df16fc879d990d36a167a0b6e719e578558.  Notes & Additional Information  [N01] Inconsistent style  There are some places in the code base, where differences in style affect the readability, making it more difficult to understand the code. Some examples are:  The Registry contract uses different styles for docstrings in the entire contract.  The SafeGuard contract is emitting an event when queueTransactionWithDescription is called but no events are emitted in other functions dealing with transactions.  In the SafeGuard contract, sometimes value is used as named parameter and sometimes _value is used.  Taking into consideration the value a consistent coding style adds to the projects readability, consider enforcing a standard coding style with help of linter tools, such as Solhint.  Update: Fixed in PR #10 and commit 7fd27df16fc879d990d36a167a0b6e719e578558.  [N02] Missing license  The following contracts within the code base are missing an SPDX license identifier.  The ISafeGuard interface.  The ITimelock interface.  The SafeGuard contract.  To silence compiler warnings and increase consistency across the codebase consider adding a license identifier. While doing it consider referring to spdx.dev guidelines.  Update: Fixed in PR #10 and commit 7fd27df16fc879d990d36a167a0b6e719e578558.  [N03] OpenZeppelin Contracts dependency is not pinned  To prevent unexpected behaviors in case breaking changes are released in future updates of the OpenZeppelin Contracts library, consider pinning the version of this dependency in the package.json file.    [N04] Solidity compiler version is not pinned  Throughout the code base, consider pinning the version of the Solidity compiler to its latest stable version. This should help prevent introducing unexpected bugs due to incompatible future releases. To choose a specific version, developers should consider both the compilers features needed by the project and the list of known bugs associated with each Solidity compiler version.    [N05] Typo  At various instances throughout the code base, the word role is misspelled as rol. One such example is in the docstring within the constructor of the SafeGuard contract.  Consider correcting these typos to improve code readability.  Update: Partially fixed in PR #10. While the spelling of role has been corrected, the comment set admin role the an defined admin address should be set admin role to a defined admin address. Additionally, execute is misspelled in the SafeGuard contract on line 69, line 82, line 96 and line 110 and available is misspelled on line 70, line 83, line 97, line 111. Also, consider replacing informal words such as gonna in SafeGuard contract with formal alternatives such as going to.  [N06] Declare uint as uint256  eta variable in the QueueTransactionWithDescription event of the  Update: Fixed in PR #10 and commit 7fd27df16fc879d990d36a167a0b6e719e578558.  [N07] Unused import  The SafeGuard contract imports the console contract but never uses it.To improve readability of the code, consider removing any unused imports.    Conclusions  One high and several other minor vulnerabilities have been found and recommendations and fixes have been suggested.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#update:-fixed-in-pr-#10.", "labels": ["OpenZeppelin"]}, {"title": "[N04] Solidity compiler version is not pinned", "body": "[N04] Solidity compiler version is not pinned", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#[n04]-solidity-compiler-version-is-not-pinned", "labels": ["OpenZeppelin"]}, {"title": "Throughout the code base, consider pinning the version of the Solidity compiler to its latest stable version. This should help prevent introducing unexpected bugs due to incompatible future releases. To choose a specific version, developers should consider both the compiler\u2019s features needed by the project and the list of known bugs associated with each Solidity compiler version.", "body": "Throughout the code base, consider pinning the version of the Solidity compiler to its latest stable version. This should help prevent introducing unexpected bugs due to incompatible future releases. To choose a specific version, developers should consider both the compiler\u2019s features needed by the project and the list of known bugs associated with each Solidity compiler version.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#throughout-the-code-base,-consider-pinning-the-version-of-the-solidity-compiler-to-its-latest-stable-version.-this-should-help-prevent-introducing-unexpected-bugs-due-to-incompatible-future-releases.-to-choose-a-specific-version,-developers-should-consider-both-the-compiler\u2019s-features-needed-by-the-project-and-the-list-of-known-bugs-associated-with-each-solidity-compiler-version.", "labels": ["OpenZeppelin"]}, {"title": "[N05] Typo", "body": "[N05] Typo", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#[n05]-typo", "labels": ["OpenZeppelin"]}, {"title": "At various instances throughout the code base, the word role is misspelled as rol. One such example is in the docstring within the constructor of the SafeGuard contract.", "body": "At various instances throughout the code base, the word role is misspelled as rol. One such example is in the docstring within the constructor of the SafeGuard contract.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#at-various-instances-throughout-the-code-base,-the-word-role-is-misspelled-as-rol.-one-such-example-is-in-the-docstring-within-the-constructor-of-the-safeguard-contract.", "labels": ["OpenZeppelin"]}, {"title": "Consider correcting these typos to improve code readability.", "body": "Consider correcting these typos to improve code readability.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#consider-correcting-these-typos-to-improve-code-readability.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed in PR #10. While the spelling of role has been corrected, the comment \u201cset admin role the an defined admin address\u201d should be \u201cset admin role to a defined admin address\u201d. Additionally, \u201cexecute\u201d is misspelled in the SafeGuard contract on line 69, line 82, line 96 and line 110 and \u201cavailable\u201d is misspelled on line 70, line 83, line 97, line 111. Also, consider replacing informal words such as \u201cgonna\u201d in SafeGuard contract with formal alternatives such as \u201cgoing to\u201d.", "body": "Update: Partially fixed in PR #10. While the spelling of role has been corrected, the comment \u201cset admin role the an defined admin address\u201d should be \u201cset admin role to a defined admin address\u201d. Additionally, \u201cexecute\u201d is misspelled in the SafeGuard contract on line 69, line 82, line 96 and line 110 and \u201cavailable\u201d is misspelled on line 70, line 83, line 97, line 111. Also, consider replacing informal words such as \u201cgonna\u201d in SafeGuard contract with formal alternatives such as \u201cgoing to\u201d.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#update:-partially-fixed-in-pr-#10.-while-the-spelling-of-role-has-been-corrected,-the-comment-\u201cset-admin-role-the-an-defined-admin-address\u201d-should-be-\u201cset-admin-role-to-a-defined-admin-address\u201d.-additionally,-\u201cexecute\u201d-is-misspelled-in-the-safeguard-contract-on-line-69,-line-82,-line-96-and-line-110-and-\u201cavailable\u201d-is-misspelled-on-line-70,-line-83,-line-97,-line-111.-also,-consider-replacing-informal-words-such-as-\u201cgonna\u201d-in-safeguard-contract-with-formal-alternatives-such-as-\u201cgoing-to\u201d.", "labels": ["OpenZeppelin"]}, {"title": "[N06] Declare uint as uint256", "body": "[N06] Declare uint as uint256", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#[n06]-declare-uint-as-uint256", "labels": ["OpenZeppelin"]}, {"title": "eta variable in the QueueTransactionWithDescription event of the", "body": "eta variable in the QueueTransactionWithDescription event of the", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#eta-variable-in-the-queuetransactionwithdescription-event-of-the", "labels": ["OpenZeppelin"]}, {"title": "[N07] Unused import", "body": "[N07] Unused import", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#[n07]-unused-import", "labels": ["OpenZeppelin"]}, {"title": "The SafeGuard contract imports the console contract but never uses it.To improve readability of the code, consider removing any unused imports.", "body": "The SafeGuard contract imports the console contract but never uses it.To improve readability of the code, consider removing any unused imports.", "html_url": "https://blog.openzeppelin.com/tally-safeguard-audit#the-safeguard-contract-imports-the-console-contract-but-never-uses-it.to-improve-readability-of-the-code,-consider-removing-any-unused-imports.", "labels": ["OpenZeppelin"]}, {"title": "[N01] Call return value not checked", "body": "[N01] Call return value not checked", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#[n01]-call-return-value-not-checked", "labels": ["OpenZeppelin"]}, {"title": "deposit function of the L2", "body": "deposit function of the L2", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#deposit-function-of-the-l2", "labels": ["OpenZeppelin"]}, {"title": "WETH interface. If this", "body": "WETH interface. If this", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#weth-interface.-if-this", "labels": ["OpenZeppelin"]}, {"title": "Consider checking and reacting appropriately to the return values of all low-level calls.", "body": "Consider checking and reacting appropriately to the return values of all low-level calls.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#consider-checking-and-reacting-appropriately-to-the-return-values-of-all-low-level-calls.", "labels": ["OpenZeppelin"]}, {"title": "[N02] Lack of indexed parameters in events", "body": "[N02] Lack of indexed parameters in events", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#[n02]-lack-of-indexed-parameters-in-events", "labels": ["OpenZeppelin"]}, {"title": "Many of the events defined in this codebase have parameters that should be indexed:", "body": "Many of the events defined in this codebase have parameters that should be indexed:", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#many-of-the-events-defined-in-this-codebase-have-parameters-that-should-be-indexed:", "labels": ["OpenZeppelin"]}, {"title": "newAdmin in BridgePoolsAdminTransferred", "body": "newAdmin in BridgePoolsAdminTransferred", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#newadmin-in-bridgepoolsadmintransferred", "labels": ["OpenZeppelin"]}, {"title": "chainId in WhitelistToken", "body": "chainId in WhitelistToken", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#chainid-in-whitelisttoken", "labels": ["OpenZeppelin"]}, {"title": "l2Token in TokensBridged", "body": "l2Token in TokensBridged", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#l2token-in-tokensbridged", "labels": ["OpenZeppelin"]}, {"title": "newAdmin in SetXDomainAdmin", "body": "newAdmin in SetXDomainAdmin", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#newadmin-in-setxdomainadmin", "labels": ["OpenZeppelin"]}, {"title": "Consider indexing event parameters to avoid hindering the task of off-chain services searching and filtering for specific events.", "body": "Consider indexing event parameters to avoid hindering the task of off-chain services searching and filtering for specific events.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#consider-indexing-event-parameters-to-avoid-hindering-the-task-of-off-chain-services-searching-and-filtering-for-specific-events.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed in commit d156b40b2ddb109806336c4d169dbdea91ed1c3e of PR3535. The chainId parameter of WhitelistToken was not updated.", "body": "Update: Partially fixed in commit d156b40b2ddb109806336c4d169dbdea91ed1c3e of PR3535. The chainId parameter of WhitelistToken was not updated.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#update:-partially-fixed-in-commit-d156b40b2ddb109806336c4d169dbdea91ed1c3e-of-pr3535.-the-chainid-parameter-of-whitelisttoken-was-not-updated.", "labels": ["OpenZeppelin"]}, {"title": "[N03] Implicit casting inconsistency", "body": "[N03] Implicit casting inconsistency", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#[n03]-implicit-casting-inconsistency", "labels": ["OpenZeppelin"]}, {"title": "treats timestamps as uint64 values, which are implicitly cast to", "body": "treats timestamps as uint64 values, which are implicitly cast to", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#treats-timestamps-as-uint64-values,-which-are-implicitly-cast-to", "labels": ["OpenZeppelin"]}, {"title": "passed to the Optimistic Oracle. However, the", "body": "passed to the Optimistic Oracle. However, the", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#passed-to-the-optimistic-oracle.-however,-the", "labels": ["OpenZeppelin"]}, {"title": "the _requestOraclePrice function is prematurely cast to a", "body": "the _requestOraclePrice function is prematurely cast to a", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#the-_requestoracleprice-function-is-prematurely-cast-to-a", "labels": ["OpenZeppelin"]}, {"title": "Nevertheless, in the interest of consistency, consider using a uint64 for this parameter and allowing it to be implicitly cast to a uint256 when passed to the Optimistic Oracle.", "body": "Nevertheless, in the interest of consistency, consider using a uint64 for this parameter and allowing it to be implicitly cast to a uint256 when passed to the Optimistic Oracle.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#nevertheless,-in-the-interest-of-consistency,-consider-using-a-uint64-for-this-parameter-and-allowing-it-to-be-implicitly-cast-to-a-uint256-when-passed-to-the-optimistic-oracle.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 1c3c5c000ef450f5e2da056e41caff468c3fcdcb of PR3528. The timestamp is now explicitly cast.", "body": "Update: Fixed in commit 1c3c5c000ef450f5e2da056e41caff468c3fcdcb of PR3528. The timestamp is now explicitly cast.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#update:-fixed-in-commit-1c3c5c000ef450f5e2da056e41caff468c3fcdcb-of-pr3528.-the-timestamp-is-now-explicitly-cast.", "labels": ["OpenZeppelin"]}, {"title": "[N04] Incorrect type", "body": "[N04] Incorrect type", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#[n04]-incorrect-type", "labels": ["OpenZeppelin"]}, {"title": "The sendMessage function of the iOptimism_CrossDomainMessenger interface uses a uint256 gas limit while Optimism\u2019s OVM_CrossDomainEnabled uses a uint32 gas limit.", "body": "The sendMessage function of the iOptimism_CrossDomainMessenger interface uses a uint256 gas limit while Optimism\u2019s OVM_CrossDomainEnabled uses a uint32 gas limit.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#the-sendmessage-function-of-the-ioptimism_crossdomainmessenger-interface-uses-a-uint256-gas-limit-while-optimism\u2019s-ovm_crossdomainenabled-uses-a-uint32-gas-limit.", "labels": ["OpenZeppelin"]}, {"title": "For consistency and predictability, consider updating the iOptimisim_CrossDomainMessenger sendMessage function to use a uint32 gas limit.", "body": "For consistency and predictability, consider updating the iOptimisim_CrossDomainMessenger sendMessage function to use a uint32 gas limit.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#for-consistency-and-predictability,-consider-updating-the-ioptimisim_crossdomainmessenger-sendmessage-function-to-use-a-uint32-gas-limit.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed as of commit 381951aad988bbba6b2ef1b136ed5c48df50aa88 in PR3460.", "body": "Update: Fixed as of commit 381951aad988bbba6b2ef1b136ed5c48df50aa88 in PR3460.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#update:-fixed-as-of-commit-381951aad988bbba6b2ef1b136ed5c48df50aa88-in-pr3460.", "labels": ["OpenZeppelin"]}, {"title": "[N05] Lack of validation", "body": "[N05] Lack of validation", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#[n05]-lack-of-validation", "labels": ["OpenZeppelin"]}, {"title": "All functions in BridgeAdmin that call _relayMessage assume the transaction value matches the l1CallValue parameter, but this is not enforced.", "body": "All functions in BridgeAdmin that call _relayMessage assume the transaction value matches the l1CallValue parameter, but this is not enforced.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#all-functions-in-bridgeadmin-that-call-_relaymessage-assume-the-transaction-value-matches-the-l1callvalue-parameter,-but-this-is-not-enforced.", "labels": ["OpenZeppelin"]}, {"title": "Consider ensuring the correct msg.value is set.", "body": "Consider ensuring the correct msg.value is set.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#consider-ensuring-the-correct-msg.value-is-set.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed as of commit f19b8d04c2343051ff2a8145abd41c39bd025063 in PR3537.", "body": "Update: Fixed as of commit f19b8d04c2343051ff2a8145abd41c39bd025063 in PR3537.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#update:-fixed-as-of-commit-f19b8d04c2343051ff2a8145abd41c39bd025063-in-pr3537.", "labels": ["OpenZeppelin"]}, {"title": "[N06] Readability", "body": "[N06] Readability", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#[n06]-readability", "labels": ["OpenZeppelin"]}, {"title": "_getDepositHash function of the", "body": "_getDepositHash function of the", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#_getdeposithash-function-of-the", "labels": ["OpenZeppelin"]}, {"title": "Consider simplifying the arguments to simply be the ordered pair depositData and l1Token.", "body": "Consider simplifying the arguments to simply be the ordered pair depositData and l1Token.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#consider-simplifying-the-arguments-to-simply-be-the-ordered-pair-depositdata-and-l1token.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed as of commit 31754be4a818109fa12131f854c3f70d6c72dba7 in PR3538.", "body": "Update: Fixed as of commit 31754be4a818109fa12131f854c3f70d6c72dba7 in PR3538.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#update:-fixed-as-of-commit-31754be4a818109fa12131f854c3f70d6c72dba7-in-pr3538.", "labels": ["OpenZeppelin"]}, {"title": "[N07] Reentrant function", "body": "[N07] Reentrant function", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#[n07]-reentrant-function", "labels": ["OpenZeppelin"]}, {"title": "The requestAndProposePriceFor function of the SkinnyOptimisticOracle contract makes a call to an untrusted msg.sender but is not guarded by a nonReentrant modifier. While, in this instance, this does not seem to be a security concern, this can introduce unexpected behavior.", "body": "The requestAndProposePriceFor function of the SkinnyOptimisticOracle contract makes a call to an untrusted msg.sender but is not guarded by a nonReentrant modifier. While, in this instance, this does not seem to be a security concern, this can introduce unexpected behavior.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#the-requestandproposepricefor-function-of-the-skinnyoptimisticoracle-contract-makes-a-call-to-an-untrusted-msg.sender-but-is-not-guarded-by-a-nonreentrant-modifier.-while,-in-this-instance,-this-does-not-seem-to-be-a-security-concern,-this-can-introduce-unexpected-behavior.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding the nonReentrant modifier to all functions which make calls to possibly untrusted contracts.", "body": "Consider adding the nonReentrant modifier to all functions which make calls to possibly untrusted contracts.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#consider-adding-the-nonreentrant-modifier-to-all-functions-which-make-calls-to-possibly-untrusted-contracts.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit b744d24e7579b7afa2c778f4dd680f26117b3990 of PR3539.", "body": "Update: Fixed in commit b744d24e7579b7afa2c778f4dd680f26117b3990 of PR3539.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#update:-fixed-in-commit-b744d24e7579b7afa2c778f4dd680f26117b3990-of-pr3539.", "labels": ["OpenZeppelin"]}, {"title": "[N08] seqNum not logged", "body": "[N08] seqNum not logged", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#[n08]-seqnum-not-logged", "labels": ["OpenZeppelin"]}, {"title": "relayMessage function of the", "body": "relayMessage function of the", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#relaymessage-function-of-the", "labels": ["OpenZeppelin"]}, {"title": "Consider emitting events after sensitive changes take place, to facilitate tracking and notify off-chain clients following the contract\u2019s activity.", "body": "Consider emitting events after sensitive changes take place, to facilitate tracking and notify off-chain clients following the contract\u2019s activity.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#consider-emitting-events-after-sensitive-changes-take-place,-to-facilitate-tracking-and-notify-off-chain-clients-following-the-contract\u2019s-activity.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed as of commit 30343f33532a6c255dc4cc18c3b497d9b2767a7c in PR3541.", "body": "Update: Fixed as of commit 30343f33532a6c255dc4cc18c3b497d9b2767a7c in PR3541.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#update:-fixed-as-of-commit-30343f33532a6c255dc4cc18c3b497d9b2767a7c-in-pr3541.", "labels": ["OpenZeppelin"]}, {"title": "[N09] Typographical errors", "body": "[N09] Typographical errors", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#[n09]-typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "The codebase contains the following typos:", "body": "The codebase contains the following typos:", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#the-codebase-contains-the-following-typos:", "labels": ["OpenZeppelin"]}, {"title": "\u201cint\u201d should be \u201cuint\u201d.", "body": "\u201cint\u201d should be \u201cuint\u201d.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#\u201cint\u201d-should-be-\u201cuint\u201d.", "labels": ["OpenZeppelin"]}, {"title": "\u201cLPS\u201d should be \u201cLSP\u201d.", "body": "\u201cLPS\u201d should be \u201cLSP\u201d.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#\u201clps\u201d-should-be-\u201clsp\u201d.", "labels": ["OpenZeppelin"]}, {"title": "\u201cmaximum\u201d should be \u201cminimum\u201d.", "body": "\u201cmaximum\u201d should be \u201cminimum\u201d.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#\u201cmaximum\u201d-should-be-\u201cminimum\u201d.", "labels": ["OpenZeppelin"]}, {"title": "\u201cexpire\u201d should be \u201cexpired\u201d.", "body": "Disiputer should be Disputer.  second should be seconds.  a instant should be an instant.  OptimismMessenger should be Optimism_Messenger.  tokens should be token.  callers should be callers.  to should be from.  Can not should be Cannot.  Consider correcting these typos to improve code readability.  Update: Fixed as of commit 2dccbe1c2c82fe2a21c179ac06c2d4f0d911a2ca in PR3540.  [N10] Undocumented ERC20 approval requirement  The requestEarlyExpiration and expire functions of the LongShortPair contract each assume that the caller has granted the contract an allowance to pull the proposer reward.  For the sake of predictability, consider documenting this requirement in the function comments.  Update: Fixed in commit da3754f50284480df57b90b80002da06a1ce0d02 in PR3529.  [N11] Unused modifier  In the BridgePool contract, the onlyFromOptimisticOracle modifier is defined but is never used in the codebase and should therefore be removed.  Update: Fixed in commit 7abece6377637e8c4cd3bd07ab9adcfa051d4e94 in PR3542.  Conclusions  2 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#\u201cexpire\u201d-should-be-\u201cexpired\u201d.", "labels": ["OpenZeppelin"]}, {"title": "\u201cmethod\u201d should be removed.", "body": "\u201cmethod\u201d should be removed.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#\u201cmethod\u201d-should-be-removed.", "labels": ["OpenZeppelin"]}, {"title": "\u201cits\u201d should be \u201cit\u2019s\u201d.", "body": "\u201cits\u201d should be \u201cit\u2019s\u201d.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#\u201cits\u201d-should-be-\u201cit\u2019s\u201d.", "labels": ["OpenZeppelin"]}, {"title": "\u201cCan not\u201d should be \u201cCannot\u201d.", "body": "Consider correcting these typos to improve code readability.  Update: Fixed as of commit 2dccbe1c2c82fe2a21c179ac06c2d4f0d911a2ca in PR3540.  [N10] Undocumented ERC20 approval requirement  The requestEarlyExpiration and expire functions of the LongShortPair contract each assume that the caller has granted the contract an allowance to pull the proposer reward.  For the sake of predictability, consider documenting this requirement in the function comments.  Update: Fixed in commit da3754f50284480df57b90b80002da06a1ce0d02 in PR3529.  [N11] Unused modifier  In the BridgePool contract, the onlyFromOptimisticOracle modifier is defined but is never used in the codebase and should therefore be removed.  Update: Fixed in commit 7abece6377637e8c4cd3bd07ab9adcfa051d4e94 in PR3542.  Conclusions  2 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#\u201ccan-not\u201d-should-be-\u201ccannot\u201d.", "labels": ["OpenZeppelin"]}, {"title": "\u201cDisiputer\u201d should be \u201cDisputer\u201d.", "body": "\u201cDisiputer\u201d should be \u201cDisputer\u201d.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#\u201cdisiputer\u201d-should-be-\u201cdisputer\u201d.", "labels": ["OpenZeppelin"]}, {"title": "\u201csecond\u201d should be \u201cseconds\u201d.", "body": "\u201csecond\u201d should be \u201cseconds\u201d.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#\u201csecond\u201d-should-be-\u201cseconds\u201d.", "labels": ["OpenZeppelin"]}, {"title": "\u201ca instant\u201d should be \u201can instant\u201d.", "body": "\u201ca instant\u201d should be \u201can instant\u201d.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#\u201ca-instant\u201d-should-be-\u201can-instant\u201d.", "labels": ["OpenZeppelin"]}, {"title": "\u201cOptimismMessenger\u201d should be \u201cOptimism_Messenger\u201d.", "body": "\u201cOptimismMessenger\u201d should be \u201cOptimism_Messenger\u201d.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#\u201coptimismmessenger\u201d-should-be-\u201coptimism_messenger\u201d.", "labels": ["OpenZeppelin"]}, {"title": "\u201ctokens\u201d should be \u201ctoken\u201d.", "body": "\u201ctokens\u201d should be \u201ctoken\u201d.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#\u201ctokens\u201d-should-be-\u201ctoken\u201d.", "labels": ["OpenZeppelin"]}, {"title": "\u201ccallers\u201d should be \u201ccaller\u2019s\u201d.", "body": "\u201ccallers\u201d should be \u201ccaller\u2019s\u201d.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#\u201ccallers\u201d-should-be-\u201ccaller\u2019s\u201d.", "labels": ["OpenZeppelin"]}, {"title": "\u201cto\u201d should be \u201cfrom\u201d.", "body": "\u201cto\u201d should be \u201cfrom\u201d.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#\u201cto\u201d-should-be-\u201cfrom\u201d.", "labels": ["OpenZeppelin"]}, {"title": "Consider correcting these typos to improve code readability.", "body": "Consider correcting these typos to improve code readability.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#consider-correcting-these-typos-to-improve-code-readability.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed as of commit 2dccbe1c2c82fe2a21c179ac06c2d4f0d911a2ca in PR3540.", "body": "Update: Fixed as of commit 2dccbe1c2c82fe2a21c179ac06c2d4f0d911a2ca in PR3540.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#update:-fixed-as-of-commit-2dccbe1c2c82fe2a21c179ac06c2d4f0d911a2ca-in-pr3540.", "labels": ["OpenZeppelin"]}, {"title": "[N10] Undocumented ERC20 approval requirement", "body": "[N10] Undocumented ERC20 approval requirement", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#[n10]-undocumented-erc20-approval-requirement", "labels": ["OpenZeppelin"]}, {"title": "The requestEarlyExpiration and expire functions of the LongShortPair contract each assume that the caller has granted the contract an allowance to pull the proposer reward.", "body": "The requestEarlyExpiration and expire functions of the LongShortPair contract each assume that the caller has granted the contract an allowance to pull the proposer reward.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#the-requestearlyexpiration-and-expire-functions-of-the-longshortpair-contract-each-assume-that-the-caller-has-granted-the-contract-an-allowance-to-pull-the-proposer-reward.", "labels": ["OpenZeppelin"]}, {"title": "For the sake of predictability, consider documenting this requirement in the function comments.", "body": "For the sake of predictability, consider documenting this requirement in the function comments.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#for-the-sake-of-predictability,-consider-documenting-this-requirement-in-the-function-comments.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit da3754f50284480df57b90b80002da06a1ce0d02 in PR3529.", "body": "Update: Fixed in commit da3754f50284480df57b90b80002da06a1ce0d02 in PR3529.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#update:-fixed-in-commit-da3754f50284480df57b90b80002da06a1ce0d02-in-pr3529.", "labels": ["OpenZeppelin"]}, {"title": "[N11] Unused modifier", "body": "[N11] Unused modifier", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#[n11]-unused-modifier", "labels": ["OpenZeppelin"]}, {"title": "In the BridgePool contract, the onlyFromOptimisticOracle modifier is defined but is never used in the codebase and should therefore be removed.", "body": "In the BridgePool contract, the onlyFromOptimisticOracle modifier is defined but is never used in the codebase and should therefore be removed.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#in-the-bridgepool-contract,-the-onlyfromoptimisticoracle-modifier-is-defined-but-is-never-used-in-the-codebase-and-should-therefore-be-removed.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 7abece6377637e8c4cd3bd07ab9adcfa051d4e94 in PR3542.", "body": "Update: Fixed in commit 7abece6377637e8c4cd3bd07ab9adcfa051d4e94 in PR3542.", "html_url": "https://blog.openzeppelin.com/uma-audit-l2-bridges#update:-fixed-in-commit-7abece6377637e8c4cd3bd07ab9adcfa051d4e94-in-pr3542.", "labels": ["OpenZeppelin"]}, {"title": "[N01] Additional issues", "body": "During our audit, the Optimism team independently found a number of issues in the code base. We briefly include them below for completeness.  The passMessageToL1 function of the OVM_L2ToL1MessagePasser contract is intended to be called by the OVM_L2CrossDomainMessenger, which validates the message sender and nonce before passing on the message. Although the function has no access controls, only messages sent from the OVM_L2ToL1MessagePasser can be relayed on layer 1. However, an attacker can use the L1-to-L2 message path to invoke the passMessageToL1 function from the OVM_L2CrossDomainMessenger with any parameters. This lets them send a message back up to L1 that bypasses the message sender and nonce validations. The Optimism team has indicated that they will remove the OVM_L2ToL1MessagePasser contract entirely, and use the sentMessages mapping in the OVM_L2CrossDomainMessenger instead.  The logic in the _handleContractCreation function of the OVM_ExecutionManager contract allows deploying potentially unsafe code. While it does validate the runtime code deployed, the restriction is enforced after the code is already deployed, without reverting the state changes.  After running a legitimate fraud proof and reaching the post-execution state, the associated State Manager still considers the Execution Manager as authenticated. This would allow further modifying state during post-execution.  An attacker can maliciously modify the context in which a fraud proof is run by first calling the run function of the OVM_ExecutionManager altering context-related variables (such as the isStatic flag), and then re-entering it during execution of a fraud proof.  Update: These issues were identified in the first audited commit. They are fixed in the latest audited commit. Note that instead of removing the OVM_L2ToL1MessagePasser contract, the first issue was addressed by recognizing and discarding L1-to-L2 cross domain messages directed at the OVM_L2ToL1MessagePasser contract.  [N02] Contracts do not compile with Solidity versions prior to 0.7  Contracts throughout the code base explicitly allow to be compiled with Solidity versions lower than 0.8 and greater than 0.5, by setting its pragma statement to pragma solidity >0.5.0 <0.8.0; (see for example the OVM_CanonicalTransactionChain contract). However, contracts that do not set explicit visibility in their constructors were only allowed starting in Solidity 0.7, meaning that it will not be possible to compile them with older versions.  Consider reviewing and updating the pragma statements of all contracts throughout the code base to ensure they can actually be compiled with the expected versions.  [N03] Fragile default values in Merkle tree  default values. These value are chosen to simulate the effect of padding the input  acceptable bound. This behavior is acknowledged,  noted in the function comments, and respected throughout the code base.  Nevertheless, we understand it would be more gas-efficient and easier to reason about if the default values were replaced with a constant value that provably has no known pre-image. Consider introducing this simplification.  [N04] Gas inefficiencies  This is a non-comprehensive list of simple gas inefficiencies detected as a side-product of the audit for the development teams consideration.  In the OVM_CanonicalTransactionChain contract:  The address of the Sequencer could be resolved before entering the loop to avoid unnecessary external calls during execution of the appendQueueBatch function. Similarly, the address referencing the queue should be resolved before entering the loop, then replacing the call to getQueueElement with _getQueueElement.  In the OVM_StateCommitmentChain contract:  The appendStateBatch function reads from storage the chains total elements twice (in lines 136 and 152) when it could do it once.  In the OVM_ExecutionManager contract:  The _createContract function reads from the messageContext.ovmADDRESS state variable three times, when it could do it just once at the beginning of the function.  In the OVM_L1ETHGateway contract:  The _safeTransferETH function of the OVM_L1ETHGateway contract uses a new bytes(0) object as a parameter when executing the call function. Using \"\" in place of new bytes(0) achieves the same effect and saves gas. Alternatively, consider entirely replacing the custom _safeTransferETH function with the sendValue function available in OpenZeppelin Contracts.  [N05] Incomplete override  The Abs_L1TokenGateway abstract contract has a default amount of gas that is sent with the cross-domain message. The intention is to allow descendant contracts to change this value as needed, but the current code base does not support this.  Consider marking the getFinalizeDepositL2Gas function as virtual so it can be overridden. Additionally, consider marking the default value as internal, so it is removed from the public API when it is no longer in use.  [N06] Inconsistent name resolution  There are a few inconsistent name resolutions throughout the code base:  The onlyRelayer modifier of the OVM_L1CrossDomainMessenger contract resolves the name OVM_L2MessageRelayer, which should point to the OVM_L1MultiMessageRelayer contract.  The OVM_L1MultiMessageRelayer and OVM_L1ETHGateway contracts resolve the name \"Proxy__OVM_L1CrossDomainMessenger\", while the OVM_L2CrossDomainMessenger contract resolves the name OVM_L1CrossDomainMessenger. Presumably, these point at the same address.  The name \"OVM_DecompressionPrecompileAddress\" should resolve to the address of the OVM_ProxySequencerEntrypoint contract.  The OVM_StateCommitmentChain contract resolves the name OVM_Proposer, but assigns it to a local variable called sequencer. This is because the sequencer and proposer are expected to be the same contract. However, in the interests of clarity, either the resolved name or the variable name should be modified for consistency (as suggested in the informational note [N31] Naming issues).  [N07] Inconsistent use of named return variables  Named return variables are used inconsistently. For example, while some functions in the OVM_CanonicalTransactionChain contract name their return variables, others do not. Consider removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This should improve both explicitness and readability of the project.  [N08] Minimum nuisance gas per contract creation is charged twice  The ovmCREATEEOA and safeCREATE functions, used for creating accounts in the OVM_ExecutionManager contract, follow a similar pattern to calculate nuisance gas:  Call the _initPendingAccount function (see lines 537 and 1098), which internally calls the _checkAccountLoad function, which in turn charges nuisance gas the first time the referenced account is loaded. Here, the amount of nuisance gas charged includes the minimum gas (dictated by the MIN_NUISANCE_GAS_PER_CONTRACT constant).  Call the _commitPendingAccount function (see lines 551 and 1125), which internally calls the _checkAccountChange function, which in turn charges nuisance gas the first time the referenced account is changed. Here, the amount of nuisance gas charged also includes MIN_NUISANCE_GAS_PER_CONTRACT (as in the first case).  This means that during account creation, the minimum amount of nuisance gas tracked in the MIN_NUISANCE_GAS_PER_CONTRACT constant is charged twice. This appears to be unnecessary since during fraud proof verification the code for the created account would only need to be provided once. Yet it could also be argued that in the fraud proof verification the pre-state of the empty account would need to be proved as well, and that is why the MIN_NUISANCE_GAS_PER_CONTRACT is charged twice.  To avoid confusions, consider explicitly specifying and documenting the intended behavior, including related unit tests if appropriate.  [N09] Redundant validations during state batch deletion  deleteStateBatch function of the  _isValidBatchHeader function, and after additional checks, it  executes the internal  checks that both the index and batch header are valid. Yet these last two validations are redundant, since as mentioned, the  already executed prior to the internal call to  To favor simplicity and gas-efficiency, consider removing these unnecessary validations.  [N10] Contract creation can revert upon failure  ovmCREATE and  ovmCREATE2 opcodes can revert during execution (instead of returning 0 upon failure as specified in the EVM). This is due to the fact that the code is validating the deployer is allowed at the beginning of the opcodes execution (see calls to the  here and  here), instead of doing it inside the  safeCREATE function, where similar validations are applied that do not result in a revert upon failure.  We are raising this peculiarity of the current version of the OVM as an informative note for completeness, since we understand that the development team is fully aware of this undocumented behavioral difference with EVM, and is planning to fix it by removing the deployer whitelist in the short term. Should that not be the case, consider this note of higher priority and explicitly document the described behavior in external documentation to raise user awareness.  [N11] Typographical errors  In Lib_MerkleTree.sol:  In line 117, sibline should say sibling.  In Lib_MerkleTrie.sol:  In line 275, 31 should say 32.  In Lib_Math.sol:  In line 14, minumum should say minimum.  In iOVM_ChainStorageContainer.sol:  In line 104, meaing should say meaning.  In OVM_CanonicalTransactionChain.sol:  In line 344, minnet should say mainnet.  In line 973, que should say queue.  In line 1011, elemtent should say element.  In OVM_CrossDomainEnabled.sol:  In line 14, recieve should say receive.  In OVM_L2ToL1MessagePasser.sol:  In line 9, facilitates is misspelled. It also includes the repeated phrase of the.  In Abs_L1TokenGateway.sol:  In line 128, recipients is misspelled.  In OVM_L1ERC20Gateway.sol:  In line 18, takes should say take.  In OVM_ExecutionManager.sol:  In line 168, awlways should say always.  In lines 191, 202, 213, and 1701, minnet should say mainnet.  In lines 1804, 1809, 1814, unnecessary the SSTORE should say the unnecessary SSTORE.  In OVM_ECDSAContract.sol:  In lines 142, transfer is misspelled.  In OVM_FraudVerifier.sol:  In line 210, minnet should say mainnet.  In Lib_RLPReader.sol:  In lines 384 and 410, a address should say an address.  [N12] Negative overflow of uint256 type  To favor readability, in line 1890 of OVM_ExecutionManager.sol consider replacing the negative overflow operation of an uint256 value with the expression type(uint256).max.  [N13] Unnecessary return statement  Consider removing the return keyword from the setGlobalMetadata function of the OVM_ChainStorageContainer contract, as the setExtraData function of the Lib_RingBuffer library being called does not return any value.  [N14] Unused imports  To improve readability and avoid confusion, consider removing the following unused imports.  In the OVM_StateCommitmentChain contract, the iOVM_FraudVerifier interface.  In the OVM_ExecutionManager contract, the OVM_ECDSAContractAccount and OVM_DeployerWhitelist contracts.  In the OVM_L2DepositedERC20 contract, the iOVM_L1TokenGateway interface.  In the OVM_ETH contract, the Lib_AddressResolver contract.  In the OVM_StateTransitioner contract, the iOVM_BondManager interface.  In the Lib_OVMCodec library, the Lib_BytesUtils library.  [N15] Unused events  The iOVM_L2ToL1MessagePasser interface defines the L2ToL1Message event, which is never emitted in the child contract OVM_L2ToL1MessagePasser.  To avoid confusion and favor simplicity, consider removing all definitions of events that are not expected to be emitted.  [N16] Unused functions  Functions toUint24, toUint8 and toAddress of the Lib_BytesUtils library are never used, and can therefore be removed.  [N17] Transaction hashes might not be unique in the Canonical Transaction Chain  The enqueue function of the OVM_CanonicalTransactionChain contract constructs transaction hashes with the callers address, the L2 target, the transactions gas limit and its data. Since this is not enough to ensure uniqueness of hashes (that is, it could be possible to construct two transactions that result in the same hash), these transactions are instead identified by their position in the queue. However, this internal subtlety of the Canonical Transaction Chain is not explicitly documented, and might lead to errors in off-chain services tracking transactions in the Canonical Transaction Chain, since transaction hashes are commonly assumed to be unique.  Consider including developer-friendly documentation stating how transaction hashes in the Canonical Transaction Chain are constructed, and how they should not be relied on to uniquely identify transactions.  [N18] Cross-domain messengers can be impersonated  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts allow relaying arbitrary cross-domain messages. Ultimately, this means that it is possible for anyone to make these contracts execute arbitrary calls (see calls hereand here). Therefore, there are two scenarios developers should consider when building and integrating bridges between layer 1 and 2. Aiming for simplicity, in the following we explain both scenarios starting on layer 1  yet a similar behavior can be seen in the opposite direction.  call any target address with arbitrary data. Therefore, layer 2 accounts should be aware that they can receive arbitrary calls from the  ERC1820Registry contract. It must be noted that during the call from the  xDomainMessageSender functionto inspect the address of the layer 1 account that originated the message.  Going further, now into the second case, a subtle behavior of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessengercontracts allows anyone not only to send messages via these contracts, but also to originate messages from them. The execution steps to originate an L2-to-L1 message from the OVM_L2CrossDomainMessenger would develop as follows:  A user-controlled account sends a message from layer 1 calling the sendMessage function of the OVM_L1CrossDomainMessengercontract. The target of this message should be the OVM_L2CrossDomainMessenger contract, and the message should be an abi-encoded call to the targets sendMessage function, including the arbitrary data the user wants the OVM_L2CrossDomainMessengercontract to send to layer 1.  The L1-to-L2 message sent by the user is enqueued in the Canonical Transaction Chain as a regular OVM transaction.  In layer 2, the relayMessage function of the OVM_L2CrossDomainMessenger contract is called to relay the users message. Following how the message was constructed, this will trigger a call from the OVM_L2CrossDomainMessenger contract to its own sendMessagefunction. In other words, the OVM_L2CrossDomainMessenger contract sends a message from L2 to L1 with target and data arbitrarily decided by the user in (1).  After the fraud proof window is over, the L2-to-L1 message sent by the OVM_L2CrossDomainMessenger contract is relayed in layer 1.  The target contract in layer 1 receives a message with the user-controlled data. Should the target address query the xDomainMessageSender function to inspect the address of the layer 2 account that originated the message, it would receive the address of the OVM_L2CrossDomainMessenger contract.  The actual consequences of the described behaviors will ultimately depend on the contracts receiving these arbitrary calls, and that is why we are only reporting this as an informative note. Developers should be fully aware of these scenarios and be ready to implement the necessary defensive measures to mitigate impact on their systems. We suggest the Optimism team to include specific developer-friendly documentation highlighting this note, so as to raise awareness of the subtleties of cross-domain communication.  [N19] Subtleties of calling contracts under construction and abstracted EOAs  In the EVM, calling accounts with no executable code (that is, contracts during construction or externally owned accounts) results in an immediate halt with a STOP opcode (see subsection 9.4 of the yellow paper), and the call is considered successful. In the OVM, this behavior is not exactly replicated, due to some fundamental differences between the EVM and the OVM.  Calling abstracted EOAs  The OVM offers native account abstraction. In other words, the only type of account is smart contracts, and the closest one can get to the behavior of EOAs is implemented in the OVM_ECDSAContractAccount contract. As a result, calling an EOA is translated to calling a specific instance of this contract, and any call that does not match the selector of the execute function will result in an out-of-gas error.  Calling contracts under construction  _callContract function of the  using the _getAccountEthAddress function. This results in a call to the  getAccountEthAddress function of the  first initialized as pending without setting its L1 address, then  created, and  finally committed. Therefore any address resolution before the account is committed will resolve to the zero address. The call to the zero address will be successful, and execution will simply continue. Off-chain services tracing the internal execution of fraud proof verifications might find this behavior relevant, as they will see a call to the zero address where they would have expected a call to a contract under construction.  It should be noted that both scenarios described were raised as issues of Medium severity in our November 2020 report as [M03] Call to contract in construction results in call to the zero address and [M04] Calls to abstracted EOA accounts may result in Out of Gas error. Taking into account that we did not receive specific feedback on those issues, and that the behavior of the system remains, we assume that the Optimism team has acknowledged these scenarios and consider them intended. Therefore, we are only describing them in this informative note for completeness, and to suggest explicitly documenting them either with inline comments, docstrings, external developer documentation or system specification if the Optimism team considers it appropriate.  [N20] Repeated authentication logic in State Manager  The isAuthenticated function of the OVM_StateManager contract can be used to validate whether a given address is allowed to write into the contracts state. The same functionality is implemented in the authenticated modifier.  To avoid code repetition, consider modifying the authenticated modifier so that it calls the isAuthenticated function to determine if the caller is authenticated. This note can be disregarded should the current implementation be more favorable in terms of gas costs.  [N21] Not using available bytes32 utilities  76,  86,  100 and  110 of  Lib_Bytes32Utils library.  [N22] Missing operations in Execution Manager wrapper library  The Lib_SafeExecutionManagerWrapper library offers functions to facilitate writing OVM safe code that can be compiled using the standard Solidity compiler. However, it is missing a number of wrappers for OVM operations, namely:  ovmCREATE2  ovmSTATICCALL  ovmEXTCODEHASH  ovmEXTCODECOPY  ovmL1TXORIGIN  ovmL1QUEUEORIGIN  ovmGASLIMIT  ovmNUMBER  ovmTIMESTAMP  Consider including wrapper functions for them in the Lib_SafeExecutionManagerWrapper library.  [N23] Unnecessary standalone contract to relay multiple messages  The OVM_L1MultiMessageRelayer contract implements a single function batchRelayMessages that forwards multiple cross-domain messages to the OVM_L1CrossDomainMessenger contract. To favor simplicity, this function could be moved to the OVM_L1CrossDomainMessenger contract (where it should be marked with the onlyRelayer modifier).  [N24] Data returned by relayed message i", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n01]-additional-issues", "labels": ["OpenZeppelin"]}, {"title": "During our audit, the Optimism team independently found a number of issues in the code base. We briefly include them below for completeness.", "body": "During our audit, the Optimism team independently found a number of issues in the code base. We briefly include them below for completeness.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#during-our-audit,-the-optimism-team-independently-found-a-number-of-issues-in-the-code-base.-we-briefly-include-them-below-for-completeness.", "labels": ["OpenZeppelin"]}, {"title": "The passMessageToL1 function of the OVM_L2ToL1MessagePasser contract is intended to be called by the OVM_L2CrossDomainMessenger, which validates the message sender and nonce before passing on the message. Although the function has no access controls, only messages sent from the OVM_L2ToL1MessagePasser can be relayed on layer 1. However, an attacker can use the L1-to-L2 message path to invoke the passMessageToL1 function from the OVM_L2CrossDomainMessenger with any parameters. This lets them send a message back up to L1 that bypasses the message sender and nonce validations. The Optimism team has indicated that they will remove the OVM_L2ToL1MessagePasser contract entirely, and use the sentMessages mapping in the OVM_L2CrossDomainMessenger instead.", "body": "The passMessageToL1 function of the OVM_L2ToL1MessagePasser contract is intended to be called by the OVM_L2CrossDomainMessenger, which validates the message sender and nonce before passing on the message. Although the function has no access controls, only messages sent from the OVM_L2ToL1MessagePasser can be relayed on layer 1. However, an attacker can use the L1-to-L2 message path to invoke the passMessageToL1 function from the OVM_L2CrossDomainMessenger with any parameters. This lets them send a message back up to L1 that bypasses the message sender and nonce validations. The Optimism team has indicated that they will remove the OVM_L2ToL1MessagePasser contract entirely, and use the sentMessages mapping in the OVM_L2CrossDomainMessenger instead.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-passmessagetol1-function-of-the-ovm_l2tol1messagepasser-contract-is-intended-to-be-called-by-the-ovm_l2crossdomainmessenger,-which-validates-the-message-sender-and-nonce-before-passing-on-the-message.-although-the-function-has-no-access-controls,-only-messages-sent-from-the-ovm_l2tol1messagepasser-can-be-relayed-on-layer-1.-however,-an-attacker-can-use-the-l1-to-l2-message-path-to-invoke-the-passmessagetol1-function-from-the-ovm_l2crossdomainmessenger-with-any-parameters.-this-lets-them-send-a-message-back-up-to-l1-that-bypasses-the-message-sender-and-nonce-validations.-the-optimism-team-has-indicated-that-they-will-remove-the-ovm_l2tol1messagepasser-contract-entirely,-and-use-the-sentmessages-mapping-in-the-ovm_l2crossdomainmessenger-instead.", "labels": ["OpenZeppelin"]}, {"title": "The logic in the _handleContractCreation function of the OVM_ExecutionManager contract allows deploying potentially unsafe code. While it does validate the runtime code deployed, the restriction is enforced after the code is already deployed, without reverting the state changes.", "body": "The logic in the _handleContractCreation function of the OVM_ExecutionManager contract allows deploying potentially unsafe code. While it does validate the runtime code deployed, the restriction is enforced after the code is already deployed, without reverting the state changes.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-logic-in-the-_handlecontractcreation-function-of-the-ovm_executionmanager-contract-allows-deploying-potentially-unsafe-code.-while-it-does-validate-the-runtime-code-deployed,-the-restriction-is-enforced-after-the-code-is-already-deployed,-without-reverting-the-state-changes.", "labels": ["OpenZeppelin"]}, {"title": "After running a legitimate fraud proof and reaching the post-execution state, the associated State Manager still considers the Execution Manager as \u201cauthenticated\u201d. This would allow further modifying state during post-execution.", "body": "After running a legitimate fraud proof and reaching the post-execution state, the associated State Manager still considers the Execution Manager as \u201cauthenticated\u201d. This would allow further modifying state during post-execution.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#after-running-a-legitimate-fraud-proof-and-reaching-the-post-execution-state,-the-associated-state-manager-still-considers-the-execution-manager-as-\u201cauthenticated\u201d.-this-would-allow-further-modifying-state-during-post-execution.", "labels": ["OpenZeppelin"]}, {"title": "An attacker can maliciously modify the context in which a fraud proof is run by first calling the run function of the OVM_ExecutionManager altering context-related variables (such as the isStatic flag), and then re-entering it during execution of a fraud proof.", "body": "An attacker can maliciously modify the context in which a fraud proof is run by first calling the run function of the OVM_ExecutionManager altering context-related variables (such as the isStatic flag), and then re-entering it during execution of a fraud proof.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#an-attacker-can-maliciously-modify-the-context-in-which-a-fraud-proof-is-run-by-first-calling-the-run-function-of-the-ovm_executionmanager-altering-context-related-variables-(such-as-the-isstatic-flag),-and-then-re-entering-it-during-execution-of-a-fraud-proof.", "labels": ["OpenZeppelin"]}, {"title": "Update: These issues were identified in the first audited commit. They are fixed in the latest audited commit. Note that instead of removing the OVM_L2ToL1MessagePasser contract, the first issue was addressed by recognizing and discarding L1-to-L2 cross domain messages directed at the OVM_L2ToL1MessagePasser contract.", "body": "Update: These issues were identified in the first audited commit. They are fixed in the latest audited commit. Note that instead of removing the OVM_L2ToL1MessagePasser contract, the first issue was addressed by recognizing and discarding L1-to-L2 cross domain messages directed at the OVM_L2ToL1MessagePasser contract.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#update:-these-issues-were-identified-in-the-first-audited-commit.-they-are-fixed-in-the-latest-audited-commit.-note-that-instead-of-removing-the-ovm_l2tol1messagepasser-contract,-the-first-issue-was-addressed-by-recognizing-and-discarding-l1-to-l2-cross-domain-messages-directed-at-the-ovm_l2tol1messagepasser-contract.", "labels": ["OpenZeppelin"]}, {"title": "[N02] Contracts do not compile with Solidity versions prior to 0.7", "body": "[N02] Contracts do not compile with Solidity versions prior to 0.7", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n02]-contracts-do-not-compile-with-solidity-versions-prior-to-0.7", "labels": ["OpenZeppelin"]}, {"title": "Contracts throughout the code base explicitly allow to be compiled with Solidity versions lower than 0.8 and greater than 0.5, by setting its pragma statement to pragma solidity >0.5.0 <0.8.0; (see for example the OVM_CanonicalTransactionChain contract). However, contracts that do not set explicit visibility in their constructors were only allowed starting in Solidity 0.7, meaning that it will not be possible to compile them with older versions.", "body": "Contracts throughout the code base explicitly allow to be compiled with Solidity versions lower than 0.8 and greater than 0.5, by setting its pragma statement to pragma solidity >0.5.0 <0.8.0; (see for example the OVM_CanonicalTransactionChain contract). However, contracts that do not set explicit visibility in their constructors were only allowed starting in Solidity 0.7, meaning that it will not be possible to compile them with older versions.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#contracts-throughout-the-code-base-explicitly-allow-to-be-compiled-with-solidity-versions-lower-than-0.8-and-greater-than-0.5,-by-setting-its-pragma-statement-to-pragma-solidity->0.5.0-<0.8.0;-(see-for-example-the-ovm_canonicaltransactionchain-contract).-however,-contracts-that-do-not-set-explicit-visibility-in-their-constructors-were-only-allowed-starting-in-solidity-0.7,-meaning-that-it-will-not-be-possible-to-compile-them-with-older-versions.", "labels": ["OpenZeppelin"]}, {"title": "Consider reviewing and updating the pragma statements of all contracts throughout the code base to ensure they can actually be compiled with the expected versions.", "body": "Consider reviewing and updating the pragma statements of all contracts throughout the code base to ensure they can actually be compiled with the expected versions.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#consider-reviewing-and-updating-the-pragma-statements-of-all-contracts-throughout-the-code-base-to-ensure-they-can-actually-be-compiled-with-the-expected-versions.", "labels": ["OpenZeppelin"]}, {"title": "[N03] Fragile default values in Merkle tree", "body": "[N03] Fragile default values in Merkle tree", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n03]-fragile-default-values-in-merkle-tree", "labels": ["OpenZeppelin"]}, {"title": "default values. These value are chosen to simulate the effect of padding the input", "body": "default values. These value are chosen to simulate the effect of padding the input", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#default-values.-these-value-are-chosen-to-simulate-the-effect-of-padding-the-input", "labels": ["OpenZeppelin"]}, {"title": "acceptable bound. This behavior is acknowledged,", "body": "acceptable bound. This behavior is acknowledged,", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#acceptable-bound.-this-behavior-is-acknowledged,", "labels": ["OpenZeppelin"]}, {"title": "noted in the function comments, and respected throughout the code base.", "body": "noted in the function comments, and respected throughout the code base.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#noted-in-the-function-comments,-and-respected-throughout-the-code-base.", "labels": ["OpenZeppelin"]}, {"title": "Nevertheless, we understand it would be more gas-efficient and easier to reason about if the default values were replaced with a constant value that provably has no known pre-image. Consider introducing this simplification.", "body": "Nevertheless, we understand it would be more gas-efficient and easier to reason about if the default values were replaced with a constant value that provably has no known pre-image. Consider introducing this simplification.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#nevertheless,-we-understand-it-would-be-more-gas-efficient-and-easier-to-reason-about-if-the-default-values-were-replaced-with-a-constant-value-that-provably-has-no-known-pre-image.-consider-introducing-this-simplification.", "labels": ["OpenZeppelin"]}, {"title": "[N04] Gas inefficiencies", "body": "[N04] Gas inefficiencies", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n04]-gas-inefficiencies", "labels": ["OpenZeppelin"]}, {"title": "This is a non-comprehensive list of simple gas inefficiencies detected as a side-product of the audit for the development team\u2019s consideration.", "body": "This is a non-comprehensive list of simple gas inefficiencies detected as a side-product of the audit for the development team\u2019s consideration.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#this-is-a-non-comprehensive-list-of-simple-gas-inefficiencies-detected-as-a-side-product-of-the-audit-for-the-development-team\u2019s-consideration.", "labels": ["OpenZeppelin"]}, {"title": "In the OVM_CanonicalTransactionChain contract:", "body": "Docstrings for the _getBatchExtraData function are missing two @return tags. Docstrings for the _getQueueElement function are missing the _queueRef parameter. Docstrings for the _getSequencerLeafHash function are missing the _hashMemory parameter.  In the iOVM_StateCommitmentChain interface:  Docstrings for the verifyStateCommitment function are missing a @return tag.  In the OVM_StateCommitmentChain contract:  Docstrings for the constructor are missing parameters _fraudProofWindow and _sequencerPublishWindow.  In the OVM_ExecutionManager contract:  Docstrings for the constructor are missing the _gasMeterConfig and _globalContext parameters. Docstrings for the simulateMessage function are missing the _ovmStateManager parameter and the returned values.  In all predeploy contracts, docstrings could include the address at which each contract will be found in Layer 2.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  [L07] Undocumented literal values  Throughout the code base, there are several instances of literal values with unexplained meaning. Moreover, some of them are not declared as constant state variables, which further hinders code readability. Literal values in the code base without an explained meaning make the code harder to read, understand and maintain, thus hindering the experience of developers, auditors and external contributors alike. Following we include a list of literal values that should be further documented and explained.  In OVM_ExecutionManager.sol:  Addresses in lines 545, 826 and 908.  Fixed gas discounts applied in line 391, line 430, line 580, line 614, and line 649.  Net gas costs applied in line 681 and line 707.  The value 100 on line 916.  In OVM_StateTransitioner.sol:  The number 100000 in line 341.  In OVM_L1CrossDomainMessenger.sol:  The number 0 in line 246.  The address 0x4200000000000000000000000000000000000000 in line 254.  The number 1 in line 270.  In Lib_MerkleTrie.sol:  The number 2 in lines 785 and 811 should be replaced with LEAF_OR_EXTENSION_NODE_LENGTH.  In OVM_CanonicalTransactionChain.sol:  The number 15 in line 627 should be replaced with BATCH_CONTEXT_START_POS.  Developers should define a constant variable for every literal value used, giving it a clear and self-explanatory name. Additionally, inline comments explaining how they were calculated or why they were chosen are highly recommended. Following Soliditys style guide, constants should be named in UPPER_CASE_WITH_UNDERSCORES format, and specific public getters should be defined to read each one of them if appropriate.  [L08] Unspecified behavior of OVM gas refund for revert flags  revert flags trigger a refund of OVM gas in the transaction being run. However, there are other flags such as  EXCEEDS_NUISANCE_GAS and  UNINITIALIZED_ACCESS which are not taken into account for gas refunds, their expected behavior being unspecified. The  is raised when there is not enough  nuisance gas to continue with transaction execution, while the  is raised when the  To better define the behavior of gas refunds in the OVM, consider specifying if and how gas refunds should be applied for the mentioned revert flags.  [L09] Nuisance gas proportional to code size is charged unnecessarily when changing an account  Within the _checkAccountChange function of the OVM_ExecutionManager contract, nuisance gas is charged proportional to the code size of the account. Since i) it can be assumed that the code deployed in the pre-execution phase of the fraud proof will not change, and ii) nuisance gas proportional to code size is already charged when initially loading an account for the first time, it appears unnecessary to charge nuisance gas again the first time the account (but not its code) is changed.  Consider removing the nuisance gas fee associated with contract code size within the _checkAccountChange function. Note that the solution to this issue might impact what is described in the informational note [N08] Minimum nuisance gas per contract creation is charged twice.  [L10] Unnecessary handling of single byte returned data  In the Lib_SafeExecutionManagerWrapper library, the internal _safeExecutionManagerInteraction function handles a case in which the returned data from a call to the OVM_ExecutionManager is a single byte. This code segment appears to be outdated, left over from an earlier version of the system, and it is no longer used.  Additionally, the ovmEXTCODECOPY function of the OVM_ExecutionManager contract introduces an artificial manipulation to avoid users inadvertently triggering this special case.  Consider removing both code segments to favor simplicity and avoid confusion.  [L11] Incorrect state transitioner index  When deploying a new OVM_StateTransitioner contract, the OVM_FraudVerifier contract incorrectly passes the index of the state root in its corresponding batch, confusing it with the state roots index in the State Commitment chain. The same mistake is made when emitting the FraudProofInitialized and FraudProofFinalized events.  Consider replacing these values with the index of the state root in the State Commitment chain.  [L12] Inconsistent and error-prone storage references in proxy contracts  There are three different proxy contracts implemented, all of them following a different approach when handling storage references.  The OVM_ProxySequencerEntrypoint contract stores the implementation and owner addresses in continuous storage slots at positions 0 and 1 (as can be seen in the internal getter and setter functions for these addresses). While this approach is certainly simple, it can be considered fragile and error-prone. In particular, any poorly constructed implementation that does not take into account the storage layout of the the proxy might accidentally cause a storage collision, and overwrite these two sensitive proxy variables. The problem is aggravated by the fact that the two state variables are not explicitly declared (and therefore visible) in the contracts state, but rather low-level ovmSSTORE and ovmSLOAD operations are performed to handle them.  The OVM_ProxyEOA contract stores the implementation address in the storage slot dictated by its IMPLEMENTATION_KEY constant, currently set to 0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead.  The Lib_ResolvedDelegateProxy contract does not follow either of the previous approaches. Instead, it uses private mappings in state to store two addresses corresponding to the Lib_AddressManager and implementation contracts, which is said to include a known flaw without providing further details.  For a more robust and consistent implementation of proxy contracts, consider always following standardized storage slots for relevant addresses in state. Refer to EIP 1967 for one possible approach. This should allow building common, reusable tooling to facilitate reliable inspection and interaction with all proxy contracts in the system.  [L13] Inconsistent key slicing when computing trie root  _getUpdatedTrieRoot function of the  iterates through the path, it consumes the corresponding parts of the key by slicing it depending on the type of each node found. Whenever a Leaf or Extension node is found, the key is reduced in size appropriately (see lines  509 and  513), regardless of whether the previous identified node is the last in the path. However, this is not the case for Branch nodes, where the key  is only sliced if the previous identified node is not the last in the path.  Consider consistently slicing the key when computing the root of Merkle tries.  [L14] Branch node modification in Merkle Trie may deviate from specification  The _editBranchIndex function of the Lib_MerkleTrie library does not RLP-encode values if their length is less than 32 bytes. This behavior does not appear to conform with the available specification for Merkle Trie. Consider either complying with the referenced specification, or alternatively document what specification was used for the implementation of the Lib_MerkleTrie library.  [L15] Unnecessary use of assembly  The getMerkleRoot function of the Lib_MerkleTree library uses assembly to pack elements before hashing them (see here and here). Consider using the globally available abi.encodePacked function instead.  The slice function of the Lib_BytesUtils library uses assembly to return a zero-length array. Consider replacing these lines simply returning the empty array tempBytes.  [L16] Incorrect parsing of booleans in RLP library  readBool function of the  false only if the provided value is 0. However, in  Geth  incorrectly revert. The flawed behavior can be reproduced by simply attempting to execute  Consider updating the implementation of the readBool function to check for the case that the input is 0x80 and return falseaccordingly. Alternatively, given that this function is never used, consider removing it from the code base.  [L17] Lookup key strings are not centrally defined  Known, legitimate contracts are tracked in the addresses mapping of the Lib_AddressManager contract. New entries can be added by a privileged address via the setAddress function, and the getAddress function function acts as a public getter to query the registry providing a string-type key. While this registry is used by several different contracts to get the addresses of registered contracts, the strings used as keys to query the registry are not centrally defined. The identified strings are:  \"OVM_L2MessageRelayer\"  \"OVM_L2BatchMessageRelayer\"  \"OVM_StateCommitmentChain\"  \"OVM_L2CrossDomainMessenger\"  \"OVM_CanonicalTransactionChain\"  \"Proxy__OVM_L1CrossDomainMessenger\"  \"OVM_L1MessageSender\"  \"OVM_L1CrossDomainMessenger\"  \"OVM_L2ToL1MessagePasser\"  \"OVM_ChainStorageContainer:CTC:batches\"  \"OVM_ChainStorageContainer:CTC:queue\"  \"OVM_Sequencer\"  \"OVM_ExecutionManager\"  \"OVM_DecompressionPrecompileAddress\"  \"OVM_ChainStorageContainer:SCC:batches\"  \"OVM_BondManager\"  \"OVM_StateCommitmentChain\"  \"OVM_CanonicalTransactionChain\"  \"OVM_FraudVerifier\"  \"OVM_Proposer\"  \"OVM_SafetyChecker\"  \"OVM_StateTransitionerFactory\"  While this issue does not pose an immediate security risk, the approach taken can be considered error-prone and difficult to maintain. Moreover, it is worth noting that the current code base has a number of inconsistencies in how these keys are referenced, as described in [N06] Inconsistent name resolution.  Consider factoring out all mentioned constant strings to a single library, which can be then imported as needed. This will ease maintenance and make the code more resilient to future changes.  [L18] Lack of allowance front-running mitigation in ERC20 contract  The UniswapV2ERC20 contract does not include the increaseAllowance and decreaseAllowance functions, nowadays common in most ERC20 interfaces to help mitigate the allowance frontrunning issue of the ERC20 standard.  While not strictly part of the ERC20 standard, consider including these two functions in the contracts interface.  [L19] Lack of event emissions  In the OVM_ProxySequencerEntrypoint contract, the upgrade function does not emit an event after a successful upgrade operation.  Consider emitting events after sensitive changes take place to facilitate tracking and notify off-chain clients following the contracts activity.  [L20] Deployment risks  The following contracts have a public initializer function:  OVM_L1CrossDomainMessenger  Abs_L2DepositedToken  OVM_L1ETHGateway  OVM_DeployerWhitelist  OVM_ProxySequencerEntrypoint  In all cases, the first account to invoke the initializer is not authenticated and can set sensitive parameters, which leaves them open to potential front-running attacks that could invalidate the contracts. We understand that this is particularly relevant for the token bridge contracts, because the Optimism team intends to provide a factory that programmatically creates the contracts and adds them to a registry, so if a particular token bridge is invalidated, it may not be recoverable.  One reason for this pattern is that contracts may have circular deployment dependencies, which means some contracts have to be deployed before their dependencies. Nevertheless, since contract addresses are created deterministically, it should still be possible to predict all addresses before the deployment, and pass them to the relevant constructors. Consider using this method where appropriate to mitigate the risk of front-running during initial configuration transactions. Alternatively, consider implementing access controls to the initializer functions.  Notes & Additional Information  [N01] Additional issues  During our audit, the Optimism team independently found a number of issues in the code base. We briefly include them below for completeness.  The passMessageToL1 function of the OVM_L2ToL1MessagePasser contract is intended to be called by the OVM_L2CrossDomainMessenger, which validates the message sender and nonce before passing on the message. Although the function has no access controls, only messages sent from the OVM_L2ToL1MessagePasser can be relayed on layer 1. However, an attacker can use the L1-to-L2 message path to invoke the passMessageToL1 function from the OVM_L2CrossDomainMessenger with any parameters. This lets them send a message back up to L1 that bypasses the message sender and nonce validations. The Optimism team has indicated that they will remove the OVM_L2ToL1MessagePasser contract entirely, and use the sentMessages mapping in the OVM_L2CrossDomainMessenger instead.  The logic in the _handleContractCreation function of the OVM_ExecutionManager contract allows deploying potentially unsafe code. While it does validate the runtime code deployed, the restriction is enforced after the code is already deployed, without reverting the state changes.  After running a legitimate fraud proof and reaching the post-execution state, the associated State Manager still considers the Execution Manager as authenticated. This would allow further modifying state during post-execution.  An attacker can maliciously modify the context in which a fraud proof is run by first calling the run function of the OVM_ExecutionManager altering context-related variables (such as the isStatic flag), and then re-entering it during execution of a fraud proof.  Update: These issues were identified in the first audited commit. They are fixed in the latest audited commit. Note that instead of removing the OVM_L2ToL1MessagePasser contract, the first issue was addressed by recognizing and discarding L1-to-L2 cross domain messages directed at the OVM_L2ToL1MessagePasser contract.  [N02] Contracts do not compile with Solidity versions prior to 0.7  Contracts throughout the code base explicitly allow to be compiled with Solidity versions lower than 0.8 and greater than 0.5, by setting its pragma statement to pragma solidity >0.5.0 <0.8.0; (see for example the OVM_CanonicalTransactionChain contract). However, contracts that do not set explicit visibility in their constructors were only allowed starting in Solidity 0.7, meaning that it will not be possible to compile them with older versions.  Consider reviewing and updating the pragma statements of all contracts throughout the code base to ensure they can actually be compiled with the expected versions.  [N03] Fragile default values in Merkle tree  default values. These value are chosen to simulate the effect of padding the input  acceptable bound. This behavior is acknowledged,  noted in the function comments, and respected throughout the code base.  Nevertheless, we understand it would be more gas-efficient and easier to reason about if the default values were replaced with a constant value that provably has no known pre-image. Consider introducing this simplification.  [N04] Gas inefficiencies  This is a non-comprehensive list of simple gas inefficiencies detected as a side-product of the audit for the development teams consideration.    The address of the Sequencer could be resolved before entering the loop to avoid unnecessary external calls during execution of the appendQueueBatch function. Similarly, the address referencing the queue should be resolved before entering the loop, then replacing the call to getQueueElement with _getQueueElement.  In the OVM_StateCommitmentChain contract:  The appendStateBatch function reads from storage the chains total elements twice (in lines 136 and 152) when it could do it once.  In the OVM_ExecutionManager contract:  The _createContract function reads from the messageContext.ovmADDRESS state variable three times, when it could do it just once at the beginning of the function.  In the OVM_L1ETHGateway contract:  The _safeTransferETH function of the OVM_L1ETHGateway contract uses a new bytes(0) object as a parameter when executing the call function. Using \"\" in place of new bytes(0) achieves the same effect and saves gas. Alternatively, consider entirely replacing the custom _safeTransferETH function with the sendValue function available in OpenZeppelin Contracts.  [N05] Incomplete override  The Abs_L1TokenGateway abstract contract has a default amount of gas that is sent with the cross-domain message. The intention is to allow descendant contracts to change this value as needed, but the current code base does not support this.  Consider marking the getFinalizeDepositL2Gas function as virtual so it can be overridden. Additionally, consider marking the default value as internal, so it is removed from the public API when it is no longer in use.  [N06] Inconsistent name resolution  There are a few inconsistent name resolutions throughout the code base:  The onlyRelayer modifier of the OVM_L1CrossDomainMessenger contract resolves the name OVM_L2MessageRelayer, which should point to the OVM_L1MultiMessageRelayer contract.  The OVM_L1MultiMessageRelayer and OVM_L1ETHGateway contracts resolve the name \"Proxy__OVM_L1CrossDomainMessenger\", while the OVM_L2CrossDomainMessenger contract resolves the name OVM_L1CrossDomainMessenger. Presumably, these point at the same address.  The name \"OVM_DecompressionPrecompileAddress\" should resolve to the address of the OVM_ProxySequencerEntrypoint contract.  The OVM_StateCommitmentChain contract resolves the name OVM_Proposer, but assigns it to a local variable called sequencer. This is because the sequencer and proposer are expected to be the same contract. However, in the interests of clarity, either the resolved name or the variable name should be modified for consistency (as suggested in the informational note [N31] Naming issues).  [N07] Inconsistent use of named return variables  Named return variables are used inconsistently. For example, while some functions in the OVM_CanonicalTransactionChain contract name their return variables, others do not. Consider removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This should improve both explicitness and readability of the project.  [N08] Minimum nuisance gas per contract creation is charged twice  The ovmCREATEEOA and safeCREATE functions, used for creating accounts in the OVM_ExecutionManager contract, follow a similar pattern to calculate nuisance gas:  Call the _initPendingAccount function (see lines 537 and 1098), which internally calls the _checkAccountLoad function, which in turn charges nuisance gas the first time the referenced account is loaded. Here, the amount of nuisance gas charged includes the minimum gas (dictated by the MIN_NUISANCE_GAS_PER_CONTRACT constant).  Call the _commitPendingAccount function (see lines 551 and 1125), which internally calls the _checkAccountChange function, which in turn charges nuisance gas the first time t", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-ovm_canonicaltransactionchain-contract:", "labels": ["OpenZeppelin"]}, {"title": "The address of the Sequencer could be resolved before entering the loop to avoid unnecessary external calls during execution of the appendQueueBatch function. Similarly, the address referencing the queue should be resolved before entering the loop, then replacing the call to getQueueElement with _getQueueElement.", "body": "The address of the Sequencer could be resolved before entering the loop to avoid unnecessary external calls during execution of the appendQueueBatch function. Similarly, the address referencing the queue should be resolved before entering the loop, then replacing the call to getQueueElement with _getQueueElement.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-address-of-the-sequencer-could-be-resolved-before-entering-the-loop-to-avoid-unnecessary-external-calls-during-execution-of-the-appendqueuebatch-function.-similarly,-the-address-referencing-the-queue-should-be-resolved-before-entering-the-loop,-then-replacing-the-call-to-getqueueelement-with-_getqueueelement.", "labels": ["OpenZeppelin"]}, {"title": "In the OVM_StateCommitmentChain contract:", "body": "The appendStateBatch function reads from storage the chains total elements twice (in lines 136 and 152) when it could do it once.  In the OVM_ExecutionManager contract:  The _createContract function reads from the messageContext.ovmADDRESS state variable three times, when it could do it just once at the beginning of the function.  In the OVM_L1ETHGateway contract:  The _safeTransferETH function of the OVM_L1ETHGateway contract uses a new bytes(0) object as a parameter when executing the call function. Using \"\" in place of new bytes(0) achieves the same effect and saves gas. Alternatively, consider entirely replacing the custom _safeTransferETH function with the sendValue function available in OpenZeppelin Contracts.  [N05] Incomplete override  The Abs_L1TokenGateway abstract contract has a default amount of gas that is sent with the cross-domain message. The intention is to allow descendant contracts to change this value as needed, but the current code base does not support this.  Consider marking the getFinalizeDepositL2Gas function as virtual so it can be overridden. Additionally, consider marking the default value as internal, so it is removed from the public API when it is no longer in use.  [N06] Inconsistent name resolution  There are a few inconsistent name resolutions throughout the code base:  The onlyRelayer modifier of the OVM_L1CrossDomainMessenger contract resolves the name OVM_L2MessageRelayer, which should point to the OVM_L1MultiMessageRelayer contract.  The OVM_L1MultiMessageRelayer and OVM_L1ETHGateway contracts resolve the name \"Proxy__OVM_L1CrossDomainMessenger\", while the OVM_L2CrossDomainMessenger contract resolves the name OVM_L1CrossDomainMessenger. Presumably, these point at the same address.  The name \"OVM_DecompressionPrecompileAddress\" should resolve to the address of the OVM_ProxySequencerEntrypoint contract.  The OVM_StateCommitmentChain contract resolves the name OVM_Proposer, but assigns it to a local variable called sequencer. This is because the sequencer and proposer are expected to be the same contract. However, in the interests of clarity, either the resolved name or the variable name should be modified for consistency (as suggested in the informational note [N31] Naming issues).  [N07] Inconsistent use of named return variables  Named return variables are used inconsistently. For example, while some functions in the OVM_CanonicalTransactionChain contract name their return variables, others do not. Consider removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This should improve both explicitness and readability of the project.  [N08] Minimum nuisance gas per contract creation is charged twice  The ovmCREATEEOA and safeCREATE functions, used for creating accounts in the OVM_ExecutionManager contract, follow a similar pattern to calculate nuisance gas:  Call the _initPendingAccount function (see lines 537 and 1098), which internally calls the _checkAccountLoad function, which in turn charges nuisance gas the first time the referenced account is loaded. Here, the amount of nuisance gas charged includes the minimum gas (dictated by the MIN_NUISANCE_GAS_PER_CONTRACT constant).  Call the _commitPendingAccount function (see lines 551 and 1125), which internally calls the _checkAccountChange function, which in turn charges nuisance gas the first time the referenced account is changed. Here, the amount of nuisance gas charged also includes MIN_NUISANCE_GAS_PER_CONTRACT (as in the first case).  This means that during account creation, the minimum amount of nuisance gas tracked in the MIN_NUISANCE_GAS_PER_CONTRACT constant is charged twice. This appears to be unnecessary since during fraud proof verification the code for the created account would only need to be provided once. Yet it could also be argued that in the fraud proof verification the pre-state of the empty account would need to be proved as well, and that is why the MIN_NUISANCE_GAS_PER_CONTRACT is charged twice.  To avoid confusions, consider explicitly specifying and documenting the intended behavior, including related unit tests if appropriate.  [N09] Redundant validations during state batch deletion  deleteStateBatch function of the  _isValidBatchHeader function, and after additional checks, it  executes the internal  checks that both the index and batch header are valid. Yet these last two validations are redundant, since as mentioned, the  already executed prior to the internal call to  To favor simplicity and gas-efficiency, consider removing these unnecessary validations.  [N10] Contract creation can revert upon failure  ovmCREATE and  ovmCREATE2 opcodes can revert during execution (instead of returning 0 upon failure as specified in the EVM). This is due to the fact that the code is validating the deployer is allowed at the beginning of the opcodes execution (see calls to the  here and  here), instead of doing it inside the  safeCREATE function, where similar validations are applied that do not result in a revert upon failure.  We are raising this peculiarity of the current version of the OVM as an informative note for completeness, since we understand that the development team is fully aware of this undocumented behavioral difference with EVM, and is planning to fix it by removing the deployer whitelist in the short term. Should that not be the case, consider this note of higher priority and explicitly document the described behavior in external documentation to raise user awareness.  [N11] Typographical errors  In Lib_MerkleTree.sol:  In line 117, sibline should say sibling.  In Lib_MerkleTrie.sol:  In line 275, 31 should say 32.  In Lib_Math.sol:  In line 14, minumum should say minimum.  In iOVM_ChainStorageContainer.sol:  In line 104, meaing should say meaning.  In OVM_CanonicalTransactionChain.sol:  In line 344, minnet should say mainnet.  In line 973, que should say queue.  In line 1011, elemtent should say element.  In OVM_CrossDomainEnabled.sol:  In line 14, recieve should say receive.  In OVM_L2ToL1MessagePasser.sol:  In line 9, facilitates is misspelled. It also includes the repeated phrase of the.  In Abs_L1TokenGateway.sol:  In line 128, recipients is misspelled.  In OVM_L1ERC20Gateway.sol:  In line 18, takes should say take.  In OVM_ExecutionManager.sol:  In line 168, awlways should say always.  In lines 191, 202, 213, and 1701, minnet should say mainnet.  In lines 1804, 1809, 1814, unnecessary the SSTORE should say the unnecessary SSTORE.  In OVM_ECDSAContract.sol:  In lines 142, transfer is misspelled.  In OVM_FraudVerifier.sol:  In line 210, minnet should say mainnet.  In Lib_RLPReader.sol:  In lines 384 and 410, a address should say an address.  [N12] Negative overflow of uint256 type  To favor readability, in line 1890 of OVM_ExecutionManager.sol consider replacing the negative overflow operation of an uint256 value with the expression type(uint256).max.  [N13] Unnecessary return statement  Consider removing the return keyword from the setGlobalMetadata function of the OVM_ChainStorageContainer contract, as the setExtraData function of the Lib_RingBuffer library being called does not return any value.  [N14] Unused imports  To improve readability and avoid confusion, consider removing the following unused imports.  In the OVM_StateCommitmentChain contract, the iOVM_FraudVerifier interface.  In the OVM_ExecutionManager contract, the OVM_ECDSAContractAccount and OVM_DeployerWhitelist contracts.  In the OVM_L2DepositedERC20 contract, the iOVM_L1TokenGateway interface.  In the OVM_ETH contract, the Lib_AddressResolver contract.  In the OVM_StateTransitioner contract, the iOVM_BondManager interface.  In the Lib_OVMCodec library, the Lib_BytesUtils library.  [N15] Unused events  The iOVM_L2ToL1MessagePasser interface defines the L2ToL1Message event, which is never emitted in the child contract OVM_L2ToL1MessagePasser.  To avoid confusion and favor simplicity, consider removing all definitions of events that are not expected to be emitted.  [N16] Unused functions  Functions toUint24, toUint8 and toAddress of the Lib_BytesUtils library are never used, and can therefore be removed.  [N17] Transaction hashes might not be unique in the Canonical Transaction Chain  The enqueue function of the OVM_CanonicalTransactionChain contract constructs transaction hashes with the callers address, the L2 target, the transactions gas limit and its data. Since this is not enough to ensure uniqueness of hashes (that is, it could be possible to construct two transactions that result in the same hash), these transactions are instead identified by their position in the queue. However, this internal subtlety of the Canonical Transaction Chain is not explicitly documented, and might lead to errors in off-chain services tracking transactions in the Canonical Transaction Chain, since transaction hashes are commonly assumed to be unique.  Consider including developer-friendly documentation stating how transaction hashes in the Canonical Transaction Chain are constructed, and how they should not be relied on to uniquely identify transactions.  [N18] Cross-domain messengers can be impersonated  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts allow relaying arbitrary cross-domain messages. Ultimately, this means that it is possible for anyone to make these contracts execute arbitrary calls (see calls hereand here). Therefore, there are two scenarios developers should consider when building and integrating bridges between layer 1 and 2. Aiming for simplicity, in the following we explain both scenarios starting on layer 1  yet a similar behavior can be seen in the opposite direction.  call any target address with arbitrary data. Therefore, layer 2 accounts should be aware that they can receive arbitrary calls from the  ERC1820Registry contract. It must be noted that during the call from the  xDomainMessageSender functionto inspect the address of the layer 1 account that originated the message.  Going further, now into the second case, a subtle behavior of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessengercontracts allows anyone not only to send messages via these contracts, but also to originate messages from them. The execution steps to originate an L2-to-L1 message from the OVM_L2CrossDomainMessenger would develop as follows:  A user-controlled account sends a message from layer 1 calling the sendMessage function of the OVM_L1CrossDomainMessengercontract. The target of this message should be the OVM_L2CrossDomainMessenger contract, and the message should be an abi-encoded call to the targets sendMessage function, including the arbitrary data the user wants the OVM_L2CrossDomainMessengercontract to send to layer 1.  The L1-to-L2 message sent by the user is enqueued in the Canonical Transaction Chain as a regular OVM transaction.  In layer 2, the relayMessage function of the OVM_L2CrossDomainMessenger contract is called to relay the users message. Following how the message was constructed, this will trigger a call from the OVM_L2CrossDomainMessenger contract to its own sendMessagefunction. In other words, the OVM_L2CrossDomainMessenger contract sends a message from L2 to L1 with target and data arbitrarily decided by the user in (1).  After the fraud proof window is over, the L2-to-L1 message sent by the OVM_L2CrossDomainMessenger contract is relayed in layer 1.  The target contract in layer 1 receives a message with the user-controlled data. Should the target address query the xDomainMessageSender function to inspect the address of the layer 2 account that originated the message, it would receive the address of the OVM_L2CrossDomainMessenger contract.  The actual consequences of the described behaviors will ultimately depend on the contracts receiving these arbitrary calls, and that is why we are only reporting this as an informative note. Developers should be fully aware of these scenarios and be ready to implement the necessary defensive measures to mitigate impact on their systems. We suggest the Optimism team to include specific developer-friendly documentation highlighting this note, so as to raise awareness of the subtleties of cross-domain communication.  [N19] Subtleties of calling contracts under construction and abstracted EOAs  In the EVM, calling accounts with no executable code (that is, contracts during construction or externally owned accounts) results in an immediate halt with a STOP opcode (see subsection 9.4 of the yellow paper), and the call is considered successful. In the OVM, this behavior is not exactly replicated, due to some fundamental differences between the EVM and the OVM.  Calling abstracted EOAs  The OVM offers native account abstraction. In other words, the only type of account is smart contracts, and the closest one can get to the behavior of EOAs is implemented in the OVM_ECDSAContractAccount contract. As a result, calling an EOA is translated to calling a specific instance of this contract, and any call that does not match the selector of the execute function will result in an out-of-gas error.  Calling contracts under construction  _callContract function of the  using the _getAccountEthAddress function. This results in a call to the  getAccountEthAddress function of the  first initialized as pending without setting its L1 address, then  created, and  finally committed. Therefore any address resolution before the account is committed will resolve to the zero address. The call to the zero address will be successful, and execution will simply continue. Off-chain services tracing the internal execution of fraud proof verifications might find this behavior relevant, as they will see a call to the zero address where they would have expected a call to a contract under construction.  It should be noted that both scenarios described were raised as issues of Medium severity in our November 2020 report as [M03] Call to contract in construction results in call to the zero address and [M04] Calls to abstracted EOA accounts may result in Out of Gas error. Taking into account that we did not receive specific feedback on those issues, and that the behavior of the system remains, we assume that the Optimism team has acknowledged these scenarios and consider them intended. Therefore, we are only describing them in this informative note for completeness, and to suggest explicitly documenting them either with inline comments, docstrings, external developer documentation or system specification if the Optimism team considers it appropriate.  [N20] Repeated authentication logic in State Manager  The isAuthenticated function of the OVM_StateManager contract can be used to validate whether a given address is allowed to write into the contracts state. The same functionality is implemented in the authenticated modifier.  To avoid code repetition, consider modifying the authenticated modifier so that it calls the isAuthenticated function to determine if the caller is authenticated. This note can be disregarded should the current implementation be more favorable in terms of gas costs.  [N21] Not using available bytes32 utilities  76,  86,  100 and  110 of  Lib_Bytes32Utils library.  [N22] Missing operations in Execution Manager wrapper library  The Lib_SafeExecutionManagerWrapper library offers functions to facilitate writing OVM safe code that can be compiled using the standard Solidity compiler. However, it is missing a number of wrappers for OVM operations, namely:  ovmCREATE2  ovmSTATICCALL  ovmEXTCODEHASH  ovmEXTCODECOPY  ovmL1TXORIGIN  ovmL1QUEUEORIGIN  ovmGASLIMIT  ovmNUMBER  ovmTIMESTAMP  Consider including wrapper functions for them in the Lib_SafeExecutionManagerWrapper library.  [N23] Unnecessary standalone contract to relay multiple messages  The OVM_L1MultiMessageRelayer contract implements a single function batchRelayMessages that forwards multiple cross-domain messages to the OVM_L1CrossDomainMessenger contract. To favor simplicity, this function could be moved to the OVM_L1CrossDomainMessenger contract (where it should be marked with the onlyRelayer modifier).  [N24] Data returned by relayed message is ignored  relayMessage function of the  ovmCALL to the messages target. While the calls success flag is  validated to determine whether the message can be considered successful, the returned data is never stored nor logged. As a consequence, relevant returned data from relayed messages will not be accessible after a message is relayed. The described behavior also occurs in the  relayMessage function of the  Should this be the intended behavior of the relayMessage functions, consider documenting it in the functions docstrings. Otherwise, consider including a mechanism to retrieve the returned data of relayed messages, which could include storing the data in storage, or logging it using an event.  [N25] Duplicated code in cross-domain messenger contracts  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts behave in a similar way and share a non-trivial amount of duplicated logic.  To reduce code duplication and favor reusability, consider abstracting away repeated logic to an internal function of the Abs_BaseCrossDomainMessenger parent contract.  [N26] Duplicated code for memory copy utility  The _copy function of the Lib_RLPReader library and _memcpy function of the Lib_RLPWriter serve a similar purpose: copying pieces of memory to other locations. To reduce duplicated logic and ease maintenance, consider defining a single memory copy utility function, and reusing it throughout the code base. Alternatively, to favor a simpler implementation, consider using the identity precompile contract at address 0x0000000000000000000000000000000000000004 to copy pieces of memory.  [N27] Redundant check when proving contract state  proveContractState function of the  two conditions. The first condition,  hasAccount, checks whether  the accounts code hash is non-zero. The second condition,  hasEmptyAccount, checks that  the accounts code hash matches the EMPTY_ACCOUNT_CODE_HASH hash.  Since the EMPTY_ACCOUNT_CODE_HASH is non-zero, the second condition implies the first one. Therefore, consider removing the call to hasAccount.  [N28] Base contract not marked as abstract  Contracts that are not intended to be instantiated directly, such as OVM_CrossDomainEnabled, should be marked as abstract to favor readability and avoid unintended usage.  [N29] Inconsistent coding style  Some instances of inconsistent coding style were identified in the code base. Specifically:  While most internal and private functions explicitly denote their visibility by prepending their names with an underscore, functions getCrossDomainMessenger and sendCrossDomainMessage of the OVM_CrossDomainEnabled contract fail to do so.  To favor readability, consider always following a consistent style throughout the code base. We suggest using Soliditys Style Guide as a reference.  [N30] Lack of explicit visibility in state variables  The following state variables and constants are implicitly using the default visibility.  In the OVM_ECDSAContractAccount contract:  The EXECUTION_VALIDATION_GAS_OVERHEAD and ETH_ERC20_ADDRESS constants.  In the OVM_ProxyEOA contract:  The IMPLEMENTATION_KEY constant.  In the Abs_L2DepositedToken contract:  The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant  To favor readability, consider explicitly declaring the visibility of all state variables and constants.  [N31] Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.  The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.  In the _appendBatch function, a local variable", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-ovm_statecommitmentchain-contract:", "labels": ["OpenZeppelin"]}, {"title": "The appendStateBatch function reads from storage the chain\u2019s total elements twice (in lines 136 and 152) when it could do it once.", "body": "The appendStateBatch function reads from storage the chain\u2019s total elements twice (in lines 136 and 152) when it could do it once.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-appendstatebatch-function-reads-from-storage-the-chain\u2019s-total-elements-twice-(in-lines-136-and-152)-when-it-could-do-it-once.", "labels": ["OpenZeppelin"]}, {"title": "In the OVM_ExecutionManager contract:", "body": "Docstrings for the constructor are missing the _gasMeterConfig and _globalContext parameters. Docstrings for the simulateMessage function are missing the _ovmStateManager parameter and the returned values.  In all predeploy contracts, docstrings could include the address at which each contract will be found in Layer 2.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  [L07] Undocumented literal values  Throughout the code base, there are several instances of literal values with unexplained meaning. Moreover, some of them are not declared as constant state variables, which further hinders code readability. Literal values in the code base without an explained meaning make the code harder to read, understand and maintain, thus hindering the experience of developers, auditors and external contributors alike. Following we include a list of literal values that should be further documented and explained.  In OVM_ExecutionManager.sol:  Addresses in lines 545, 826 and 908.  Fixed gas discounts applied in line 391, line 430, line 580, line 614, and line 649.  Net gas costs applied in line 681 and line 707.  The value 100 on line 916.  In OVM_StateTransitioner.sol:  The number 100000 in line 341.  In OVM_L1CrossDomainMessenger.sol:  The number 0 in line 246.  The address 0x4200000000000000000000000000000000000000 in line 254.  The number 1 in line 270.  In Lib_MerkleTrie.sol:  The number 2 in lines 785 and 811 should be replaced with LEAF_OR_EXTENSION_NODE_LENGTH.  In OVM_CanonicalTransactionChain.sol:  The number 15 in line 627 should be replaced with BATCH_CONTEXT_START_POS.  Developers should define a constant variable for every literal value used, giving it a clear and self-explanatory name. Additionally, inline comments explaining how they were calculated or why they were chosen are highly recommended. Following Soliditys style guide, constants should be named in UPPER_CASE_WITH_UNDERSCORES format, and specific public getters should be defined to read each one of them if appropriate.  [L08] Unspecified behavior of OVM gas refund for revert flags  revert flags trigger a refund of OVM gas in the transaction being run. However, there are other flags such as  EXCEEDS_NUISANCE_GAS and  UNINITIALIZED_ACCESS which are not taken into account for gas refunds, their expected behavior being unspecified. The  is raised when there is not enough  nuisance gas to continue with transaction execution, while the  is raised when the  To better define the behavior of gas refunds in the OVM, consider specifying if and how gas refunds should be applied for the mentioned revert flags.  [L09] Nuisance gas proportional to code size is charged unnecessarily when changing an account  Within the _checkAccountChange function of the OVM_ExecutionManager contract, nuisance gas is charged proportional to the code size of the account. Since i) it can be assumed that the code deployed in the pre-execution phase of the fraud proof will not change, and ii) nuisance gas proportional to code size is already charged when initially loading an account for the first time, it appears unnecessary to charge nuisance gas again the first time the account (but not its code) is changed.  Consider removing the nuisance gas fee associated with contract code size within the _checkAccountChange function. Note that the solution to this issue might impact what is described in the informational note [N08] Minimum nuisance gas per contract creation is charged twice.  [L10] Unnecessary handling of single byte returned data  In the Lib_SafeExecutionManagerWrapper library, the internal _safeExecutionManagerInteraction function handles a case in which the returned data from a call to the OVM_ExecutionManager is a single byte. This code segment appears to be outdated, left over from an earlier version of the system, and it is no longer used.  Additionally, the ovmEXTCODECOPY function of the OVM_ExecutionManager contract introduces an artificial manipulation to avoid users inadvertently triggering this special case.  Consider removing both code segments to favor simplicity and avoid confusion.  [L11] Incorrect state transitioner index  When deploying a new OVM_StateTransitioner contract, the OVM_FraudVerifier contract incorrectly passes the index of the state root in its corresponding batch, confusing it with the state roots index in the State Commitment chain. The same mistake is made when emitting the FraudProofInitialized and FraudProofFinalized events.  Consider replacing these values with the index of the state root in the State Commitment chain.  [L12] Inconsistent and error-prone storage references in proxy contracts  There are three different proxy contracts implemented, all of them following a different approach when handling storage references.  The OVM_ProxySequencerEntrypoint contract stores the implementation and owner addresses in continuous storage slots at positions 0 and 1 (as can be seen in the internal getter and setter functions for these addresses). While this approach is certainly simple, it can be considered fragile and error-prone. In particular, any poorly constructed implementation that does not take into account the storage layout of the the proxy might accidentally cause a storage collision, and overwrite these two sensitive proxy variables. The problem is aggravated by the fact that the two state variables are not explicitly declared (and therefore visible) in the contracts state, but rather low-level ovmSSTORE and ovmSLOAD operations are performed to handle them.  The OVM_ProxyEOA contract stores the implementation address in the storage slot dictated by its IMPLEMENTATION_KEY constant, currently set to 0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead.  The Lib_ResolvedDelegateProxy contract does not follow either of the previous approaches. Instead, it uses private mappings in state to store two addresses corresponding to the Lib_AddressManager and implementation contracts, which is said to include a known flaw without providing further details.  For a more robust and consistent implementation of proxy contracts, consider always following standardized storage slots for relevant addresses in state. Refer to EIP 1967 for one possible approach. This should allow building common, reusable tooling to facilitate reliable inspection and interaction with all proxy contracts in the system.  [L13] Inconsistent key slicing when computing trie root  _getUpdatedTrieRoot function of the  iterates through the path, it consumes the corresponding parts of the key by slicing it depending on the type of each node found. Whenever a Leaf or Extension node is found, the key is reduced in size appropriately (see lines  509 and  513), regardless of whether the previous identified node is the last in the path. However, this is not the case for Branch nodes, where the key  is only sliced if the previous identified node is not the last in the path.  Consider consistently slicing the key when computing the root of Merkle tries.  [L14] Branch node modification in Merkle Trie may deviate from specification  The _editBranchIndex function of the Lib_MerkleTrie library does not RLP-encode values if their length is less than 32 bytes. This behavior does not appear to conform with the available specification for Merkle Trie. Consider either complying with the referenced specification, or alternatively document what specification was used for the implementation of the Lib_MerkleTrie library.  [L15] Unnecessary use of assembly  The getMerkleRoot function of the Lib_MerkleTree library uses assembly to pack elements before hashing them (see here and here). Consider using the globally available abi.encodePacked function instead.  The slice function of the Lib_BytesUtils library uses assembly to return a zero-length array. Consider replacing these lines simply returning the empty array tempBytes.  [L16] Incorrect parsing of booleans in RLP library  readBool function of the  false only if the provided value is 0. However, in  Geth  incorrectly revert. The flawed behavior can be reproduced by simply attempting to execute  Consider updating the implementation of the readBool function to check for the case that the input is 0x80 and return falseaccordingly. Alternatively, given that this function is never used, consider removing it from the code base.  [L17] Lookup key strings are not centrally defined  Known, legitimate contracts are tracked in the addresses mapping of the Lib_AddressManager contract. New entries can be added by a privileged address via the setAddress function, and the getAddress function function acts as a public getter to query the registry providing a string-type key. While this registry is used by several different contracts to get the addresses of registered contracts, the strings used as keys to query the registry are not centrally defined. The identified strings are:  \"OVM_L2MessageRelayer\"  \"OVM_L2BatchMessageRelayer\"  \"OVM_StateCommitmentChain\"  \"OVM_L2CrossDomainMessenger\"  \"OVM_CanonicalTransactionChain\"  \"Proxy__OVM_L1CrossDomainMessenger\"  \"OVM_L1MessageSender\"  \"OVM_L1CrossDomainMessenger\"  \"OVM_L2ToL1MessagePasser\"  \"OVM_ChainStorageContainer:CTC:batches\"  \"OVM_ChainStorageContainer:CTC:queue\"  \"OVM_Sequencer\"  \"OVM_ExecutionManager\"  \"OVM_DecompressionPrecompileAddress\"  \"OVM_ChainStorageContainer:SCC:batches\"  \"OVM_BondManager\"  \"OVM_StateCommitmentChain\"  \"OVM_CanonicalTransactionChain\"  \"OVM_FraudVerifier\"  \"OVM_Proposer\"  \"OVM_SafetyChecker\"  \"OVM_StateTransitionerFactory\"  While this issue does not pose an immediate security risk, the approach taken can be considered error-prone and difficult to maintain. Moreover, it is worth noting that the current code base has a number of inconsistencies in how these keys are referenced, as described in [N06] Inconsistent name resolution.  Consider factoring out all mentioned constant strings to a single library, which can be then imported as needed. This will ease maintenance and make the code more resilient to future changes.  [L18] Lack of allowance front-running mitigation in ERC20 contract  The UniswapV2ERC20 contract does not include the increaseAllowance and decreaseAllowance functions, nowadays common in most ERC20 interfaces to help mitigate the allowance frontrunning issue of the ERC20 standard.  While not strictly part of the ERC20 standard, consider including these two functions in the contracts interface.  [L19] Lack of event emissions  In the OVM_ProxySequencerEntrypoint contract, the upgrade function does not emit an event after a successful upgrade operation.  Consider emitting events after sensitive changes take place to facilitate tracking and notify off-chain clients following the contracts activity.  [L20] Deployment risks  The following contracts have a public initializer function:  OVM_L1CrossDomainMessenger  Abs_L2DepositedToken  OVM_L1ETHGateway  OVM_DeployerWhitelist  OVM_ProxySequencerEntrypoint  In all cases, the first account to invoke the initializer is not authenticated and can set sensitive parameters, which leaves them open to potential front-running attacks that could invalidate the contracts. We understand that this is particularly relevant for the token bridge contracts, because the Optimism team intends to provide a factory that programmatically creates the contracts and adds them to a registry, so if a particular token bridge is invalidated, it may not be recoverable.  One reason for this pattern is that contracts may have circular deployment dependencies, which means some contracts have to be deployed before their dependencies. Nevertheless, since contract addresses are created deterministically, it should still be possible to predict all addresses before the deployment, and pass them to the relevant constructors. Consider using this method where appropriate to mitigate the risk of front-running during initial configuration transactions. Alternatively, consider implementing access controls to the initializer functions.  Notes & Additional Information  [N01] Additional issues  During our audit, the Optimism team independently found a number of issues in the code base. We briefly include them below for completeness.  The passMessageToL1 function of the OVM_L2ToL1MessagePasser contract is intended to be called by the OVM_L2CrossDomainMessenger, which validates the message sender and nonce before passing on the message. Although the function has no access controls, only messages sent from the OVM_L2ToL1MessagePasser can be relayed on layer 1. However, an attacker can use the L1-to-L2 message path to invoke the passMessageToL1 function from the OVM_L2CrossDomainMessenger with any parameters. This lets them send a message back up to L1 that bypasses the message sender and nonce validations. The Optimism team has indicated that they will remove the OVM_L2ToL1MessagePasser contract entirely, and use the sentMessages mapping in the OVM_L2CrossDomainMessenger instead.  The logic in the _handleContractCreation function of the OVM_ExecutionManager contract allows deploying potentially unsafe code. While it does validate the runtime code deployed, the restriction is enforced after the code is already deployed, without reverting the state changes.  After running a legitimate fraud proof and reaching the post-execution state, the associated State Manager still considers the Execution Manager as authenticated. This would allow further modifying state during post-execution.  An attacker can maliciously modify the context in which a fraud proof is run by first calling the run function of the OVM_ExecutionManager altering context-related variables (such as the isStatic flag), and then re-entering it during execution of a fraud proof.  Update: These issues were identified in the first audited commit. They are fixed in the latest audited commit. Note that instead of removing the OVM_L2ToL1MessagePasser contract, the first issue was addressed by recognizing and discarding L1-to-L2 cross domain messages directed at the OVM_L2ToL1MessagePasser contract.  [N02] Contracts do not compile with Solidity versions prior to 0.7  Contracts throughout the code base explicitly allow to be compiled with Solidity versions lower than 0.8 and greater than 0.5, by setting its pragma statement to pragma solidity >0.5.0 <0.8.0; (see for example the OVM_CanonicalTransactionChain contract). However, contracts that do not set explicit visibility in their constructors were only allowed starting in Solidity 0.7, meaning that it will not be possible to compile them with older versions.  Consider reviewing and updating the pragma statements of all contracts throughout the code base to ensure they can actually be compiled with the expected versions.  [N03] Fragile default values in Merkle tree  default values. These value are chosen to simulate the effect of padding the input  acceptable bound. This behavior is acknowledged,  noted in the function comments, and respected throughout the code base.  Nevertheless, we understand it would be more gas-efficient and easier to reason about if the default values were replaced with a constant value that provably has no known pre-image. Consider introducing this simplification.  [N04] Gas inefficiencies  This is a non-comprehensive list of simple gas inefficiencies detected as a side-product of the audit for the development teams consideration.  In the OVM_CanonicalTransactionChain contract:  The address of the Sequencer could be resolved before entering the loop to avoid unnecessary external calls during execution of the appendQueueBatch function. Similarly, the address referencing the queue should be resolved before entering the loop, then replacing the call to getQueueElement with _getQueueElement.  In the OVM_StateCommitmentChain contract:  The appendStateBatch function reads from storage the chains total elements twice (in lines 136 and 152) when it could do it once.    The _createContract function reads from the messageContext.ovmADDRESS state variable three times, when it could do it just once at the beginning of the function.  In the OVM_L1ETHGateway contract:  The _safeTransferETH function of the OVM_L1ETHGateway contract uses a new bytes(0) object as a parameter when executing the call function. Using \"\" in place of new bytes(0) achieves the same effect and saves gas. Alternatively, consider entirely replacing the custom _safeTransferETH function with the sendValue function available in OpenZeppelin Contracts.  [N05] Incomplete override  The Abs_L1TokenGateway abstract contract has a default amount of gas that is sent with the cross-domain message. The intention is to allow descendant contracts to change this value as needed, but the current code base does not support this.  Consider marking the getFinalizeDepositL2Gas function as virtual so it can be overridden. Additionally, consider marking the default value as internal, so it is removed from the public API when it is no longer in use.  [N06] Inconsistent name resolution  There are a few inconsistent name resolutions throughout the code base:  The onlyRelayer modifier of the OVM_L1CrossDomainMessenger contract resolves the name OVM_L2MessageRelayer, which should point to the OVM_L1MultiMessageRelayer contract.  The OVM_L1MultiMessageRelayer and OVM_L1ETHGateway contracts resolve the name \"Proxy__OVM_L1CrossDomainMessenger\", while the OVM_L2CrossDomainMessenger contract resolves the name OVM_L1CrossDomainMessenger. Presumably, these point at the same address.  The name \"OVM_DecompressionPrecompileAddress\" should resolve to the address of the OVM_ProxySequencerEntrypoint contract.  The OVM_StateCommitmentChain contract resolves the name OVM_Proposer, but assigns it to a local variable called sequencer. This is because the sequencer and proposer are expected to be the same contract. However, in the interests of clarity, either the resolved name or the variable name should be modified for consistency (as suggested in the informational note [N31] Naming issues).  [N07] Inconsistent use of named return variables  Named return variables are used inconsistently. For example, while some functions in the OVM_CanonicalTransactionChain contract name their return variables, others do not. Consider removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This should improve both explicitness and readability of the project.  [N08] Minimum nuisance gas per contract creation is charged twice  The ovmCREATEEOA and safeCREATE functions, used for creating accounts in the OVM_ExecutionManager contract, follow a similar pattern to calculate nuisance gas:  Call the _initPendingAccount function (see lines 537 and 1098), which internally calls the _checkAccountLoad function, which in turn charges nuisance gas the first time the referenced account is loaded. Here, the amount of nuisance gas charged includes the minimum gas (dictated by the MIN_NUISANCE_GAS_PER_CONTRACT constant).  Call the _commitPendingAccount function (see lines 551 and 1125), which internally calls the _checkAccountChange function, which in turn charges nuisance gas the first time the referenced account is changed. Here, the amount of nuisance gas charged also includes MIN_NUISANCE_GAS_PER_CONTRACT (as in the first case).  This means that during account creation, the minimum amount of nuisance gas tracked in the MIN_NUISANCE_GAS_PER_CONTRACT constant is charged twice. This appears to be unnecessary since during fraud proof verification the code for the created account would only need to be provided once. Yet it could also be argued that in the fraud proof verification the pre-state of the empty account would need to be", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-ovm_executionmanager-contract:", "labels": ["OpenZeppelin"]}, {"title": "The _createContract function reads from the messageContext.ovmADDRESS state variable three times, when it could do it just once at the beginning of the function.", "body": "The _createContract function reads from the messageContext.ovmADDRESS state variable three times, when it could do it just once at the beginning of the function.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-_createcontract-function-reads-from-the-messagecontext.ovmaddress-state-variable-three-times,-when-it-could-do-it-just-once-at-the-beginning-of-the-function.", "labels": ["OpenZeppelin"]}, {"title": "In the OVM_L1ETHGateway contract:", "body": "In the OVM_L1ETHGateway contract:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-ovm_l1ethgateway-contract:", "labels": ["OpenZeppelin"]}, {"title": "The _safeTransferETH function of the OVM_L1ETHGateway contract uses a new bytes(0) object as a parameter when executing the call function. Using \"\" in place of new bytes(0) achieves the same effect and saves gas. Alternatively, consider entirely replacing the custom _safeTransferETH function with the sendValue function available in OpenZeppelin Contracts.", "body": "The _safeTransferETH function of the OVM_L1ETHGateway contract uses a new bytes(0) object as a parameter when executing the call function. Using \"\" in place of new bytes(0) achieves the same effect and saves gas. Alternatively, consider entirely replacing the custom _safeTransferETH function with the sendValue function available in OpenZeppelin Contracts.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-_safetransfereth-function-of-the-ovm_l1ethgateway-contract-uses-a-new-bytes(0)-object-as-a-parameter-when-executing-the-call-function.-using-\"\"-in-place-of-new-bytes(0)-achieves-the-same-effect-and-saves-gas.-alternatively,-consider-entirely-replacing-the-custom-_safetransfereth-function-with-the-sendvalue-function-available-in-openzeppelin-contracts.", "labels": ["OpenZeppelin"]}, {"title": "[N05] Incomplete override", "body": "[N05] Incomplete override", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n05]-incomplete-override", "labels": ["OpenZeppelin"]}, {"title": "The Abs_L1TokenGateway abstract contract has a default amount of gas that is sent with the cross-domain message. The intention is to allow descendant contracts to change this value as needed, but the current code base does not support this.", "body": "The Abs_L1TokenGateway abstract contract has a default amount of gas that is sent with the cross-domain message. The intention is to allow descendant contracts to change this value as needed, but the current code base does not support this.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-abs_l1tokengateway-abstract-contract-has-a-default-amount-of-gas-that-is-sent-with-the-cross-domain-message.-the-intention-is-to-allow-descendant-contracts-to-change-this-value-as-needed,-but-the-current-code-base-does-not-support-this.", "labels": ["OpenZeppelin"]}, {"title": "Consider marking the getFinalizeDepositL2Gas function as virtual so it can be overridden. Additionally, consider marking the default value as internal, so it is removed from the public API when it is no longer in use.", "body": "Consider marking the getFinalizeDepositL2Gas function as virtual so it can be overridden. Additionally, consider marking the default value as internal, so it is removed from the public API when it is no longer in use.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#consider-marking-the-getfinalizedepositl2gas-function-as-virtual-so-it-can-be-overridden.-additionally,-consider-marking-the-default-value-as-internal,-so-it-is-removed-from-the-public-api-when-it-is-no-longer-in-use.", "labels": ["OpenZeppelin"]}, {"title": "[N06] Inconsistent name resolution", "body": "There are a few inconsistent name resolutions throughout the code base:  The onlyRelayer modifier of the OVM_L1CrossDomainMessenger contract resolves the name OVM_L2MessageRelayer, which should point to the OVM_L1MultiMessageRelayer contract.  The OVM_L1MultiMessageRelayer and OVM_L1ETHGateway contracts resolve the name \"Proxy__OVM_L1CrossDomainMessenger\", while the OVM_L2CrossDomainMessenger contract resolves the name OVM_L1CrossDomainMessenger. Presumably, these point at the same address.  The name \"OVM_DecompressionPrecompileAddress\" should resolve to the address of the OVM_ProxySequencerEntrypoint contract.  The OVM_StateCommitmentChain contract resolves the name OVM_Proposer, but assigns it to a local variable called sequencer. This is because the sequencer and proposer are expected to be the same contract. However, in the interests of clarity, either the resolved name or the variable name should be modified for consistency (as suggested in the informational note [N31] Naming issues).  [N07] Inconsistent use of named return variables  Named return variables are used inconsistently. For example, while some functions in the OVM_CanonicalTransactionChain contract name their return variables, others do not. Consider removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This should improve both explicitness and readability of the project.  [N08] Minimum nuisance gas per contract creation is charged twice  The ovmCREATEEOA and safeCREATE functions, used for creating accounts in the OVM_ExecutionManager contract, follow a similar pattern to calculate nuisance gas:  Call the _initPendingAccount function (see lines 537 and 1098), which internally calls the _checkAccountLoad function, which in turn charges nuisance gas the first time the referenced account is loaded. Here, the amount of nuisance gas charged includes the minimum gas (dictated by the MIN_NUISANCE_GAS_PER_CONTRACT constant).  Call the _commitPendingAccount function (see lines 551 and 1125), which internally calls the _checkAccountChange function, which in turn charges nuisance gas the first time the referenced account is changed. Here, the amount of nuisance gas charged also includes MIN_NUISANCE_GAS_PER_CONTRACT (as in the first case).  This means that during account creation, the minimum amount of nuisance gas tracked in the MIN_NUISANCE_GAS_PER_CONTRACT constant is charged twice. This appears to be unnecessary since during fraud proof verification the code for the created account would only need to be provided once. Yet it could also be argued that in the fraud proof verification the pre-state of the empty account would need to be proved as well, and that is why the MIN_NUISANCE_GAS_PER_CONTRACT is charged twice.  To avoid confusions, consider explicitly specifying and documenting the intended behavior, including related unit tests if appropriate.  [N09] Redundant validations during state batch deletion  deleteStateBatch function of the  _isValidBatchHeader function, and after additional checks, it  executes the internal  checks that both the index and batch header are valid. Yet these last two validations are redundant, since as mentioned, the  already executed prior to the internal call to  To favor simplicity and gas-efficiency, consider removing these unnecessary validations.  [N10] Contract creation can revert upon failure  ovmCREATE and  ovmCREATE2 opcodes can revert during execution (instead of returning 0 upon failure as specified in the EVM). This is due to the fact that the code is validating the deployer is allowed at the beginning of the opcodes execution (see calls to the  here and  here), instead of doing it inside the  safeCREATE function, where similar validations are applied that do not result in a revert upon failure.  We are raising this peculiarity of the current version of the OVM as an informative note for completeness, since we understand that the development team is fully aware of this undocumented behavioral difference with EVM, and is planning to fix it by removing the deployer whitelist in the short term. Should that not be the case, consider this note of higher priority and explicitly document the described behavior in external documentation to raise user awareness.  [N11] Typographical errors  In Lib_MerkleTree.sol:  In line 117, sibline should say sibling.  In Lib_MerkleTrie.sol:  In line 275, 31 should say 32.  In Lib_Math.sol:  In line 14, minumum should say minimum.  In iOVM_ChainStorageContainer.sol:  In line 104, meaing should say meaning.  In OVM_CanonicalTransactionChain.sol:  In line 344, minnet should say mainnet.  In line 973, que should say queue.  In line 1011, elemtent should say element.  In OVM_CrossDomainEnabled.sol:  In line 14, recieve should say receive.  In OVM_L2ToL1MessagePasser.sol:  In line 9, facilitates is misspelled. It also includes the repeated phrase of the.  In Abs_L1TokenGateway.sol:  In line 128, recipients is misspelled.  In OVM_L1ERC20Gateway.sol:  In line 18, takes should say take.  In OVM_ExecutionManager.sol:  In line 168, awlways should say always.  In lines 191, 202, 213, and 1701, minnet should say mainnet.  In lines 1804, 1809, 1814, unnecessary the SSTORE should say the unnecessary SSTORE.  In OVM_ECDSAContract.sol:  In lines 142, transfer is misspelled.  In OVM_FraudVerifier.sol:  In line 210, minnet should say mainnet.  In Lib_RLPReader.sol:  In lines 384 and 410, a address should say an address.  [N12] Negative overflow of uint256 type  To favor readability, in line 1890 of OVM_ExecutionManager.sol consider replacing the negative overflow operation of an uint256 value with the expression type(uint256).max.  [N13] Unnecessary return statement  Consider removing the return keyword from the setGlobalMetadata function of the OVM_ChainStorageContainer contract, as the setExtraData function of the Lib_RingBuffer library being called does not return any value.  [N14] Unused imports  To improve readability and avoid confusion, consider removing the following unused imports.  In the OVM_StateCommitmentChain contract, the iOVM_FraudVerifier interface.  In the OVM_ExecutionManager contract, the OVM_ECDSAContractAccount and OVM_DeployerWhitelist contracts.  In the OVM_L2DepositedERC20 contract, the iOVM_L1TokenGateway interface.  In the OVM_ETH contract, the Lib_AddressResolver contract.  In the OVM_StateTransitioner contract, the iOVM_BondManager interface.  In the Lib_OVMCodec library, the Lib_BytesUtils library.  [N15] Unused events  The iOVM_L2ToL1MessagePasser interface defines the L2ToL1Message event, which is never emitted in the child contract OVM_L2ToL1MessagePasser.  To avoid confusion and favor simplicity, consider removing all definitions of events that are not expected to be emitted.  [N16] Unused functions  Functions toUint24, toUint8 and toAddress of the Lib_BytesUtils library are never used, and can therefore be removed.  [N17] Transaction hashes might not be unique in the Canonical Transaction Chain  The enqueue function of the OVM_CanonicalTransactionChain contract constructs transaction hashes with the callers address, the L2 target, the transactions gas limit and its data. Since this is not enough to ensure uniqueness of hashes (that is, it could be possible to construct two transactions that result in the same hash), these transactions are instead identified by their position in the queue. However, this internal subtlety of the Canonical Transaction Chain is not explicitly documented, and might lead to errors in off-chain services tracking transactions in the Canonical Transaction Chain, since transaction hashes are commonly assumed to be unique.  Consider including developer-friendly documentation stating how transaction hashes in the Canonical Transaction Chain are constructed, and how they should not be relied on to uniquely identify transactions.  [N18] Cross-domain messengers can be impersonated  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts allow relaying arbitrary cross-domain messages. Ultimately, this means that it is possible for anyone to make these contracts execute arbitrary calls (see calls hereand here). Therefore, there are two scenarios developers should consider when building and integrating bridges between layer 1 and 2. Aiming for simplicity, in the following we explain both scenarios starting on layer 1  yet a similar behavior can be seen in the opposite direction.  call any target address with arbitrary data. Therefore, layer 2 accounts should be aware that they can receive arbitrary calls from the  ERC1820Registry contract. It must be noted that during the call from the  xDomainMessageSender functionto inspect the address of the layer 1 account that originated the message.  Going further, now into the second case, a subtle behavior of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessengercontracts allows anyone not only to send messages via these contracts, but also to originate messages from them. The execution steps to originate an L2-to-L1 message from the OVM_L2CrossDomainMessenger would develop as follows:  A user-controlled account sends a message from layer 1 calling the sendMessage function of the OVM_L1CrossDomainMessengercontract. The target of this message should be the OVM_L2CrossDomainMessenger contract, and the message should be an abi-encoded call to the targets sendMessage function, including the arbitrary data the user wants the OVM_L2CrossDomainMessengercontract to send to layer 1.  The L1-to-L2 message sent by the user is enqueued in the Canonical Transaction Chain as a regular OVM transaction.  In layer 2, the relayMessage function of the OVM_L2CrossDomainMessenger contract is called to relay the users message. Following how the message was constructed, this will trigger a call from the OVM_L2CrossDomainMessenger contract to its own sendMessagefunction. In other words, the OVM_L2CrossDomainMessenger contract sends a message from L2 to L1 with target and data arbitrarily decided by the user in (1).  After the fraud proof window is over, the L2-to-L1 message sent by the OVM_L2CrossDomainMessenger contract is relayed in layer 1.  The target contract in layer 1 receives a message with the user-controlled data. Should the target address query the xDomainMessageSender function to inspect the address of the layer 2 account that originated the message, it would receive the address of the OVM_L2CrossDomainMessenger contract.  The actual consequences of the described behaviors will ultimately depend on the contracts receiving these arbitrary calls, and that is why we are only reporting this as an informative note. Developers should be fully aware of these scenarios and be ready to implement the necessary defensive measures to mitigate impact on their systems. We suggest the Optimism team to include specific developer-friendly documentation highlighting this note, so as to raise awareness of the subtleties of cross-domain communication.  [N19] Subtleties of calling contracts under construction and abstracted EOAs  In the EVM, calling accounts with no executable code (that is, contracts during construction or externally owned accounts) results in an immediate halt with a STOP opcode (see subsection 9.4 of the yellow paper), and the call is considered successful. In the OVM, this behavior is not exactly replicated, due to some fundamental differences between the EVM and the OVM.  Calling abstracted EOAs  The OVM offers native account abstraction. In other words, the only type of account is smart contracts, and the closest one can get to the behavior of EOAs is implemented in the OVM_ECDSAContractAccount contract. As a result, calling an EOA is translated to calling a specific instance of this contract, and any call that does not match the selector of the execute function will result in an out-of-gas error.  Calling contracts under construction  _callContract function of the  using the _getAccountEthAddress function. This results in a call to the  getAccountEthAddress function of the  first initialized as pending without setting its L1 address, then  created, and  finally committed. Therefore any address resolution before the account is committed will resolve to the zero address. The call to the zero address will be successful, and execution will simply continue. Off-chain services tracing the internal execution of fraud proof verifications might find this behavior relevant, as they will see a call to the zero address where they would have expected a call to a contract under construction.  It should be noted that both scenarios described were raised as issues of Medium severity in our November 2020 report as [M03] Call to contract in construction results in call to the zero address and [M04] Calls to abstracted EOA accounts may result in Out of Gas error. Taking into account that we did not receive specific feedback on those issues, and that the behavior of the system remains, we assume that the Optimism team has acknowledged these scenarios and consider them intended. Therefore, we are only describing them in this informative note for completeness, and to suggest explicitly documenting them either with inline comments, docstrings, external developer documentation or system specification if the Optimism team considers it appropriate.  [N20] Repeated authentication logic in State Manager  The isAuthenticated function of the OVM_StateManager contract can be used to validate whether a given address is allowed to write into the contracts state. The same functionality is implemented in the authenticated modifier.  To avoid code repetition, consider modifying the authenticated modifier so that it calls the isAuthenticated function to determine if the caller is authenticated. This note can be disregarded should the current implementation be more favorable in terms of gas costs.  [N21] Not using available bytes32 utilities  76,  86,  100 and  110 of  Lib_Bytes32Utils library.  [N22] Missing operations in Execution Manager wrapper library  The Lib_SafeExecutionManagerWrapper library offers functions to facilitate writing OVM safe code that can be compiled using the standard Solidity compiler. However, it is missing a number of wrappers for OVM operations, namely:  ovmCREATE2  ovmSTATICCALL  ovmEXTCODEHASH  ovmEXTCODECOPY  ovmL1TXORIGIN  ovmL1QUEUEORIGIN  ovmGASLIMIT  ovmNUMBER  ovmTIMESTAMP  Consider including wrapper functions for them in the Lib_SafeExecutionManagerWrapper library.  [N23] Unnecessary standalone contract to relay multiple messages  The OVM_L1MultiMessageRelayer contract implements a single function batchRelayMessages that forwards multiple cross-domain messages to the OVM_L1CrossDomainMessenger contract. To favor simplicity, this function could be moved to the OVM_L1CrossDomainMessenger contract (where it should be marked with the onlyRelayer modifier).  [N24] Data returned by relayed message is ignored  relayMessage function of the  ovmCALL to the messages target. While the calls success flag is  validated to determine whether the message can be considered successful, the returned data is never stored nor logged. As a consequence, relevant returned data from relayed messages will not be accessible after a message is relayed. The described behavior also occurs in the  relayMessage function of the  Should this be the intended behavior of the relayMessage functions, consider documenting it in the functions docstrings. Otherwise, consider including a mechanism to retrieve the returned data of relayed messages, which could include storing the data in storage, or logging it using an event.  [N25] Duplicated code in cross-domain messenger contracts  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts behave in a similar way and share a non-trivial amount of duplicated logic.  To reduce code duplication and favor reusability, consider abstracting away repeated logic to an internal function of the Abs_BaseCrossDomainMessenger parent contract.  [N26] Duplicated code for memory copy utility  The _copy function of the Lib_RLPReader library and _memcpy function of the Lib_RLPWriter serve a similar purpose: copying pieces of memory to other locations. To reduce duplicated logic and ease maintenance, consider defining a single memory copy utility function, and reusing it throughout the code base. Alternatively, to favor a simpler implementation, consider using the identity precompile contract at address 0x0000000000000000000000000000000000000004 to copy pieces of memory.  [N27] Redundant check when proving contract state  proveContractState function of the  two conditions. The first condition,  hasAccount, checks whether  the accounts code hash is non-zero. The second condition,  hasEmptyAccount, checks that  the accounts code hash matches the EMPTY_ACCOUNT_CODE_HASH hash.  Since the EMPTY_ACCOUNT_CODE_HASH is non-zero, the second condition implies the first one. Therefore, consider removing the call to hasAccount.  [N28] Base contract not marked as abstract  Contracts that are not intended to be instantiated directly, such as OVM_CrossDomainEnabled, should be marked as abstract to favor readability and avoid unintended usage.  [N29] Inconsistent coding style  Some instances of inconsistent coding style were identified in the code base. Specifically:  While most internal and private functions explicitly denote their visibility by prepending their names with an underscore, functions getCrossDomainMessenger and sendCrossDomainMessage of the OVM_CrossDomainEnabled contract fail to do so.  To favor readability, consider always following a consistent style throughout the code base. We suggest using Soliditys Style Guide as a reference.  [N30] Lack of explicit visibility in state variables  The following state variables and constants are implicitly using the default visibility.  In the OVM_ECDSAContractAccount contract:  The EXECUTION_VALIDATION_GAS_OVERHEAD and ETH_ERC20_ADDRESS constants.  In the OVM_ProxyEOA contract:  The IMPLEMENTATION_KEY constant.  In the Abs_L2DepositedToken contract:  The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant  To favor readability, consider explicitly declaring the visibility of all state variables and constants.  [N31] Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.  The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.  In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.  [N32] Implicit casting operations  The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when its passed to the call to _sendXDomainMessage.  The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transactions nonce matches the expected one.  For added readability, consider making casting operations explicit where possible.  Conclusions  4 critical and 4 high severity issues were found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n06]-inconsistent-name-resolution", "labels": ["OpenZeppelin"]}, {"title": "There are a few inconsistent name resolutions throughout the code base:", "body": "There are a few inconsistent name resolutions throughout the code base:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#there-are-a-few-inconsistent-name-resolutions-throughout-the-code-base:", "labels": ["OpenZeppelin"]}, {"title": "The onlyRelayer modifier of the OVM_L1CrossDomainMessenger contract resolves the name \u201cOVM_L2MessageRelayer\u201d, which should point to the OVM_L1MultiMessageRelayer contract.", "body": "The onlyRelayer modifier of the OVM_L1CrossDomainMessenger contract resolves the name \u201cOVM_L2MessageRelayer\u201d, which should point to the OVM_L1MultiMessageRelayer contract.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-onlyrelayer-modifier-of-the-ovm_l1crossdomainmessenger-contract-resolves-the-name-\u201covm_l2messagerelayer\u201d,-which-should-point-to-the-ovm_l1multimessagerelayer-contract.", "labels": ["OpenZeppelin"]}, {"title": "The OVM_L1MultiMessageRelayer and OVM_L1ETHGateway contracts resolve the name \"Proxy__OVM_L1CrossDomainMessenger\", while the OVM_L2CrossDomainMessenger contract resolves the name \u201cOVM_L1CrossDomainMessenger\u201d. Presumably, these point at the same address.", "body": "The OVM_L1MultiMessageRelayer and OVM_L1ETHGateway contracts resolve the name \"Proxy__OVM_L1CrossDomainMessenger\", while the OVM_L2CrossDomainMessenger contract resolves the name \u201cOVM_L1CrossDomainMessenger\u201d. Presumably, these point at the same address.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-ovm_l1multimessagerelayer-and-ovm_l1ethgateway-contracts-resolve-the-name-\"proxy__ovm_l1crossdomainmessenger\",-while-the-ovm_l2crossdomainmessenger-contract-resolves-the-name-\u201covm_l1crossdomainmessenger\u201d.-presumably,-these-point-at-the-same-address.", "labels": ["OpenZeppelin"]}, {"title": "The name \"OVM_DecompressionPrecompileAddress\" should resolve to the address of the OVM_ProxySequencerEntrypoint contract.", "body": "The name \"OVM_DecompressionPrecompileAddress\" should resolve to the address of the OVM_ProxySequencerEntrypoint contract.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-name-\"ovm_decompressionprecompileaddress\"-should-resolve-to-the-address-of-the-ovm_proxysequencerentrypoint-contract.", "labels": ["OpenZeppelin"]}, {"title": "The OVM_StateCommitmentChain contract resolves the name \u201cOVM_Proposer\u201d, but assigns it to a local variable called sequencer. This is because the sequencer and proposer are expected to be the same contract. However, in the interests of clarity, either the resolved name or the variable name should be modified for consistency (as suggested in the informational note \u201c[N31] Naming issues\u201d).", "body": "The OVM_StateCommitmentChain contract resolves the name \u201cOVM_Proposer\u201d, but assigns it to a local variable called sequencer. This is because the sequencer and proposer are expected to be the same contract. However, in the interests of clarity, either the resolved name or the variable name should be modified for consistency (as suggested in the informational note \u201c[N31] Naming issues\u201d).", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-ovm_statecommitmentchain-contract-resolves-the-name-\u201covm_proposer\u201d,-but-assigns-it-to-a-local-variable-called-sequencer.-this-is-because-the-sequencer-and-proposer-are-expected-to-be-the-same-contract.-however,-in-the-interests-of-clarity,-either-the-resolved-name-or-the-variable-name-should-be-modified-for-consistency-(as-suggested-in-the-informational-note-\u201c[n31]-naming-issues\u201d).", "labels": ["OpenZeppelin"]}, {"title": "[N07] Inconsistent use of named return variables", "body": "[N07] Inconsistent use of named return variables", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n07]-inconsistent-use-of-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Named return variables are used inconsistently. For example, while some functions in the OVM_CanonicalTransactionChain contract name their return variables, others do not. Consider removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This should improve both explicitness and readability of the project.", "body": "Named return variables are used inconsistently. For example, while some functions in the OVM_CanonicalTransactionChain contract name their return variables, others do not. Consider removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This should improve both explicitness and readability of the project.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#named-return-variables-are-used-inconsistently.-for-example,-while-some-functions-in-the-ovm_canonicaltransactionchain-contract-name-their-return-variables,-others-do-not.-consider-removing-all-named-return-variables,-explicitly-declaring-them-as-local-variables,-and-adding-the-necessary-return-statements-where-appropriate.-this-should-improve-both-explicitness-and-readability-of-the-project.", "labels": ["OpenZeppelin"]}, {"title": "[N08] Minimum nuisance gas per contract creation is charged twice", "body": "The ovmCREATEEOA and safeCREATE functions, used for creating accounts in the OVM_ExecutionManager contract, follow a similar pattern to calculate nuisance gas:  Call the _initPendingAccount function (see lines 537 and 1098), which internally calls the _checkAccountLoad function, which in turn charges nuisance gas the first time the referenced account is loaded. Here, the amount of nuisance gas charged includes the minimum gas (dictated by the MIN_NUISANCE_GAS_PER_CONTRACT constant).  Call the _commitPendingAccount function (see lines 551 and 1125), which internally calls the _checkAccountChange function, which in turn charges nuisance gas the first time the referenced account is changed. Here, the amount of nuisance gas charged also includes MIN_NUISANCE_GAS_PER_CONTRACT (as in the first case).  This means that during account creation, the minimum amount of nuisance gas tracked in the MIN_NUISANCE_GAS_PER_CONTRACT constant is charged twice. This appears to be unnecessary since during fraud proof verification the code for the created account would only need to be provided once. Yet it could also be argued that in the fraud proof verification the pre-state of the empty account would need to be proved as well, and that is why the MIN_NUISANCE_GAS_PER_CONTRACT is charged twice.  To avoid confusions, consider explicitly specifying and documenting the intended behavior, including related unit tests if appropriate.  [N09] Redundant validations during state batch deletion  deleteStateBatch function of the  _isValidBatchHeader function, and after additional checks, it  executes the internal  checks that both the index and batch header are valid. Yet these last two validations are redundant, since as mentioned, the  already executed prior to the internal call to  To favor simplicity and gas-efficiency, consider removing these unnecessary validations.  [N10] Contract creation can revert upon failure  ovmCREATE and  ovmCREATE2 opcodes can revert during execution (instead of returning 0 upon failure as specified in the EVM). This is due to the fact that the code is validating the deployer is allowed at the beginning of the opcodes execution (see calls to the  here and  here), instead of doing it inside the  safeCREATE function, where similar validations are applied that do not result in a revert upon failure.  We are raising this peculiarity of the current version of the OVM as an informative note for completeness, since we understand that the development team is fully aware of this undocumented behavioral difference with EVM, and is planning to fix it by removing the deployer whitelist in the short term. Should that not be the case, consider this note of higher priority and explicitly document the described behavior in external documentation to raise user awareness.  [N11] Typographical errors  In Lib_MerkleTree.sol:  In line 117, sibline should say sibling.  In Lib_MerkleTrie.sol:  In line 275, 31 should say 32.  In Lib_Math.sol:  In line 14, minumum should say minimum.  In iOVM_ChainStorageContainer.sol:  In line 104, meaing should say meaning.  In OVM_CanonicalTransactionChain.sol:  In line 344, minnet should say mainnet.  In line 973, que should say queue.  In line 1011, elemtent should say element.  In OVM_CrossDomainEnabled.sol:  In line 14, recieve should say receive.  In OVM_L2ToL1MessagePasser.sol:  In line 9, facilitates is misspelled. It also includes the repeated phrase of the.  In Abs_L1TokenGateway.sol:  In line 128, recipients is misspelled.  In OVM_L1ERC20Gateway.sol:  In line 18, takes should say take.  In OVM_ExecutionManager.sol:  In line 168, awlways should say always.  In lines 191, 202, 213, and 1701, minnet should say mainnet.  In lines 1804, 1809, 1814, unnecessary the SSTORE should say the unnecessary SSTORE.  In OVM_ECDSAContract.sol:  In lines 142, transfer is misspelled.  In OVM_FraudVerifier.sol:  In line 210, minnet should say mainnet.  In Lib_RLPReader.sol:  In lines 384 and 410, a address should say an address.  [N12] Negative overflow of uint256 type  To favor readability, in line 1890 of OVM_ExecutionManager.sol consider replacing the negative overflow operation of an uint256 value with the expression type(uint256).max.  [N13] Unnecessary return statement  Consider removing the return keyword from the setGlobalMetadata function of the OVM_ChainStorageContainer contract, as the setExtraData function of the Lib_RingBuffer library being called does not return any value.  [N14] Unused imports  To improve readability and avoid confusion, consider removing the following unused imports.  In the OVM_StateCommitmentChain contract, the iOVM_FraudVerifier interface.  In the OVM_ExecutionManager contract, the OVM_ECDSAContractAccount and OVM_DeployerWhitelist contracts.  In the OVM_L2DepositedERC20 contract, the iOVM_L1TokenGateway interface.  In the OVM_ETH contract, the Lib_AddressResolver contract.  In the OVM_StateTransitioner contract, the iOVM_BondManager interface.  In the Lib_OVMCodec library, the Lib_BytesUtils library.  [N15] Unused events  The iOVM_L2ToL1MessagePasser interface defines the L2ToL1Message event, which is never emitted in the child contract OVM_L2ToL1MessagePasser.  To avoid confusion and favor simplicity, consider removing all definitions of events that are not expected to be emitted.  [N16] Unused functions  Functions toUint24, toUint8 and toAddress of the Lib_BytesUtils library are never used, and can therefore be removed.  [N17] Transaction hashes might not be unique in the Canonical Transaction Chain  The enqueue function of the OVM_CanonicalTransactionChain contract constructs transaction hashes with the callers address, the L2 target, the transactions gas limit and its data. Since this is not enough to ensure uniqueness of hashes (that is, it could be possible to construct two transactions that result in the same hash), these transactions are instead identified by their position in the queue. However, this internal subtlety of the Canonical Transaction Chain is not explicitly documented, and might lead to errors in off-chain services tracking transactions in the Canonical Transaction Chain, since transaction hashes are commonly assumed to be unique.  Consider including developer-friendly documentation stating how transaction hashes in the Canonical Transaction Chain are constructed, and how they should not be relied on to uniquely identify transactions.  [N18] Cross-domain messengers can be impersonated  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts allow relaying arbitrary cross-domain messages. Ultimately, this means that it is possible for anyone to make these contracts execute arbitrary calls (see calls hereand here). Therefore, there are two scenarios developers should consider when building and integrating bridges between layer 1 and 2. Aiming for simplicity, in the following we explain both scenarios starting on layer 1  yet a similar behavior can be seen in the opposite direction.  call any target address with arbitrary data. Therefore, layer 2 accounts should be aware that they can receive arbitrary calls from the  ERC1820Registry contract. It must be noted that during the call from the  xDomainMessageSender functionto inspect the address of the layer 1 account that originated the message.  Going further, now into the second case, a subtle behavior of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessengercontracts allows anyone not only to send messages via these contracts, but also to originate messages from them. The execution steps to originate an L2-to-L1 message from the OVM_L2CrossDomainMessenger would develop as follows:  A user-controlled account sends a message from layer 1 calling the sendMessage function of the OVM_L1CrossDomainMessengercontract. The target of this message should be the OVM_L2CrossDomainMessenger contract, and the message should be an abi-encoded call to the targets sendMessage function, including the arbitrary data the user wants the OVM_L2CrossDomainMessengercontract to send to layer 1.  The L1-to-L2 message sent by the user is enqueued in the Canonical Transaction Chain as a regular OVM transaction.  In layer 2, the relayMessage function of the OVM_L2CrossDomainMessenger contract is called to relay the users message. Following how the message was constructed, this will trigger a call from the OVM_L2CrossDomainMessenger contract to its own sendMessagefunction. In other words, the OVM_L2CrossDomainMessenger contract sends a message from L2 to L1 with target and data arbitrarily decided by the user in (1).  After the fraud proof window is over, the L2-to-L1 message sent by the OVM_L2CrossDomainMessenger contract is relayed in layer 1.  The target contract in layer 1 receives a message with the user-controlled data. Should the target address query the xDomainMessageSender function to inspect the address of the layer 2 account that originated the message, it would receive the address of the OVM_L2CrossDomainMessenger contract.  The actual consequences of the described behaviors will ultimately depend on the contracts receiving these arbitrary calls, and that is why we are only reporting this as an informative note. Developers should be fully aware of these scenarios and be ready to implement the necessary defensive measures to mitigate impact on their systems. We suggest the Optimism team to include specific developer-friendly documentation highlighting this note, so as to raise awareness of the subtleties of cross-domain communication.  [N19] Subtleties of calling contracts under construction and abstracted EOAs  In the EVM, calling accounts with no executable code (that is, contracts during construction or externally owned accounts) results in an immediate halt with a STOP opcode (see subsection 9.4 of the yellow paper), and the call is considered successful. In the OVM, this behavior is not exactly replicated, due to some fundamental differences between the EVM and the OVM.  Calling abstracted EOAs  The OVM offers native account abstraction. In other words, the only type of account is smart contracts, and the closest one can get to the behavior of EOAs is implemented in the OVM_ECDSAContractAccount contract. As a result, calling an EOA is translated to calling a specific instance of this contract, and any call that does not match the selector of the execute function will result in an out-of-gas error.  Calling contracts under construction  _callContract function of the  using the _getAccountEthAddress function. This results in a call to the  getAccountEthAddress function of the  first initialized as pending without setting its L1 address, then  created, and  finally committed. Therefore any address resolution before the account is committed will resolve to the zero address. The call to the zero address will be successful, and execution will simply continue. Off-chain services tracing the internal execution of fraud proof verifications might find this behavior relevant, as they will see a call to the zero address where they would have expected a call to a contract under construction.  It should be noted that both scenarios described were raised as issues of Medium severity in our November 2020 report as [M03] Call to contract in construction results in call to the zero address and [M04] Calls to abstracted EOA accounts may result in Out of Gas error. Taking into account that we did not receive specific feedback on those issues, and that the behavior of the system remains, we assume that the Optimism team has acknowledged these scenarios and consider them intended. Therefore, we are only describing them in this informative note for completeness, and to suggest explicitly documenting them either with inline comments, docstrings, external developer documentation or system specification if the Optimism team considers it appropriate.  [N20] Repeated authentication logic in State Manager  The isAuthenticated function of the OVM_StateManager contract can be used to validate whether a given address is allowed to write into the contracts state. The same functionality is implemented in the authenticated modifier.  To avoid code repetition, consider modifying the authenticated modifier so that it calls the isAuthenticated function to determine if the caller is authenticated. This note can be disregarded should the current implementation be more favorable in terms of gas costs.  [N21] Not using available bytes32 utilities  76,  86,  100 and  110 of  Lib_Bytes32Utils library.  [N22] Missing operations in Execution Manager wrapper library  The Lib_SafeExecutionManagerWrapper library offers functions to facilitate writing OVM safe code that can be compiled using the standard Solidity compiler. However, it is missing a number of wrappers for OVM operations, namely:  ovmCREATE2  ovmSTATICCALL  ovmEXTCODEHASH  ovmEXTCODECOPY  ovmL1TXORIGIN  ovmL1QUEUEORIGIN  ovmGASLIMIT  ovmNUMBER  ovmTIMESTAMP  Consider including wrapper functions for them in the Lib_SafeExecutionManagerWrapper library.  [N23] Unnecessary standalone contract to relay multiple messages  The OVM_L1MultiMessageRelayer contract implements a single function batchRelayMessages that forwards multiple cross-domain messages to the OVM_L1CrossDomainMessenger contract. To favor simplicity, this function could be moved to the OVM_L1CrossDomainMessenger contract (where it should be marked with the onlyRelayer modifier).  [N24] Data returned by relayed message is ignored  relayMessage function of the  ovmCALL to the messages target. While the calls success flag is  validated to determine whether the message can be considered successful, the returned data is never stored nor logged. As a consequence, relevant returned data from relayed messages will not be accessible after a message is relayed. The described behavior also occurs in the  relayMessage function of the  Should this be the intended behavior of the relayMessage functions, consider documenting it in the functions docstrings. Otherwise, consider including a mechanism to retrieve the returned data of relayed messages, which could include storing the data in storage, or logging it using an event.  [N25] Duplicated code in cross-domain messenger contracts  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts behave in a similar way and share a non-trivial amount of duplicated logic.  To reduce code duplication and favor reusability, consider abstracting away repeated logic to an internal function of the Abs_BaseCrossDomainMessenger parent contract.  [N26] Duplicated code for memory copy utility  The _copy function of the Lib_RLPReader library and _memcpy function of the Lib_RLPWriter serve a similar purpose: copying pieces of memory to other locations. To reduce duplicated logic and ease maintenance, consider defining a single memory copy utility function, and reusing it throughout the code base. Alternatively, to favor a simpler implementation, consider using the identity precompile contract at address 0x0000000000000000000000000000000000000004 to copy pieces of memory.  [N27] Redundant check when proving contract state  proveContractState function of the  two conditions. The first condition,  hasAccount, checks whether  the accounts code hash is non-zero. The second condition,  hasEmptyAccount, checks that  the accounts code hash matches the EMPTY_ACCOUNT_CODE_HASH hash.  Since the EMPTY_ACCOUNT_CODE_HASH is non-zero, the second condition implies the first one. Therefore, consider removing the call to hasAccount.  [N28] Base contract not marked as abstract  Contracts that are not intended to be instantiated directly, such as OVM_CrossDomainEnabled, should be marked as abstract to favor readability and avoid unintended usage.  [N29] Inconsistent coding style  Some instances of inconsistent coding style were identified in the code base. Specifically:  While most internal and private functions explicitly denote their visibility by prepending their names with an underscore, functions getCrossDomainMessenger and sendCrossDomainMessage of the OVM_CrossDomainEnabled contract fail to do so.  To favor readability, consider always following a consistent style throughout the code base. We suggest using Soliditys Style Guide as a reference.  [N30] Lack of explicit visibility in state variables  The following state variables and constants are implicitly using the default visibility.  In the OVM_ECDSAContractAccount contract:  The EXECUTION_VALIDATION_GAS_OVERHEAD and ETH_ERC20_ADDRESS constants.  In the OVM_ProxyEOA contract:  The IMPLEMENTATION_KEY constant.  In the Abs_L2DepositedToken contract:  The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant  To favor readability, consider explicitly declaring the visibility of all state variables and constants.  [N31] Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.  The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.  In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.  [N32] Implicit casting operations  The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when its passed to the call to _sendXDomainMessage.  The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transactions nonce matches the expected one.  For added readability, consider making casting operations explicit where possible.  Conclusions  4 critical and 4 high severity issues were found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n08]-minimum-nuisance-gas-per-contract-creation-is-charged-twice", "labels": ["OpenZeppelin"]}, {"title": "The ovmCREATEEOA and safeCREATE functions, used for creating accounts in the OVM_ExecutionManager contract, follow a similar pattern to calculate nuisance gas:", "body": "The ovmCREATEEOA and safeCREATE functions, used for creating accounts in the OVM_ExecutionManager contract, follow a similar pattern to calculate nuisance gas:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-ovmcreateeoa-and-safecreate-functions,-used-for-creating-accounts-in-the-ovm_executionmanager-contract,-follow-a-similar-pattern-to-calculate-nuisance-gas:", "labels": ["OpenZeppelin"]}, {"title": "Call the _initPendingAccount function (see lines 537 and 1098), which internally calls the _checkAccountLoad function, which in turn charges nuisance gas the first time the referenced account is loaded. Here, the amount of nuisance gas charged includes the minimum gas (dictated by the MIN_NUISANCE_GAS_PER_CONTRACT constant).", "body": "Call the _initPendingAccount function (see lines 537 and 1098), which internally calls the _checkAccountLoad function, which in turn charges nuisance gas the first time the referenced account is loaded. Here, the amount of nuisance gas charged includes the minimum gas (dictated by the MIN_NUISANCE_GAS_PER_CONTRACT constant).", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#call-the-_initpendingaccount-function-(see-lines-537-and-1098),-which-internally-calls-the-_checkaccountload-function,-which-in-turn-charges-nuisance-gas-the-first-time-the-referenced-account-is-loaded.-here,-the-amount-of-nuisance-gas-charged-includes-the-minimum-gas-(dictated-by-the-min_nuisance_gas_per_contract-constant).", "labels": ["OpenZeppelin"]}, {"title": "Call the _commitPendingAccount function (see lines 551 and 1125), which internally calls the _checkAccountChange function, which in turn charges nuisance gas the first time the referenced account is changed. Here, the amount of nuisance gas charged also includes MIN_NUISANCE_GAS_PER_CONTRACT (as in the first case).", "body": "Call the _commitPendingAccount function (see lines 551 and 1125), which internally calls the _checkAccountChange function, which in turn charges nuisance gas the first time the referenced account is changed. Here, the amount of nuisance gas charged also includes MIN_NUISANCE_GAS_PER_CONTRACT (as in the first case).", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#call-the-_commitpendingaccount-function-(see-lines-551-and-1125),-which-internally-calls-the-_checkaccountchange-function,-which-in-turn-charges-nuisance-gas-the-first-time-the-referenced-account-is-changed.-here,-the-amount-of-nuisance-gas-charged-also-includes-min_nuisance_gas_per_contract-(as-in-the-first-case).", "labels": ["OpenZeppelin"]}, {"title": "This means that during account creation, the minimum amount of nuisance gas tracked in the MIN_NUISANCE_GAS_PER_CONTRACT constant is charged twice. This appears to be unnecessary since during fraud proof verification the code for the created account would only need to be provided once. Yet it could also be argued that in the fraud proof verification the pre-state of the empty account would need to be proved as well, and that is why the MIN_NUISANCE_GAS_PER_CONTRACT is charged twice.", "body": "This means that during account creation, the minimum amount of nuisance gas tracked in the MIN_NUISANCE_GAS_PER_CONTRACT constant is charged twice. This appears to be unnecessary since during fraud proof verification the code for the created account would only need to be provided once. Yet it could also be argued that in the fraud proof verification the pre-state of the empty account would need to be proved as well, and that is why the MIN_NUISANCE_GAS_PER_CONTRACT is charged twice.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#this-means-that-during-account-creation,-the-minimum-amount-of-nuisance-gas-tracked-in-the-min_nuisance_gas_per_contract-constant-is-charged-twice.-this-appears-to-be-unnecessary-since-during-fraud-proof-verification-the-code-for-the-created-account-would-only-need-to-be-provided-once.-yet-it-could-also-be-argued-that-in-the-fraud-proof-verification-the-pre-state-of-the-empty-account-would-need-to-be-proved-as-well,-and-that-is-why-the-min_nuisance_gas_per_contract-is-charged-twice.", "labels": ["OpenZeppelin"]}, {"title": "To avoid confusions, consider explicitly specifying and documenting the intended behavior, including related unit tests if appropriate.", "body": "To avoid confusions, consider explicitly specifying and documenting the intended behavior, including related unit tests if appropriate.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#to-avoid-confusions,-consider-explicitly-specifying-and-documenting-the-intended-behavior,-including-related-unit-tests-if-appropriate.", "labels": ["OpenZeppelin"]}, {"title": "[N09] Redundant validations during state batch deletion", "body": "[N09] Redundant validations during state batch deletion", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n09]-redundant-validations-during-state-batch-deletion", "labels": ["OpenZeppelin"]}, {"title": "deleteStateBatch function of the", "body": "deleteStateBatch function of the", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#deletestatebatch-function-of-the", "labels": ["OpenZeppelin"]}, {"title": "_isValidBatchHeader function, and after additional checks, it", "body": "_isValidBatchHeader function, and after additional checks, it", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#_isvalidbatchheader-function,-and-after-additional-checks,-it", "labels": ["OpenZeppelin"]}, {"title": "executes the internal", "body": "executes the internal", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#executes-the-internal", "labels": ["OpenZeppelin"]}, {"title": "checks that both the index and batch header are valid. Yet these last two validations are redundant, since as mentioned, the", "body": "checks that both the index and batch header are valid. Yet these last two validations are redundant, since as mentioned, the", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#checks-that-both-the-index-and-batch-header-are-valid.-yet-these-last-two-validations-are-redundant,-since-as-mentioned,-the", "labels": ["OpenZeppelin"]}, {"title": "already executed prior to the internal call to", "body": "already executed prior to the internal call to", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#already-executed-prior-to-the-internal-call-to", "labels": ["OpenZeppelin"]}, {"title": "To favor simplicity and gas-efficiency, consider removing these unnecessary validations.", "body": "To favor simplicity and gas-efficiency, consider removing these unnecessary validations.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#to-favor-simplicity-and-gas-efficiency,-consider-removing-these-unnecessary-validations.", "labels": ["OpenZeppelin"]}, {"title": "[N10] Contract creation can revert upon failure", "body": "ovmCREATE and  ovmCREATE2 opcodes can revert during execution (instead of returning 0 upon failure as specified in the EVM). This is due to the fact that the code is validating the deployer is allowed at the beginning of the opcodes execution (see calls to the  here and  here), instead of doing it inside the  safeCREATE function, where similar validations are applied that do not result in a revert upon failure.  We are raising this peculiarity of the current version of the OVM as an informative note for completeness, since we understand that the development team is fully aware of this undocumented behavioral difference with EVM, and is planning to fix it by removing the deployer whitelist in the short term. Should that not be the case, consider this note of higher priority and explicitly document the described behavior in external documentation to raise user awareness.  [N11] Typographical errors  In Lib_MerkleTree.sol:  In line 117, sibline should say sibling.  In Lib_MerkleTrie.sol:  In line 275, 31 should say 32.  In Lib_Math.sol:  In line 14, minumum should say minimum.  In iOVM_ChainStorageContainer.sol:  In line 104, meaing should say meaning.  In OVM_CanonicalTransactionChain.sol:  In line 344, minnet should say mainnet.  In line 973, que should say queue.  In line 1011, elemtent should say element.  In OVM_CrossDomainEnabled.sol:  In line 14, recieve should say receive.  In OVM_L2ToL1MessagePasser.sol:  In line 9, facilitates is misspelled. It also includes the repeated phrase of the.  In Abs_L1TokenGateway.sol:  In line 128, recipients is misspelled.  In OVM_L1ERC20Gateway.sol:  In line 18, takes should say take.  In OVM_ExecutionManager.sol:  In line 168, awlways should say always.  In lines 191, 202, 213, and 1701, minnet should say mainnet.  In lines 1804, 1809, 1814, unnecessary the SSTORE should say the unnecessary SSTORE.  In OVM_ECDSAContract.sol:  In lines 142, transfer is misspelled.  In OVM_FraudVerifier.sol:  In line 210, minnet should say mainnet.  In Lib_RLPReader.sol:  In lines 384 and 410, a address should say an address.  [N12] Negative overflow of uint256 type  To favor readability, in line 1890 of OVM_ExecutionManager.sol consider replacing the negative overflow operation of an uint256 value with the expression type(uint256).max.  [N13] Unnecessary return statement  Consider removing the return keyword from the setGlobalMetadata function of the OVM_ChainStorageContainer contract, as the setExtraData function of the Lib_RingBuffer library being called does not return any value.  [N14] Unused imports  To improve readability and avoid confusion, consider removing the following unused imports.  In the OVM_StateCommitmentChain contract, the iOVM_FraudVerifier interface.  In the OVM_ExecutionManager contract, the OVM_ECDSAContractAccount and OVM_DeployerWhitelist contracts.  In the OVM_L2DepositedERC20 contract, the iOVM_L1TokenGateway interface.  In the OVM_ETH contract, the Lib_AddressResolver contract.  In the OVM_StateTransitioner contract, the iOVM_BondManager interface.  In the Lib_OVMCodec library, the Lib_BytesUtils library.  [N15] Unused events  The iOVM_L2ToL1MessagePasser interface defines the L2ToL1Message event, which is never emitted in the child contract OVM_L2ToL1MessagePasser.  To avoid confusion and favor simplicity, consider removing all definitions of events that are not expected to be emitted.  [N16] Unused functions  Functions toUint24, toUint8 and toAddress of the Lib_BytesUtils library are never used, and can therefore be removed.  [N17] Transaction hashes might not be unique in the Canonical Transaction Chain  The enqueue function of the OVM_CanonicalTransactionChain contract constructs transaction hashes with the callers address, the L2 target, the transactions gas limit and its data. Since this is not enough to ensure uniqueness of hashes (that is, it could be possible to construct two transactions that result in the same hash), these transactions are instead identified by their position in the queue. However, this internal subtlety of the Canonical Transaction Chain is not explicitly documented, and might lead to errors in off-chain services tracking transactions in the Canonical Transaction Chain, since transaction hashes are commonly assumed to be unique.  Consider including developer-friendly documentation stating how transaction hashes in the Canonical Transaction Chain are constructed, and how they should not be relied on to uniquely identify transactions.  [N18] Cross-domain messengers can be impersonated  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts allow relaying arbitrary cross-domain messages. Ultimately, this means that it is possible for anyone to make these contracts execute arbitrary calls (see calls hereand here). Therefore, there are two scenarios developers should consider when building and integrating bridges between layer 1 and 2. Aiming for simplicity, in the following we explain both scenarios starting on layer 1  yet a similar behavior can be seen in the opposite direction.  call any target address with arbitrary data. Therefore, layer 2 accounts should be aware that they can receive arbitrary calls from the  ERC1820Registry contract. It must be noted that during the call from the  xDomainMessageSender functionto inspect the address of the layer 1 account that originated the message.  Going further, now into the second case, a subtle behavior of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessengercontracts allows anyone not only to send messages via these contracts, but also to originate messages from them. The execution steps to originate an L2-to-L1 message from the OVM_L2CrossDomainMessenger would develop as follows:  A user-controlled account sends a message from layer 1 calling the sendMessage function of the OVM_L1CrossDomainMessengercontract. The target of this message should be the OVM_L2CrossDomainMessenger contract, and the message should be an abi-encoded call to the targets sendMessage function, including the arbitrary data the user wants the OVM_L2CrossDomainMessengercontract to send to layer 1.  The L1-to-L2 message sent by the user is enqueued in the Canonical Transaction Chain as a regular OVM transaction.  In layer 2, the relayMessage function of the OVM_L2CrossDomainMessenger contract is called to relay the users message. Following how the message was constructed, this will trigger a call from the OVM_L2CrossDomainMessenger contract to its own sendMessagefunction. In other words, the OVM_L2CrossDomainMessenger contract sends a message from L2 to L1 with target and data arbitrarily decided by the user in (1).  After the fraud proof window is over, the L2-to-L1 message sent by the OVM_L2CrossDomainMessenger contract is relayed in layer 1.  The target contract in layer 1 receives a message with the user-controlled data. Should the target address query the xDomainMessageSender function to inspect the address of the layer 2 account that originated the message, it would receive the address of the OVM_L2CrossDomainMessenger contract.  The actual consequences of the described behaviors will ultimately depend on the contracts receiving these arbitrary calls, and that is why we are only reporting this as an informative note. Developers should be fully aware of these scenarios and be ready to implement the necessary defensive measures to mitigate impact on their systems. We suggest the Optimism team to include specific developer-friendly documentation highlighting this note, so as to raise awareness of the subtleties of cross-domain communication.  [N19] Subtleties of calling contracts under construction and abstracted EOAs  In the EVM, calling accounts with no executable code (that is, contracts during construction or externally owned accounts) results in an immediate halt with a STOP opcode (see subsection 9.4 of the yellow paper), and the call is considered successful. In the OVM, this behavior is not exactly replicated, due to some fundamental differences between the EVM and the OVM.  Calling abstracted EOAs  The OVM offers native account abstraction. In other words, the only type of account is smart contracts, and the closest one can get to the behavior of EOAs is implemented in the OVM_ECDSAContractAccount contract. As a result, calling an EOA is translated to calling a specific instance of this contract, and any call that does not match the selector of the execute function will result in an out-of-gas error.  Calling contracts under construction  _callContract function of the  using the _getAccountEthAddress function. This results in a call to the  getAccountEthAddress function of the  first initialized as pending without setting its L1 address, then  created, and  finally committed. Therefore any address resolution before the account is committed will resolve to the zero address. The call to the zero address will be successful, and execution will simply continue. Off-chain services tracing the internal execution of fraud proof verifications might find this behavior relevant, as they will see a call to the zero address where they would have expected a call to a contract under construction.  It should be noted that both scenarios described were raised as issues of Medium severity in our November 2020 report as [M03] Call to contract in construction results in call to the zero address and [M04] Calls to abstracted EOA accounts may result in Out of Gas error. Taking into account that we did not receive specific feedback on those issues, and that the behavior of the system remains, we assume that the Optimism team has acknowledged these scenarios and consider them intended. Therefore, we are only describing them in this informative note for completeness, and to suggest explicitly documenting them either with inline comments, docstrings, external developer documentation or system specification if the Optimism team considers it appropriate.  [N20] Repeated authentication logic in State Manager  The isAuthenticated function of the OVM_StateManager contract can be used to validate whether a given address is allowed to write into the contracts state. The same functionality is implemented in the authenticated modifier.  To avoid code repetition, consider modifying the authenticated modifier so that it calls the isAuthenticated function to determine if the caller is authenticated. This note can be disregarded should the current implementation be more favorable in terms of gas costs.  [N21] Not using available bytes32 utilities  76,  86,  100 and  110 of  Lib_Bytes32Utils library.  [N22] Missing operations in Execution Manager wrapper library  The Lib_SafeExecutionManagerWrapper library offers functions to facilitate writing OVM safe code that can be compiled using the standard Solidity compiler. However, it is missing a number of wrappers for OVM operations, namely:  ovmCREATE2  ovmSTATICCALL  ovmEXTCODEHASH  ovmEXTCODECOPY  ovmL1TXORIGIN  ovmL1QUEUEORIGIN  ovmGASLIMIT  ovmNUMBER  ovmTIMESTAMP  Consider including wrapper functions for them in the Lib_SafeExecutionManagerWrapper library.  [N23] Unnecessary standalone contract to relay multiple messages  The OVM_L1MultiMessageRelayer contract implements a single function batchRelayMessages that forwards multiple cross-domain messages to the OVM_L1CrossDomainMessenger contract. To favor simplicity, this function could be moved to the OVM_L1CrossDomainMessenger contract (where it should be marked with the onlyRelayer modifier).  [N24] Data returned by relayed message is ignored  relayMessage function of the  ovmCALL to the messages target. While the calls success flag is  validated to determine whether the message can be considered successful, the returned data is never stored nor logged. As a consequence, relevant returned data from relayed messages will not be accessible after a message is relayed. The described behavior also occurs in the  relayMessage function of the  Should this be the intended behavior of the relayMessage functions, consider documenting it in the functions docstrings. Otherwise, consider including a mechanism to retrieve the returned data of relayed messages, which could include storing the data in storage, or logging it using an event.  [N25] Duplicated code in cross-domain messenger contracts  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts behave in a similar way and share a non-trivial amount of duplicated logic.  To reduce code duplication and favor reusability, consider abstracting away repeated logic to an internal function of the Abs_BaseCrossDomainMessenger parent contract.  [N26] Duplicated code for memory copy utility  The _copy function of the Lib_RLPReader library and _memcpy function of the Lib_RLPWriter serve a similar purpose: copying pieces of memory to other locations. To reduce duplicated logic and ease maintenance, consider defining a single memory copy utility function, and reusing it throughout the code base. Alternatively, to favor a simpler implementation, consider using the identity precompile contract at address 0x0000000000000000000000000000000000000004 to copy pieces of memory.  [N27] Redundant check when proving contract state  proveContractState function of the  two conditions. The first condition,  hasAccount, checks whether  the accounts code hash is non-zero. The second condition,  hasEmptyAccount, checks that  the accounts code hash matches the EMPTY_ACCOUNT_CODE_HASH hash.  Since the EMPTY_ACCOUNT_CODE_HASH is non-zero, the second condition implies the first one. Therefore, consider removing the call to hasAccount.  [N28] Base contract not marked as abstract  Contracts that are not intended to be instantiated directly, such as OVM_CrossDomainEnabled, should be marked as abstract to favor readability and avoid unintended usage.  [N29] Inconsistent coding style  Some instances of inconsistent coding style were identified in the code base. Specifically:  While most internal and private functions explicitly denote their visibility by prepending their names with an underscore, functions getCrossDomainMessenger and sendCrossDomainMessage of the OVM_CrossDomainEnabled contract fail to do so.  To favor readability, consider always following a consistent style throughout the code base. We suggest using Soliditys Style Guide as a reference.  [N30] Lack of explicit visibility in state variables  The following state variables and constants are implicitly using the default visibility.  In the OVM_ECDSAContractAccount contract:  The EXECUTION_VALIDATION_GAS_OVERHEAD and ETH_ERC20_ADDRESS constants.  In the OVM_ProxyEOA contract:  The IMPLEMENTATION_KEY constant.  In the Abs_L2DepositedToken contract:  The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant  To favor readability, consider explicitly declaring the visibility of all state variables and constants.  [N31] Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.  The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.  In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.  [N32] Implicit casting operations  The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when its passed to the call to _sendXDomainMessage.  The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transactions nonce matches the expected one.  For added readability, consider making casting operations explicit where possible.  Conclusions  4 critical and 4 high severity issues were found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n10]-contract-creation-can-revert-upon-failure", "labels": ["OpenZeppelin"]}, {"title": "ovmCREATE and", "body": "ovmCREATE and", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#ovmcreate-and", "labels": ["OpenZeppelin"]}, {"title": "ovmCREATE2 opcodes can revert during execution (instead of returning 0 upon failure as specified in the EVM). This is due to the fact that the code is validating the deployer is allowed at the beginning of the opcodes execution (see calls to the", "body": "ovmCREATE2 opcodes can revert during execution (instead of returning 0 upon failure as specified in the EVM). This is due to the fact that the code is validating the deployer is allowed at the beginning of the opcodes execution (see calls to the", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#ovmcreate2-opcodes-can-revert-during-execution-(instead-of-returning-0-upon-failure-as-specified-in-the-evm).-this-is-due-to-the-fact-that-the-code-is-validating-the-deployer-is-allowed-at-the-beginning-of-the-opcodes-execution-(see-calls-to-the", "labels": ["OpenZeppelin"]}, {"title": "here and", "body": "here), instead of doing it inside the  safeCREATE function, where similar validations are applied that do not result in a revert upon failure.  We are raising this peculiarity of the current version of the OVM as an informative note for completeness, since we understand that the development team is fully aware of this undocumented behavioral difference with EVM, and is planning to fix it by removing the deployer whitelist in the short term. Should that not be the case, consider this note of higher priority and explicitly document the described behavior in external documentation to raise user awareness.  [N11] Typographical errors  In Lib_MerkleTree.sol:  In line 117, sibline should say sibling.  In Lib_MerkleTrie.sol:  In line 275, 31 should say 32.  In Lib_Math.sol:  In line 14, minumum should say minimum.  In iOVM_ChainStorageContainer.sol:  In line 104, meaing should say meaning.  In OVM_CanonicalTransactionChain.sol:  In line 344, minnet should say mainnet.  In line 973, que should say queue.  In line 1011, elemtent should say element.  In OVM_CrossDomainEnabled.sol:  In line 14, recieve should say receive.  In OVM_L2ToL1MessagePasser.sol:  In line 9, facilitates is misspelled. It also includes the repeated phrase of the.  In Abs_L1TokenGateway.sol:  In line 128, recipients is misspelled.  In OVM_L1ERC20Gateway.sol:  In line 18, takes should say take.  In OVM_ExecutionManager.sol:  In line 168, awlways should say always.  In lines 191, 202, 213, and 1701, minnet should say mainnet.  In lines 1804, 1809, 1814, unnecessary the SSTORE should say the unnecessary SSTORE.  In OVM_ECDSAContract.sol:  In lines 142, transfer is misspelled.  In OVM_FraudVerifier.sol:  In line 210, minnet should say mainnet.  In Lib_RLPReader.sol:  In lines 384 and 410, a address should say an address.  [N12] Negative overflow of uint256 type  To favor readability, in line 1890 of OVM_ExecutionManager.sol consider replacing the negative overflow operation of an uint256 value with the expression type(uint256).max.  [N13] Unnecessary return statement  Consider removing the return keyword from the setGlobalMetadata function of the OVM_ChainStorageContainer contract, as the setExtraData function of the Lib_RingBuffer library being called does not return any value.  [N14] Unused imports  To improve readability and avoid confusion, consider removing the following unused imports.  In the OVM_StateCommitmentChain contract, the iOVM_FraudVerifier interface.  In the OVM_ExecutionManager contract, the OVM_ECDSAContractAccount and OVM_DeployerWhitelist contracts.  In the OVM_L2DepositedERC20 contract, the iOVM_L1TokenGateway interface.  In the OVM_ETH contract, the Lib_AddressResolver contract.  In the OVM_StateTransitioner contract, the iOVM_BondManager interface.  In the Lib_OVMCodec library, the Lib_BytesUtils library.  [N15] Unused events  The iOVM_L2ToL1MessagePasser interface defines the L2ToL1Message event, which is never emitted in the child contract OVM_L2ToL1MessagePasser.  To avoid confusion and favor simplicity, consider removing all definitions of events that are not expected to be emitted.  [N16] Unused functions  Functions toUint24, toUint8 and toAddress of the Lib_BytesUtils library are never used, and can therefore be removed.  [N17] Transaction hashes might not be unique in the Canonical Transaction Chain  The enqueue function of the OVM_CanonicalTransactionChain contract constructs transaction hashes with the callers address, the L2 target, the transactions gas limit and its data. Since this is not enough to ensure uniqueness of hashes (that is, it could be possible to construct two transactions that result in the same hash), these transactions are instead identified by their position in the queue. However, this internal subtlety of the Canonical Transaction Chain is not explicitly documented, and might lead to errors in off-chain services tracking transactions in the Canonical Transaction Chain, since transaction hashes are commonly assumed to be unique.  Consider including developer-friendly documentation stating how transaction hashes in the Canonical Transaction Chain are constructed, and how they should not be relied on to uniquely identify transactions.  [N18] Cross-domain messengers can be impersonated  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts allow relaying arbitrary cross-domain messages. Ultimately, this means that it is possible for anyone to make these contracts execute arbitrary calls (see calls hereand here). Therefore, there are two scenarios developers should consider when building and integrating bridges between layer 1 and 2. Aiming for simplicity, in the following we explain both scenarios starting on layer 1  yet a similar behavior can be seen in the opposite direction.  call any target address with arbitrary data. Therefore, layer 2 accounts should be aware that they can receive arbitrary calls from the  ERC1820Registry contract. It must be noted that during the call from the  xDomainMessageSender functionto inspect the address of the layer 1 account that originated the message.  Going further, now into the second case, a subtle behavior of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessengercontracts allows anyone not only to send messages via these contracts, but also to originate messages from them. The execution steps to originate an L2-to-L1 message from the OVM_L2CrossDomainMessenger would develop as follows:  A user-controlled account sends a message from layer 1 calling the sendMessage function of the OVM_L1CrossDomainMessengercontract. The target of this message should be the OVM_L2CrossDomainMessenger contract, and the message should be an abi-encoded call to the targets sendMessage function, including the arbitrary data the user wants the OVM_L2CrossDomainMessengercontract to send to layer 1.  The L1-to-L2 message sent by the user is enqueued in the Canonical Transaction Chain as a regular OVM transaction.  In layer 2, the relayMessage function of the OVM_L2CrossDomainMessenger contract is called to relay the users message. Following how the message was constructed, this will trigger a call from the OVM_L2CrossDomainMessenger contract to its own sendMessagefunction. In other words, the OVM_L2CrossDomainMessenger contract sends a message from L2 to L1 with target and data arbitrarily decided by the user in (1).  After the fraud proof window is over, the L2-to-L1 message sent by the OVM_L2CrossDomainMessenger contract is relayed in layer 1.  The target contract in layer 1 receives a message with the user-controlled data. Should the target address query the xDomainMessageSender function to inspect the address of the layer 2 account that originated the message, it would receive the address of the OVM_L2CrossDomainMessenger contract.  The actual consequences of the described behaviors will ultimately depend on the contracts receiving these arbitrary calls, and that is why we are only reporting this as an informative note. Developers should be fully aware of these scenarios and be ready to implement the necessary defensive measures to mitigate impact on their systems. We suggest the Optimism team to include specific developer-friendly documentation highlighting this note, so as to raise awareness of the subtleties of cross-domain communication.  [N19] Subtleties of calling contracts under construction and abstracted EOAs  In the EVM, calling accounts with no executable code (that is, contracts during construction or externally owned accounts) results in an immediate halt with a STOP opcode (see subsection 9.4 of the yellow paper), and the call is considered successful. In the OVM, this behavior is not exactly replicated, due to some fundamental differences between the EVM and the OVM.  Calling abstracted EOAs  The OVM offers native account abstraction. In other words, the only type of account is smart contracts, and the closest one can get to the behavior of EOAs is implemented in the OVM_ECDSAContractAccount contract. As a result, calling an EOA is translated to calling a specific instance of this contract, and any call that does not match the selector of the execute function will result in an out-of-gas error.  Calling contracts under construction  _callContract function of the  using the _getAccountEthAddress function. This results in a call to the  getAccountEthAddress function of the  first initialized as pending without setting its L1 address, then  created, and  finally committed. Therefore any address resolution before the account is committed will resolve to the zero address. The call to the zero address will be successful, and execution will simply continue. Off-chain services tracing the internal execution of fraud proof verifications might find this behavior relevant, as they will see a call to the zero address where they would have expected a call to a contract under construction.  It should be noted that both scenarios described were raised as issues of Medium severity in our November 2020 report as [M03] Call to contract in construction results in call to the zero address and [M04] Calls to abstracted EOA accounts may result in Out of Gas error. Taking into account that we did not receive specific feedback on those issues, and that the behavior of the system remains, we assume that the Optimism team has acknowledged these scenarios and consider them intended. Therefore, we are only describing them in this informative note for completeness, and to suggest explicitly documenting them either with inline comments, docstrings, external developer documentation or system specification if the Optimism team considers it appropriate.  [N20] Repeated authentication logic in State Manager  The isAuthenticated function of the OVM_StateManager contract can be used to validate whether a given address is allowed to write into the contracts state. The same functionality is implemented in the authenticated modifier.  To avoid code repetition, consider modifying the authenticated modifier so that it calls the isAuthenticated function to determine if the caller is authenticated. This note can be disregarded should the current implementation be more favorable in terms of gas costs.  [N21] Not using available bytes32 utilities  76,  86,  100 and  110 of  Lib_Bytes32Utils library.  [N22] Missing operations in Execution Manager wrapper library  The Lib_SafeExecutionManagerWrapper library offers functions to facilitate writing OVM safe code that can be compiled using the standard Solidity compiler. However, it is missing a number of wrappers for OVM operations, namely:  ovmCREATE2  ovmSTATICCALL  ovmEXTCODEHASH  ovmEXTCODECOPY  ovmL1TXORIGIN  ovmL1QUEUEORIGIN  ovmGASLIMIT  ovmNUMBER  ovmTIMESTAMP  Consider including wrapper functions for them in the Lib_SafeExecutionManagerWrapper library.  [N23] Unnecessary standalone contract to relay multiple messages  The OVM_L1MultiMessageRelayer contract implements a single function batchRelayMessages that forwards multiple cross-domain messages to the OVM_L1CrossDomainMessenger contract. To favor simplicity, this function could be moved to the OVM_L1CrossDomainMessenger contract (where it should be marked with the onlyRelayer modifier).  [N24] Data returned by relayed message is ignored  relayMessage function of the  ovmCALL to the messages target. While the calls success flag is  validated to determine whether the message can be considered successful, the returned data is never stored nor logged. As a consequence, relevant returned data from relayed messages will not be accessible after a message is relayed. The described behavior also occurs in the  relayMessage function of the  Should this be the intended behavior of the relayMessage functions, consider documenting it in the functions docstrings. Otherwise, consider including a mechanism to retrieve the returned data of relayed messages, which could include storing the data in storage, or logging it using an event.  [N25] Duplicated code in cross-domain messenger contracts  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts behave in a similar way and share a non-trivial amount of duplicated logic.  To reduce code duplication and favor reusability, consider abstracting away repeated logic to an internal function of the Abs_BaseCrossDomainMessenger parent contract.  [N26] Duplicated code for memory copy utility  The _copy function of the Lib_RLPReader library and _memcpy function of the Lib_RLPWriter serve a similar purpose: copying pieces of memory to other locations. To reduce duplicated logic and ease maintenance, consider defining a single memory copy utility function, and reusing it throughout the code base. Alternatively, to favor a simpler implementation, consider using the identity precompile contract at address 0x0000000000000000000000000000000000000004 to copy pieces of memory.  [N27] Redundant check when proving contract state  proveContractState function of the  two conditions. The first condition,  hasAccount, checks whether  the accounts code hash is non-zero. The second condition,  hasEmptyAccount, checks that  the accounts code hash matches the EMPTY_ACCOUNT_CODE_HASH hash.  Since the EMPTY_ACCOUNT_CODE_HASH is non-zero, the second condition implies the first one. Therefore, consider removing the call to hasAccount.  [N28] Base contract not marked as abstract  Contracts that are not intended to be instantiated directly, such as OVM_CrossDomainEnabled, should be marked as abstract to favor readability and avoid unintended usage.  [N29] Inconsistent coding style  Some instances of inconsistent coding style were identified in the code base. Specifically:  While most internal and private functions explicitly denote their visibility by prepending their names with an underscore, functions getCrossDomainMessenger and sendCrossDomainMessage of the OVM_CrossDomainEnabled contract fail to do so.  To favor readability, consider always following a consistent style throughout the code base. We suggest using Soliditys Style Guide as a reference.  [N30] Lack of explicit visibility in state variables  The following state variables and constants are implicitly using the default visibility.  In the OVM_ECDSAContractAccount contract:  The EXECUTION_VALIDATION_GAS_OVERHEAD and ETH_ERC20_ADDRESS constants.  In the OVM_ProxyEOA contract:  The IMPLEMENTATION_KEY constant.  In the Abs_L2DepositedToken contract:  The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant  To favor readability, consider explicitly declaring the visibility of all state variables and constants.  [N31] Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.  The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.  In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.  [N32] Implicit casting operations  The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when its passed to the call to _sendXDomainMessage.  The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transactions nonce matches the expected one.  For added readability, consider making casting operations explicit where possible.  Conclusions  4 critical and 4 high severity issues were found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#here-and", "labels": ["OpenZeppelin"]}, {"title": "here), instead of doing it inside the", "body": "here), instead of doing it inside the", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#here),-instead-of-doing-it-inside-the", "labels": ["OpenZeppelin"]}, {"title": "safeCREATE function, where similar validations are applied that do not result in a revert upon failure.", "body": "safeCREATE function, where similar validations are applied that do not result in a revert upon failure.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#safecreate-function,-where-similar-validations-are-applied-that-do-not-result-in-a-revert-upon-failure.", "labels": ["OpenZeppelin"]}, {"title": "We are raising this peculiarity of the current version of the OVM as an informative note for completeness, since we understand that the development team is fully aware of this undocumented behavioral difference with EVM, and is planning to fix it by removing the deployer whitelist in the short term. Should that not be the case, consider this note of higher priority and explicitly document the described behavior in external documentation to raise user awareness.", "body": "We are raising this peculiarity of the current version of the OVM as an informative note for completeness, since we understand that the development team is fully aware of this undocumented behavioral difference with EVM, and is planning to fix it by removing the deployer whitelist in the short term. Should that not be the case, consider this note of higher priority and explicitly document the described behavior in external documentation to raise user awareness.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#we-are-raising-this-peculiarity-of-the-current-version-of-the-ovm-as-an-informative-note-for-completeness,-since-we-understand-that-the-development-team-is-fully-aware-of-this-undocumented-behavioral-difference-with-evm,-and-is-planning-to-fix-it-by-removing-the-deployer-whitelist-in-the-short-term.-should-that-not-be-the-case,-consider-this-note-of-higher-priority-and-explicitly-document-the-described-behavior-in-external-documentation-to-raise-user-awareness.", "labels": ["OpenZeppelin"]}, {"title": "[N11] Typographical errors", "body": "[N11] Typographical errors", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n11]-typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "In Lib_MerkleTree.sol:", "body": "In Lib_MerkleTree.sol:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-lib_merkletree.sol:", "labels": ["OpenZeppelin"]}, {"title": "In line 117, \u201csibline\u201d should say \u201csibling\u201d.", "body": "In line 117, \u201csibline\u201d should say \u201csibling\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-line-117,-\u201csibline\u201d-should-say-\u201csibling\u201d.", "labels": ["OpenZeppelin"]}, {"title": "In Lib_MerkleTrie.sol:", "body": "In line 275, 31 should say 32.  In Lib_Math.sol:  In line 14, minumum should say minimum.  In iOVM_ChainStorageContainer.sol:  In line 104, meaing should say meaning.  In OVM_CanonicalTransactionChain.sol:  In line 344, minnet should say mainnet.  In line 973, que should say queue.  In line 1011, elemtent should say element.  In OVM_CrossDomainEnabled.sol:  In line 14, recieve should say receive.  In OVM_L2ToL1MessagePasser.sol:  In line 9, facilitates is misspelled. It also includes the repeated phrase of the.  In Abs_L1TokenGateway.sol:  In line 128, recipients is misspelled.  In OVM_L1ERC20Gateway.sol:  In line 18, takes should say take.  In OVM_ExecutionManager.sol:  In line 168, awlways should say always.  In lines 191, 202, 213, and 1701, minnet should say mainnet.  In lines 1804, 1809, 1814, unnecessary the SSTORE should say the unnecessary SSTORE.  In OVM_ECDSAContract.sol:  In lines 142, transfer is misspelled.  In OVM_FraudVerifier.sol:  In line 210, minnet should say mainnet.  In Lib_RLPReader.sol:  In lines 384 and 410, a address should say an address.  [N12] Negative overflow of uint256 type  To favor readability, in line 1890 of OVM_ExecutionManager.sol consider replacing the negative overflow operation of an uint256 value with the expression type(uint256).max.  [N13] Unnecessary return statement  Consider removing the return keyword from the setGlobalMetadata function of the OVM_ChainStorageContainer contract, as the setExtraData function of the Lib_RingBuffer library being called does not return any value.  [N14] Unused imports  To improve readability and avoid confusion, consider removing the following unused imports.  In the OVM_StateCommitmentChain contract, the iOVM_FraudVerifier interface.  In the OVM_ExecutionManager contract, the OVM_ECDSAContractAccount and OVM_DeployerWhitelist contracts.  In the OVM_L2DepositedERC20 contract, the iOVM_L1TokenGateway interface.  In the OVM_ETH contract, the Lib_AddressResolver contract.  In the OVM_StateTransitioner contract, the iOVM_BondManager interface.  In the Lib_OVMCodec library, the Lib_BytesUtils library.  [N15] Unused events  The iOVM_L2ToL1MessagePasser interface defines the L2ToL1Message event, which is never emitted in the child contract OVM_L2ToL1MessagePasser.  To avoid confusion and favor simplicity, consider removing all definitions of events that are not expected to be emitted.  [N16] Unused functions  Functions toUint24, toUint8 and toAddress of the Lib_BytesUtils library are never used, and can therefore be removed.  [N17] Transaction hashes might not be unique in the Canonical Transaction Chain  The enqueue function of the OVM_CanonicalTransactionChain contract constructs transaction hashes with the callers address, the L2 target, the transactions gas limit and its data. Since this is not enough to ensure uniqueness of hashes (that is, it could be possible to construct two transactions that result in the same hash), these transactions are instead identified by their position in the queue. However, this internal subtlety of the Canonical Transaction Chain is not explicitly documented, and might lead to errors in off-chain services tracking transactions in the Canonical Transaction Chain, since transaction hashes are commonly assumed to be unique.  Consider including developer-friendly documentation stating how transaction hashes in the Canonical Transaction Chain are constructed, and how they should not be relied on to uniquely identify transactions.  [N18] Cross-domain messengers can be impersonated  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts allow relaying arbitrary cross-domain messages. Ultimately, this means that it is possible for anyone to make these contracts execute arbitrary calls (see calls hereand here). Therefore, there are two scenarios developers should consider when building and integrating bridges between layer 1 and 2. Aiming for simplicity, in the following we explain both scenarios starting on layer 1  yet a similar behavior can be seen in the opposite direction.  call any target address with arbitrary data. Therefore, layer 2 accounts should be aware that they can receive arbitrary calls from the  ERC1820Registry contract. It must be noted that during the call from the  xDomainMessageSender functionto inspect the address of the layer 1 account that originated the message.  Going further, now into the second case, a subtle behavior of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessengercontracts allows anyone not only to send messages via these contracts, but also to originate messages from them. The execution steps to originate an L2-to-L1 message from the OVM_L2CrossDomainMessenger would develop as follows:  A user-controlled account sends a message from layer 1 calling the sendMessage function of the OVM_L1CrossDomainMessengercontract. The target of this message should be the OVM_L2CrossDomainMessenger contract, and the message should be an abi-encoded call to the targets sendMessage function, including the arbitrary data the user wants the OVM_L2CrossDomainMessengercontract to send to layer 1.  The L1-to-L2 message sent by the user is enqueued in the Canonical Transaction Chain as a regular OVM transaction.  In layer 2, the relayMessage function of the OVM_L2CrossDomainMessenger contract is called to relay the users message. Following how the message was constructed, this will trigger a call from the OVM_L2CrossDomainMessenger contract to its own sendMessagefunction. In other words, the OVM_L2CrossDomainMessenger contract sends a message from L2 to L1 with target and data arbitrarily decided by the user in (1).  After the fraud proof window is over, the L2-to-L1 message sent by the OVM_L2CrossDomainMessenger contract is relayed in layer 1.  The target contract in layer 1 receives a message with the user-controlled data. Should the target address query the xDomainMessageSender function to inspect the address of the layer 2 account that originated the message, it would receive the address of the OVM_L2CrossDomainMessenger contract.  The actual consequences of the described behaviors will ultimately depend on the contracts receiving these arbitrary calls, and that is why we are only reporting this as an informative note. Developers should be fully aware of these scenarios and be ready to implement the necessary defensive measures to mitigate impact on their systems. We suggest the Optimism team to include specific developer-friendly documentation highlighting this note, so as to raise awareness of the subtleties of cross-domain communication.  [N19] Subtleties of calling contracts under construction and abstracted EOAs  In the EVM, calling accounts with no executable code (that is, contracts during construction or externally owned accounts) results in an immediate halt with a STOP opcode (see subsection 9.4 of the yellow paper), and the call is considered successful. In the OVM, this behavior is not exactly replicated, due to some fundamental differences between the EVM and the OVM.  Calling abstracted EOAs  The OVM offers native account abstraction. In other words, the only type of account is smart contracts, and the closest one can get to the behavior of EOAs is implemented in the OVM_ECDSAContractAccount contract. As a result, calling an EOA is translated to calling a specific instance of this contract, and any call that does not match the selector of the execute function will result in an out-of-gas error.  Calling contracts under construction  _callContract function of the  using the _getAccountEthAddress function. This results in a call to the  getAccountEthAddress function of the  first initialized as pending without setting its L1 address, then  created, and  finally committed. Therefore any address resolution before the account is committed will resolve to the zero address. The call to the zero address will be successful, and execution will simply continue. Off-chain services tracing the internal execution of fraud proof verifications might find this behavior relevant, as they will see a call to the zero address where they would have expected a call to a contract under construction.  It should be noted that both scenarios described were raised as issues of Medium severity in our November 2020 report as [M03] Call to contract in construction results in call to the zero address and [M04] Calls to abstracted EOA accounts may result in Out of Gas error. Taking into account that we did not receive specific feedback on those issues, and that the behavior of the system remains, we assume that the Optimism team has acknowledged these scenarios and consider them intended. Therefore, we are only describing them in this informative note for completeness, and to suggest explicitly documenting them either with inline comments, docstrings, external developer documentation or system specification if the Optimism team considers it appropriate.  [N20] Repeated authentication logic in State Manager  The isAuthenticated function of the OVM_StateManager contract can be used to validate whether a given address is allowed to write into the contracts state. The same functionality is implemented in the authenticated modifier.  To avoid code repetition, consider modifying the authenticated modifier so that it calls the isAuthenticated function to determine if the caller is authenticated. This note can be disregarded should the current implementation be more favorable in terms of gas costs.  [N21] Not using available bytes32 utilities  76,  86,  100 and  110 of  Lib_Bytes32Utils library.  [N22] Missing operations in Execution Manager wrapper library  The Lib_SafeExecutionManagerWrapper library offers functions to facilitate writing OVM safe code that can be compiled using the standard Solidity compiler. However, it is missing a number of wrappers for OVM operations, namely:  ovmCREATE2  ovmSTATICCALL  ovmEXTCODEHASH  ovmEXTCODECOPY  ovmL1TXORIGIN  ovmL1QUEUEORIGIN  ovmGASLIMIT  ovmNUMBER  ovmTIMESTAMP  Consider including wrapper functions for them in the Lib_SafeExecutionManagerWrapper library.  [N23] Unnecessary standalone contract to relay multiple messages  The OVM_L1MultiMessageRelayer contract implements a single function batchRelayMessages that forwards multiple cross-domain messages to the OVM_L1CrossDomainMessenger contract. To favor simplicity, this function could be moved to the OVM_L1CrossDomainMessenger contract (where it should be marked with the onlyRelayer modifier).  [N24] Data returned by relayed message is ignored  relayMessage function of the  ovmCALL to the messages target. While the calls success flag is  validated to determine whether the message can be considered successful, the returned data is never stored nor logged. As a consequence, relevant returned data from relayed messages will not be accessible after a message is relayed. The described behavior also occurs in the  relayMessage function of the  Should this be the intended behavior of the relayMessage functions, consider documenting it in the functions docstrings. Otherwise, consider including a mechanism to retrieve the returned data of relayed messages, which could include storing the data in storage, or logging it using an event.  [N25] Duplicated code in cross-domain messenger contracts  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts behave in a similar way and share a non-trivial amount of duplicated logic.  To reduce code duplication and favor reusability, consider abstracting away repeated logic to an internal function of the Abs_BaseCrossDomainMessenger parent contract.  [N26] Duplicated code for memory copy utility  The _copy function of the Lib_RLPReader library and _memcpy function of the Lib_RLPWriter serve a similar purpose: copying pieces of memory to other locations. To reduce duplicated logic and ease maintenance, consider defining a single memory copy utility function, and reusing it throughout the code base. Alternatively, to favor a simpler implementation, consider using the identity precompile contract at address 0x0000000000000000000000000000000000000004 to copy pieces of memory.  [N27] Redundant check when proving contract state  proveContractState function of the  two conditions. The first condition,  hasAccount, checks whether  the accounts code hash is non-zero. The second condition,  hasEmptyAccount, checks that  the accounts code hash matches the EMPTY_ACCOUNT_CODE_HASH hash.  Since the EMPTY_ACCOUNT_CODE_HASH is non-zero, the second condition implies the first one. Therefore, consider removing the call to hasAccount.  [N28] Base contract not marked as abstract  Contracts that are not intended to be instantiated directly, such as OVM_CrossDomainEnabled, should be marked as abstract to favor readability and avoid unintended usage.  [N29] Inconsistent coding style  Some instances of inconsistent coding style were identified in the code base. Specifically:  While most internal and private functions explicitly denote their visibility by prepending their names with an underscore, functions getCrossDomainMessenger and sendCrossDomainMessage of the OVM_CrossDomainEnabled contract fail to do so.  To favor readability, consider always following a consistent style throughout the code base. We suggest using Soliditys Style Guide as a reference.  [N30] Lack of explicit visibility in state variables  The following state variables and constants are implicitly using the default visibility.  In the OVM_ECDSAContractAccount contract:  The EXECUTION_VALIDATION_GAS_OVERHEAD and ETH_ERC20_ADDRESS constants.  In the OVM_ProxyEOA contract:  The IMPLEMENTATION_KEY constant.  In the Abs_L2DepositedToken contract:  The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant  To favor readability, consider explicitly declaring the visibility of all state variables and constants.  [N31] Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.  The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.  In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.  [N32] Implicit casting operations  The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when its passed to the call to _sendXDomainMessage.  The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transactions nonce matches the expected one.  For added readability, consider making casting operations explicit where possible.  Conclusions  4 critical and 4 high severity issues were found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-lib_merkletrie.sol:", "labels": ["OpenZeppelin"]}, {"title": "In line 275, \u201c31\u201d should say \u201c32\u201d.", "body": "In line 275, \u201c31\u201d should say \u201c32\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-line-275,-\u201c31\u201d-should-say-\u201c32\u201d.", "labels": ["OpenZeppelin"]}, {"title": "In Lib_Math.sol:", "body": "In Lib_Math.sol:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-lib_math.sol:", "labels": ["OpenZeppelin"]}, {"title": "In line 14, \u201cminumum\u201d should say \u201cminimum\u201d.", "body": "In line 14, \u201cminumum\u201d should say \u201cminimum\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-line-14,-\u201cminumum\u201d-should-say-\u201cminimum\u201d.", "labels": ["OpenZeppelin"]}, {"title": "In iOVM_ChainStorageContainer.sol:", "body": "In iOVM_ChainStorageContainer.sol:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-iovm_chainstoragecontainer.sol:", "labels": ["OpenZeppelin"]}, {"title": "In line 104, \u201cmeaing\u201d should say \u201cmeaning\u201d.", "body": "In line 104, \u201cmeaing\u201d should say \u201cmeaning\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-line-104,-\u201cmeaing\u201d-should-say-\u201cmeaning\u201d.", "labels": ["OpenZeppelin"]}, {"title": "In OVM_CanonicalTransactionChain.sol:", "body": "In line 344, minnet should say mainnet.  In line 973, que should say queue.  In line 1011, elemtent should say element.  In OVM_CrossDomainEnabled.sol:  In line 14, recieve should say receive.  In OVM_L2ToL1MessagePasser.sol:  In line 9, facilitates is misspelled. It also includes the repeated phrase of the.  In Abs_L1TokenGateway.sol:  In line 128, recipients is misspelled.  In OVM_L1ERC20Gateway.sol:  In line 18, takes should say take.  In OVM_ExecutionManager.sol:  In line 168, awlways should say always.  In lines 191, 202, 213, and 1701, minnet should say mainnet.  In lines 1804, 1809, 1814, unnecessary the SSTORE should say the unnecessary SSTORE.  In OVM_ECDSAContract.sol:  In lines 142, transfer is misspelled.  In OVM_FraudVerifier.sol:  In line 210, minnet should say mainnet.  In Lib_RLPReader.sol:  In lines 384 and 410, a address should say an address.  [N12] Negative overflow of uint256 type  To favor readability, in line 1890 of OVM_ExecutionManager.sol consider replacing the negative overflow operation of an uint256 value with the expression type(uint256).max.  [N13] Unnecessary return statement  Consider removing the return keyword from the setGlobalMetadata function of the OVM_ChainStorageContainer contract, as the setExtraData function of the Lib_RingBuffer library being called does not return any value.  [N14] Unused imports  To improve readability and avoid confusion, consider removing the following unused imports.  In the OVM_StateCommitmentChain contract, the iOVM_FraudVerifier interface.  In the OVM_ExecutionManager contract, the OVM_ECDSAContractAccount and OVM_DeployerWhitelist contracts.  In the OVM_L2DepositedERC20 contract, the iOVM_L1TokenGateway interface.  In the OVM_ETH contract, the Lib_AddressResolver contract.  In the OVM_StateTransitioner contract, the iOVM_BondManager interface.  In the Lib_OVMCodec library, the Lib_BytesUtils library.  [N15] Unused events  The iOVM_L2ToL1MessagePasser interface defines the L2ToL1Message event, which is never emitted in the child contract OVM_L2ToL1MessagePasser.  To avoid confusion and favor simplicity, consider removing all definitions of events that are not expected to be emitted.  [N16] Unused functions  Functions toUint24, toUint8 and toAddress of the Lib_BytesUtils library are never used, and can therefore be removed.  [N17] Transaction hashes might not be unique in the Canonical Transaction Chain  The enqueue function of the OVM_CanonicalTransactionChain contract constructs transaction hashes with the callers address, the L2 target, the transactions gas limit and its data. Since this is not enough to ensure uniqueness of hashes (that is, it could be possible to construct two transactions that result in the same hash), these transactions are instead identified by their position in the queue. However, this internal subtlety of the Canonical Transaction Chain is not explicitly documented, and might lead to errors in off-chain services tracking transactions in the Canonical Transaction Chain, since transaction hashes are commonly assumed to be unique.  Consider including developer-friendly documentation stating how transaction hashes in the Canonical Transaction Chain are constructed, and how they should not be relied on to uniquely identify transactions.  [N18] Cross-domain messengers can be impersonated  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts allow relaying arbitrary cross-domain messages. Ultimately, this means that it is possible for anyone to make these contracts execute arbitrary calls (see calls hereand here). Therefore, there are two scenarios developers should consider when building and integrating bridges between layer 1 and 2. Aiming for simplicity, in the following we explain both scenarios starting on layer 1  yet a similar behavior can be seen in the opposite direction.  call any target address with arbitrary data. Therefore, layer 2 accounts should be aware that they can receive arbitrary calls from the  ERC1820Registry contract. It must be noted that during the call from the  xDomainMessageSender functionto inspect the address of the layer 1 account that originated the message.  Going further, now into the second case, a subtle behavior of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessengercontracts allows anyone not only to send messages via these contracts, but also to originate messages from them. The execution steps to originate an L2-to-L1 message from the OVM_L2CrossDomainMessenger would develop as follows:  A user-controlled account sends a message from layer 1 calling the sendMessage function of the OVM_L1CrossDomainMessengercontract. The target of this message should be the OVM_L2CrossDomainMessenger contract, and the message should be an abi-encoded call to the targets sendMessage function, including the arbitrary data the user wants the OVM_L2CrossDomainMessengercontract to send to layer 1.  The L1-to-L2 message sent by the user is enqueued in the Canonical Transaction Chain as a regular OVM transaction.  In layer 2, the relayMessage function of the OVM_L2CrossDomainMessenger contract is called to relay the users message. Following how the message was constructed, this will trigger a call from the OVM_L2CrossDomainMessenger contract to its own sendMessagefunction. In other words, the OVM_L2CrossDomainMessenger contract sends a message from L2 to L1 with target and data arbitrarily decided by the user in (1).  After the fraud proof window is over, the L2-to-L1 message sent by the OVM_L2CrossDomainMessenger contract is relayed in layer 1.  The target contract in layer 1 receives a message with the user-controlled data. Should the target address query the xDomainMessageSender function to inspect the address of the layer 2 account that originated the message, it would receive the address of the OVM_L2CrossDomainMessenger contract.  The actual consequences of the described behaviors will ultimately depend on the contracts receiving these arbitrary calls, and that is why we are only reporting this as an informative note. Developers should be fully aware of these scenarios and be ready to implement the necessary defensive measures to mitigate impact on their systems. We suggest the Optimism team to include specific developer-friendly documentation highlighting this note, so as to raise awareness of the subtleties of cross-domain communication.  [N19] Subtleties of calling contracts under construction and abstracted EOAs  In the EVM, calling accounts with no executable code (that is, contracts during construction or externally owned accounts) results in an immediate halt with a STOP opcode (see subsection 9.4 of the yellow paper), and the call is considered successful. In the OVM, this behavior is not exactly replicated, due to some fundamental differences between the EVM and the OVM.  Calling abstracted EOAs  The OVM offers native account abstraction. In other words, the only type of account is smart contracts, and the closest one can get to the behavior of EOAs is implemented in the OVM_ECDSAContractAccount contract. As a result, calling an EOA is translated to calling a specific instance of this contract, and any call that does not match the selector of the execute function will result in an out-of-gas error.  Calling contracts under construction  _callContract function of the  using the _getAccountEthAddress function. This results in a call to the  getAccountEthAddress function of the  first initialized as pending without setting its L1 address, then  created, and  finally committed. Therefore any address resolution before the account is committed will resolve to the zero address. The call to the zero address will be successful, and execution will simply continue. Off-chain services tracing the internal execution of fraud proof verifications might find this behavior relevant, as they will see a call to the zero address where they would have expected a call to a contract under construction.  It should be noted that both scenarios described were raised as issues of Medium severity in our November 2020 report as [M03] Call to contract in construction results in call to the zero address and [M04] Calls to abstracted EOA accounts may result in Out of Gas error. Taking into account that we did not receive specific feedback on those issues, and that the behavior of the system remains, we assume that the Optimism team has acknowledged these scenarios and consider them intended. Therefore, we are only describing them in this informative note for completeness, and to suggest explicitly documenting them either with inline comments, docstrings, external developer documentation or system specification if the Optimism team considers it appropriate.  [N20] Repeated authentication logic in State Manager  The isAuthenticated function of the OVM_StateManager contract can be used to validate whether a given address is allowed to write into the contracts state. The same functionality is implemented in the authenticated modifier.  To avoid code repetition, consider modifying the authenticated modifier so that it calls the isAuthenticated function to determine if the caller is authenticated. This note can be disregarded should the current implementation be more favorable in terms of gas costs.  [N21] Not using available bytes32 utilities  76,  86,  100 and  110 of  Lib_Bytes32Utils library.  [N22] Missing operations in Execution Manager wrapper library  The Lib_SafeExecutionManagerWrapper library offers functions to facilitate writing OVM safe code that can be compiled using the standard Solidity compiler. However, it is missing a number of wrappers for OVM operations, namely:  ovmCREATE2  ovmSTATICCALL  ovmEXTCODEHASH  ovmEXTCODECOPY  ovmL1TXORIGIN  ovmL1QUEUEORIGIN  ovmGASLIMIT  ovmNUMBER  ovmTIMESTAMP  Consider including wrapper functions for them in the Lib_SafeExecutionManagerWrapper library.  [N23] Unnecessary standalone contract to relay multiple messages  The OVM_L1MultiMessageRelayer contract implements a single function batchRelayMessages that forwards multiple cross-domain messages to the OVM_L1CrossDomainMessenger contract. To favor simplicity, this function could be moved to the OVM_L1CrossDomainMessenger contract (where it should be marked with the onlyRelayer modifier).  [N24] Data returned by relayed message is ignored  relayMessage function of the  ovmCALL to the messages target. While the calls success flag is  validated to determine whether the message can be considered successful, the returned data is never stored nor logged. As a consequence, relevant returned data from relayed messages will not be accessible after a message is relayed. The described behavior also occurs in the  relayMessage function of the  Should this be the intended behavior of the relayMessage functions, consider documenting it in the functions docstrings. Otherwise, consider including a mechanism to retrieve the returned data of relayed messages, which could include storing the data in storage, or logging it using an event.  [N25] Duplicated code in cross-domain messenger contracts  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts behave in a similar way and share a non-trivial amount of duplicated logic.  To reduce code duplication and favor reusability, consider abstracting away repeated logic to an internal function of the Abs_BaseCrossDomainMessenger parent contract.  [N26] Duplicated code for memory copy utility  The _copy function of the Lib_RLPReader library and _memcpy function of the Lib_RLPWriter serve a similar purpose: copying pieces of memory to other locations. To reduce duplicated logic and ease maintenance, consider defining a single memory copy utility function, and reusing it throughout the code base. Alternatively, to favor a simpler implementation, consider using the identity precompile contract at address 0x0000000000000000000000000000000000000004 to copy pieces of memory.  [N27] Redundant check when proving contract state  proveContractState function of the  two conditions. The first condition,  hasAccount, checks whether  the accounts code hash is non-zero. The second condition,  hasEmptyAccount, checks that  the accounts code hash matches the EMPTY_ACCOUNT_CODE_HASH hash.  Since the EMPTY_ACCOUNT_CODE_HASH is non-zero, the second condition implies the first one. Therefore, consider removing the call to hasAccount.  [N28] Base contract not marked as abstract  Contracts that are not intended to be instantiated directly, such as OVM_CrossDomainEnabled, should be marked as abstract to favor readability and avoid unintended usage.  [N29] Inconsistent coding style  Some instances of inconsistent coding style were identified in the code base. Specifically:  While most internal and private functions explicitly denote their visibility by prepending their names with an underscore, functions getCrossDomainMessenger and sendCrossDomainMessage of the OVM_CrossDomainEnabled contract fail to do so.  To favor readability, consider always following a consistent style throughout the code base. We suggest using Soliditys Style Guide as a reference.  [N30] Lack of explicit visibility in state variables  The following state variables and constants are implicitly using the default visibility.  In the OVM_ECDSAContractAccount contract:  The EXECUTION_VALIDATION_GAS_OVERHEAD and ETH_ERC20_ADDRESS constants.  In the OVM_ProxyEOA contract:  The IMPLEMENTATION_KEY constant.  In the Abs_L2DepositedToken contract:  The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant  To favor readability, consider explicitly declaring the visibility of all state variables and constants.  [N31] Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.  The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.  In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.  [N32] Implicit casting operations  The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when its passed to the call to _sendXDomainMessage.  The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transactions nonce matches the expected one.  For added readability, consider making casting operations explicit where possible.  Conclusions  4 critical and 4 high severity issues were found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-ovm_canonicaltransactionchain.sol:", "labels": ["OpenZeppelin"]}, {"title": "In line 344, \u201cminnet\u201d should say \u201cmainnet\u201d.", "body": "In line 344, \u201cminnet\u201d should say \u201cmainnet\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-line-344,-\u201cminnet\u201d-should-say-\u201cmainnet\u201d.", "labels": ["OpenZeppelin"]}, {"title": "In line 973, \u201cque\u201d should say \u201cqueue\u201d.", "body": "In line 973, \u201cque\u201d should say \u201cqueue\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-line-973,-\u201cque\u201d-should-say-\u201cqueue\u201d.", "labels": ["OpenZeppelin"]}, {"title": "In line 1011, \u201celemtent\u201d should say \u201celement\u201d.", "body": "In line 1011, \u201celemtent\u201d should say \u201celement\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-line-1011,-\u201celemtent\u201d-should-say-\u201celement\u201d.", "labels": ["OpenZeppelin"]}, {"title": "In OVM_CrossDomainEnabled.sol:", "body": "In OVM_CrossDomainEnabled.sol:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-ovm_crossdomainenabled.sol:", "labels": ["OpenZeppelin"]}, {"title": "In line 14, \u201crecieve\u201d should say \u201creceive\u201d.", "body": "In line 14, \u201crecieve\u201d should say \u201creceive\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-line-14,-\u201crecieve\u201d-should-say-\u201creceive\u201d.", "labels": ["OpenZeppelin"]}, {"title": "In OVM_L2ToL1MessagePasser.sol:", "body": "In OVM_L2ToL1MessagePasser.sol:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-ovm_l2tol1messagepasser.sol:", "labels": ["OpenZeppelin"]}, {"title": "In line 9, \u201cfacilitates\u201d is misspelled. It also includes the repeated phrase \u201cof the\u201d.", "body": "In line 9, \u201cfacilitates\u201d is misspelled. It also includes the repeated phrase \u201cof the\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-line-9,-\u201cfacilitates\u201d-is-misspelled.-it-also-includes-the-repeated-phrase-\u201cof-the\u201d.", "labels": ["OpenZeppelin"]}, {"title": "In Abs_L1TokenGateway.sol:", "body": "In Abs_L1TokenGateway.sol:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-abs_l1tokengateway.sol:", "labels": ["OpenZeppelin"]}, {"title": "In line 128, \u201crecipient\u2019s\u201d is misspelled.", "body": "In line 128, \u201crecipient\u2019s\u201d is misspelled.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-line-128,-\u201crecipient\u2019s\u201d-is-misspelled.", "labels": ["OpenZeppelin"]}, {"title": "In OVM_L1ERC20Gateway.sol:", "body": "In OVM_L1ERC20Gateway.sol:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-ovm_l1erc20gateway.sol:", "labels": ["OpenZeppelin"]}, {"title": "In line 18, \u201ctakes\u201d should say \u201ctake\u201d.", "body": "In line 18, \u201ctakes\u201d should say \u201ctake\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-line-18,-\u201ctakes\u201d-should-say-\u201ctake\u201d.", "labels": ["OpenZeppelin"]}, {"title": "In OVM_ExecutionManager.sol:", "body": "In line 168, awlways should say always.  In lines 191, 202, 213, and 1701, minnet should say mainnet.  In lines 1804, 1809, 1814, unnecessary the SSTORE should say the unnecessary SSTORE.  In OVM_ECDSAContract.sol:  In lines 142, transfer is misspelled.  In OVM_FraudVerifier.sol:  In line 210, minnet should say mainnet.  In Lib_RLPReader.sol:  In lines 384 and 410, a address should say an address.  [N12] Negative overflow of uint256 type  To favor readability, in line 1890 of OVM_ExecutionManager.sol consider replacing the negative overflow operation of an uint256 value with the expression type(uint256).max.  [N13] Unnecessary return statement  Consider removing the return keyword from the setGlobalMetadata function of the OVM_ChainStorageContainer contract, as the setExtraData function of the Lib_RingBuffer library being called does not return any value.  [N14] Unused imports  To improve readability and avoid confusion, consider removing the following unused imports.  In the OVM_StateCommitmentChain contract, the iOVM_FraudVerifier interface.  In the OVM_ExecutionManager contract, the OVM_ECDSAContractAccount and OVM_DeployerWhitelist contracts.  In the OVM_L2DepositedERC20 contract, the iOVM_L1TokenGateway interface.  In the OVM_ETH contract, the Lib_AddressResolver contract.  In the OVM_StateTransitioner contract, the iOVM_BondManager interface.  In the Lib_OVMCodec library, the Lib_BytesUtils library.  [N15] Unused events  The iOVM_L2ToL1MessagePasser interface defines the L2ToL1Message event, which is never emitted in the child contract OVM_L2ToL1MessagePasser.  To avoid confusion and favor simplicity, consider removing all definitions of events that are not expected to be emitted.  [N16] Unused functions  Functions toUint24, toUint8 and toAddress of the Lib_BytesUtils library are never used, and can therefore be removed.  [N17] Transaction hashes might not be unique in the Canonical Transaction Chain  The enqueue function of the OVM_CanonicalTransactionChain contract constructs transaction hashes with the callers address, the L2 target, the transactions gas limit and its data. Since this is not enough to ensure uniqueness of hashes (that is, it could be possible to construct two transactions that result in the same hash), these transactions are instead identified by their position in the queue. However, this internal subtlety of the Canonical Transaction Chain is not explicitly documented, and might lead to errors in off-chain services tracking transactions in the Canonical Transaction Chain, since transaction hashes are commonly assumed to be unique.  Consider including developer-friendly documentation stating how transaction hashes in the Canonical Transaction Chain are constructed, and how they should not be relied on to uniquely identify transactions.  [N18] Cross-domain messengers can be impersonated  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts allow relaying arbitrary cross-domain messages. Ultimately, this means that it is possible for anyone to make these contracts execute arbitrary calls (see calls hereand here). Therefore, there are two scenarios developers should consider when building and integrating bridges between layer 1 and 2. Aiming for simplicity, in the following we explain both scenarios starting on layer 1  yet a similar behavior can be seen in the opposite direction.  call any target address with arbitrary data. Therefore, layer 2 accounts should be aware that they can receive arbitrary calls from the  ERC1820Registry contract. It must be noted that during the call from the  xDomainMessageSender functionto inspect the address of the layer 1 account that originated the message.  Going further, now into the second case, a subtle behavior of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessengercontracts allows anyone not only to send messages via these contracts, but also to originate messages from them. The execution steps to originate an L2-to-L1 message from the OVM_L2CrossDomainMessenger would develop as follows:  A user-controlled account sends a message from layer 1 calling the sendMessage function of the OVM_L1CrossDomainMessengercontract. The target of this message should be the OVM_L2CrossDomainMessenger contract, and the message should be an abi-encoded call to the targets sendMessage function, including the arbitrary data the user wants the OVM_L2CrossDomainMessengercontract to send to layer 1.  The L1-to-L2 message sent by the user is enqueued in the Canonical Transaction Chain as a regular OVM transaction.  In layer 2, the relayMessage function of the OVM_L2CrossDomainMessenger contract is called to relay the users message. Following how the message was constructed, this will trigger a call from the OVM_L2CrossDomainMessenger contract to its own sendMessagefunction. In other words, the OVM_L2CrossDomainMessenger contract sends a message from L2 to L1 with target and data arbitrarily decided by the user in (1).  After the fraud proof window is over, the L2-to-L1 message sent by the OVM_L2CrossDomainMessenger contract is relayed in layer 1.  The target contract in layer 1 receives a message with the user-controlled data. Should the target address query the xDomainMessageSender function to inspect the address of the layer 2 account that originated the message, it would receive the address of the OVM_L2CrossDomainMessenger contract.  The actual consequences of the described behaviors will ultimately depend on the contracts receiving these arbitrary calls, and that is why we are only reporting this as an informative note. Developers should be fully aware of these scenarios and be ready to implement the necessary defensive measures to mitigate impact on their systems. We suggest the Optimism team to include specific developer-friendly documentation highlighting this note, so as to raise awareness of the subtleties of cross-domain communication.  [N19] Subtleties of calling contracts under construction and abstracted EOAs  In the EVM, calling accounts with no executable code (that is, contracts during construction or externally owned accounts) results in an immediate halt with a STOP opcode (see subsection 9.4 of the yellow paper), and the call is considered successful. In the OVM, this behavior is not exactly replicated, due to some fundamental differences between the EVM and the OVM.  Calling abstracted EOAs  The OVM offers native account abstraction. In other words, the only type of account is smart contracts, and the closest one can get to the behavior of EOAs is implemented in the OVM_ECDSAContractAccount contract. As a result, calling an EOA is translated to calling a specific instance of this contract, and any call that does not match the selector of the execute function will result in an out-of-gas error.  Calling contracts under construction  _callContract function of the  using the _getAccountEthAddress function. This results in a call to the  getAccountEthAddress function of the  first initialized as pending without setting its L1 address, then  created, and  finally committed. Therefore any address resolution before the account is committed will resolve to the zero address. The call to the zero address will be successful, and execution will simply continue. Off-chain services tracing the internal execution of fraud proof verifications might find this behavior relevant, as they will see a call to the zero address where they would have expected a call to a contract under construction.  It should be noted that both scenarios described were raised as issues of Medium severity in our November 2020 report as [M03] Call to contract in construction results in call to the zero address and [M04] Calls to abstracted EOA accounts may result in Out of Gas error. Taking into account that we did not receive specific feedback on those issues, and that the behavior of the system remains, we assume that the Optimism team has acknowledged these scenarios and consider them intended. Therefore, we are only describing them in this informative note for completeness, and to suggest explicitly documenting them either with inline comments, docstrings, external developer documentation or system specification if the Optimism team considers it appropriate.  [N20] Repeated authentication logic in State Manager  The isAuthenticated function of the OVM_StateManager contract can be used to validate whether a given address is allowed to write into the contracts state. The same functionality is implemented in the authenticated modifier.  To avoid code repetition, consider modifying the authenticated modifier so that it calls the isAuthenticated function to determine if the caller is authenticated. This note can be disregarded should the current implementation be more favorable in terms of gas costs.  [N21] Not using available bytes32 utilities  76,  86,  100 and  110 of  Lib_Bytes32Utils library.  [N22] Missing operations in Execution Manager wrapper library  The Lib_SafeExecutionManagerWrapper library offers functions to facilitate writing OVM safe code that can be compiled using the standard Solidity compiler. However, it is missing a number of wrappers for OVM operations, namely:  ovmCREATE2  ovmSTATICCALL  ovmEXTCODEHASH  ovmEXTCODECOPY  ovmL1TXORIGIN  ovmL1QUEUEORIGIN  ovmGASLIMIT  ovmNUMBER  ovmTIMESTAMP  Consider including wrapper functions for them in the Lib_SafeExecutionManagerWrapper library.  [N23] Unnecessary standalone contract to relay multiple messages  The OVM_L1MultiMessageRelayer contract implements a single function batchRelayMessages that forwards multiple cross-domain messages to the OVM_L1CrossDomainMessenger contract. To favor simplicity, this function could be moved to the OVM_L1CrossDomainMessenger contract (where it should be marked with the onlyRelayer modifier).  [N24] Data returned by relayed message is ignored  relayMessage function of the  ovmCALL to the messages target. While the calls success flag is  validated to determine whether the message can be considered successful, the returned data is never stored nor logged. As a consequence, relevant returned data from relayed messages will not be accessible after a message is relayed. The described behavior also occurs in the  relayMessage function of the  Should this be the intended behavior of the relayMessage functions, consider documenting it in the functions docstrings. Otherwise, consider including a mechanism to retrieve the returned data of relayed messages, which could include storing the data in storage, or logging it using an event.  [N25] Duplicated code in cross-domain messenger contracts  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts behave in a similar way and share a non-trivial amount of duplicated logic.  To reduce code duplication and favor reusability, consider abstracting away repeated logic to an internal function of the Abs_BaseCrossDomainMessenger parent contract.  [N26] Duplicated code for memory copy utility  The _copy function of the Lib_RLPReader library and _memcpy function of the Lib_RLPWriter serve a similar purpose: copying pieces of memory to other locations. To reduce duplicated logic and ease maintenance, consider defining a single memory copy utility function, and reusing it throughout the code base. Alternatively, to favor a simpler implementation, consider using the identity precompile contract at address 0x0000000000000000000000000000000000000004 to copy pieces of memory.  [N27] Redundant check when proving contract state  proveContractState function of the  two conditions. The first condition,  hasAccount, checks whether  the accounts code hash is non-zero. The second condition,  hasEmptyAccount, checks that  the accounts code hash matches the EMPTY_ACCOUNT_CODE_HASH hash.  Since the EMPTY_ACCOUNT_CODE_HASH is non-zero, the second condition implies the first one. Therefore, consider removing the call to hasAccount.  [N28] Base contract not marked as abstract  Contracts that are not intended to be instantiated directly, such as OVM_CrossDomainEnabled, should be marked as abstract to favor readability and avoid unintended usage.  [N29] Inconsistent coding style  Some instances of inconsistent coding style were identified in the code base. Specifically:  While most internal and private functions explicitly denote their visibility by prepending their names with an underscore, functions getCrossDomainMessenger and sendCrossDomainMessage of the OVM_CrossDomainEnabled contract fail to do so.  To favor readability, consider always following a consistent style throughout the code base. We suggest using Soliditys Style Guide as a reference.  [N30] Lack of explicit visibility in state variables  The following state variables and constants are implicitly using the default visibility.  In the OVM_ECDSAContractAccount contract:  The EXECUTION_VALIDATION_GAS_OVERHEAD and ETH_ERC20_ADDRESS constants.  In the OVM_ProxyEOA contract:  The IMPLEMENTATION_KEY constant.  In the Abs_L2DepositedToken contract:  The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant  To favor readability, consider explicitly declaring the visibility of all state variables and constants.  [N31] Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.  The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.  In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.  [N32] Implicit casting operations  The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when its passed to the call to _sendXDomainMessage.  The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transactions nonce matches the expected one.  For added readability, consider making casting operations explicit where possible.  Conclusions  4 critical and 4 high severity issues were found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-ovm_executionmanager.sol:", "labels": ["OpenZeppelin"]}, {"title": "In line 168, \u201cawlways\u201d should say \u201calways\u201d.", "body": "In line 168, \u201cawlways\u201d should say \u201calways\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-line-168,-\u201cawlways\u201d-should-say-\u201calways\u201d.", "labels": ["OpenZeppelin"]}, {"title": "In lines 191, 202, 213, and 1701, \u201cminnet\u201d should say \u201cmainnet\u201d.", "body": "In lines 191, 202, 213, and 1701, \u201cminnet\u201d should say \u201cmainnet\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-lines-191,-202,-213,-and-1701,-\u201cminnet\u201d-should-say-\u201cmainnet\u201d.", "labels": ["OpenZeppelin"]}, {"title": "In lines 1804, 1809, 1814, \u201cunnecessary the SSTORE\u201d should say \u201cthe unnecessary SSTORE\u201d.", "body": "In lines 1804, 1809, 1814, \u201cunnecessary the SSTORE\u201d should say \u201cthe unnecessary SSTORE\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-lines-1804,-1809,-1814,-\u201cunnecessary-the-sstore\u201d-should-say-\u201cthe-unnecessary-sstore\u201d.", "labels": ["OpenZeppelin"]}, {"title": "In OVM_ECDSAContract.sol:", "body": "In OVM_ECDSAContract.sol:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-ovm_ecdsacontract.sol:", "labels": ["OpenZeppelin"]}, {"title": "In lines 142, \u201ctransfer\u201d is misspelled.", "body": "In lines 142, \u201ctransfer\u201d is misspelled.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-lines-142,-\u201ctransfer\u201d-is-misspelled.", "labels": ["OpenZeppelin"]}, {"title": "In OVM_FraudVerifier.sol:", "body": "In OVM_FraudVerifier.sol:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-ovm_fraudverifier.sol:", "labels": ["OpenZeppelin"]}, {"title": "In line 210, \u201cminnet\u201d should say \u201cmainnet\u201d.", "body": "In line 210, \u201cminnet\u201d should say \u201cmainnet\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-line-210,-\u201cminnet\u201d-should-say-\u201cmainnet\u201d.", "labels": ["OpenZeppelin"]}, {"title": "In Lib_RLPReader.sol:", "body": "In Lib_RLPReader.sol:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-lib_rlpreader.sol:", "labels": ["OpenZeppelin"]}, {"title": "In lines 384 and 410, \u201ca address\u201d should say \u201can address\u201d.", "body": "In lines 384 and 410, \u201ca address\u201d should say \u201can address\u201d.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-lines-384-and-410,-\u201ca-address\u201d-should-say-\u201can-address\u201d.", "labels": ["OpenZeppelin"]}, {"title": "[N12] Negative overflow of uint256 type", "body": "[N12] Negative overflow of uint256 type", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n12]-negative-overflow-of-uint256-type", "labels": ["OpenZeppelin"]}, {"title": "To favor readability, in line 1890 of OVM_ExecutionManager.sol consider replacing the negative overflow operation of an uint256 value with the expression type(uint256).max.", "body": "To favor readability, in line 1890 of OVM_ExecutionManager.sol consider replacing the negative overflow operation of an uint256 value with the expression type(uint256).max.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#to-favor-readability,-in-line-1890-of-ovm_executionmanager.sol-consider-replacing-the-negative-overflow-operation-of-an-uint256-value-with-the-expression-type(uint256).max.", "labels": ["OpenZeppelin"]}, {"title": "[N13] Unnecessary return statement", "body": "[N13] Unnecessary return statement", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n13]-unnecessary-return-statement", "labels": ["OpenZeppelin"]}, {"title": "Consider removing the return keyword from the setGlobalMetadata function of the OVM_ChainStorageContainer contract, as the setExtraData function of the Lib_RingBuffer library being called does not return any value.", "body": "Consider removing the return keyword from the setGlobalMetadata function of the OVM_ChainStorageContainer contract, as the setExtraData function of the Lib_RingBuffer library being called does not return any value.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#consider-removing-the-return-keyword-from-the-setglobalmetadata-function-of-the-ovm_chainstoragecontainer-contract,-as-the-setextradata-function-of-the-lib_ringbuffer-library-being-called-does-not-return-any-value.", "labels": ["OpenZeppelin"]}, {"title": "[N14] Unused imports", "body": "[N14] Unused imports", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n14]-unused-imports", "labels": ["OpenZeppelin"]}, {"title": "To improve readability and avoid confusion, consider removing the following unused imports.", "body": "To improve readability and avoid confusion, consider removing the following unused imports.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#to-improve-readability-and-avoid-confusion,-consider-removing-the-following-unused-imports.", "labels": ["OpenZeppelin"]}, {"title": "In the OVM_StateCommitmentChain contract, the iOVM_FraudVerifier interface.", "body": "In the OVM_StateCommitmentChain contract, the iOVM_FraudVerifier interface.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-ovm_statecommitmentchain-contract,-the-iovm_fraudverifier-interface.", "labels": ["OpenZeppelin"]}, {"title": "In the OVM_ExecutionManager contract, the OVM_ECDSAContractAccount and OVM_DeployerWhitelist contracts.", "body": "In the OVM_ExecutionManager contract, the OVM_ECDSAContractAccount and OVM_DeployerWhitelist contracts.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-ovm_executionmanager-contract,-the-ovm_ecdsacontractaccount-and-ovm_deployerwhitelist-contracts.", "labels": ["OpenZeppelin"]}, {"title": "In the OVM_L2DepositedERC20 contract, the iOVM_L1TokenGateway interface.", "body": "In the OVM_L2DepositedERC20 contract, the iOVM_L1TokenGateway interface.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-ovm_l2depositederc20-contract,-the-iovm_l1tokengateway-interface.", "labels": ["OpenZeppelin"]}, {"title": "In the OVM_ETH contract, the Lib_AddressResolver contract.", "body": "In the OVM_ETH contract, the Lib_AddressResolver contract.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-ovm_eth-contract,-the-lib_addressresolver-contract.", "labels": ["OpenZeppelin"]}, {"title": "In the OVM_StateTransitioner contract, the iOVM_BondManager interface.", "body": "In the OVM_StateTransitioner contract, the iOVM_BondManager interface.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-ovm_statetransitioner-contract,-the-iovm_bondmanager-interface.", "labels": ["OpenZeppelin"]}, {"title": "In the Lib_OVMCodec library, the Lib_BytesUtils library.", "body": "In the Lib_OVMCodec library, the Lib_BytesUtils library.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-lib_ovmcodec-library,-the-lib_bytesutils-library.", "labels": ["OpenZeppelin"]}, {"title": "[N15] Unused events", "body": "[N15] Unused events", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n15]-unused-events", "labels": ["OpenZeppelin"]}, {"title": "The iOVM_L2ToL1MessagePasser interface defines the L2ToL1Message event, which is never emitted in the child contract OVM_L2ToL1MessagePasser.", "body": "The iOVM_L2ToL1MessagePasser interface defines the L2ToL1Message event, which is never emitted in the child contract OVM_L2ToL1MessagePasser.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-iovm_l2tol1messagepasser-interface-defines-the-l2tol1message-event,-which-is-never-emitted-in-the-child-contract-ovm_l2tol1messagepasser.", "labels": ["OpenZeppelin"]}, {"title": "To avoid confusion and favor simplicity, consider removing all definitions of events that are not expected to be emitted.", "body": "To avoid confusion and favor simplicity, consider removing all definitions of events that are not expected to be emitted.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#to-avoid-confusion-and-favor-simplicity,-consider-removing-all-definitions-of-events-that-are-not-expected-to-be-emitted.", "labels": ["OpenZeppelin"]}, {"title": "[N16] Unused functions", "body": "[N16] Unused functions", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n16]-unused-functions", "labels": ["OpenZeppelin"]}, {"title": "Functions toUint24, toUint8 and toAddress of the Lib_BytesUtils library are never used, and can therefore be removed.", "body": "Functions toUint24, toUint8 and toAddress of the Lib_BytesUtils library are never used, and can therefore be removed.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#functions-touint24,-touint8-and-toaddress-of-the-lib_bytesutils-library-are-never-used,-and-can-therefore-be-removed.", "labels": ["OpenZeppelin"]}, {"title": "[N17] Transaction hashes might not be unique in the Canonical Transaction Chain", "body": "[N17] Transaction hashes might not be unique in the Canonical Transaction Chain", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n17]-transaction-hashes-might-not-be-unique-in-the-canonical-transaction-chain", "labels": ["OpenZeppelin"]}, {"title": "The enqueue function of the OVM_CanonicalTransactionChain contract constructs transaction hashes with the caller\u2019s address, the L2 target, the transaction\u2019s gas limit and its data. Since this is not enough to ensure uniqueness of hashes (that is, it could be possible to construct two transactions that result in the same hash), these transactions are instead identified by their position in the queue. However, this internal subtlety of the Canonical Transaction Chain is not explicitly documented, and might lead to errors in off-chain services tracking transactions in the Canonical Transaction Chain, since transaction hashes are commonly assumed to be unique.", "body": "The enqueue function of the OVM_CanonicalTransactionChain contract constructs transaction hashes with the caller\u2019s address, the L2 target, the transaction\u2019s gas limit and its data. Since this is not enough to ensure uniqueness of hashes (that is, it could be possible to construct two transactions that result in the same hash), these transactions are instead identified by their position in the queue. However, this internal subtlety of the Canonical Transaction Chain is not explicitly documented, and might lead to errors in off-chain services tracking transactions in the Canonical Transaction Chain, since transaction hashes are commonly assumed to be unique.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-enqueue-function-of-the-ovm_canonicaltransactionchain-contract-constructs-transaction-hashes-with-the-caller\u2019s-address,-the-l2-target,-the-transaction\u2019s-gas-limit-and-its-data.-since-this-is-not-enough-to-ensure-uniqueness-of-hashes-(that-is,-it-could-be-possible-to-construct-two-transactions-that-result-in-the-same-hash),-these-transactions-are-instead-identified-by-their-position-in-the-queue.-however,-this-internal-subtlety-of-the-canonical-transaction-chain-is-not-explicitly-documented,-and-might-lead-to-errors-in-off-chain-services-tracking-transactions-in-the-canonical-transaction-chain,-since-transaction-hashes-are-commonly-assumed-to-be-unique.", "labels": ["OpenZeppelin"]}, {"title": "Consider including developer-friendly documentation stating how transaction hashes in the Canonical Transaction Chain are constructed, and how they should not be relied on to uniquely identify transactions.", "body": "Consider including developer-friendly documentation stating how transaction hashes in the Canonical Transaction Chain are constructed, and how they should not be relied on to uniquely identify transactions.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#consider-including-developer-friendly-documentation-stating-how-transaction-hashes-in-the-canonical-transaction-chain-are-constructed,-and-how-they-should-not-be-relied-on-to-uniquely-identify-transactions.", "labels": ["OpenZeppelin"]}, {"title": "[N18] Cross-domain messengers can be impersonated", "body": "[N18] Cross-domain messengers can be impersonated", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n18]-cross-domain-messengers-can-be-impersonated", "labels": ["OpenZeppelin"]}, {"title": "The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts allow relaying arbitrary cross-domain messages. Ultimately, this means that it is possible for anyone to make these contracts execute arbitrary calls (see calls hereand here). Therefore, there are two scenarios developers should consider when building and integrating bridges between layer 1 and 2. Aiming for simplicity, in the following we explain both scenarios starting on layer 1 \u2013 yet a similar behavior can be seen in the opposite direction.", "body": "The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts allow relaying arbitrary cross-domain messages. Ultimately, this means that it is possible for anyone to make these contracts execute arbitrary calls (see calls hereand here). Therefore, there are two scenarios developers should consider when building and integrating bridges between layer 1 and 2. Aiming for simplicity, in the following we explain both scenarios starting on layer 1 \u2013 yet a similar behavior can be seen in the opposite direction.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-relaymessage-functions-of-the-ovm_l1crossdomainmessenger-and-ovm_l2crossdomainmessenger-contracts-allow-relaying-arbitrary-cross-domain-messages.-ultimately,-this-means-that-it-is-possible-for-anyone-to-make-these-contracts-execute-arbitrary-calls-(see-calls-hereand-here).-therefore,-there-are-two-scenarios-developers-should-consider-when-building-and-integrating-bridges-between-layer-1-and-2.-aiming-for-simplicity,-in-the-following-we-explain-both-scenarios-starting-on-layer-1-\u2013-yet-a-similar-behavior-can-be-seen-in-the-opposite-direction.", "labels": ["OpenZeppelin"]}, {"title": "call any target address with arbitrary data. Therefore, layer 2 accounts should be aware that they can receive arbitrary calls from the", "body": "call any target address with arbitrary data. Therefore, layer 2 accounts should be aware that they can receive arbitrary calls from the", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#call-any-target-address-with-arbitrary-data.-therefore,-layer-2-accounts-should-be-aware-that-they-can-receive-arbitrary-calls-from-the", "labels": ["OpenZeppelin"]}, {"title": "ERC1820Registry contract. It must be noted that during the call from the", "body": "ERC1820Registry contract. It must be noted that during the call from the", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#erc1820registry-contract.-it-must-be-noted-that-during-the-call-from-the", "labels": ["OpenZeppelin"]}, {"title": "xDomainMessageSender functionto inspect the address of the layer 1 account that originated the message.", "body": "xDomainMessageSender functionto inspect the address of the layer 1 account that originated the message.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#xdomainmessagesender-functionto-inspect-the-address-of-the-layer-1-account-that-originated-the-message.", "labels": ["OpenZeppelin"]}, {"title": "Going further, now into the second case, a subtle behavior of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessengercontracts allows anyone not only to send messages via these contracts, but also to originate messages from them. The execution steps to originate an L2-to-L1 message from the OVM_L2CrossDomainMessenger would develop as follows:", "body": "Going further, now into the second case, a subtle behavior of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessengercontracts allows anyone not only to send messages via these contracts, but also to originate messages from them. The execution steps to originate an L2-to-L1 message from the OVM_L2CrossDomainMessenger would develop as follows:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#going-further,-now-into-the-second-case,-a-subtle-behavior-of-the-ovm_l1crossdomainmessenger-and-ovm_l2crossdomainmessengercontracts-allows-anyone-not-only-to-send-messages-via-these-contracts,-but-also-to-originate-messages-from-them.-the-execution-steps-to-originate-an-l2-to-l1-message-from-the-ovm_l2crossdomainmessenger-would-develop-as-follows:", "labels": ["OpenZeppelin"]}, {"title": "A user-controlled account sends a message from layer 1 calling the sendMessage function of the OVM_L1CrossDomainMessengercontract. The target of this message should be the OVM_L2CrossDomainMessenger contract, and the message should be an abi-encoded call to the target\u2019s sendMessage function, including the arbitrary data the user wants the OVM_L2CrossDomainMessengercontract to send to layer 1.", "body": "A user-controlled account sends a message from layer 1 calling the sendMessage function of the OVM_L1CrossDomainMessengercontract. The target of this message should be the OVM_L2CrossDomainMessenger contract, and the message should be an abi-encoded call to the target\u2019s sendMessage function, including the arbitrary data the user wants the OVM_L2CrossDomainMessengercontract to send to layer 1.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#a-user-controlled-account-sends-a-message-from-layer-1-calling-the-sendmessage-function-of-the-ovm_l1crossdomainmessengercontract.-the-target-of-this-message-should-be-the-ovm_l2crossdomainmessenger-contract,-and-the-message-should-be-an-abi-encoded-call-to-the-target\u2019s-sendmessage-function,-including-the-arbitrary-data-the-user-wants-the-ovm_l2crossdomainmessengercontract-to-send-to-layer-1.", "labels": ["OpenZeppelin"]}, {"title": "The L1-to-L2 message sent by the user is enqueued in the Canonical Transaction Chain as a regular OVM transaction.", "body": "The L1-to-L2 message sent by the user is enqueued in the Canonical Transaction Chain as a regular OVM transaction.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-l1-to-l2-message-sent-by-the-user-is-enqueued-in-the-canonical-transaction-chain-as-a-regular-ovm-transaction.", "labels": ["OpenZeppelin"]}, {"title": "In layer 2, the relayMessage function of the OVM_L2CrossDomainMessenger contract is called to relay the user\u2019s message. Following how the message was constructed, this will trigger a call from the OVM_L2CrossDomainMessenger contract to its own sendMessagefunction. In other words, the OVM_L2CrossDomainMessenger contract sends a message from L2 to L1 with target and data arbitrarily decided by the user in (1).", "body": "In layer 2, the relayMessage function of the OVM_L2CrossDomainMessenger contract is called to relay the user\u2019s message. Following how the message was constructed, this will trigger a call from the OVM_L2CrossDomainMessenger contract to its own sendMessagefunction. In other words, the OVM_L2CrossDomainMessenger contract sends a message from L2 to L1 with target and data arbitrarily decided by the user in (1).", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-layer-2,-the-relaymessage-function-of-the-ovm_l2crossdomainmessenger-contract-is-called-to-relay-the-user\u2019s-message.-following-how-the-message-was-constructed,-this-will-trigger-a-call-from-the-ovm_l2crossdomainmessenger-contract-to-its-own-sendmessagefunction.-in-other-words,-the-ovm_l2crossdomainmessenger-contract-sends-a-message-from-l2-to-l1-with-target-and-data-arbitrarily-decided-by-the-user-in-(1).", "labels": ["OpenZeppelin"]}, {"title": "After the fraud proof window is over, the L2-to-L1 message sent by the OVM_L2CrossDomainMessenger contract is relayed in layer 1.", "body": "After the fraud proof window is over, the L2-to-L1 message sent by the OVM_L2CrossDomainMessenger contract is relayed in layer 1.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#after-the-fraud-proof-window-is-over,-the-l2-to-l1-message-sent-by-the-ovm_l2crossdomainmessenger-contract-is-relayed-in-layer-1.", "labels": ["OpenZeppelin"]}, {"title": "The target contract in layer 1 receives a message with the user-controlled data. Should the target address query the xDomainMessageSender function to inspect the address of the layer 2 account that originated the message, it would receive the address of the OVM_L2CrossDomainMessenger contract.", "body": "The target contract in layer 1 receives a message with the user-controlled data. Should the target address query the xDomainMessageSender function to inspect the address of the layer 2 account that originated the message, it would receive the address of the OVM_L2CrossDomainMessenger contract.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-target-contract-in-layer-1-receives-a-message-with-the-user-controlled-data.-should-the-target-address-query-the-xdomainmessagesender-function-to-inspect-the-address-of-the-layer-2-account-that-originated-the-message,-it-would-receive-the-address-of-the-ovm_l2crossdomainmessenger-contract.", "labels": ["OpenZeppelin"]}, {"title": "The actual consequences of the described behaviors will ultimately depend on the contracts receiving these arbitrary calls, and that is why we are only reporting this as an informative note. Developers should be fully aware of these scenarios and be ready to implement the necessary defensive measures to mitigate impact on their systems. We suggest the Optimism team to include specific developer-friendly documentation highlighting this note, so as to raise awareness of the subtleties of cross-domain communication.", "body": "The actual consequences of the described behaviors will ultimately depend on the contracts receiving these arbitrary calls, and that is why we are only reporting this as an informative note. Developers should be fully aware of these scenarios and be ready to implement the necessary defensive measures to mitigate impact on their systems. We suggest the Optimism team to include specific developer-friendly documentation highlighting this note, so as to raise awareness of the subtleties of cross-domain communication.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-actual-consequences-of-the-described-behaviors-will-ultimately-depend-on-the-contracts-receiving-these-arbitrary-calls,-and-that-is-why-we-are-only-reporting-this-as-an-informative-note.-developers-should-be-fully-aware-of-these-scenarios-and-be-ready-to-implement-the-necessary-defensive-measures-to-mitigate-impact-on-their-systems.-we-suggest-the-optimism-team-to-include-specific-developer-friendly-documentation-highlighting-this-note,-so-as-to-raise-awareness-of-the-subtleties-of-cross-domain-communication.", "labels": ["OpenZeppelin"]}, {"title": "[N19] Subtleties of calling contracts under construction and abstracted EOAs", "body": "[N19] Subtleties of calling contracts under construction and abstracted EOAs", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n19]-subtleties-of-calling-contracts-under-construction-and-abstracted-eoas", "labels": ["OpenZeppelin"]}, {"title": "In the EVM, calling accounts with no executable code (that is, contracts during construction or externally owned accounts) results in an immediate halt with a STOP opcode (see subsection 9.4 of the yellow paper), and the call is considered successful. In the OVM, this behavior is not exactly replicated, due to some fundamental differences between the EVM and the OVM.", "body": "In the EVM, calling accounts with no executable code (that is, contracts during construction or externally owned accounts) results in an immediate halt with a STOP opcode (see subsection 9.4 of the yellow paper), and the call is considered successful. In the OVM, this behavior is not exactly replicated, due to some fundamental differences between the EVM and the OVM.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-evm,-calling-accounts-with-no-executable-code-(that-is,-contracts-during-construction-or-externally-owned-accounts)-results-in-an-immediate-halt-with-a-stop-opcode-(see-subsection-9.4-of-the-yellow-paper),-and-the-call-is-considered-successful.-in-the-ovm,-this-behavior-is-not-exactly-replicated,-due-to-some-fundamental-differences-between-the-evm-and-the-ovm.", "labels": ["OpenZeppelin"]}, {"title": "Calling abstracted EOAs", "body": "Calling abstracted EOAs", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#calling-abstracted-eoas", "labels": ["OpenZeppelin"]}, {"title": "The OVM offers native account abstraction. In other words, the only type of account is smart contracts, and the closest one can get to the behavior of EOAs is implemented in the OVM_ECDSAContractAccount contract. As a result, \u201ccalling an EOA\u201d is translated to calling a specific instance of this contract, and any call that does not match the selector of the execute function will result in an out-of-gas error.", "body": "The OVM offers native account abstraction. In other words, the only type of account is smart contracts, and the closest one can get to the behavior of EOAs is implemented in the OVM_ECDSAContractAccount contract. As a result, \u201ccalling an EOA\u201d is translated to calling a specific instance of this contract, and any call that does not match the selector of the execute function will result in an out-of-gas error.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-ovm-offers-native-account-abstraction.-in-other-words,-the-only-type-of-account-is-smart-contracts,-and-the-closest-one-can-get-to-the-behavior-of-eoas-is-implemented-in-the-ovm_ecdsacontractaccount-contract.-as-a-result,-\u201ccalling-an-eoa\u201d-is-translated-to-calling-a-specific-instance-of-this-contract,-and-any-call-that-does-not-match-the-selector-of-the-execute-function-will-result-in-an-out-of-gas-error.", "labels": ["OpenZeppelin"]}, {"title": "Calling contracts under construction", "body": "Calling contracts under construction", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#calling-contracts-under-construction", "labels": ["OpenZeppelin"]}, {"title": "_callContract function of the", "body": "_callContract function of the", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#_callcontract-function-of-the", "labels": ["OpenZeppelin"]}, {"title": "using the _getAccountEthAddress function. This results in a call to the", "body": "using the _getAccountEthAddress function. This results in a call to the", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#using-the-_getaccountethaddress-function.-this-results-in-a-call-to-the", "labels": ["OpenZeppelin"]}, {"title": "getAccountEthAddress function of the", "body": "getAccountEthAddress function of the", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#getaccountethaddress-function-of-the", "labels": ["OpenZeppelin"]}, {"title": "first initialized as pending without setting its L1 address, then", "body": "first initialized as pending without setting its L1 address, then", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#first-initialized-as-pending-without-setting-its-l1-address,-then", "labels": ["OpenZeppelin"]}, {"title": "created, and", "body": "created, and", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#created,-and", "labels": ["OpenZeppelin"]}, {"title": "finally committed. Therefore any address resolution before the account is committed will resolve to the zero address. The call to the zero address will be successful, and execution will simply continue. Off-chain services tracing the internal execution of fraud proof verifications might find this behavior relevant, as they will see a call to the zero address where they would have expected a call to a contract under construction.", "body": "finally committed. Therefore any address resolution before the account is committed will resolve to the zero address. The call to the zero address will be successful, and execution will simply continue. Off-chain services tracing the internal execution of fraud proof verifications might find this behavior relevant, as they will see a call to the zero address where they would have expected a call to a contract under construction.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#finally-committed.-therefore-any-address-resolution-before-the-account-is-committed-will-resolve-to-the-zero-address.-the-call-to-the-zero-address-will-be-successful,-and-execution-will-simply-continue.-off-chain-services-tracing-the-internal-execution-of-fraud-proof-verifications-might-find-this-behavior-relevant,-as-they-will-see-a-call-to-the-zero-address-where-they-would-have-expected-a-call-to-a-contract-under-construction.", "labels": ["OpenZeppelin"]}, {"title": "It should be noted that both scenarios described were raised as issues of Medium severity in our November 2020 report as \u201c[M03] Call to contract in construction results in call to the zero address\u201d and \u201c[M04] Calls to abstracted EOA accounts may result in Out of Gas error\u201d. Taking into account that we did not receive specific feedback on those issues, and that the behavior of the system remains, we assume that the Optimism team has acknowledged these scenarios and consider them intended. Therefore, we are only describing them in this informative note for completeness, and to suggest explicitly documenting them either with inline comments, docstrings, external developer documentation or system specification if the Optimism team considers it appropriate.", "body": "It should be noted that both scenarios described were raised as issues of Medium severity in our November 2020 report as \u201c[M03] Call to contract in construction results in call to the zero address\u201d and \u201c[M04] Calls to abstracted EOA accounts may result in Out of Gas error\u201d. Taking into account that we did not receive specific feedback on those issues, and that the behavior of the system remains, we assume that the Optimism team has acknowledged these scenarios and consider them intended. Therefore, we are only describing them in this informative note for completeness, and to suggest explicitly documenting them either with inline comments, docstrings, external developer documentation or system specification if the Optimism team considers it appropriate.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#it-should-be-noted-that-both-scenarios-described-were-raised-as-issues-of-medium-severity-in-our-november-2020-report-as-\u201c[m03]-call-to-contract-in-construction-results-in-call-to-the-zero-address\u201d-and-\u201c[m04]-calls-to-abstracted-eoa-accounts-may-result-in-out-of-gas-error\u201d.-taking-into-account-that-we-did-not-receive-specific-feedback-on-those-issues,-and-that-the-behavior-of-the-system-remains,-we-assume-that-the-optimism-team-has-acknowledged-these-scenarios-and-consider-them-intended.-therefore,-we-are-only-describing-them-in-this-informative-note-for-completeness,-and-to-suggest-explicitly-documenting-them-either-with-inline-comments,-docstrings,-external-developer-documentation-or-system-specification-if-the-optimism-team-considers-it-appropriate.", "labels": ["OpenZeppelin"]}, {"title": "[N20] Repeated authentication logic in State Manager", "body": "[N20] Repeated authentication logic in State Manager", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n20]-repeated-authentication-logic-in-state-manager", "labels": ["OpenZeppelin"]}, {"title": "The isAuthenticated function of the OVM_StateManager contract can be used to validate whether a given address is allowed to write into the contract\u2019s state. The same functionality is implemented in the authenticated modifier.", "body": "The isAuthenticated function of the OVM_StateManager contract can be used to validate whether a given address is allowed to write into the contract\u2019s state. The same functionality is implemented in the authenticated modifier.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-isauthenticated-function-of-the-ovm_statemanager-contract-can-be-used-to-validate-whether-a-given-address-is-allowed-to-write-into-the-contract\u2019s-state.-the-same-functionality-is-implemented-in-the-authenticated-modifier.", "labels": ["OpenZeppelin"]}, {"title": "To avoid code repetition, consider modifying the authenticated modifier so that it calls the isAuthenticated function to determine if the caller is authenticated. This note can be disregarded should the current implementation be more favorable in terms of gas costs.", "body": "To avoid code repetition, consider modifying the authenticated modifier so that it calls the isAuthenticated function to determine if the caller is authenticated. This note can be disregarded should the current implementation be more favorable in terms of gas costs.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#to-avoid-code-repetition,-consider-modifying-the-authenticated-modifier-so-that-it-calls-the-isauthenticated-function-to-determine-if-the-caller-is-authenticated.-this-note-can-be-disregarded-should-the-current-implementation-be-more-favorable-in-terms-of-gas-costs.", "labels": ["OpenZeppelin"]}, {"title": "[N21] Not using available bytes32 utilities", "body": "[N21] Not using available bytes32 utilities", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n21]-not-using-available-bytes32-utilities", "labels": ["OpenZeppelin"]}, {"title": "76,", "body": "76,", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#76,", "labels": ["OpenZeppelin"]}, {"title": "86,", "body": "86,", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#86,", "labels": ["OpenZeppelin"]}, {"title": "100 and", "body": "100 and", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#100-and", "labels": ["OpenZeppelin"]}, {"title": "110 of", "body": "110 of", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#110-of", "labels": ["OpenZeppelin"]}, {"title": "Lib_Bytes32Utils library.", "body": "Lib_Bytes32Utils library.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#lib_bytes32utils-library.", "labels": ["OpenZeppelin"]}, {"title": "[N22] Missing operations in Execution Manager wrapper library", "body": "[N22] Missing operations in Execution Manager wrapper library", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n22]-missing-operations-in-execution-manager-wrapper-library", "labels": ["OpenZeppelin"]}, {"title": "The Lib_SafeExecutionManagerWrapper library offers functions to facilitate writing OVM safe code that can be compiled using the standard Solidity compiler. However, it is missing a number of wrappers for OVM operations, namely:", "body": "The Lib_SafeExecutionManagerWrapper library offers functions to facilitate writing OVM safe code that can be compiled using the standard Solidity compiler. However, it is missing a number of wrappers for OVM operations, namely:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-lib_safeexecutionmanagerwrapper-library-offers-functions-to-facilitate-writing-ovm-safe-code-that-can-be-compiled-using-the-standard-solidity-compiler.-however,-it-is-missing-a-number-of-wrappers-for-ovm-operations,-namely:", "labels": ["OpenZeppelin"]}, {"title": "ovmCREATE2", "body": "opcodes can revert during execution (instead of returning 0 upon failure as specified in the EVM). This is due to the fact that the code is validating the deployer is allowed at the beginning of the opcodes execution (see calls to the  here and  here), instead of doing it inside the  safeCREATE function, where similar validations are applied that do not result in a revert upon failure.  We are raising this peculiarity of the current version of the OVM as an informative note for completeness, since we understand that the development team is fully aware of this undocumented behavioral difference with EVM, and is planning to fix it by removing the deployer whitelist in the short term. Should that not be the case, consider this note of higher priority and explicitly document the described behavior in external documentation to raise user awareness.  [N11] Typographical errors  In Lib_MerkleTree.sol:  In line 117, sibline should say sibling.  In Lib_MerkleTrie.sol:  In line 275, 31 should say 32.  In Lib_Math.sol:  In line 14, minumum should say minimum.  In iOVM_ChainStorageContainer.sol:  In line 104, meaing should say meaning.  In OVM_CanonicalTransactionChain.sol:  In line 344, minnet should say mainnet.  In line 973, que should say queue.  In line 1011, elemtent should say element.  In OVM_CrossDomainEnabled.sol:  In line 14, recieve should say receive.  In OVM_L2ToL1MessagePasser.sol:  In line 9, facilitates is misspelled. It also includes the repeated phrase of the.  In Abs_L1TokenGateway.sol:  In line 128, recipients is misspelled.  In OVM_L1ERC20Gateway.sol:  In line 18, takes should say take.  In OVM_ExecutionManager.sol:  In line 168, awlways should say always.  In lines 191, 202, 213, and 1701, minnet should say mainnet.  In lines 1804, 1809, 1814, unnecessary the SSTORE should say the unnecessary SSTORE.  In OVM_ECDSAContract.sol:  In lines 142, transfer is misspelled.  In OVM_FraudVerifier.sol:  In line 210, minnet should say mainnet.  In Lib_RLPReader.sol:  In lines 384 and 410, a address should say an address.  [N12] Negative overflow of uint256 type  To favor readability, in line 1890 of OVM_ExecutionManager.sol consider replacing the negative overflow operation of an uint256 value with the expression type(uint256).max.  [N13] Unnecessary return statement  Consider removing the return keyword from the setGlobalMetadata function of the OVM_ChainStorageContainer contract, as the setExtraData function of the Lib_RingBuffer library being called does not return any value.  [N14] Unused imports  To improve readability and avoid confusion, consider removing the following unused imports.  In the OVM_StateCommitmentChain contract, the iOVM_FraudVerifier interface.  In the OVM_ExecutionManager contract, the OVM_ECDSAContractAccount and OVM_DeployerWhitelist contracts.  In the OVM_L2DepositedERC20 contract, the iOVM_L1TokenGateway interface.  In the OVM_ETH contract, the Lib_AddressResolver contract.  In the OVM_StateTransitioner contract, the iOVM_BondManager interface.  In the Lib_OVMCodec library, the Lib_BytesUtils library.  [N15] Unused events  The iOVM_L2ToL1MessagePasser interface defines the L2ToL1Message event, which is never emitted in the child contract OVM_L2ToL1MessagePasser.  To avoid confusion and favor simplicity, consider removing all definitions of events that are not expected to be emitted.  [N16] Unused functions  Functions toUint24, toUint8 and toAddress of the Lib_BytesUtils library are never used, and can therefore be removed.  [N17] Transaction hashes might not be unique in the Canonical Transaction Chain  The enqueue function of the OVM_CanonicalTransactionChain contract constructs transaction hashes with the callers address, the L2 target, the transactions gas limit and its data. Since this is not enough to ensure uniqueness of hashes (that is, it could be possible to construct two transactions that result in the same hash), these transactions are instead identified by their position in the queue. However, this internal subtlety of the Canonical Transaction Chain is not explicitly documented, and might lead to errors in off-chain services tracking transactions in the Canonical Transaction Chain, since transaction hashes are commonly assumed to be unique.  Consider including developer-friendly documentation stating how transaction hashes in the Canonical Transaction Chain are constructed, and how they should not be relied on to uniquely identify transactions.  [N18] Cross-domain messengers can be impersonated  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts allow relaying arbitrary cross-domain messages. Ultimately, this means that it is possible for anyone to make these contracts execute arbitrary calls (see calls hereand here). Therefore, there are two scenarios developers should consider when building and integrating bridges between layer 1 and 2. Aiming for simplicity, in the following we explain both scenarios starting on layer 1  yet a similar behavior can be seen in the opposite direction.  call any target address with arbitrary data. Therefore, layer 2 accounts should be aware that they can receive arbitrary calls from the  ERC1820Registry contract. It must be noted that during the call from the  xDomainMessageSender functionto inspect the address of the layer 1 account that originated the message.  Going further, now into the second case, a subtle behavior of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessengercontracts allows anyone not only to send messages via these contracts, but also to originate messages from them. The execution steps to originate an L2-to-L1 message from the OVM_L2CrossDomainMessenger would develop as follows:  A user-controlled account sends a message from layer 1 calling the sendMessage function of the OVM_L1CrossDomainMessengercontract. The target of this message should be the OVM_L2CrossDomainMessenger contract, and the message should be an abi-encoded call to the targets sendMessage function, including the arbitrary data the user wants the OVM_L2CrossDomainMessengercontract to send to layer 1.  The L1-to-L2 message sent by the user is enqueued in the Canonical Transaction Chain as a regular OVM transaction.  In layer 2, the relayMessage function of the OVM_L2CrossDomainMessenger contract is called to relay the users message. Following how the message was constructed, this will trigger a call from the OVM_L2CrossDomainMessenger contract to its own sendMessagefunction. In other words, the OVM_L2CrossDomainMessenger contract sends a message from L2 to L1 with target and data arbitrarily decided by the user in (1).  After the fraud proof window is over, the L2-to-L1 message sent by the OVM_L2CrossDomainMessenger contract is relayed in layer 1.  The target contract in layer 1 receives a message with the user-controlled data. Should the target address query the xDomainMessageSender function to inspect the address of the layer 2 account that originated the message, it would receive the address of the OVM_L2CrossDomainMessenger contract.  The actual consequences of the described behaviors will ultimately depend on the contracts receiving these arbitrary calls, and that is why we are only reporting this as an informative note. Developers should be fully aware of these scenarios and be ready to implement the necessary defensive measures to mitigate impact on their systems. We suggest the Optimism team to include specific developer-friendly documentation highlighting this note, so as to raise awareness of the subtleties of cross-domain communication.  [N19] Subtleties of calling contracts under construction and abstracted EOAs  In the EVM, calling accounts with no executable code (that is, contracts during construction or externally owned accounts) results in an immediate halt with a STOP opcode (see subsection 9.4 of the yellow paper), and the call is considered successful. In the OVM, this behavior is not exactly replicated, due to some fundamental differences between the EVM and the OVM.  Calling abstracted EOAs  The OVM offers native account abstraction. In other words, the only type of account is smart contracts, and the closest one can get to the behavior of EOAs is implemented in the OVM_ECDSAContractAccount contract. As a result, calling an EOA is translated to calling a specific instance of this contract, and any call that does not match the selector of the execute function will result in an out-of-gas error.  Calling contracts under construction  _callContract function of the  using the _getAccountEthAddress function. This results in a call to the  getAccountEthAddress function of the  first initialized as pending without setting its L1 address, then  created, and  finally committed. Therefore any address resolution before the account is committed will resolve to the zero address. The call to the zero address will be successful, and execution will simply continue. Off-chain services tracing the internal execution of fraud proof verifications might find this behavior relevant, as they will see a call to the zero address where they would have expected a call to a contract under construction.  It should be noted that both scenarios described were raised as issues of Medium severity in our November 2020 report as [M03] Call to contract in construction results in call to the zero address and [M04] Calls to abstracted EOA accounts may result in Out of Gas error. Taking into account that we did not receive specific feedback on those issues, and that the behavior of the system remains, we assume that the Optimism team has acknowledged these scenarios and consider them intended. Therefore, we are only describing them in this informative note for completeness, and to suggest explicitly documenting them either with inline comments, docstrings, external developer documentation or system specification if the Optimism team considers it appropriate.  [N20] Repeated authentication logic in State Manager  The isAuthenticated function of the OVM_StateManager contract can be used to validate whether a given address is allowed to write into the contracts state. The same functionality is implemented in the authenticated modifier.  To avoid code repetition, consider modifying the authenticated modifier so that it calls the isAuthenticated function to determine if the caller is authenticated. This note can be disregarded should the current implementation be more favorable in terms of gas costs.  [N21] Not using available bytes32 utilities  76,  86,  100 and  110 of  Lib_Bytes32Utils library.  [N22] Missing operations in Execution Manager wrapper library  The Lib_SafeExecutionManagerWrapper library offers functions to facilitate writing OVM safe code that can be compiled using the standard Solidity compiler. However, it is missing a number of wrappers for OVM operations, namely:    ovmSTATICCALL  ovmEXTCODEHASH  ovmEXTCODECOPY  ovmL1TXORIGIN  ovmL1QUEUEORIGIN  ovmGASLIMIT  ovmNUMBER  ovmTIMESTAMP  Consider including wrapper functions for them in the Lib_SafeExecutionManagerWrapper library.  [N23] Unnecessary standalone contract to relay multiple messages  The OVM_L1MultiMessageRelayer contract implements a single function batchRelayMessages that forwards multiple cross-domain messages to the OVM_L1CrossDomainMessenger contract. To favor simplicity, this function could be moved to the OVM_L1CrossDomainMessenger contract (where it should be marked with the onlyRelayer modifier).  [N24] Data returned by relayed message is ignored  relayMessage function of the  ovmCALL to the messages target. While the calls success flag is  validated to determine whether the message can be considered successful, the returned data is never stored nor logged. As a consequence, relevant returned data from relayed messages will not be accessible after a message is relayed. The described behavior also occurs in the  relayMessage function of the  Should this be the intended behavior of the relayMessage functions, consider documenting it in the functions docstrings. Otherwise, consider including a mechanism to retrieve the returned data of relayed messages, which could include storing the data in storage, or logging it using an event.  [N25] Duplicated code in cross-domain messenger contracts  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts behave in a similar way and share a non-trivial amount of duplicated logic.  To reduce code duplication and favor reusability, consider abstracting away repeated logic to an internal function of the Abs_BaseCrossDomainMessenger parent contract.  [N26] Duplicated code for memory copy utility  The _copy function of the Lib_RLPReader library and _memcpy function of the Lib_RLPWriter serve a similar purpose: copying pieces of memory to other locations. To reduce duplicated logic and ease maintenance, consider defining a single memory copy utility function, and reusing it throughout the code base. Alternatively, to favor a simpler implementation, consider using the identity precompile contract at address 0x0000000000000000000000000000000000000004 to copy pieces of memory.  [N27] Redundant check when proving contract state  proveContractState function of the  two conditions. The first condition,  hasAccount, checks whether  the accounts code hash is non-zero. The second condition,  hasEmptyAccount, checks that  the accounts code hash matches the EMPTY_ACCOUNT_CODE_HASH hash.  Since the EMPTY_ACCOUNT_CODE_HASH is non-zero, the second condition implies the first one. Therefore, consider removing the call to hasAccount.  [N28] Base contract not marked as abstract  Contracts that are not intended to be instantiated directly, such as OVM_CrossDomainEnabled, should be marked as abstract to favor readability and avoid unintended usage.  [N29] Inconsistent coding style  Some instances of inconsistent coding style were identified in the code base. Specifically:  While most internal and private functions explicitly denote their visibility by prepending their names with an underscore, functions getCrossDomainMessenger and sendCrossDomainMessage of the OVM_CrossDomainEnabled contract fail to do so.  To favor readability, consider always following a consistent style throughout the code base. We suggest using Soliditys Style Guide as a reference.  [N30] Lack of explicit visibility in state variables  The following state variables and constants are implicitly using the default visibility.  In the OVM_ECDSAContractAccount contract:  The EXECUTION_VALIDATION_GAS_OVERHEAD and ETH_ERC20_ADDRESS constants.  In the OVM_ProxyEOA contract:  The IMPLEMENTATION_KEY constant.  In the Abs_L2DepositedToken contract:  The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant  To favor readability, consider explicitly declaring the visibility of all state variables and constants.  [N31] Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.  The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.  In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.  [N32] Implicit casting operations  The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when its passed to the call to _sendXDomainMessage.  The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transactions nonce matches the expected one.  For added readability, consider making casting operations explicit where possible.  Conclusions  4 critical and 4 high severity issues were found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#ovmcreate2", "labels": ["OpenZeppelin"]}, {"title": "ovmSTATICCALL", "body": "ovmSTATICCALL", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#ovmstaticcall", "labels": ["OpenZeppelin"]}, {"title": "ovmEXTCODEHASH", "body": "ovmEXTCODEHASH", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#ovmextcodehash", "labels": ["OpenZeppelin"]}, {"title": "ovmEXTCODECOPY", "body": "ovmL1TXORIGIN  ovmL1QUEUEORIGIN  ovmGASLIMIT  ovmNUMBER  ovmTIMESTAMP  Consider including wrapper functions for them in the Lib_SafeExecutionManagerWrapper library.  [N23] Unnecessary standalone contract to relay multiple messages  The OVM_L1MultiMessageRelayer contract implements a single function batchRelayMessages that forwards multiple cross-domain messages to the OVM_L1CrossDomainMessenger contract. To favor simplicity, this function could be moved to the OVM_L1CrossDomainMessenger contract (where it should be marked with the onlyRelayer modifier).  [N24] Data returned by relayed message is ignored  relayMessage function of the  ovmCALL to the messages target. While the calls success flag is  validated to determine whether the message can be considered successful, the returned data is never stored nor logged. As a consequence, relevant returned data from relayed messages will not be accessible after a message is relayed. The described behavior also occurs in the  relayMessage function of the  Should this be the intended behavior of the relayMessage functions, consider documenting it in the functions docstrings. Otherwise, consider including a mechanism to retrieve the returned data of relayed messages, which could include storing the data in storage, or logging it using an event.  [N25] Duplicated code in cross-domain messenger contracts  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts behave in a similar way and share a non-trivial amount of duplicated logic.  To reduce code duplication and favor reusability, consider abstracting away repeated logic to an internal function of the Abs_BaseCrossDomainMessenger parent contract.  [N26] Duplicated code for memory copy utility  The _copy function of the Lib_RLPReader library and _memcpy function of the Lib_RLPWriter serve a similar purpose: copying pieces of memory to other locations. To reduce duplicated logic and ease maintenance, consider defining a single memory copy utility function, and reusing it throughout the code base. Alternatively, to favor a simpler implementation, consider using the identity precompile contract at address 0x0000000000000000000000000000000000000004 to copy pieces of memory.  [N27] Redundant check when proving contract state  proveContractState function of the  two conditions. The first condition,  hasAccount, checks whether  the accounts code hash is non-zero. The second condition,  hasEmptyAccount, checks that  the accounts code hash matches the EMPTY_ACCOUNT_CODE_HASH hash.  Since the EMPTY_ACCOUNT_CODE_HASH is non-zero, the second condition implies the first one. Therefore, consider removing the call to hasAccount.  [N28] Base contract not marked as abstract  Contracts that are not intended to be instantiated directly, such as OVM_CrossDomainEnabled, should be marked as abstract to favor readability and avoid unintended usage.  [N29] Inconsistent coding style  Some instances of inconsistent coding style were identified in the code base. Specifically:  While most internal and private functions explicitly denote their visibility by prepending their names with an underscore, functions getCrossDomainMessenger and sendCrossDomainMessage of the OVM_CrossDomainEnabled contract fail to do so.  To favor readability, consider always following a consistent style throughout the code base. We suggest using Soliditys Style Guide as a reference.  [N30] Lack of explicit visibility in state variables  The following state variables and constants are implicitly using the default visibility.  In the OVM_ECDSAContractAccount contract:  The EXECUTION_VALIDATION_GAS_OVERHEAD and ETH_ERC20_ADDRESS constants.  In the OVM_ProxyEOA contract:  The IMPLEMENTATION_KEY constant.  In the Abs_L2DepositedToken contract:  The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant  To favor readability, consider explicitly declaring the visibility of all state variables and constants.  [N31] Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.  The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.  In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.  [N32] Implicit casting operations  The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when its passed to the call to _sendXDomainMessage.  The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transactions nonce matches the expected one.  For added readability, consider making casting operations explicit where possible.  Conclusions  4 critical and 4 high severity issues were found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#ovmextcodecopy", "labels": ["OpenZeppelin"]}, {"title": "ovmL1TXORIGIN", "body": "ovmL1TXORIGIN", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#ovml1txorigin", "labels": ["OpenZeppelin"]}, {"title": "ovmL1QUEUEORIGIN", "body": "function states that an address is returned, yet the actual returned value is the element of an enum.  The inline comment in line 857 states that the nonce is updated even if contract creation fails, yet that is incorrect. When the contract creation fails with a revert due to the deployer not being allowed, the accounts nonce is not updated (see note [N10] Contract creation can revert upon failure for additional details).  An inline comment in line 1039 states that the revert flag EXCEEDS_NUISANCE_GAS explicitly reduces the remaining nuisance gas for this message to zero. However, as can be observed in the related _useNuisanceGas function where the flag is raised, the remaining nuisance gas of the message is not set to zero (as described in issue [M05] Nuisance gas left is not reduced to zero when operation exceeds budget)  An inline comment in line 1358 mentions loading an account but is referring to changing an account.  In the Lib_Bytes32Utils library:  The @return tag of the removeLeadingZeros function specifies that the returned value is bytes32, while it actually returns a bytestype.  In the OVM_L1ERC20Gateway contract:  lines 63 and 64 imply that ETH is being deposited, when actually an ERC20 token is being deposited.  In the Abs_L1TokenGateway contract:  The comment on line 77 describes a withdrawal operation instead of a deposit.  The comment on line 129 says withdrawal instead of deposit.  The comment on line 188 says the function will fail if the L2 withdrawal was not finalized, but that logic is not included within the function.  In the Abs_L2DepositedToken contract:  Docstrings for the contracts constructor should say L2 Messenger address instead of L1 Messenger address.  Documented parameters _to and _amount of the finalizeDeposit function refer to withdrawals, when they should be referring to deposits.  In the OVM_L2ToL1MessagePasser contract:  Docstrings state that the contracts runtime target is the EVM, while it should say OVM.  In the OVM_StateManager contract:  Docstrings in lines 274 and 292 state that the related functions are only called during ovmCREATE or ovmCREATE2 operations, failing to account that they are also called during ovmCREATEEOA.  In the OVM_StateTransitioner contract:  Docstrings for the getPostStateRoot function state that the value returned corresponds to the state root after execution. However, if it is called prior to the transaction being applied, the function will return the state root before execution.  In the Lib_MerkleTrie library:  Docstrings for the _getNodeValue function should say Gets the value for a node instead of Gets the path for a node.  In the OVM_ECDSAContractAccount contract:  The comment on line 17 indicates that eth_sign messages can be parsed, but this functionality has been removed.  The comment on line 73 appears to be removable as it is similar to the comment on line 79.  [L06] Missing and / or incomplete docstrings  Some contracts and functions in the code base lack documentation or include incomplete descriptions. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted. Below we list all instances detected during the audit.  All functions of the Lib_BytesUtils library.  In the OVM_CanonicalTransactionChain contract:  Docstrings for the _getBatchExtraData function are missing two @return tags. Docstrings for the _getQueueElement function are missing the _queueRef parameter. Docstrings for the _getSequencerLeafHash function are missing the _hashMemory parameter.  In the iOVM_StateCommitmentChain interface:  Docstrings for the verifyStateCommitment function are missing a @return tag.  In the OVM_StateCommitmentChain contract:  Docstrings for the constructor are missing parameters _fraudProofWindow and _sequencerPublishWindow.  In the OVM_ExecutionManager contract:  Docstrings for the constructor are missing the _gasMeterConfig and _globalContext parameters. Docstrings for the simulateMessage function are missing the _ovmStateManager parameter and the returned values.  In all predeploy contracts, docstrings could include the address at which each contract will be found in Layer 2.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  [L07] Undocumented literal values  Throughout the code base, there are several instances of literal values with unexplained meaning. Moreover, some of them are not declared as constant state variables, which further hinders code readability. Literal values in the code base without an explained meaning make the code harder to read, understand and maintain, thus hindering the experience of developers, auditors and external contributors alike. Following we include a list of literal values that should be further documented and explained.  In OVM_ExecutionManager.sol:  Addresses in lines 545, 826 and 908.  Fixed gas discounts applied in line 391, line 430, line 580, line 614, and line 649.  Net gas costs applied in line 681 and line 707.  The value 100 on line 916.  In OVM_StateTransitioner.sol:  The number 100000 in line 341.  In OVM_L1CrossDomainMessenger.sol:  The number 0 in line 246.  The address 0x4200000000000000000000000000000000000000 in line 254.  The number 1 in line 270.  In Lib_MerkleTrie.sol:  The number 2 in lines 785 and 811 should be replaced with LEAF_OR_EXTENSION_NODE_LENGTH.  In OVM_CanonicalTransactionChain.sol:  The number 15 in line 627 should be replaced with BATCH_CONTEXT_START_POS.  Developers should define a constant variable for every literal value used, giving it a clear and self-explanatory name. Additionally, inline comments explaining how they were calculated or why they were chosen are highly recommended. Following Soliditys style guide, constants should be named in UPPER_CASE_WITH_UNDERSCORES format, and specific public getters should be defined to read each one of them if appropriate.  [L08] Unspecified behavior of OVM gas refund for revert flags  revert flags trigger a refund of OVM gas in the transaction being run. However, there are other flags such as  EXCEEDS_NUISANCE_GAS and  UNINITIALIZED_ACCESS which are not taken into account for gas refunds, their expected behavior being unspecified. The  is raised when there is not enough  nuisance gas to continue with transaction execution, while the  is raised when the  To better define the behavior of gas refunds in the OVM, consider specifying if and how gas refunds should be applied for the mentioned revert flags.  [L09] Nuisance gas proportional to code size is charged unnecessarily when changing an account  Within the _checkAccountChange function of the OVM_ExecutionManager contract, nuisance gas is charged proportional to the code size of the account. Since i) it can be assumed that the code deployed in the pre-execution phase of the fraud proof will not change, and ii) nuisance gas proportional to code size is already charged when initially loading an account for the first time, it appears unnecessary to charge nuisance gas again the first time the account (but not its code) is changed.  Consider removing the nuisance gas fee associated with contract code size within the _checkAccountChange function. Note that the solution to this issue might impact what is described in the informational note [N08] Minimum nuisance gas per contract creation is charged twice.  [L10] Unnecessary handling of single byte returned data  In the Lib_SafeExecutionManagerWrapper library, the internal _safeExecutionManagerInteraction function handles a case in which the returned data from a call to the OVM_ExecutionManager is a single byte. This code segment appears to be outdated, left over from an earlier version of the system, and it is no longer used.  Additionally, the ovmEXTCODECOPY function of the OVM_ExecutionManager contract introduces an artificial manipulation to avoid users inadvertently triggering this special case.  Consider removing both code segments to favor simplicity and avoid confusion.  [L11] Incorrect state transitioner index  When deploying a new OVM_StateTransitioner contract, the OVM_FraudVerifier contract incorrectly passes the index of the state root in its corresponding batch, confusing it with the state roots index in the State Commitment chain. The same mistake is made when emitting the FraudProofInitialized and FraudProofFinalized events.  Consider replacing these values with the index of the state root in the State Commitment chain.  [L12] Inconsistent and error-prone storage references in proxy contracts  There are three different proxy contracts implemented, all of them following a different approach when handling storage references.  The OVM_ProxySequencerEntrypoint contract stores the implementation and owner addresses in continuous storage slots at positions 0 and 1 (as can be seen in the internal getter and setter functions for these addresses). While this approach is certainly simple, it can be considered fragile and error-prone. In particular, any poorly constructed implementation that does not take into account the storage layout of the the proxy might accidentally cause a storage collision, and overwrite these two sensitive proxy variables. The problem is aggravated by the fact that the two state variables are not explicitly declared (and therefore visible) in the contracts state, but rather low-level ovmSSTORE and ovmSLOAD operations are performed to handle them.  The OVM_ProxyEOA contract stores the implementation address in the storage slot dictated by its IMPLEMENTATION_KEY constant, currently set to 0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead.  The Lib_ResolvedDelegateProxy contract does not follow either of the previous approaches. Instead, it uses private mappings in state to store two addresses corresponding to the Lib_AddressManager and implementation contracts, which is said to include a known flaw without providing further details.  For a more robust and consistent implementation of proxy contracts, consider always following standardized storage slots for relevant addresses in state. Refer to EIP 1967 for one possible approach. This should allow building common, reusable tooling to facilitate reliable inspection and interaction with all proxy contracts in the system.  [L13] Inconsistent key slicing when computing trie root  _getUpdatedTrieRoot function of the  iterates through the path, it consumes the corresponding parts of the key by slicing it depending on the type of each node found. Whenever a Leaf or Extension node is found, the key is reduced in size appropriately (see lines  509 and  513), regardless of whether the previous identified node is the last in the path. However, this is not the case for Branch nodes, where the key  is only sliced if the previous identified node is not the last in the path.  Consider consistently slicing the key when computing the root of Merkle tries.  [L14] Branch node modification in Merkle Trie may deviate from specification  The _editBranchIndex function of the Lib_MerkleTrie library does not RLP-encode values if their length is less than 32 bytes. This behavior does not appear to conform with the available specification for Merkle Trie. Consider either complying with the referenced specification, or alternatively document what specification was used for the implementation of the Lib_MerkleTrie library.  [L15] Unnecessary use of assembly  The getMerkleRoot function of the Lib_MerkleTree library uses assembly to pack elements before hashing them (see here and here). Consider using the globally available abi.encodePacked function instead.  The slice function of the Lib_BytesUtils library uses assembly to return a zero-length array. Consider replacing these lines simply returning the empty array tempBytes.  [L16] Incorrect parsing of booleans in RLP library  readBool function of the  false only if the provided value is 0. However, in  Geth  incorrectly revert. The flawed behavior can be reproduced by simply attempting to execute  Consider updating the implementation of the readBool function to check for the case that the input is 0x80 and return falseaccordingly. Alternatively, given that this function is never used, consider removing it from the code base.  [L17] Lookup key strings are not centrally defined  Known, legitimate contracts are tracked in the addresses mapping of the Lib_AddressManager contract. New entries can be added by a privileged address via the setAddress function, and the getAddress function function acts as a public getter to query the registry providing a string-type key. While this registry is used by several different contracts to get the addresses of registered contracts, the strings used as keys to query the registry are not centrally defined. The identified strings are:  \"OVM_L2MessageRelayer\"  \"OVM_L2BatchMessageRelayer\"  \"OVM_StateCommitmentChain\"  \"OVM_L2CrossDomainMessenger\"  \"OVM_CanonicalTransactionChain\"  \"Proxy__OVM_L1CrossDomainMessenger\"  \"OVM_L1MessageSender\"  \"OVM_L1CrossDomainMessenger\"  \"OVM_L2ToL1MessagePasser\"  \"OVM_ChainStorageContainer:CTC:batches\"  \"OVM_ChainStorageContainer:CTC:queue\"  \"OVM_Sequencer\"  \"OVM_ExecutionManager\"  \"OVM_DecompressionPrecompileAddress\"  \"OVM_ChainStorageContainer:SCC:batches\"  \"OVM_BondManager\"  \"OVM_StateCommitmentChain\"  \"OVM_CanonicalTransactionChain\"  \"OVM_FraudVerifier\"  \"OVM_Proposer\"  \"OVM_SafetyChecker\"  \"OVM_StateTransitionerFactory\"  While this issue does not pose an immediate security risk, the approach taken can be considered error-prone and difficult to maintain. Moreover, it is worth noting that the current code base has a number of inconsistencies in how these keys are referenced, as described in [N06] Inconsistent name resolution.  Consider factoring out all mentioned constant strings to a single library, which can be then imported as needed. This will ease maintenance and make the code more resilient to future changes.  [L18] Lack of allowance front-running mitigation in ERC20 contract  The UniswapV2ERC20 contract does not include the increaseAllowance and decreaseAllowance functions, nowadays common in most ERC20 interfaces to help mitigate the allowance frontrunning issue of the ERC20 standard.  While not strictly part of the ERC20 standard, consider including these two functions in the contracts interface.  [L19] Lack of event emissions  In the OVM_ProxySequencerEntrypoint contract, the upgrade function does not emit an event after a successful upgrade operation.  Consider emitting events after sensitive changes take place to facilitate tracking and notify off-chain clients following the contracts activity.  [L20] Deployment risks  The following contracts have a public initializer function:  OVM_L1CrossDomainMessenger  Abs_L2DepositedToken  OVM_L1ETHGateway  OVM_DeployerWhitelist  OVM_ProxySequencerEntrypoint  In all cases, the first account to invoke the initializer is not authenticated and can set sensitive parameters, which leaves them open to potential front-running attacks that could invalidate the contracts. We understand that this is particularly relevant for the token bridge contracts, because the Optimism team intends to provide a factory that programmatically creates the contracts and adds them to a registry, so if a particular token bridge is invalidated, it may not be recoverable.  One reason for this pattern is that contracts may have circular deployment dependencies, which means some contracts have to be deployed before their dependencies. Nevertheless, since contract addresses are created deterministically, it should still be possible to predict all addresses before the deployment, and pass them to the relevant constructors. Consider using this method where appropriate to mitigate the risk of front-running during initial configuration transactions. Alternatively, consider implementing access controls to the initializer functions.  Notes & Additional Information  [N01] Additional issues  During our audit, the Optimism team independently found a number of issues in the code base. We briefly include them below for completeness.  The passMessageToL1 function of the OVM_L2ToL1MessagePasser contract is intended to be called by the OVM_L2CrossDomainMessenger, which validates the message sender and nonce before passing on the message. Although the function has no access controls, only messages sent from the OVM_L2ToL1MessagePasser can be relayed on layer 1. However, an attacker can use the L1-to-L2 message path to invoke the passMessageToL1 function from the OVM_L2CrossDomainMessenger with any parameters. This lets them send a message back up to L1 that bypasses the message sender and nonce validations. The Optimism team has indicated that they will remove the OVM_L2ToL1MessagePasser contract entirely, and use the sentMessages mapping in the OVM_L2CrossDomainMessenger instead.  The logic in the _handleContractCreation function of the OVM_ExecutionManager contract allows deploying potentially unsafe code. While it does validate the runtime code deployed, the restriction is enforced after the code is already deployed, without reverting the state changes.  After running a legitimate fraud proof and reaching the post-execution state, the associated State Manager still considers the Execution Manager as authenticated. This would allow further modifying state during post-execution.  An attacker can maliciously modify the context in which a fraud proof is run by first calling the run function of the OVM_ExecutionManager altering context-related variables (such as the isStatic flag), and then re-entering it during execution of a fraud proof.  Update: These issues were identified in the first audited commit. They are fixed in the latest audited commit. Note that instead of removing the OVM_L2ToL1MessagePasser contract, the first issue was addressed by recognizing and discarding L1-to-L2 cross domain messages directed at the OVM_L2ToL1MessagePasser contract.  [N02] Contracts do not compile with Solidity versions prior to 0.7  Contracts throughout the code base explicitly allow to be compiled with Solidity versions lower than 0.8 and greater than 0.5, by setting its pragma statement to pragma solidity >0.5.0 <0.8.0; (see for example the OVM_CanonicalTransactionChain contract). However, contracts that do not set explicit visibility in their constructors were only allowed starting in Solidity 0.7, meaning that it will not be possible to compile them with older versions.  Consider reviewing and updating the pragma statements of all contracts throughout the code base to ensure they can actually be compiled with the expected versions.  [N03] Fragile default values in Merkle tree  default values. These value are chosen to simulate the effect of padding the input  acceptable bound. This behavior is acknowledged,  noted in the function comments, and respected throughout the code base.  Nevertheless, we understand it would be more gas-efficient and easier to reason about if the default values were replaced with a constant value that provably has no known pre-image. Consider introducing this simplification.  [N04] Gas inefficiencies  This is a non-comprehensive list of simple gas inefficiencies detected as a side-product of the audit for the development teams consideration.  In the OVM_CanonicalTransactionChain contract:  The address of the Sequencer could be resolved before entering the loop to avoid unnecessary external calls during execution of the appendQueueBatch function. ", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#ovml1queueorigin", "labels": ["OpenZeppelin"]}, {"title": "ovmGASLIMIT", "body": "ovmGASLIMIT", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#ovmgaslimit", "labels": ["OpenZeppelin"]}, {"title": "ovmNUMBER", "body": "ovmNUMBER", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#ovmnumber", "labels": ["OpenZeppelin"]}, {"title": "ovmTIMESTAMP", "body": "ovmTIMESTAMP", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#ovmtimestamp", "labels": ["OpenZeppelin"]}, {"title": "Consider including wrapper functions for them in the Lib_SafeExecutionManagerWrapper library.", "body": "Consider including wrapper functions for them in the Lib_SafeExecutionManagerWrapper library.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#consider-including-wrapper-functions-for-them-in-the-lib_safeexecutionmanagerwrapper-library.", "labels": ["OpenZeppelin"]}, {"title": "[N23] Unnecessary standalone contract to relay multiple messages", "body": "[N23] Unnecessary standalone contract to relay multiple messages", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n23]-unnecessary-standalone-contract-to-relay-multiple-messages", "labels": ["OpenZeppelin"]}, {"title": "The OVM_L1MultiMessageRelayer contract implements a single function batchRelayMessages that forwards multiple cross-domain messages to the OVM_L1CrossDomainMessenger contract. To favor simplicity, this function could be moved to the OVM_L1CrossDomainMessenger contract (where it should be marked with the onlyRelayer modifier).", "body": "The OVM_L1MultiMessageRelayer contract implements a single function batchRelayMessages that forwards multiple cross-domain messages to the OVM_L1CrossDomainMessenger contract. To favor simplicity, this function could be moved to the OVM_L1CrossDomainMessenger contract (where it should be marked with the onlyRelayer modifier).", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-ovm_l1multimessagerelayer-contract-implements-a-single-function-batchrelaymessages-that-forwards-multiple-cross-domain-messages-to-the-ovm_l1crossdomainmessenger-contract.-to-favor-simplicity,-this-function-could-be-moved-to-the-ovm_l1crossdomainmessenger-contract-(where-it-should-be-marked-with-the-onlyrelayer-modifier).", "labels": ["OpenZeppelin"]}, {"title": "[N24] Data returned by relayed message is ignored", "body": "[N24] Data returned by relayed message is ignored", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n24]-data-returned-by-relayed-message-is-ignored", "labels": ["OpenZeppelin"]}, {"title": "relayMessage function of the", "body": "ovmCALL to the messages target. While the calls success flag is  validated to determine whether the message can be considered successful, the returned data is never stored nor logged. As a consequence, relevant returned data from relayed messages will not be accessible after a message is relayed. The described behavior also occurs in the    Should this be the intended behavior of the relayMessage functions, consider documenting it in the functions docstrings. Otherwise, consider including a mechanism to retrieve the returned data of relayed messages, which could include storing the data in storage, or logging it using an event.  [N25] Duplicated code in cross-domain messenger contracts  The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts behave in a similar way and share a non-trivial amount of duplicated logic.  To reduce code duplication and favor reusability, consider abstracting away repeated logic to an internal function of the Abs_BaseCrossDomainMessenger parent contract.  [N26] Duplicated code for memory copy utility  The _copy function of the Lib_RLPReader library and _memcpy function of the Lib_RLPWriter serve a similar purpose: copying pieces of memory to other locations. To reduce duplicated logic and ease maintenance, consider defining a single memory copy utility function, and reusing it throughout the code base. Alternatively, to favor a simpler implementation, consider using the identity precompile contract at address 0x0000000000000000000000000000000000000004 to copy pieces of memory.  [N27] Redundant check when proving contract state  proveContractState function of the  two conditions. The first condition,  hasAccount, checks whether  the accounts code hash is non-zero. The second condition,  hasEmptyAccount, checks that  the accounts code hash matches the EMPTY_ACCOUNT_CODE_HASH hash.  Since the EMPTY_ACCOUNT_CODE_HASH is non-zero, the second condition implies the first one. Therefore, consider removing the call to hasAccount.  [N28] Base contract not marked as abstract  Contracts that are not intended to be instantiated directly, such as OVM_CrossDomainEnabled, should be marked as abstract to favor readability and avoid unintended usage.  [N29] Inconsistent coding style  Some instances of inconsistent coding style were identified in the code base. Specifically:  While most internal and private functions explicitly denote their visibility by prepending their names with an underscore, functions getCrossDomainMessenger and sendCrossDomainMessage of the OVM_CrossDomainEnabled contract fail to do so.  To favor readability, consider always following a consistent style throughout the code base. We suggest using Soliditys Style Guide as a reference.  [N30] Lack of explicit visibility in state variables  The following state variables and constants are implicitly using the default visibility.  In the OVM_ECDSAContractAccount contract:  The EXECUTION_VALIDATION_GAS_OVERHEAD and ETH_ERC20_ADDRESS constants.  In the OVM_ProxyEOA contract:  The IMPLEMENTATION_KEY constant.  In the Abs_L2DepositedToken contract:  The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant  To favor readability, consider explicitly declaring the visibility of all state variables and constants.  [N31] Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.  The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.  In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.  [N32] Implicit casting operations  The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when its passed to the call to _sendXDomainMessage.  The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transactions nonce matches the expected one.  For added readability, consider making casting operations explicit where possible.  Conclusions  4 critical and 4 high severity issues were found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#relaymessage-function-of-the", "labels": ["OpenZeppelin"]}, {"title": "ovmCALL to the message\u2019s target. While the call\u2019s success flag is", "body": "ovmCALL to the message\u2019s target. While the call\u2019s success flag is", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#ovmcall-to-the-message\u2019s-target.-while-the-call\u2019s-success-flag-is", "labels": ["OpenZeppelin"]}, {"title": "validated to determine whether the message can be considered successful, the returned data is never stored nor logged. As a consequence, relevant returned data from relayed messages will not be accessible after a message is relayed. The described behavior also occurs in the", "body": "validated to determine whether the message can be considered successful, the returned data is never stored nor logged. As a consequence, relevant returned data from relayed messages will not be accessible after a message is relayed. The described behavior also occurs in the", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#validated-to-determine-whether-the-message-can-be-considered-successful,-the-returned-data-is-never-stored-nor-logged.-as-a-consequence,-relevant-returned-data-from-relayed-messages-will-not-be-accessible-after-a-message-is-relayed.-the-described-behavior-also-occurs-in-the", "labels": ["OpenZeppelin"]}, {"title": "Should this be the intended behavior of the relayMessage functions, consider documenting it in the functions\u2019 docstrings. Otherwise, consider including a mechanism to retrieve the returned data of relayed messages, which could include storing the data in storage, or logging it using an event.", "body": "Should this be the intended behavior of the relayMessage functions, consider documenting it in the functions\u2019 docstrings. Otherwise, consider including a mechanism to retrieve the returned data of relayed messages, which could include storing the data in storage, or logging it using an event.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#should-this-be-the-intended-behavior-of-the-relaymessage-functions,-consider-documenting-it-in-the-functions\u2019-docstrings.-otherwise,-consider-including-a-mechanism-to-retrieve-the-returned-data-of-relayed-messages,-which-could-include-storing-the-data-in-storage,-or-logging-it-using-an-event.", "labels": ["OpenZeppelin"]}, {"title": "[N25] Duplicated code in cross-domain messenger contracts", "body": "[N25] Duplicated code in cross-domain messenger contracts", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n25]-duplicated-code-in-cross-domain-messenger-contracts", "labels": ["OpenZeppelin"]}, {"title": "The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts behave in a similar way and share a non-trivial amount of duplicated logic.", "body": "The relayMessage functions of the OVM_L1CrossDomainMessenger and OVM_L2CrossDomainMessenger contracts behave in a similar way and share a non-trivial amount of duplicated logic.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-relaymessage-functions-of-the-ovm_l1crossdomainmessenger-and-ovm_l2crossdomainmessenger-contracts-behave-in-a-similar-way-and-share-a-non-trivial-amount-of-duplicated-logic.", "labels": ["OpenZeppelin"]}, {"title": "To reduce code duplication and favor reusability, consider abstracting away repeated logic to an internal function of the Abs_BaseCrossDomainMessenger parent contract.", "body": "To reduce code duplication and favor reusability, consider abstracting away repeated logic to an internal function of the Abs_BaseCrossDomainMessenger parent contract.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#to-reduce-code-duplication-and-favor-reusability,-consider-abstracting-away-repeated-logic-to-an-internal-function-of-the-abs_basecrossdomainmessenger-parent-contract.", "labels": ["OpenZeppelin"]}, {"title": "[N26] Duplicated code for memory copy utility", "body": "[N26] Duplicated code for memory copy utility", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n26]-duplicated-code-for-memory-copy-utility", "labels": ["OpenZeppelin"]}, {"title": "The _copy function of the Lib_RLPReader library and _memcpy function of the Lib_RLPWriter serve a similar purpose: copying pieces of memory to other locations. To reduce duplicated logic and ease maintenance, consider defining a single memory copy utility function, and reusing it throughout the code base. Alternatively, to favor a simpler implementation, consider using the identity precompile contract at address 0x0000000000000000000000000000000000000004 to copy pieces of memory.", "body": "The _copy function of the Lib_RLPReader library and _memcpy function of the Lib_RLPWriter serve a similar purpose: copying pieces of memory to other locations. To reduce duplicated logic and ease maintenance, consider defining a single memory copy utility function, and reusing it throughout the code base. Alternatively, to favor a simpler implementation, consider using the identity precompile contract at address 0x0000000000000000000000000000000000000004 to copy pieces of memory.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-_copy-function-of-the-lib_rlpreader-library-and-_memcpy-function-of-the-lib_rlpwriter-serve-a-similar-purpose:-copying-pieces-of-memory-to-other-locations.-to-reduce-duplicated-logic-and-ease-maintenance,-consider-defining-a-single-memory-copy-utility-function,-and-reusing-it-throughout-the-code-base.-alternatively,-to-favor-a-simpler-implementation,-consider-using-the-identity-precompile-contract-at-address-0x0000000000000000000000000000000000000004-to-copy-pieces-of-memory.", "labels": ["OpenZeppelin"]}, {"title": "[N27] Redundant check when proving contract state", "body": "[N27] Redundant check when proving contract state", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n27]-redundant-check-when-proving-contract-state", "labels": ["OpenZeppelin"]}, {"title": "proveContractState function of the", "body": "proveContractState function of the", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#provecontractstate-function-of-the", "labels": ["OpenZeppelin"]}, {"title": "two conditions. The first condition,", "body": "two conditions. The first condition,", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#two-conditions.-the-first-condition,", "labels": ["OpenZeppelin"]}, {"title": "hasAccount, checks whether", "body": "hasAccount, checks whether", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#hasaccount,-checks-whether", "labels": ["OpenZeppelin"]}, {"title": "the account\u2019s code hash is non-zero. The second condition,", "body": "the account\u2019s code hash is non-zero. The second condition,", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-account\u2019s-code-hash-is-non-zero.-the-second-condition,", "labels": ["OpenZeppelin"]}, {"title": "hasEmptyAccount, checks that", "body": "hasEmptyAccount, checks that", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#hasemptyaccount,-checks-that", "labels": ["OpenZeppelin"]}, {"title": "the account\u2019s code hash matches the EMPTY_ACCOUNT_CODE_HASH hash.", "body": "the account\u2019s code hash matches the EMPTY_ACCOUNT_CODE_HASH hash.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-account\u2019s-code-hash-matches-the-empty_account_code_hash-hash.", "labels": ["OpenZeppelin"]}, {"title": "Since the EMPTY_ACCOUNT_CODE_HASH is non-zero, the second condition implies the first one. Therefore, consider removing the call to hasAccount.", "body": "Since the EMPTY_ACCOUNT_CODE_HASH is non-zero, the second condition implies the first one. Therefore, consider removing the call to hasAccount.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#since-the-empty_account_code_hash-is-non-zero,-the-second-condition-implies-the-first-one.-therefore,-consider-removing-the-call-to-hasaccount.", "labels": ["OpenZeppelin"]}, {"title": "[N28] Base contract not marked as abstract", "body": "[N28] Base contract not marked as abstract", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n28]-base-contract-not-marked-as-abstract", "labels": ["OpenZeppelin"]}, {"title": "Contracts that are not intended to be instantiated directly, such as OVM_CrossDomainEnabled, should be marked as abstract to favor readability and avoid unintended usage.", "body": "Contracts that are not intended to be instantiated directly, such as OVM_CrossDomainEnabled, should be marked as abstract to favor readability and avoid unintended usage.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#contracts-that-are-not-intended-to-be-instantiated-directly,-such-as-ovm_crossdomainenabled,-should-be-marked-as-abstract-to-favor-readability-and-avoid-unintended-usage.", "labels": ["OpenZeppelin"]}, {"title": "[N29] Inconsistent coding style", "body": "[N29] Inconsistent coding style", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n29]-inconsistent-coding-style", "labels": ["OpenZeppelin"]}, {"title": "Some instances of inconsistent coding style were identified in the code base. Specifically:", "body": "Some instances of inconsistent coding style were identified in the code base. Specifically:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#some-instances-of-inconsistent-coding-style-were-identified-in-the-code-base.-specifically:", "labels": ["OpenZeppelin"]}, {"title": "While most internal and private functions explicitly denote their visibility by prepending their names with an underscore, functions getCrossDomainMessenger and sendCrossDomainMessage of the OVM_CrossDomainEnabled contract fail to do so.", "body": "While most internal and private functions explicitly denote their visibility by prepending their names with an underscore, functions getCrossDomainMessenger and sendCrossDomainMessage of the OVM_CrossDomainEnabled contract fail to do so.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#while-most-internal-and-private-functions-explicitly-denote-their-visibility-by-prepending-their-names-with-an-underscore,-functions-getcrossdomainmessenger-and-sendcrossdomainmessage-of-the-ovm_crossdomainenabled-contract-fail-to-do-so.", "labels": ["OpenZeppelin"]}, {"title": "To favor readability, consider always following a consistent style throughout the code base. We suggest using Solidity\u2019s Style Guide as a reference.", "body": "To favor readability, consider always following a consistent style throughout the code base. We suggest using Solidity\u2019s Style Guide as a reference.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#to-favor-readability,-consider-always-following-a-consistent-style-throughout-the-code-base.-we-suggest-using-solidity\u2019s-style-guide-as-a-reference.", "labels": ["OpenZeppelin"]}, {"title": "[N30] Lack of explicit visibility in state variables", "body": "[N30] Lack of explicit visibility in state variables", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n30]-lack-of-explicit-visibility-in-state-variables", "labels": ["OpenZeppelin"]}, {"title": "The following state variables and constants are implicitly using the default visibility.", "body": "The following state variables and constants are implicitly using the default visibility.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-following-state-variables-and-constants-are-implicitly-using-the-default-visibility.", "labels": ["OpenZeppelin"]}, {"title": "In the OVM_ECDSAContractAccount contract:", "body": "The EXECUTION_VALIDATION_GAS_OVERHEAD and ETH_ERC20_ADDRESS constants.  In the OVM_ProxyEOA contract:  The IMPLEMENTATION_KEY constant.  In the Abs_L2DepositedToken contract:  The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant  To favor readability, consider explicitly declaring the visibility of all state variables and constants.  [N31] Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.  The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.  In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.  [N32] Implicit casting operations  The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when its passed to the call to _sendXDomainMessage.  The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transactions nonce matches the expected one.  For added readability, consider making casting operations explicit where possible.  Conclusions  4 critical and 4 high severity issues were found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-ovm_ecdsacontractaccount-contract:", "labels": ["OpenZeppelin"]}, {"title": "The EXECUTION_VALIDATION_GAS_OVERHEAD and ETH_ERC20_ADDRESS constants.", "body": "The EXECUTION_VALIDATION_GAS_OVERHEAD and ETH_ERC20_ADDRESS constants.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-execution_validation_gas_overhead-and-eth_erc20_address-constants.", "labels": ["OpenZeppelin"]}, {"title": "In the OVM_ProxyEOA contract:", "body": "In the OVM_ProxyEOA contract:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-ovm_proxyeoa-contract:", "labels": ["OpenZeppelin"]}, {"title": "The IMPLEMENTATION_KEY constant.", "body": "The IMPLEMENTATION_KEY constant.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-implementation_key-constant.", "labels": ["OpenZeppelin"]}, {"title": "In the Abs_L2DepositedToken contract:", "body": "The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant  To favor readability, consider explicitly declaring the visibility of all state variables and constants.  [N31] Naming issues  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.  The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.  In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.  [N32] Implicit casting operations  The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when its passed to the call to _sendXDomainMessage.  The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transactions nonce matches the expected one.  For added readability, consider making casting operations explicit where possible.  Conclusions  4 critical and 4 high severity issues were found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-abs_l2depositedtoken-contract:", "labels": ["OpenZeppelin"]}, {"title": "The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant", "body": "The DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS constant", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-default_finalize_withdrawal_l1_gas-constant", "labels": ["OpenZeppelin"]}, {"title": "To favor readability, consider explicitly declaring the visibility of all state variables and constants.", "body": "To favor readability, consider explicitly declaring the visibility of all state variables and constants.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#to-favor-readability,-consider-explicitly-declaring-the-visibility-of-all-state-variables-and-constants.", "labels": ["OpenZeppelin"]}, {"title": "[N31] Naming issues", "body": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.  The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.  In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.  [N32] Implicit casting operations  The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when its passed to the call to _sendXDomainMessage.  The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transactions nonce matches the expected one.  For added readability, consider making casting operations explicit where possible.  Conclusions  4 critical and 4 high severity issues were found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n31]-naming-issues", "labels": ["OpenZeppelin"]}, {"title": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:", "body": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#to-favor-explicitness-and-readability,-several-parts-of-the-contracts-may-benefit-from-better-naming.-our-suggestions-are:", "labels": ["OpenZeppelin"]}, {"title": "The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.", "body": "The FRAUD_PROOF_WINDOW state variable should be renamed to FRAUD_PROOF_WINDOW_IN_SECONDS.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-fraud_proof_window-state-variable-should-be-renamed-to-fraud_proof_window_in_seconds.", "labels": ["OpenZeppelin"]}, {"title": "The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.", "body": "The SEQUENCER_PUBLISH_WINDOW state variable should be renamed to SEQUENCER_PUBLISH_WINDOW_IN_SECONDS.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-sequencer_publish_window-state-variable-should-be-renamed-to-sequencer_publish_window_in_seconds.", "labels": ["OpenZeppelin"]}, {"title": "In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.", "body": "In the _appendBatch function, a local variable sequencer is assigned the address resolved for the OVM_Proposer key. As the proposer might not be the sequencer (their roles having been split in PR#252), the local variable name should be modified to avoid confusion.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#in-the-_appendbatch-function,-a-local-variable-sequencer-is-assigned-the-address-resolved-for-the-ovm_proposer-key.-as-the-proposer-might-not-be-the-sequencer-(their-roles-having-been-split-in-pr#252),-the-local-variable-name-should-be-modified-to-avoid-confusion.", "labels": ["OpenZeppelin"]}, {"title": "[N32] Implicit casting operations", "body": "[N32] Implicit casting operations", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#[n32]-implicit-casting-operations", "labels": ["OpenZeppelin"]}, {"title": "The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when it\u2019s passed to the call to _sendXDomainMessage.", "body": "The sendMessage function of the Abs_BaseCrossDomainMessenger contract implicitly upcasts its _gasLimit parameter from uint32 to uint256 when it\u2019s passed to the call to _sendXDomainMessage.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-sendmessage-function-of-the-abs_basecrossdomainmessenger-contract-implicitly-upcasts-its-_gaslimit-parameter-from-uint32-to-uint256-when-it\u2019s-passed-to-the-call-to-_sendxdomainmessage.", "labels": ["OpenZeppelin"]}, {"title": "The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transaction\u2019s nonce matches the expected one.", "body": "The execute function of the OVM_ECDSAContractAccount contract implicitly casts a uint64 number to uint256 when validatingthat the transaction\u2019s nonce matches the expected one.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#the-execute-function-of-the-ovm_ecdsacontractaccount-contract-implicitly-casts-a-uint64-number-to-uint256-when-validatingthat-the-transaction\u2019s-nonce-matches-the-expected-one.", "labels": ["OpenZeppelin"]}, {"title": "For added readability, consider making casting operations explicit where possible.", "body": "For added readability, consider making casting operations explicit where possible.", "html_url": "https://blog.openzeppelin.com/optimism-smart-contracts-audit#for-added-readability,-consider-making-casting-operations-explicit-where-possible.", "labels": ["OpenZeppelin"]}, {"title": "[N01] Event parameters are not indexed", "body": "[N01] Event parameters are not indexed", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#[n01]-event-parameters-are-not-indexed", "labels": ["OpenZeppelin"]}, {"title": "Throughout the codebase, there was a lack of index used on event parameters. For example, the VoteCast and ProposalQueued event parameters are not indexed. Consider indexing event parameters so event logs are easier to be queried and used by offline services.", "body": "Throughout the codebase, there was a lack of index used on event parameters. For example, the VoteCast and ProposalQueued event parameters are not indexed. Consider indexing event parameters so event logs are easier to be queried and used by offline services.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#throughout-the-codebase,-there-was-a-lack-of-index-used-on-event-parameters.-for-example,-the-votecast-and-proposalqueued-event-parameters-are-not-indexed.-consider-indexing-event-parameters-so-event-logs-are-easier-to-be-queried-and-used-by-offline-services.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request 29.", "body": "[N05] Revert messages statements are missing  Some require statements are missing their respective revert messages. For example:  line 160 in GovernorAlpha.sol.  line 88 in NoteERC20.sol.  line 93 in NoteERC20.sol.  line 99 in NoteERC20.sol.  To improve the codes readability and to help debugging issues that may arise, consider always including revert messages in all require statements.  Update: Acknowledged, and will not fix. Notionals statement for this issue:  Wont fix, require strings add to deployed code size which increase gas costs for users. Initialize will only be called once so this is a fair trade off.  [N06] Unused import  The GovernorAlpha contract imports Constants.sol, but does not use it. To improve readability and avoid confusion, consider removing unused imports.    Conclusions  1 high severity issue was found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#update:-fixed-in-pull-request-29.", "labels": ["OpenZeppelin"]}, {"title": "[N02] Gas Optimizations", "body": "[N02] Gas Optimizations", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#[n02]-gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "executeProposal function from the", "body": "executeBatch function from the OpenZeppelins  _executeBatch function. However, if the proposal is still queued, the transaction will revert just before the end  while checking the timelock, instead of failing early before several calls to contracts are made.  Consider reviewing the codebase for such occurrences and refactoring by returning or failing earlier for gas efficiency.  Update: Acknowledged, and will not fix. Notionals statement for this issue:  Wont fix, will just rely on the client to check that this works before submitting.  [N03] Inconsistent coding style  Some instances of inconsistent coding style and style guide deviations were identified in the code base. Specifically:  The GovernorAlpha contract inherits the functionality of the OpenZeppelins TimeLockController contract. If a proposal is cancelled, the contract will trigger two events as shown in the documentation. However, the names of the events are spelled in different English styles. To improve the codebases consistency, the name of the event from the GovernorAlpha contract should be changed to match its equivalent event in the TimeLockController contract.  The functions in the GovernorAlpha contract do not follow the recommended order of: constructor, fallback, external, public, internal, private. For example, the private _computeHash function comes before the external queueProposal function.  The GovernorAlpha contract checks if the current block number fits inside a uint32 variable type in order to prevent errors due to its internal accounting system. The NoteERC20 contract also performs this check by using a dedicated function in several places of the code. However, the GovernorAlpha contract does not perform this check in all places where the block number is used, such as in the cancelProposal or the state functions.  Constants should follow the UPPER_CASE notation. Some deviations were identified, such as the name and proposalMaxOperations constants.  For long function declarations, such as castVoteBySig, consider putting the opening brace on its own line.  For functions with lots of arguments, such as hashOperationBatch, consider dropping each argument onto its own line.  The GovernorAlpha.sol file implements a minimal interface for the NoteERC20 contract which is then used by the GovernorAlpha contract. However, the NoteInterface name does not follow the usual naming style for interfaces, which should be INoteERC20. Furthermore, this interface is placed inside the same file where the contract that uses it is, instead of importing the respective interfaces file at the beginning of the file.  Some revert messages in the GovernorAlpha contract do not follow the same style as other revert messages in the same contract.  GoverorAlpha provides \"\" as the optional predecessor argument for hashOperationBatch, instead of the recommended bytes32(0).  To favor readability, consider always following a consistent style throughout the code base. We suggest using Soliditys Style Guide as a reference with the help of linter tools such as Solhint.  Update: Partially fixed on pull request 29. Issue has been updated based on the teams response. Further Notionals statements for this issue:  Wont fix, prefer to have internal / private methods near the functions where they are referenced for readability  Wont fix name as it is used as a public getter as well  Wont fix, not compatible with with prettier config  Wont fix revert messages  [N04] Proposal states overlap during voting expiry  The GovernorAlpha contract implements the state function that outputs the current state of a proposal.  However, there are two states that overlap their conditions during the expiration of the voting period: the Active and the Succeeded states.  Although this does not represent a security issue, because the first conditional to be checked will be the Active state, having two overlapped states may render the codes readability when transactions are sent during expiry.  Consider restricting the Succeeded state to be active when the block number is strictly greater than the endBlock value.  Update: Fixed in pull request 29.  [N05] Revert messages statements are missing  Some require statements are missing their respective revert messages. For example:  line 160 in GovernorAlpha.sol.  line 88 in NoteERC20.sol.  line 93 in NoteERC20.sol.  line 99 in NoteERC20.sol.  To improve the codes readability and to help debugging issues that may arise, consider always including revert messages in all require statements.  Update: Acknowledged, and will not fix. Notionals statement for this issue:  Wont fix, require strings add to deployed code size which increase gas costs for users. Initialize will only be called once so this is a fair trade off.  [N06] Unused import  The GovernorAlpha contract imports Constants.sol, but does not use it. To improve readability and avoid confusion, consider removing unused imports.  Update: Fixed in pull request 29.  Conclusions  1 high severity issue was found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#executeproposal-function-from-the", "labels": ["OpenZeppelin"]}, {"title": "executeBatch function from the OpenZeppelin\u2019s", "body": "executeBatch function from the OpenZeppelin\u2019s", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#executebatch-function-from-the-openzeppelin\u2019s", "labels": ["OpenZeppelin"]}, {"title": "_executeBatch function. However, if the proposal is still queued, the transaction will revert just before the end", "body": "_executeBatch function. However, if the proposal is still queued, the transaction will revert just before the end", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#_executebatch-function.-however,-if-the-proposal-is-still-queued,-the-transaction-will-revert-just-before-the-end", "labels": ["OpenZeppelin"]}, {"title": "while checking the timelock, instead of failing early before several calls to contracts are made.", "body": "while checking the timelock, instead of failing early before several calls to contracts are made.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#while-checking-the-timelock,-instead-of-failing-early-before-several-calls-to-contracts-are-made.", "labels": ["OpenZeppelin"]}, {"title": "Consider reviewing the codebase for such occurrences and refactoring by returning or failing earlier for gas efficiency.", "body": "Consider reviewing the codebase for such occurrences and refactoring by returning or failing earlier for gas efficiency.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#consider-reviewing-the-codebase-for-such-occurrences-and-refactoring-by-returning-or-failing-earlier-for-gas-efficiency.", "labels": ["OpenZeppelin"]}, {"title": "Update: Acknowledged, and will not fix. Notional\u2019s statement for this issue:", "body": "Wont fix, the intention is to only use the reservoir for NOTE tokens.  [M08] Untested custom SafeMath library in use  The GovernorAlpha and the NoteERC20 contracts make use of a SafeMath alike library embedded into the contracts based on OpenZeppelins SafeMath library, customized to support safe mathematical operations for unsigned integers of 32 and 96 bits. Yet, none of the functions in the implemented SafeMath library are tested, which may hinder users and developers trust in this custom library. Moreover, any change in the library is not going to be detected by the current test suite, rendering all business logic depending on it vulnerable to potential security issues introduced by these future modifications.  Consider including thorough and extensive unit tests for the SafeMath library.    Wont fix, have manually tested that the methods dont overflow.  [M09] Variables are not initialized  In the NoteERC20 contract a for statement is used to distribute the grant tokens between all the initial accounts.  However, the index i used to cycle among all the elements is not initialized with zero and its default value is used instead. Relying on the default value of a variable is not a recommended and secure methodology to perform due to the unexpected effects that may occur when this is not true, whether it is the result of a compilation bug or the outcome of a security issue.  Similarly, during the contract initialization, the totalGrants variable is used as a counter for all the distributed grant tokens but it is not initialized with a zero value before its usage.  Consider initializing all variables, specially indexes and counters, that will use their initial value during operation.  Update: Fixed in pull request 23.  Low severity  [L01] Users can emit Approval and VoteCast events to deceive offline services  The NoteERC20 contract implements the functionalities of the NOTE token that allow users to delegate their voting power and vote proposals. However, if a non-allowed user tries to transfer zero number of tokens on behalf of another another account by calling the transferFrom function, the transaction will not only succeed but will also emit both the Transfer and Approval events, allowing a malicious user to disguise this harmless transaction as an approval on a non-owned account.  Similarly, in the GovernorAlpha contract, the _castVote function can also be successfully used by an user that does not have any voting power to submit their vote, resulting in the emission of the VoteCast event.  Although these situations will not impact in the votings result nor the users balances, the emission of these Approval and VoteCast events may be used to spam offline services, to confuse users, or to perform phishing attacks. Consider either requiring non-zero values in those functions to prevent users from being deceived and to improve the readability of off-chain services that track event logs, or documenting and letting the users know about this possible attack.  Update: Fixed on pull request 26. However, the changes has broken the ERC20 compliant token compatibility because no Transfer event is emitted on zero value transfers. Consider emitting the Transfer event on such cases.  [L02] Lack of guardian-role transfer  The guardian address from the GovernorAlpha contract has a special role inside the system.  However, if the address associated with the guardian gets compromised, there is no way to transfer those special roles to another address.  Consider creating a function to transfer the guardian role to another address or consider documenting this limitation.  Update: Fixed in pull request 30.  [L03] Implicit casting  Throughout the codebase, many instances of implicit casting between types exist.  Some examples of such behavior can be found in the NoteERC20.sol file on:  Line 96 where the each element of the initialGrantAmount is being casted in the Transfer event.  Line 99 where an implicit casting on the granted amount occurs when it is being compared to the total supply.  Line 107 where the allowance in uint96 for a pair of accounts is casted into uint256 by the return operation.  Line 127 where the amount value is casted in the Approval event.  Line 135 where the balance in uint96 is casted into uint256 by the return operation.  Whenever a different type of variable is needed, consider either checking and casting the variable into the desired type or using OpenZeppelins SafeCast library which provides overflow checking when casting from one type of number to another.    Wont fix this, it adds to gas costs to do this checking and since we are casting to larger unsigned sizes I dont see a potential overflow issue.  [L04] Misleading comments  Throughout the codebase there are cases of misleading or inaccurate documentation. Some examples are:  The description of the dripRate_ parameter for the Reservoir constructor claims to be tokens per block, but the implementation is actually tokens per second as described in the DRIP_RATE variable.  The documentation for the quorumVotes parameter state that for a vote to succeed although it should be either for a voting process to succeed or for a proposal to succeed.  Consider fixing these and all misleading comments in the codebase to improve the codes readability.  Update: Fixed in pull request 27.  [L05] Lack of input validation  Several external functions fail to validate the input parameters supplied. For example:  The initialization of the Reservoir contract completely lacks input validation, such as validating whether the token_ address corresponds to a real contract and whether the dripRate_ value is greater than zero.  The notionalProxy_ address from the NoteERC20 contract does not check if that address corresponds to a contracts address.  The constructor function from the GovernorAlpha contract does not check if the note_ address corresponds to a contracts address. Moreover, the quorumVotes_, the proposalThreshold_, the votingDelayBlocks_, and the votingPeriodBlocks_ values are not being check in any sense, which could result in the ability to vote a proposal without the need of voting power, the inability to vote a proposal if the voting period is zero, or the inability to pass a proposal due to a shortage of needed voting power, among other outcomes.  Similarly, in the GovernorAlpha contract, the updateQuorumVotes, the updateProposalThreshold, the updateVotingDelayBlocks, and the updateVotingPeriodBlocks functions lack of input validation, which may cause the outcomes mentioned above.  To avoid errors and unexpected system behavior, consider explicitly restricting the range of inputs that can be accepted for all externally-provided inputs via require clauses where appropriate. For all cases of contracts addresses, consider using the OpenZeppelins Address library to check that the input address corresponds to a contracts address.  Update: Partially fixed in pull request 32. Some of the protocols parameters are still not checked against a zero value. Furthermore, the code does not enforce validation over the voting period due to conflicts with the tests. Notionals statement for this issue:  No validation is done for quorumVotes, proposalThreshold and votingDelayBlocks because it is not clear what values would be reasonable minimums or maximums there.  [L06] Missing and / or incomplete docstrings  Some contracts and functions in the code base lack documentation or include incomplete descriptions. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted. Below we list all instances detected during the audit.  In the Constants library:  Several constants lack their documentation stating its purpose and the reason of its value, such as the FCASH_ASSET_TYPE constant.  In the GovernorAlpha contract:  The getReceipt function is missing a docstring for the return value.  The state function contains an incomplete docstring for the return value.  The updateQuorumVotes function is missing all its documentation.  The updateProposalThreshold function is missing all its documentation.  The updateVotingDelayBlocks function is missing all its documentation.  The updateVotingPeriodBlocks function is missing all its documentation.  The constructor function is missing all its documentation.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Partially fixed in pull request 27. No documentation has been added to the Constants library, such as on the FCASH_ASSET_TYPE constant.  [L07] Not using SafeMath functions  Although several parts of the codebase employs its custom SafeMath methods where appropriate, there are still a few instances of regular Solidity arithmetic operators being used. Some examples are:  On line 191 of GovernorAlpha.sol a + is used.  On line 56 of Reservoir.sol a - is used.  On line 221 of NoteERC20.sol a - is used.  On line 244 of NoteERC20.sol a - is used.  On line 245 of NoteERC20.sol a - is used.  On line 254 of NoteERC20.sol a - is used.  On line 361 of NoteERC20.sol a - is used.  On line 365 of NoteERC20.sol a + is used.  Although these cases do not represent a security risk per se, consider always performing arithmetic operations with methods that protect the system from such possibilities, like the math libraries of OpenZeppelin contracts.    Wont fix, overflow in any of these cases is highly unlikely  [L08] Transfer of ERC20 tokens do not use SafeERC20  The drip function from the Reservoir contract transfers a fix-rate of ERC-20 tokens to a target address based on its deployment parameters. The transfer call used is then checked for success. However, some ERC-20 compliant tokens may not return a boolean.  To handle a broader variety of tokens, consider using the safeTransfer method from the OpenZeppelins SafeERC20 library as an alternative.    Wont fix, theres no intention of expanding the use case beyond NOTE tokens  [L09] Proposals never reach the Queued state  The state function from the GovernorAlpha contract is used to return the current state of any proposal. The possible states are stored in the ProposalState enum and the proposals mapping contains a record of all proposals data in any state.  Due to the logic used for determining the Succeeded state, a queued proposal will never be able to reach the Queued state, even after the queueProposal function has been called.  Update: Fixed in pull request 31. The state function now validates if the proposal is queued by checking if it is still pending.  [L10] Re-implementing ECDSA signature recovery  The castVoteBySig function from the GovernorAlpha contract and the delegateBySig function from the NoteERC20 contract include an implementation of the ECDSA signature recovery function. This function is already part of the OpenZeppelin contracts, which has been audited and is constantly reviewed by the community.  Consider importing and using the recover function from OpenZeppelins ECDSA library not only to benefit from bug fixes to be applied in future releases, but also to reduce the codes attack surface.  Update: Fixed in pull request 28. However, because the OpenZeppelins ECDSA library already checks if the outcome is the zero address, the same validation from the GovernorAlpha contract is redundant. Consider removing it. The same note applies to the respective case in the NoteERC20 contract.  [L11] Proposal execution not handling returned data  The executeProposal function from the GovernorAlpha contract allows any user to execute a proposal from the timelock queue once the delay has passed. This is accomplished through the executeBatch function from OpenZeppelins TimelockController contract.  Currently the executeBatch function does not handle data returned by executed transactions. Although OpenZeppelin plans to implement this soon in the TimelockController contract, consider extending the functionality in order to handle return data from the proposals execution.  Update: Acknowledged. Notionals statement for this issue:  Wont fix, will use the OZ implementation when it is ready. Its not clear how a set of governance proposals will actually use return data during a batch of transaction executions.  [L12] Unnecessary return statements  The delegate and delegateBySig functions use return when calling the _delegate function. However, because the _delegate function does not return any output, these return statements are needless.  To avoid confusion and improve the codes readability, consider removing the unnecessary return statements from the code.  Update: Fixed in pull request 28.  Notes & Additional Information  [N01] Event parameters are not indexed  Throughout the codebase, there was a lack of index used on event parameters. For example, the VoteCast and ProposalQueued event parameters are not indexed. Consider indexing event parameters so event logs are easier to be queried and used by offline services.  Update: Fixed in pull request 29.  [N02] Gas Optimizations  executeProposal function from the  executeBatch function from the OpenZeppelins  _executeBatch function. However, if the proposal is still queued, the transaction will revert just before the end  while checking the timelock, instead of failing early before several calls to contracts are made.  Consider reviewing the codebase for such occurrences and refactoring by returning or failing earlier for gas efficiency.    Wont fix, will just rely on the client to check that this works before submitting.  [N03] Inconsistent coding style  Some instances of inconsistent coding style and style guide deviations were identified in the code base. Specifically:  The GovernorAlpha contract inherits the functionality of the OpenZeppelins TimeLockController contract. If a proposal is cancelled, the contract will trigger two events as shown in the documentation. However, the names of the events are spelled in different English styles. To improve the codebases consistency, the name of the event from the GovernorAlpha contract should be changed to match its equivalent event in the TimeLockController contract.  The functions in the GovernorAlpha contract do not follow the recommended order of: constructor, fallback, external, public, internal, private. For example, the private _computeHash function comes before the external queueProposal function.  The GovernorAlpha contract checks if the current block number fits inside a uint32 variable type in order to prevent errors due to its internal accounting system. The NoteERC20 contract also performs this check by using a dedicated function in several places of the code. However, the GovernorAlpha contract does not perform this check in all places where the block number is used, such as in the cancelProposal or the state functions.  Constants should follow the UPPER_CASE notation. Some deviations were identified, such as the name and proposalMaxOperations constants.  For long function declarations, such as castVoteBySig, consider putting the opening brace on its own line.  For functions with lots of arguments, such as hashOperationBatch, consider dropping each argument onto its own line.  The GovernorAlpha.sol file implements a minimal interface for the NoteERC20 contract which is then used by the GovernorAlpha contract. However, the NoteInterface name does not follow the usual naming style for interfaces, which should be INoteERC20. Furthermore, this interface is placed inside the same file where the contract that uses it is, instead of importing the respective interfaces file at the beginning of the file.  Some revert messages in the GovernorAlpha contract do not follow the same style as other revert messages in the same contract.  GoverorAlpha provides \"\" as the optional predecessor argument for hashOperationBatch, instead of the recommended bytes32(0).  To favor readability, consider always following a consistent style throughout the code base. We suggest using Soliditys Style Guide as a reference with the help of linter tools such as Solhint.  Update: Partially fixed on pull request 29. Issue has been updated based on the teams response. Further Notionals statements for this issue:  Wont fix, prefer to have internal / private methods near the functions where they are referenced for readability  Wont fix name as it is used as a public getter as well  Wont fix, not compatible with with prettier config  Wont fix revert messages  [N04] Proposal states overlap during voting expiry  The GovernorAlpha contract implements the state function that outputs the current state of a proposal.  However, there are two states that overlap their conditions during the expiration of the voting period: the Active and the Succeeded states.  Although this does not represent a security issue, because the first conditional to be checked will be the Active state, having two overlapped states may render the codes readability when transactions are sent during expiry.  Consider restricting the Succeeded state to be active when the block number is strictly greater than the endBlock value.  Update: Fixed in pull request 29.  [N05] Revert messages statements are missing  Some require statements are missing their respective revert messages. For example:  line 160 in GovernorAlpha.sol.  line 88 in NoteERC20.sol.  line 93 in NoteERC20.sol.  line 99 in NoteERC20.sol.  To improve the codes readability and to help debugging issues that may arise, consider always including revert messages in all require statements.    Wont fix, require strings add to deployed code size which increase gas costs for users. Initialize will only be called once so this is a fair trade off.  [N06] Unused import  The GovernorAlpha contract imports Constants.sol, but does not use it. To improve readability and avoid confusion, consider removing unused imports.  Update: Fixed in pull request 29.  Conclusions  1 high severity issue was found. Several changes and recommendations were proposed to reduce the codes attack surface and improve its overall quality.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#update:-acknowledged,-and-will-not-fix.-notional\u2019s-statement-for-this-issue:", "labels": ["OpenZeppelin"]}, {"title": "Won\u2019t fix, will just rely on the client to check that this works before submitting.", "body": "Won\u2019t fix, will just rely on the client to check that this works before submitting.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#won\u2019t-fix,-will-just-rely-on-the-client-to-check-that-this-works-before-submitting.", "labels": ["OpenZeppelin"]}, {"title": "[N03] Inconsistent coding style", "body": "[N03] Inconsistent coding style", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#[n03]-inconsistent-coding-style", "labels": ["OpenZeppelin"]}, {"title": "Some instances of inconsistent coding style and style guide deviations were identified in the code base. Specifically:", "body": "Some instances of inconsistent coding style and style guide deviations were identified in the code base. Specifically:", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#some-instances-of-inconsistent-coding-style-and-style-guide-deviations-were-identified-in-the-code-base.-specifically:", "labels": ["OpenZeppelin"]}, {"title": "The GovernorAlpha contract inherits the functionality of the OpenZeppelin\u2019s TimeLockController contract. If a proposal is cancelled, the contract will trigger two events as shown in the documentation. However, the names of the events are spelled in different English styles. To improve the codebase\u2019s consistency, the name of the event from the GovernorAlpha contract should be changed to match its equivalent event in the TimeLockController contract.", "body": "The GovernorAlpha contract inherits the functionality of the OpenZeppelin\u2019s TimeLockController contract. If a proposal is cancelled, the contract will trigger two events as shown in the documentation. However, the names of the events are spelled in different English styles. To improve the codebase\u2019s consistency, the name of the event from the GovernorAlpha contract should be changed to match its equivalent event in the TimeLockController contract.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#the-governoralpha-contract-inherits-the-functionality-of-the-openzeppelin\u2019s-timelockcontroller-contract.-if-a-proposal-is-cancelled,-the-contract-will-trigger-two-events-as-shown-in-the-documentation.-however,-the-names-of-the-events-are-spelled-in-different-english-styles.-to-improve-the-codebase\u2019s-consistency,-the-name-of-the-event-from-the-governoralpha-contract-should-be-changed-to-match-its-equivalent-event-in-the-timelockcontroller-contract.", "labels": ["OpenZeppelin"]}, {"title": "The functions in the GovernorAlpha contract do not follow the recommended order of: constructor, fallback, external, public, internal, private. For example, the private _computeHash function comes before the external queueProposal function.", "body": "The functions in the GovernorAlpha contract do not follow the recommended order of: constructor, fallback, external, public, internal, private. For example, the private _computeHash function comes before the external queueProposal function.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#the-functions-in-the-governoralpha-contract-do-not-follow-the-recommended-order-of:-constructor,-fallback,-external,-public,-internal,-private.-for-example,-the-private-_computehash-function-comes-before-the-external-queueproposal-function.", "labels": ["OpenZeppelin"]}, {"title": "The GovernorAlpha contract checks if the current block number fits inside a uint32 variable type in order to prevent errors due to its internal accounting system. The NoteERC20 contract also performs this check by using a dedicated function in several places of the code. However, the GovernorAlpha contract does not perform this check in all places where the block number is used, such as in the cancelProposal or the state functions.", "body": "The GovernorAlpha contract checks if the current block number fits inside a uint32 variable type in order to prevent errors due to its internal accounting system. The NoteERC20 contract also performs this check by using a dedicated function in several places of the code. However, the GovernorAlpha contract does not perform this check in all places where the block number is used, such as in the cancelProposal or the state functions.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#the-governoralpha-contract-checks-if-the-current-block-number-fits-inside-a-uint32-variable-type-in-order-to-prevent-errors-due-to-its-internal-accounting-system.-the-noteerc20-contract-also-performs-this-check-by-using-a-dedicated-function-in-several-places-of-the-code.-however,-the-governoralpha-contract-does-not-perform-this-check-in-all-places-where-the-block-number-is-used,-such-as-in-the-cancelproposal-or-the-state-functions.", "labels": ["OpenZeppelin"]}, {"title": "Constants should follow the UPPER_CASE notation. Some deviations were identified, such as the name and proposalMaxOperations constants.", "body": "Constants should follow the UPPER_CASE notation. Some deviations were identified, such as the name and proposalMaxOperations constants.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#constants-should-follow-the-upper_case-notation.-some-deviations-were-identified,-such-as-the-name-and-proposalmaxoperations-constants.", "labels": ["OpenZeppelin"]}, {"title": "For long function declarations, such as castVoteBySig, consider putting the opening brace on it\u2019s own line.", "body": "For long function declarations, such as castVoteBySig, consider putting the opening brace on it\u2019s own line.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#for-long-function-declarations,-such-as-castvotebysig,-consider-putting-the-opening-brace-on-it\u2019s-own-line.", "labels": ["OpenZeppelin"]}, {"title": "For functions with lots of arguments, such as hashOperationBatch, consider dropping each argument onto it\u2019s own line.", "body": "For functions with lots of arguments, such as hashOperationBatch, consider dropping each argument onto it\u2019s own line.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#for-functions-with-lots-of-arguments,-such-as-hashoperationbatch,-consider-dropping-each-argument-onto-it\u2019s-own-line.", "labels": ["OpenZeppelin"]}, {"title": "The GovernorAlpha.sol file implements a minimal interface for the NoteERC20 contract which is then used by the GovernorAlpha contract. However, the NoteInterface name does not follow the usual naming style for interfaces, which should be INoteERC20. Furthermore, this interface is placed inside the same file where the contract that uses it is, instead of importing the respective interface\u2019s file at the beginning of the file.", "body": "The GovernorAlpha.sol file implements a minimal interface for the NoteERC20 contract which is then used by the GovernorAlpha contract. However, the NoteInterface name does not follow the usual naming style for interfaces, which should be INoteERC20. Furthermore, this interface is placed inside the same file where the contract that uses it is, instead of importing the respective interface\u2019s file at the beginning of the file.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#the-governoralpha.sol-file-implements-a-minimal-interface-for-the-noteerc20-contract-which-is-then-used-by-the-governoralpha-contract.-however,-the-noteinterface-name-does-not-follow-the-usual-naming-style-for-interfaces,-which-should-be-inoteerc20.-furthermore,-this-interface-is-placed-inside-the-same-file-where-the-contract-that-uses-it-is,-instead-of-importing-the-respective-interface\u2019s-file-at-the-beginning-of-the-file.", "labels": ["OpenZeppelin"]}, {"title": "Some revert messages in the GovernorAlpha contract do not follow the same style as other revert messages in the same contract.", "body": "Some revert messages in the GovernorAlpha contract do not follow the same style as other revert messages in the same contract.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#some-revert-messages-in-the-governoralpha-contract-do-not-follow-the-same-style-as-other-revert-messages-in-the-same-contract.", "labels": ["OpenZeppelin"]}, {"title": "GoverorAlpha provides \"\" as the optional predecessor argument for hashOperationBatch, instead of the recommended bytes32(0).", "body": "GoverorAlpha provides \"\" as the optional predecessor argument for hashOperationBatch, instead of the recommended bytes32(0).", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#goveroralpha-provides-\"\"-as-the-optional-predecessor-argument-for-hashoperationbatch,-instead-of-the-recommended-bytes32(0).", "labels": ["OpenZeppelin"]}, {"title": "To favor readability, consider always following a consistent style throughout the code base. We suggest using Solidity\u2019s Style Guide as a reference with the help of linter tools such as Solhint.", "body": "To favor readability, consider always following a consistent style throughout the code base. We suggest using Solidity\u2019s Style Guide as a reference with the help of linter tools such as Solhint.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#to-favor-readability,-consider-always-following-a-consistent-style-throughout-the-code-base.-we-suggest-using-solidity\u2019s-style-guide-as-a-reference-with-the-help-of-linter-tools-such-as-solhint.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed on pull request 29. Issue has been updated based on the team\u2019s response. Further Notional\u2019s statements for this issue:", "body": "Update: Partially fixed on pull request 29. Issue has been updated based on the team\u2019s response. Further Notional\u2019s statements for this issue:", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#update:-partially-fixed-on-pull-request-29.-issue-has-been-updated-based-on-the-team\u2019s-response.-further-notional\u2019s-statements-for-this-issue:", "labels": ["OpenZeppelin"]}, {"title": "Won\u2019t fix, prefer to have internal / private methods near the functions where they are referenced for readability", "body": "Won\u2019t fix, prefer to have internal / private methods near the functions where they are referenced for readability", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#won\u2019t-fix,-prefer-to-have-internal-/-private-methods-near-the-functions-where-they-are-referenced-for-readability", "labels": ["OpenZeppelin"]}, {"title": "Won\u2019t fix name as it is used as a public getter as well", "body": "Won\u2019t fix name as it is used as a public getter as well", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#won\u2019t-fix-name-as-it-is-used-as-a-public-getter-as-well", "labels": ["OpenZeppelin"]}, {"title": "Won\u2019t fix, not compatible with with prettier config", "body": "Won\u2019t fix, not compatible with with prettier config", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#won\u2019t-fix,-not-compatible-with-with-prettier-config", "labels": ["OpenZeppelin"]}, {"title": "Won\u2019t fix revert messages", "body": "Won\u2019t fix revert messages", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#won\u2019t-fix-revert-messages", "labels": ["OpenZeppelin"]}, {"title": "[N04] Proposal states overlap during voting expiry", "body": "[N04] Proposal states overlap during voting expiry", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#[n04]-proposal-states-overlap-during-voting-expiry", "labels": ["OpenZeppelin"]}, {"title": "The GovernorAlpha contract implements the state function that outputs the current state of a proposal.", "body": "The GovernorAlpha contract implements the state function that outputs the current state of a proposal.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#the-governoralpha-contract-implements-the-state-function-that-outputs-the-current-state-of-a-proposal.", "labels": ["OpenZeppelin"]}, {"title": "However, there are two states that overlap their conditions during the expiration of the voting period: the Active and the Succeeded states.", "body": "However, there are two states that overlap their conditions during the expiration of the voting period: the Active and the Succeeded states.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#however,-there-are-two-states-that-overlap-their-conditions-during-the-expiration-of-the-voting-period:-the-active-and-the-succeeded-states.", "labels": ["OpenZeppelin"]}, {"title": "Although this does not represent a security issue, because the first conditional to be checked will be the Active state, having two overlapped states may render the code\u2019s readability when transactions are sent during expiry.", "body": "Although this does not represent a security issue, because the first conditional to be checked will be the Active state, having two overlapped states may render the code\u2019s readability when transactions are sent during expiry.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#although-this-does-not-represent-a-security-issue,-because-the-first-conditional-to-be-checked-will-be-the-active-state,-having-two-overlapped-states-may-render-the-code\u2019s-readability-when-transactions-are-sent-during-expiry.", "labels": ["OpenZeppelin"]}, {"title": "Consider restricting the Succeeded state to be active when the block number is strictly greater than the endBlock value.", "body": "Consider restricting the Succeeded state to be active when the block number is strictly greater than the endBlock value.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#consider-restricting-the-succeeded-state-to-be-active-when-the-block-number-is-strictly-greater-than-the-endblock-value.", "labels": ["OpenZeppelin"]}, {"title": "[N05] Revert messages statements are missing", "body": "[N05] Revert messages statements are missing", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#[n05]-revert-messages-statements-are-missing", "labels": ["OpenZeppelin"]}, {"title": "Some require statements are missing their respective revert messages. For example:", "body": "Some require statements are missing their respective revert messages. For example:", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#some-require-statements-are-missing-their-respective-revert-messages.-for-example:", "labels": ["OpenZeppelin"]}, {"title": "line 160 in GovernorAlpha.sol.", "body": "line 160 in GovernorAlpha.sol.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#line-160-in-governoralpha.sol.", "labels": ["OpenZeppelin"]}, {"title": "line 88 in NoteERC20.sol.", "body": "line 88 in NoteERC20.sol.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#line-88-in-noteerc20.sol.", "labels": ["OpenZeppelin"]}, {"title": "line 93 in NoteERC20.sol.", "body": "line 93 in NoteERC20.sol.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#line-93-in-noteerc20.sol.", "labels": ["OpenZeppelin"]}, {"title": "line 99 in NoteERC20.sol.", "body": "line 99 in NoteERC20.sol.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#line-99-in-noteerc20.sol.", "labels": ["OpenZeppelin"]}, {"title": "To improve the code\u2019s readability and to help debugging issues that may arise, consider always including revert messages in all require statements.", "body": "To improve the code\u2019s readability and to help debugging issues that may arise, consider always including revert messages in all require statements.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#to-improve-the-code\u2019s-readability-and-to-help-debugging-issues-that-may-arise,-consider-always-including-revert-messages-in-all-require-statements.", "labels": ["OpenZeppelin"]}, {"title": "Won\u2019t fix, require strings add to deployed code size which increase gas costs for users. Initialize will only be called once so this is a fair trade off.", "body": "Won\u2019t fix, require strings add to deployed code size which increase gas costs for users. Initialize will only be called once so this is a fair trade off.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#won\u2019t-fix,-require-strings-add-to-deployed-code-size-which-increase-gas-costs-for-users.-initialize-will-only-be-called-once-so-this-is-a-fair-trade-off.", "labels": ["OpenZeppelin"]}, {"title": "[N06] Unused import", "body": "[N06] Unused import", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#[n06]-unused-import", "labels": ["OpenZeppelin"]}, {"title": "The GovernorAlpha contract imports Constants.sol, but does not use it. To improve readability and avoid confusion, consider removing unused imports.", "body": "The GovernorAlpha contract imports Constants.sol, but does not use it. To improve readability and avoid confusion, consider removing unused imports.", "html_url": "https://blog.openzeppelin.com/notional-v2-audit-governance-contracts#the-governoralpha-contract-imports-constants.sol,-but-does-not-use-it.-to-improve-readability-and-avoid-confusion,-consider-removing-unused-imports.", "labels": ["OpenZeppelin"]}, {"title": "[N01] Buyback could be rebasing", "body": "[N01] Buyback could be rebasing", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#[n01]-buyback-could-be-rebasing", "labels": ["OpenZeppelin"]}, {"title": "The Buyback contract can receive OUSD tokens whenever the token contract rebases and it disposes of them whenever funds are allocated in the vault and it has at least $1000. Therefore, it\u2019s possible for the contract to hold OUSD tokens during a rebase. Moreover, it does not perform any internal accounting to track its own OUSD balance, which makes it safe for rebasing. To maximize the effectiveness of the Buyback program, consider allowing the contract to opt-in to rebases.", "body": "The Buyback contract can receive OUSD tokens whenever the token contract rebases and it disposes of them whenever funds are allocated in the vault and it has at least $1000. Therefore, it\u2019s possible for the contract to hold OUSD tokens during a rebase. Moreover, it does not perform any internal accounting to track its own OUSD balance, which makes it safe for rebasing. To maximize the effectiveness of the Buyback program, consider allowing the contract to opt-in to rebases.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-buyback-contract-can-receive-ousd-tokens-whenever-the-token-contract-rebases-and-it-disposes-of-them-whenever-funds-are-allocated-in-the-vault-and-it-has-at-least-$1000.-therefore,-it\u2019s-possible-for-the-contract-to-hold-ousd-tokens-during-a-rebase.-moreover,-it-does-not-perform-any-internal-accounting-to-track-its-own-ousd-balance,-which-makes-it-safe-for-rebasing.-to-maximize-the-effectiveness-of-the-buyback-program,-consider-allowing-the-contract-to-opt-in-to-rebases.", "labels": ["OpenZeppelin"]}, {"title": "Update: Acknowledged and retained. The Origin team states:", "body": "Keeping as is to maintain backwards compatibility.  [L17] Not using safeTransfer  The Flipper contract allows users to exchange OUSD 1:1 for any of DAI, USDC, or USDT and vice versa as a low cost way to perform swaps. Although the withdraw functions use safeTransfer, none of the other transfer functions in the Flipper contracts use safeTransfer.  Consider always using safeTransfer as a best practice.  Update: Acknowledged. The Origin team states:  The flipper contract uses hard-coded token addresses, and does not support adding tokens without deploying a new contract. For the swaps, each token has the correct interface for it, with USDT in particular using their own returnless transfers. We do use safeTransfer on methods that can operate on arbitrary tokens. Were going to keep this as is, since the focus on this contract is extremely low gas usage for small swaps.  [L18] Implicit casting  Implicit casting is used to convert the price from int256 to uint256. This could overflow if the price were negative, but the require statements should revert the function in such case, as the result would be outside this range.  Although this cannot result in overflow because of the require statements, consider using SafeCast to safely convert between different integer types as a best practice.  Update: Acknowledged and retained by the Origin team.  [L19] Unnecessary empty constructors defined  The Flipper contract defines empty constructors with no parameters, which is not necessary and only hinders code readability. According to the Solidity docs on constructors: If there is no constructor, the contract will assume the default constructor, which is equivalent to constructor() public {}.  To favor simplicity, consider removing all empty constructors from the codebase.  Update: Fixed in PR#646.  Notes & Additional Information  [N01] Buyback could be rebasing  The Buyback contract can receive OUSD tokens whenever the token contract rebases and it disposes of them whenever funds are allocated in the vault and it has at least $1000. Therefore, its possible for the contract to hold OUSD tokens during a rebase. Moreover, it does not perform any internal accounting to track its own OUSD balance, which makes it safe for rebasing. To maximize the effectiveness of the Buyback program, consider allowing the contract to opt-in to rebases.    Well keep as is. By not being rebasing, this provides extra yield to user of OUSD.  [N02] Misleading comments  Throughout the code, we found several comments either misleading or inconsistent with the function implementation. Some examples are:  The withdrawAll functions of the Flipper contracts claim to be equivalent to pausing the contract, but this is not true as anyone can still subsequently deposit into the contract to enable all functionality.  The deposit, _deposit and withdraw functions of the AaveStategy contract provide a NatSpec comment for the return value, but the function does not return anything.  The changeSupply function of the OUSD contract provides a NatSpec comment for the return value, but the function does not return anything.  The onlyVault modifier mentions a non-existent Savings Manager contract  The transferTokens function on the Buyback contract is missing its @param statements.  The feed function on the OracleRouter contract is missing its @return statement.  Consider either revising or removing misleading comments to more accurately reflect function implementations.  Update: Partially fixed in commit b80180bb5c606ea47266f186d5d232de95f72e48, where the misleading @return NatSpec comments were removed.  [N03] Withdraw funds to recipient  The Buyback contract and Flipper contract each contain mechanisms for the governor to withdraw funds to its own address. However, this mixes roles and requires additional complexity to handle the received tokens. Consider specifying a recipient address, so the governance structure can allocate the funds without having to first take possession of them.  Update: Not fixed. The Origin team state:  We are going to keep these as is. It makes it easier for humans to validate the admin transactions, and its one less place to fat finger a number. It would save on gas, but these admin transfers are very rare. When we do need to make them, our governor timelock can queue and atomically run multiple actions, so its easy enough to withdraw in one action and transfer after, all in the same transaction.  [N04] Unnecessary external calls  In the depositAll function of the ThreePoolStrategy contract, the get_virtual_price function is called against Curves 3Pool contract for each iteration of a for loop.  Consider instead just calling get_virtual_price once before the loop to improve efficiency.  Update: Fixed in PR#639.  [N05] Unnecessary writes to strategies mapping  removeStrategy function removes a strategy from the vault, withdrawing all invested assets and returning them to the vault. It updates the  whether the _addr parameter exists in allStrategies. Then,  if the strategyIndex exists in allStrategies, the function pops the value from the  updates the struct in the strategies mapping for _addr to set isSupported to false, regardless of whether the  Consider moving the strategies mapping update into the conditional block that checks whether the _addr exists in allStrategies to avoid unnecessary writes to storage.  Update: Fixed in PR#705.  [N06] Unconventional storage slots  The Governable contract uses a similar pattern to EIP-1967 to produce pseudo-random storage slot locations. As noted in the EIP, it is conventional to introduce a fixed offset to ensure there is no known hash pre-image. Nevertheless, the current locations are chosen securely and we do not recommend changing storage locations on live contracts, so we are noting this for informational purposes.  Update: Acknowledged. In the words of the Origin team:  We are acknowledging the comment on this, and concur with you that we should continue to use the current values.  [N07] Incorrect function visibility  allocate,  rebase, and  redeem functions are not called internally by the  Update: Fixed in PR#641.  [N08] Lack of explicit visibility in state variables  Throughout the codebase there are state variables and constants that are implicitly using the default visibility. Some examples are:  In the VaultStorage contract: assets, allAssets, strategies, allStrategies, OUSD.  In the ThreePoolStrategy contract: crvGaugeAddress, crvMinterAddress , maxSlippage.  To favor readability, consider explicitly declaring the visibility of all state variables and constants.  Update: Partially fixed in PR#642.  [N09] Unnecessary modifier defined in function  The rebase function from the VaultCore contract uses the whenNotRebasePaused modifier and calls the _rebase internal function, which also uses this modifier.  In the interest of simplicity and avoiding redundant validations, consider removing the modifier from the rebase function.  Update: Fixed in PR#643.  [N10] Using now instead of block.timestamp  The global variable now is used in a few places within the codebase, such as in the Buyback contract and in the VaultAdmin contract. This value could be misinterpreted and has since been deprecated in Solidity v0.7.0.Consider instead using block.timestamp to reflect that the value is a property of the block and to future-proof the codebase for newer versions of Solidity.  Update: Fixed in PR#714.  [N11] Using require to revert  The OracleRouter contract uses a require statement that always fails. To better signal the codes intention, consider using a revert statement instead.  Update: Fixed in PR#644.  [N12] Unused variable  The calculateRedeemOutputs function defines a totalValue variable, but never uses it.  Consider removing unused variables.  Update: Fixed in PR#638.  [N13] Inconsistent coding style  The codebase does not follow a consistent style and it deviates from the recommended Solidity Style Guide. Some examples include:  constants not using UPPER_CASE format  contract should be preceded by 2 blank lines  the order of functions does not always follow the recommended order of: constructor, fallback, external, public, internal, private  Taking into consideration how much value a consistent coding style adds to the projects readability, enforcing a standard coding style with help of linter tools such as Solhint is recommended.  Update: Acknowledged and retained by the Origin team.  [N14] Typographical errors  We have identified the following typographical errors in the codebase:  ICERC20 should be IERC20  approval approval should be approval  liquidiity should be liquidity  ot should be of  jGeneric should be Generic  a should be an  9e38 should be 9e36  Addresss should be Address  form should be from  the the should be to the  optionaly should be optionally  suppported should be supported  _amount should be amount in several comments in the OUSD contract  to should be from  Consider correcting typographical errors in the codebase and using an IDE add-on to identify errors in the future.  Update: Fixed in commit 192e012.  Conclusions  1 critical and 5 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#update:-acknowledged-and-retained.-the-origin-team-states:", "labels": ["OpenZeppelin"]}, {"title": "We\u2019ll keep as is. By not being rebasing, this provides extra yield to user of OUSD.", "body": "We\u2019ll keep as is. By not being rebasing, this provides extra yield to user of OUSD.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#we\u2019ll-keep-as-is.-by-not-being-rebasing,-this-provides-extra-yield-to-user-of-ousd.", "labels": ["OpenZeppelin"]}, {"title": "[N02] Misleading comments", "body": "[N02] Misleading comments", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#[n02]-misleading-comments", "labels": ["OpenZeppelin"]}, {"title": "Throughout the code, we found several comments either misleading or inconsistent with the function implementation. Some examples are:", "body": "Throughout the code, we found several comments either misleading or inconsistent with the function implementation. Some examples are:", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#throughout-the-code,-we-found-several-comments-either-misleading-or-inconsistent-with-the-function-implementation.-some-examples-are:", "labels": ["OpenZeppelin"]}, {"title": "The withdrawAll functions of the Flipper contracts claim to be equivalent to \u201cpausing\u201d the contract, but this is not true as anyone can still subsequently deposit into the contract to enable all functionality.", "body": "The withdrawAll functions of the Flipper contracts claim to be equivalent to \u201cpausing\u201d the contract, but this is not true as anyone can still subsequently deposit into the contract to enable all functionality.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-withdrawall-functions-of-the-flipper-contracts-claim-to-be-equivalent-to-\u201cpausing\u201d-the-contract,-but-this-is-not-true-as-anyone-can-still-subsequently-deposit-into-the-contract-to-enable-all-functionality.", "labels": ["OpenZeppelin"]}, {"title": "The deposit, _deposit and withdraw functions of the AaveStategy contract provide a NatSpec comment for the return value, but the function does not return anything.", "body": "The deposit, _deposit and withdraw functions of the AaveStategy contract provide a NatSpec comment for the return value, but the function does not return anything.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-deposit,-_deposit-and-withdraw-functions-of-the-aavestategy-contract-provide-a-natspec-comment-for-the-return-value,-but-the-function-does-not-return-anything.", "labels": ["OpenZeppelin"]}, {"title": "The changeSupply function of the OUSD contract provides a NatSpec comment for the return value, but the function does not return anything.", "body": "The changeSupply function of the OUSD contract provides a NatSpec comment for the return value, but the function does not return anything.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-changesupply-function-of-the-ousd-contract-provides-a-natspec-comment-for-the-return-value,-but-the-function-does-not-return-anything.", "labels": ["OpenZeppelin"]}, {"title": "The onlyVault modifier mentions a non-existent Savings Manager contract", "body": "The onlyVault modifier mentions a non-existent Savings Manager contract", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-onlyvault-modifier-mentions-a-non-existent-savings-manager-contract", "labels": ["OpenZeppelin"]}, {"title": "The transferTokens function on the Buyback contract is missing its @param statements.", "body": "The transferTokens function on the Buyback contract is missing its @param statements.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-transfertokens-function-on-the-buyback-contract-is-missing-its-@param-statements.", "labels": ["OpenZeppelin"]}, {"title": "The feed function on the OracleRouter contract is missing its @return statement.", "body": "The feed function on the OracleRouter contract is missing its @return statement.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-feed-function-on-the-oraclerouter-contract-is-missing-its-@return-statement.", "labels": ["OpenZeppelin"]}, {"title": "Consider either revising or removing misleading comments to more accurately reflect function implementations.", "body": "Consider either revising or removing misleading comments to more accurately reflect function implementations.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#consider-either-revising-or-removing-misleading-comments-to-more-accurately-reflect-function-implementations.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed in commit b80180bb5c606ea47266f186d5d232de95f72e48, where the misleading @return NatSpec comments were removed.", "body": "Update: Partially fixed in commit b80180bb5c606ea47266f186d5d232de95f72e48, where the misleading @return NatSpec comments were removed.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#update:-partially-fixed-in-commit-b80180bb5c606ea47266f186d5d232de95f72e48,-where-the-misleading-@return-natspec-comments-were-removed.", "labels": ["OpenZeppelin"]}, {"title": "[N03] Withdraw funds to recipient", "body": "[N03] Withdraw funds to recipient", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#[n03]-withdraw-funds-to-recipient", "labels": ["OpenZeppelin"]}, {"title": "The Buyback contract and Flipper contract each contain mechanisms for the governor to withdraw funds to its own address. However, this mixes roles and requires additional complexity to handle the received tokens. Consider specifying a recipient address, so the governance structure can allocate the funds without having to first take possession of them.", "body": "The Buyback contract and Flipper contract each contain mechanisms for the governor to withdraw funds to its own address. However, this mixes roles and requires additional complexity to handle the received tokens. Consider specifying a recipient address, so the governance structure can allocate the funds without having to first take possession of them.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-buyback-contract-and-flipper-contract-each-contain-mechanisms-for-the-governor-to-withdraw-funds-to-its-own-address.-however,-this-mixes-roles-and-requires-additional-complexity-to-handle-the-received-tokens.-consider-specifying-a-recipient-address,-so-the-governance-structure-can-allocate-the-funds-without-having-to-first-take-possession-of-them.", "labels": ["OpenZeppelin"]}, {"title": "Update: Not fixed. The Origin team state:", "body": "Update: Not fixed. The Origin team state:", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#update:-not-fixed.-the-origin-team-state:", "labels": ["OpenZeppelin"]}, {"title": "We are going to keep these as is. It makes it easier for humans to validate the admin transactions, and it\u2019s one less place to fat finger a number. It would save on gas, but these admin transfers are very rare. When we do need to make them, our governor timelock can queue and atomically run multiple actions, so it\u2019s easy enough to withdraw in one action and transfer after, all in the same transaction.", "body": "We are going to keep these as is. It makes it easier for humans to validate the admin transactions, and it\u2019s one less place to fat finger a number. It would save on gas, but these admin transfers are very rare. When we do need to make them, our governor timelock can queue and atomically run multiple actions, so it\u2019s easy enough to withdraw in one action and transfer after, all in the same transaction.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#we-are-going-to-keep-these-as-is.-it-makes-it-easier-for-humans-to-validate-the-admin-transactions,-and-it\u2019s-one-less-place-to-fat-finger-a-number.-it-would-save-on-gas,-but-these-admin-transfers-are-very-rare.-when-we-do-need-to-make-them,-our-governor-timelock-can-queue-and-atomically-run-multiple-actions,-so-it\u2019s-easy-enough-to-withdraw-in-one-action-and-transfer-after,-all-in-the-same-transaction.", "labels": ["OpenZeppelin"]}, {"title": "[N04] Unnecessary external calls", "body": "[N04] Unnecessary external calls", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#[n04]-unnecessary-external-calls", "labels": ["OpenZeppelin"]}, {"title": "In the depositAll function of the ThreePoolStrategy contract, the get_virtual_price function is called against Curve\u2019s 3Pool contract for each iteration of a for loop.", "body": "In the depositAll function of the ThreePoolStrategy contract, the get_virtual_price function is called against Curve\u2019s 3Pool contract for each iteration of a for loop.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#in-the-depositall-function-of-the-threepoolstrategy-contract,-the-get_virtual_price-function-is-called-against-curve\u2019s-3pool-contract-for-each-iteration-of-a-for-loop.", "labels": ["OpenZeppelin"]}, {"title": "Consider instead just calling get_virtual_price once before the loop to improve efficiency.", "body": "Consider instead just calling get_virtual_price once before the loop to improve efficiency.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#consider-instead-just-calling-get_virtual_price-once-before-the-loop-to-improve-efficiency.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#639.", "body": "Update: Fixed in PR#639.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#update:-fixed-in-pr#639.", "labels": ["OpenZeppelin"]}, {"title": "[N05] Unnecessary writes to strategies mapping", "body": "[N05] Unnecessary writes to strategies mapping", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#[n05]-unnecessary-writes-to-strategies-mapping", "labels": ["OpenZeppelin"]}, {"title": "removeStrategy function removes a strategy from the vault, withdrawing all invested assets and returning them to the vault. It updates the", "body": "removeStrategy function removes a strategy from the vault, withdrawing all invested assets and returning them to the vault. It updates the", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#removestrategy-function-removes-a-strategy-from-the-vault,-withdrawing-all-invested-assets-and-returning-them-to-the-vault.-it-updates-the", "labels": ["OpenZeppelin"]}, {"title": "whether the _addr parameter exists in allStrategies. Then,", "body": "whether the _addr parameter exists in allStrategies. Then,", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#whether-the-_addr-parameter-exists-in-allstrategies.-then,", "labels": ["OpenZeppelin"]}, {"title": "if the strategyIndex exists in allStrategies, the function pops the value from the", "body": "if the strategyIndex exists in allStrategies, the function pops the value from the", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#if-the-strategyindex-exists-in-allstrategies,-the-function-pops-the-value-from-the", "labels": ["OpenZeppelin"]}, {"title": "updates the struct in the strategies mapping for _addr to set isSupported to false, regardless of whether the", "body": "updates the struct in the strategies mapping for _addr to set isSupported to false, regardless of whether the", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#updates-the-struct-in-the-strategies-mapping-for-_addr-to-set-issupported-to-false,-regardless-of-whether-the", "labels": ["OpenZeppelin"]}, {"title": "Consider moving the strategies mapping update into the conditional block that checks whether the _addr exists in allStrategies to avoid unnecessary writes to storage.", "body": "Consider moving the strategies mapping update into the conditional block that checks whether the _addr exists in allStrategies to avoid unnecessary writes to storage.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#consider-moving-the-strategies-mapping-update-into-the-conditional-block-that-checks-whether-the-_addr-exists-in-allstrategies-to-avoid-unnecessary-writes-to-storage.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#705.", "body": "Update: Fixed in PR#705.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#update:-fixed-in-pr#705.", "labels": ["OpenZeppelin"]}, {"title": "[N06] Unconventional storage slots", "body": "[N06] Unconventional storage slots", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#[n06]-unconventional-storage-slots", "labels": ["OpenZeppelin"]}, {"title": "The Governable contract uses a similar pattern to EIP-1967 to produce pseudo-random storage slot locations. As noted in the EIP, it is conventional to introduce a fixed offset to ensure there is no known hash pre-image. Nevertheless, the current locations are chosen securely and we do not recommend changing storage locations on live contracts, so we are noting this for informational purposes.", "body": "The Governable contract uses a similar pattern to EIP-1967 to produce pseudo-random storage slot locations. As noted in the EIP, it is conventional to introduce a fixed offset to ensure there is no known hash pre-image. Nevertheless, the current locations are chosen securely and we do not recommend changing storage locations on live contracts, so we are noting this for informational purposes.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-governable-contract-uses-a-similar-pattern-to-eip-1967-to-produce-pseudo-random-storage-slot-locations.-as-noted-in-the-eip,-it-is-conventional-to-introduce-a-fixed-offset-to-ensure-there-is-no-known-hash-pre-image.-nevertheless,-the-current-locations-are-chosen-securely-and-we-do-not-recommend-changing-storage-locations-on-live-contracts,-so-we-are-noting-this-for-informational-purposes.", "labels": ["OpenZeppelin"]}, {"title": "Update: Acknowledged. In the words of the Origin team:", "body": "Update: Acknowledged. In the words of the Origin team:", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#update:-acknowledged.-in-the-words-of-the-origin-team:", "labels": ["OpenZeppelin"]}, {"title": "We are acknowledging the comment on this, and concur with you that we should continue to use the current values.", "body": "We are acknowledging the comment on this, and concur with you that we should continue to use the current values.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#we-are-acknowledging-the-comment-on-this,-and-concur-with-you-that-we-should-continue-to-use-the-current-values.", "labels": ["OpenZeppelin"]}, {"title": "[N07] Incorrect function visibility", "body": "[N07] Incorrect function visibility", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#[n07]-incorrect-function-visibility", "labels": ["OpenZeppelin"]}, {"title": "allocate,", "body": "allocate,", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#allocate,", "labels": ["OpenZeppelin"]}, {"title": "rebase, and", "body": "rebase, and", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#rebase,-and", "labels": ["OpenZeppelin"]}, {"title": "redeem functions are not called internally by the", "body": "redeem functions are not called internally by the", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#redeem-functions-are-not-called-internally-by-the", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#641.", "body": "Update: Fixed in PR#641.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#update:-fixed-in-pr#641.", "labels": ["OpenZeppelin"]}, {"title": "[N08] Lack of explicit visibility in state variables", "body": "[N08] Lack of explicit visibility in state variables", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#[n08]-lack-of-explicit-visibility-in-state-variables", "labels": ["OpenZeppelin"]}, {"title": "Throughout the codebase there are state variables and constants that are implicitly using the default visibility. Some examples are:", "body": "Throughout the codebase there are state variables and constants that are implicitly using the default visibility. Some examples are:", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#throughout-the-codebase-there-are-state-variables-and-constants-that-are-implicitly-using-the-default-visibility.-some-examples-are:", "labels": ["OpenZeppelin"]}, {"title": "In the VaultStorage contract: assets, allAssets, strategies, allStrategies, OUSD.", "body": "In the VaultStorage contract: assets, allAssets, strategies, allStrategies, OUSD.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#in-the-vaultstorage-contract:-assets,-allassets,-strategies,-allstrategies,-ousd.", "labels": ["OpenZeppelin"]}, {"title": "In the ThreePoolStrategy contract: crvGaugeAddress, crvMinterAddress , maxSlippage.", "body": "In the ThreePoolStrategy contract: crvGaugeAddress, crvMinterAddress , maxSlippage.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#in-the-threepoolstrategy-contract:-crvgaugeaddress,-crvminteraddress-,-maxslippage.", "labels": ["OpenZeppelin"]}, {"title": "To favor readability, consider explicitly declaring the visibility of all state variables and constants.", "body": "To favor readability, consider explicitly declaring the visibility of all state variables and constants.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#to-favor-readability,-consider-explicitly-declaring-the-visibility-of-all-state-variables-and-constants.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed in PR#642.", "body": "Update: Partially fixed in PR#642.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#update:-partially-fixed-in-pr#642.", "labels": ["OpenZeppelin"]}, {"title": "[N09] Unnecessary modifier defined in function", "body": "[N09] Unnecessary modifier defined in function", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#[n09]-unnecessary-modifier-defined-in-function", "labels": ["OpenZeppelin"]}, {"title": "The rebase function from the VaultCore contract uses the whenNotRebasePaused modifier and calls the _rebase internal function, which also uses this modifier.", "body": "The rebase function from the VaultCore contract uses the whenNotRebasePaused modifier and calls the _rebase internal function, which also uses this modifier.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-rebase-function-from-the-vaultcore-contract-uses-the-whennotrebasepaused-modifier-and-calls-the-_rebase-internal-function,-which-also-uses-this-modifier.", "labels": ["OpenZeppelin"]}, {"title": "In the interest of simplicity and avoiding redundant validations, consider removing the modifier from the rebase function.", "body": "In the interest of simplicity and avoiding redundant validations, consider removing the modifier from the rebase function.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#in-the-interest-of-simplicity-and-avoiding-redundant-validations,-consider-removing-the-modifier-from-the-rebase-function.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#643.", "body": "Update: Fixed in PR#643.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#update:-fixed-in-pr#643.", "labels": ["OpenZeppelin"]}, {"title": "[N10] Using now instead of block.timestamp", "body": "[N10] Using now instead of block.timestamp", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#[n10]-using-now-instead-of-block.timestamp", "labels": ["OpenZeppelin"]}, {"title": "The global variable now is used in a few places within the codebase, such as in the Buyback contract and in the VaultAdmin contract. This value could be misinterpreted and has since been deprecated in Solidity v0.7.0.Consider instead using block.timestamp to reflect that the value is a property of the block and to future-proof the codebase for newer versions of Solidity.", "body": "The global variable now is used in a few places within the codebase, such as in the Buyback contract and in the VaultAdmin contract. This value could be misinterpreted and has since been deprecated in Solidity v0.7.0.Consider instead using block.timestamp to reflect that the value is a property of the block and to future-proof the codebase for newer versions of Solidity.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-global-variable-now-is-used-in-a-few-places-within-the-codebase,-such-as-in-the-buyback-contract-and-in-the-vaultadmin-contract.-this-value-could-be-misinterpreted-and-has-since-been-deprecated-in-solidity-v0.7.0.consider-instead-using-block.timestamp-to-reflect-that-the-value-is-a-property-of-the-block-and-to-future-proof-the-codebase-for-newer-versions-of-solidity.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#714.", "body": "Update: Fixed in PR#714.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#update:-fixed-in-pr#714.", "labels": ["OpenZeppelin"]}, {"title": "[N11] Using require to revert", "body": "[N11] Using require to revert", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#[n11]-using-require-to-revert", "labels": ["OpenZeppelin"]}, {"title": "The OracleRouter contract uses a require statement that always fails. To better signal the code\u2019s intention, consider using a revert statement instead.", "body": "The OracleRouter contract uses a require statement that always fails. To better signal the code\u2019s intention, consider using a revert statement instead.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-oraclerouter-contract-uses-a-require-statement-that-always-fails.-to-better-signal-the-code\u2019s-intention,-consider-using-a-revert-statement-instead.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#644.", "body": "Update: Fixed in PR#644.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#update:-fixed-in-pr#644.", "labels": ["OpenZeppelin"]}, {"title": "[N12] Unused variable", "body": "[N12] Unused variable", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#[n12]-unused-variable", "labels": ["OpenZeppelin"]}, {"title": "The calculateRedeemOutputs function defines a totalValue variable, but never uses it.", "body": "The calculateRedeemOutputs function defines a totalValue variable, but never uses it.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-calculateredeemoutputs-function-defines-a-totalvalue-variable,-but-never-uses-it.", "labels": ["OpenZeppelin"]}, {"title": "Consider removing unused variables.", "body": "Consider removing unused variables.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#consider-removing-unused-variables.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR#638.", "body": "Update: Fixed in PR#638.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#update:-fixed-in-pr#638.", "labels": ["OpenZeppelin"]}, {"title": "[N13] Inconsistent coding style", "body": "[N13] Inconsistent coding style", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#[n13]-inconsistent-coding-style", "labels": ["OpenZeppelin"]}, {"title": "The codebase does not follow a consistent style and it deviates from the recommended Solidity Style Guide. Some examples include:", "body": "The codebase does not follow a consistent style and it deviates from the recommended Solidity Style Guide. Some examples include:", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-codebase-does-not-follow-a-consistent-style-and-it-deviates-from-the-recommended-solidity-style-guide.-some-examples-include:", "labels": ["OpenZeppelin"]}, {"title": "constants not using UPPER_CASE format", "body": "constants not using UPPER_CASE format", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#constants-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "contract should be preceded by 2 blank lines", "body": "contract should be preceded by 2 blank lines", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#contract-should-be-preceded-by-2-blank-lines", "labels": ["OpenZeppelin"]}, {"title": "the order of functions does not always follow the recommended order of: constructor, fallback, external, public, internal, private", "body": "the order of functions does not always follow the recommended order of: constructor, fallback, external, public, internal, private", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#the-order-of-functions-does-not-always-follow-the-recommended-order-of:-constructor,-fallback,-external,-public,-internal,-private", "labels": ["OpenZeppelin"]}, {"title": "Taking into consideration how much value a consistent coding style adds to the project\u2019s readability, enforcing a standard coding style with help of linter tools such as Solhint is recommended.", "body": "Taking into consideration how much value a consistent coding style adds to the project\u2019s readability, enforcing a standard coding style with help of linter tools such as Solhint is recommended.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#taking-into-consideration-how-much-value-a-consistent-coding-style-adds-to-the-project\u2019s-readability,-enforcing-a-standard-coding-style-with-help-of-linter-tools-such-as-solhint-is-recommended.", "labels": ["OpenZeppelin"]}, {"title": "Update: Acknowledged and retained by the Origin team.", "body": "[N14] Typographical errors  We have identified the following typographical errors in the codebase:  ICERC20 should be IERC20  approval approval should be approval  liquidiity should be liquidity  ot should be of  jGeneric should be Generic  a should be an  9e38 should be 9e36  Addresss should be Address  form should be from  the the should be to the  optionaly should be optionally  suppported should be supported  _amount should be amount in several comments in the OUSD contract  to should be from  Consider correcting typographical errors in the codebase and using an IDE add-on to identify errors in the future.  Update: Fixed in commit 192e012.  Conclusions  1 critical and 5 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#update:-acknowledged-and-retained-by-the-origin-team.", "labels": ["OpenZeppelin"]}, {"title": "[N14] Typographical errors", "body": "[N14] Typographical errors", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#[n14]-typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "We have identified the following typographical errors in the codebase:", "body": "We have identified the following typographical errors in the codebase:", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#we-have-identified-the-following-typographical-errors-in-the-codebase:", "labels": ["OpenZeppelin"]}, {"title": "\u201cICERC20\u201d should be \u201cIERC20\u201d", "body": "\u201cICERC20\u201d should be \u201cIERC20\u201d", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#\u201cicerc20\u201d-should-be-\u201cierc20\u201d", "labels": ["OpenZeppelin"]}, {"title": "\u201capproval approval\u201d should be \u201capproval\u201d", "body": "\u201capproval approval\u201d should be \u201capproval\u201d", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#\u201capproval-approval\u201d-should-be-\u201capproval\u201d", "labels": ["OpenZeppelin"]}, {"title": "\u201cliquidiity\u201d should be \u201cliquidity\u201d", "body": "\u201cliquidiity\u201d should be \u201cliquidity\u201d", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#\u201cliquidiity\u201d-should-be-\u201cliquidity\u201d", "labels": ["OpenZeppelin"]}, {"title": "\u201cot\u201d should be \u201cof\u201d", "body": "\u201cot\u201d should be \u201cof\u201d", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#\u201cot\u201d-should-be-\u201cof\u201d", "labels": ["OpenZeppelin"]}, {"title": "\u201cjGeneric\u201d should be \u201cGeneric\u201d", "body": "\u201cjGeneric\u201d should be \u201cGeneric\u201d", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#\u201cjgeneric\u201d-should-be-\u201cgeneric\u201d", "labels": ["OpenZeppelin"]}, {"title": "\u201ca\u201d should be \u201can\u201d", "body": "\u201ca\u201d should be \u201can\u201d", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#\u201ca\u201d-should-be-\u201can\u201d", "labels": ["OpenZeppelin"]}, {"title": "\u201c9e38\u201d should be \u201c9e36\u201d", "body": "\u201c9e38\u201d should be \u201c9e36\u201d", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#\u201c9e38\u201d-should-be-\u201c9e36\u201d", "labels": ["OpenZeppelin"]}, {"title": "\u201cAddresss\u201d should be \u201cAddress\u201d", "body": "\u201cAddresss\u201d should be \u201cAddress\u201d", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#\u201caddresss\u201d-should-be-\u201caddress\u201d", "labels": ["OpenZeppelin"]}, {"title": "\u201cform\u201d should be \u201cfrom\u201d", "body": "\u201cform\u201d should be \u201cfrom\u201d", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#\u201cform\u201d-should-be-\u201cfrom\u201d", "labels": ["OpenZeppelin"]}, {"title": "\u201cthe the\u201d should be \u201cto the\u201d", "body": "\u201cthe the\u201d should be \u201cto the\u201d", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#\u201cthe-the\u201d-should-be-\u201cto-the\u201d", "labels": ["OpenZeppelin"]}, {"title": "\u201coptionaly\u201d should be \u201coptionally\u201d", "body": "\u201coptionaly\u201d should be \u201coptionally\u201d", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#\u201coptionaly\u201d-should-be-\u201coptionally\u201d", "labels": ["OpenZeppelin"]}, {"title": "\u201csuppported\u201d should be \u201csupported\u201d", "body": "\u201csuppported\u201d should be \u201csupported\u201d", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#\u201csuppported\u201d-should-be-\u201csupported\u201d", "labels": ["OpenZeppelin"]}, {"title": "\u201c_amount\u201d should be \u201camount\u201d in several comments in the OUSD contract", "body": "\u201c_amount\u201d should be \u201camount\u201d in several comments in the OUSD contract", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#\u201c_amount\u201d-should-be-\u201camount\u201d-in-several-comments-in-the-ousd-contract", "labels": ["OpenZeppelin"]}, {"title": "\u201cto\u201d should be \u201cfrom\u201d", "body": "\u201cto\u201d should be \u201cfrom\u201d", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#\u201cto\u201d-should-be-\u201cfrom\u201d", "labels": ["OpenZeppelin"]}, {"title": "Consider correcting typographical errors in the codebase and using an IDE add-on to identify errors in the future.", "body": "Consider correcting typographical errors in the codebase and using an IDE add-on to identify errors in the future.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#consider-correcting-typographical-errors-in-the-codebase-and-using-an-ide-add-on-to-identify-errors-in-the-future.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 192e012.", "body": "Update: Fixed in commit 192e012.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit#update:-fixed-in-commit-192e012.", "labels": ["OpenZeppelin"]}, {"title": "[N01] Broken links in inline documentation", "body": "[N01] Broken links in inline documentation", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#[n01]-broken-links-in-inline-documentation", "labels": ["OpenZeppelin"]}, {"title": "Throughout the codebase, various links present in the inline documentation are broken. For example:", "body": "Throughout the codebase, various links present in the inline documentation are broken. For example:", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#throughout-the-codebase,-various-links-present-in-the-inline-documentation-are-broken.-for-example:", "labels": ["OpenZeppelin"]}, {"title": "These links in RibbonVault", "body": "These links in RibbonVault", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#these-links-in-ribbonvault", "labels": ["OpenZeppelin"]}, {"title": "This link in VaultLifecycle", "body": "This link in VaultLifecycle", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#this-link-in-vaultlifecycle", "labels": ["OpenZeppelin"]}, {"title": "To make the codebase easier to understand and maintain, consider reviewing the links in the codebase and fixing any which are broken.", "body": "To make the codebase easier to understand and maintain, consider reviewing the links in the codebase and fixing any which are broken.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#to-make-the-codebase-easier-to-understand-and-maintain,-consider-reviewing-the-links-in-the-codebase-and-fixing-any-which-are-broken.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 6edda917d1e019ba86a4fd5854ba96abaa1aab42 of PR#99.", "body": "Update: Fixed in commit 6edda917d1e019ba86a4fd5854ba96abaa1aab42 of PR#99.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#update:-fixed-in-commit-6edda917d1e019ba86a4fd5854ba96abaa1aab42-of-pr#99.", "labels": ["OpenZeppelin"]}, {"title": "[N02] Implicit access control has drawbacks", "body": "[N02] Implicit access control has drawbacks", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#[n02]-implicit-access-control-has-drawbacks", "labels": ["OpenZeppelin"]}, {"title": "rollToNextOption function of", "body": "rollToNextOption function of", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#rolltonextoption-function-of", "labels": ["OpenZeppelin"]}, {"title": "RibbonThetaVault does not use this modifier, but instead implicitly relies on the nested call to", "body": "RibbonThetaVault does not use this modifier, but instead implicitly relies on the nested call to", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#ribbonthetavault-does-not-use-this-modifier,-but-instead-implicitly-relies-on-the-nested-call-to", "labels": ["OpenZeppelin"]}, {"title": "startAuction for access control. While this effectively prevents accounts other than the", "body": "startAuction for access control. While this effectively prevents accounts other than the", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#startauction-for-access-control.-while-this-effectively-prevents-accounts-other-than-the", "labels": ["OpenZeppelin"]}, {"title": "In order to avoid unnecessary gas consumption in some cases and to increase the legibility of the codebase, consider having all functions explicitly define their access control mechanisms.", "body": "In order to avoid unnecessary gas consumption in some cases and to increase the legibility of the codebase, consider having all functions explicitly define their access control mechanisms.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#in-order-to-avoid-unnecessary-gas-consumption-in-some-cases-and-to-increase-the-legibility-of-the-codebase,-consider-having-all-functions-explicitly-define-their-access-control-mechanisms.", "labels": ["OpenZeppelin"]}, {"title": "Update: Acknowledged. The Ribbon Finance team has said that this is addressed with their new keeper role and onlyKeeper modifiers, though those additions and modifications have not been audited by OpenZeppelin at this time.", "body": "Update: Acknowledged. The Ribbon Finance team has said that this is addressed with their new keeper role and onlyKeeper modifiers, though those additions and modifications have not been audited by OpenZeppelin at this time.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#update:-acknowledged.-the-ribbon-finance-team-has-said-that-this-is-addressed-with-their-new-keeper-role-and-onlykeeper-modifiers,-though-those-additions-and-modifications-have-not-been-audited-by-openzeppelin-at-this-time.", "labels": ["OpenZeppelin"]}, {"title": "[N03] Incomplete enum definition", "body": "[N03] Incomplete enum definition", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#[n03]-incomplete-enum-definition", "labels": ["OpenZeppelin"]}, {"title": "The ActionType enum is missing Liquidate, which is present in Gamma Protocol\u2019s Actions library.", "body": "The ActionType enum is missing Liquidate, which is present in Gamma Protocol\u2019s Actions library.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#the-actiontype-enum-is-missing-liquidate,-which-is-present-in-gamma-protocol\u2019s-actions-library.", "labels": ["OpenZeppelin"]}, {"title": "To facilitate future iterations and minimize potential confusion, consider using the complete enum definition from Opyn\u2019s Gamma Protocol.", "body": "To facilitate future iterations and minimize potential confusion, consider using the complete enum definition from Opyn\u2019s Gamma Protocol.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#to-facilitate-future-iterations-and-minimize-potential-confusion,-consider-using-the-complete-enum-definition-from-opyn\u2019s-gamma-protocol.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 9f1d067fa726adf8fe4c4bc61589429acd7794d0 of PR#100.", "body": "Update: Fixed in commit 9f1d067fa726adf8fe4c4bc61589429acd7794d0 of PR#100.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#update:-fixed-in-commit-9f1d067fa726adf8fe4c4bc61589429acd7794d0-of-pr#100.", "labels": ["OpenZeppelin"]}, {"title": "[N04] Inconsistent use of safe math libraries", "body": "[N04] Inconsistent use of safe math libraries", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#[n04]-inconsistent-use-of-safe-math-libraries", "labels": ["OpenZeppelin"]}, {"title": "The codebase uses two separate math libraries, namely, DSMath and SafeMath, to perform common math operations in a safe manner. The former library, despite being partially duplicated throughout the codebase, is used relatively sparsely.", "body": "The codebase uses two separate math libraries, namely, DSMath and SafeMath, to perform common math operations in a safe manner. The former library, despite being partially duplicated throughout the codebase, is used relatively sparsely.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#the-codebase-uses-two-separate-math-libraries,-namely,-dsmath-and-safemath,-to-perform-common-math-operations-in-a-safe-manner.-the-former-library,-despite-being-partially-duplicated-throughout-the-codebase,-is-used-relatively-sparsely.", "labels": ["OpenZeppelin"]}, {"title": "StrikeSelection contract,", "body": "StrikeSelection contract,", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#strikeselection-contract,", "labels": ["OpenZeppelin"]}, {"title": "sub method is used. In the same contract, the", "body": "sub method is used. In the same contract, the", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#sub-method-is-used.-in-the-same-contract,-the", "labels": ["OpenZeppelin"]}, {"title": "for uint256 values. Then", "body": "for uint256 values. Then", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#for-uint256-values.-then", "labels": ["OpenZeppelin"]}, {"title": "https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol) inherits from", "body": "https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/RibbonVault.sol) inherits from", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/base/ribbonvault.sol)-inherits-from", "labels": ["OpenZeppelin"]}, {"title": "min method is used. Since", "body": "min method is used. Since", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#min-method-is-used.-since", "labels": ["OpenZeppelin"]}, {"title": "OpenZeppelin contracts are being imported as a dependency already, the", "body": "OpenZeppelin contracts are being imported as a dependency already, the", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#openzeppelin-contracts-are-being-imported-as-a-dependency-already,-the", "labels": ["OpenZeppelin"]}, {"title": "OpenZeppelin Math library could be used to provide this", "body": "OpenZeppelin Math library could be used to provide this", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#openzeppelin-math-library-could-be-used-to-provide-this", "labels": ["OpenZeppelin"]}, {"title": "To simplify the codebase, reduce bytecode size, and increase readability, consider using a single vendor for safe math functionalities and inheriting desired functionality from a single library where possible.", "body": "To simplify the codebase, reduce bytecode size, and increase readability, consider using a single vendor for safe math functionalities and inheriting desired functionality from a single library where possible.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#to-simplify-the-codebase,-reduce-bytecode-size,-and-increase-readability,-consider-using-a-single-vendor-for-safe-math-functionalities-and-inheriting-desired-functionality-from-a-single-library-where-possible.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 810de79b6ea2f81e5c0d146d219fa51284e49c2a of PR#102.", "body": "Update: Fixed in commit 810de79b6ea2f81e5c0d146d219fa51284e49c2a of PR#102.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#update:-fixed-in-commit-810de79b6ea2f81e5c0d146d219fa51284e49c2a-of-pr#102.", "labels": ["OpenZeppelin"]}, {"title": "[N05] Inconsistent coding style", "body": "[N05] Inconsistent coding style", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#[n05]-inconsistent-coding-style", "labels": ["OpenZeppelin"]}, {"title": "An inconsistent coding style can be found throughout the codebase. Some examples include:", "body": "An inconsistent coding style can be found throughout the codebase. Some examples include:", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#an-inconsistent-coding-style-can-be-found-throughout-the-codebase.-some-examples-include:", "labels": ["OpenZeppelin"]}, {"title": "Constants not using UPPER_CASE format", "body": "Constants not using UPPER_CASE format", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#constants-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent prefixes used for parameter naming within functions", "body": "Inconsistent prefixes used for parameter naming within functions", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#inconsistent-prefixes-used-for-parameter-naming-within-functions", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent use of the Pct suffix to denote that a variable represents a percentage. This is inconsistent with other variables that represent percentages but do not use said suffix.", "body": "Inconsistent use of the Pct suffix to denote that a variable represents a percentage. This is inconsistent with other variables that represent percentages but do not use said suffix.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#inconsistent-use-of-the-pct-suffix-to-denote-that-a-variable-represents-a-percentage.-this-is-inconsistent-with-other-variables-that-represent-percentages-but-do-not-use-said-suffix.", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent grouping of immutable variables. Some contracts group all immutable variables together while others do not.", "body": "Inconsistent grouping of immutable variables. Some contracts group all immutable variables together while others do not.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#inconsistent-grouping-of-immutable-variables.-some-contracts-group-all-immutable-variables-together-while-others-do-not.", "labels": ["OpenZeppelin"]}, {"title": "The project includes commands to run a linter, but when running them they report several linting issues.", "body": "The project includes commands to run a linter, but when running them they report several linting issues.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#the-project-includes-commands-to-run-a-linter,-but-when-running-them-they-report-several-linting-issues.", "labels": ["OpenZeppelin"]}, {"title": "To improve the overall consistency and readability of the codebase, consider adhering to a more consistent coding style by following a specific style guide and by fixing issues reported by the linter.", "body": "To improve the overall consistency and readability of the codebase, consider adhering to a more consistent coding style by following a specific style guide and by fixing issues reported by the linter.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#to-improve-the-overall-consistency-and-readability-of-the-codebase,-consider-adhering-to-a-more-consistent-coding-style-by-following-a-specific-style-guide-and-by-fixing-issues-reported-by-the-linter.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed in commit b869e49b2daf2c860db10efb5fb33967ac42bf89 of PR#104.", "body": "Update: Partially fixed in commit b869e49b2daf2c860db10efb5fb33967ac42bf89 of PR#104.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#update:-partially-fixed-in-commit-b869e49b2daf2c860db10efb5fb33967ac42bf89-of-pr#104.", "labels": ["OpenZeppelin"]}, {"title": "[N06] Inconsistent use of named return variables", "body": "[N06] Inconsistent use of named return variables", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#[n06]-inconsistent-use-of-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "There is an inconsistent use of named return variables across the codebase.", "body": "There is an inconsistent use of named return variables across the codebase.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#there-is-an-inconsistent-use-of-named-return-variables-across-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "For instance, in the VaultLifecycle library alone, some functions return named variables, some return explicit values, and others declare a named return variable but override it with an explicit return statement.", "body": "For instance, in the VaultLifecycle library alone, some functions return named variables, some return explicit values, and others declare a named return variable but override it with an explicit return statement.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#for-instance,-in-the-vaultlifecycle-library-alone,-some-functions-return-named-variables,-some-return-explicit-values,-and-others-declare-a-named-return-variable-but-override-it-with-an-explicit-return-statement.", "labels": ["OpenZeppelin"]}, {"title": "Similar inconsistencies can be found throughout the contracts, interfaces, and libraries that comprise the project.", "body": "Similar inconsistencies can be found throughout the contracts, interfaces, and libraries that comprise the project.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#similar-inconsistencies-can-be-found-throughout-the-contracts,-interfaces,-and-libraries-that-comprise-the-project.", "labels": ["OpenZeppelin"]}, {"title": "Consider adopting a consistent approach to return values by removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This would improve both the explicitness and readability of the code, and it may also help reduce regressions during future code refactors.", "body": "Consider adopting a consistent approach to return values by removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This would improve both the explicitness and readability of the code, and it may also help reduce regressions during future code refactors.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#consider-adopting-a-consistent-approach-to-return-values-by-removing-all-named-return-variables,-explicitly-declaring-them-as-local-variables,-and-adding-the-necessary-return-statements-where-appropriate.-this-would-improve-both-the-explicitness-and-readability-of-the-code,-and-it-may-also-help-reduce-regressions-during-future-code-refactors.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed in commit 7eefb3e45d2c54411e00614f6230d38ff0f99c13 of PR#107. The new style, though consistently adopted, removes named returns from functions with a single return value, but uses both named returns and explicit returns with functions that return more than a single value. This can be an error prone style. The compiler will not flag functions that do not explicitly return values when named returns are used.", "body": "Update: Partially fixed in commit 7eefb3e45d2c54411e00614f6230d38ff0f99c13 of PR#107. The new style, though consistently adopted, removes named returns from functions with a single return value, but uses both named returns and explicit returns with functions that return more than a single value. This can be an error prone style. The compiler will not flag functions that do not explicitly return values when named returns are used.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#update:-partially-fixed-in-commit-7eefb3e45d2c54411e00614f6230d38ff0f99c13-of-pr#107.-the-new-style,-though-consistently-adopted,-removes-named-returns-from-functions-with-a-single-return-value,-but-uses-both-named-returns-and-explicit-returns-with-functions-that-return-more-than-a-single-value.-this-can-be-an-error-prone-style.-the-compiler-will-not-flag-functions-that-do-not-explicitly-return-values-when-named-returns-are-used.", "labels": ["OpenZeppelin"]}, {"title": "[N07] Lack of explicit visibility in constants", "body": "[N07] Lack of explicit visibility in constants", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#[n07]-lack-of-explicit-visibility-in-constants", "labels": ["OpenZeppelin"]}, {"title": "Throughout the codebase there are constants that are implicitly using the default visibility. For example:", "body": "Throughout the codebase there are constants that are implicitly using the default visibility. For example:", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#throughout-the-codebase-there-are-constants-that-are-implicitly-using-the-default-visibility.-for-example:", "labels": ["OpenZeppelin"]}, {"title": "The USDT constant in SupportsNonCompliantERC20", "body": "The USDT constant in SupportsNonCompliantERC20", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#the-usdt-constant-in-supportsnoncomplianterc20", "labels": ["OpenZeppelin"]}, {"title": "The DSWAD constant in GnosisAuction", "body": "The DSWAD constant in GnosisAuction", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#the-dswad-constant-in-gnosisauction", "labels": ["OpenZeppelin"]}, {"title": "The DSWAD constant in VaultLifecycle", "body": "The DSWAD constant in VaultLifecycle", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#the-dswad-constant-in-vaultlifecycle", "labels": ["OpenZeppelin"]}, {"title": "To clarify intent and favor readability, consider explicitly declaring the visibility of all constants and state variables.", "body": "To clarify intent and favor readability, consider explicitly declaring the visibility of all constants and state variables.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#to-clarify-intent-and-favor-readability,-consider-explicitly-declaring-the-visibility-of-all-constants-and-state-variables.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 36b9f33db90a3eb357eace7c4fd69cad6c2980b6 of PR#108.", "body": "Update: Fixed in commit 36b9f33db90a3eb357eace7c4fd69cad6c2980b6 of PR#108.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#update:-fixed-in-commit-36b9f33db90a3eb357eace7c4fd69cad6c2980b6-of-pr#108.", "labels": ["OpenZeppelin"]}, {"title": "[N08] Unnecessary complexity for managementFee calculation", "body": "[N08] Unnecessary complexity for managementFee calculation", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#[n08]-unnecessary-complexity-for-managementfee-calculation", "labels": ["OpenZeppelin"]}, {"title": "RibbonVault, both during initialization and in the", "body": "RibbonVault, both during initialization and in the", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#ribbonvault,-both-during-initialization-and-in-the", "labels": ["OpenZeppelin"]}, {"title": "setManagementFee function, the input parameter corresponds to the", "body": "setManagementFee function, the input parameter corresponds to the", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#setmanagementfee-function,-the-input-parameter-corresponds-to-the", "labels": ["OpenZeppelin"]}, {"title": "In both cases, the input parameter must be immediately divided by the WEEKS_PER_YEAR constant. Because the number of weeks per year differs between leap years and non-leap years, this division can introduce some imprecision. Additionally, having the relevant setter and getter functions dealing in different terms can be confusing.", "body": "In both cases, the input parameter must be immediately divided by the WEEKS_PER_YEAR constant. Because the number of weeks per year differs between leap years and non-leap years, this division can introduce some imprecision. Additionally, having the relevant setter and getter functions dealing in different terms can be confusing.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#in-both-cases,-the-input-parameter-must-be-immediately-divided-by-the-weeks_per_year-constant.-because-the-number-of-weeks-per-year-differs-between-leap-years-and-non-leap-years,-this-division-can-introduce-some-imprecision.-additionally,-having-the-relevant-setter-and-getter-functions-dealing-in-different-terms-can-be-confusing.", "labels": ["OpenZeppelin"]}, {"title": "The similar variable, performanceFee, is handled consistently in weekly terms. This makes the inconsistent handling of managementFee even more confusing and potentially error prone.", "body": "The similar variable, performanceFee, is handled consistently in weekly terms. This makes the inconsistent handling of managementFee even more confusing and potentially error prone.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#the-similar-variable,-performancefee,-is-handled-consistently-in-weekly-terms.-this-makes-the-inconsistent-handling-of-managementfee-even-more-confusing-and-potentially-error-prone.", "labels": ["OpenZeppelin"]}, {"title": "In order to make the effective managementFee more precise, make its handling consistent with performanceFee, and reduce the complexity of the code, consider passing the weekly management fee to the contract rather than the yearly management fee.", "body": "In order to make the effective managementFee more precise, make its handling consistent with performanceFee, and reduce the complexity of the code, consider passing the weekly management fee to the contract rather than the yearly management fee.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#in-order-to-make-the-effective-managementfee-more-precise,-make-its-handling-consistent-with-performancefee,-and-reduce-the-complexity-of-the-code,-consider-passing-the-weekly-management-fee-to-the-contract-rather-than-the-yearly-management-fee.", "labels": ["OpenZeppelin"]}, {"title": "Update: Not fixed. The Ribbon Finance team state, \u201cwe prefer leaving as is\u201d.", "body": "[N11] Redundant require statements  ShareMath library includes two helper functions,  assertUint104 and  assertUint128, to check that a provided  getSharesFromReceipt function, the  sharesFromRound value is set as the return value of  underlyingToShares. However,  asserts that its calculated return value can fit inside a uint104 before returning that value as a uint104. This makes the  assertion that sharesFromRound is a uint104 redundant.  Consider removing redundant require statements and assertions to reduce the overall complexity and gas consumption of the codebase.  Update: Fixed in commit 78448cb3ab4626cc68f753141a5354c5579a9361 of PR#110.  [N12] Gas-saving conditional too strict  shareBalances function of  To further clarify the intent of the function and to save additional gas, consider modifying the conditional to be &lt;= rather than strictly &lt;.  Update: Not an issue. It is possible for a vault to have unredeemed shares at round PLACEHOLDER_UINT so the equality from the audited codebase should not be modified.  [N13] Undocumented implicit approval requirements  The RibbonVault contracts deposit and depositFor functions implicitly assume that they have been granted an appropriate allowance before calling safeTransferFrom.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed in commit f9fe0c7deee8bd4c05645ec5f7e8b5662d4730a3 of PR#112.  [N14] Unused import statements  Within the codebase there are instances of files being imported unnecessarily. For example:  SafeERC20 and IOptionsPremiumPricer in VaultLifecycle  GnosisAuction, IOtoken, IGnosisAuction, IStrikeSelection, and IOptionsPremiumPricer in RibbonVault  SafeERC20 and IGnosisAuction in RibbonDeltaVault  IOtoken in StrikeSelection  To improve the overall legibility and maintainability of the codebase, consider removing any unused import statements.  Update: Partially fixed in commit 35fd1001b4c0b4b76b47e1a88dac8f6c2606b6f1 in PR#113. SafeERC20 is still imported in RibbonDeltaVault but not used.  Conclusions  1 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#update:-not-fixed.-the-ribbon-finance-team-state,-\u201cwe-prefer-leaving-as-is\u201d.", "labels": ["OpenZeppelin"]}, {"title": "[N09] Loss of accuracy as a result of divisions", "body": "[N09] Loss of accuracy as a result of divisions", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#[n09]-loss-of-accuracy-as-a-result-of-divisions", "labels": ["OpenZeppelin"]}, {"title": "Due to the fact that division truncates in the EVM, division should be done last unless overflows make such an order infeasible. While divisions are generally performed last throughout the codebase, on lines 128-132 of GnosisAuction, there are a series of SafeMath operations performed to calculate a buyAmount where the division happens in the middle of the calculation, before a multiplication. This can lead to the amplification of the truncation and further loss of precision.", "body": "Due to the fact that division truncates in the EVM, division should be done last unless overflows make such an order infeasible. While divisions are generally performed last throughout the codebase, on lines 128-132 of GnosisAuction, there are a series of SafeMath operations performed to calculate a buyAmount where the division happens in the middle of the calculation, before a multiplication. This can lead to the amplification of the truncation and further loss of precision.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#due-to-the-fact-that-division-truncates-in-the-evm,-division-should-be-done-last-unless-overflows-make-such-an-order-infeasible.-while-divisions-are-generally-performed-last-throughout-the-codebase,-on-lines-128-132-of-gnosisauction,-there-are-a-series-of-safemath-operations-performed-to-calculate-a-buyamount-where-the-division-happens-in-the-middle-of-the-calculation,-before-a-multiplication.-this-can-lead-to-the-amplification-of-the-truncation-and-further-loss-of-precision.", "labels": ["OpenZeppelin"]}, {"title": "Consider changing the order of operations so that the multiplications are done before divisions where possible.", "body": "Consider changing the order of operations so that the multiplications are done before divisions where possible.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#consider-changing-the-order-of-operations-so-that-the-multiplications-are-done-before-divisions-where-possible.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 9d036480c0850648b681847f421361dc6481f904 of PR#109.", "body": "Update: Fixed in commit 9d036480c0850648b681847f421361dc6481f904 of PR#109.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#update:-fixed-in-commit-9d036480c0850648b681847f421361dc6481f904-of-pr#109.", "labels": ["OpenZeppelin"]}, {"title": "[N10] Not inheriting from available interfaces", "body": "[N10] Not inheriting from available interfaces", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#[n10]-not-inheriting-from-available-interfaces", "labels": ["OpenZeppelin"]}, {"title": "Some of the provided interfaces are not inherited from by the contracts they are meant to describe. This can lead to issues if an interface or corresponding contract is modified in a way that would make them incompatible. Some examples of this lack of inheritance are:", "body": "Some of the provided interfaces are not inherited from by the contracts they are meant to describe. This can lead to issues if an interface or corresponding contract is modified in a way that would make them incompatible. Some examples of this lack of inheritance are:", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#some-of-the-provided-interfaces-are-not-inherited-from-by-the-contracts-they-are-meant-to-describe.-this-can-lead-to-issues-if-an-interface-or-corresponding-contract-is-modified-in-a-way-that-would-make-them-incompatible.-some-examples-of-this-lack-of-inheritance-are:", "labels": ["OpenZeppelin"]}, {"title": "StrikeSelection does not inherit from IStrikeSelection.", "body": "StrikeSelection does not inherit from IStrikeSelection.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#strikeselection-does-not-inherit-from-istrikeselection.", "labels": ["OpenZeppelin"]}, {"title": "RibbonThetaVault does not inherit from IRibbonThetaVault.", "body": "RibbonThetaVault does not inherit from IRibbonThetaVault.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#ribbonthetavault-does-not-inherit-from-iribbonthetavault.", "labels": ["OpenZeppelin"]}, {"title": "To clarify intent, increase the readability the codebase, and allow the compiler to perform more robust error-checking, consider updating the contracts\u2019 inheritance declarations to explicitly inherit from their corresponding interfaces.", "body": "To clarify intent, increase the readability the codebase, and allow the compiler to perform more robust error-checking, consider updating the contracts\u2019 inheritance declarations to explicitly inherit from their corresponding interfaces.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#to-clarify-intent,-increase-the-readability-the-codebase,-and-allow-the-compiler-to-perform-more-robust-error-checking,-consider-updating-the-contracts\u2019-inheritance-declarations-to-explicitly-inherit-from-their-corresponding-interfaces.", "labels": ["OpenZeppelin"]}, {"title": "[N11] Redundant require statements", "body": "[N11] Redundant require statements", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#[n11]-redundant-require-statements", "labels": ["OpenZeppelin"]}, {"title": "ShareMath library includes two helper functions,", "body": "ShareMath library includes two helper functions,", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#sharemath-library-includes-two-helper-functions,", "labels": ["OpenZeppelin"]}, {"title": "assertUint104 and", "body": "assertUint104 and", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#assertuint104-and", "labels": ["OpenZeppelin"]}, {"title": "assertUint128, to check that a provided", "body": "assertUint128, to check that a provided", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#assertuint128,-to-check-that-a-provided", "labels": ["OpenZeppelin"]}, {"title": "getSharesFromReceipt function, the", "body": "getSharesFromReceipt function, the", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#getsharesfromreceipt-function,-the", "labels": ["OpenZeppelin"]}, {"title": "sharesFromRound value is set as the return value of", "body": "sharesFromRound value is set as the return value of", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#sharesfromround-value-is-set-as-the-return-value-of", "labels": ["OpenZeppelin"]}, {"title": "underlyingToShares. However,", "body": "underlyingToShares. However,", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#underlyingtoshares.-however,", "labels": ["OpenZeppelin"]}, {"title": "asserts that its calculated return value can fit inside a uint104 before returning that value as a uint104. This makes the", "body": "asserts that its calculated return value can fit inside a uint104 before returning that value as a uint104. This makes the", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#asserts-that-its-calculated-return-value-can-fit-inside-a-uint104-before-returning-that-value-as-a-uint104.-this-makes-the", "labels": ["OpenZeppelin"]}, {"title": "assertion that sharesFromRound is a uint104 redundant.", "body": "assertion that sharesFromRound is a uint104 redundant.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#assertion-that-sharesfromround-is-a-uint104-redundant.", "labels": ["OpenZeppelin"]}, {"title": "Consider removing redundant require statements and assertions to reduce the overall complexity and gas consumption of the codebase.", "body": "Consider removing redundant require statements and assertions to reduce the overall complexity and gas consumption of the codebase.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#consider-removing-redundant-require-statements-and-assertions-to-reduce-the-overall-complexity-and-gas-consumption-of-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 78448cb3ab4626cc68f753141a5354c5579a9361 of PR#110.", "body": "Update: Fixed in commit 78448cb3ab4626cc68f753141a5354c5579a9361 of PR#110.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#update:-fixed-in-commit-78448cb3ab4626cc68f753141a5354c5579a9361-of-pr#110.", "labels": ["OpenZeppelin"]}, {"title": "[N12] Gas-saving conditional too strict", "body": "[N12] Gas-saving conditional too strict", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#[n12]-gas-saving-conditional-too-strict", "labels": ["OpenZeppelin"]}, {"title": "shareBalances function of", "body": "shareBalances function of", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#sharebalances-function-of", "labels": ["OpenZeppelin"]}, {"title": "To further clarify the intent of the function and to save additional gas, consider modifying the conditional to be &lt;= rather than strictly &lt;.", "body": "To further clarify the intent of the function and to save additional gas, consider modifying the conditional to be &lt;= rather than strictly &lt;.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#to-further-clarify-the-intent-of-the-function-and-to-save-additional-gas,-consider-modifying-the-conditional-to-be-&lt;=-rather-than-strictly-&lt;.", "labels": ["OpenZeppelin"]}, {"title": "Update: Not an issue. It is possible for a vault to have unredeemed shares at round PLACEHOLDER_UINT so the equality from the audited codebase should not be modified.", "body": "Update: Not an issue. It is possible for a vault to have unredeemed shares at round PLACEHOLDER_UINT so the equality from the audited codebase should not be modified.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#update:-not-an-issue.-it-is-possible-for-a-vault-to-have-unredeemed-shares-at-round-placeholder_uint-so-the-equality-from-the-audited-codebase-should-not-be-modified.", "labels": ["OpenZeppelin"]}, {"title": "[N13] Undocumented implicit approval requirements", "body": "[N13] Undocumented implicit approval requirements", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#[n13]-undocumented-implicit-approval-requirements", "labels": ["OpenZeppelin"]}, {"title": "The RibbonVault contract\u2019s deposit and depositFor functions implicitly assume that they have been granted an appropriate allowance before calling safeTransferFrom.", "body": "The RibbonVault contract\u2019s deposit and depositFor functions implicitly assume that they have been granted an appropriate allowance before calling safeTransferFrom.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#the-ribbonvault-contract\u2019s-deposit-and-depositfor-functions-implicitly-assume-that-they-have-been-granted-an-appropriate-allowance-before-calling-safetransferfrom.", "labels": ["OpenZeppelin"]}, {"title": "In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions\u2019 inline documentation.", "body": "In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions\u2019 inline documentation.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#in-favor-of-explicitness-and-to-improve-the-overall-clarity-of-the-codebase,-consider-documenting-all-approval-requirements-in-the-relevant-functions\u2019-inline-documentation.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit f9fe0c7deee8bd4c05645ec5f7e8b5662d4730a3 of PR#112.", "body": "Update: Fixed in commit f9fe0c7deee8bd4c05645ec5f7e8b5662d4730a3 of PR#112.", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#update:-fixed-in-commit-f9fe0c7deee8bd4c05645ec5f7e8b5662d4730a3-of-pr#112.", "labels": ["OpenZeppelin"]}, {"title": "[N14] Unused import statements", "body": "[N14] Unused import statements", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#[n14]-unused-import-statements", "labels": ["OpenZeppelin"]}, {"title": "Within the codebase there are instances of files being imported unnecessarily. For example:", "body": "Within the codebase there are instances of files being imported unnecessarily. For example:", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#within-the-codebase-there-are-instances-of-files-being-imported-unnecessarily.-for-example:", "labels": ["OpenZeppelin"]}, {"title": "SafeERC20 and IOptionsPremiumPricer in VaultLifecycle", "body": "SafeERC20 and IOptionsPremiumPricer in VaultLifecycle", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#safeerc20-and-ioptionspremiumpricer-in-vaultlifecycle", "labels": ["OpenZeppelin"]}, {"title": "GnosisAuction, IOtoken, IGnosisAuction, IStrikeSelection, and IOptionsPremiumPricer in RibbonVault", "body": "GnosisAuction, IOtoken, IGnosisAuction, IStrikeSelection, and IOptionsPremiumPricer in RibbonVault", "html_url": "https://blog.openzeppelin.com/ribbon-finance-audit#gnosisauction,-iotoken,-ignosisauction,-istrikeselection,-and-ioptionspremiumpricer-in-ribbonvault", "labels": ["OpenZeppelin"]}]