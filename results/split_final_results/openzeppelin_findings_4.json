[{"title": "Recommendations", "body": "Conclusion  Summary  zkEVM-based ZK-rollup, Bridge & Rollup  From 2023-08-16  To 2023-08-23  Solidity  10 (8\u202fresolved, 1\u202fpartially\u202fresolved)  0 (0\u202fresolved)  1 (1\u202fresolved)  0 (0\u202fresolved)  2 (1\u202fresolved)  7 (6\u202fresolved, 1\u202fpartially\u202fresolved)  Scope  We audited the Scroll Owner pull request and the Rate Limiter pull request from the scroll-tech/scroll repository at commit ae2e010.  For the Rate Limiter pull request, we also performed a diff audit of the scroll-tech/scroll repository at the ae2e010 commit against the 767a2cb commit.  System Overview  Scroll is an EVM-equivalent ZK-rollup designed to be a scaling solution for Ethereum. It achieves this by interpreting EVM bytecode directly at the bytecode level, following a similar path to projects like Polygon's zkEVM and Consensys' Linea.  Scroll's architecture and code structure draw inspiration from other Layer 2 solutions like Arbitrum and Optimism, particularly in the design of their gateways, predeploys, and messaging contracts. Notably, a lot of code structures from Arbitrum's gateways and the AddressAliasHelper.sol contract are reused with minor modifications.  This audit reviewed two new additions to the protocol. ScrollOwner implements a role-based model for access control. This will allow administrators' addresses to execute sensitive configurations on the core contracts of the protocol. Additionally, rate-limiting contracts have been implemented to enforce deposit and withdrawal limits for assets over specific time intervals for enhanced security.  This report presents our findings and recommendations for the additions to the Scroll ZK-rollup protocol. In the following sections, we will discuss these aspects in detail. We urge the Scroll team to consider these findings in their ongoing efforts to provide a secure and efficient Layer 2 solution for Ethereum.  Trust Assumptions  During the course of the audit, several assumptions about the Scroll protocol were considered to be inherently trusted. These assumptions and the context surrounding them include:  EVM node and relayer implementation: It is assumed that the EVM node implementation will work as described in the Scroll documentation, particularly the opcodes and their expected behavior. The relayer implementation is trusted to act in the best interest of the users.  Censoring: The protocol is centralized as is, as the sequencer and prover have the ability to censor L2 messages and transactions. L1 to L2 messages are appended into a message queue that is checked against when finalizing, but the sequencer can currently choose to skip any message from this queue during finalization. This allows the chain to finalize even if a message is not provable. Therefore, it is worth noting that L1 to L2 messages from the L1ScrollMessenger or EnforcedTxGateway can be ignored and skipped. There are plans to remove this message-skipping mechanism after the mainnet launch, once the prover is more capable.  No escape hatch: The Scroll protocol does not feature an escape hatch mechanism. This, combined with the potential for transaction censorship by the relayer, introduces a trust assumption in the protocol. In the event of the network going offline, users would not be able to recover their funds.  Whitelist ownership: The whitelist contract has an owner who can update the whitelist status of different addresses. This implies trust in the owner of the whitelist to manage this list correctly and in the best interest of the system and its users.  Privileged Roles  Certain privileged roles within the Scroll protocol were identified during the audit. These roles possess special permissions that could potentially impact the system's operation:  Access Control: The access control manager is a contract in which there is an address with default admin privileges that can perform the critical administrative action of giving and revoking roles for different addresses. This mechanism is used in the following contracts:  ScrollOwner: The default admin role can grant roles for addresses to execute functions through the contract. Every role will be associated with a designated set of functions tied to specific addresses permissible to execute within that role. Moreover, existing roles will come with execution delays ranging from 0 days for instant execution to 1 day, 7 days, and 14 days. This provides a dynamic control mechanism over the timing of function execution based on their respective impact levels. TokenRateLimiter: The default admin role can update the total token amount limit. The admin can also grant a token spender role for the Scroll gateways and messengers to ensure a rate limit when depositing or withdrawing funds.  Proxy Admins: Most of the contracts are upgradeable. Hence, most of the logic can be changed by the proxy admin. The following contracts are upgradeable:  The gateway contracts L1MessageQueue L1ScrollMessenger L2GasPriceOracle ScrollChain L2ScrollMessenger  Implementation Owners: Most contracts are", "html_url": "https://blog.openzeppelin.com/scrollowner-and-rate-limiter-audit#recommendations", "labels": ["OpenZeppelin"]}, {"title": "Monitoring Recommendations", "body": "While audits help in identifying code-level issues in the current implementation and potentially the code deployed in production, the Scroll team is encouraged to consider incorporating monitoring activities in the production environment. Ongoing monitoring of deployed contracts helps identify potential threats and issues affecting production environments. With the goal of providing a complete security assessment, the monitoring recommendations section raises several actions addressing trust assumptions and out-of-scope components that can benefit from on-chain monitoring.  Scroll Owner  Monitoring any role changes from the Scroll Owner will help detect any unauthorized changes. This can help detect malicious activity or a compromised account.  Rate Limiter  Monitoring the current rate limits against the total rate limit should be done to ensure that protocol withdrawals are not being paused because of rate limit breaches. It can also help detect DOS attacks against the rate limiter or suspicious activity. It is also recommended to monitor any updates to the rate limiter limit.", "html_url": "https://blog.openzeppelin.com/scrollowner-and-rate-limiter-audit#monitoring-recommendations", "labels": ["OpenZeppelin"]}, {"title": "L2USDCGateway Is Missing Rate Limiter Functionality", "body": "L1USDCGateway contract inherits from  L1ERC20Gateway. When a user initiates a deposit, the  _addUsedAmount. However, the  L2USDCGateway contract inherits from  L2ERC20Gateway which does not call the rate limiter  Consider ensuring that _addUsedAmount is called when users make a withdrawal in USDC.  Update: Resolved in pull request #927 at commit be6d404.  Low Severity", "html_url": "https://blog.openzeppelin.com/scroll-usdc-gateway-audit#l2usdcgateway-is-missing-rate-limiter-functionality", "labels": ["OpenZeppelin"]}, {"title": "Misleading Comment", "body": "The comment in line 172 of the L2USDCGateway contract should say L2ScrollMessenger instead of L1ScrollMessenger.  Consider resolving this instance of incorrect documentation to improve the clarity and readability of the codebase.  Update: Resolved in pull request #928 at commit 733d2a6.", "html_url": "https://blog.openzeppelin.com/scroll-usdc-gateway-audit#misleading-comment", "labels": ["OpenZeppelin"]}, {"title": "Lack of gap Variable", "body": "The CCTPGatewayBase contract does not contain a gap variable although it is upgradeable.  Consider adding a gap variable following OpenZeppelin's upgradeable contracts guide to avoid future storage collisions.  Update: Resolved in pull request #929 at commit 5e61a05.", "html_url": "https://blog.openzeppelin.com/scroll-usdc-gateway-audit#lack-of-gap-variable", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Throughout the codebase there are several parts that do not have docstrings. For instance:  Line 17 in L1ERC20Gateway.sol  Line 64 in L2USDCGateway.sol  Line 5 in IMessageTransmitter.sol  Line 6 in IMessageTransmitter.sol  Line 5 in ITokenMessenger.sol  Line 6 in IUSDCBurnableSourceBridge.sol  Line 6 in IUSDCDestinationBridge.sol  Line 9 in CCTPGatewayBase.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #940 at commit 30fa5e6.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/scroll-usdc-gateway-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "Throughout the codebase there are imports that are unused and could be removed. For instance:  Import IScrollMessenger of L1ERC20Gateway.sol  Import ScrollConstants of L1ERC20Gateway.sol  Import OwnableUpgradeable of L1USDCGateway.sol  Import IERC20Upgradeable of L1USDCGateway.sol  Import IL1ERC20Gateway of L1USDCGateway.sol  Import IL2ERC20Gateway of L2USDCGateway.sol  Import IScrollGateway of L2USDCGateway.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Partially resolved in pull request #930 at commit 23bf84a. L1USDCGateway.sol still imports IL1ERC20Gateway and L2USDCGateway.sol still imports IL2ERC20Gateway.", "html_url": "https://blog.openzeppelin.com/scroll-usdc-gateway-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Insufficient Tests When Using BitMaps", "body": "Pull request 893 changes the way of popping and tracking skipped messages, using BitMaps and buckets instead. This represents a sensitive change compared to the previous version. However, only a single test case with a fixed random BitMap, count, and starting index was introduced.  In order to verify that the expected behavior of filling the buckets and skipping messages is the expected one from the rest of the code, consider adding more test cases, especially testing edge cases for filling buckets.  Update: Resolved in pull request 956 at commit 6749eb7.", "html_url": "https://blog.openzeppelin.com/scroll-diff-audit-report#insufficient-tests-when-using-bitmaps", "labels": ["OpenZeppelin"]}, {"title": "Implicit Limitation of Withdrawal", "body": "On pull request 912, the FeeVault contract introduced the possibility to pass a parameter of the value to withdraw. However, this value is implicitly limited to the contract's current balance by the sendMessage function call.  In order to fail early and return a clear error message (which would help when debugging a reverted transaction), consider adding a requirement that asserts that the value passed is equal to or less than the contract's balance.  Update: Resolved in pull request 954 at commit 08b8bc9.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/scroll-diff-audit-report#implicit-limitation-of-withdrawal", "labels": ["OpenZeppelin"]}, {"title": "Misleading Documentation", "body": "Throughout the codebase, there are some instances of incorrect or misleading documentation. In particular:  Pull request 943 refactored the functionality of the FeeVault contract under the L2TxFeeVault contract. However, the NatSpec was copied from the FeeVault contract, stating: \"The L2TxFeeVault contract contains the basic logic for the various different vault contracts used to hold fee revenue generated by the L2 system\". Unless the L2TxFeeVault contract is going to be used as a base contract for other future contracts, consider adjusting the documentation to reflect the current behavior.  The comment in line 67 of L1MessageQueue.sol should say \"for dropped messages\" instead of \"skipped messages\".  Consider resolving these instances of incorrect documentation to improve the clarity and readability of the codebase.  Update: Resolved in pull request 955 at commit e1a3f95.", "html_url": "https://blog.openzeppelin.com/scroll-diff-audit-report#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Batch Hashes Due to Memory Corruption", "body": "When committing a new batch, the ScrollChain contract calls the _commitChunk function to compute a hash for each chunk in the batch. This hash includes the block contexts, as well as L1 and L2 transaction hashes that are part of this chunk. The _commitChunk function does this by getting the free memory pointer, storing everything it needs contiguously starting there, and then getting the free memory pointer again to compute the keccak256 hash of this section of memory.  Importantly, the function relies on the free memory pointer pointing to the same memory location to be able to fetch the initial location from which to start computing the hash. However, when fetching the L1 message hashes, the code does an external call to getCrossDomainMessage which stores its return value in memory. This causes the free memory pointer to be shifted by a word to the right for each L1 message being processed. This means that the chunk hashes are incomplete and the commitment would not include parts of the information needed as soon as a block contains L1 transactions.  The resulting batch would thus have an incorrect hash. The network would not be able to finalize when there are L1 transactions in a batch because the hash would not match with the proof based on the zkEVM circuits.  Consider limiting the inline assembly usage to be less error-prone for memory corruption issues. Otherwise, make sure to keep track of the right pointer to begin the hashing. Further, ensure that these endpoints and any changes to them are fully end-to-end tested.  Update: Resolved in pull request #546 at commit 9606c61.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#incorrect-batch-hashes-due-to-memory-corruption", "labels": ["OpenZeppelin"]}, {"title": "Non-Standard RLP Encoding of Integer Zero", "body": "In the L1MessageQueue, the computeTransactionHash function implements the EIP-2718 standard. Here, the transaction type of 0x7E is concatenated with the RLP-encoded transaction values and hashed.  store_uint assembly function which gives the non-standard encoding for the integer value zero. While the standard foresees that zero is encoded as  calling _queueTransaction with zero and then computing the transaction hash with  During the committing of batches, hashes of the message queue become part of the commitment that will be proven during finalization. Considering the non-standard L1 transaction hashes, this commitment is expected to not align with the proof coming from the zk-circuit, hence making the first and majority of L1 messages impossible to finalize.  Consider patching the store_uint function to catch this zero-integer edge case and achieve a standard encoding.  Update: Resolved in pull request #558 at commit 869111b.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#non-standard-rlp-encoding-of-integer-zero", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Depth Calculation for Extension Nodes Allows Denial-of-Service", "body": "PatriciaMerkleTrieVerifier library is used by the  sent an L1 message or  executed an L2 message. Further, this functionality enables the user to  retry an L1 sent message on L2 in case of insufficient gas. Therefore, users can call the  RPC method eth_getProof on an Ethereum node and submit the obtained proof to the  at least one failed attempt to relay the message. Since the proof verification is based on the world state and account storage trie, the proof consists of an account and storage proof.  During verification, the PatriciaMerkleTrieVerifier library walks down the inclusion proof to verify that hashes match as expected. However, when encountering an extension node in the account or storage proof, the library incorrectly computes the depth by adding the length in bytes to the depth, instead of the number of nibbles (half-bytes), as well as not accounting for the path length parity.  For example, if the extension node ['13 f4 a7', next_hash] was encountered, the 1 would indicate that it is an extension node with an odd path length. The correct path length to be added to the depth would be 5, but the library incorrectly adds 3 to the depth by getting the length in bytes. More concretely, due to an extension node in the account proof, it is impossible to prove that the storage slot 0 of address 0x0068cf6ef4fdf5a95d0e2546dab76f679969f3f5 contains the value 2 on the Ethereum mainnet.  This error leads to valid proofs not being accepted by the PatriciaMerkleTrieVerifier library. Since only the storage for the L1ScrollMessenger contract address is checked, a present extension node in the proof for this account would fail all verifications. An attacker can take advantage of this by brute-forcing an address on L1 via CREATE2 that has a hash collision in the first nibbles with the hash of the L1ScrollMessenger address. Hence, an extension node is forced to appear in the state trie, thereby preventing any message to be replayed on L2 - a denial-of-service attack - potentially locking users' funds until the contract is upgraded.  Consider fixing the length calculation for extension nodes to accept valid proofs. It is advised to test the library and integration more thoroughly, for instance with a differential fuzzing approach and integration tests.  Update: Resolved in pull request #617 at commit a8832bf.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#incorrect-depth-calculation-for-extension-nodes-allows-denial-of-service", "labels": ["OpenZeppelin"]}, {"title": "Withdraw Root Can Be Set Up as a Rug Pull", "body": "withdrawRoot hash of the first batch. For L2 to L1 communication, L2 transactions are relayed through the  _xDomainCalldataHash which is based on the relayed message data can be precalculated to  send any amount of ETH to any address. By setting up that hash as the genesis block  _messageRoot in the respective relay message call. Then, with a proof of length zero, the  hashes match and the  Merkle proof requirement passes, thereby stealing the users' deposited funds.  Since the importGenesisBatch function is unprotected this could be set up by anyone, although it is unlikely to be unnoticed that the genesis block was initialized by an outside actor. But this could also just lead to a malicious actor setting up the chain with erroneous parameters and the Scroll team having to redeploy the proxy contract that delegates into the ScrollChain contract implementation.  Consider removing the _withdrawRoot parameter of the importGenesisBatch function and instead hardcoding its genesis block value to zero. Further, consider protecting the function to only be called by the owner.  Update: Partially resolved in pull request #558 at commit b82dab5. The _withdrawRoot is removed as a parameter and unset, but the function is still callable by anyone. The Scroll team stated:  It is only called once during initialization, it should not be a problem to be callable by anyone.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#withdraw-root-can-be-set-up-as-a-rug-pull", "labels": ["OpenZeppelin"]}, {"title": "Users Can Lose Refund by Default", "body": "Users Can Lose Refund by Default", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#users-can-lose-refund-by-default", "labels": ["OpenZeppelin"]}, {"title": "Lack of Refunds", "body": ".  Trust Assumptions  During the course of the audit, several assumptions about the Scroll protocol were considered to be inherently trusted. These assumptions and the context surrounding them include:  EVM node and relayer implementation: It is assumed that the EVM node implementation will work as described in the Scroll documentation, particularly the opcodes and their expected behavior. The relayer implementation is trusted to act in the best interest of the users.  Censoring: The protocol is centralized as is, as the sequencer has the ability to censor L2 messages and transactions. L1 to L2 messages are appended into a message queue that is checked against when finalizing, but the sequencer can currently choose to skip any message from this queue during finalization. This allows the chain to finalize even if a message is not provable. Therefore, it is worth noting that L1 to L2 messages from the L1ScrollMessenger or EnforcedTxGateway can be ignored and skipped. There are plans to remove this message-skipping mechanism post-mainnet launch once the prover is more capable.  No escape hatch: The Scroll protocol does not feature an escape hatch mechanism. This, combined with the potential for transaction censorship by the relayer, introduces a trust assumption in the protocol. In the event of the network going offline, users would not be able to recover their funds.  Privileged Roles  Certain privileged roles within the Scroll protocol were identified during the audit. These roles possess special permissions that could potentially impact the system's operation:  Proxy Admins: Most of the contracts are upgradeable. Hence, most of the logic can be changed by the proxy admin. The following contracts are upgradeable:  The gateway contracts L1MessageQueue L1ScrollMessenger L2GasPriceOracle ScrollChain SimpleGasOracle  Implementation Owners: Most contracts are also ownable. The following actions describe what the owner can do in each contract.  L1ScrollMessenger: Pause relaying of L2 to L1 messages and L1 to L2 message requests. EnforcedTxGateway: Pause L1 to L2 transaction requests and change the fee vault. L1{CustomERC20|ERC721|ERC1155}Gateway: Change the token mapping of which L1 token is bridged to which L2 token. L1GatewayRouter: Set the respective gateway for ETH, custom ERC-20s and default ERC-20s. L1MessageQueue: Update the maximum allowed gas limit for L2 transactions, the gas price oracle to calculate the L2 fee and the EnforcedTxGateway address that may append unaliased messages into the queue. L2GasPriceOracle: Set the whitelist contract address that defines who may change gas-related settings. ScrollChain: Revert previously committed batches that haven't been finalized yet, set addresses as sequencers, change the verifier, and update the maximum amount of L2 transactions that are allowed in a chunk (bundle of blocks). FeeVault: Change the messenger address that is used to withdraw the funds from L2 to L1, the recipient address of the collected fees, and update the minimum amount of funds to withdraw. ScrollMessengerBase: Change the fee vault address which collects fees for message relaying. SimpleGasOracle: Update the default and a custom per-sender fee configuration. ScrollStandardERC20Factory: Use the factory to deploy another instance of a standard ERC-20 token on L2.  Sequencer: The sequencer role can interact with the ScrollChain contract to commit to new batches that bundle multiple L2 blocks in chunks that can then be finalized along with a proof.  Whitelist: Accounts can be whitelisted to change the L2 base fee on L1 as well as the intrinsic gas parameters.  Each of these roles presents a unique set of permissions within the Scroll protocol. The potential implications of these permissions warrant further consideration and mitigation to ensure the systems security and robustness.  High Severity  Incorrect Batch Hashes Due to Memory Corruption  When committing a new batch, the ScrollChain contract calls the _commitChunk function to compute a hash for each chunk in the batch. This hash includes the block contexts, as well as L1 and L2 transaction hashes that are part of this chunk. The _commitChunk function does this by getting the free memory pointer, storing everything it needs contiguously starting there, and then getting the free memory pointer again to compute the keccak256 hash of this section of memory.  Importantly, the function relies on the free memory pointer pointing to the same memory location to be able to fetch the initial location from which to start computing the hash. However, when fetching the L1 message hashes, the code does an external call to getCrossDomainMessage which stores its return value in memory. This causes the free memory pointer to be shifted by a word to the right for each L1 message being processed. This means that the chunk hashes are incomplete and the commitment would not include parts of the information needed as soon as a block contains L1 transactions.  Th", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#lack-of-refunds", "labels": ["OpenZeppelin"]}, {"title": "L2 Standard ERC-20 Token Metadata Can Be Set Arbitrarily", "body": "contract fetches the symbol, name and decimals of the ERC-20 token. These are  ABI encoded alongside the  decoded from the data. A  call to the ScrollStandardERC20Factory is then made and a clone of the  initialized with the symbol, name and decimals.  However, an attacker can use the lack of atomicity when bridging to set arbitrary metadata when an ERC-20 is bridged to L2 for the first time. An example of this would involve two transactions:  The attacker first calls the deposit function to deposit a new ERC-20 token with a very low _gasLimit parameter. Because the ERC-20 address is not yet in tokenMapping, the contract fetches its metadata information and encodes it alongside the _data parameter. The token is then added to the tokenMapping, the message is relayed and reverts on L2 with an out-of-gas exception.  The attacker then calls the deposit function again with a _data parameter containing an ABI encoding of arbitrary metadata. Because the tokenMapping now contains the ERC-20 address, the call would be directly transmitted to L2 without fetching the ERC-20 metadata. As it is the first time the L2 sees this token, a ScrollStandardERC20 clone is deployed with symbol, name and decimals decoded from the _data parameter set by the attacker.  The token contract would thus have its metadata set by the attacker. Additionally, this contract and the factory are immutable, and the address to which a clone is deployed is deterministic meaning it cannot be redeployed easily. This would be complex to fix in practice. In terms of impact, it would be very confusing for users, having to deal with tokens with different metadata in the UIs depending on whether the token is on L1 or L2, and could be used to intentionally grief specific projects.  Consider not updating tokenMapping[_token] on the first partially successful L1 deposit, but only when a token is successfully withdrawn from L2 in the finalizeWithdrawERC20 function. This strikes a good balance by ensuring that tokens can be deployed even if a first transaction fails on L2, as the metadata would be sent again, while avoiding wasting gas by querying this information on each deposit forever.  Update: Resolved in pull request #606 at commit 2f76991.  Medium Severity", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#l2-standard-erc-20-token-metadata-can-be-set-arbitrarily", "labels": ["OpenZeppelin"]}, {"title": "Enforced Transactions Signed Off-Chain Are Likely to Fail", "body": "The EnforcedTxGateway contract allows users to sign a transaction hash that authorizes an L1 to L2 transaction. During the verification of the signature, the signed hash is computed given the sendTransaction function parameters, except for the _queueIndex value, which is fetched as the supposedly following index from the message queue.  Timing this queue index during signing becomes challenging considering the following scenario:  User A signs the transaction off-chain for index i.  User B queues a transaction unrelated to A, thereby incrementing the queue index to i+1.  User C tries to submit user A's transaction, which reverts due to the mismatching queue indices.  Depending on the activity of the messenger contract and the delay between users A and C, it is likely that this call reverts.  Consider repurposing the queue index to a nonce that is signed as part of the transaction hash by taking it as an additional function parameter. The replayability must therefore be prevented by keeping track of used transaction hashes in a mapping. Also, consider adding an expiration timestamp and chain id to the message such that signed messages are not indefinitely valid and are chain dependent. Otherwise, a signature can be reused for a rollup that follows the same message format and is signed by the same user. It's important to note that the transaction hash should not be constructed over the signature when an OpenZeppelin library version lower than 4.7.3 is used, due to a signature malleability issue.  Update: Resolved in pull request #620 at commit af8a4c9. The data is now signed using the EIP-712 standard. Expiration and replayability were addressed by adding a deadline and nonce.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#enforced-transactions-signed-off-chain-are-likely-to-fail", "labels": ["OpenZeppelin"]}, {"title": "Lack of Upgradeability Storage Gaps", "body": "Throughout the codebase, these base contracts are inherited into upgradeable contracts:  ScrollMessengerBase  ScrollGatewayBase  L1ERC20Gateway  If storage variables are added to these base contracts without accounting for a storage gap towards the child contracts, a storage collision may cause contracts to malfunction and compromise other functionalities.  Consider adding a gap variable to future-proof base contract storage changes and be safe against storage collisions.  Update: Resolved in pull request #618 at commit 2395883.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#lack-of-upgradeability-storage-gaps", "labels": ["OpenZeppelin"]}, {"title": "WithdrawTrieVerifier Proves Intermediate Nodes", "body": "The WithdrawTrieVerifier library is a Merkle trie verifier. It implements a function to check that a message hash along with a Merkle proof hashes to the given root. This root hash is acquired by consecutively hashing the provided message hash with the hashes from the proof. However, since the length of the proof is not checked, the following problem arises.  The initially provided message hash can be hashed with the first hash of the proof, thereby giving an intermediate node of the trie. This can then be used with a shortened proof to pass the verification, which may lead to replayability. While the forgeability of an intermediate node was not identified as an issue for this library's usage, it is still an issue for the stand-alone library.  Consider adding a length check of the proof to prevent the verification of intermediate nodes with a shortened proof.  Update: Resolved in pull request #619 at commit 22b30ba. The issue was not addressed in the code, but the limitations and how the library should be used were added to the NatSpec of the function.  Low Severity", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#withdrawtrieverifier-proves-intermediate-nodes", "labels": ["OpenZeppelin"]}, {"title": "Batch Reverting Can Pause Finalization", "body": "The ScrollChain contract allows sequencers to commit new batches of L2 blocks on L1. It also allows the owner of the contract to revert a _count amount of unfinalized batches.  However, as the _count parameter can be less than the number of remaining unfinalized batches, the owner can create gaps in the array of batches. With consecutive batches being committed, this gap can be filled until the first old batch. For instance:  This creates two problems:  The b5 batch cannot be overwritten with b5' because the batch index's hash value is non-zero.  The b5 batch cannot be finalized because it is likely that the finalized state root of its parent batch does not match.  Hence, this will lead to downtime in block finalization until the b5 block is reverted.  In order to prevent the creation of gaps and having the owner manually intervene multiple times to fix the chain, consider checking that the batch index + count batch is indeed the latest committed batch to be reverted, for instance by checking that the next committedBatches value is zero. Otherwise, consider using an array type and popping elements from the end, as long as the finalized batches are left untouched.  Update: Resolved in pull request #634 at commit c7de22d.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#batch-reverting-can-pause-finalization", "labels": ["OpenZeppelin"]}, {"title": "Initialization Not Disabled for Implementation Contracts", "body": "Throughout the codebase, implementation contracts are used behind proxies for upgradeability. Hence, many contracts have an initialize function that sets up the proxy. It is a good practice to not leave implementation contracts uninitialized. Hence, consider calling the _disableInitializers function of the inherited Initializable contract in the constructor to prevent the initialization of the implementation contract.  Update: Resolved in pull request #639 at commit d1b7719.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#initialization-not-disabled-for-implementation-contracts", "labels": ["OpenZeppelin"]}, {"title": "Code Redundancy", "body": "Throughout the codebase, there are multiple instances of code redundancy, which is error-prone and hinders the codebase's readability:  The L1ScrollMessenger and ScrollGatewayBase contracts implement a nonReentrant modifier. Instead, consider utilizing the ReentrancyGuardUpgradeable contract of the OpenZeppelin library which is a dependency in use. The same holds for the OwnableBase contract and OpenZeppelin's Ownable contract. The reimplementation of such safety mechanisms is generally discouraged. In both cases, make sure to initialize the contracts properly if they are used for upgradeable contracts.  The IERC20Metadata interface could also be used from the OpenZeppelin library.  The IScrollERC20 and IScrollERC20Upgradeable interfaces are the same interface - consider removing one of them.  The isContract function of the ScrollStandardERC20 contract could also be realized with address.code.length > 0. For better gas efficiency, it is recommended to use this with a Solidity version higher than 0.8.1.  The L1ScrollMessenger and L2ScrollMessenger both implement the setPause function but inherit from ScrollMessengerBase. Consider moving the setPause function to the base contract.  The onlyMessenger modifier of the ScrollGatewayBase contract is unused. Consider removing it.  Consider applying these code changes to improve the quality of the codebase. Make sure to have all of these changes tested with an extensive test suite.  Update: Acknowledged, not resolved. The Scroll team stated:  This will be fixed later if we have more bandwidth.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#code-redundancy", "labels": ["OpenZeppelin"]}, {"title": "Lost Funds in Messenger Contracts", "body": "The ScrollMessengerBase contract has a receive function that does not have any code implemented. There is no use case for the messenger contracts to receive any ETH outside of the payable functions. Instead, users might accidentally send ETH to it. Hence, consider removing the receive function.  Update: Resolved in pull request #637 at commit c89704c. The receive function is needed to provide an equal balance in the messenger contracts after initialization of the rollup. A restriction was added to only be callable by the contract owner.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#lost-funds-in-messenger-contracts", "labels": ["OpenZeppelin"]}, {"title": "Outdated OpenZeppelin Library Version", "body": "The OpenZeppelin library version in use is ^4.5.0 and ^4.5.2 for the upgradeable contracts, while the current release version is 4.9.3. Consider updating the dependency to be safe against any bugs that were patched in the meantime. Make sure to have an extensive test suite testing the integration of the library modules, as some changes may break the existing functionality.  Update: Resolved in pull request #622 at commit 6a01399.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#outdated-openzeppelin-library-version", "labels": ["OpenZeppelin"]}, {"title": "Missing and Misleading Documentation", "body": "Throughout the codebase, there are various instances of misleading documentation:  The burn function of the IScrollERC20 and IScrollERC20Upgradeable interface defines the _amount parameter as the \"token to mint\" although it should say burn.  The comment in the L1CustomERC20Gateway contract saying that the message is passed to L2StandardERC20Gateway should be about L2CustomERC20Gateway.  The NatSpec comments \"Update layer 2 to layer 2\" of the L1ERC1155Gateway and L1ERC721Gateway should be \"Update layer 1 to layer 2\".  The UpdateTokenMapping event of the L1ERC1155Gateway contract documents the L1 token twice, while the second one should be the L2 token.  The L1ETHGateway contract mentions that \"The deposited ETH tokens are held in this gateway\", however, ETH is actually forwarded to the L1ScrollMessenger contract.  The revert string of \"only EOA\" in the L1MessageQueue contract is not accurate for the check it performs, because contract accounts fulfill this condition during the construction time.  In the IL2ETHGateway the gasLimit parameter of the withdraw functions is said to be optional, while the same parameter in the ERC-20, ERC-721, and ERC-1155 corresponding interfaces is said to be unused. Looking into the relayer code, the parameter is indeed unused. Hence, consider correcting the ETH gateway documentation.  In the PatriciaMerkleTrieVerifier library, the comment \"calldata offset | value length\" should be reversed to \"value length | calldata offset\" as correctly pointed out in the comments above.  In the ScrollChain contract, \"lastBlockHash\" should be \"parentBatchHash\" to be consistent.  In the ScrollChain contract the comment \"see the encoding in comments of commitBatch\" on lines 63 and 68 should refer to BatchHeaderV0Codec instead.  A comment in the ScrollChain contract says \"check genesis batch header length\", although the following line of code checks that the _stateRoot function parameter is non-zero.  In the L2GasPriceOracle contract, the setL2BaseFee function is commented as \"Allows the owner to modify the l2 base fee\", although the function is callable by whitelisted accounts which is a separate role from the owner.  The ScrollMessengerBase and L1ScrollMessenger contracts' NatSpec suggests that the fee vault is a custom contract on L1, while it is actually an EOA or multisig. Consider clarifying this in the documentation.  The L1ScrollMessenger contract documents that it can \"drop expired message due to sequencer problems\", while neither that functionality nor timestamps are implemented.  Besides correcting the above documentation errors, consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. The following instances are concrete examples of missing documentation:  In the ChunkCodec library, L2 transactions are encoded as part of the chunks and added as bytes at the end. However, the encoding of l2Transactions is not documented, except for a comment indicating that the first 4 bytes of each transaction are its length. Consider documenting it.  The _gasLimit parameter of the IGasOracle.estimateMessageFee function is not documented.  The purpose of External.sol should be documented.  When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Acknowledged, not resolved. The Scroll team stated:  This will be fixed later if we have more bandwidth.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#missing-and-misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Lack of Logs on Sensitive Actions", "body": "In the FeeVault contract, the owner role can change the minimum value to withdraw, the recipient, and messenger address. However, none of the functions emit an event. Although these functions will not interfere with users' actions, it could be useful to log the changes for debugging unexpected behaviors or potential hacks.  Moreover, the DeployToken event is defined in the IScrollStandardERC20Factory interface but it is never emitted in the deployL2Token function of the ScrollStandardERC20Factory contract.  Consider adding events to such functions.  Update: Resolved in pull request #623 at commit baa48b7.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#lack-of-logs-on-sensitive-actions", "labels": ["OpenZeppelin"]}, {"title": "Batch Events Lack Information", "body": "IScrollChain interface give crucial updates about the state of L2 finalization on L1. However, while the  ScrollChain view functions work by querying the  Consider emitting the indexed batchIndex together with the hash per event to help facilitate querying important information.  Update: Resolved in pull request #624 at commit 7e8bf3a.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#batch-events-lack-information", "labels": ["OpenZeppelin"]}, {"title": "User Can Derive Call to Be on Behalf of the L1ScrollMessenger", "body": "The L1ScrollMessenger contract enables users to send messages to L2. To pay for the fees or any value sent with the message, ETH is provided along with the call. Because the restriction only asserts that the value needed is less than or equal to the one sent, the protocol refunds any overpayment to the _refundAddress address.  [1] and  [2]), a malicious user might take advantage of the refund process to execute access-controlled functionalities in their  few checks are done to prevent this type of attack.  Even though currently there are no implementations at risk, it is always important to reduce the attack surface for future versions of this upgradeable contract. Hence, consider restricting the _refundAddress to addresses that do not allow the L1ScrollMessenger contract to execute access-controlled functionalities.  Update: Acknowledged, not resolved. The Scroll team stated:  We do not think this needs to be fixed at the moment.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#user-can-derive-call-to-be-on-behalf-of-the-l1scrollmessenger", "labels": ["OpenZeppelin"]}, {"title": "Unpinned Compiler Version", "body": "Valid compiler versions are set via the pragma solidity tag at the top of Solidity files. Most of the codebase provides pragma solidity ^0.8.0 as the compiler pragma. This pragma requires the compiler used to be at least 0.8.0 and lower than 0.9.0.  Since the compiler is not pinned to a specific version, it is possible that tests will target a different version than the one deployed, rendering the test suite inadequate. It also allows new, unreleased compilers to be valid. Although unlikely, new compilers may not support all the code written for current compilers.  Compiler bugs are most commonly found within one to two versions of their introduction. This means the safest, most up-to-date compiler version is a few versions behind the latest unless the code is affected by a bug that was recently fixed. For example, Solidity version 0.8.13 was found to suffer from a bug where under certain conditions some assembly instructions are ignored by the compiler. While the codebase in its current state does not seem to be affected by this specific bug, pinning the version reduces the odds of such vulnerabilities affecting it in the future.  Moreover, the RollupVerifier library makes use of a different pragma (>=0.4.16 <0.9.0), which is inconsistent with the one used in the rest of the codebase.  To ensure the released version matches the tested version, consider pining the Solidity compiler of the entire codebase to a specific version, preferably slightly behind the most up-to-date version (currently 0.8.20).  Update: Resolved in pull request #636 at commit 6d88f92. The Scroll team stated:  The version of all deployable contracts is pinned with =0.8.16. For interfaces, libraries, and abstract contracts, ^0.8.16 is used.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#unpinned-compiler-version", "labels": ["OpenZeppelin"]}, {"title": "Constant Not Using UPPER_CASE Format", "body": "In AddressAliasHelper.sol, the offset constant is not declared using UPPER_CASE format.  According to the Solidity Style Guide, constants should be named with all capital letters with underscores separating words. For better readability, consider following this convention.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#constant-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "Error-Prone Call Encoding", "body": "Throughout the codebase, calls are either encoded with abi.encodeWithSignature or abi.encodeWithSelector, both of which are prone to type or typo errors. Instead, consider using the abi.encodeCall function that protects against both mistakes. When making this change, use Solidity version 0.8.13 or higher, due to a bug encoding literals.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#error-prone-call-encoding", "labels": ["OpenZeppelin"]}, {"title": "Events Should Emit Old and New Value", "body": "There are events in the codebase that would benefit from emitting old and new values for the sake of traceability:  The events in the IL1GatewayRouter and IL2GatewayRouter interfaces.  The UpdateTokenMapping events in the L1 and L2 gateway contracts for the address of the counterpart token.  The L2BaseFeeUpdated event of the L2GasPriceOracle contract for the l2BaseFee value.  Consider emitting the respective old values to enable traceability for off-chain applications and facilitate monitoring rules for suspicious activity.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#events-should-emit-old-and-new-value", "labels": ["OpenZeppelin"]}, {"title": "Events Split Between Contracts and Interfaces", "body": "Throughout the codebase, events are placed in both contracts and interfaces. With the current pattern, events on authorized actions are placed in the contracts while user-relevant events are placed in the interfaces, negatively impacting the codebase's readability. Consider moving the events from the contracts to their respective interfaces. Furthermore, to facilitate monitoring capabilities (which rely on checking events) it is easier to compile the interfaces and obtain their ABI when they are all located in one place.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#events-split-between-contracts-and-interfaces", "labels": ["OpenZeppelin"]}, {"title": "Gas Optimizations", "body": "There are a few instances in the codebase where gas consumption can be reduced. For instance:  In ScrollChain.sol, the lastFinalizedBatchIndex check can be moved up to fail early.  Consider using the delete keyword instead of overwriting variables to their default.  In ScrollChain.sol committedBatches is overwritten. In L1MessageQueue.sol messageQueue is overwritten.  Consider using ++i instead of i++ for for loop increments.  During the initialization of the L1ScrollMessenger contract, the xDomainMessageSender variable is set a second time after the _initialize function of the base contract  In the L1ScrollMessenger the relayMessageWithProof function keeps track of all relay message calls by bundling the information into an id and setting it in a mapping. This seems to be obsolete code and an unnecessary storage write.  Consider bumping the Solidity version to at least 0.8.1 where address.code.length is used, to not copy the code into memory. For more information see the release announcement.  The double hashing of the _l1Token address in the _getSalt and getL2ERC20Address function is unnecessary since _gateway/counterpart and _l1Token are both fixed-size values that cannot result in a hash collision for different values.  In EnforcedTxGateway, the messageQueue storage variable is read onto the stack to save gas, but then again read from storage a second time.  Consider making the above changes to reduce gas consumption.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Integer Base in Inline Assembly", "body": "The codebase makes use of inline assembly for multiple features. When performing these calculations, a decimal and hexadecimal integer base is used interchangeably. Mostly as 32 and 0x20 to calculate word offsets in memory. Consider sticking to one integer base to ease readability and prevent calculation errors.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#inconsistent-integer-base-in-inline-assembly", "labels": ["OpenZeppelin"]}, {"title": "Lack of Indexed Event Parameters", "body": "Throughout the codebase, several events do not have their parameters indexed. For instance:  The UpdateFeeVault event  The UpdateTokenMapping events [1] [2] [3]  The events in L1MessageQueue  The events in L2GasPriceOracle  The UpdateVerifier event  The Withdrawal event  The UpdateFeeVault event  Consider indexing event parameters to improve the ability of off-chain services to search and filter for specific events.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Multiple Event Emissions Can Confuse Off-Chain Clients", "body": "Throughout the codebase, there are multiple onlyOwner-protected functions that set sensitive addresses or values. When passing the same address or value as the one the variable currently has, the triggered event will suggest that the variable has changed its value, creating confusion for off-chain clients potentially reacting to it.  Consider validating the current setting in storage before setting the variable with the passed value and emitting the event.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#multiple-event-emissions-can-confuse-off-chain-clients", "labels": ["OpenZeppelin"]}, {"title": "No Function to Remove a Custom Setting", "body": "In the SimpleGasOracle contract, message fees are estimated based on a fee configuration. This configuration can be set by the owner for default values but also per sender for a custom configuration. However, there is no functionality to return from a custom configuration to the default one. While the custom configuration could be changed to match the default, it would not change along with it. Consider being more flexible and future-proof by adding a removeCustomFeeConfig function instead of having to implement this through a more gas-consuming contract upgrade.  Further, in the L1{CustomERC20|ERC721|ERC1155}Gateway, the owner can update the token mapping of L1 to L2 contracts. However, this mapping is not resettable back to address zero to prevent depositing or withdrawing such tokens in cases of deprecation or scams. As such, consider allowing the mapping to be set to zero.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#no-function-to-remove-a-custom-setting", "labels": ["OpenZeppelin"]}, {"title": "SimpleGasOracle Is Not Used", "body": "The SimpleGasOracle contract does not find any utility in the rest of the codebase and appears to be obsolete. Consider removing it.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be deleted later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#simplegasoracle-is-not-used", "labels": ["OpenZeppelin"]}, {"title": "Token Counterpart Address in WETH Gateway Can Be Misleading", "body": "To align with the inherited L1 and L2 ERC-20 gateway interfaces, the WETH gateways ([1], [2]) implement functions to fetch the L1 and L2 token counterparts as getL1ERC20Address and getL2ERC20Address. But, since the WETH gateway only interacts with one token on each layer, these functions just return the hardcoded address regardless of what token is queried through the function parameter.  This could cause confusion since only one L1 WETH token maps the L2 token and vice versa. However, the function could suggest that other tokens also fulfill this mapping.  Even though the protocol expects users to interact with the gateways by calling the L1GatewayRouter contract, it is possible for users to bypass this contract and reduce the gas cost. For that reason, consider returning the zero address if the queried token does not match the WETH token of the respective layer.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#token-counterpart-address-in-weth-gateway-can-be-misleading", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "Throughout the codebase there are multiple instances of typographical errors:  \"called by a list of validator\" should be \"called by a list of validators\".  \"choosen\" [1] [2] should be \"chosen\".  \"return true is\" should be \"return true if\"  \"The the\" [1] [2] should be \"The\".  \"Return the message of in queueIndex\" should be \"Return the message at `queueIndex`.  \"All deposited Ether (including WETH deposited throng L1WETHGateway) will locked in this contract.\" should be \"through\" and \"will be locked\".  \"transfered\" should be \"transferred\" (throughout the whole codebase).  \"recieve\" should be \"receive\".  \"addess\" should be \"address\".  \"malicous\" should be \"malicious\".  \"continous\" should be \"continuous\".  Consider fixing these and any other typographical errors to improve the readability of the codebase.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unintuitive Bitmap Ordering and Type for Skipped Messages", "body": "In the ScrollChain contract, as a new batch is committed, L1 messages can be skipped from being included in the batch. The indication of whether a message should be skipped or not is realized through a bitmap of type bytes. However, the dynamic bytes type is expected to have a length of k words. Thus, a bytes32[] array would be a more suitable type for this parameter.  Further, while the bytes value is processed from left to right as words, the bits are processed from right to left, giving an unintuitive ordering of skipped messages.  Consider sticking to a dynamic bytes value of arbitrary length that is processed from left to right, or changing the type to a bytes32 array.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#unintuitive-bitmap-ordering-and-type-for-skipped-messages", "labels": ["OpenZeppelin"]}, {"title": "WETH Is Passed as a Parameter", "body": "The WETH address is being passed as a parameter in the constructor of the L1WETHGateway contract. However, as the address could be considered a constant in the ecosystem, consider hard-coding the address with a constant variable in the implementation to decrease the likelihood of errors when deploying the contract.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#weth-is-passed-as-a-parameter", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "Throughout the codebase, there are imports that are unused and could be removed. For instance:  Import ProxyAdmin of External.sol  Import TransparentUpgradeableProxy of External.sol  Import AddressAliasHelper of L1ScrollMessenger.sol  Import IL2GatewayRouter of L1GatewayRouter.sol  Import IScrollGateway of L1GatewayRouter.sol  Import IL1ScrollMessenger of L1GatewayRouter.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused Named Return Variable", "body": "Named return variables are a way to declare variables that are meant to be used within a function's body for the purpose of being returned as the function's output. They are an alternative to explicit in-line return statements.  In ScrollStandardERC20.sol, there are two instances of unused named return variables:  The success return variable in the transferAndCall function  The hasCode return variable in the isContract function  Consider using or removing any unused named return variables. Moreover, consider keeping a consistent style throughout the codebase regarding the usage of named return variables.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#unused-named-return-variable", "labels": ["OpenZeppelin"]}, {"title": "Use Custom Errors", "body": "Throughout the codebase, the code makes use of require statements with error strings to describe the reasons for reverting.  However, since Solidity version 0.8.4, custom errors provide a cleaner and more cost-efficient way to explain to users why an operation failed versus using require and revert statements with custom error strings.  For better conciseness, consistency, and gas savings, consider replacing hard-coded require and revert messages with custom errors.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#use-custom-errors", "labels": ["OpenZeppelin"]}, {"title": "Variable Name Inconsistency", "body": "Throughout the codebase, some variables referring to the same matter have different names. For instance, the ScrollChain contract address in the L1ScrollMessenger contract is named rollup, while in the L1MessageQueue contract, it is scrollChain.  For better readability, consider giving variables the same name if they refer to the same contract.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#variable-name-inconsistency", "labels": ["OpenZeppelin"]}, {"title": "Client-Reported", "body": "Client-Reported", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#client-reported", "labels": ["OpenZeppelin"]}, {"title": "Missing Chain ID Allows Reuse of Proofs", "body": "Missing Chain ID Allows Reuse of Proofs", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#missing-chain-id-allows-reuse-of-proofs", "labels": ["OpenZeppelin"]}, {"title": "Recommendations", "body": "Conclusion  Summary  ZK Rollup  From 2023-05-15  To 2023-06-23  Solidity  39 (16\u202fresolved, 1\u202fpartially\u202fresolved)  0 (0\u202fresolved)  7 (5\u202fresolved, 1\u202fpartially\u202fresolved)  3 (3\u202fresolved)  10 (7\u202fresolved)  18 (0\u202fresolved)  1 (1\u202fresolved)  Scope  We audited the scroll-tech/scroll repository at the 3bc8a3f commit of the develop branch.  In scope were the following contracts:  Scroll's architecture and code structure draw inspiration from other Layer 2 solutions like Arbitrum and Optimism, particularly in the design of their gateways, predeploys, and messaging contracts. Notably, a lot of code structure from Arbitrum's gateways and the AddressAliasHelper.sol contract are reused with minor modifications.  The primary focus of this audit was on the Scroll Rollup and Bridge Contracts. In this audit, we aimed to verify the correctness and security of the contracts, focusing on aspects like block finalization, message passing, and the process of depositing and withdrawing into/from the rollup.  Update: It is important to note that the develop branch changed the codebase between the audit's start and the fix review. Hence, we only reviewed the fixes in their respective context and cannot guarantee other implications that were introduced in the meantime.  System Overview  Scroll is an EVM-equivalent zk-Rollup designed to be a scaling solution for Ethereum. It achieves this by interpreting EVM bytecode directly at the bytecode level, following a similar path to projects like Polygon zkEVM and ConsenSys' Linea.  This report presents our findings and recommendations for the Scroll zk-Rollup protocol. In the following sections, we will discuss these aspects in detail. We urge the Scroll team to consider these findings in their ongoing efforts to provide a secure and efficient Layer 2 solution for Ethereum.  Architecture  The system's architecture is split into three main components:  Scroll Node: This constructs Layer 2 (L2) blocks from user transactions, commits these transactions to the Ethereum base layer, and handles message passing between L1 and L2.  Roller Network: This component is responsible for generating the zkEVM validity proofs, which are used to prove that transactions are executed correctly.  Rollup and Bridge contracts: These contracts provide data availability for Scroll transactions, verify zkEVM validity proofs, and allow users to move assets between Ethereum and Scroll. Users can pass arbitrary messages between L1 and L2, and can bridge assets in either direction thanks to the Gateway contracts.  Rollup and Bridging  The Scroll system connects to Ethereum primarily through its Rollup and Messenger contracts. The Rollup contract is responsible for receiving L2 state roots and blocks from the Sequencer, and finalizing blocks on Scroll once their validity is established.  The Messenger contracts enable users to pass arbitrary messages between L1 and L2, as well as bridge assets in both directions. The gateway contracts make use of the messages to operate on the appropriate layer.  The standard ERC-20 token bridge automatically deploys tokens on L2, using a standardized token implementation. There is also a custom token bridge which enables users to deploy their L1 token on L2 for more sophisticated cases. In such scenarios, the Scroll team would need to manually set the mapping for these tokens. This could potentially lead to double-minting on L2 (two tokens being created, one through each method). To prevent such a scenario, it is recommended to use the GatewayRouter, which will route the token to the correct gateway.  State of Refunds  When communicating/bridging from L1 to L2, values are handled in two ways on the L1 side:  If a token is bridged, the token will be held by the gateway contract. If ETH is transferred, the value is kept in the L1 messenger contract. In the case of WETH, the assets will be first unwrapped to ETH and forwarded to be held by the L1 messenger contract.  The user has to specify a gas limit that will be used for the L2 transaction. The relayer accounts for this gas limit through a fee that is deducted on the L1 call.  In the audited version of the protocol there is no refund mechanism for (1) if the L1 initialized message is not provable (or censored) and hence not executed and skipped from the L1 message queue. There is no refund either when a transaction is provable but reverts on L2. This means assets can potentially get stuck in the Gateway or L1 messenger contracts. Regarding (2), any gas limit in excess of the required amount is paid as an extra fee into the fee vault. It is therefore crucial for users to make their best estimations through the l2geth API. For technical details please see Lack of Refunds.  Trust Assumptions  During the course of the audit, several assumptions about the Scroll protocol were considered to be inherently trusted. These assumptions and the context surrounding them include:  EVM node and relayer implementation: It is assumed that the EVM node impl", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#recommendations", "labels": ["OpenZeppelin"]}, {"title": "ERC-20 Factory Design", "body": "Tokens can be bridged in a custom and standard way. For the latter, the ScrollStandardERC20 is the default implementation that will represent the L1 token on L2. This is realized with the Clones library and the EIP-1167 standard. It works by deploying a minimal proxy that delegates its calls into the token implementation and that is initialized as the token instance.  These standard tokens are not upgradeable, which comes with a trade-off. On the one hand, it is more secure since the logic can not be changed. On the other hand, it is less future-proof meaning that standards like ERC-677 - which is not a finalized EIP - might at some point be overruled by a new standard that finds mass adoption.  An alternative future-proof factory design would be the Beacon proxy pattern. In a similar approach, the BeaconProxy will be the token instance, but then fetches the implementation contract to delegate into from a single UpgradeableBeacon contract. This enables upgrading all tokens in one transaction.  Regarding the security implications of upgradeable contracts, it is crucial to have the UpgradeableBeacon secured through a timelock, multisig, and cold wallets.  Update: Acknowledged. The Scroll team stated:  For safety concerns, we prefer the contract to be non-upgradeable.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#erc-20-factory-design", "labels": ["OpenZeppelin"]}, {"title": "ERC-165 Support", "body": "While most of the codebase includes custom contracts which do not implement a specific standard, the ScrollStandardERC20 contract is implementing the ERC-20 and ERC-677 standards. As such, it makes sense to also add ERC-165 support to it to enable other parties to identify its interface and the standard it implements.  Update: Acknowledged. The Scroll team stated:  Makes sense, we will support it if we have time.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#erc-165-support", "labels": ["OpenZeppelin"]}, {"title": "Testing Coverage", "body": "Due to the complex nature of the system, we believe this audit would have benefitted from more complete testing coverage.  While insufficient testing is not necessarily a vulnerability, it implies a high probability of additional hidden vulnerabilities and bugs. Given the complexity of this codebase and the numerous interrelated risk factors, this probability is further increased. Testing provides a full implicit specification along with the expected behaviors of the codebase, which is especially important when adding novel functionalities. A lack thereof increases the chances that correctness issues will be missed. It also results in more effort to establish basic correctness and increases the effort spent exploring edge cases, thereby increasing the chances of missing complex issues.  Moreover, the lack of repeated automated testing of the full specification increases the chances of introducing breaking changes and new vulnerabilities. This applies to both previously audited code and future changes to current code. This is particularly true in this project due to the pace, extent, and complexity of ongoing and planned changes across all parts of the stack (L1, L2, relayer, and zkEVM). Under-specified interfaces and assumptions increase the risk of subtle integration issues, which testing could reduce by enforcing an exhaustive specification.  We recommend implementing a comprehensive multi-level test suite consisting of contract-level tests with more than 90% coverage, per-layer deployment and integration tests that test the deployment scripts as well as the system as a whole, per-layer fork tests for planned upgrades and cross-chain full integration tests of the entire system. Crucially, the test suite should be documented in a way so that a reviewer can set up and run all these test layers independently from the development team. Some existing examples of such setups can be suggested for use as reference in a follow-up conversation. Implementing such a test suite should be a very high priority to ensure the system's robustness and reduce the risk of vulnerabilities and bugs.  Update: Acknowledged. The Scroll team stated:  More tests will be added later.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#testing-coverage", "labels": ["OpenZeppelin"]}, {"title": "Monitoring Recommendations", "body": "While audits help in identifying code-level issues in the current implementation and potentially the code deployed in production, the Scroll team is encouraged to consider incorporating monitoring activities in the production environment. Ongoing monitoring of deployed contracts helps identify potential threats and issues affecting production environments. With the goal of providing a complete security assessment, the monitoring recommendations section raises several actions addressing trust assumptions and out-of-scope components that can benefit from on-chain monitoring.  Governance  Critical: There are several important contracts that use the Proxy Pattern and can be arbitrarily upgraded by the proxy owner. Consider monitoring for upgrade events on at least the following contracts:  ScrollChain  L1ScrollMessenger  Gateway contracts  Access Control  Critical: Ownable allows implementing access control to prevent unauthorized parties making unintended changes, but it is important to monitor for events where the owner changes. Consider monitoring for the OwnershipTransferred event on all ownable contracts such as ScrollChain and L1MessageQueue.  Technical  High: The rollup contract contains sensitive functions that should be called only by the owner. Consider monitoring if any of the following events are emitted.  UpdateSequencer  UpdateProver  UpdateVerifier  Medium: The L1ScrollMessenger contract includes a mechanism for pausing in case of an incident. Consider monitoring for the Paused since an unexpected pause may cause a disruption in the system.  Financial  Medium: Consider monitoring the size, cadence and token type of bridge transfers during normal operations to establish a baseline of healthy properties. Any large deviation, or unexpectedly large withdrawals may indicate unusual behavior of the contracts or an ongoing attack.  Update: Acknowledged. The Scroll team stated:  It is on our roadmap. We will have one before mainnet launch.", "html_url": "https://blog.openzeppelin.com/scroll-phase-1-audit#monitoring-recommendations", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Storage Slot Calculations", "body": "L2ScrollMessenger contract, the functions  verifyMessageInclusionStatus and  verifyMessageExecutionStatus use assembly code to manually calculate the storage slot for mappings  ScrollMessengerBase uses 4 storage slots instead of 3.  This would make both functions verifyMessageInclusionStatus and verifyMessageExecutionStatus unusable, which would prevent the contract from verifying inclusion or execution status for messages. Furthermore, the function retryMessageWithProof relies on verifyMessageInclusionStatus, and therefore failed messages on L2 could not be retried.  Consider fixing the calculation and thoroughly documenting any changes to the storage layout of ScrollMessengerBase and L1ScrollMessenger. Furthermore, consider moving these hard-coded values in the assembly code into a separate \"constants\" file to reduce the number of failure points in the case of future changes.  Update: Resolved in pull request #558 at commit 94db3ab and in pull request #618 at commit 2395883. The assembly code was updated with the correct magic constants for storage slot lookups. The values were not placed into a separate constants file, but the Scroll team stated:  We decided to remove the retry in the Layer 2 logic. The code related to the storage slot will also be deleted.  Medium Severity", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#incorrect-storage-slot-calculations", "labels": ["OpenZeppelin"]}, {"title": "L2MessageQueue Stores Incorrect Value if not Initialized Before Appending", "body": "zeroHashes array. If however, it is not,  appendMessage can still be called. On the 5th message sent, the wrong Merkle tree will be calculated (since at that point the calculation starts using the  Fortunately, appendMessage can only be called by the messenger, which makes this scenario unlikely.  Consider adding a safeguard so that appendMessage cannot be called until initialize is called first.  Update: Resolved in pull request #630 at commit 89814bd.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#l2messagequeue-stores-incorrect-value-if-not-initialized-before-appending", "labels": ["OpenZeppelin"]}, {"title": "WETH9 Approval Can Be Front-Run", "body": "approve function which allows the  transferFrom to spend all the previously authorized tokens before being authorized the amount specified in the second  This is possible because L2 transactions are ordered by the L2 node based on gas price. This means that the malicious spender could transfer the original amount, and once this second approval transaction is confirmed, the spender could also transfer the second amount as well, rather than the approver's intent, which was only the second amount that was set. This is a well-known attack that is properly documented here.  While it is possible to avoid this problem by having every approver submit an approve transaction with the amount set to 0 prior to submitting another approve transaction with the newly desired amount, this is error-prone and gas-inefficient. Consider adding increaseAllowance and decreaseAllowance functions to atomically increase and decrease the allowance granted to the spender.  Update: Resolved in pull request #632 at commit 85850f1. The WETH9.sol file was removed and was instead replaced by a custom-made wrapper (WrappedEther.sol) that inherits from OpenZeppelin's ERC20Permit contract, which already has the increaseAllowance and decreaseAllowance methods implemented.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#weth9-approval-can-be-front-run", "labels": ["OpenZeppelin"]}, {"title": "Lack of Storage Gaps", "body": "The contract L2ERC20Gateway is being inherited by multiple upgradeable contracts.  Without adding a storage gap, new storage variables cannot be added to L2ERC20Gateway without causing a storage collision in all the contracts that inherit from it. This would cause contracts to malfunction and compromise their functionalities.  Consider adding a gap variable to future-proof base contract storage changes and be safe against storage collisions.  Update: Resolved in pull request #618 at commit 2395883.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#lack-of-storage-gaps", "labels": ["OpenZeppelin"]}, {"title": "Smart Contract Wallets Cannot Withdraw WETH", "body": "The predeployed WETH9 implementation uses transfer to unwrap WETH to ETH for a msg.sender. If users attempt to withdraw funds using a Smart Wallet that has any extra logic on the receive method, the transaction will run out of gas and fail. Users would then need to transfer the WETH to an EOA in order to unwrap their funds.  Consider using address.call{value: amount}(\"\") or the sendValue function of the OpenZeppelin Address library to provide them with enough gas to handle additional logic, as this is the recommended method to use. Thereby make sure to protect against reentrancy by following the check-effects-interactions pattern or adding a reentrancy guard.  Update: Resolved in pull request #558 at commit 0df7531 and in pull request #632 at commit 85850f1 by replacing WETH9.sol with WrappedEther.sol, which uses the call method.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#smart-contract-wallets-cannot-withdraw-weth", "labels": ["OpenZeppelin"]}, {"title": "Lack Of Expiration For Retrying Transactions", "body": "The L2ScrollMessenger contract provides a mechanism to retry failed transactions from L1 to L2 at any time. Therefore, if a user creates an L1 to L2 transaction and it fails, it can be retried indefinitely at a later time. A scenario could occur where a user erroneously sends an L1 to L2 transaction (such as transferring more L2 ETH than the user had intended), which fails at the L2 level. The user may be inclined to resend the transaction with the correct amount of L2 ETH, which would then succeed. However, because the first transaction has still persisted, a malicious recipient could retry the first transaction again with a higher gas limit, which would succeed, causing the sender to send more L2 ETH than intended.  More generally, if a transaction is sent from L1 to L2 and fails, it can be retried indefinitely at a later time. This may not align with the intention of a user. Consider adding a timeout mechanism for failed transactions, limiting the timeframe in which a failed transaction can be retried.  Update: Acknowledged, not resolved. The Scroll team stated:  It is related to the refund feature, so we don't support it for now.  Low Severity", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#lack-of-expiration-for-retrying-transactions", "labels": ["OpenZeppelin"]}, {"title": "Lack of Validation When Updating Maximum Failed Execution Tries", "body": "The L2ScrollMessenger contract provides a mechanism to limit the number of failed execution tries that a transaction may have. This limit can be changed with the function updateMaxFailedExecutionTimes. However, it is possible to set maxFailedExecutionTimes to zero, which could lead to a situation where no transactions can ever succeed, as they would immediately fail this requirement.  Consider enforcing that maxFailedExecutionTimes cannot be set to zero in the updateMaxFailedExecutionTimes function.  Update: Resolved in pull request #649 at commit 58ee807.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#lack-of-validation-when-updating-maximum-failed-execution-tries", "labels": ["OpenZeppelin"]}, {"title": "Missing Error Messages in require Statements", "body": "Within WETH9.sol there are multiple require statements that lack error messages. For instance:  The require statement on line 48  The require statement on line 80  The require statement on line 83  Consider including specific, informative error messages in require statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied.  Update: Resolved in pull request #632 at commit 85850f1. The WETH9.sol file was removed and was instead replaced by a custom-made wrapper (WrappedEther.sol) that inherits from OpenZeppelin's ERC20Permit contract, which does have such revert messages.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#missing-error-messages-in-require-statements", "labels": ["OpenZeppelin"]}, {"title": "Unsafe ABI Encoding", "body": "Throughout the codebase there are several occurrences of unsafe ABI encodings through the use of abi.encodeWithSelector. It is not an uncommon practice to use either abi.encodeWithSignature or abi.encodeWithSelector to generate this calldata. However, the first option is not typo-safe and the second option is not type-safe. The result is that both of these methods are error-prone and should be considered unsafe. These occurrences are outlined below:  On line 132 of L2CustomERC20Gateway.sol  On line 173 of L2ERC1155Gateway.sol  On line 216 of L2ERC1155Gateway.sol  On line 166 of L2ERC721Gateway.sol  On line 205 of L2ERC721Gateway.sol  On line 100 of L2ETHGateway.sol  On line 144 of L2StandardERC20Gateway.sol  On line 124 of L2WETHGateway.sol  bug detected regarding fixed-length bytes literals. Using an updated version will remove the possibility of future errors. In order to perform this safe encoding, consider upgrading all contracts from  Update: Acknowledged, will resolve. The Scroll team stated:  This issue was also reported in the Layer 1 report (N-02 Error-Prone Call Encoding). This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#unsafe-abi-encoding", "labels": ["OpenZeppelin"]}, {"title": "Initialization Not Disabled for Implementation Contracts", "body": "Throughout the codebase, implementation contracts are used behind proxies for upgradeability. Hence, many contracts have an initialize function that sets up the proxy. It is a good practice to not leave implementation contracts uninitialized, hence, consider calling _disableInitializers of the inherited Initializable contract from the constructor to prevent initialization of the implementation contract.  Update: Resolved in pull request #639 at commit d1b7719. It is worth noting that the SimpleGasOracle contract has not been fixed. The Scroll team stated:  The SimpleGasOracle contract is not being used anymore, we are considerting its removal at a later time.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#initialization-not-disabled-for-implementation-contracts", "labels": ["OpenZeppelin"]}, {"title": "Lack of Event Emissions", "body": "Throughout the codebase, several instances were identified where events should be emitted.  When Whitelist is deployed, the owner is set by the constructor. Because owner is not set using _transferOwnership, the OwnershipTransferred event is not emitted.  The updateMessenger function does not emit an event upon the successful update of the L2ScrollMessenger address.  The L2GatewayRouter does not emit an event when setting defaultERC20Gateway in the initialize function.  Consider emitting the OwnershipTransferred event, as well as an event when the address of the L2ScrollMessenger gets updated on the L2MessageQueue contract. Furthermore, consider emitting the SetERC20Gateway event when the L2GatewayRouter is initialized. Emitting events provides a way for external integrations to track changes being made to the contract configuration by external integrations. This is especially important for monitoring operations and proper incident response, particularly with regard to trusted entities with special privileges.  Update: Resolved in pull request #650 at commit 90cf7b7.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#lack-of-event-emissions", "labels": ["OpenZeppelin"]}, {"title": "Initialization Performed Outside of Initialization Function", "body": "The updateMessenger function in L2MessageQueue can only be called before any message is appended, otherwise it will revert since nextMessageIndex is sequentially increased. Therefore, the updateMessenger logic aligns closer with the purpose of the initialize function, rather than a standalone function.  Consider moving the logic of updateMessenger into the initialize function with the onlyOwner modifier. This can be done since the predeployed contracts should exist before L2ScrollMessenger.  Update: Resolved in pull request #652 at commit dd9d880.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#initialization-performed-outside-of-initialization-function", "labels": ["OpenZeppelin"]}, {"title": "Block Container Does Not Enforce Whitelist", "body": "In the L1BlockContainer contract, the importBlockHeader function can be called by anyone if the whitelist address has not been initialized.  The block container contract is used to check the state root when doing an inclusion proof in the verifyMessage{Inclusion|Execution}Status function. Hence, an attacker can determine which messages are seen as sent or executed on L1. Although the attacker cannot relay or retry any message on L2 because they are not the L1ScrollMessenger address, they can overwrite the state root to make retry messages fail.  Consider preventing the importBlockHeader function to be called if the whitelist address is zero.  Update: Resolved in pull request #651 at commit 6959d82.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#block-container-does-not-enforce-whitelist", "labels": ["OpenZeppelin"]}, {"title": "Typos In Comments", "body": "Throughout the codebase, there are some instances of typos in comments and docstrings. Some examples are:  line 11 of IL2ERC1155Gateway.sol transfered should be transferred.  line 11 of IL2ERC721Gateway.sol transfered should be transferred.  line 19 of L2ERC721Gateway.sol transfered should be transferred.  line 27 of L2GatewayRouter.sol addess should be address.  line 22 of L2StandardERC20Gateway.sol transfered should be transferred.  line 20 of L2WETHGateway.sol transfered should be transferred.  line 251 of L1BlockContainer.sol vaules should be values.  Consider updating the lines identified above. Furthermore consider applying an automated spelling and grammar checker to your codebase to identify further instances.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#typos-in-comments", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "Throughout the codebase the following imports are unused and could be removed:  Import IL1GasPriceOracle of L2ScrollMessenger.sol  Import IERC20Upgradeable of L2CustomERC20Gateway.sol  Import IL2ERC20Gateway of L2CustomERC20Gateway.sol  Import IScrollGateway of L2CustomERC20Gateway.sol  Import IERC1155Upgradeable of L2ERC1155Gateway.sol  Import IScrollGateway of L2ERC1155Gateway.sol  Import IERC721Upgradeable of L2ERC721Gateway.sol  Import IScrollGateway of L2ERC721Gateway.sol  Import IL2ScrollMessenger of L2GatewayRouter.sol  Import IL1ETHGateway of L2GatewayRouter.sol  Import IScrollGateway of L2GatewayRouter.sol  Import IL2ERC20Gateway of L2StandardERC20Gateway.sol  Import IScrollGateway of L2StandardERC20Gateway.sol  Import IScrollGateway of L2WETHGateway.sol  Import IL1BlockContainer of L1GasPriceOracle.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused or Unnecessary Code", "body": "Through the codebase, there are instances of variables that are not used or code that is unnecessary:  In ScrollGatewayBase it states that the address of router could be zero, if this contract is GatewayRouter. However the L2GatewayRouter contract doesn't inherit from ScrollGatewayBase. Therefore, it would be possible to remove this line and this line and move the require statement to ScrollGatewayBase.  In L2ScrollMessenger, the immutable variable gasOracle is never used.  Consider removing unnecessary code and unused variables to have a cleaner and more readable codebase. This helps keep the code readable which can help avoid bugs and reduce the attack surface in any future development.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#unused-or-unnecessary-code", "labels": ["OpenZeppelin"]}, {"title": "Use Custom Errors", "body": "Throughout the codebase, the code makes use of require statements with error strings (i.e., this line of code) to describe the reason of a reversion.  However, since Solidity version 0.8.4, custom errors provide a cleaner and more cost-effective way to explain to users why an operation failed versus using require and revert statements with custom error strings.  To improve conciseness, consistency, and obtain gas savings, consider replacing hard-coded require and revert messages with custom errors.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#use-custom-errors", "labels": ["OpenZeppelin"]}, {"title": "Events Split Between Contracts and Interfaces", "body": "Throughout the codebase, events are placed both in contracts and interfaces. It is using the pattern where events on authorized actions are placed in the contract while user-relevant events are placed in the interface, which harms the readability. Consider moving the events from the contracts to their respective interfaces for clarity. Furthermore, to facilitate monitoring capabilities, which rely on checking events, it is easier to compile the interfaces and obtain their ABI when they are all located in a single place.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#events-split-between-contracts-and-interfaces", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Documentation", "body": "The following instances of incorrect documentation have been identified:  The comment on line 43 in the L2ScrollMessenger contract incorrectly states that the gasOracle address variable contains the address for the contract L2MessageQueue.  The comment on line 94 in L2ETHGateway should say L2GatewayRouter instead of L1GatewayRouter.  The comment on line 112 in L2WETHGateway should say L2GatewayRouter instead of L1GatewayRouter.  The comment on line 28 in L2ERC721Gateway should say _l2Token instead of _l1Token.  The comment on line 9 in L2MessageQueue contains a broken link.  The require message on line 144 in L2GatewayRouter should say \"no eth gateway available\".  Consider resolving these instances of incorrect documentation to improve the clarity and readability of the codebase.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#incorrect-documentation", "labels": ["OpenZeppelin"]}, {"title": "Unused Return Value", "body": "The L2ScrollMessenger contract calls the function appendMessage in L2MessageQueue which returns _currentRoot. However, the return value is not used, and this function is only used by L2ScrollMessenger.  Consider removing the return value of the function appendMessage if it is not intended to be used.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#unused-return-value", "labels": ["OpenZeppelin"]}, {"title": "Gas Optimizations", "body": "Throughout the codebase there are multiple instances where gas costs can be optimized:  In line 30 of Whitelist, _accounts.length is calculated for every iteration of the loop. Consider using a local variable to store the value of _accounts.length and use that in the for loop instead.  In line 203 of L2GatewayRouter, _tokens.length is calculated for every iteration of the loop. Consider using a local variable to store the value of _tokens.length and use that in the for loop instead.  In line 51 of L2StandardERC20Gateway, the require statement checks if the address of _tokenFactory is equal to 0. This is done after the call to ScrollGatewayBase._initialize. Consider moving this require check prior to the _initialize call.  In the retryMessageWithProof function of L2ScrollMessenger, it checks to see if the number of failed times has exceeded the maximum amount. In the event of successful execution, consider setting the storage slot of l1MessageFailedTimes[_xDomainCalldataHash] to 0 after for a gas refund.  In L2ScrollMessenger, the _lock_status is a state variable. The modifier nonReentrant uses the value of _ENTERED and _NOT_ENTERED as 1 and 2, but the _lock_status value is never set to _NOT_ENTERED in the initializer. Consider setting this _lock_status to the value of _NOT_ENTERED in the initializer to save on gas on the call to the modifier.  In a previous version of the code, some users had to pay a fee on L2 to relay their message to L1. The architecture has now moved to Merkle Proofs for the user to prove message inclusion without relying on the relayer. However, there is still some code left from before that isn't used anymore. Consider removing the remaining feeVault and several _gasLimit parameters on L2 to save on gas.  During the initialization of the L2ScrollMessenger contract, the xDomainMessageSender variable is set a second time after the _initialize function of the base contract. Consider setting this variable only once in order to save gas.  Consider applying the above changes to improve gas consumption.  Update: Acknowledged, will resolve. The Scroll team stated:  This is not a priority at the time. It will be addressed later on.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "Naming Suggestions", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Recommendations", "body": "Conclusion  Summary  zkEVM-based zkRollup, Bridge & Rollup  From 2023-06-05  To 2023-06-30  Solidity  22 (11\u202fresolved)  0 (0\u202fresolved)  1 (1\u202fresolved)  5 (4\u202fresolved)  7 (6\u202fresolved)  9 (0\u202fresolved)  Scope  We audited the scroll-tech/scroll repository at the 3bc8a3f commit.  Scroll's architecture and code structure draw inspiration from other Layer 2 solutions such as Arbitrum and Optimism, particularly in the design of their gateways, predeploys, and messaging contracts. Notably, a lot of code structure from Arbitrum's gateways and the AddressAliasHelper.sol contract is reused with minor modifications.  The primary focus of this audit was on the Scroll L2 Bridge Contracts. In this audit, we aimed to verify the correctness and security of the contracts, focusing on aspects like block finalization, message passing, and the process of depositing and withdrawing.  Update: It is important to note that the develop branch changed the codebase between the audit's start and the fix review. Hence, we only reviewed the fixes in their respective context and cannot guarantee other implications that were introduced in the meantime.  System Overview  Scroll is an EVM-equivalent zk-Rollup designed to be a scaling solution for Ethereum. It achieves this by interpreting EVM bytecode directly at the bytecode level, following a similar path to projects like Polygon zkEVM and ConsenSys' Linea.  This report presents our findings and recommendations for the Scroll zk-Rollup protocol. In the following sections, we will discuss these aspects in detail. We urge the Scroll team to consider these findings in their ongoing efforts to provide a secure and efficient Layer 2 solution for Ethereum.  Architecture  The system's architecture is split into three main components:  Scroll Node: This constructs Layer 2 (L2) blocks from user transactions, commits these transactions to the Ethereum base layer, and handles message passing between L1 and L2.  Roller Network: This component is responsible for generating the zkEVM validity proofs, which are used to prove that transactions are executed correctly.  Rollup and Gateway contracts: These contracts provide data availability for Scroll transactions, verify zkEVM validity proofs, and allow users to move assets between Ethereum and Scroll. Users can pass arbitrary messages between L1 and L2, and can bridge assets in either direction due to the Gateway contracts.  Rollup and Bridging  The Scroll system connects to Ethereum primarily through its Rollup and Messenger contracts. The Rollup contract is responsible for receiving L2 state roots and blocks from the Sequencer, and finalizing blocks on Scroll once their validity is established.  The Messenger Contracts enable users to pass arbitrary messages between L1 and L2, as well as bridge assets in both directions. The gateway contracts make use of the messages to operate on the appropriate layer.  The standard ERC-20 token gateway automatically deploys tokens on L2, using a standardized token implementation. There is also a custom token gateway which enables users to deploy their L1 token on L2, in more sophisticated cases. In such scenarios, the Scroll team would need to manually set the mapping for these tokens. This could potentially lead to double-minting on L2 (two tokens being created, one through each method). To prevent such a scenario, it is recommended to use the GatewayRouter, which will route the token to the correct gateway. These custom gateways are also required for ERC-721 and ERC-1155 tokens, which currently do not have a standard gateway provided. However, the GatewayRouter does not currently support ERC-721 or ERC-1155 custom gateways.  State of Refunds  When communicating/bridging from L1 to L2, values are handled in two ways on the L1 side:  If a token is bridged, the token will be transferred into the gateway contract. If ETH is transferred, the value is kept in the L1 messenger contract. In the case of WETH, the assets will be first unwrapped to ETH and forwarded to the L1 messenger contract.  The user has to specify a gas limit that will be used for the L2 transaction. The relayer accounts for this gas limit through a fee that is deducted on the L1 call.  In the audited version of the protocol, there is no refund mechanism for (1) if the L1 initialized message is not provable (or censored) and hence not executed and removed from the L1 message queue. This means assets can potentially get stuck in the Gateway or L1 messenger contracts. Regarding (2), any excessive gas limit over the required amount is paid as an extra fee into the fee vault. It is therefore crucial for users to make their best estimations through the l2geth API.  Trust Assumptions  During the course of the audit, several assumptions about the Scroll protocol were considered to be inherently trusted. These assumptions and the context surrounding them include:  EVM node and relayer implementation: It is assumed that the EVM node implementation will work as des", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#recommendations", "labels": ["OpenZeppelin"]}, {"title": "ERC-20 Factory Design", "body": "Tokens can be bridged in a custom and standard way. For the latter, the ScrollStandardERC20 is the default implementation that will represent the L1 token on L2. This is realized with the Clones library and the EIP-1167 standard. It works by deploying a minimal proxy that delegates its calls into the token implementation and that is initialized as the token instance.  These standard tokens are not upgradeable, which comes with a trade-off. On the one hand, it is more secure since the logic cannot be changed. On the other hand, it is less future-proof meaning that standards like ERC-677 - which is not a finalized EIP - might at some point be overruled by a new standard that finds mass adoption.  An alternative factory design that is future-proof would be the Beacon proxy pattern. In a similar approach the BeaconProxy will be the token instance, but then fetches the implementation contract to delegate into from a single UpgradeableBeacon contract. This allows upgrading all tokens in one transaction.  Regarding the security implications of upgradeable contracts it is crucial to have the UpgradeableBeacon secured through a timelock, multisig, and cold wallets.  Update: Acknowledged. The Scroll team stated:  For safety concerns, we prefer the contract to be non-upgradeable.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#erc-20-factory-design", "labels": ["OpenZeppelin"]}, {"title": "ERC-165 Support", "body": "While most of the codebase is comprised of custom contracts which do not implement a specific standard, the ScrollStandardERC20 contract is implementing the ERC-20 and ERC-677 standards. As such, it makes sense to also add ERC-165 support to enable other parties to identify its interface and the standard it implements.  Update: Acknowledged. The Scroll team stated:  Makes sense, will support it if we have time.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#erc-165-support", "labels": ["OpenZeppelin"]}, {"title": "Testing Coverage", "body": "Due to the complex nature of the system, we believe this audit would have benefitted from more complete testing coverage.  While insufficient testing is not necessarily a vulnerability, it implies a high probability of additional hidden vulnerabilities and bugs. Given the complexity of this codebase and the numerous interrelated risk factors, this probability is further increased. Testing provides a full implicit specification along with the expected behaviors of the codebase, which is especially important when adding novel functionalities. A lack thereof increases the chances that correctness issues will be missed. It also results in more effort to establish basic correctness and reduces the effort spent exploring edge cases, thereby increasing the chances of missing complex issues.  Moreover, the lack of repeated automated testing of the full specification increases the chances of introducing breaking changes and new vulnerabilities. This applies to both previously audited code and future changes to current code. This is particularly true in this project due to the pace, extent, and complexity of ongoing and planned changes across all parts of the stack (L1, L2, relayer, and zkEVM). Underspecified interfaces and assumptions increase the risk of subtle integration issues, which testing could reduce by enforcing an exhaustive specification.  We recommend implementing a comprehensive multi-level test suite consisting of contract-level tests with >90% coverage, per-layer deployment and integration tests that test the deployment scripts as well as the system as a whole, per-layer fork tests for planned upgrades and cross-chain full integration tests of the entire system. Crucially, the test suite should be documented in a way so that a reviewer can set up and run all these test layers independently of the development team. Some existing examples of such setups can be suggested for use as reference in a follow-up conversation. Implementing such a test suite should be a very high priority to ensure the system's robustness and reduce the risk of vulnerabilities and bugs.  Update: Acknowledged. The Scroll team stated:  More tests will be added later.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#testing-coverage", "labels": ["OpenZeppelin"]}, {"title": "Custom Gateway Contracts", "body": "Developers who need to use custom gateway contracts should ensure that their contracts are designed to allow for the burning of tokens and the creation of the same tokens with the same id. This is particularly relevant for non-fungible tokens (NFTs) and other unique asset types that rely on the token id for maintaining uniqueness.  The burning of tokens on one layer (L1 or L2) and the subsequent creation of the same tokens on the other layer is a crucial feature for token bridging in layer 2 solutions like Scroll. However, most NFT contracts are designed to create new tokens with a sequential counter, which makes them incompatible with this requirement.  Ensure providing adequate documentation, and if possible code examples, so that developers in the Scroll ecosystem can properly implement these requirements.  Update: Acknowledged. The Scroll team stated:  We have refactored the interface required for ERC721/ERC1155 gateway. And also more examples will be added. Hopefully, it will be enough for developers.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#custom-gateway-contracts", "labels": ["OpenZeppelin"]}, {"title": "Monitoring Recommendations", "body": "While audits help in identifying code-level issues in the current implementation and potentially the code deployed in production, the Scroll team is encouraged to consider incorporating monitoring activities in the production environment. Ongoing monitoring of deployed contracts helps identify potential threats and issues affecting production environments. With the goal of providing a complete security assessment, the monitoring recommendations section raises several actions addressing trust assumptions and out-of-scope components that can benefit from on-chain monitoring.  Governance  Critical: There are several important contracts that use the Proxy Pattern and can be arbitrarily upgraded by the proxy owner. Consider monitoring for upgrade events on at least the following contracts:  L2ScrollMessenger  Gateway contracts  Access Control  Technical  Medium: The L2ScrollMessenger contract includes a mechanism for pausing in case of an incident. Consider monitoring for the Paused since an unexpected pause may cause a disruption in the system.  Financial  Medium: Consider monitoring the size, cadence and token type of bridge transfers during normal operations to establish a baseline of healthy properties. Any large deviation, such as an unexpectedly large withdrawal, may indicate unusual behavior of the contracts or an ongoing attack.  Update: Acknowledged. The Scroll team stated:  It is on our roadmap. Will have one before the mainnet launch.", "html_url": "https://blog.openzeppelin.com/scroll-phase-2-audit#monitoring-recommendations", "labels": ["OpenZeppelin"]}, {"title": " Issues", "body": "0 (0 resolved)  High Severity  0 (0\u202fresolved)  Medium Severity  5 (3 resolved)  Low Severity  2 (1 resolved)  Notes & Additional Information  5 (4 resolved, 1 partially resolved)  Scope  We audited the oceanprotocl/vw-cli repository at commit 0397c74.  System Overview  As the Ocean Protocol  migrates  to a more decentralized architecture, the  Splitter  and  VestingWalletHalving  contracts are intended to be utilities for setting up token cashflows  from the initial multisig wallet to the  DF Rewards  contracts and their respective stakeholders.  In a one-time transaction, Ocean tokens are intended to be transferred to a collection of vesting contracts with various vesting schedules. Over time, these vesting wallets will release funds into the payment splitter which will apportion the payment across the DF Rewards contracts.  The  VestingWalletHalving  contract is an implementation of the vesting wallet functionality of the protocol, based on a half-life formula. Its source code is substantially similar to the OpenZeppelin  implementation  of an abstract  VestingWallet  The Splitter contract implements the payment splitter functionality of the protocol. Its source code again hews closely to the OpenZeppelin implementation.  Security Model and Privileged Roles  When compared to their corresponding implementations by OpenZeppelin, both of these contracts have additional administrative functionalities accessible by their owners.  The owner of the Splitter contract can:  1. Add a payee at any point in time.       2. Remove a payee at any point in time.       3. Alter the shares of any payee at any point in time.  The owner of the VestingWalletHalving contract can:       1. Change the beneficiary address of the wallet at any point in time.        2. Remove all tokens from the contract at any point in time.  The administrative functionality creates substantial risk for the  payees  of the  Splitter  and  beneficiary  of the  VestingWalletHalving  contracts when compared to the immutable  and irrevocable implementations.  The development team has indicated that these administrative features are intended as contingencies and that ownership of both is to be renounced at some future point in time. For this reason, we have reduced the severity of the findings involving the administrative functions.  It should be noted, however, that as written, the contracts are not suitable for use between non-trusting counterparties. Cashflows into the DF Rewards contracts cannot, therefore, be considered trustless until ownership of the above contracts is renounced.  Medium Severity  Insufficient Input Validation for Vesting Schedule  The input arguments of the constructor are not sufficiently validated. Some problematic scenarios will arise from this, including:       \u2022 startTimestamp can be a timestamp that has already passed or is too far away in the              future.       \u2022 halfLife can be zero, causing the getAmount function to always revert.       \u2022 duration can be zero, allowing a user to instantly release all allocated tokens and Ether.  Consider adding sensible lower and upper bounds for all arguments of the constructor to ensure none of the outlined scenarios occur.  Update: Resolved in pull request #42 at commit a009de2.  Dust Is Paid to Last Payee in the _payees Array  Line 117 sets the payment variable to the remaining balance for the last address in the _payees array. While this keeps the rounded-down wei from remaining in the contract after a single payment, it also creates a fairness issue from the point of view of the other _payees.  Consider paying all payees balance * _shares[payee] / _totalShares.  Update: Resolved in pull request #44 at commit 822347b.  Owner of the Splitter Contract Can Dilute Existing Shareholders  The addPayee function of the Splitter contract allows the owner of the contract to unilaterally mint new shares to a new address. When unclaimed funds are present within the splitter, the existing shareholders are diluted by the administrative action.  When unclaimed funds are present within the splitter, the same holds true for the adjustShare function.  Consider developing an architecture where these administrative functions are not necessary. At a minimum, ensure that unreleased payments to pre-existing shareholders are not diluted by administrative actions.  Update: Acknowledged, not resolved. The Ocean Protocol team stated:  The existing shareholders are diluted by the administrative action. This aligns with our expectations, we would like the alterations to the shares to effectively apply to the unclaimed amount.  VestingWalletHalving Administrative Functions Ignore Previously Released Tokens  renounceVesting function in  splitter.sol, which will then release tokens to the respective incentive programs.  For example, if a long time has passed and the release function has never been called, there would be a large amount of tokens owed to the incentive programs. However, if an owner were to", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#-issues", "labels": ["OpenZeppelin"]}, {"title": "0 (0 resolved)", "body": "0 (0 resolved)", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#0-(0-resolved)", "labels": ["OpenZeppelin"]}, {"title": "Insufficient Input Validation for Vesting Schedule", "body": "The input arguments of the constructor are not sufficiently validated. Some problematic scenarios will arise from this, including:       \u2022 startTimestamp can be a timestamp that has already passed or is too far away in the              future.       \u2022 halfLife can be zero, causing the getAmount function to always revert.       \u2022 duration can be zero, allowing a user to instantly release all allocated tokens and Ether.  Consider adding sensible lower and upper bounds for all arguments of the constructor to ensure none of the outlined scenarios occur.  Update: Resolved in pull request #42 at commit a009de2.", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#insufficient-input-validation-for-vesting-schedule", "labels": ["OpenZeppelin"]}, {"title": "Dust Is Paid to Last Payee in the _payees Array", "body": "Line 117 sets the payment variable to the remaining balance for the last address in the _payees array. While this keeps the rounded-down wei from remaining in the contract after a single payment, it also creates a fairness issue from the point of view of the other _payees.  Consider paying all payees balance * _shares[payee] / _totalShares.  Update: Resolved in pull request #44 at commit 822347b.", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#dust-is-paid-to-last-payee-in-the-_payees-array", "labels": ["OpenZeppelin"]}, {"title": "Owner of the Splitter Contract Can Dilute Existing Shareholders", "body": "The addPayee function of the Splitter contract allows the owner of the contract to unilaterally mint new shares to a new address. When unclaimed funds are present within the splitter, the existing shareholders are diluted by the administrative action.  When unclaimed funds are present within the splitter, the same holds true for the adjustShare function.  Consider developing an architecture where these administrative functions are not necessary. At a minimum, ensure that unreleased payments to pre-existing shareholders are not diluted by administrative actions.  Update: Acknowledged, not resolved. The Ocean Protocol team stated:  The existing shareholders are diluted by the administrative action. This aligns with our expectations, we would like the alterations to the shares to effectively apply to the unclaimed amount.", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#owner-of-the-splitter-contract-can-dilute-existing-shareholders", "labels": ["OpenZeppelin"]}, {"title": "VestingWalletHalving Administrative Functions Ignore Previously Released Tokens", "body": "renounceVesting function in  splitter.sol, which will then release tokens to the respective incentive programs.  For example, if a long time has passed and the release function has never been called, there would be a large amount of tokens owed to the incentive programs. However, if an owner were to call renounceVesting, the incentive programs would not get paid what they are owed at that point in time.  The same can be said for changeBeneficiary, since the prior incentive programs will not be paid what they are owed before it is changed.  Consider an architecture and deployment strategy where these administrative functions are not necessary. At a minimum, consider changing renounceVesting and changeBeneificiary to first transfer vested tokens to the incentive program and only the remaining as a refund to the owner.  Update: Acknowledged, not resolved. The Ocean Protocol team stated:  The contract is not obligated to account for unpaid incentive programs and is designed to promptly return all funds back to the owner, so this is ok.", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#vestingwallethalving-administrative-functions-ignore-previously-released-tokens", "labels": ["OpenZeppelin"]}, {"title": "renounceVesting Does Not Return ETH", "body": "Currently, the  renounceVesting  function of the  VestingWalletHalving  contract only sweeps a single ERC-20 token and cannot return ETH to the owner. The  VestingWalletHalving  contract has the ability to handle both ERC-20 tokens and ETH. The contract also has a function called  renounceVesting  used by the owner to return a specific ERC-20 token and renounce vesting.  However, the function does not allow the owner to have any ETH returned upon renouncing. This would leave the ETH stuck in the contract until the end of the given schedule period.  Consider adding a variant implementation of renounceVesting that allows the owner to recover ETH.  Update: Resolved in pull request #40 at commit 543fb5c.  Low Severity", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#renouncevesting-does-not-return-eth", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings. For instance:  Line 210 of VestingWalletHalving.sol  Line 217 of VestingWalletHalving.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #53 at commit 11bbd7a.", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "The Caller of release Will Pay Gas Fees for All Payees", "body": "The  release  function of the  Splitter  contract iterates over the array of payees in order to disperse payments to each payee. This creates a fairness issue in the scenario where a  payee  is intended to call  release  .Consider allowing each payee to release their own payment.  Update: Acknowledged, not resolved. The Ocean Protocol team stated:  OPF is going to trigger reward distribution, this is fine.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#the-caller-of-release-will-pay-gas-fees-for-all-payees", "labels": ["OpenZeppelin"]}, {"title": "Non-Explicit Imports Are Used", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code, and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are used:  Line 5  of  VestingWalletHalving.sol  Line 6  of VestingWalletHalving.sol  Line 7  of VestingWalletHalving.sol  Line 8  of VestingWalletHalving.sol  Following the principle that clearer code is better code, consider using named import syntax ( import {A, B, C} from \"X\" ) to explicitly declare which contracts are being imported.  Update: Resolved in pull request #55 at commit 55a3e07.", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Lack of Indexed Event Parameters", "body": "Throughout the codebase, several events do not have their parameters indexed. For instance:  Line 20  of Splitter.sol  Line 27  of Splitter.sol  Line 30  of Splitter.sol  Consider indexing event parameters to improve the ability of off-chain services to search and filter for specific events.  Update: Resolved in pull request #50 at commit c6d6f5a.", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "constructor Is Payable But receive Raises an Error", "body": "Native  ETH  is not supported by the  Splitter  contract, but the  constructor  function of the  Splitter  contract is declared as  payable  . In addition, the  receive  function reverts with an error.  receive  functions that merely revert are redundant.  Consider removing the  payable  modifier from the  constructor  and deleting the  receive  function.  Update: Resolved in pull request #48 at commit 49a845b.", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#constructor-is-payable-but-receive-raises-an-error", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary require Checks in release Functions", "body": "The  release()  and  release(address)  functions of the  VestingWalletHalving  contract both contain a  require  check that asserts that the beneficiary of the wallet is not the zero address. These checks are unnecessary since both the  constructor  function and the setter that mutates the  _beneficiary  variable contain the check as well, ensuring that the variable can never be the zero address.  Consider removing the unnecessary require checks.  To avoid legal issues regarding copyright and follow best practices, consider adding SPDX license identifiers to files as suggested by the Solidity documentation.  Update: Resolved in pull request #46 at commit 1695bbf.", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#unnecessary-require-checks-in-release-functions", "labels": ["OpenZeppelin"]}, {"title": "VestingWalletHalving Currently Does Not Support All ERC-20 Tokens", "body": "VestingWalletHalving Currently Does Not Support All ERC-20 Tokens", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#vestingwallethalving-currently-does-not-support-all-erc-20-tokens", "labels": ["OpenZeppelin"]}, {"title": "Summary", "body": "Type  DeFi  Timeline  From 2023-09-19  To 2023-09-21  Languages  Solidity  Total Issues  12 (8 resolved, 1 partially resolved)  Critical Severity Issues  0 (0 resolved)  High Severity Issues  0 (0\u202fresolved)  Medium Severity Issues  5 (3 resolved)  Low Severity Issues  2 (1 resolved)  Notes & Additional Information  5 (4 resolved, 1 partially resolved)  Scope  We audited the oceanprotocl/vw-cli repository at commit 0397c74.  System Overview  As the Ocean Protocol  migrates  to a more decentralized architecture, the  Splitter  and  VestingWalletHalving  contracts are intended to be utilities for setting up token cashflows  from the initial multisig wallet to the  DF Rewards  contracts and their respective stakeholders.  In a one-time transaction, Ocean tokens are intended to be transferred to a collection of vesting contracts with various vesting schedules. Over time, these vesting wallets will release funds into the payment splitter which will apportion the payment across the DF Rewards contracts.  The  VestingWalletHalving  contract is an implementation of the vesting wallet functionality of the protocol, based on a half-life formula. Its source code is substantially similar to the OpenZeppelin  implementation  of an abstract  VestingWallet  The Splitter contract implements the payment splitter functionality of the protocol. Its source code again hews closely to the OpenZeppelin implementation.  Security Model and Privileged Roles  When compared to their corresponding implementations by OpenZeppelin, both of these contracts have additional administrative functionalities accessible by their owners.  The owner of the Splitter contract can:  1. Add a payee at any point in time.       2. Remove a payee at any point in time.       3. Alter the shares of any payee at any point in time.  The owner of the VestingWalletHalving contract can:       1. Change the beneficiary address of the wallet at any point in time.        2. Remove all tokens from the contract at any point in time.  The administrative functionality creates substantial risk for the  payees  of the  Splitter  and  beneficiary  of the  VestingWalletHalving  contracts when compared to the immutable  and irrevocable implementations.  The development team has indicated that these administrative features are intended as contingencies and that ownership of both is to be renounced at some future point in time. For this reason, we have reduced the severity of the findings involving the administrative functions.  It should be noted, however, that as written, the contracts are not suitable for use between non-trusting counterparties. Cashflows into the DF Rewards contracts cannot, therefore, be considered trustless until ownership of the above contracts is renounced.  Medium Severity  Insufficient Input Validation for Vesting Schedule  The input arguments of the constructor are not sufficiently validated. Some problematic scenarios will arise from this, including:       \u2022 startTimestamp can be a timestamp that has already passed or is too far away in the              future.       \u2022 halfLife can be zero, causing the getAmount function to always revert.       \u2022 duration can be zero, allowing a user to instantly release all allocated tokens and Ether.  Consider adding sensible lower and upper bounds for all arguments of the constructor to ensure none of the outlined scenarios occur.  Update: Resolved in pull request #42 at commit a009de2.  Dust Is Paid to Last Payee in the _payees Array  Line 117 sets the payment variable to the remaining balance for the last address in the _payees array. While this keeps the rounded-down wei from remaining in the contract after a single payment, it also creates a fairness issue from the point of view of the other _payees.  Consider paying all payees balance * _shares[payee] / _totalShares.  Update: Resolved in pull request #44 at commit 822347b.  Owner of the Splitter Contract Can Dilute Existing Shareholders  The addPayee function of the Splitter contract allows the owner of the contract to unilaterally mint new shares to a new address. When unclaimed funds are present within the splitter, the existing shareholders are diluted by the administrative action.  When unclaimed funds are present within the splitter, the same holds true for the adjustShare function.  Consider developing an architecture where these administrative functions are not necessary. At a minimum, ensure that unreleased payments to pre-existing shareholders are not diluted by administrative actions.  Update: Acknowledged, not resolved. The Ocean Protocol team stated:  The existing shareholders are diluted by the administrative action. This aligns with our expectations, we would like the alterations to the shares to effectively apply to the unclaimed amount.  VestingWalletHalving Administrative Functions Ignore Previously Released Tokens  renounceVesting function in  splitter.sol, which will then release tokens to the respective incentive programs.  For example,", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#summary", "labels": ["OpenZeppelin"]}, {"title": "Type", "body": "Type", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#type", "labels": ["OpenZeppelin"]}, {"title": "DeFi", "body": "DeFi", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#defi", "labels": ["OpenZeppelin"]}, {"title": "Timeline", "body": "Timeline", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#timeline", "labels": ["OpenZeppelin"]}, {"title": "From 2023-09-19", "body": "From 2023-09-19", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#from-2023-09-19", "labels": ["OpenZeppelin"]}, {"title": "To 2023-09-21", "body": "To 2023-09-21", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#to-2023-09-21", "labels": ["OpenZeppelin"]}, {"title": "Languages", "body": "Languages", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#languages", "labels": ["OpenZeppelin"]}, {"title": "Solidity", "body": "Total Issues  12 (8 resolved, 1 partially resolved)  Critical Severity Issues  0 (0 resolved)  High Severity Issues  0 (0\u202fresolved)  Medium Severity Issues  5 (3 resolved)  Low Severity Issues  2 (1 resolved)  Notes & Additional Information  5 (4 resolved, 1 partially resolved)  Scope  We audited the oceanprotocl/vw-cli repository at commit 0397c74.  System Overview  As the Ocean Protocol  migrates  to a more decentralized architecture, the  Splitter  and  VestingWalletHalving  contracts are intended to be utilities for setting up token cashflows  from the initial multisig wallet to the  DF Rewards  contracts and their respective stakeholders.  In a one-time transaction, Ocean tokens are intended to be transferred to a collection of vesting contracts with various vesting schedules. Over time, these vesting wallets will release funds into the payment splitter which will apportion the payment across the DF Rewards contracts.  The  VestingWalletHalving  contract is an implementation of the vesting wallet functionality of the protocol, based on a half-life formula. Its source code is substantially similar to the OpenZeppelin  implementation  of an abstract  VestingWallet  The Splitter contract implements the payment splitter functionality of the protocol. Its source code again hews closely to the OpenZeppelin implementation.  Security Model and Privileged Roles  When compared to their corresponding implementations by OpenZeppelin, both of these contracts have additional administrative functionalities accessible by their owners.  The owner of the Splitter contract can:  1. Add a payee at any point in time.       2. Remove a payee at any point in time.       3. Alter the shares of any payee at any point in time.  The owner of the VestingWalletHalving contract can:       1. Change the beneficiary address of the wallet at any point in time.        2. Remove all tokens from the contract at any point in time.  The administrative functionality creates substantial risk for the  payees  of the  Splitter  and  beneficiary  of the  VestingWalletHalving  contracts when compared to the immutable  and irrevocable implementations.  The development team has indicated that these administrative features are intended as contingencies and that ownership of both is to be renounced at some future point in time. For this reason, we have reduced the severity of the findings involving the administrative functions.  It should be noted, however, that as written, the contracts are not suitable for use between non-trusting counterparties. Cashflows into the DF Rewards contracts cannot, therefore, be considered trustless until ownership of the above contracts is renounced.  Medium Severity  Insufficient Input Validation for Vesting Schedule  The input arguments of the constructor are not sufficiently validated. Some problematic scenarios will arise from this, including:       \u2022 startTimestamp can be a timestamp that has already passed or is too far away in the              future.       \u2022 halfLife can be zero, causing the getAmount function to always revert.       \u2022 duration can be zero, allowing a user to instantly release all allocated tokens and Ether.  Consider adding sensible lower and upper bounds for all arguments of the constructor to ensure none of the outlined scenarios occur.  Update: Resolved in pull request #42 at commit a009de2.  Dust Is Paid to Last Payee in the _payees Array  Line 117 sets the payment variable to the remaining balance for the last address in the _payees array. While this keeps the rounded-down wei from remaining in the contract after a single payment, it also creates a fairness issue from the point of view of the other _payees.  Consider paying all payees balance * _shares[payee] / _totalShares.  Update: Resolved in pull request #44 at commit 822347b.  Owner of the Splitter Contract Can Dilute Existing Shareholders  The addPayee function of the Splitter contract allows the owner of the contract to unilaterally mint new shares to a new address. When unclaimed funds are present within the splitter, the existing shareholders are diluted by the administrative action.  When unclaimed funds are present within the splitter, the same holds true for the adjustShare function.  Consider developing an architecture where these administrative functions are not necessary. At a minimum, ensure that unreleased payments to pre-existing shareholders are not diluted by administrative actions.  Update: Acknowledged, not resolved. The Ocean Protocol team stated:  The existing shareholders are diluted by the administrative action. This aligns with our expectations, we would like the alterations to the shares to effectively apply to the unclaimed amount.  VestingWalletHalving Administrative Functions Ignore Previously Released Tokens  renounceVesting function in  splitter.sol, which will then release tokens to the respective incentive programs.  For example, if a long time has passed and the release function has never been called, ", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#solidity", "labels": ["OpenZeppelin"]}, {"title": "Total Issues", "body": "Total Issues", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#total-issues", "labels": ["OpenZeppelin"]}, {"title": "12 (8 resolved, 1 partially resolved)", "body": "12 (8 resolved, 1 partially resolved)", "html_url": "https://blog.openzeppelin.com/ocean-vesting-wallet-audit#12-(8-resolved,-1-partially-resolved)", "labels": ["OpenZeppelin"]}, {"title": "updateAlpha and updateMultipliers Break Rewards Accounting and Could Make Rewards Pool Insolvent", "body": "updateAlpha and updateMultipliers Break Rewards Accounting and Could Make Rewards Pool Insolvent", "html_url": "https://blog.openzeppelin.com/venus-prime-audit#updatealpha-and-updatemultipliers-break-rewards-accounting-and-could-make-rewards-pool-insolvent", "labels": ["OpenZeppelin"]}, {"title": "Maximum XVS Staked Does Not Match the Documentation", "body": "The documentation states:  The maximum XVS cap taken into account when calculating the score of a user is 100,000 XVS.  However the constant MAXIMUM_XVS_CAP is set to 10000. Consider modifying the variable or updating the documentation accordingly.  Update: Resolved in pull request #196 at commit 860c959.", "html_url": "https://blog.openzeppelin.com/venus-prime-audit#maximum-xvs-staked-does-not-match-the-documentation", "labels": ["OpenZeppelin"]}, {"title": "Irrevocable Token Cannot Be Minted to Revocable Token Holder", "body": "If the Venus team attempts to mint an irrevocable token for a user already holding a revocable Prime token, the minting process fails. This is due to the internal function _mint, which requires that the recipient must not hold any form of Prime token, whether it is revocable or irrevocable.  Given that irrevocable Prime tokens are more desirable as they remain even when the user unstakes, this behavior suggests an unintended restriction in the minting process.  Update: Resolved at commit a19e29c, pull request #196 at commit b98dc82.  Low Severity", "html_url": "https://blog.openzeppelin.com/venus-prime-audit#irrevocable-token-cannot-be-minted-to-revocable-token-holder", "labels": ["OpenZeppelin"]}, {"title": "Missing Check for Setting Alpha Values", "body": "alphaDenominator  should never exceed  alphaNumerator  , as specified by the audit documentation as well as this  error  which would be thrown in the  calculateScore  function:  assert(alphaNumerator <= alphaDenominator);  Consider ensuring that  alphaNumerator <= alphaDenominator  in the  initialize  and  updateAlpha  functions.  Resolved at commit  f7d463b  , at commit  a7e913f  , at commit  5a04aa0", "html_url": "https://blog.openzeppelin.com/venus-prime-audit#missing-check-for-setting-alpha-values", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings:  Line 572  in  Prime.sol  Line 105  in  Prime.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved at commit eb36a3f, at commit 91b2474, at commit 2825c16, at commit 2abb751.  Unsafe Typecasting in uintMul() and uintDiv()  The divisor argument of  uintDiv  and the multiplier argument of  uintMul  in the  FixedMath  library are both signed integers.  The results of multiplication and division operations involving these arguments will therefore be signed, and the results of both the  uintDiv  and  uintMul  functions are downcast to  uint256  While this may produce the correct results when the multiplier and divisor arguments are properly-encoded fixed-point numbers, it will produce erroneous results when the high bit of either of these arguments is set.  Consider adding a check to ensure that the multiplier argument of uintMul and the divisor argument of uintDiv are well-formed fixed-point numbers.  Update: Resolved at commit 61ad1e7.  Old Floating Pragma Version  Pragma directives should be fixed to clearly identify the Solidity version with which the contracts will be compiled.  The file IPrime.sol has the solidity ^0.5.16 floating pragma directive which is an outdated Solidity version.  Consider using the same fixed pragma version used in Prime.sol.  Update: Acknowledged, not resolved. The Venus team stated:  It is done so that our core pool contracts can import the interface.  Missing Check that PrimePoolId Is a Valid poolId  A valid  poolId  for a token must be less than the length of the  poolInfos  array for a particular  rewardToken  . A prime  poolId  should also match a pre-existing  poolId  , so this condition should also be true for Prime pools. However, the  setPrimeToken  function does not have this check.  Consider adding a check in setPrimeToken to ensure that it matches a pre-existing poolId.  Update: Resolved at commit ad5b11a.  Notes & Additional Information  Non-Explicit Imports Are Used  The use of non-explicit imports in the codebase can decrease the clarity of the code, and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are used:  Line 3  of  Prime.sol  Line 4  of  Prime.sol  Line 5  of  Prime.sol  Line 6  of  Prime.sol  Line 6  of  FixedMath.sol  Line 7  of  FixedMath.sol  Line 5  of  Scores.sol  Line 6  of  Scores.sol  Line 9  of  XVSVault.sol  Following the principle that clearer code is better code, consider using named import syntax ( import {A, B, C} from \"X\" ) to explicitly declare which contracts are being imported.  Update: Resolved at commit b2fa6d5, and commit adb8535.  Using int/uint Instead of int256/uint256  Throughout the  codebase  , there are multiple instances where  int/uint  is used as opposed to  int256/uint256  Line 9  of Prime.sol  Line 10  of Prime.sol  Line 11  of Prime.sol  Line 118  of Prime.sol  Line 185  of Prime.sol  Line 190  of Prime.sol  Line 208  of Prime.sol  Line 223  of Prime.sol  Line 249  of Prime.sol  In favor of explicitness, consider replacing all instances of int/uint with int256/ uint256.  Update: Resolved at commit e9269c7.  Unused State Variable  The  MAXIMUM_BPS  state variable in the  PrimeStorageV1  contract  is never used.  To improve the overall clarity, intentionality, and readability of the codebase, consider removing any unused state variables.  Update: Resolved. The Venus team stated:  We are finally using it in the function _calculateUserAPR. See commit ec2f4fd.  Lack of SPDX License Identifiers  Throughout the codebase, there are files that lack SPDX license identifiers. For instance:  IPrime.sol  Prime.sol  PrimeStorage.sol  To avoid legal issues regarding copyright and follow best practices, consider adding SPDX license identifiers to files as suggested by the Solidity documentation.  Update: Resolved at commit f0b12eb.  Lack of Security Contact  Providing a specific security contact, such as an email or ENS, within a smart contract significantly simplifies the process for individuals to communicate if they identify a vulnerability in the code. This practice proves beneficial as it permits the code owners to dictate the communication channel for vulnerability disclosure, eliminating the risk of miscommunication or failure to report due to a lack of knowledge on how to do so. Additionally, if the contract incorporates third-party libraries and a bug surfaces in these, it becomes easier for the creators of those libraries to make contact, inform the code owners about the problem,", "html_url": "https://blog.openzeppelin.com/venus-prime-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Unsafe Typecasting in uintMul()and\u00a0uintDiv()", "body": "Unsafe Typecasting in uintMul()and\u00a0uintDiv()", "html_url": "https://blog.openzeppelin.com/venus-prime-audit#unsafe-typecasting-in-uintmul()and\u00a0uintdiv()", "labels": ["OpenZeppelin"]}, {"title": "Old Floating Pragma Version", "body": "Pragma directives should be fixed to clearly identify the Solidity version with which the contracts will be compiled.  The file IPrime.sol has the solidity ^0.5.16 floating pragma directive which is an outdated Solidity version.  Consider using the same fixed pragma version used in Prime.sol.  Update: Acknowledged, not resolved. The Venus team stated:  It is done so that our core pool contracts can import the interface.  Missing Check that PrimePoolId Is a Valid poolId  A valid  poolId  for a token must be less than the length of the  poolInfos  array for a particular  rewardToken  . A prime  poolId  should also match a pre-existing  poolId  , so this condition should also be true for Prime pools. However, the  setPrimeToken  function does not have this check.  Consider adding a check in setPrimeToken to ensure that it matches a pre-existing poolId.  Update: Resolved at commit ad5b11a.  Notes & Additional Information  Non-Explicit Imports Are Used  The use of non-explicit imports in the codebase can decrease the clarity of the code, and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are used:  Line 3  of  Prime.sol  Line 4  of  Prime.sol  Line 5  of  Prime.sol  Line 6  of  Prime.sol  Line 6  of  FixedMath.sol  Line 7  of  FixedMath.sol  Line 5  of  Scores.sol  Line 6  of  Scores.sol  Line 9  of  XVSVault.sol  Following the principle that clearer code is better code, consider using named import syntax ( import {A, B, C} from \"X\" ) to explicitly declare which contracts are being imported.  Update: Resolved at commit b2fa6d5, and commit adb8535.  Using int/uint Instead of int256/uint256  Throughout the  codebase  , there are multiple instances where  int/uint  is used as opposed to  int256/uint256  Line 9  of Prime.sol  Line 10  of Prime.sol  Line 11  of Prime.sol  Line 118  of Prime.sol  Line 185  of Prime.sol  Line 190  of Prime.sol  Line 208  of Prime.sol  Line 223  of Prime.sol  Line 249  of Prime.sol  In favor of explicitness, consider replacing all instances of int/uint with int256/ uint256.  Update: Resolved at commit e9269c7.  Unused State Variable  The  MAXIMUM_BPS  state variable in the  PrimeStorageV1  contract  is never used.  To improve the overall clarity, intentionality, and readability of the codebase, consider removing any unused state variables.  Update: Resolved. The Venus team stated:  We are finally using it in the function _calculateUserAPR. See commit ec2f4fd.  Lack of SPDX License Identifiers  Throughout the codebase, there are files that lack SPDX license identifiers. For instance:  IPrime.sol  Prime.sol  PrimeStorage.sol  To avoid legal issues regarding copyright and follow best practices, consider adding SPDX license identifiers to files as suggested by the Solidity documentation.  Update: Resolved at commit f0b12eb.  Lack of Security Contact  Providing a specific security contact, such as an email or ENS, within a smart contract significantly simplifies the process for individuals to communicate if they identify a vulnerability in the code. This practice proves beneficial as it permits the code owners to dictate the communication channel for vulnerability disclosure, eliminating the risk of miscommunication or failure to report due to a lack of knowledge on how to do so. Additionally, if the contract incorporates third-party libraries and a bug surfaces in these, it becomes easier for the creators of those libraries to make contact, inform the code owners about the problem, and provide mitigation instructions.  Neither of the contracts in scope has a security contact.  Consider adding a NatSpec comment on top of the contracts' definitions with a security contact. Using the  @custom:security-contact  convention is recommended as it has been adopted by the  OpenZeppelin Wizard  and the  ethereum-lists  Update: Resolved at commit 405f962. The Venus team stated:  We have added a link to our github repo. At the end of the readme file in that repo we say this: For any concerns with the protocol, open an issue or visit us on Telegram to discuss. For security concerns, please contact the administrators of our telegram chat.  Multiple Instances of Missing Named Parameters in Mappings  Since  Solidity 0.8.18  , developers can utilize named parameters in mappings. This means mappings can take the form of  mapping(KeyType KeyName? => ValueType  ValueName?).  This updated syntax provides a more transparent representation of the mapping's purpose.  Throughout the codebase, there are multiple mappings without named parameters:  The  tokens  state variable in the  PrimeStorageV1 contract  .\u2022 The  stakedAt  state variable in the PrimeStorageV1 contract.  The  markets  state variable in the PrimeStorageV1 contract.  The  interests  state variable in the PrimeStorageV1 contract.  The  isScoreUpdated  state ", "html_url": "https://blog.openzeppelin.com/venus-prime-audit#old-floating-pragma-version", "labels": ["OpenZeppelin"]}, {"title": "Missing Check that\u00a0PrimePoolId Is a Valid poolId", "body": "Missing Check that\u00a0PrimePoolId Is a Valid poolId", "html_url": "https://blog.openzeppelin.com/venus-prime-audit#missing-check-that\u00a0primepoolid-is-a-valid-poolid", "labels": ["OpenZeppelin"]}, {"title": "Non-Explicit Imports Are Used", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code, and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are used:  Line 3  of  Prime.sol  Line 4  of  Prime.sol  Line 5  of  Prime.sol  Line 6  of  Prime.sol  Line 6  of  FixedMath.sol  Line 7  of  FixedMath.sol  Line 5  of  Scores.sol  Line 6  of  Scores.sol  Line 9  of  XVSVault.sol  Following the principle that clearer code is better code, consider using named import syntax ( import {A, B, C} from \"X\" ) to explicitly declare which contracts are being imported.  Update: Resolved at commit b2fa6d5, and commit adb8535.  Using int/uint Instead of int256/uint256  Throughout the  codebase  , there are multiple instances where  int/uint  is used as opposed to  int256/uint256  Line 9  of Prime.sol  Line 10  of Prime.sol  Line 11  of Prime.sol  Line 118  of Prime.sol  Line 185  of Prime.sol  Line 190  of Prime.sol  Line 208  of Prime.sol  Line 223  of Prime.sol  Line 249  of Prime.sol  In favor of explicitness, consider replacing all instances of int/uint with int256/ uint256.  Update: Resolved at commit e9269c7.  Unused State Variable  The  MAXIMUM_BPS  state variable in the  PrimeStorageV1  contract  is never used.  To improve the overall clarity, intentionality, and readability of the codebase, consider removing any unused state variables.  Update: Resolved. The Venus team stated:  We are finally using it in the function _calculateUserAPR. See commit ec2f4fd.  Lack of SPDX License Identifiers  Throughout the codebase, there are files that lack SPDX license identifiers. For instance:  IPrime.sol  Prime.sol  PrimeStorage.sol  To avoid legal issues regarding copyright and follow best practices, consider adding SPDX license identifiers to files as suggested by the Solidity documentation.  Update: Resolved at commit f0b12eb.  Lack of Security Contact  Providing a specific security contact, such as an email or ENS, within a smart contract significantly simplifies the process for individuals to communicate if they identify a vulnerability in the code. This practice proves beneficial as it permits the code owners to dictate the communication channel for vulnerability disclosure, eliminating the risk of miscommunication or failure to report due to a lack of knowledge on how to do so. Additionally, if the contract incorporates third-party libraries and a bug surfaces in these, it becomes easier for the creators of those libraries to make contact, inform the code owners about the problem, and provide mitigation instructions.  Neither of the contracts in scope has a security contact.  Consider adding a NatSpec comment on top of the contracts' definitions with a security contact. Using the  @custom:security-contact  convention is recommended as it has been adopted by the  OpenZeppelin Wizard  and the  ethereum-lists  Update: Resolved at commit 405f962. The Venus team stated:  We have added a link to our github repo. At the end of the readme file in that repo we say this: For any concerns with the protocol, open an issue or visit us on Telegram to discuss. For security concerns, please contact the administrators of our telegram chat.  Multiple Instances of Missing Named Parameters in Mappings  Since  Solidity 0.8.18  , developers can utilize named parameters in mappings. This means mappings can take the form of  mapping(KeyType KeyName? => ValueType  ValueName?).  This updated syntax provides a more transparent representation of the mapping's purpose.  Throughout the codebase, there are multiple mappings without named parameters:  The  tokens  state variable in the  PrimeStorageV1 contract  .\u2022 The  stakedAt  state variable in the PrimeStorageV1 contract.  The  markets  state variable in the PrimeStorageV1 contract.  The  interests  state variable in the PrimeStorageV1 contract.  The  isScoreUpdated  state variable in the PrimeStorageV1 contract.  The  vTokenForAsset  state variable in the PrimeStorageV1 contract.  The  unreleasedIncome  state variable in the PrimeStorageV1 contract.  Consider adding named parameters to the mappings to improve the readability and maintainability of the code.  Update: Acknowledged, not resolved. The Venus team stated:  We are using solidity 0.8.13, and named parameters were included in 0.8.18  Conclusion  The addition of Prime tokens had a relatively low impact on the existing codebase. The audit uncovered 1 critical-severity and 2 medium-severity issues. Several recommendations were proposed to follow best practices.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Securi", "html_url": "https://blog.openzeppelin.com/venus-prime-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Using\u00a0int/uint Instead of int256/uint256", "body": "Using\u00a0int/uint Instead of int256/uint256", "html_url": "https://blog.openzeppelin.com/venus-prime-audit#using\u00a0int/uint-instead-of-int256/uint256", "labels": ["OpenZeppelin"]}, {"title": "Unused State Variable", "body": "The  MAXIMUM_BPS  state variable in the  PrimeStorageV1  contract  is never used.  To improve the overall clarity, intentionality, and readability of the codebase, consider removing any unused state variables.  Update: Resolved. The Venus team stated:  We are finally using it in the function _calculateUserAPR. See commit ec2f4fd.", "html_url": "https://blog.openzeppelin.com/venus-prime-audit#unused-state-variable", "labels": ["OpenZeppelin"]}, {"title": "Lack of SPDX License Identifiers", "body": "Throughout the codebase, there are files that lack SPDX license identifiers. For instance:  IPrime.sol  Prime.sol  PrimeStorage.sol  To avoid legal issues regarding copyright and follow best practices, consider adding SPDX license identifiers to files as suggested by the Solidity documentation.  Update: Resolved at commit f0b12eb.", "html_url": "https://blog.openzeppelin.com/venus-prime-audit#lack-of-spdx-license-identifiers", "labels": ["OpenZeppelin"]}, {"title": "Lack of Security Contact", "body": "Providing a specific security contact, such as an email or ENS, within a smart contract significantly simplifies the process for individuals to communicate if they identify a vulnerability in the code. This practice proves beneficial as it permits the code owners to dictate the communication channel for vulnerability disclosure, eliminating the risk of miscommunication or failure to report due to a lack of knowledge on how to do so. Additionally, if the contract incorporates third-party libraries and a bug surfaces in these, it becomes easier for the creators of those libraries to make contact, inform the code owners about the problem, and provide mitigation instructions.  Neither of the contracts in scope has a security contact.  Consider adding a NatSpec comment on top of the contracts' definitions with a security contact. Using the  @custom:security-contact  convention is recommended as it has been adopted by the  OpenZeppelin Wizard  and the  ethereum-lists  Update: Resolved at commit 405f962. The Venus team stated:  We have added a link to our github repo. At the end of the readme file in that repo we say this: For any concerns with the protocol, open an issue or visit us on Telegram to discuss. For security concerns, please contact the administrators of our telegram chat.", "html_url": "https://blog.openzeppelin.com/venus-prime-audit#lack-of-security-contact", "labels": ["OpenZeppelin"]}, {"title": "Multiple Instances of Missing Named Parameters in Mappings", "body": "Since  Solidity 0.8.18  , developers can utilize named parameters in mappings. This means mappings can take the form of  mapping(KeyType KeyName? => ValueType  ValueName?).  This updated syntax provides a more transparent representation of the mapping's purpose.  Throughout the codebase, there are multiple mappings without named parameters:  The  tokens  state variable in the  PrimeStorageV1 contract  .\u2022 The  stakedAt  state variable in the PrimeStorageV1 contract.  The  markets  state variable in the PrimeStorageV1 contract.  The  interests  state variable in the PrimeStorageV1 contract.  The  isScoreUpdated  state variable in the PrimeStorageV1 contract.  The  vTokenForAsset  state variable in the PrimeStorageV1 contract.  The  unreleasedIncome  state variable in the PrimeStorageV1 contract.  Consider adding named parameters to the mappings to improve the readability and maintainability of the code.  Update: Acknowledged, not resolved. The Venus team stated:  We are using solidity 0.8.13, and named parameters were included in 0.8.18", "html_url": "https://blog.openzeppelin.com/venus-prime-audit#multiple-instances-of-missing-named-parameters-in-mappings", "labels": ["OpenZeppelin"]}, {"title": "Fillers Can Incur a Loss Without a Chance to Revert", "body": "When fillers execute an order, they have a chance to revert at the end of their  callback  if the trade was not profitable for them. However, the  executeWithCallback  flow (and its batch equivalent) does not end right after the callback. Instead, once the callback is over, the  output balances are transferred  from the filler to the swapper by the reactor.  If one of the output tokens is either a malicious ERC-20 implementation controlled by the swapper or a legitimate ERC-777 implementation, the swapper can receive one more callback within the transferFrom function call to perform arbitrary operations. These operations might be gas intensive and will be funded by the filler. At this point, the filler has no more execution control. As such, given a high enough overall transaction gas limit, even if a profit was made on the trade, the filler could incur a loss.  A malicious swapper might use this technique to perform a legitimate swap as well as let the filler subsidize a potentially gas-intensive operation (e.g., minting gas tokens on applicable chains, performing more swaps, deploying contracts, etc).  Consider adding a final callback to the filler to allow reverts if a profit was not made after fees. This will turn this vector into a griefing attack since the filler will be charged for the revert, but at least the swapper will not profit from the filler. In order to make the extra callback more gas efficient, consider either making it optional or having the filler call an external version of _fill as the last step on their callback. It is imperative to ensure the filler has called the _fill function, but this must be done without checking the balances of the recipients.  Update: Acknowledged, not resolved. This issue is only applicable if the filler is using an EOA to target the various execute entrypoints directly (without using an intermediate contract of their own) and / or not using a private mempool to relay their transactions in order to avoid paying for reverts. The Uniswap team stated:  Fillers generally estimateGas on their transaction before including them anyways, and they will only send it if it is profitable net of gas. They also generally use private mempools like flashbots or mevblocker to get protection from loss due to gas. Further, they do have the chance to revert after the order is filled in their fillContract, after the execution is finished.", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#fillers-can-incur-a-loss-without-a-chance-to-revert", "labels": ["OpenZeppelin"]}, {"title": "Gas Limitation Can Disable Smart Contract Wallets", "body": "The CurrencyLibrary is used to handle ERC-20 tokens and native currency transfers in UniswapX. The native transfer is performed with a low-level call without calldata and a hard-coded gas limit of 6900.  Gas limits on calls are considered a bad practice for two main reasons:  Gas costs have changed over time (e.g., as per EIP-1884).       \u2022 EVM side-chains and L2s can have different gas costs. This has previously caused funds to           become stuck as transfers run out of gas and revert.  Both arguments could lead to unreliable functionality over time and across chains. A smart contract wallet can have logic in its receive or fallback function which exceeds the 6900 gas limit, thereby disabling that wallet to use the service for swaps where the native currency is involved. Furthermore, the protocol injects fees into the orders that are sent to the fee recipient, including ETH. Hence, a fee vault or a multi-sig wallet as a fee recipient can be equally affected by this problem.  Note that the concern of reentrancy should be tackled at the entry point level, which was not identified as a risk for this scope. Further, for the concern regarding the swapper being able to spend the filler's gas maliciously, please see M-01.  Consider removing the gas limitation to guarantee the functionality of smart contract wallets when engaging with UniswapX.  Update: Resolved in pull request #189 at commit 0cdf97e.  Low Severity", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#gas-limitation-can-disable-smart-contract-wallets", "labels": ["OpenZeppelin"]}, {"title": "Floating Pragma", "body": "The contracts in the codebase are using the floating pragma ^0.8.0 . This version indicates that any compiler version starting from 0.8.0 can be used to compile the source code.  However, the code will not compile when using version  0.8.3  or earlier since the protocol is using custom errors that were introduced in Solidity  0.8.4  . In addition, the use of Solidity  0.8.20  and later might cause a problem with a deployment to Arbitrum and Optimism, which do not yet support opcode  PUSH0  that has been introduced with Solidity version  0.8.20  It is recommended to set the pragma to 0.8.19 to align with the best practice of locking the pragma for all contracts. This precautionary measure also helps prevent the accidental deployment of contracts with outdated compiler versions that could potentially introduce vulnerabilities.  Update: Acknowledged, not resolved. The Uniswap team stated:  We will not be doing this for now because it makes it harder to import / depend on the contracts if we do not use a precise solc version.", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#floating-pragma", "labels": ["OpenZeppelin"]}, {"title": "Fee Controller Can DOS Trading Activity", "body": "The protocol allows fees to be collected. To do so, a protocol fee controller needs to be  set  to a non-zero address. Uniswap governance has the ability to collect up to 0.05% of the token amounts, as enforced by the  ProtocolFees contract  . The  FeeController  is queried  by the  ProtocolFees  contract to get a list of fees that need to be taken, specifying the amounts, the token addresses, and the recipients.  Any mistakes in that return value will cause the _injectFees function to revert if:  The fee token  is not part of the original order  .        \u2022 The fee is  too large  .       \u2022 There is a  duplicated entry  Since the fees are fetched for every order from any reactor, an incorrect response will halt all trading activity. This can be the result of an attack or a bug in the fee controller.  If this is not intended behavior, consider not charging fees when one of the above cases occurs in order to not affect trading activity. Instead of reverting, an event can be emitted and be caught by a monitoring solution.  Update: Acknowledged, not resolved. The Uniswap team stated:  This is a known issue, and we acknowledge it for now. We can always redeploy a reactor in such circumstances, which would only cause a minor inconvenience. We will likely decide on a fix before the next version is deployed.", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#fee-controller-can-dos-trading-activity", "labels": ["OpenZeppelin"]}, {"title": "Dutch Orders Without Duration Benefit the Filler", "body": "The Dutch order implements a  linear decay function  . From  decayStartTime  to  decayEndTime  the amount of input or output tokens goes from  startAmount  (best rate for  swapper) to  endAmount  (worst rate the swapper agrees with).  However, in the current implementation, it is possible to provide the same value for the  decayStartTime  and  decayEndTime  . In this case, the Dutch order is acting like a limit  order as the final amount will not change gradually over time. Instead,  the final amount will be equal to the  endAmount  , which ambiguously benefits the filler over the swapper.  Consider changing the price of Dutch orders without duration to be equal to the  startAmount  instead of the  endAmount  by swapping  the two else-if  blocks  checking  that the timeframe is in favor of the swapper. Alternatively, consider restricting the usage of Dutch orders to actual Dutch orders with a non-zero duration and price decay.  Update: Resolved in pull request #194 at commit 068076f. Dutch orders with zero duration are now disallowed to avoid this ambiguity.", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#dutch-orders-without-duration-benefit-the-filler", "labels": ["OpenZeppelin"]}, {"title": "Missing or Incorrect Docstrings", "body": "codebase, there are several parts that have missing or incorrect docstrings:  ResolvedOrderLib library.  ExclusiveFillerValidation contract.  line 11-12 in  ReactorEvents.sol . The  callbackData in  IReactor.sol.  parseRevertReason function misses the  Consider thoroughly documenting all functions and their parameters that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #192 at commit ce6b1f5.", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#missing-or-incorrect-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Inaccurate Documentation", "body": "There are multiple areas where the protocol would benefit from more accurate documentation:  The _validateOrder function documentation of the DutchOrderReactor and ExclusiveDutchOrderReactor contracts describe order properties that must be fulfilled. However, these functions only validate a subset of those properties.  The documentation of the checkExclusivity function does not mention thetimestamp impact on the exclusivity. Furthermore, the function name does not fully align with the code's intention. For instance, the return is true if the deadline has expired, or the exclusivity was disabled through the exclusive address being zero. Consider renaming the function to something like hasFillingRights which matches the intention of the check.  The Fees section of the whitepaper states that a fee is only taken on the output tokens of the swap, while the code also allows a fee on the input token.  The documentation on the website elaborating on Direct Fill appears to be outdated.  Consider updating the documentation to be aligned with the intentions of the code.  Update: Resolved in pull request #193 of the UniswapX repository at commit cdd4e33 and pull request #626 of the docs repository at commit 24d90ab.", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#inaccurate-documentation", "labels": ["OpenZeppelin"]}, {"title": "Incomplete Test Coverage", "body": "While the overall coverage is close to 100%, there are several lines of code lacking testcoverage:  In the ExclusiveDutchOrderReactor contract, the validation logic is not tested for orders with input decay. Consider adding at least one succeeding and one reverting test case with input decay to the ExclusiveDutchOrderReactor test file.  In the ProtocolFees contract, the _injectFees function is not tested for input fees.  To further enhance the quality of the tests, here are some suggested improvements:  Add tests of executeBatch for ExclusiveDutchOrders (already present for DutchOrder and LimitOrder).  Add integration tests for limit orders and exclusive Dutch orders since currently only the Dutch order reactor is being integration-tested.  Update: Resolved in pull request #197 at commit e327540 by adding tests for input fees and exclusive Dutch auctions with decaying input. The Uniswap team explained that additional integration tests are expected to be added in the future.", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#incomplete-test-coverage", "labels": ["OpenZeppelin"]}, {"title": "Redundant Code", "body": "Redundant code reduces the protocol's gas efficiency, especially when considering on-chain trading, as it impacts the filler's profit and the swapper's execution price. The following opportunities have been identified for potential enhancements:  Checking the order expiration is redundant since the same check is performed when calling permitTransferFrom on the Permit2 contract afterwards. These deadlines are the same value, as set through the Permit2Lib. Removing this check makes successful trades more gas-optimized while reverting trades will use a bit more gas.  The exclusive Dutch order reactor does not have to validate that endDecayTime is larger than or equal to startDecayTime, since it will be validated again when applying the decay.  The CurrencyLibrary implements a balanceOf function that is not used throughout the protocol. Consider removing unused code to improve the readability.  Consider applying the suggested changes in order to make the code more efficient. Note that for the removed checks, it is important to document where the actual check is performed.  Update: Resolved in pull request #195 at commit 36a0a28. The balanceOf function of the CurrencyLibrary was not removed since it might be used by the fill contracts.", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#redundant-code", "labels": ["OpenZeppelin"]}, {"title": "Magic Numbers", "body": "In the OrderQuoter contract, there are occurrences of literal values with unexplainedmeanings:  ORDER_INFO_OFFSET = 64, which is used to skip a bytes length and struct offset slot to point to the offset slot of the inner OrderInfo struct. In addition, it lacks an explicitly declared visibility.  reason.length < 192, which checks whether reason is less than 6 slots to distinguish a revert reason from an encoded order. Note that the OrderInfo struct has a minimal encoded length of 8 slots to account for the struct and dynamic bytes offsets.  Consider documenting these numbers to improve the readability of the codebase.  Update: Resolved in pull request #196 at commit 2b881d4.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#magic-numbers", "labels": ["OpenZeppelin"]}, {"title": "Unused Named Return Variables", "body": "Named return variables are a way to declare variables that are meant to be used within a function's body for the purpose of being returned as the function's output. They are an alternative to explicit in-line return statements. The following instances were identified where named return variables were declared but unused:  order within the parseRevertReason function.  pass within the checkExclusivity function.  Consider either using or removing any unused named return variables.  Update: Resolved in pull request #199 at commit 5e5ef41. Both unused named return variables were removed.", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#unused-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "Throughout the codebase there are imports that are unused and could be removed. Forinstance:  Imports ResolvedOrder and IReactorCallback of IReactor.sol  Import OrderInfo of IValidationCallback.sol  Imports BaseReactor and OrderInfo of OrderQuoter.sol  Imports IPermit2 and SafeCast of CurrencyLibrary.sol  Import ERC20 of Permit2Lib.sol  Import IValidationCallback of ResolvedOrderLib.sol  Import NATIVE of BaseReactor.sol  Imports InputToken, OutputToken, and OrderInfo of DutchOrderReactor.sol  Import OrderInfo of ExclusiveDutchOrderReactor.sol  Imports OrderInfo, OutputToken, and InputToken of LimitOrderReactor.sol  Import OutputToken of SwapRouter02Executor.sol  Import OrderInfo of ExclusiveFillerValidation.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #191 at commit ae17cd3.", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "Consider addressing the following typographical errors:  Line 13 in DutchDecayLib.sol : \"toendAmount\" should be \"to endAmount\".  Line 21 in SwapRouter02Executor.sol : \"adress\" should be \"address\".  Update: Resolved in pull request #190 at commit 19307ff.", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Potential Double Fees on Cross-Chain Swaps", "body": "Every swap through UniswapX can charge a fee on the input and output tokens. As per the  documentation  , this fee must not exceed 0.05% \"of the order outputs\". This is checked by  accumulating  the input and output token amounts per token address and calculating whether the fee amount  is within the 0.05% threshold  When swapping a token for itself, such as when bridging it from one chain to another (assuming the same token address and value), the token amount would be doubled through the accumulation. Hence, a double fee could be erroneously charged.  Consider handling this specific case such that only the input or the output amount is taken into account when calculating the fee.  Update: Acknowledged, not resolved. The Uniswap team stated:  These contracts are not intended for cross-chain swaps. A cross-chain reactor will likely also include chainId specification for tokens to differentiate the same token across chains.", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#potential-double-fees-on-cross-chain-swaps", "labels": ["OpenZeppelin"]}, {"title": "Gas Optimizations", "body": "There are some areas where gas savings can be achieved in order to improve the system'sperformance. For instance:  There are multiple for loops throughout the codebase that use the postfix increment operator. Consider using the prefix increment operator ++i instead in order to save gas. This skips storing the value before the incremental operation, as the return value of the expression is ignored.  When filling single orders, consider removing the overhead of turning a single order into a 1-item array of orders which will be looped through when preparing and filling it. The main preparation and filling logic could be extracted into an internal function called from inside the loop when working with batches, and individually called from single-order executions.  Validating that the transaction is targeting the proper reactor and has not yet expired could be performed as soon as possible in the transaction lifecycle. This will save some gas by failing early in the case of mistaken orders.  In the EVM, it is more gas-efficient to read values from stack than from memory or state. Since in a for loop the termination condition is read repeatedly, it makes sense to write the length of an array to stack and reuse the stack variable. Multiple instances were identified where this optimization could be applied. For instance:  On line 87 of DutchOrderLib.sol On line 43 of ExclusivityOverrideLib.sol On line 50 of LimitOrderLib.sol On line 71 of DutchOrderReactor.sol On line 81 of ExclusiveDutchOrderReactor.sol On line 75 of SwapRouter02Executor.sol On line 79 of SwapRouter02Executor.sol  To improve gas consumption, readability and code quality, consider refactoring wherever possible, carefully reviewing the entire codebase and making sure the test suite still passes.  Update: Partially resolved in pull request #198 at commit b0d62e3. The prefix increment operator is now being used. The second suggestion was disregarded in favor of code readability. The change of validation logic was not applied because the Uniswap team preferred the current execution flow and they did not want to prioritize one check over the other. The recommendation of reading array lengths from the stack rather than from memory when looping was not applied since on the current test suite, given the low expected iterations on these loops, it showed an increase in gas usage rather than actual savings.", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Usage of Insecure Approval Functions", "body": "Usage of Insecure Approval Functions", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#usage-of-insecure-approval-functions", "labels": ["OpenZeppelin"]}, {"title": "Recommendations", "body": "Conclusion  Summary  DeFi  From 2023-07-31  To 2023-08-11  Solidity  16 (10 resolved, 1 partially resolved)  0 (0 resolved)  0 (0 resolved)  2 (1 resolved)  8 (6 resolved)  6 (3 resolved, 1 partially resolved)        Scope  We audited the Uniswap/UniswapX repository at the 7c5e359 commit.  src/\u251c\u2500 base/\u2502  \u251c\u2500 ProtocolFees.sol\u2502  \u251c\u2500 ReactorEvents.sol\u2502  \u2514\u2500 ReactorStructs.sol\u251c\u2500 external/\u2502  \u2514\u2500 ISwapRouter02.sol\u251c\u2500 interfaces/\u2502  \u251c\u2500 IProtocolFeeController.sol\u2502  \u251c\u2500 IReactor.sol\u2502  \u251c\u2500 IReactorCallback.sol\u2502  \u2514\u2500 IValidationCallback.sol\u251c\u2500 lens/\u2502  \u2514\u2500 OrderQuoter.sol\u251c\u2500 lib/\u2502  \u251c\u2500 CurrencyLibrary.sol\u2502  \u251c\u2500 DutchDecayLib.sol\u2502  \u251c\u2500 DutchOrderLib.sol\u2502  \u251c\u2500 ExclusiveDutchOrderLib.sol\u2502  \u251c\u2500 ExclusivityOverrideLib.sol\u2502  \u251c\u2500 LimitOrderLib.sol\u2502  \u251c\u2500 OrderInfoLib.sol\u2502  \u251c\u2500 Permit2Lib.sol\u2502  \u2514\u2500 ResolvedOrderLib.sol\u251c\u2500 reactors/\u2502  \u251c\u2500 BaseReactor.sol\u2502  \u251c\u2500 DutchOrderReactor.sol\u2502  \u251c\u2500 ExclusiveDutchOrderReactor.sol\u2502  \u2514\u2500 LimitOrderReactor.sol\u251c\u2500 sample-executors/\u2502  \u2514\u2500 SwapRouter02Executor.sol\u2514\u2500 sample-validation-contracts/   \u2514\u2500 ExclusiveFillerValidation.sol  System Overview  The UniswapX Protocol operates as a non-custodial trading framework based on Dutch auctions. It seamlessly combines on-chain and off-chain liquidity, protects swappers from MEV by making them participants via price enhancement, and enables gas-less swaps. Traders create signed orders detailing their swap requirements, while participants known as fillers employ arbitrary strategies to fulfill these orders by competing with each other.  Orders  UniswapX leverages  Permit2  , a token approval contract introducing signature-based approvals and transfers for ERC-20 tokens without the need for them to be compliant with  EIP-2612  . Swappers must approve the  Permit2  contract first for each token, but this only needs to be done once. After that, instead of self-submitting transactions, they sign orders which are shared via API to a network of fillers (MEV searchers, market makers, or other on-chain agents). Fillers send them to a specific reactor contract, which settles orders ensuring that trade execution aligns with user expectations and reverts non-compliant trades. The gas-less experience for the swapper is achieved because the fillers are the ones submitting orders on-chain, covering the gas fees on their behalf. This cost is recouped, in addition to a small profit on the trade itself, by factoring it into the execution price.  UniswapX incorporates the logic to manage three distinct order types by providing three different reactor contracts, each of which presents its own unique fulfilment rules.  Reactors  Reactor contracts share the main logic, but they differ in the type of orders they are managing and the validations they perform. All of them have four entry points, so that fillers can have enough flexibility to execute single orders or batches of orders in a sequential fashion. In both cases, fillers can also decide whether they want to get a callback in order to perform arbitrary strategies to get the funds on-chain. Alternatively, fillers have the option of filling orders directly with no callbacks. Either way, fillers need to grant prior approval to the reactor contract, as it will transfer the input tokens to them and pull the output tokens directly from their account to the swapper's address.  Prior to the input token transfer, a validation takes place ensuring the order has not expired and addresses the correct reactor. Further custom validation can be enabled by the swapper through an additional callback.  There are currently three different types of reactors. Their differences are described below.  Dutch Order Reactor  Dutch orders are designed to optimize swapper execution price versus simply choosing an AMM, by closely emulating the mechanics of a Dutch auction. The intrinsic feature of Dutch orders lies in the execution price decaying over time, fostering a competitive environment among fillers to swiftly secure the most favorable price for swappers while maintaining a modest profit margin. Fillers are incentivized to fill these orders as soon as it is profitable for them to do so. If a filler decides to wait for the decay to grow larger in order to make a larger profit, another filler may jump in and fill the order first for a more modest profit.  Exclusive Dutch Order Reactor  An exclusive Dutch order introduces a temporary exclusivity period before the linear decay of the execution price begins. This innovative mechanism provides a specific filler with a timeframe to engage with the order without any decay nor any other competitor being able to fill the order at that price. However, in order to always respect the swappers' best interest, there are settings in place to enable any other filler to jump in and provide a better price, provided that this price improvement is large enough.  Once the exclusivity period concludes, the order seamlessly transitions into a standard linear- decay phase as if it was a standard Dutch order.  Limit Order Reactor  In contrast to ", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#recommendations", "labels": ["OpenZeppelin"]}, {"title": "Monitoring Recommendations", "body": "While audits help in identifying code-level issues in the current implementation and potentially the code deployed in production, the Uniswap team is encouraged to consider incorporating monitoring activities in the production environment. Ongoing monitoring of deployed contracts helps identify potential threats and issues affecting production environments. With the goal of providing a complete security assessment, the monitoring recommendations section raises several actions addressing trust assumptions and out-of-scope components that can benefit from on-chain monitoring.  Access Control  Medium:  Regarding issue  L-02  , consider monitoring the  ProtocolFeeControllerSet  event to track when  FeeController  address has been changed unexpectedly. While this means that the account has been compromised, in the audited version a malicious change could manipulate the returning fees and thereby halt the trading activity.  Technical  Low:  Regarding the recommendation of  L-02  , if an event is implemented as a reaction to a wrong fee, consider monitoring it to be alerted about bugs in the  FeeController  Suspicious Activity  Medium: Consider monitoring the parametrization of orders for outlier detection. Activity outside the norm, such as a rapid linear decay or no duration (see L-03), can indicate malicious intent by the quoter to trick the swapper in signing an adverse order to make an exceptional profit. Note that due to the inherent filler competition this is rather applicable for exclusive Dutch orders.  Low: As of now, the allowed order reactors in UniswapX need to be explicitly enabled. In the future, this restriction may be lifted, allowing for arbitrary reactor contracts to be used. Consider monitoring that these reactors do not pose a threat for swappers or fillers if they are injected maliciously.", "html_url": "https://blog.openzeppelin.com/uniswapx-audit#monitoring-recommendations", "labels": ["OpenZeppelin"]}, {"title": "safeApproveAllTokens Implementation Differs From Documentation", "body": "comments specify that the function should approve the Balancer pool to transfer all supported assets from the strategy, as well as approve the  withdraw an unlimited number of BPTs.  Consider correcting the safeApproveAllTokens function to follow its intended behavior.  Update: Resolved in pull request #1776.", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#safeapprovealltokens-implementation-differs-from-documentation", "labels": ["OpenZeppelin"]}, {"title": "withdrawAll Function Can Withdraw Unsupported Tokens", "body": "In the BalancerMetaPoolStrategy, the withdrawAll implementation retrieves the pool tokens and iterates through them, calculating the expected minimum amounts out. These calculated amounts are used for exiting the pool, where tokens are received in exchange for BPTs.  While these calculations are correct, if the intention is to withdraw across all tokens supported by the pool, they are incorrect when the assets supported by the strategy are a subset of the assets in the Balancer pool.  During initialization, the BaseBalancerStrategy passes a list of tokens to the InitializableAbstractStrategy, which in turn populates the assetsMapped array. This array contains the strategy's supported assets and is not guaranteed to include all assets supported by the associated Balancer pool.  When exiting, consider only withdrawing assets that are supported by the strategy to prevent ending up with assets that are not accounted for and could potentially become stuck.  Update: Resolved. The Origin team stated:  We decided not to make any changes. While we agree with the identified problem, our strategy currently does not support a configuration where only a subset of the pool's assets can be supported.", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#withdrawall-function-can-withdraw-unsupported-tokens", "labels": ["OpenZeppelin"]}, {"title": "getBPTExpected Calculation Is Not Robust", "body": "The getBPTExpected functions are used to calculate the minimum amount of BPTs to receive when depositing liquidity, or the maximum amount of BPTs to provide when withdrawing liquidity. They calculate the underlying ETH value of the assets to deposit/withdraw, and divide it by the price of a BPT in terms of the pool's underlying base asset.  There are two issues with this:  Based on which oracles are being used, the strategy's asset price might be stale, which will result in an over/underestimation of the correct number of BPTs.  The calculation assumes normal market conditions, namely that the pool's underlying base asset is trading at 1-1 parity with ETH. stETH or frxETH depegging from ETH would make this untrue, resulting in an overestimation of the amount of BPTs.  Overestimating the BPT amount can result in reverts during deposits while underestimating them can result in reverts during withdrawals. Consider accurately calculating the exact number of BPTs required for these operations using Balancer's StableMath.  Update: Resolved in pull request #1795. The Origin team identified the additional concern of MEV attacks and stated:  We have decided to move the primary responsibility of defending against MEV attacks back to the ValueValueChecker as our other strategies do. Only the strategist can deposit/withdraw funds and fork tests have been added confirming that the VaultValue checker used by the strategist catches MEV attack attempts. The checks in deposit/withdraw are now secondary sanity checks to prevent large losses and work without oracles. We can repay our debts in depegged coins, so we are not in danger of insolvency even if the pool mix changes. We did not implement the suggested math that would copy the math that the Balancer pool does under the hood since it would not protect the protocol against MEV sandwich attacks.  Medium Severity", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#getbptexpected-calculation-is-not-robust", "labels": ["OpenZeppelin"]}, {"title": "Non-Comprehensive Test Suite", "body": "The current test suite does not cover all the functionality in the BalancerMetaPoolStrategy.  There are no tests for deposit, only for depositAll. This can be problematic, as supplying only one token at a time will incur more slippage and potentially return fewer BPTs than expected, as opposed to joining the Balancer pool with multiple supported assets at the same time.  There are no tests for safeApproveAllTokens.  There are no tests to ensure that BAL and AURA tokens are actually rewarded when calling collectRewardTokens.  Additionally, because of the significant number of external dependencies, there are multiple corner cases that are not covered in the existing test suite:  If price oracles become stale and report outdated prices  If withdrawAll is called when supported strategy assets are a subset of the pool's assets  Based on different deposited/withdrawn values as well as oracle staleness, what maxDepositSlippage and maxWithdrawalSlippage should be in order to prevent DoS while depositing and withdrawing  Whether the underlying value of the Strategy will be reported correctly irrespective of the liquidity pool being balanced  Additional tests would not only help maintain the correctness of the codebase when changes are implemented but would also serve as documentation for developers and auditors, aiding them in understanding multiple possible scenarios. Consider increasing the test coverage, especially around scenarios that deviate from normal operation.  Update: Resolved in pull request #1780. The Origin team stated:  1. The deposit test has not been added because single-asset deposits have been disabled.2. The test for safeApproveAllTokens has been added.3. The BAL and AURA harvesting test has been added.4. maxDepositSlippage and how it affects oracle prices: We are no longer using oracles so this portion is skipped. Changing maxDepositSlippage (now maxDepositDeviation) is tested in H-03. Also, the maxDepositDeviation is much more lenient now as VaultValueChecker has become the line of defense against MEV.5. Whether the underlying value of the Strategy will be reported correctly, irrespective of the liquidity pool being balanced: initial test added in H-03's pull request and enhanced via a separate commit.6. Stale oracle prices test: skipped since we do not use oracles.7. withdrawAll on a subset of assets: no test since this functionality is not yet supported.", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#non-comprehensive-test-suite", "labels": ["OpenZeppelin"]}, {"title": "Withdrawal May Revert Because of Rounding Errors", "body": "The _withdraw function redeems BPTs from the Balancer pool in exchange for exact _amounts of tokens, which are then sent to the Vault. This is not a straightforward process, and involves at least two steps which introduce precision loss, potentially reverting the function upon safeTransfer.  Balancer has been found to round down by 1 WEI even when provided more than enough BPTs for the required liquidity. It has been observed to return only 1 less WEI so far, but that is not a guarantee. To circumvent this issue, the strategy overshoots the required liquidity by 2 WEI.  If the strategy asset to be withdrawn is a rebasing asset, it only exists as a wrapped version in the Balancer pool. Hence, the strategy calculates how much wrapped asset should be withdrawn from Balancer, withdraws it and then unwraps to the strategy asset. Because wrapping/unwrapping assets usually rounds in favor of the system (the wstETH and sfrxETH smart contracts), this method of calculation might also result in slightly fewer units of the required strategy asset.  Consider adding a fuzz test to have a greater certainty that rounding errors will not result in a denial-of-service of the _withdraw function, or requesting an error-adjusted amount of liquidity when exiting the Balancer pool.  Update: Acknowledged, will resolve in pull request #1801. The Origin team stated:  The pull request adds more fork test cases. We have fuzzing test infrastructure in development. Once that is done, we will add proper fuzzing tests, as suggested.", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#withdrawal-may-revert-because-of-rounding-errors", "labels": ["OpenZeppelin"]}, {"title": "Missing or Misleading Documentation", "body": "Throughout the codebase, there are multiple sections which are difficult to understand, and would benefit from additional or clearer documentation:  It was difficult to assert that reward tokens are actually rewarded to the strategy. Consider adding more details around how this happens, especially for the AURA tokens where the process is more complex and not intuitive to follow.  Given the intricacies of how Balancer works, as well as the need to wrap rebasing tokens, it was difficult to follow the math behind the getBPTExpected functions.  Consider adding a practical example, as well as explanations regarding what each variable means and what each price is measured in. Consider documenting why the Balancer read-only reentrancy check is not needed on deposit and withdrawal functions.  Additionally, while there was documentation around the addition of strategies using Balancer, it was at times misleading as it was not specifically targeted towards the BalancerMetaPoolStrategy, and hence would differ from the implementation that was audited. Consider creating documentation specific to the strategy at hand, explicitly and concisely explaining the design decisions behind each important piece.  Update: Resolved in pull request #1781 and pull request #1795.", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#missing-or-misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Providing or Withdrawing Liquidity One Asset at a Time Might Incur Considerable Price Impact", "body": "In the Balancer documentation, there is a section on risks which arise when using the platform. One section goes into detail about the potential loss of funds when entering and exiting pools.  #### Due to high price impact  When joining a pool, LPs should be aware of the price impact from adding tokens to the pool. In general, adding liquidity in proportional amounts to the token weights of the pool incur low price impact. Adding custom token amounts (non-proportionally) causes the internal prices of the pool to change, as if you were swapping tokens. The higher the price impact the more you'll spend in swap fees.  In the BalancerMetaPoolStrategy, there are multiple deposit function signatures, one of which deposits a single asset adding liquidity to the pool in a non-proportional amount. This function is integrated with the VaultCore via the allocate function.  Aside from the gas inefficiencies of sequential deposits, it is possible that, because of the swap fees incurred when swapping the provided token for all the others in the Balancer pool, considerably fewer BPTs will be returned than the allowed maxDepositSlippage and maxWithdrawSlippage, potentially DOSing single-token deposits and withdrawals. Hence, the maxDepositSlippage and maxWithdrawSlippage variables might need to be different, depending on whether the called functions deal with multiple pool assets at once.  Note that the above problem also applies when exiting a pool during withdrawals.  Consider always depositing/withdrawing all tokens simultaneously to avoid any reverts and inefficiencies as well as to comply with the best practices defined by the Balancer protocol.  Update: Acknowledged, will resolve. The Origin team stated:  We are aware of this shortcoming and have decided not to fix this issue. Thanks for being thorough and identifying it. Deposits are fine - we have only been planning on using depositAll, which does support multiple coins at once. We have disabled the single asset deposits for this strategy as they will never be used by VaultCores allocate function (we never plan on enabling this strategy as an asset default strategy). We plan on adding support for multi-asset withdrawals for all strategies in the future and Balancers strategy will get the upgrade at that time, and with that, also gain the benefits of lower gas costs and better capital efficiency. MaxWithdrawal / DepositSlippage is now a lot more lenient (default setting of 1% instead of 0.1%). As per the solution in H-03, the VaultValue checker will be catching any irregularities (MEV attack attempts).  Low Severity", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#providing-or-withdrawing-liquidity-one-asset-at-a-time-might-incur-considerable-price-impact", "labels": ["OpenZeppelin"]}, {"title": "Magic Numbers Are Used", "body": "In the BalancerMetaPoolStrategy contract, the value of 1e50 is used for setting approvals on both stETH and frxETH. There is no clear motivation as to why this number is selected, and the contract lacks inline documentation to clarify its significance.  Consider defining and documenting a constant variable to represent this number, as it is used in multiple places. Following Solidity's style guide, constants should be named in UPPER_CASE_WITH_UNDERSCORES format.  Update: Resolved in pull request #1782.", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#magic-numbers-are-used", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "Throughout the codebase, there are multiple variables named similarly but with vastly different meanings, which makes it difficult for the reader to understand the context. A non-comprehensive list of these is:  When depositing or withdrawing, _assets and _amounts could be changed to _strategyAssets and _strategyAssetsAmounts.  mappedAmounts and mappedAssets could be changed to strategyAssetsToPoolAssets and strategyAssetsAmountsToPoolAssetsAmounts. mappedAssets is especially confusing, as it is very similar to the strategy's assetsMapped, which has a completely different function.  asset and amount could be changed to strategyAsset and strategyAssetAmount.  wrappedAssetAmounts could be changed to strategyAssetsAmountsToPoolAssetsAmounts.  vaultAsset could be changed to strategyAsset.  asset could be changed to strategyAsset, or something consistent with the naming previously used.  assetAmount could be changed to poolAssetAmountToStrategyAssetAmount.  poolAmountsOut could be changed to poolAssetsAmountsOut.  In order to improve readability and better convey the code's intentions to the reader, consider modifying variable names to be more aligned with the codebase, while using these suggestions as potential guidelines.  Update: Resolved in pull request #1783.", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Unused Function", "body": "The checkBalance function is only used in tests.  Consider removing it from the production code in order to improve readability.  Update: Acknowledged, will resolve. The Origin team stated:  We plan on using this read-only function in the future since it will be a much more gas-efficient way of calculating the vault's totalValue.", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#unused-function", "labels": ["OpenZeppelin"]}, {"title": "Strategy Can Withdraw Unsupported Assets", "body": "In the _deposit function, tokens are checked to ensure they are supported before being deposited into Balancer pools. However, the _withdraw function lacks this check. If the assets supported in the strategy are a subset of the tokens in the Balancer pool, it can result in withdrawing an asset that is not supported by the strategy.  Consider only allowing callers to withdraw assets that are supported by the strategy.  Update: Resolved in pull request #1784.  Notes & Additional Information  Unused Import  The IERC20Details and IRETH files are unused. Consider removing them to maintain a cleaner codebase.  Update: Resolved in pull request #1785.  Gas Inefficiencies  There are several places across the codebase where changes can be made to improve gas consumption.  The amount = 0; assignment is unnecessary.  There is another, more efficient version of the fromPoolAsset function that can be used when the amount is not needed. Consider switching to it instead.  The assetAmount variable is unused, consider removing it.  In the withdraw function, the conversion to a pool asset depends only on poolAssets[i]. Consider doing it only once per pool asset, outside of the for loop that goes through the strategy assets.  The asset variable can be reused here, to avoid another array access through _assets[i].  There are several places where function parameters could be marked as calldata, consider changing them for future gas optimizations: deposit, _deposit, withdraw, _withdraw, and getBPTExpected.  There are multiple instances of an array's length being accessed on every iteration of a loop. This can be made more efficient by saving off the length of the array in a local variable and using that in the for loop instead.  When performing these changes, aim to reach an optimal trade-off between gas optimization and readability. Having a codebase that is easy to understand reduces the chance of errors in the future and improves transparency for the community.  Update: Resolved in pull request #1786.  TODO Comments  The following instances of TODO comments were found in the codebase:  The TODO comment on line 296 in BalancerMetaPoolStrategy.sol  The TODO comment on line 380 in BalancerMetaPoolStrategy.sol  During development, having well-described TODO comments will facilitate the process of tracking and solving them. Without this information these comments may age and important information for the security of the system could be forgotten by the time it is released to production.  Consider removing all instances of TODO comments and instead tracking them in the issues backlog. Alternatively, consider linking each inline TODO to the corresponding issues backlog entry.  Update: Resolved in pull request #1796.  Inconsistent Function Naming  In the BaseBalancerStrategy some internal functions start with a leading underscore while others do not.  The use of standard conventions can quickly convey information to developers and users alike. Consider standardizing a naming convention for private and internal functions. A leading underscore is recommended, as mentioned in the Solidity documentation.  Update: Partially resolved in pull request #1797. Some internal functions have not been updated with leading underscores.  mappedAssets Is Initialized With Wrong Length  In the _deposit function, the length of mappedAmounts and mappedAssets is initialized to tokens.length. This is superfluous if only a subset of the Balancer pool's tokens are supported by the strategy.  While this currently does not present a security risk, consider initializing the array to the correct length.  Update: Resolved in pull request #1800.  Typographical Error  Consider addressing the following typographical error in the codebase:  sent should be send.  Update: Resolved in pull request #1798.  Client-Reported  Balancer Pool tokens Can Remain in the Strategy After Withdrawing Funds  Withdrawing assets from the strategy calculates maxBPTtoWithdraw , namely how many BPTs should be redeemed with Balancer, in order to get the required liquidity back. Based on Oracle price staleness, this number might be slightly higher than the actual required amount. This means that there could be leftover BPTs in the Strategy contract, after most of them have been spent exiting the Balancer pool. This results in sub-optimal yield generation, as these BPTs should be re-deposited into Aura.  Update: Resolved at commit b9dd480 and documented at commit 6ad405c.  checkBalance Assumes Normal Market Conditions  balance of BPTs held by their  price, in terms of the pool's underlying base asset. The functions assume normal market conditions, meaning the underlying base asset is at 1-1 parity with ETH. This is not the case if  Update: Partially resolved. Upon conducting additional research, the Origin team stated:  The requirements we would like the checkBalance function to meet:  (critical) Flash loan pool manipulation must not change the total value of units (normalized assets) returned", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#strategy-can-withdraw-unsupported-assets", "labels": ["OpenZeppelin"]}, {"title": "Unused Files", "body": "Unused Files", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#unused-files", "labels": ["OpenZeppelin"]}, {"title": "Gas Inefficiencies", "body": "There are several places across the codebase where changes can be made to improve gas consumption.  The amount = 0; assignment is unnecessary.  There is another, more efficient version of the fromPoolAsset function that can be used when the amount is not needed. Consider switching to it instead.  The assetAmount variable is unused, consider removing it.  In the withdraw function, the conversion to a pool asset depends only on poolAssets[i]. Consider doing it only once per pool asset, outside of the for loop that goes through the strategy assets.  The asset variable can be reused here, to avoid another array access through _assets[i].  There are several places where function parameters could be marked as calldata, consider changing them for future gas optimizations: deposit, _deposit, withdraw, _withdraw, and getBPTExpected.  There are multiple instances of an array's length being accessed on every iteration of a loop. This can be made more efficient by saving off the length of the array in a local variable and using that in the for loop instead.  When performing these changes, aim to reach an optimal trade-off between gas optimization and readability. Having a codebase that is easy to understand reduces the chance of errors in the future and improves transparency for the community.  Update: Resolved in pull request #1786.", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#gas-inefficiencies", "labels": ["OpenZeppelin"]}, {"title": "TODO Comments", "body": "The following instances of TODO comments were found in the codebase:  The TODO comment on line 296 in BalancerMetaPoolStrategy.sol  The TODO comment on line 380 in BalancerMetaPoolStrategy.sol  During development, having well-described TODO comments will facilitate the process of tracking and solving them. Without this information these comments may age and important information for the security of the system could be forgotten by the time it is released to production.  Consider removing all instances of TODO comments and instead tracking them in the issues backlog. Alternatively, consider linking each inline TODO to the corresponding issues backlog entry.  Update: Resolved in pull request #1796.", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#todo-comments", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Function Naming", "body": "In the BaseBalancerStrategy some internal functions start with a leading underscore while others do not.  The use of standard conventions can quickly convey information to developers and users alike. Consider standardizing a naming convention for private and internal functions. A leading underscore is recommended, as mentioned in the Solidity documentation.  Update: Partially resolved in pull request #1797. Some internal functions have not been updated with leading underscores.", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#inconsistent-function-naming", "labels": ["OpenZeppelin"]}, {"title": "mappedAssets Is Initialized With Wrong Length", "body": "In the _deposit function, the length of mappedAmounts and mappedAssets is initialized to tokens.length. This is superfluous if only a subset of the Balancer pool's tokens are supported by the strategy.  While this currently does not present a security risk, consider initializing the array to the correct length.  Update: Resolved in pull request #1800.", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#mappedassets-is-initialized-with-wrong-length", "labels": ["OpenZeppelin"]}, {"title": "Typographical Error", "body": "Consider addressing the following typographical error in the codebase:  sent should be send.  Update: Resolved in pull request #1798.", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#typographical-error", "labels": ["OpenZeppelin"]}, {"title": "Client-Reported", "body": "Balancer Pool tokens Can Remain in the Strategy After Withdrawing Funds  Withdrawing assets from the strategy calculates maxBPTtoWithdraw , namely how many BPTs should be redeemed with Balancer, in order to get the required liquidity back. Based on Oracle price staleness, this number might be slightly higher than the actual required amount. This means that there could be leftover BPTs in the Strategy contract, after most of them have been spent exiting the Balancer pool. This results in sub-optimal yield generation, as these BPTs should be re-deposited into Aura.  Update: Resolved at commit b9dd480 and documented at commit 6ad405c.  checkBalance Assumes Normal Market Conditions  balance of BPTs held by their  price, in terms of the pool's underlying base asset. The functions assume normal market conditions, meaning the underlying base asset is at 1-1 parity with ETH. This is not the case if  Update: Partially resolved. Upon conducting additional research, the Origin team stated:  The requirements we would like the checkBalance function to meet:  (critical) Flash loan pool manipulation must not change the total value of units (normalized assets) returned by looping through and adding all the supported pool asset balances together.  (important) checkBalance must report accurate amounts proportional to the share of assets held in the underlying Balancer pool.  Conclusion: with the researched approaches, we are able to satisfy only one of the above requirements. We can borrow Balancers pool math and calculate the precise amount of assets (the strategy is able to withdraw in any market condition). Unfortunately, such an approach is vulnerable to flash loan sandwich attacks that tilt the pool heavily toward one asset. And while the second requirement would be satisfied, the first one would not be.  For this reason, we have decided to implement a solution that satisfies the first requirement and reports the same token balances no matter the share distribution of the assets in the underlying pool. This does not satisfy the second condition, which makes allocations and correctness regarding withdrawable underlying assets incorrect.  Conclusion  Several high and medium-severity issues were identified. Additionally, suggestions have been made to increase the overall readability and cleanliness of the codebase.  We strongly advise implementing a comprehensive test suite around functionality calculating the underlying value of the strategy. Additionally, the provided documentation has been lacking and confusing at times, as it was not up-to-date with the implementation. We encourage employing better practices around documenting the design decisions behind key functionality and keeping such documentation up-to-date.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#client-reported", "labels": ["OpenZeppelin"]}, {"title": "Balancer Pool Tokens Can Remain in the Strategy After Withdrawing Funds", "body": "Balancer Pool Tokens Can Remain in the Strategy After Withdrawing Funds", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#balancer-pool-tokens-can-remain-in-the-strategy-after-withdrawing-funds", "labels": ["OpenZeppelin"]}, {"title": "checkBalance Assumes Normal Market Conditions", "body": "balance of BPTs held by their  price, in terms of the pool's underlying base asset. The functions assume normal market conditions, meaning the underlying base asset is at 1-1 parity with ETH. This is not the case if  Update: Partially resolved. Upon conducting additional research, the Origin team stated:  The requirements we would like the checkBalance function to meet:  (critical) Flash loan pool manipulation must not change the total value of units (normalized assets) returned by looping through and adding all the supported pool asset balances together.  (important) checkBalance must report accurate amounts proportional to the share of assets held in the underlying Balancer pool.", "html_url": "https://blog.openzeppelin.com/origin-balancer-metapool-audit#checkbalance-assumes-normal-market-conditions", "labels": ["OpenZeppelin"]}, {"title": "Front-Running redeem Can Prevent From Receiving Rewards for Allocations", "body": "Front-Running redeem Can Prevent From Receiving Rewards for Allocations", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#front-running-redeem-can-prevent-from-receiving-rewards-for-allocations", "labels": ["OpenZeppelin"]}, {"title": "redeem Lacks Slippage Protection", "body": "The redeem function in Escrow.sol contains the logic to determine the amount of GRT rewards an Indexer will receive as the minimum of the currently available escrow balance and the aggregated amount in the voucher. This allows slippage to occur against the Indexer (i.e., the Indexer may get less than what is deemed acceptable).  The redeem function does not allow the Indexer to specify an expected amount of rewards to receive. Therefore, it is possible that the Indexer receives fewer rewards than expected, at which point the voucher that was worth more has been used and cannot be re-used. This could surprise the Indexer, who may have otherwise expected the call to revert if the full reward amount could not be given to them.  Consider adding a parameter to the redeem function that allows the caller to specify an expected reward amount. If the calculated amount is not greater than or equal to the expected amount, the call should revert.  Update: Partially resolved in pull request #61. The Graph's core developers stated:  We decided to leave the code as is (option #2). This allows flexibility while maintaining a low gas cost. We have updated the inline documentation to detail the expectations of Indexers during thaws and redeems. Some context for the decision: Whenever a thaw commences and threatens to reduce the escrow account below the owed amount, the Indexer software should promptly act to close any pending RAVs with that gateway. Otherwise, the Indexer should act as if anything being thawed has already been withdrawn. Complete transparency exists regarding an account: Indexers can verify values anytime, and numerous events (like deposit, thaw, withdraw, redeem, and other account interactions) are signaled. The only methods to withdraw money from an account are either under the Indexer's control (redeem) or are subject to a time-lock (withdraw). The associated issue can be found here.", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#redeem-lacks-slippage-protection", "labels": ["OpenZeppelin"]}, {"title": "Signed Messages Can Be Replayed", "body": "In both the verifyProof and verifyAuthorizedSignerProof functions, the messageHash does not include the chainId. Since the project will be deployed on both Ethereum and Arbitrum networks, the same signed message intended for one chain can be replayed on the other chain.  Consider adding the chainId, as well as the nonce or deadline to the message's content when generating proofs to ensure that signed messages are only used on the intended blockchain, and not replayable multiple times.  Update: Resolved in pull request #56. The Graph's core developers stated:  Thank you for highlighting this issue. After several discussions, we fixed this by adding a chainID to the allocationID proof (a deadline is not needed since a used allocationID cannot be unset). The authorized signer proof needs a chainID and a deadline because signers can be revoked, which could enable a possible replay attack. The associated issue can be found here.", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#signed-messages-can-be-replayed", "labels": ["OpenZeppelin"]}, {"title": "Vesting Contracts Cannot Call redeem", "body": "a vesting contract, which enables them to be awarded GRT over a period of time and still utilize the tokens for staking, curating, and delegating. In order to prevent the awarded GRT from escaping the vesting lock before the end of the vesting period, the smart contract restricts function calls and function call targets to only those approved by The Graph. Therefore, Indexers that are vesting contracts would initially be unable to call  redeem  caller of the function.  Update: Resolved in pull request #58. The Graph's core developers stated:  This issue is fixed with the same solution as C-01, linking it to the same pull request. The associated issue can be found here.  Low Severity", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#vesting-contracts-cannot-call-redeem", "labels": ["OpenZeppelin"]}, {"title": "Lack of Integration Tests With Existing Contracts", "body": "TAP contracts are tested against mocks of The Graph's contracts (such as Staking), which works well for unit tests. However, having integration tests that test against the deployed contracts with varied inputs, such as using different fee-tiers, ensures there are no undesirable side effects to other parts of the ecosystem.  Update: Acknowledged, will resolve. The Graph's core developers stated:  Thank you for raising this issue. We will not be addressing it now, as we are going to do thorough integration tests after the audit. They are going to be part of a larger Scalar TAP deployment plan and it is going to be a joint effort between Semiotic Labs, Edge & Node and The Graph Foundation.", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#lack-of-integration-tests-with-existing-contracts", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Event Emission", "body": "thaw function in  Update: Resolved in pull request #54 at commit 73efad0. The Graph's core developers stated:  We added a check for the thaw request amount to be greater than 0. In the first pull request #54, we checked if amount <= 0, but as it is a uint256, we modified this to check if == 0, along with the thaw fixes, pointing to the last commit. The associated issue can be found here.", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#unnecessary-event-emission", "labels": ["OpenZeppelin"]}, {"title": "push0 OPCODE Incompatible With Arbitrum", "body": "EIP-3855) is implemented in the latest Shanghai EVM version, which is the default version for the Solidity compiler  not yet support the  Update: Resolved in pull request #55. The Graph's core developers stated:  We capped the Solidity version to 0.8.18. The associated issue can be found here.", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#push0-opcode-incompatible-with-arbitrum", "labels": ["OpenZeppelin"]}, {"title": "thawSigner May Be Ineffective", "body": "The thawSigner function in Escrow.sol allows a sender to initiate the process of revoking authorization from a signer address. After initiating thawSigner, the signer can continue to sign vouchers that can be redeemed until the signer is revoked.  This process allows a sender to initiate thawSigner as soon as the signer is authorized. After the thaw period is over, the sender has full discretion on when to revoke the signers, which can take effect immediately. This consequently disables the redemption of any vouchers signed by the address without a grace period. The grace period during which any signed vouchers by the outgoing signer can be redeemed is thus rendered ineffective. Further, there is no way to cancel this action, which hinders the user experience.  Consider reassessing the effectiveness of thawSigner and revokeAuthorizedSigner's functionality, and decide whether they can be removed.  Update: Partially resolved in pull request #59. The Graph team stated:  Thank you for posting this issue. After discussing this with our partners from Edge & Node, we concluded that we do not fully align with the problem's statement. As the thawSigner will be called from the Indexer software, we decided to enhance its documentation to provide more meaningful details. \"Thawing a signer\" is designed to alert Indexers that signatures from that signer will soon be deemed invalid. Indexers without existing signed receipts or RAVs from this signer should, in essence, treat them as unauthorized. Those with existing signed documents from this signer should work towards settling their engagements. They can either initiate an RAV request using the signed receipts (with a new signer in place), redeem their most recent RAV, or request a new RAV associated with a different signer. Once a signer is thawed, they should, for all practical reasons, be viewed as revoked regardless of their revocation status. Given this context, we are confident in the current implementation's efficacy in serving as an alert mechanism, especially with the emitted event and provided grace period, which lets Indexers act accordingly. While we do not plan on altering the code based on this suggestion, we will enhance our documentation to ensure such expectations are conveyed transparently. The associated issue can be found here.", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#thawsigner-may-be-ineffective", "labels": ["OpenZeppelin"]}, {"title": "Retrieving Escrow Account Details via Signers Can Be Misleading", "body": "getEscrowAccountFromSignerAddress  Consider reverting with an error message indicating that the signer is no longer authorized.  Update: Resolved in pull request #53. The Graph's core developers stated:  It was previously ambiguous as to whether getEscrowAccountFromSignerAddress returned zero values because the account is empty or the signer is not actually authorized (possibly revoked). This fixes that by reverting with a custom error if the signer is not authorized. The associated issue can be found here.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#retrieving-escrow-account-details-via-signers-can-be-misleading", "labels": ["OpenZeppelin"]}, {"title": "Unused Import", "body": "In TAPVerifier.sol, the import Address is unused and could be removed.  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #47. The Graph's core developers stated:  We removed the Address import. The associated issue can be found here.", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#unused-import", "labels": ["OpenZeppelin"]}, {"title": "Sender Is Unable to Decrease the Thaw Amount or Cancel the Thaw", "body": "only increase the value to be withdrawn from an  withdraw  Update: Resolved in pull request #52. The Graph's core developers stated:  If the requested amount is zero, any thawing in progress will be cancelled. If the requested amount is greater than zero, any thawing in progress will be cancelled and a new thawing request will be initiated. The associated issue can be found here.", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#sender-is-unable-to-decrease-the-thaw-amount-or-cancel-the-thaw", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "The following typographical errors were identified:  Consider correcting reciever to receiver.  Consider correcting neccessary to necessary.  Update: Resolved in pull request #51. The Graph's core developers stated:  The associated issue can be found here.", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "unchecked Arithmetic Blocks", "body": "The following arithmetic in Escrow.sol occurs in unchecked blocks:  Line 263  Line 387  There does not appear to be an underflow risk in the logic as the amount deducted is always less than or equal to the escrow balance. Inserting mathematical operations inside an unchecked block will reduce the amount of gas used in a transaction. However, in case of unpredictable scenarios (e.g., unknown compiler issues), having an underflow in the balance variable would be disastrous. We recommend a safer approach by removing the unchecked block to allow the compiler to insert overflow and underflow guards  Update: Resolved in pull request #50. The Graph's core developers stated:  We agree it is not worth the risk to save the gas costs. The associated issue can be found here.", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#unchecked-arithmetic-blocks", "labels": ["OpenZeppelin"]}, {"title": "Signature Does Not Fully Comply With EIP-712", "body": "The signature for a Receipt Aggregate Voucher (RAV) is intended to be compliant with EIP-712. However, there is a discrepancy in the typeHash. Per EIP-712, the typeHash includes the encodeType for a struct, which is encoded as:  The type of a struct is encoded as name \u2016 \"(\" \u2016 member\u2081 \u2016 \",\" \u2016 member\u2082 \u2016 \",\" \u2016 \u2026 \u2016 member \u2099 \")\" where each member is written as type \u2016 \" \" \u2016 name.  ReceiptAggregateVoucher, whereas the name of the corresponding struct defined in the contract is  ReceiptAggregationVoucher  Consider renaming the struct to be identical to the name used in the typeHash.  Update: Resolved in pull request #49. The Graph's core developers stated:  The ReceiptAggregationVoucher struct was renamed to ReceiptAggregateVoucher. The associated issue can be found here.", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#signature-does-not-fully-comply-with-eip-712", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Documentation", "body": "Line 50 of AllocationIDTracker.sol: The word 'collateral' should be changed to 'escrow' as it is referring to the renamed Escrow contract.  Line 71 of AllocationIDTracker.sol: The word 'collateral' should be changed to 'escrow' as it is referring to the renamed Escrow contract.  Line 29 of Escrow.sol: 'Block number' should be changed to 'Timestamp' as thawEndTimestamp represents a timestamp.  Line 34 of Escrow.sol: 'Block number' should be changed to 'Timestamp' as thawEndTimestamp represents a timestamp.  Consider addressing these instances of incorrect documentation.  Update: Resolved in pull request #48. The Graph's core developers stated:  Good catch, fixed. The associated issue can be found here.", "html_url": "https://blog.openzeppelin.com/thegraph-timeline-aggregation-audit#incorrect-documentation", "labels": ["OpenZeppelin"]}, {"title": "Unclear the Blocklist Limitations", "body": "The blocklist feature is meant to prevent some users from transferring USDM tokens. The list of blocked addresses is managed by any address with the BLOCKLIST_ROLE role.  All token transfers only ensure that the source of the tokens is not blocked. This has several implications:  blocked addresses can receive USDM tokens through the mint and transfer/transferFrom functions, but they cannot transfer them out.  addresses on the blocklist cannot have their tokens burned.  a blocked address still can spend a token allowance or grant allowances to other addresses, although the grantee will still not be able to transferFrom the blocked address.  Consider whether this is the expected behavior in all four functionalities (mint, transfer, burn and approvals) and whether the code should be updated accordingly. Moreover, consider explicitly documenting the behavior in all functions' docstrings.  Update: Resolved in commit 92584df. The Mountain Protocol confirmed that this is the desired behavior and expanded the smart contract documentation accordingly. They also stated:  In an effort to avoid increased gas fees on all users, a verification of destination blocked address has purposefully not been set in place. Users are expected to know parties they are transacting with and avoiding blocked addresses.  Low Severity", "html_url": "https://blog.openzeppelin.com/mountain-protocol-audit#unclear-the-blocklist-limitations", "labels": ["OpenZeppelin"]}, {"title": "Discontinuous Reward Pattern", "body": "Rebases occur by discontinuously increasing all user balances. This implies that a USDM token purchased immediately before the rebase transaction is worth more than one purchased immediately afterwards. In principle, this means that the price of USDM tokens should follow a sawtooth wave.  In practice, the effect size will be minimal because the daily interest rate is expected to be less than 0.02%. Nevertheless, we believe it is worth considering because:  The expected impact depends on external factors, such as the actual yield, the availability of Ethereum, the reliability and availability of Mountain Protocol's external infrastructure, any events that require pausing the contract, etc.  Any discontinuity creates front-running, back-running or transaction delay opportunities. In this case, a transfer of a fixed number of USDM is worth slightly less if executed after the update. Similarly, anyone who wants to spend an allowance would get more value if they spent it before the update. Even with a small effect size, it could introduce a new market behavior.  Consider whether it is worth the extra complexity to smooth the discontinuity. This would involve distributing the daily yield over time rather than in one step.  Update: Acknowledged, not resolved. The Mountain Protocol team stated:  Given the minimal effect size, smoothing the rebases is not worth the extra complexity. However, we will describe the edge case in our risk documentation.", "html_url": "https://blog.openzeppelin.com/mountain-protocol-audit#discontinuous-reward-pattern", "labels": ["OpenZeppelin"]}, {"title": "Misleading Comments", "body": "There are some places in the codebase where comments are either inaccurate or misleading.  The addRewardMultiplier has a comment that says that the input parameter _rewardMultiplier is the new rewardMultiplier value, but this is not true since it is actually an increment on top of it.  The setRewardMultiplier comment says it can be called by ADMIN_ROLE but it is actually DEFAULT_ADMIN_ROLE.  The comment above the _mint function says \"Internal function\" but it should be \"Private function\" instead.  To improve correctness and readability, consider fixing these examples and reviewing the codebase in case other comments can benefit from rephrasing.  Update: Resolved in commit fdaf392.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/mountain-protocol-audit#misleading-comments", "labels": ["OpenZeppelin"]}, {"title": "Dust Can Accumulate", "body": "To accommodate rebasing, the user-facing functions describe token amounts while the contract's own logic uses the equivalent amount of shares. Both conversion functions (convertToShares and convertToAmount) round down, which could lead to minor discrepancies.  For example, 0.1e18 USDM tokens at a rewardMultiplier of 1.2e18 will convert to 83333333333333333 shares, which will convert back to 99999999999999999 USDM tokens.  In the interest of safety, all rounding errors should be in favor of the protocol, and the contract correctly implements this heuristic. Nevertheless, the consequence is that all token transfers (including mint and burn operations) may transfer slightly less than expected. If a user attempted to transfer their entire balance, they could retain some shares in their wallet, corresponding to a fraction of a token.  Consider documenting this behavior in the docstrings so that users can be aware of it. In addition, consider whether a transferShares function (or possible transferAll function) should be included so that knowledgeable users can have finer control.  Update: Resolved in commit 4606704.", "html_url": "https://blog.openzeppelin.com/mountain-protocol-audit#dust-can-accumulate", "labels": ["OpenZeppelin"]}, {"title": "Imprecise Reward Multiplier Restriction", "body": "The _setRewardMultiplier function of the USDM contract ensures the parameter is not less than 1e18. This correctly represents 100%, since it is the same numeric value as the multiplier precision constant. Nevertheless, in the interest of predictability and local reasoning, consider using the existing constant in the validation.  Update: Resolved in commit 2e9b94c.", "html_url": "https://blog.openzeppelin.com/mountain-protocol-audit#imprecise-reward-multiplier-restriction", "labels": ["OpenZeppelin"]}, {"title": "Missing Interface", "body": "The USDM contract implements ERC-20 metadata functions but does not inherit the corresponding interface. Consider explicitly inheriting relevant interfaces to ensure consistency and to document the intended behavior.  Update: Resolved in commit a532c49.", "html_url": "https://blog.openzeppelin.com/mountain-protocol-audit#missing-interface", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "There are some names used throughout the codebase that might benefit from a change:  The convertToAmount function should be convertToToken. Both conversion functions use the term \"amount\" to describe both shares and tokens and it might be confusing.  The _rewardMultiplier input parameter of the addRewardMultiplier function should be something like _rewardMultiplierIncrement instead.  While the _blocklist mapping has an accurate name since it represents a list of blocked accounts, the blocklistAccounts and unblocklistAccounts functions might be just blockAccounts and unblockAccounts, since blocklist is not a verb. The same applies to the AccountBlocklisted and AccountUnblocklisted events.  Consider adopting the suggested naming conventions to improve the readability and clarity of the codebase.  Update: Resolved in commit 500a2c9.", "html_url": "https://blog.openzeppelin.com/mountain-protocol-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Reuse OpenZeppelin Implementation", "body": "The USDM contract reimplements a lot of functionality that is already available in the OpenZeppelin ERC20PermitUpgradeable contract with minor modifications to account for the rebasing logic. However, it would be simpler to inherit from the contract and introduce the modifications by overriding the relevant functions. Specifically, our suggestion is:  Treat the existing _balances and _totalSupply as the _shares mapping and _totalShares variable respectively. Since these are private values, the original names never need to be shown to the user.  Update the balance getter functions accordingly.  Update the _mint, _burn and _transfer functions to simply override and invoke the OpenZeppelin version, first converting the amount parameter to the equivalent number of shares.  Remove the obsolete variables and reimplemented code. This includes the metadata getters, transfer function and bottom third of the contract.  In this way, the USDM contract would only focus on the new functionality that it introduces.  Update: Acknowledged, not resolved. The Mountain Protocol team stated:  In the interest of code clarity and avoiding confusion, we do not want to record shares in the _balances mapping.", "html_url": "https://blog.openzeppelin.com/mountain-protocol-audit#reuse-openzeppelin-implementation", "labels": ["OpenZeppelin"]}, {"title": "Unexpected Storage Gap Size", "body": "The USDM contract contains a storage gap of 50 storage slots to account for potential future changes to the storage layout. However, the convention (as noted in the referenced document) is to choose the size so the contract's variables, including the __gap, use a combined 50 storage slots. In this way, future versions of the contract will have a computable gap without reference to the original version.  Consider changing the size of the variable to correctly follow the convention.  Update: Resolved in commit de984d1.", "html_url": "https://blog.openzeppelin.com/mountain-protocol-audit#unexpected-storage-gap-size", "labels": ["OpenZeppelin"]}, {"title": "Use of Deprecated Function", "body": "The USDM contract uses the _setupRole function, but this function has been deprecated. Consider using _grantRole instead.  Update: Resolved in commit 45a85a3.", "html_url": "https://blog.openzeppelin.com/mountain-protocol-audit#use-of-deprecated-function", "labels": ["OpenZeppelin"]}, {"title": "Potential Irreversibility in venusVAIVaultRate Adjustments", "body": "If the venusVAIVaultRate is mistakenly changed to a very high number in _setVenusVAIVaultRate(), releaseToVault() will overflow.  If there is an attempt to correct the venusVAIVaultRate, releaseToVault will revert due to overflow, impeding any further change to the venusVAIVaultRate.  Consider adding input checks to prevent overflows.  Update: Acknowledged, not resolved. The Venus team stated:  venusVAIVaultRate is set by the governance so the chances of setting it wrong are negligible. For now, we will just acknowledge the issue and no actions are needed from us.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#potential-irreversibility-in-venusvaivaultrate-adjustments", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Function Signature in _setActionsPaused", "body": "The ensureAllowed check in the _setActionsPaused function verifies whether a certain user is allowed to call the function by checking the msg.sender and function signature in the AccessControlManager.  Actions is an enum, and in Solidity  the smallest uint type that is large enough to hold all the values. Since  Actions holds 9 values, it will be mapped to  The correct function signature for the _setActionsPaused function should be 0x2b5d790c.  In this case, since the canonical representation is used instead of the 4-byte signature when setting and checking the signature, the impact is relatively limited.  Update: Resolved in pull request #312 at commit cfaa69a.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#incorrect-function-signature-in-_setactionspaused", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Although many functions in the codebase are well-documented and the code is generally self-explanatory, the codebase could benefit from more complete NatSpec comments for all public and external functions. For instance:  getAssetsIn in MarketFacet.sol  _setLiquidatorContract in SetterFacet.sol  _setVAIMintRate in SetterFacet.sol  _setTreasuryData in SetterFacet.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well.  Update: Resolved in pull request #312 at commit 3909ff7.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Implementation of EIP-2535 Does Not Fully Match the Specification", "body": "The Diamond contract implements the EIP-2535 standard, often referred to as the diamond proxy pattern.  The diamond proxy pattern is a proxy design where the functions are separated into multiple smaller 'facet' contracts. By breaking down the implementation contract into multiple facets, it is possible to build larger and more complex applications without exceeding the contract size limit.  However, there are some mismatches between the current implementation and the official specification worth highlighting:  The diamondCut(IDiamondCut.FacetCut[] memory _diamondCut) function should be diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes calldata _calldata).  The getFacetFunctionSelectors function should be facetFunctionSelectors.  The getAllFacetAddresses function should be facetAddresses.  The Diamond contract does not implement the facets function.  The Diamond contract does not implement the facetAddress function.  The DiamondCut(IDiamondCut.FacetCut[] _diamondCut) event should be DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);.  While the deviations from the specification may not be problematic for this particular use case, they may potentially cause errors in clients interacting with the Diamond contract who expect a fully-compliant implementation of EIP-2535. For example, tools such as Louper will not work as the function signatures of the functions used to inspect the Diamond do not match the ones from the standard.  Therefore, it is advisable to either modify the contract to make it fully compliant or clearly document the expected differences between the Diamond contract and the EIP.  Update: Resolved in pull request #312 at commit 7417d8f.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#implementation-of-eip-2535-does-not-fully-match-the-specification", "labels": ["OpenZeppelin"]}, {"title": "Possible Function Selector Clashing", "body": "Clashing can happen among functions with different names. Every function that is part of a contracts public ABI is identified, at the bytecode level, by a 4-byte identifier. This identifier depends on the function's signature, but since it is only 4 bytes, there is a possibility that two different functions with different function signatures may end up having the same identifier. The Solidity compiler tracks when this happens within the same contract, but not when the collision happens across different ones, such as between a proxy and its logic contract.  Unitroller contract  delegatecalls the  Diamond contract which  delegatecalls the facets. The  The presence of these functions creates the possibility of a function selector clash. This can happen in the following scenarios:  Functions in Unitroller and hardcoded functions in Diamond with the same function selector  Functions in Unitroller and a facet with the same function selector  Hardcoded functions in Diamond and a facet with the same function selector  Note that functions between different facets cannot clash as the diamondCut function prevents adding new functions whose signature is already registered in the Diamond.  Consider checking that no function selector collision is present when adding new functions to the Diamond (using diamondCut) or upgrading the Diamond's implementation. Moving the hardcoded functions in Diamond.sol to a facet will also reduce the chances of a collision going unnoticed.  Update: Acknowledged, not resolved. The Venus team stated:  We have just included the diamondCut functionality in the Diamond.sol file. For now, we will just acknowledge the issue, and no actions are needed from us.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#possible-function-selector-clashing", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Access Allowance to the Comptroller Implementation", "body": "_setVenusSpeeds and  _grantXVS allows  Allowing access from the comptrollerImplementation opens a potential attack path if the implementation were able to do calls to the Unitroller.  Consider disallowing access to these functions from the ComtprollerImplementation.  Update: Resolved in pull request #312 at commit 0aa7e17.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#unnecessary-access-allowance-to-the-comptroller-implementation", "labels": ["OpenZeppelin"]}, {"title": "Non-Explicit Imports", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are being used. Some instances are (but not limited to):  Line 3 of ComptrollerStorage.sol  Line 4 of ComptrollerStorage.sol  Line 5 of ComptrollerStorage.sol  Line 7 of FacetBase.sol  Line 8 of FacetBase.sol  Line 3 of MarketFacet.sol  Line 4 of MarketFacet.sol  Line 3 of PolicyFacet.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Resolved in pull request #312 at commit 6d0a33c.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#non-explicit-imports", "labels": ["OpenZeppelin"]}, {"title": "Not Inheriting From Available Interfaces", "body": "The Diamond has multiple facets, and each facet has its own interface. However, the facet contracts are not explicitly inheriting their interfaces. This can lead to issues if an interface or corresponding contract is modified in a way that would make them incompatible.  Additionally, functions are added to the Diamond by calculating the function signatures from the interfaces instead of the contracts. Therefore it is important that the facet contracts explicitly inherit their respective interfaces to ensure the correct functions are added to the Diamond. For instance:  Diamond does not inherit from IDiamondCut  MarketFacet does not inherit from IMarketFacet  PolicyFacet does not inherit from IPolicyFacet  RewardFacet does not inherit from IRewardFacet  SetterFacet does not inherit from ISetterFacet  To clarify intent, increase the readability of the codebase, and allow the compiler to perform more robust error-checking, consider updating the contracts' inheritance declarations to explicitly inherit from their corresponding interfaces.  Update: Resolved in pull request #312 at commit 50761a0.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#not-inheriting-from-available-interfaces", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Inheritances", "body": "The codebase contains two instances of unnecessary inheritances:  MarketFacet inherits ExponentialNoError. However, FacetBase already inherits ExponentialNoError. Consider removing the explicit inheritance of ExponentialNoError in MarketFacet.  SetterFacet inherits ExponentialNoError. However, FacetBase already inherits ExponentialNoError. Consider removing the explicit inheritance of ExponentialNoError in SetterFacet.  Inheriting a contract multiple times can be confusing and may lead to inconsistencies if the inherited contract is consuming storage slots. While the current version of ExponentialNoError is not consuming any storage slots, consider removing the duplicate inheritance to improve readability.  Update: Resolved in pull request #312 at commit 4c72e43.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#unnecessary-inheritances", "labels": ["OpenZeppelin"]}, {"title": "Lack of SPDX License Identifiers", "body": "Throughout the codebase, there are files that lack SPDX license identifiers. For instance:  ComptrollerStorage.sol  Diamond.sol  FacetBase.sol  MarketFacet.sol  PolicyFacet.sol  RewardFacet.sol  SetterFacet.sol  XVSRewardsHelper.sol  IDiamondCut.sol  IMarketFacet.sol  IPolicyFacet.sol  IRewardFacet.sol  ISetterFacet.sol  To avoid legal issues regarding copyright and follow best practices, consider adding SPDX license identifiers to files as suggested by the Solidity documentation.  Update: Resolved in pull request #312 at commit 0387b34.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#lack-of-spdx-license-identifiers", "labels": ["OpenZeppelin"]}, {"title": "Lack of Indexed Event Parameters", "body": "Throughout the codebase, several events do not have their parameters indexed. For instance:  Line 12 and line 15 of FacetBase.sol  Line 11, line 14, and line 17 of MarketFacet.sol  Line 11 of RewardFacet.sol  All events in SetterFacet.sol  Consider indexing event parameters to improve the ability of off-chain services to search and filter for specific events.  Update: Resolved in pull request #312 at commit 5533343.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Using int/uint Instead of int256/uint256", "body": "In the following contracts, there are instances where int/uint are used instead of int256/uint256:  ComptrollerStorage.sol  FacetBase.sol  MarketFacet.sol  PolicyFacet.sol  SetterFacet.sol  IPolicyFacet.sol  ISetterFacet.sol  In favor of explicitness, consider replacing all instances of int/uint with int256/uint256.  Update: Resolved in pull request #312 at commit 5533343.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#using-int/uint-instead-of-int256/uint256", "labels": ["OpenZeppelin"]}, {"title": "Local Variable Shares Name With Storage Variable", "body": "venusAccrued is declared as a local variable, but there is a storage variable with the same name.  Consider using different names to improve the codebase's readability.  Update: Resolved in pull request #312 at commit 4596c2b.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#local-variable-shares-name-with-storage-variable", "labels": ["OpenZeppelin"]}, {"title": "Constants Not Using UPPER_CASE Format", "body": "In FacetBase.sol, there are several constants that are not using UPPER_CASE format. For instance:  The venusInitialIndex constant declared on line 20  The closeFactorMinMantissa constant declared on line 22  The closeFactorMaxMantissa constant declared on line 24  The collateralFactorMaxMantissa constant declared on line 26  According to the Solidity Style Guide, constants should be named with all capital letters with underscores separating words. For better readability, consider following this convention.  Update: Acknowledged, not resolved. The Venus team stated:  As we have dependencies on external contracts, if we change the convention the public variable venusInitialIndex and its getter will be changed. So for now we can't do the suggested change and will acknowledge the issue.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#constants-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Imports", "body": "Throughout the codebase, there are multiple instances of unnecessary imports that are either unused or already imported by other files.  Import ComptrollerStorage of Diamond.sol which is already imported by Unitroller  Import ErrorReporter of FacetBase.sol which is already imported by VToken  Import ErrorReporter of PolicyFacet.sol which is already imported by VToken  Import ErrorReporter of SetterFacet.sol which is already imported by FacetBase  Import PriceOracle of IMarketFacet.sol  Import PriceOracle of IRewardFacet.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #312 at commit 6d0a33c.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#unnecessary-imports", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Coding Style", "body": "There are general inconsistencies and deviations from the Solidity Style Guide throughout the codebase. Below is a non-exhaustive list of inconsistent coding styles.  While most external function names do not contain an underscore, some begin with one underscore. For example:  _supportMarket  _setVenusSpeeds  _grantXVS  Some functions use named return variables, while others do not. For example:  getFacetFunctionSelectors and getAllFacetAddresses declare named variables for the returned values.  All the other functions in Diamond.sol do not declare a named variable for the return values.  Some facets are importing the ComptrollerErrorReporter contract while other facets are inheriting the ComptrollerErrorReporter contract. For example:  FacetBase is importing the ComptrollerErrorReporter contract and therefore uses ComptrollerErrorReporter.Error.  MarketFacet is inheriting the ComptrollerErrorReporter contract and therefore uses Error.  Consider enforcing a standard coding style, such as the one provided by the Solidity Style Guide, to improve the project's overall readability and consistency. Also, consider using a linter such as Solhint to define a style and analyze the codebase for style deviations.  Update: Partially resolved in pull request #312 at commit 4c72e43. The Venus team stated:  We have not removed _ from external methods as they are setters for the state variables and governance-controlled.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#inconsistent-coding-style", "labels": ["OpenZeppelin"]}, {"title": "Wrong State Update in distributeRewards", "body": "There are two types of allocations in the TruStake protocol: strict and loose. In loose allocations, there is no guarantee that the rewards will be distributed to the recipients and the distributeRewards function can only be called by the allocator(distributor). If the allocation is strict, the rewards from the staked MATIC are guaranteed and anyone should be able to call the distributeRewards function to distribute the rewards to the recipient.  When the distributeRewards function is called, it calls the _distributeRewardsUpdateTotal function which distributes the reward and updates the state. The _distributeRewardsUpdateTotal updates the totalAllocated of the msg.sender instead of the distributor. Since anyone can call the distributeRewards function, this leads to wrong state updation.  Update: Resolved in pull request #1 at commit 091b908.  High Severity", "html_url": "https://blog.openzeppelin.com/trufin-audit#wrong-state-update-in-distributerewards", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Calculation of Total Amount Staked", "body": "The TruStakeMATICv2 contract implements the totalStaked function to calculate the total amount of MATIC staked by the vault on the validator. The function incorrectly calculates this, as it divides the amount of shares held by the vault by the exchangeRate, where it should multiply by it.  As the current exchangeRate is 1, the result of the function is still correct. However, if the exchangeRate value changes, the result will be incorrect.  In contrast, the getTotalStake(address user) function from the ValidatorShare contract performs the same operation but multiplies the amount of shares held by the user address passed as a parameter. Additionally, this function takes into account the exchange rate decimals of the validator, making it unnecessary to hardcode it.  Consider using getTotalStake function of the ValidatorShare contract to get the total amount of MATIC staked by the vault. Additionally, consider including additional tests to validate the calculated amount.  Update: Resolved in pull request #1 at commit 89c54da.  Low Severity", "html_url": "https://blog.openzeppelin.com/trufin-audit#incorrect-calculation-of-total-amount-staked", "labels": ["OpenZeppelin"]}, {"title": "Lack of Event Emission After Sensitive Actions", "body": "The following functions do not emit relevant events after executing sensitive actions.  MasterWhiteList contract:  When changing the KYC Passport address  When changing the KYC Reader address  When changing the KYC Registry address  When adding or removing assets from the whitelist  When adding or removing countries from the blacklist  When countries are added to the blacklistedCountries mapping  When a user is removed from the blacklist by being added to the whitelist via addUserToWhitelist function  When a user is removed from the blacklist by being added to the whitelist via addUserToWhitelistWithProvider function  When setting the id for a market maker  Consider emitting events after sensitive changes occur to facilitate tracking and notify off-chain clients following the contracts' activity.  Update: Resolved in pull request #1 at commits 5a95710, 9ea10bf and 71cc3a4.", "html_url": "https://blog.openzeppelin.com/trufin-audit#lack-of-event-emission-after-sensitive-actions", "labels": ["OpenZeppelin"]}, {"title": "Hardcoded Values", "body": "Throughout the codebase, there are several occurrences of literal values with unexplained meanings. For example:  TruStakeMATICv2 contract:  In the totalStaked function, the amount of shares returned by the validator is multiplied by 1e29.  In the isClaimable function, the epochs needed to allow withdrawing are calculated adding 80.  In the setEpsilon function, the parameter is checked against 1e12.  MasterWhitelist contract:  Consider documenting the origin of CODE_RISK and CODE_COUNTRY.  Digits 0 to 4 are often used to represent user types.  In addUserToWhitelistUsingPassport, the passport's AML risk is compared against 5.  To improve the code's readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name.  Update: Resolved in pull request #1 at commits 4b9e4d4 and d0453ae.", "html_url": "https://blog.openzeppelin.com/trufin-audit#hardcoded-values", "labels": ["OpenZeppelin"]}, {"title": "Use of Deprecated Method", "body": "The MasterWhitelist contract uses the balanceOf function from Quadrata's QuadReader contract. According to Quadrata's documentation, this function has been deprecated.  Consider instead using getAttributes function to query for a specific attribute and validate the returned result.  Update: Acknowledged, not resolved. The TruFin team stated:  Not fixed. We have decided not to use this method for a few reasons. This method as it is works well for us and the team at Quadrata has assured us that they do not plan to remove it. Also, this method is free to use, as opposed to the alternative method getAttributes which we would have to pay for.", "html_url": "https://blog.openzeppelin.com/trufin-audit#use-of-deprecated-method", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Some of the following contracts have functions with incomplete or lacking docstrings:  MasterWhitelist.sol  TrueStakeMaticv2.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well.  Also, it is unclear from the documentation how the idMM, whitelistedVaults, whitelistedAssets and whitelistedSwapManagers mappings will integrate with the rest of the system. Consider documenting their use cases.  Update: Resolved in pull request #1 at commits 52525b0 and f7555da.", "html_url": "https://blog.openzeppelin.com/trufin-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "A Future Action Can Lead to a Vulnerability", "body": "In upgradeable contracts, every new version of the implementation contract needs to have all the state variables of the previous implementation in the same layout or else it can lead to a storage collision. Attackers can use this vulnerability to overwrite sensitive information.  55 and  58 of the  Consider keeping the same storage layout throughout all versions of the TruStakeMATICv2 contract and removing the misleading comments.  Update: Resolved in pull request #1 at commit fcd6b61.", "html_url": "https://blog.openzeppelin.com/trufin-audit#a-future-action-can-lead-to-a-vulnerability", "labels": ["OpenZeppelin"]}, {"title": "Removing Market Makers From Whitelist Can Leave Inconsistent State", "body": "The idMM mapping is used to connect a market maker's address to the market maker id they belong to. Key-value pairs are set using either the addMMToWhitelistWithId or the setIdMM functions.  When removing a market maker from the whitelist, only the whitelistedMMs mapping is altered, while idMM remains set. Depending on future integrations with idMM, this could lead to a vulnerability.  When removing a market maker from the whitelist, consider also deleting the corresponding entry from the idMM mapping.  Update: Resolved in pull request #1 at commit 3498b70.", "html_url": "https://blog.openzeppelin.com/trufin-audit#removing-market-makers-from-whitelist-can-leave-inconsistent-state", "labels": ["OpenZeppelin"]}, {"title": "Some Functions Are Not ERC-4626 Compliant", "body": "Since the TruStakeMATICv2 contract is an ERC-4626 vault, it is important that it complies with all the specifications of the standard. Some functionality of the vault diverges from the standard:  The maxDeposit and maxMint functions must not revert under any circumstances.  The maxDeposit function in TruStakeMATICv2 will revert if cap < totalStaked(). The maxMint function would also revert under the same circumstance as it makes a call to the maxDeposit function.  The ERC-4626 standard stipulates that an approved EIP-20 spender is able to call the deposit, mint, withdraw and redeem functions on behalf of the asset/share owner and deposit/withdraw the assets.  In the TruStakeMATICv2 contract, only the owner of the tokens/shares can call these functions.  The standard also stipulates that the withdraw and redeem functions are the functions in which assets are transferred to the recipient. If an implementation requires pre-requesting to the vault before a withdrawal can be performed then those methods should be performed separately.  In TruStakeMATICv2 contract, the withdraw and redeem functions are used to unstake MATIC from the validator. The actual transfer happens by calling the withdrawClaim function after 80 checkpoints.  Contracts that integrate with the TruStakeMATICv2 vault may wrongly assume that the functions are EIP-4626 compliant, which can cause integration problems in the future, potentially leading to a wide range of issues for both parties, including loss of funds.  Consider making all functions ERC-4626 compliant to prevent any integration issues.  Update: Partially resolved in pull request #1 at commit 4514cfb. Functions that are not compliant with the ERC-4626 standard are documented.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/trufin-audit#some-functions-are-not-erc-4626-compliant", "labels": ["OpenZeppelin"]}, {"title": "Commented-out Code", "body": "Throughout the codebase, there are lines of code that have been commented out with //. This can lead to confusion and is detrimental to overall code readability. We have provided a non-exhaustive list of examples below:  Lines 8, 17 and 42 of MasterWhitelist.sol.  Consider removing any unneeded commented-out lines of code.  Update: Resolved in pull request #1 at commit 75d4221.", "html_url": "https://blog.openzeppelin.com/trufin-audit#commented-out-code", "labels": ["OpenZeppelin"]}, {"title": "Gas Inefficiencies", "body": "There are several places across the codebase where changes can be made to improve gas consumption. For example:  Several for loops assign the starting index to a default value, which is unnecessary. See initialize and claimList.  The getDistributors and getRecipients functions can be removed to reduce deployment gas cost, as well as code size. Consider using the default distributors() and recipients() getters instead.  In addUserToWhitelistUsingPassport, consider swapping the calls to hasPassport and isUserBlacklisted. On average, prioritizing require statements that do not involve external calls would return more gas to the user in case the method reverts.  _countryBlacklist is read-only, and can be declared as calldata to save gas.  In deallocate function, consider moving the call to sharePrice after the revert statements, as the share price is only needed if the initial checks pass.  It is recommended that if a storage variable will be read multiple times in the same function, a copy to memory should first be created since reading from storage is expensive. Here are a few of the places where this change could decrease gas cost: allocate, deallocate, distributeAll.  When performing these changes, aim to reach an optimal tradeoff between gas optimization and readability. Having a codebase that is easy to understand reduces the chance of errors in the future and improves transparency for the community.  Update: Resolved in pull request #1 at commits fbfcc80 and 62fbe7b.", "html_url": "https://blog.openzeppelin.com/trufin-audit#gas-inefficiencies", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "In the codebase, there is an import that is unused and could be removed:  Import ERC20Upgradeable of TruStakeMATICv2.sol.  Consider removing the unused import to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #1 at commit 7a93a9c.", "html_url": "https://blog.openzeppelin.com/trufin-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused Named Return Variables", "body": "Named return variables are a way to declare variables that are meant to be used within a function's body for the purpose of being returned as the function's output. They are an alternative to explicit in-line return statements.  In TruStakeMATICv2.sol, there are multiple instances of unused named return variables. For instance:  The unbondNonce return variable in the _unbond function.  The shares return variable in the _convertToShares function.  Consider either using or removing any unused named return variables.  Update: Resolved in pull request #1 at commit f861037.", "html_url": "https://blog.openzeppelin.com/trufin-audit#unused-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit Imports are Used", "body": "The use of non-explicit imports can decrease the code's clarity, and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple definitions exist within the same Solidity file.  Several global imports are being used, such as:  Line 22 of TruStakeMATICv2.sol.  Line 5 of TruStakeMATICv2Storage.sol.  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") everywhere.  Update: Resolved in pull request #1 at commit 84c7f3c.", "html_url": "https://blog.openzeppelin.com/trufin-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "State Variable Visibility Not Explicitly Declared", "body": "Within MasterWhitelist.sol there are multiple state variables that lack an explicitly declared visibility. For instance:  The state variables initialized from line 53 to line 135.  For clarity, consider always explicitly declaring the visibility of variables, even when the default visibility matches the intended visibility.  Update: Resolved in pull request #1 at commit 9bed3dc.", "html_url": "https://blog.openzeppelin.com/trufin-audit#state-variable-visibility-not-explicitly-declared", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed event parameters", "body": "Throughout the codebase, several events do not have their parameters indexed. For instance:  Line 180 of MasterWhitelist.sol  Line 10, line 77, line 172, line 174, line 176, line 178, line 180, line 182, line 184, and line 186 of ITruStakeMATICv2.sol  Consider indexing event parameters to improve the ability of off-chain services to search and filter for specific events.  Update: Resolved in pull request #1 at commits 5c9bba9 and a82a051.", "html_url": "https://blog.openzeppelin.com/trufin-audit#lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "Consider addressing the following typographical errors.  In TruStakeMATICv2Storage.sol:  On line 33 \"phi\" should be \"distPhi\".  On line 43 \"fudns\" should be \"funds\".  In MasterWhitelist.sol:  On line 166 \"the address added to blacklisted\" should be \"the address added to the blacklist\".  On line 564 \"users adds themselves\" should be \"users add themselves\".  Update: Resolved in pull request #1 at commit 2406960.", "html_url": "https://blog.openzeppelin.com/trufin-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Coding Style", "body": "Throughout the codebase, there are several places that have inconsistent code style:  TruStakeMATICv2.sol and TruStakeMATICv2Storage.sol write NatSpec using single-line comments, while other files use block comments.  removeSwapManagerFromWhitelist and removeUserFromBlacklist assign default values instead of using delete.  Consider moving the INF_TIME constant above investigation_period, for better visibility (same for PROV_CODE_MANUAL and CODE_COUNTRY).  The imports in MasterWhitelist.sol are in the order: vendor contracts, Trufin contracts. However, in TruStakeMATICv2.sol they are in the opposite order. Consider having the same order for imports to improve the codebase's readability. The imports should also be grouped with a space in between.  IMasterWhitelist is under the Polygon imports section, not Trufin.  ++i is used consistently across the codebase, except for inside claimList.  investigation_period, investigation_time, KYCPassport, KYCReader and KYCRegistry should use camelCase.  Several comments have no spacing between // and the comments' text. Here are some examples: #1, #2, #3.  Taking into consideration how much value a consistent coding style adds to the projects readability, enforcing a standard coding style with the help of linter tools such as Solhint is recommended.  Update: Resolved in pull request #1 at commits 2da2114, 1989b80 and 0b75e11.", "html_url": "https://blog.openzeppelin.com/trufin-audit#inconsistent-coding-style", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "Some events in MasterWhitelist.sol can benefit from better naming. Specifically:  UserAddedToWhitelist should be addedToWhitelist.  userRemovedFromWhitelist should be removedFromWhitelist.  As these events are used for logging data for all types of roles and not just the user role, considering renaming these events to improve the clarity of the codebase.  Update: Resolved in pull request #1 at commit 50a80ff.", "html_url": "https://blog.openzeppelin.com/trufin-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Unused Variable", "body": "MasterWhitelist uses Quadrata QuadReader to query a user's KYC verification attributes. However, it also stores a pointer to a QuadPassport contract, which is unused.  Moreover, Quadrata's documentation states that QuadPassport contains the logic for onboarding/minting Quadrata Passport, which is not the responsibility of the MasterWhitelist.  Consider removing the KYCPassport storage variable to improve the codebase's quality and reduce gas consumption.  Update: Resolved in pull request #1 at commit 8de5818.", "html_url": "https://blog.openzeppelin.com/trufin-audit#unused-variable", "labels": ["OpenZeppelin"]}, {"title": "Incorrect or Misleading Documentation", "body": "On line 204 of the MasterWhitelist contract, the Natspec comment could be better rephrased as \"_countryBlacklist is an array of the keccak256 hashes of 2 letter country codes\".  In the Types contract, the Natspec comments at the end of the file are misplaced and incomplete.  On lines 7, 50 and 144 of the MasterWhitelist contract, the Natspec comments omit mentioning the swapManager user type.  On line 97 of the MasterWhitelist contract, the Natspec comment could be better rephrased as \"Mapping of users to the kycProvider used for verification\", as it is not the kycProvider that whitelists, but a lawyer or the users themselves.  On line 36 of the TruStakeMATICv2Storage contract, the Natspec comments read \"cap on deposits into the vault\" but it is actually the cap on total amount staked with the validator, which is different because the latter also counts MATIC that was rewarded and restaked.  There were instances in this codebase where function parameters appear in a function signature to comply with the ERC-4626 but are never used within their respective function.  The address parameter of the maxDeposit function The address parameter of the maxMint function To improve clarity, consider documenting the reason for having these unused function parameters.  Consider correcting the missing or misleading documentation.  Update: Resolved in pull request #1 at commit d08ab44.", "html_url": "https://blog.openzeppelin.com/trufin-audit#incorrect-or-misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Potentially unsafe usage of unchecked math", "body": "The following instances of unchecked math were identified:  The operation on line 44 of LandBaseTokenV3.sol  The operation on line 50 of LandBaseTokenV3.sol  The operation on line 57 of LandBaseTokenV3.sol  The operation on line 84 of LandBaseTokenV3.sol  The operation on line 85 of LandBaseTokenV3.sol  The operation on line 228 of LandBaseTokenV3.sol  The operation on line 258 of LandBaseTokenV3.sol  The operation on line 279 of LandBaseTokenV3.sol  The operation on line 293 of LandBaseTokenV3.sol  The operation on line 294 of LandBaseTokenV3.sol  The operation on line 314 of LandBaseTokenV3.sol  The operation on line 317 of LandBaseTokenV3.sol  The operation on line 341 of LandBaseTokenV3.sol  The operation on line 383 of LandBaseTokenV3.sol  The operation on line 390 of LandBaseTokenV3.sol  The operation on line 391 of LandBaseTokenV3.sol  The operation on line 421 of LandBaseTokenV3.sol  The operation on line 486 of LandBaseTokenV3.sol  The operation on line 487 of LandBaseTokenV3.sol  The operation on line 541 of LandBaseTokenV3.sol  The operation on line 543 of LandBaseTokenV3.sol  The operation on line 611 of LandBaseTokenV3.sol  The operation on line 620 of LandBaseTokenV3.sol  The operation on line 40 of LandV3.sol  Consider using the latest Solidity version which has built-in math checks against overflows and underflows. Alternatively, consider using the OpenZeppelin SafeMath library to protect math operations against overflows and underflows for Solidity versions >=0.6.0 and <0.8.0.  Update: Resolved in pull request #909 at commit 37b3dfb. The exists (_isValidQuad) function in the LandBaseTokenV3 contract has been updated to ensure the input quad size is one of the valid sizes. In addition, upon further review from the OpenZeppelin team, it was noted that unchecked math for both the LandBaseTokenV3.sol and LandV3.sol does not introduce potential for overflows or underflows. Also, the Sandbox team stated:  We checked for possible cases of unsafeMath but feel that we have good validation for the values of parameters, which will never cause a safeMath error. We have found one case regarding the possible value of size, which has been handled in the pull request for L-02.  Medium Severity", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#potentially-unsafe-usage-of-unchecked-math", "labels": ["OpenZeppelin"]}, {"title": "Lack of documentation for complex functionality", "body": "The codebase contains several internal functions that perform complex computations but lack sufficient documentation. Further, some state variables have complex implicit assumptions about the values they store that are not documented. This lack of documentation can hinder the maintainability of these functions and variables, making it more challenging for auditors to thoughtfully understand their implications. In particular:  The _mintAndTransferQuad, _checkAndClearOwner, _checkAndClear, and _checkBatchReceiverAcceptQuadAndClearOwner functions in the PolygonLandBaseTokenV2 and LandBaseTokenV3 contracts.  The _owners state variable defined in the ERC721BaseTokenV2 contract in both the Ethereum implementation and Polygon implementation, which is used throughout the LandBaseTokenV3 and PolygonLandBaseTokenV2 contracts. This variable uses a complex storage pattern to record ownership of individual LAND tokens as well as \"quads\". Quads are indexed using a bitmask and the code implicitly assumes that ownership of individual LAND tokens takes precedence over quads. Further, the stored addresses include indicator bits above the 160th bit to mark tokens as burned or have an operator enabled.  To ensure ease of maintainability, consider thoroughly documenting these functions and variables, including both function-level documentation as well as in-line documentation where appropriate.  Update: Resolved in pull request #916 at commit 3d5acc1.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-documentation-for-complex-functionality", "labels": ["OpenZeppelin"]}, {"title": "Lack of input id validation in the _ownerOf function", "body": "Ethereum and  Polygon implementations does not validate that the input  Consider validating that the input ID corresponds to a single token. This can be done by adding additional checks to the function to ensure that only valid token IDs are processed.  Update: Resolved in pull request #921 at commit 97da7fb.  Low Severity", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-input-id-validation-in-the-_ownerof-function", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "The following instances of missing docstrings were identified:  Lines 11 and 32 in ERC721BaseTokenV2.sol  Line 6 in LandBaseTokenV3.sol  Line 9 in LandV3.sol  Lines 4, 5, 7, 9, 11, 13, 19, 25, 31, 37, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, and 65 in IOperatorFilterRegistry.sol  Line 6 in MetaTransactionReceiverV2.sol  Line 5 in SuperOperatorsV2.sol  Lines 12 and 19 in ERC721MandatoryTokenReceiver.sol  Lines 11 and 17 in ERC721TokenReceiver.sol  Line 3 in AddressUtils.sol  Lines 4, 5, 7, 9, 11, 13, 19, 25, 31, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, and 65 in IOperatorFilterRegistry.sol  Lines 16 and 20 in ERC2771Handler.sol  Line 13 in ERC721BaseTokenV2.sol  Line 7 in WithAdminV2.sol  Line 8 in WithSuperOperatorsV2.sol  Line 6 in FxBaseChildTunnelUpgradeable.sol  Line 10 in FxBaseRootTunnelUpgradeable.sol  Lines 12 and 19 in IERC721MandatoryTokenReceiver.sol  Lines 4, 5, 14, and 23 in ILandToken.sol  Lines 6, 7, 13, 21, and 29 in ILandTokenV2.sol  Lines 6, 13, and 19 in IPolygonLand.sol  Lines 4 and 11 in IPolygonLandTunnel.sol  Lines 6 and 7 in IPolygonLandWithSetApproval.sol  Lines 10, and 195 in PolygonLandBaseTokenV2.sol  Line 13 in PolygonLandTunnelV2.sol  Lines 14, 30, and 77 in LandTunnelV2.sol  Lines 122 and 131 of PolygonLandTunnelMigration.sol  Lines 6, 7, and 15 of IPolygonLandV2.sol  Line 38 of LandTunnelMigration.sol  Additionally, there are cases that require further completion:  The return from the supportsInterface function in the LandTunnelV2 contract is undocumented.  The return from the supportsInterface function in the PolygonLandTunnelV2 contract is undocumented.  The _childToken argument to the initialize function in the PolygonLandTunnelV2 contract is undocumented.  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #907 at commit 9ddf8c9.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "require statements with multiple conditions", "body": "The following instances of  were identified:  The require statement on line 43 of LandBaseTokenV3.sol  The require statement on line 44 of LandBaseTokenV3.sol  The require statement on line 140 of LandBaseTokenV3.sol  The require statement on line 227 of LandBaseTokenV3.sol  The require statement on line 228 of LandBaseTokenV3.sol  The require statement on line 420 of LandBaseTokenV3.sol  The require statement on line 421 of LandBaseTokenV3.sol  The require statement on line 658 of LandBaseTokenV3.sol  The require statement on line 38 of PolygonLandBaseTokenV2.sol  The require statement on line 39 of PolygonLandBaseTokenV2.sol  The require statement on line 61 of PolygonLandBaseTokenV2.sol  The require statement on line 611 of PolygonLandBaseTokenV2.sol  The require statement on line 612 of PolygonLandBaseTokenV2.sol  The require statement on line 731 of PolygonLandBaseTokenV2.sol  The require statement on line 103 of PolygonLandTunnelV2.sol  The require statement on line 79 of LandTunnelV2.sol  To simplify the codebase and raise the most helpful error messages for failing require statements, consider having a single require statement per condition.  Update: Resolved in pull request #909 at commit 37b3dfb.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#require-statements-with-multiple-conditions", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission after sensitive actions", "body": "The following functions do not emit relevant events after executing sensitive actions.  Ethereum LAND:  When the _admin variable is set in the initialize function of the ERC721BaseTokenV2 contract  When the filter registry is set in the LandV3 contract  When the LAND contract is registered on the Operator Filterer Registry in the LandV3 contract  Polygon LAND:  When the _admin variable is set in the initialize function of the PolygonLandV2 contract  When the _trustedForwarder is set in the initializer of the ERC2771Handler contract  When the _trustedForwarder is set using the setTrustedForwarder method in the PolygonLandV2 contract  When the filter registry is set in the PolygonLandV2 contract  When the LAND contract is registered on the Operator Filterer Registry in the PolygonLandV2 contract  When the _trustedForwarder is set using the setTrustedForwarder method in the LandTunnelV2 contract  When the _trustedForwarder is set using the setTrustedForwarder method in the PolygonLandTunnelV2 contract  When the maxGasLimitOnL1 and maxAllowedQuads state variables are set in the initialize function in the PolygonLandTunnelV2 contract  When the admin is set in the constructor of the PolygonLandTunnelMigration contract  When the admin is set in the constructor of the LandTunnelMigration contract  Consider emitting events after sensitive changes occur to facilitate tracking and notify any off-chain clients who may be following the contracts' activity.  Update: Resolved in pull request #919 at commit c5bb59b.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-event-emission-after-sensitive-actions", "labels": ["OpenZeppelin"]}, {"title": "Lack of input validation", "body": "Throughout the codebase, there are several functions that lack input validation when changing privileged roles, allowing these roles to be set to the zero address. In particular:  The newAdmin argument of the changeAdmin function in the AdminV2 contract for both implementations  The batchTransferQuadToL2 function in the LandTunnelV2 contract can be called with zero-length arrays for the sizes, xs, and ys arguments. Consider validating that the input arrays have a length of at least 1.  The batchTransferQuadToL1 function in the PolygonLandTunnelV2 contract can be called with zero-length arrays for the sizes, xs, and ys arguments. Consider validating that the input arrays have a length of at least 1.  The setLimit function in the PolygonLandTunnelV2 contract accepts a quad size and the gas limit for that size. The size argument is never validated to ensure it corresponds to a valid quad size of 1, 3, 6, 12, or 24.  The setMaxLimitOnL1 function in the PolygonLandTunnelV2 contract does not validate that the input gas limit is non-zero. If the maxGasOnLimitOnL1 variable is set to zero it would prevent tokens from being transferred to L1 as the gas check within the batchTransferQuadToL1 function will always fail.  Consider adding a check that prevents setting these roles to the zero address and including a separate function for revoking role rights.  Update: Partially resolved in pull request #954 at commit 0f7f68d. The Sandbox team stated:  We decided not to fix the issue on AdminV2 as we want to be able to give up on the admin role.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Operator approval can cause unexpected behavior", "body": "When an operator approval is set, the _owners data stores a flag at the 256th bit (this is done in both implementations, Ethereum and Polygon).  line 357 in the Polygon implementation and on  line 264 in the Ethereum implementation will fail since the 256th bit will never match  Function _checkBatchReceiverAcceptQuadAndClearOwner will fail to clear the owner of a quad with an operator approval set, as it also performs ownership checks following the pattern explained above, specifically, in lines 323 and 343 in the Ethereum implementation and in lines 463 and 483 in the Polygon implementation.  Consider disregarding the operator flag when checking ownership within the _mintAndTransferQuad and _checkBatchReceiverAcceptQuadAndClearOwner functions. Further, if an operator is set for any of the transferred tokens, the operator should be cleared from the operator mapping.  Update: Resolved in pull request #917 at commit 02f7bc8.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#operator-approval-can-cause-unexpected-behavior", "labels": ["OpenZeppelin"]}, {"title": "Lack of storage gap in upgradeable contracts", "body": "Throughout the codebase, there are several contracts that are inherited by upgradeable contracts that do not include a storage gap. In particular:  The ERC2771Handler contract  The ERC721BaseTokenV2 contract  The WithSuperOperatorsV2 contract  The WithAdminV2 contract  If any of these contracts add new storage variables it will overwrite the storage of parent contracts and lead to an incompatible storage layout.  To allow additions of new state variables without compromising the storage compatibility with existing deployments, consider leaving a storage gap at the end of each contract.  Update: Acknowledged, not resolved. The Sandbox team stated:  Those contracts are already deployed on mainnet, therefore we cannot add gaps without breaking the storage.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-storage-gap-in-upgradeable-contracts", "labels": ["OpenZeppelin"]}, {"title": "Setting the root and child tunnel addresses can be front-run", "body": "setFxRootTunnel and  setFxChildTunnel functions defined in the  FxBaseChildTunnelUpgradeable and  FxBaseRootTunnelUpgradeable contracts and the functions are never overridden. Since these functions do not contain any access control, anyone can call them and set the aforementioned addresses to any address except the zero address. If these functions were front-run, the implementation contracts would need to be redeployed as it will not be possible to change these addresses after they have been set.  Consider either including access control on these functions, calling them within the initialize functions, or ensuring that they are called within the same transaction as when the implementation contracts are initialized.  Update: Resolved in pull request #945 at commit b74749c.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#setting-the-root-and-child-tunnel-addresses-can-be-front-run", "labels": ["OpenZeppelin"]}, {"title": "Unused variable", "body": "The PolygonLandTunnelMigration and LandTunnelMigration contracts both define a constant GRID_SIZE that is not used within these contracts.  Consider removing this variable.  Update: Resolved in pull request #942 at commit 8a16ac2.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#unused-variable", "labels": ["OpenZeppelin"]}, {"title": "Missing access control", "body": "The approveNewLandTunnel function in the PolygonLandTunnelMigration contract sets approval for the new land tunnel contract to transfer LAND tokens on behalf of the contract. This function lacks any access control and can be called by anyone.  While this is not directly a security risk as only super-operators are approved to transfer LAND tokens to the contract within the migrateToTunnelWithWithdraw function, consider restricting this function such that only the admin can call it to further secure the contract.  Update: Resolved in pull request #946 at commit 90a111e.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#missing-access-control", "labels": ["OpenZeppelin"]}, {"title": "Files specifying outdated Solidity versions", "body": "The following instances of files specifying outdated Solidity versions were identified:  The pragma statement on line 2 of ERC721BaseTokenV2.sol  The pragma statement on line 2 of LandBaseTokenV3.sol  The pragma statement on line 3 of LandV3.sol  The pragma statement on line 2 of OperatorFiltererUpgradeable.sol  The pragma statement on line 2 of IOperatorFilterRegistry.sol  The pragma statement on line 1 of MetaTransactionReceiverV2.sol  The pragma statement on line 1 of SuperOperatorsV2.sol  The pragma statement on line 1 of ERC721Events.sol  The pragma statement on line 1 of ERC721MandatoryTokenReceiver.sol  The pragma statement on line 9 of ERC721TokenReceiver.sol  The pragma statement on line 1 of AddressUtils.sol  Consider taking advantage of the latest Solidity version to improve the overall readability and security of the codebase. Regardless of which version of Solidity is used, consider pinning the version consistently throughout the codebase to prevent bugs due to incompatible future releases.  Update: Acknowledged, not resolved. The Sandbox team stated:  We decided not to change the solidity version as it causes too many changes.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#files-specifying-outdated-solidity-versions", "labels": ["OpenZeppelin"]}, {"title": "Fuzzing testing opportunities", "body": "The following functions could benefit from fuzzing:  _idInPath of LandBaseTokenV3.sol  _isQuadMinted of LandBaseTokenV3.sol  _getQuadLayer of LandBaseTokenV3.sol  _getQuadById of LandBaseTokenV3.sol  uint2str of LandV3.sol  _isQuadMinted of PolygonLandBaseTokenV2.sol  _getQuadLayer of PolygonLandBaseTokenV2.sol  _idInPath of PolygonLandBaseTokenV2.sol  _getQuadById of PolygonLandBaseTokenV2.sol  Consider performing additional testing for the functions above.  Update: Acknowledged, not resolved. The Sandbox team stated:  Fuzzing testing is not easily possible on the current repository but we're planning to migrate the repository and enable fuzz testing later this year.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#fuzzing-testing-opportunities", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed event parameters", "body": "The following instances could benefit from indexing event parameters:  line 18 of LandBaseTokenV3.sol  line 10 of MetaTransactionReceiverV2.sol  line 9 of SuperOperatorsV2.sol  line 24 of PolygonLandBaseTokenV2.sol  line 25 of PolygonLandTunnelMigration.sol  line 33 of PolygonLandTunnelMigration.sol  line 27 of PolygonLandTunnelV2.sol  line 23 of LandTunnelMigration.sol  Consider indexing event parameters to improve the ability of off-chain services to search and filter for specific events.  Update: Resolved in pull request #902 at commit 83835cd.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Lack of SPDX license identifiers", "body": "The following Solidity files lack the appropriate SPDX license identifiers:  ERC721BaseTokenV2.sol  LandBaseTokenV3.sol  LandV3.sol  MetaTransactionReceiverV2.sol  SuperOperatorsV2.sol  ERC721Events.sol  ERC721MandatoryTokenReceiver.sol  AddressUtils.sol  ERC721TokenReceiver.sol  To avoid legal issues regarding copyright and follow best practices, consider adding SPDX license identifiers to files as suggested by the Solidity documentation.  Update: Resolved in pull request #903 at commit dc4bade.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-spdx-license-identifiers", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit imports are used", "body": "throughout the codebase, which reduces code readability and could lead to conflicts between the names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or if inheritance chains are long.  For instance:  LAND  lines 4-9 of ERC721BaseTokenV2.sol  line 4 of LandBaseTokenV3.sol  lines 5-7 of LandV3.sol  lines 3 and 4 of MetaTransactionReceiverV2.sol  line 3 of SuperOperatorsV2.sol  lines 6-11 of ERC721BaseTokenV2.sol  line 5 of WithAdminV2.sol  lines 5 and 6 of WithSuperOperatorsV2.sol  line 4 of IPolygonLand.sol  lines 5-8 of PolygonLandBaseTokenV2.sol  lines 5-8 of PolygonLandV2.sol  line 4 of IPolygonLandV2.sol  TUNNEL  line 4 of ILandTokenV2.sol  line 4 of IPolygonLandWithSetApproval.sol  lines 4-6 of PolygonLandTunnelMigration.sol  lines 4-11 of PolygonLandTunnelV2.sol  line 4 of LandTunnelMigration.sol  lines 4-9 of LandTunnelV2.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Resolved in pull request #904 at commit 94697a5.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "The following instances of unused imports were identified:  Import ERC721BaseTokenV2 of LandV3.sol  Import PolygonLandBaseToken of PolygonLandTunnelV2.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #905 at commit 4736d01.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused named return variables", "body": "Throughout the codebase there are multiple instances of unused named return variables:  The isOperator return variable in the isApprovedForAll function in ERC721BaseTokenV2.sol.  The trustedForwarder return variable in the getTrustedForwarder function in ERC2771Handler.sol.  The isOperator return variable in the isApprovedForAll function in ERC721BaseTokenV2.sol.  The isMetaTx return variable in the _checkTransfer function in ERC721BaseTokenV2.sol.  The sender return variable in the _msgSender function in PolygonLandTunnelV2.sol.  The sender return variable in the _msgSender function in PolygonLandV2.sol.  The sender return variable in the _msgSender function in LandTunnelV2.sol.  Consider either using or removing any unused named return variables.  Update: Resolved in pull request #906 at commit 697bd41.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#unused-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Lack of EIP-173 support for operator filter registry", "body": "The OpenSea operator filter registry lets a smart contract manage the operators allowed to transfer tokens on behalf of users. If the contract implementing the registry follows EIP-173, the owner is able to manage the registry on behalf of the contract. The PolygonLandV2 contract does not follow EIP-173 but instead has an equivalent admin role.  To enable easier control over the registry and provide access to more functionality without requiring an upgrade to the token contract, consider implementing EIP-173.  Update: Acknowledged, not resolved. The Sandbox team stated:  We decided not to implement the EIP-173 as the OperatorFilterSubscription contract will handle the administration.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-eip-173-support-for-operator-filter-registry", "labels": ["OpenZeppelin"]}, {"title": "Redundant code", "body": "Consider making the following changes to eliminate redundant code:  Ethereum LAND:  The _register function of OperatorFiltererUpgradeable contract in line 24 handles the case where subscriptionOrRegistrantToCopy is the zero address, but this path will never be executed as there is a require statement validating that subscriptionOrRegistrantToCopy != address(0) in the caller function. Consider removing this code path.  Checking if the output of the exists function is true in the mintAndTransferQuad function in the LandBaseTokenV3 contract is unnecessary.  The _checkTransfer function in the ERC721BaseTokenV2 contract will either revert or return true. Returning true from this function is unnecessary.  Polygon LAND:  The _register function of the OperatorFiltererUpgradeable contract in line 27 handles the case where subscriptionOrRegistrantToCopy is the zero address, but this path will never be executed as there is a require statement validating that subscriptionOrRegistrantToCopy != address(0) in the caller function. Consider removing this code path.  Checking if the output of the exists function is true in the mintAndTransferQuad function in the PolygonLandBaseTokenV2 contract is unnecessary.  The _checkTransfer function in the ERC721BaseTokenV2 contract will either revert or return true. Returning true from this function is unnecessary.  When calling the safeTransferFrom function in the PolygonLandV2 contract without the data argument, the onlyAllowedOperator modifier is called twice: once by the safeTransferFrom function without the data argument, and again by the safeTransferFrom function with the data argument.  Update: Partially resolved in pull request #910 at commit 28607d2. The following instances remain unresolved:  Ethereum LAND: The _register function of OperatorFiltererUpgradeable contract in line 24 handles the case where subscriptionOrRegistrantToCopy is the zero address, but this path will never be executed as there is a require statement validating that subscriptionOrRegistrantToCopy != address(0) in the caller function. Consider removing this code path.  Polygon LAND: The _register function of the OperatorFiltererUpgradeable contract in line 27 handles the case where subscriptionOrRegistrantToCopy is the zero address, but this path will never be executed as there is a require statement validating that subscriptionOrRegistrantToCopy != address(0) in the caller function. Consider removing this code path.  In addition, The Sandbox team stated:  We decided not to resolve this issue to keep the code as close as the original one from OpenSea.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#redundant-code", "labels": ["OpenZeppelin"]}, {"title": "Reuse onlyAdmin modifier", "body": "The onlyAdmin modifier can be used instead of the require checks:  In the setMinter function in the PolygonLandBaseTokenV2 contract  In the setSuperOperator function in the WithSuperOperatorsV2 contract  To improve the readability of the codebase, consider using the onlyAdmin modifier instead of the require checks.  Update: Resolved in pull request #911 at commit 6fe419b.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#reuse-onlyadmin-modifier", "labels": ["OpenZeppelin"]}, {"title": "Trusted forwarder validated against operator filter registry", "body": "The trusted forwarder is used throughout the contract to enable meta-transactions. With the addition of the operator filter registry, any transaction initiated by the trusted forwarder will validate the trusted forwarder against the registry as the onlyAllowedOperator modifier checks msg.sender rather than _msgSender.  Consider using _msgSender within the onlyAllowedOperator modifier to reduce gas consumption when performing meta-transactions.  Update: Resolved in pull request #924 at commit 967f133.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#trusted-forwarder-validated-against-operator-filter-registry", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Consider addressing the following typographical errors.  Ethereum LAND:  On line 8 of OperatorFiltererUpgradeable.sol, \"subscibe\" should be \"subscribe\", and \"or copy or just to the subscription provided\" should be \"or copy the subscription provided\".  On line 388 of LandBaseTokenV3.sol, \"when the size is smaller than..\" should be bigger.  On line 470 of LandBaseTokenV3.sol, \"transfered\" should be \"transferred\".  On line 485 of LandBaseTokenV3.sol, \"itereates\" should be \"iterates\".  On line 513 of LandBaseTokenV3.sol, \"ittereated\" should be iterated.  On line 81 of ERC721BaseTokenV2.sol, \"resset\" should be \"reset\".  On line 81 of ERC721BaseTokenV2.sol, \"overriden\" should be \"overridden\".  Polygon LAND:  On line 8 of OperatorFiltererUpgradeable.sol, \"subscibe\" should be \"subscribe\".  On line 8 of OperatorFiltererUpgradeable.sol, \"or copy or just to the subscription provided\" should be \"or copy the subscription provided\".  On line 38 of LandTunnelV2 contract, \"trasnfer\" should be \"transfer\".  On line 51 of LandTunnelV2 contract, \"trasnfer\" should be \"transfer\".  On lines 54-57 of the PolygonLandTunnelMigration contract, \"cant\" should be \"can't\".  On line 142 of PolygonLandTunnelV2 contract, \"trasnfer\" should be \"transfer\".  On line 155 of PolygonLandTunnelV2 contract, \"trasnfer\" should be \"transfer\".  On line 86 of ERC721BaseTokenV2.sol, \"send\" should be \"sender\".  On line 155 of ERC721BaseTokenV2.sol, there should be a space after \"token\".  On line 355 of ERC721BaseTokenV2.sol, \"adddress\" should be \"address\".  On line 373 of ERC721BaseTokenV2.sol, \"adddress\" should be \"address\".  On line 418 of ERC721BaseTokenV2.sol, \"recieving\" should be \"receiving\".  On line 625 of PolygonLandBaseTokenV2.sol, \"transfered\" should be \"transferred\".  On line 640 of PolygonLandBaseTokenV2.sol, \"itereates\" should be \"iterates\".  On line 664 of PolygonLandBaseTokenV2.sol, \"qua\" should be \"quad\".  On line 668 of PolygonLandBaseTokenV2.sol, \"ittereated\" should be \"iterated\".  On line 163 of PolygonLandV2.sol, the double quote \"\" after \"true\" should be a single quote \".  Update: Resolved in pull request #912 at commit e11a210.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unclear event names", "body": "Clear and concise event names are essential for off-chain applications to grasp the intended purpose of the event. However, there are several events in the codebase that lack precisely defined names. In particular:  Ethereum LAND:  The MetaTransactionProcessor event defined in the MetaTransactionReceiverV2 contract  The Minter event defined in the LandBaseTokenV3 contract  The SuperOperator event defined in the SuperOperatorsV2 contract  Polygon LAND:  The Minter event defined in the PolygonLandBaseTokenV2 contract  The SuperOperator event defined in the WithSuperOperatorsV2 contract  Consider renaming these events using descriptive names that provide a clear context of their intended purpose.  Update: Acknowledged, not resolved. The Sandbox team stated:  We decided not to change the event names because those events are already consumed.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#unclear-event-names", "labels": ["OpenZeppelin"]}, {"title": "Lack of attribution", "body": "Throughout the codebase, there are files that have been copied and modified from the OpenSea operator filter registry codebase. The original contracts use the MIT license which requires attribution. In particular:  Ethereum LAND:  OperatorFiltererUpgradeable.sol  IOperatorFilterRegistry.sol  Polygon LAND:  OperatorFiltererUpgradeable.sol  IOperatorFilterRegistry.sol  Consider including a comment in these files attributing the original authors and source.  Update: Resolved in pull request #914 at commit e46d379.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-attribution", "labels": ["OpenZeppelin"]}, {"title": "Gas optimizations", "body": "The following opportunities for gas optimization were identified:  Ethereum LAND:  In the _checkTransfer function of the ERC721BaseTokenV2 contract, lines 150 and 151 perform the same check. Consider refactoring the function to avoid duplicated checks.  Using a bitmask to clear the highest 8 bits in the _getX and _getY functions in the LandBaseTokenV3 contract would be more gas efficient.  Polygon LAND:  Using a bitmask to clear the highest 8 bits in the _getX and _getY functions in the PolygonLandBaseTokenV2 contract would be more gas efficient.  Consider optimizing gas consumption by adjusting the aforementioned issues.  Update: Resolved in pull request #915 at commit 2c0b610.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent use of named return values", "body": "The following contracts contain some functions with named return values, and some without.  In Ethereum LAND:  The LandBaseTokenV3 contract  The AddressUtils library  The ERC721BaseTokenV2 contract  In Polygon LAND:  The PolygonLandV2 contract  The PolygonLandBaseTokenV2 contract  The ERC721BaseTokenV2 contract  The ERC2771Handler contract  The LandTunnelV2 contract  The PolygonLandTunnelV2 contract  Consider using named return values consistently throughout every contract and library to provide a clear understanding of the code's behavior.  Update: Resolved in pull request #918 at commit ef05b41.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#inconsistent-use-of-named-return-values", "labels": ["OpenZeppelin"]}, {"title": "Naming issues hinder code understanding and readability", "body": "Throughout the codebase, there are several functions and variables that could be renamed to better reflect their purpose, in particular:  Ethereum LAND:  _checkAndClear function of LandBaseTokenV3 contract.  The landMinted variable in the _mintAndTransferQuad function in the LandBaseTokenV3 contract corresponds to the number of LAND tokens transferred, not minted.  Polygon LAND:  The _checkAndClear function in the PolygonLandBaseTokenV2 contract.  The landMinted variable in the _mintAndTransferQuad function in the PolygonLandBaseTokenV2 contract corresponds to the number of LAND tokens transferred, not minted.  The maxAllowedQuads state variable in the PolygonLandTunnelV2 contract corresponds to the maximum amount of LAND tokens, not quads.  The user address parameter in the mintQuad function of the IPolygonLand interface should be to address  In PolygonLandTunnelV2 contract, gasLimit should be totalGasLimit  The naming of setLimit and setupLimits functions in the PolygonLandTunnelV2 contract is unclear and confusing.  Consider renaming these functions and variables to improve the codebase's readability.  Update: Partially resolved in pull request #922 at commit 0de8738. The Sandbox team stated:  __checkAndClear called in in regroupquad to check it the owner of 1x1 land in a 3x3 quad are owned by the from or not and clears the owner data of any land that is owned by the from address___checkAndClearOwner called during the mintandtransfer to check if the sub quads are owned by the msg.sender and clears it___checkBatchReceiverAcceptQuadAndClearOwner checks if to in the mintandtransfer if is a contract and can handle ERC721(onERC721 receive functions) and clears the owner of 1x1 land for every 1x1 land in the Quad to be mint and transfer___numLandMinted is the cumulative value of number of land tokens that are found to be already minted. numLandMinted variable correspond to number of Land already minted_", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#naming-issues-hinder-code-understanding-and-readability", "labels": ["OpenZeppelin"]}, {"title": "public function that should have external visibility", "body": "The following public function should be external:  The batchTransferQuadToL2 function in the LandTunnelV2 contract.  Consider changing the visibility of this function to external in order to clarify that this function will only be called by external contracts.  Update: Resolved in pull request #947 at commit 0d38cb3.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#public-function-that-should-have-external-visibility", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent ordering of functions", "body": "The codebase generally follows the recommended order in the Solidity Style Guide, however there are some instances where contracts deviate from the style guide. In particular:  In the LandTunnelMigration contract there are functions defined before the constructor.  In the PolygonLandTunnelMigration contract there are functions defined before the constructor.  In the PolygonLandTunnelV2 contract there are functions defined before the initialize function. While not directly part of the Solidity style guide, the initialize function should be considered comparable to a constructor.  To improve the project's overall legibility, consider standardizing ordering throughout the codebase, as recommended by the Solidity Style Guide.  Update: Resolved in pull request #949 at commit a706fe6.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#inconsistent-ordering-of-functions", "labels": ["OpenZeppelin"]}, {"title": "Variables could be immutable", "body": "Throughout the codebase, there are several variables that could be immutable. For instance:  The polygonLand variable in the PolygonLandTunnelMigration contract.  The newLandTunnel variable in the PolygonLandTunnelMigration contract.  The oldLandTunnel variable in the PolygonLandTunnelMigration contract.  The landToken variable in the LandTunnelMigration contract.  The newLandTunnel variable in the LandTunnelMigration contract.  The oldLandTunnel variable in the LandTunnelMigration contract.  To better convey the intended use of variables and to potentially save gas, consider adding the immutable keyword to variables that are only set in the constructor.  Update: Resolved in pull request #953 at commit 6b5b33f.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#variables-could-be-immutable", "labels": ["OpenZeppelin"]}, {"title": "Unused bytes data value", "body": "Throughout the codebase, there are calls for transferring LAND tokens that include the data argument. These calls pass a value of \"0x\" for the data argument which is never used within the calls. In particular:  Within the migrateLandsToTunnel function in the LandTunnelMigration contract.  Within the migrateQuadsToTunnel function in the LandTunnelMigration contract.  Within the migrateLandsToTunnel function in the PolygonLandTunnelMigration contract.  Within the migrateToTunnelWithWithdraw function in the PolygonLandTunnelMigration contract.  Within the migrateQuadsToTunnel function in the PolygonLandTunnelMigration contract.  Consider passing empty bytes data (\"\") to these functions as the input value is never used and consumes unnecessary gas.  Update: Resolved in pull request #952 at commit b949862.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#unused-bytes-data-value", "labels": ["OpenZeppelin"]}, {"title": "Anyone can initialize the implementation contracts", "body": "Initializable contract is added. Since there is no access control on the  _disableInitializers function, introduced in version  4.6.0 of the OpenZeppelin contracts library, from the constructors of the implementation contracts to prevent them from being initialized. In particular, the following implementation contracts should be updated:  PolygonLandV2  LandTunnelV2  PolygonLandTunnelV2  While not a direct security concern, it is a good practice to prevent the implementation contract from being initialized as this could allow an attacker to take over the contract. This would not affect the functionality of the proxy contract as only the storage of the implementation contract would be affected.  Update: Acknowledged, not resolved. The Sandbox team stated:  We decided not to fix this issue as it would require upgrading the OpenZeppelin contracts to 4.6.0, which is not an option for us with the current implementation.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#anyone-can-initialize-the-implementation-contracts", "labels": ["OpenZeppelin"]}, {"title": "Additional \"Do No Harm\" Principles", "body": "At the request of SphereX, in addition to the usual risks to safety and security, we assessed the risks associated with their \"Do No Harm Principles\". These principles strive to ensure that even if the owner of SphereXEngine is compromised or is malicious, the following statements should hold true:  SphereXEngine is immutable. Even in extreme cases of a malicious operator of SphereXEngine, the maximal potential damage would be limited to reverting transactions for the protected contracts. In that case, SphereXEngines Admin can renounce the malicious operators ownership and restore control.  SphereXProtected does not collide with existing standard libraries/contracts (e.g., we do not store SphereXAdmin on slot 0 to prevent collision with OpenZeppelin Ownable).  The product does not alter the customer's contract logic. It only approves or denies transactions.  Our product cannot alter the state of the customer's contract (apart from predetermined SphereXProtected-related storage slots).  The engine does not censor transactions based on addresses (tx.origin, msg.sender).  Customer's or owner's funds are not processed by or stored inside SphereXEngine at any phase during or after execution of tx.  The SphereXAdmin is always capable of disabling the SphereXEngine, and therefore SphereXEngine's owner is incapable of a DoS or ransom scenario.  SphereXAdmin has no control over the customers' contracts except for: (a) enabling/updating the engine, (b) disabling the engine, and (c) changing SphereXAdmin's address.  Management functions: no one besides SphereXAdmin and SphereXEngine's owner can access management functions for the SphereXProtected and SphereXEngine (respectively).  Risks concerning these principles were considered in our analysis. Although most of the principles hold, there are some important considerations for a few of the principles above:  Regarding principle 5: Some censorship by SphereXEngine is discussed in finding M-05.  Regarding principle 7: Short-term DoS risks caused by malice or false positives are discussed in findings H-03 and M-01.  Regarding principle 8: This holds true as long as SphereXAdmin is controlled by the customer, and not SphereX, as intended in principle #1. This is because setting a reverting engine can disable the customer's contract.  Update: The section above was edited following the fix-review process to reflect the updated state of the codebase, as multiple findings that were related to principles 5, 7, 8, and 9 were resolved.  High Severity", "html_url": "https://blog.openzeppelin.com/spherex-audit#additional-\"do-no-harm\"-principles", "labels": ["OpenZeppelin"]}, {"title": "Call Depth Is Never Explicitly Reset", "body": "The Engine does not explicitly reset the call depth, which can lead to an off-by-one error in certain situations:  If an arbitrary call to the Pre-hook is allowed from an unprotected method in an approved sender (a known client-reported edge case)  In the event of a malicious or incorrectly implemented call to the Pre-hook from a contract mistakenly or maliciously added to approved senders  If an assembly return occurs (another known client-reported edge case)  In scenarios where checks are bypassed due to forceCheck being set to false, the pattern could drift into an unpredictable state because it will not be reset. This could result in the rejection of all ensuing transactions once a check is eventually enforced during a Post-hook invocation (triggered from an external method).  Given its potential to cause a Denial-of-Service (DoS), it will require deactivating the protection mechanism.  Consider introducing explicit recording and invalidation of currentBlockOriginHash for both call flow and transaction flow cases, along with a reset of the call depth when currentBlockOriginHash is invalidated. This approach is valid because a call or a transaction cannot extend over multiple transactions, allowing each new transaction to always start from a depth of 1. In this manner, any drift scenario would only persist for the duration of that transaction instead of indefinitely. Furthermore, it is recommended to include all three scenarios in the testing suite to ensure any state corruption is confined to a single transaction.  Update: Resolved in pull request #6 at commit c95fce7.", "html_url": "https://blog.openzeppelin.com/spherex-audit#call-depth-is-never-explicitly-reset", "labels": ["OpenZeppelin"]}, {"title": "Mutually Exclusive Modes are Allowed at the Same Time", "body": "Both operational modes can be activated simultaneously, which leads to a conflict as their resetting logics are mutually exclusive. Specifically, one mode resets with each new transaction, while the other resets at each external call. The existing documentation further indicates that these modes are intended to operate individually rather than concurrently.  Consider adopting an Enum implementation for the modes to enforce exclusivity. Alternatively, input validation can be added on mode setters to prevent invalid configurations.  Update: Resolved in pull request #10 at commit d221420.", "html_url": "https://blog.openzeppelin.com/spherex-audit#mutually-exclusive-modes-are-allowed-at-the-same-time", "labels": ["OpenZeppelin"]}, {"title": "Loop-Called Methods and MultiCall Contracts Require an Individual Allowance of All Likely Loop Lengths and Combinations", "body": "The current implementation requires explicit permission for each possible loop length if a protected method (internal, public, or external) is invoked within a loop. Furthermore, for contracts using the common MultiCall functionality, every likely combination of called methods will need to be allowed separately. This can result in false positives under these conditions:  For Control Flow (CF): if a protected method is ever called from another protected method within a loop.  For Transaction Flow (TF): in general, even without being called from another protected method.  For TF, this means that a third-party (e.g., an integrating) contract calling any protected method in a loop, or using a MultiCall could experience reverts. This reduces the attractiveness of TF to some integrators, as a protocol cannot realistically prevent third-party integrators from calling its methods within loops or from using MultiCall.  For CF, this means that a protected method should avoid calling another protected method in a loop.  This issue is also applicable to recursion, although recursion is rarely used in high-level methods in Solidity.  Consider prohibiting the instrumentation of calls within loops in integrating protocols, and recommend against using TF for protocols likely to be called by third-party contracts.  Update: Acknowledged. The SphereX team stated:  The customers will be notified of this issue. Internal loops (CF) will be solved by preapproving each number of repetitions within a range discussed with the customer. We plan to invest further research resources to find a generic solution for the TF case.  Medium Severity", "html_url": "https://blog.openzeppelin.com/spherex-audit#loop-called-methods-and-multicall-contracts-require-an-individual-allowance-of-all-likely-loop-lengths-and-combinations", "labels": ["OpenZeppelin"]}, {"title": "currentBlockOriginHash Invalidation Issues Can Lead to False Positives", "body": "Although reported as a known issue, this can be particularly severe in some circumstances:  On some L2s, such as Arbitrum, where block.number is the L1 block number, so it will remain constant for some time. Similarly for Optimism, and zkSync.  In chains that rely on relayers and Account Abstraction (quite possibly zkSync).  This can cause intermittent false positives as the second transaction could be rejected for producing a disallowed pattern.  Consider adding block.timestamp (will help with Arbitrum and Optimism) into the hash. It is possible that block.difficulty, tx.gasPrice, block.baseFee can also help.  Update: Resolved in pull request #11 at commit 51e369f.", "html_url": "https://blog.openzeppelin.com/spherex-audit#currentblockoriginhash-invalidation-issues-can-lead-to-false-positives", "labels": ["OpenZeppelin"]}, {"title": "Potential for Hidden Attack Patterns During the Recording Phase", "body": "The recording phase of the contract could potentially be manipulated by an attacker to obscure harmful patterns within a large number of benign ones. This could allow a malicious user to introduce an attack vector into the list of permitted patterns.  For example, if an attacker discovers a reentrancy vulnerability, they could perform numerous transactions, some of which involve harmless reentrancy (resulting in no loss of funds), with the hope of getting this pattern added to the allow-list.  Once the protection is activated and the total value locked (TVL) within the contract reaches a significant level, the attacker may exploit the allow-listed attack pattern.  Consider filtering the initially recorded patterns, particularly if there are a large number of them.  Update: Acknowledged. The SphereX team stated:  Recommendation accepted. Our research team is working on analyzing and sanitizing the recording phase data (identifying abnormal transactions and analyzing them before approving them into the permissible patterns).", "html_url": "https://blog.openzeppelin.com/spherex-audit#potential-for-hidden-attack-patterns-during-the-recording-phase", "labels": ["OpenZeppelin"]}, {"title": "Client Project Has No Ownership Over the Engine Configuration", "body": "At present, the contract engine is solely governed by a single administrator address. As this address is expected to actively operate the contract, it is most likely to be a Spherex-controlled address. This means that if SphereS, as the admin, fails to cooperate, the client project can only deactivate the protection mechanism or deploy its own engine and update its state. This creates an imbalanced relationship since the client has no direct control over patterns being accepted or rejected.  This issue's severity is exacerbated by a lack of emitted events during both configuration and operation, which would hinder the client from configuring their \"forked\" engine instance.  To address this, consider implementing Role-Based Access Control (RBAC). Under this framework, the client project would have admin control while SphereX is granted an operational role, enabling them to update patterns and other configurations. If the client project is dissatisfied with recent configuration updates, they can take over the operational role, reverse any changes, and maintain the previous protection level. Additionally, consider implementing events such that a community member would be able to reconstruct the state of the Engine with common tools.  Update: Resolved in pull request #14 at commit ec71add.", "html_url": "https://blog.openzeppelin.com/spherex-audit#client-project-has-no-ownership-over-the-engine-configuration", "labels": ["OpenZeppelin"]}, {"title": "No Events Emitted and Lack of External Views in Contracts", "body": "The contracts SphereXProtected and SphereXEngine do not emit events or implement external views. This absence of conventional observability methods demands specialized tools and knowledge to monitor and inspect the operational state of these contracts. Moreover, it impedes the utilization of existing data analysis tools, dashboards, monitoring utilities, and front-end frameworks. This opacity can diminish trust, neutrality, and the overall utility of the system for integrating projects.  This lack of observability can introduce further security risks. For instance, if the engine is deactivated by the admin, whether intentionally or unintentionally, it could go unnoticed due to reliance on specialized monitoring tools and their operators. This will expose the customer to exploits via allowing previously disallowed transaction flows, and expose SphereX to legal and reputational risks.  We recommend implementing comprehensive observability of all state changes using both views and events. The entire current state of the contract should be visible through views and reconstructible via events. Additionally, to facilitate gas savings for the customer, consider providing a feature to control event emission during hook execution, possibly through a configuration or input flag. This feature may be more relevant for deployments on Ethereum L1, as the extra gas cost for emitting events on L2s or sidechains should be insignificant.  Update: Partially resolved in pull request #15 at commit f0a818b. Configuration-related events were added. However, state changes involved in hook execution remain unaccompanied by events, which will make tracking the operation of the engine harder to track off-chain.", "html_url": "https://blog.openzeppelin.com/spherex-audit#no-events-emitted-and-lack-of-external-views-in-contracts", "labels": ["OpenZeppelin"]}, {"title": "Potential Issues in Systems Using Factory and Beacon Patterns", "body": "Various smart contract systems implement patterns that dynamically add contracts to the system based on user actions. Some notable examples include pool creation in AMMs, personal proxies in Maker, and multi-signature (multi-sig) Safe creation. When protected by SphereX, each newly created instance of a factory-created contract would need to be separately added by the admin, preventing the contract from becoming immediately operational upon creation, adding a centralizing step, and adding operational complexity.  Furthermore, performing changes to admin and engine addresses on the dynamically generated contracts will be operationally complex and error-prone.  Moreover, these systems can pose a risk of targeted censorship due to the capability of SphereX to exclude a specific personal proxy address from the allowed senders.  Consider implementing Role-Based Access Control (RBAC) as described in the OpenZeppelin documentation. One possible approach could be creating a SENDER_CONFIG_ROLE with the permissions to add allowed senders. This will allow the general admin to assign this role to the factory contract when needed. Alternatively, consider establishing an additional administrative function that enables a factory contract to independently add a newly created contract as an approved sender.  To resolve the configuration issues, consider utilizing a single contract for updating and querying the configuration in the client's project.  To alleviate the censorship risk, consider separating the storage of factory-added addresses and disallowing the removal of any specific address from that set. Alternatively, consider implementing a long delay for removing senders, such that a censored personal proxy owner will have time to exit the system if both SphereX and the Client project are forced to censor it.  Update: Partially resolved in pull request #27 at commit 052bb05. A role-based system was implemented, allowing factories to add new senders on-chain. The configuration and censorship concerns were not resolved.  Low Severity", "html_url": "https://blog.openzeppelin.com/spherex-audit#potential-issues-in-systems-using-factory-and-beacon-patterns", "labels": ["OpenZeppelin"]}, {"title": "Outdated Solidity Versions", "body": "Throughout the codebase, there are pragma statements that use an outdated version of Solidity. For instance:  The pragma statement on line 4 of ISphereXEngine.sol  The pragma statement on line 4 of SphereXEngine.sol  The pragma statement on line 4 of SphereXProtected.sol  Consider taking advantage of the latest Solidity version to improve the overall readability and security of the codebase by avoiding known bugs and taking advantage of newer language features.  Furthermore, it is highly unlikely that newly deployed customer contracts will use versions of Solidity that are older than 0.8. To accommodate specific clients who may require an older version, code can be back-ported and audited separately for that specific integration as part of the integration audit (which is needed for other reasons as well).  Update: Resolved in pull request #16 at commit 9b6c897.", "html_url": "https://blog.openzeppelin.com/spherex-audit#outdated-solidity-versions", "labels": ["OpenZeppelin"]}, {"title": "Possible Underflow Due to Unnecessary Signed Integers in Interfaces", "body": "SphereXEngine hooks lack validation of the sign of num parameter. This can cause an underflow when adding it to _callDepth in _addCFElement if using a Solidity version older than 0.8. This is unintuitive and error-prone, and is particularly problematic if not all numbers are \"flipped\". For example, two Pre hooks called in sequence, one with positive num, and another with negative, will cause the call depth to go back to starting depth unexpectedly.  In addition to being error-prone, the use of int16 in the signatures of sphereXGuard modifiers in SphereXProtected and hooks in SphereXEngine is redundant. This is because a positive number is always expected for the Pre hooks, and a negative, exactly opposite number is expected for the Post hooks. Thus, the negative sign can always be safely added in the Post hooks, leaving the engine's implementation encapsulated and separated from the interface.  Consider using uint256 for the identifier in all the modifiers and the hooks, and using signed integers only in the internal calls in SphereXEngine. Alternatively, consider adding input validation to the hooks to ensure that the sign is as expected.  Update: Resolved in pull request #6 at commit c95fce7.", "html_url": "https://blog.openzeppelin.com/spherex-audit#possible-underflow-due-to-unnecessary-signed-integers-in-interfaces", "labels": ["OpenZeppelin"]}, {"title": "Transaction Flow Mode Vulnerable to Circumvention Via Flashbot Bundles", "body": "A complex attack transaction (disallowed by the engine) involving multiple calls to the client contract may be subdivided into several transactions and executed in sequence, using a private mempool like flashbots. This may allow circumventing the protection of TF mode by employing different externally owned accounts (EOAs) as tx.origin.  For instance, an attack requiring a sequence of [attacker: action_A, attacker: action_B] could appear as a novel transaction flow pattern if executed from an attacking contract. To circumvent this, the attack could be submitted as a bundle of EOA transactions: [attacker: action_A, decoy: action_C, attacker: action_B]. Each transaction in this bundle would pass transaction flow validation as a separate flow. Although certain attacks, such as flashloan attacks, can't be fragmented in this manner, many other multi-step attacks can be.  Consider documenting this option as a consideration for correctly configuring the engine for the client's security needs.  Update: Acknowledged. The SphereX team stated:  This possible bypass scenario is to be taken into account and will be the subject of future research.", "html_url": "https://blog.openzeppelin.com/spherex-audit#transaction-flow-mode-vulnerable-to-circumvention-via-flashbot-bundles", "labels": ["OpenZeppelin"]}, {"title": "Potential for User Exploitation by Integrating Protocols Through Engine Swapping", "body": "An integrating protocol, even one with an ostensibly limited control area, might exploit the sphereXGuard modifiers as a \"backdoor\" by transitioning to a custom engine implementation.  For instance, a protocol could introduce a custom engine that disallows non-insider users from interacting with it. This restriction could prevent users from managing their assets. This will enable insiders to extract these assets by exploiting protocol-specific mechanisms that depend on unrestricted access. Examples could involve using liquidations for lending protocols or arbitrage for trading protocols.  Consider documenting the trust assumptions of the system such as the expanded control surface and potential centralization risks that can arise, so that they are clear to the user communities of the integrating protocols.  Update: Acknowledged. The SphereX team stated:  We will explicitly state this issue in the trust assumptions of the system. Moreover, we will state in our legal documents that we are not liable for any engine that was not deployed and operated by SphereX.", "html_url": "https://blog.openzeppelin.com/spherex-audit#potential-for-user-exploitation-by-integrating-protocols-through-engine-swapping", "labels": ["OpenZeppelin"]}, {"title": "Potential Risks with Hooks' Internal Visibility", "body": "To minimize the likelihood of erroneous integrations, consider changing the visibility of these methods to private.  Update: Resolved in pull request #19 at commit 1baed67.", "html_url": "https://blog.openzeppelin.com/spherex-audit#potential-risks-with-hooks'-internal-visibility", "labels": ["OpenZeppelin"]}, {"title": "Unrecorded Calls Resulting from try/catch or Low-Level Reverts", "body": "When a protocol employs try/catch or low-level calls anticipated to revert and subsequently relies on these revert messages as part of its operational logic, these calls may not be recorded. This is due to the fact that they revert their changes in the Engine.  An illustrative example can be seen in the counterfactual, always-reverting rollback logic in the Synthetix V3 upgrade module. Here, calls always revert but with varying revert errors.  We recommend documenting this edge case to ensure it is considered during integration audits.  Update: Acknowledged. The SphereX team stated:  We will document this edge case.", "html_url": "https://blog.openzeppelin.com/spherex-audit#unrecorded-calls-resulting-from-try/catch-or-low-level-reverts", "labels": ["OpenZeppelin"]}, {"title": "Potential Loss of Ownership During Transfer", "body": "The SphereXEngine implements a single-step ownership transfer mechanism that is prone to operator errors.  Consider using the Ownable2Step contract from the OpenZeppelin library for a safer transition of ownership. This will increase the contract's flexibility and safeguard against unintended loss of control over the engine. Also, the inclusion of a renounce function should be considered to enable owners to more transparently renounce their ownership.  Update: Resolved in pull request #14 at commit ec71add.", "html_url": "https://blog.openzeppelin.com/spherex-audit#potential-loss-of-ownership-during-transfer", "labels": ["OpenZeppelin"]}, {"title": "SphereXEngine Rule Configuration Methods Poorly Named", "body": "In the implementation of the SphereXEngine contract, the activateRules method allows the owner to deactivate the rules by inputting all 8 bytes as zero. This is counterintuitive as activateRules should logically serve to enable the rules, not deactivate them. The deactivateRules method, meant for rule suspension, becomes redundant as the same action can be performed through the activateRules method.  In order to avoid any misinterpretation or misuse, it is recommended to integrate a validation process within the activateRules method that prevents rule deactivation. Alternatively, one could consider consolidating these functions into a single method, configureRules, that toggles the state of the rules based on the input provided, thus eliminating any redundancy and making the system's interface more intuitive.  Update: Resolved in pull request #10 at commit d221420.", "html_url": "https://blog.openzeppelin.com/spherex-audit#spherexengine-rule-configuration-methods-poorly-named", "labels": ["OpenZeppelin"]}, {"title": "Ownership Transfer in changeSphereXAdmin Method is Error-Prone", "body": "The changeSphereXAdmin method currently allows for a single-step ownership transfer, which can be risky due to potential mistakes leading to loss of control to update the Admin or the Engine address and thus losing the ability to opt out of the SphereX Protect.  Consider using a two-step ownership transfer to provide a safer mechanism. Moreover, the method should also validate that the proposed address conforms to the expected contract interface to ensure correct functionality. Lastly, the method should be made virtual to permit override by integrating contracts with their own access control measures.  Update: Resolved in pull request #14 at commit ec71add.", "html_url": "https://blog.openzeppelin.com/spherex-audit#ownership-transfer-in-changespherexadmin-method-is-error-prone", "labels": ["OpenZeppelin"]}, {"title": "Gas Inefficiencies", "body": "There are many instances throughout the codebase where changes can be made to improve gas consumption. For example:  Consolidate _callDepth, _currentPattern, and _currentBlockOriginHash into a single slot. This can be done using a Struct that defines variables that will fit into a single slot. For example, using uint16 for _callDepth, uint216 for _currentBlockOriginHash, and bytes3 for _currentBlockOriginHash. This optimization reduces storage operations and may save up to 5000-7000 gas per transaction during execution on L1.  Avoid performing multiple storage reads and writes on _callDepth. _currentBlockOriginHash and _currentPattern during _addCFElement by reading once into stack variables, and writing back into storage at the end of the method.  Avoid checking for the active rule twice during _addCFElement by using a separate internal method for each case. Additionally, splitting the method into two distinct methods will make the code more readable, auditable, and testable. This will also make the exclusivity of the modes clear.  Use modifiers with internal methods. By doing so, bytecode size is reduced.  The returnsIfNotActivated check can be performed once in the SphereXGuard modifiers, rather than being checked twice for each hook (Pre and Post).  Performing calculations for values that will not change is suboptimal. deactivateRules() should set the value directly.  Use a more recent version of Solidity to take advantage of compiler gas optimizations for both deployment and execution costs.  Use custom errors implementation (if upgrading to a more recent version of Solidity) to save on deployment cost and failed execution gas cost.  When performing these changes, aim to reach an optimal tradeoff between gas optimizations and readability. Having a codebase that is easy to understand reduces the chance of future errors and improves community transparency.  Update: Partially resolved. Suggestion 1 was implemented in pull request #23 at commit 950a31d. Suggestions 2 and 3 were implemented in pull request #6. Suggestion 7 was implemented in pull request #16. Regarding the other suggestions, the SphereX team stated:  After deeply discussing every gas inefficiency issue, we have reached an optimal tradeoff from our point of view.", "html_url": "https://blog.openzeppelin.com/spherex-audit#gas-inefficiencies", "labels": ["OpenZeppelin"]}, {"title": "SphereXEngine Migration Flow Susceptible to Human Error", "body": "The SphereXEngine migration process is currently prone to errors if it involves multiple smart contracts using SphereXProtected. When SphereXEngine requires a change, the admin of each contract must manually replace the engine address. This approach becomes problematic if any contracts are inadvertently overlooked and continue pointing to an outdated version of the SphereXEngine. This can be particularly problematic, or operationally complex when dealing with a large or dynamic system of contracts (e.g., contracts using a factory pattern).  Consider introducing a periphery contract that enables updating all associated contracts in a single transaction. Alternatively, consider implementing a pattern similar to the beacon proxy pattern. The beacon proxy pattern centralizes the update mechanism and reduces the manual workload. By referencing a single 'beacon' that holds the updated SphereXEngine address, all contracts could automatically reflect the most recent engine version, thus reducing the risk of misalignment and potential system malfunctions.  Update: Acknowledged, not resolved. The SphereX team expressed that a separate config contract is not desirable due to gas costs.", "html_url": "https://blog.openzeppelin.com/spherex-audit#spherexengine-migration-flow-susceptible-to-human-error", "labels": ["OpenZeppelin"]}, {"title": "Confusing Revert Messages", "body": "The current revert messages !SX:DETECTED, !SX:SENDERS and !SX:SPHEREX may confuse users of the integrating protocols due to their lack of descriptiveness. It is recommended to revise these messages to more accurately depict the corresponding issues and context (e.g., \"SphereX error: disallowed tx pattern\"). This change will enhance user understanding and facilitate troubleshooting of contract interaction issues.  Update: Resolved in pull request #22 at commit b533a0b.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/spherex-audit#confusing-revert-messages", "labels": ["OpenZeppelin"]}, {"title": "Non-Explicit Imports Are Used", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code, and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are being used. For instance:  Line 6 of SphereXEngine.sol  Line 7 of SphereXEngine.sol  Line 6 of SphereXProtected.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Resolved in pull request #20 at commit cfdd63c.", "html_url": "https://blog.openzeppelin.com/spherex-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Usage of Small-Size Variables", "body": "The usage of int16 and other small number types is present in several parts of the codebase. It is advisable to refrain from using these types in memory calls, interfaces, and calculations. Only employ them when writing into storage for storage slot packing. Utilizing these smaller size variables can lead to potential issues:  Overflows and underflows in mathematical and casting operations can remain undetected  Increased gas expenditure during execution and larger contract bytecode size  Reduced code readability  Potential precision loss  We recommend using uint256 and int256 types whenever possible instead of smaller sizes. Perform downcasting (safely) only when writing values into storage.  Update: Resolved in pull request #18 at commit 0df3f47.", "html_url": "https://blog.openzeppelin.com/spherex-audit#usage-of-small-size-variables", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "There are typographical errors in the codebase's comments. For example:  \"Poistive\" should be \"Positive\".  \"insturction\" should be \"instruction\".  \"nody\" should be \"body\".  \"rotected\" should be \"protected\".  \"defence\" should be \"defense\".  \"abitrary\" should be \"arbitrary\".  \"visibality\" should be \"visibility\".  \"defenitions\" should be \"definitions\".  \"Technolegie\"s should be \"Technologies\".  Consider scanning the codebase using automated tooling and correcting typographical errors.  Update: Resolved in pull request #21 at commit ed86e8a.", "html_url": "https://blog.openzeppelin.com/spherex-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Misleading Comments", "body": "The following misleading comments were identified:  The comment describing the setMintCapNumerator references a MintCapNumeratorSet event, but it should be MintCapNumeratorChanged.  The comment describing the mint function says the mint time interval \"is initially set to 1 year\", which suggests it could be updated. It is actually a constant and can only be changed if the whole contract is upgraded.  Consider updating the comments accordingly.  Update: Resolved in pull request #50 at commit 2a04393.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#misleading-comments", "labels": ["OpenZeppelin"]}, {"title": "Bridge Can Be Reinitialized", "body": "The L1StandardBridge contains a guard condition to prevent it from being reinitialized. However, it assumes the messenger will be non-zero after initialization, which is not guaranteed by the initialize function. This means it is possible to initialize the other variables and later overwrite them. In practice, the contract will be non-functional until the messenger is set.  Nevertheless, in the interest of predictability, consider ensuring the messenger is non-zero during initialization.  Update: Resolved in pull request #1027 at commit e641f0e.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#bridge-can-be-reinitialized", "labels": ["OpenZeppelin"]}, {"title": "Disable Implementation Contract", "body": "The L1StandardBridge implementation contract sets the messenger to the zero address, but this doesn't prevent it from being initialized.  In the interest of limiting the attack surface, consider ensuring the implementation contract cannot be initialized. This could be achieved by setting the messenger to an unused non-zero address.  Update: Acknowledged, not resolved. The Mantle team stated:  We will use our proxy contract to initialize right after deploying the bridge contract, and the proxy contract will be required to be initialized only once. Even if someone tries to initialize the implementation contract afterwards, it will have no impact on our proxy contract.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#disable-implementation-contract", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "In MantleTokenMigrator.sol the received word is misspelled as recieved in several places. Consider resolving this typographical error.  Update: Resolved in pull request #53 at commit 6b78f54. There have been unrelated changes that removed several instances.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "ETH Handling Can Be Simplified", "body": "reverts on the  the Solidity documentation, without the  Update: Resolved in pull request #45 at commit c662f74.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#eth-handling-can-be-simplified", "labels": ["OpenZeppelin"]}, {"title": "Gas Savings", "body": "The setMintCapNumerator and setTreasury functions can consume less gas by emitting an event first and then changing the storage variable.  For example, the following code snippet  uint256  previousMintCapNumerator  mintCapNumerator  mintCapNumerator  _mintCapNumerator  emit  MintCapNumeratorChanged  msg.sender  previousMintCapNumerator  mintCapNumerator  );  may be rewritten as:  MintCapNumeratorChanged  msg.sender  mintCapNumerator  _mintCapNumerator  );  mintCapNumerator  _mintCapNumerator  Consider rewriting the setMintCapNumerator and setTreasury functions to save gas.  Update: Resolved in pull request #48 at commit 4159ef3.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#gas-savings", "labels": ["OpenZeppelin"]}, {"title": "Imprecise Docstrings", "body": "Some imprecise docstrings have been identified:  The comment describing the parameter for the setMintCapNumerator function does not follow the Ethereum Natural Specification Format (NatSpec) format.  For consistency with the migrateAllBIT description, the migrateBIT description should note that the _amount must be non-zero.  Consider updating the docstrings accordingly.  Update: Resolved in pull request #54 at commits 97d88d6 and 0e76225, and pull request #55 at commit d515706.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#imprecise-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Redundant Cast", "body": "The sweepTokens function of the MantleTokenMigrator contract redundantly casts both known token addresses to the address type. Consider removing the unnecessary cast operations.  Update: Resolved in pull request #44 at commit bb921bf.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#redundant-cast", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Multiple Inheritance", "body": "The L1MantleToken contract inherits from several contracts with redundant dependencies. This means that some of the contracts are inherited both directly and indirectly. For example, inheriting ERC20VotesUpgradeable makes inheriting ERC20PermitUpgradeable and ERC20Upgradeable redundant.  the sequence of initializations more intuitive. However, it also forces the  boilerplate functions that are unrelated to the token's new logic. Our opinion is that removing redundancy from the inheritance chain would make the contract simpler and easier to reason about. Consider limiting the inheritance chain to the necessary contracts (i.e.,  Update: Acknowledged, not resolved. The Mantle team stated:  We prefer not to make modifications to improve explicitness and make the initialization sequence more intuitive.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#unnecessary-multiple-inheritance", "labels": ["OpenZeppelin"]}, {"title": "BIT Token Address Is Used Instead of MNT Token Address", "body": "The bridge contracts have specific logic to handle MNT tokens but the L1StandardBridge contract currently associates the BIT token with the L2 Mantle token. Consider reusing the existing variable to identify the MNT token address.  Note that the L2 token also still references the BIT token and should be updated accordingly.  Update: Resolved in pull request #1075 at commit d140d18. The correct address is now hardcoded instead of reusing the variable.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#bit-token-address-is-used-instead-of-mnt-token-address", "labels": ["OpenZeppelin"]}, {"title": "Unused Function", "body": "The L1StandardBridge has a function to donate ETH to the contract. However, this function is a holdover from the Optimism code base and is not required for a fresh deployment. Consider removing it.  Update: Resolved in pull request #1029 at commit a47a661.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#unused-function", "labels": ["OpenZeppelin"]}, {"title": "Unusable Data Parameter", "body": "All deposits and withdrawals pass an arbitrary data parameter over the bridge. This parameter is emitted in the events on both sides, but is otherwise unused. The documentation claims it is a convenience for external contracts, but it is not passed to the destination and other contracts cannot read the events. Consider clarifying how the parameter could be used, or remove it from the transfer.  Update: Acknowledged, not resolved. The Mantle team stated:  We see this as a data interface reserved for subsequent cross-chain interoperability.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#unusable-data-parameter", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Specialization", "body": "depositing Mantle tokens. However, only the  token mapping validation differs from the generic ERC-20 case, so the  generic ERC-20 logic. This would remove unnecessary withdrawal logic and make the  finalizeMantleWithdrawal function obsolete. Consider simplifying the code accordingly.  Update: Acknowledged, not resolved. The Mantle team stated:  We divided this method mainly to facilitate the addition of necessary restrictions for the L2 native token, and also to facilitate subsequent targeted maintenance.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#unnecessary-specialization", "labels": ["OpenZeppelin"]}, {"title": "Redundant Validation", "body": "The finalizeMantleWithdrawal function validates that it is called from the L2 bridge, but this check is repeated on the finalizeERC20Withdrawal function. Consider removing the redundant validation.  Update: Resolved in pull request #1031 at commit 5fbb898.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#redundant-validation", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Encapsulation", "body": "claims to retrieve tokens from the  takes them from the caller. Similarly, the event  references the caller instead of the  both calling functions pass the message sender as the  Update: Acknowledged, not resolved. The Mantle team stated:  We will consider this in future Mantle Network upgrades.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#incorrect-encapsulation", "labels": ["OpenZeppelin"]}, {"title": "Use of Hardcoded Values", "body": "The L1StandardBridge contract has the address of the MNT token hardcoded. Consider creating a constant variable and using it instead of the hardcoded address for clarity and readability.  Similarly, the L2StandardBridge contract hardcodes the IL2StandardERC20 identifier. Consider using the more expressive type(IL2StandardERC20).interfaceId statement instead.  Update: Acknowledged, not resolved. The Mantle team stated:  We will consider this in future Mantle Network upgrades. For now, we have decided to hardcode this address as we do not foresee the MNT token address changing in the future as the MNT token itself is upgradable.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#use-of-hardcoded-values", "labels": ["OpenZeppelin"]}, {"title": "ProposalDeleted events can be emitted with non-existent assertionId", "body": "assertionDisputedCallback function does not validate whether its  to be emitted for any  A user can accomplish this by interacting with the OptimisticOracleV3 contract. The OptimisticOracleV3 contract's assertTruth function may be called by any user to assert truths that will be accepted as true unless disputed. This will result in the generation of a new assertionId that will be stored in the oracle's assertions mapping.  disputeAssertion will call  call the  line 369 because the caller is the  line 374 the  Consider adding a check in the assertionDisputedCallback function that ensures the assertionId value maps to a non-zero proposalHash, which ensures the assertion is associated with a proposal.  Update: Resolved in pull request #4486 at commit d880037.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#proposaldeleted-events-can-be-emitted-with-non-existent-assertionid", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission", "body": "The internal _sync function changes the OptimisticOracleV3 contract used by the OptimisticGovernor, but unlike other administrative setter functions, it does not emit an event when a change occurs.  Consider adding a new OptimisticOracleChanged event that is emitted by _sync whenever the finder contract returns a different address than that of the current optimisticOracleV3 variable.  Update: Resolved in pull request #4487 at commit f3ea7a6.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#lack-of-event-emission", "labels": ["OpenZeppelin"]}, {"title": "Lack of contract address check in setEscalationManager", "body": "The setEscalationManager administrative function in OptimisticGovernor does not perform any checks to validate that the _escalationManager address is a contract. Specifying an address where no contract code is deployed could result in unexpected behavior since the OptimisticOracleV3 contract expects that all escalation managers implement EscalationManagerInterface.  Consider using the existing _isContract function to validate the _escalationManager argument.  Update: Resolved in pull request #4488 at commit ed8f3fc.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#lack-of-contract-address-check-in-setescalationmanager", "labels": ["OpenZeppelin"]}, {"title": "Unused event", "body": "SetCollateral event, which can be used to emit an updated  SetBond event, which includes both the  Consider renaming the SetBond event to SetCollateralAndBond, and removing the unused SetCollateral event.  Update: Resolved in pull request #4489 at commit cf6b68f.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#unused-event", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent variable naming", "body": "Some functions in the OptimisticGovernor contract use leading underscores to name either input parameters or local variables in cases where there is no name collision with the contract's storage variables:  proposeTransactions: Input parameters _transactions and _explanation  executeProposal: Input parameter _transactions and local variable _proposalHash  deleteProposalOnUpgrade: Input parameter _proposalHash  _constructClaim: Input parameters _proposalHash and _explanation  For consistency and clarity, consider removing the leading underscore from these parameters, and also updating the corresponding docstrings. Alternatively, consider using the leading underscore consistently throughout the contract.  Update: Resolved in pull request #4490 at commit 8a2f6d5.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#inconsistent-variable-naming", "labels": ["OpenZeppelin"]}, {"title": "Locked ETH", "body": "The executeProposal function has the payable modifier. However, any ETH sent is not used in the function and will be locked in the OptimisticGovernor contract.  Consider removing the payable attribute to avoid potentially locking ETH in the OptimisticGovernor contract.  Update: Resolved in pull request #4491 at commit f417256.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#locked-eth", "labels": ["OpenZeppelin"]}, {"title": "Misleading variable names", "body": "proposalHashes and  assertionIds mapping names misleadingly reflect the contents of one another (i.e.,  To increase clarity, consider swapping the names of the proposalHashes and assertionIds mappings, so that the variable names correspond to the values being stored.  Update: Resolved in pull request #4492 at commit c1e996c.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#misleading-variable-names", "labels": ["OpenZeppelin"]}, {"title": "Redundant code", "body": "Consider making the following changes to eliminate redundant code:  In OptimisticGovernor.sol, msg.sender is used on line 263 to transfer tokens from the proposer to the Optimistic Governor contract, but proposer has already been defined as msg.sender on line 234, so proposer can be used here.  In OptimisticGovernor.sol, line 310 computes the assertionId, but this value was already computed on line 307 inside a require statement. Lines 310 and 307 can be swapped, and proposalHashes[_proposalhash] inside the require statement can be replaced with assertionId.  In StakerInterface.sol, the setDelegate and setDelegator functions are marked virtual, but interface functions are implicitly virtual, so this keyword can be removed.  Update: Resolved in pull request #4493 at commit 835a6ff. The StakerInterface.sol file was not changed. The UMA team stated:  The issue in StakerInterface.sol was not fixed as it is not used by the Optimistic Governor, while the dependent VotingV2 contract is already deployed in production.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#redundant-code", "labels": ["OpenZeppelin"]}, {"title": "Gauges Rewards Can Be Erroneously Deleted", "body": "Each voting period is supposed to last 1 week. There are two ways for anyone to update the system's period after this time has passed:  Call one of the distribute functions of VoterV3, which in turn calls the Minter contract's update_period function  Call update_period on the Minter contract directly  The second method to update the system's period can allow attackers to delete entire reward distributions which were allocated to gauges. This is attributed to a bug in the _updateFor function, where the calculation incorrectly considers the timestamp of the current active epoch when counting votes, rather than the previous epoch.  More specifically, consider the following attack scenario:  First, the function update_period is called directly on the Minter contract and executes successfully. This means that the active period changes, the gauges' reward for the finished period is notified to the Voter contract, and the index is increased.  vote (or  poke) function is called. As a result, the function  the total votes for _epochTimestamp are equal to zero, as this is the very first vote for the new period. In consequence,  supplyIndex for the gauge is set equal to index without accounting the claimable amount for the period that just ended,  making it impossible for the gauge to ever claim that amount.  An attacker could exploit this vulnerability to cause a complete DoS on the gauges' rewards by voting a small amount on every gauge before their distribute functions are called.  Consider using the previous period's timestamp for calculations in the _updateFor function. As an alternative solution, consider completely removing the gauge's update functionality upon every voting action and relying on the updates triggered by the Voter's distribute functions, which are supposed to take place once per voting period.  Update: Resolved in pull request #2 at commit f2c6688.  High Severity", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#gauges-rewards-can-be-erroneously-deleted", "labels": ["OpenZeppelin"]}, {"title": "GaugeExtraRewarder Accounts for Excessive Rewards", "body": "The function updatePool of the GaugeExtraRewarder contract is supposed to update the pool's information upon every state-changing interaction with the contract. The reward-per-share value is then updated by considering the time interval since the latest update. However, the reward rate value keeps increasing even if the distribution period is over. In this scenario, the variable lastRewardTime is assigned incorrectly, as it should be set equal to the end of the distribution period.  This improper accounting results in users accruing and taking rewards that were meant for other users, and in the worst case, causing the underlying gauge to revert during deposit and withdrawal operations.  Consider updating the implementation of the GaugeExtraRewarder contract so as to properly account for the reward amounts after the end of the distribution period.  Update: Resolved in pull request #3 at commit 6d740eb.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#gaugeextrarewarder-accounts-for-excessive-rewards", "labels": ["OpenZeppelin"]}, {"title": "Killing a Gauge Could Result in Stuck Funds", "body": "When a gauge is killed using the killGauge or killGaugeTotally functions in the VoterV3 contract, the gauge-related data is cleared out. However, it is possible that the killed gauge has already been voted for and its respective vote weight has been added to the period's total vote weight. The period's total weight is not adjusted when a gauge is killed, resulting in the portion of the reward that is committed to that gauge remaining unused and getting stuck in the contract.  More specifically, there are two possible problematic scenarios, regarding the rewards accounting of the current and previous period relative to the time that a gauge is killed.  Effects on the currently active voting period. If a gauge is killed in the middle of a period, it's possible that this gauge has already been voted for by some users, so it already contributes to totalWeightPerEpoch, which is later used to compute the index for that period. As a consequence, the killed gauge's share will eventually remain stuck in the contract. In fact, totalWeightsPerEpoch should be updated when killing a gauge to discard the respective votes and distribute the whole $THE emissions amount to the remaining gauges.  Effects on the previous voting period. It is possible that a gauge is killed at a time when a voting period has been updated but the reward amounts have not been distributed yet. This is possible because updating the period and distributing the respective rewards to the gauges require two separate actions (period update and rewards distribution). In this scenario, the totalWeightsPerEpoch that has been used to compute index includes the killed gauge's weight, even if its share of rewards will not be attributed to it after it's killed. Thus its share will eventually remain unused and stuck in the VoterV3 contract.  When a gauge is killed, consider updating the totalWeightsPerEpoch value of the currently active voting period in order to distribute the whole reward amount to the remaining gauges. In addition, consider consolidating the reward amount notification and the distribution of the gauges' rewards into one single action in order to avoid losing part of the previous period's rewards when a gauge is killed.  Update: Partially resolved in pull request #3 at commit 7864885. The effects on the currently active voting period are handled by updating totalWeightPerEpoch when killing a gauge. Regarding the effects on the previous voting period, the Retro-Thena team stated:  We do not expect any gauge to be killed between a period update and rewards distribution because of our off-chain procedures that make sure to trigger the rewards distribution right after each period update.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#killing-a-gauge-could-result-in-stuck-funds", "labels": ["OpenZeppelin"]}, {"title": "Killed Gauge Can Be Voted For", "body": "temporary and  permanent removal of gauges in the case they are malicious. In order to track the state of a gauge, the  isAlive mapping will be set to either  During the voting phase, there only exists a check to see if the address is a gauge, which doesn't take into account if the gauge is still alive. This check will pass for any gauge temporarily killed, as a temporarily killed gauge will still reside in the isGauge mapping. This means users can vote for killed gauges.  Voting for killed gauges should not be allowed, as it results in reward tokens being allocated towards the gauge without any way to claim them. This means any votes for temporarily killed gauges will lock funds on the VoterV3 contract.  Consider removing the ability to vote from a killed gauge in order to avoid locking funds on the VoterV3 contract.  Update: Resolved in pull request #3 at commit 64bf6c5.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#killed-gauge-can-be-voted-for", "labels": ["OpenZeppelin"]}, {"title": "Users Can Be Locked From Voting", "body": "In the VoterV3 contract, users vote in order to receive rewards from gauges. During each epoch, rewards are reset and users need to vote again, either by calling the poke or vote functions. If a user does not vote in an epoch, they will not receive rewards. Votes do not roll over from epoch to epoch.  Through each method of voting, the _reset function is first called, clearing out the tokenId's previous vote allocation to the gauges. During this reset, internal and external bribes from the votes are cleared by calling the withdraw function of the Bribes contract.  However, if a gauge is destroyed via the killGaugeTotally function, these internal and external Bribes addresses will be cleared while leaving the poolVote mapping populated with votes for pools that are linked to non-existent gauges. This results in the withdraw calls reverting for any voter escrow token that contains uncleared votes for a gauge killed with killGaugeTotally.  Interestingly, these calls should fail during the gauges[_pool] lookup in the _withdraw execution, as that is supposed to be cleared during killGaugeTotally call, but due to another bug, this will return the killed gauge's address.  Similarly, this should be able to be remedied by creating a new gauge for the pool, but in the _createGauge function, there is a requirement for the gauges mapping to hold the zero address, which will not be the case due to the previously mentioned bug.  In order to avoid locking users out of voting, consider adding logic to avoid reverts during _reset calls to tokens which have outstanding votes to totally killed gauges.  Update: Resolved in pull request #3 at commit 35c01c8. The killGaugeTotally function has been completely removed.  Medium Severity", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#users-can-be-locked-from-voting", "labels": ["OpenZeppelin"]}, {"title": "GaugeExtraRewarder's Reward Rate Can Be Set to an Arbitrary Value", "body": "The owner of the GaugeExtraRewarder contract is able to set an arbitrary value as reward rate. However, the reward rate should always be calculated based on the existing reward amount and the distribution period otherwise inconsistent accounting is possible, resulting in unfair rewards distribution among the users.  Consider removing the function setRewardPerSecond and always using setDistributionRate instead in order to avoid inconsistent rewards accounting.  Update: Resolved in pull request #4 at commit e8b757f.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#gaugeextrarewarder's-reward-rate-can-be-set-to-an-arbitrary-value", "labels": ["OpenZeppelin"]}, {"title": "Reward Amount in GaugeExtraRewarder Can Be Overestimated", "body": "The function setDistributionRate of the GaugeExtraRewarder contract first checks that the contract's balance is sufficient to cover the notified reward amount. However, any remaining reward amount from the latest distribution period is not considered during this check, as it is added to the total distributed reward amount only after this check. As a consequence, the final reward amount to be distributed may exceed the contract's reserves.  Consider ensuring that the total reward amount can be covered by the contract's reserves.  Update: Resolved in pull request #4 at commit a1dc83f.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#reward-amount-in-gaugeextrarewarder-can-be-overestimated", "labels": ["OpenZeppelin"]}, {"title": "Wrong Accounting of Extra Rewards Upon Depositing to a Gauge", "body": "Liquidity providers that deposit their tokens to a gauge are entitled to a portion of the extra rewards, if there are any. The extra reward amount is handled by the GaugeExtraRewarder contract and is distributed to the users in proportion to their share of the total staked LP tokens. Thus, each time the total staked amount in the gauge changes (i.e. upon deposit or withdrawal) the extra-reward-per-share value needs to be updated appropriately.  the user's funds are first transferred to the contract and the  onReward function of the  is only called thereafter. The sequence of these two operations is wrong, leading to a miscalculation of  when updating the pool, because the gauge's balance has already been increased by the freshly deposited amount. As a consequence, the users might lose part of their reward.  Consider transferring the user's deposited funds only after calling the onReward function.  Update: Resolved in pull request #4 at commit da9df65.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#wrong-accounting-of-extra-rewards-upon-depositing-to-a-gauge", "labels": ["OpenZeppelin"]}, {"title": "Error-prone Contracts Initialization", "body": "The VoterV3 contract has two separate initialization functions, initialize and _init. It is possible for users to interact with this contract in the invalid state where the initialize function has been called but the _init function has not.  In addition, several other issues appear:  initialize sets minter and permissionRegistry equal to msg.sender. This is incorrect as neither of these contracts are supposed to initialize the Voter contract, nor should they be the same contract.  _init is required to be called by the minter or the permissionRegistry, though neither of these contracts supports this functionality.  On a similar note, the constructor of the PermissionsRegistry contract sets all three entities thenaTeamMultisig, thenaMultisig, and emergencyCouncil equal to msg.sender. While this is technically feasible (e.g. all three lie behind the same multisig), it seems unreasonable to have all three roles handled by the same entity.  Consider having a single initialization function for all upgradeable contracts and assigning reasonable values to the system's parameters during initialization, so the protocol can immediately function in a secure manner.  Update: Acknowledged, not resolved. The Retro-Thena team stated:  Users cannot interact with the protocol before _init is called. This is because createGauge would fail since no token will have been whitelisted yet and vote/reset/poke would also fail since the minter contract, used in _epochTimestamp, would point to an EOA. The msg.sender sets are because of the way we deploy the contracts. The minter (multisig, etc) can be set after deploying the VoterV3/PermissionRegistry contracts. Therefore, function _init must be called before actually going live.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#error-prone-contracts-initialization", "labels": ["OpenZeppelin"]}, {"title": "Risk-prone Accounting in GaugeExtraRewarder", "body": "The GaugeExtraRewarder contract tracks shares by updating internal tracking whenever the onReward function is called. This function is called from the underlying gauge whenever tokens are deposited or withdrawn.  not track the state changes, resulting in the internal accounting of the  Consider updating the accounting method of the GaugeExtraRewarder to accurately track shares on their associated gauge contracts. In order to save gas fees, it may be beneficial to piggyback off of the accounting done on the gauge rather than tracking everything in two places.  Update: Partially resolved in pull request #4 at commit 6b17ff7. The pause functionality for the GaugeExtraRewarder contract has been removed. The accounting method has not been altered, which requires that the users interact with the system when a \"GaugeExtraRewarder\" contract with extra reward amount is deployed in order to start accruing their extra reward share.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#risk-prone-accounting-in-gaugeextrarewarder", "labels": ["OpenZeppelin"]}, {"title": "gauges Mapping Cannot Be Cleared", "body": "deleted then later  retrieved and used as a key to clear the  gauges mapping. This retrieval will always return the zero address, resulting in the pool address never being cleared from the  Additionally, this results in the inability to create a new gauge for a pool whose gauge was killed totally, as the mapping will already have an address set for the given pool.  In order to avoid an invalid gauge state, consider correctly clearing the gauges mapping when killing a gauge totally.  Update: Resolved in pull request #3 at commit 35c01c8. killGaugeTotally has been completely removed.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#gauges-mapping-cannot-be-cleared", "labels": ["OpenZeppelin"]}, {"title": "Whitelist Is Incompatible With Proxies", "body": "The intention of the whitelist is to keep malicious contracts off of the protocol. When whitelisting upgradable contracts, it is possible for a formerly benign whitelisted contract to eventually upgrade into a malicious contract. Because of this, proxy contracts should never be whitelisted.  Consider removing any proxy contracts from the whitelist and introducing documentation around proxies in the whitelist code to avoid future proxies from being whitelisted.  Update: Acknowledged, not resolved. The Retro-Thena team stated:  We do due diligence on the whitelisted projects and we are in contact with them. Some projects (e.g., USDC) need a proxy.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#whitelist-is-incompatible-with-proxies", "labels": ["OpenZeppelin"]}, {"title": "Removing a Role Does Not Remove the Role From All Users", "body": "The removeRole function in the PermissionsRegistry contract allows the Thena multisig to remove roles from the PermissionsRegistry.  When removing roles, the role is removed from the _roles list, but does not remove that role's entries in the hasRole mapping.  typical access control using the  Consider removing all users from the role upon deletion of the role.  Update: Resolved in pull request #4 at commit 8b2b9c1.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#removing-a-role-does-not-remove-the-role-from-all-users", "labels": ["OpenZeppelin"]}, {"title": "Unfair Distribution of Rewards", "body": "In the VoterV3 contract, the _notifyRewardAmount function allows individuals to contribute to the next epoch's total rewards.  Reward distribution is calculated by directly increasing the index parameter. During an _updateFor call, which is called every time a vote is cast to a gauge, the rewards are allocated to the gauges when claimable is updated. Since _updateFor calculates the rewards based off of the current number of votes, the reward will be distributed in proportion to the snapshot of votes in the system when the funds were contributed.  This does not follow the rest of the protocol's calculations, where voters are given rewards at the end of the voting epoch and the votes' distribution is final. Additionally, this could lead to bizarre contributions where a user can contribute a large sum of rewards, but be the only voter in the epoch, resulting in all of the contributed funds being directed to them, signaling a large contribution but really not contributing anything.  In order to match other accounting done in the system and avoid the distribution of rewards based on intermediate voting state, consider changing the _notifyRewardAmount to distribute rewards at the end of the epoch rather than during one.  Update: Resolved in pull request #4 at commit 8f108fd. _notifyRewardAmount has been completely removed.  Low Severity", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unfair-distribution-of-rewards", "labels": ["OpenZeppelin"]}, {"title": "Invalid Entries Remain in _addressToRoles Array", "body": "The function removeRoleFrom of the PermissionsRegistry contract revokes a role from the specified address and is supposed to appropriately update the arrays _roleToAddresses and _addressToRoles.  However, because of a typographical error, the code never loops over the _addressToRoles array, resulting in invalid remaining entries.  Consider fixing the typographical error so that no invalid entries remain in the array.  Update: Resolved in pull request #5 at commit 95d8d25.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#invalid-entries-remain-in-_addresstoroles-array", "labels": ["OpenZeppelin"]}, {"title": "Unsigned Integer Variable Declared and Treated as a Signed Integer", "body": "The rewardDebt field of the Poolnfo struct in the GaugeRewarder contract is declared as a signed integer, though it can never hold a negative value as it is initialized to zero and is monotonically increasing. This leads to essentially unnecessary type casts and is also error-prone in consideration of future updates to the codebase.  Consider declaring variable rewardDebt as an unsigned integer.  Update: Resolved in pull request #5 at commit a2f45d0.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unsigned-integer-variable-declared-and-treated-as-a-signed-integer", "labels": ["OpenZeppelin"]}, {"title": "Unsafe ABI Encoding", "body": "It is not an uncommon practice to use abi.encodeWithSignature or abi.encodeWithSelector to generate calldata for a low-level call. However, the first option is not typo-safe and the second option is not type-safe. The result is that both of these methods are error-prone and should be considered unsafe.  On line 861 of VoterV3 an unsafe ABI encoding is used.  Consider replacing the unsafe ABI encoding with abi.encodeCall, which checks whether the supplied values actually match the types expected by the called function and also avoids errors caused by typos. Alternatively, consider changing the type of the token argument to an IERC20 so normal function calling syntax can be used.  Update: Resolved in pull request #5 at commit c3f6d95.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unsafe-abi-encoding", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings.  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Partially resolved in pull request #5 at commit 7ca7fc1.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "The System Is Not Robust to Delayed Period Updates", "body": "The major functionalities of the protocol (i.e., voting, reward emission, reward distribution) are synchronized on a per-voting-period basis, making the per-period consistency in bookkeeping and accounting a factor of major importance. However, the way that the current implementation refers to a voting period is rather brittle.  More specifically, the unique identifier of a period is its starting timestamp, which is calculated modulo a week's time. When calculating the rewards of a voting period that has ended, that period's id is retrieved by manually subtracting a week's seconds from the current active period's id. However, it is not strictly imposed by the codebase that the time interval between two periods is exactly one week but rather a multiple of a week's time. It is possible, for example, that a period update action continuously fails for longer than a full period. In such a case, it would not be possible to access the past period's data and any reward distribution action would fail silently, essentially locking the reward amount in the contract.  Consider introducing a status for each voting period's phase, so as to be able to distinguish non-existing period timestamps due to delayed updates. As a more radical solution, consider adopting a serial number for uniquely identifying the voting periods and making the period's starting timestamp a separate data entry. This would make the system robust to potential delayed period updates but would also help improve the codebase's readability and overall quality making it less error-prone during future upgrades.  Update: Acknowledged, not resolved. The Retro-Thena team stated:  We ensure that each epoch lasts 1 week and no delays are allowed.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#the-system-is-not-robust-to-delayed-period-updates", "labels": ["OpenZeppelin"]}, {"title": "Voting or Poking Emits Wrong Event", "body": "vote or  poke function in the  _reset which emits the  Hence, both Voted and Abstained events are emitted when a user votes. This could result in off-chain indexers computing the protocol state incorrectly.  Consider removing the Abstained event from the _reset function and only emitting it when a user abstains from voting.  Update: Acknowledged, not resolved. The Retro-Thena team stated:  We will keep it as it is in order to avoid the extra gas costs for loading the event variables to the reset function.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#voting-or-poking-emits-wrong-event", "labels": ["OpenZeppelin"]}, {"title": "Missing Error Messages in require Statements", "body": "Throughout the codebase, there are require statements that lack error messages. There are also some cases, for example line 244 in the GaugeV2 contract, where the error messages are undermined by checks that overflow or underflow.  Consider including specific, informative error messages in require statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied. In addition, consider appropriately modifying the checks of the require statements wherever needed, so that it is not possible to overflow or underflow.  Update: Partially resolved in pull request #5 at commit bd5dc9f and pull request #6 at commit a0eac56. There are still a few require statements that miss an error message.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#missing-error-messages-in-require-statements", "labels": ["OpenZeppelin"]}, {"title": "Code Simplifications", "body": "A number of opportunities for simplification of code were observed. Consider applying the following code simplifications:  Contracts GaugeV2 and GaugeV2_CL can be refactored so that a base contract contains the shared logic.  Line 123 of the GaugeExtraRewarder contract can be simplified as the first condition is already covered by the second.  The functions balanceOfAt, balanceOf, balanceOfOwner, and balanceOfOwnerAt can be refactored to consolidate shared logic.  The functions getReward and getReward in the GaugeV2 contract can be refactored to consolidate shared logic.  The functions earned, earned, and earnedWithTimestamp in the Bribes contract can be refactored to consolidate shared logic.  The functions getReward, getReward, getRewardForOwner, and getRewardForAddress in the Bribes contract can be refactored to consolidate shared logic.  In the _vote function of the VoterV3 contract, the _usedWeight variable contains the same value as _totalWeight is therefore redundant.  The conditions on lines 820-822 of the _updateFor function in the VoterV3 contract can be consolidated into a single if statement.  The functions _updateFor and _updateForAfterDistribution of the VoterV3 contract can be refactored to consolidate shared logic.  The function claimBribes on line 467 and claimFees on line 475 of the VoterV3 contract are identical.  The function claimBribes on line 483 and claimFees on line 490 of the VoterV3 contract are identical.  \u0399n line 366 and line 382 of the _reset function of the VoterV3 contract, there is a call to _epochTimestamp() but the value of _epochTimestamp() has already been stored in the _time variable.  The _reset function in the VoterV3 contract can be refactored as follows:   The if statement on line 370 is redundant as _votes is unsigned and resides inside the check on line 362   The calls to _withdraw on lines 371-372 are only meaningful when the token was last voted in the current active period. If these operations are performed only when this condition is met, the if statement on line 382 can be removed.  In the GaugeV2 contract, the variables fees0 and fees1 are only ever assigned to zero and are therefore redundant.  In the Bribes contract, the if statement on lines 131-133 is redundant, as this case is covered on lines 141-143.  In the Bribes contract, the IERC20Ext interface declaration is unused and can be removed.  In the PermissionsRegistry contract, the functions __helper_stringToBytes and __helper_bytesToString are unused and can be removed.  \u0399n lines 821 and 844 of the VoterV3 contract, the variable _supplied is cast to uint but is already declared as uint256.  The increaseGaugeApprovals function of the VoterV3 contract sets the allowance of _gauge by VoterV3 to type(uint256).max. However, the allowance is already set to type(uint256).max during the gauge creation and the approval will never decrease. Therefore, the increaseGaugeApprovals function is redundant.  Update: Partially resolved in pull request #5 at commit 541bd36. Most of the suggestions were not adopted.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#code-simplifications", "labels": ["OpenZeppelin"]}, {"title": "Lacking Address Checks", "body": "Across the repository, addresses are commonly saved into storage to be used later. When saving addresses, it is best practice to add basic checks to avoid accidentally setting these addresses to incorrect values.  In some cases, these addresses are expected to be set to the address of smart contracts. The best check for this case is using a code length check such as a library that provides an isContract function. Otherwise, a check to ensure the provided address is not the zero address is helpful.  Consider adding address checks to all addresses set in the codebase to help protect against the accidental setting of incorrect addresses.  Update: Resolved in pull request #5 at commit 0f1551f.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#lacking-address-checks", "labels": ["OpenZeppelin"]}, {"title": "No Events Emitted on Sensitive Operations", "body": "There are plenty of functions throughout the codebase that are only called by privileged entities and perform sensitive operations, yet emit no events. Whenever executing highly privileged actions on-chain, it is preferable to emit some sort of logging for easy tracking and increased visibility. Some examples of such sensitive actions include setting a role for an address in the PermissionsRegistry contract, setting a new owner in the Bribes contract, and activating emergency mode in the Gauge contracts.  Consider emitting informative events upon each sensitive operation taking place in the system.  Update: Resolved in pull request #5 at commit ebf6eaa and in pull request #10 at commit b369708.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#no-events-emitted-on-sensitive-operations", "labels": ["OpenZeppelin"]}, {"title": "Recover Function Can Stall Associated Gauge", "body": "The owner of a GaugeExtraRewarder can use the recoverERC20 function to move any ERC20 token from the contract. However, if an amount of the reward token is removed while there are active users, deposit and withdraw operations in the associated gauge contract can fail on the reward transfers due to low balance.  Consider excluding rewardToken when calling function recoverERC20, so as to restrict the owner to only be able to recover funds that have mistakenly been sent to the contract. If the reward token needs to remain recoverable for emergency cases, consider adding a require statement to ensure that the GaugeExtraRewarder contract is stopped before recovering the reward token from the contract.  Update: Resolved in pull request #9 at commit 748e153 and pull request #12 at commit 7693167. For the reward token, the owner can only recover up to the amount that has not yet been accounted for distribution. The Retro-Thena team stated:  The owner of the GaugeExtraRewarder contract is either the project that provides the extra reward amount or the Thena-Retro team.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#recover-function-can-stall-associated-gauge", "labels": ["OpenZeppelin"]}, {"title": "Invalid Votes Are Counted Towards a User's Vote Weight", "body": "line 428 of the  _vote function in the  Consider reverting when a user attempts to vote for an address that is a totally killed, or otherwise invalid gauge.  Update: Resolved in pull request #9 at commit 983da1f.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#invalid-votes-are-counted-towards-a-user's-vote-weight", "labels": ["OpenZeppelin"]}, {"title": "Unused Function Arguments", "body": "The onReward function in the GaugeExtraRewarder contract has two unused arguments: pid and extraData.  To improve the overall clarity, intentionality, and readability of the codebase, consider removing the unused function parameters. This would simplify the calling contract's code as well.  Update: Resolved in pull request #6 at commit 62a11ec.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unused-function-arguments", "labels": ["OpenZeppelin"]}, {"title": "Hardhat console Import Present", "body": "There is a Hardhat console import on line 17 in the VoterV3 contract.  Consider removing Hardhat debugging imports to improve the codebase's readability.  Update: Resolved in pull request #6 at commit 99574c5.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#hardhat-console-import-present", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "In the Bribes and VoterV3 contracts there are some imports that are unused and could be removed:  Import Math of contract Bribes  Import Ownable of contract Bribes  Import Math of contract VoterV3  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #6 at commit 0fc5de4.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused Event", "body": "In the GaugeExtraRewarder contract, the LogOnReward event is unused.  To improve the overall clarity, intentionality, and readability of the codebase, consider emitting or removing the unused event.  Update: Resolved in pull request #6 at commit 158db13.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unused-event", "labels": ["OpenZeppelin"]}, {"title": "Lack of Indexed Event Parameters", "body": "Throughout the codebase, several events do not have their parameters indexed. For instance:  Line 439 of Bribes.sol  Line 443 of Bribes.sol  Line 73 of VoterV3.sol  Consider indexing event parameters to improve the ability of off-chain services to search for and filter for specific events.  Update: Acknowledged, not resolved.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Per-period Deposits to a Gauge and Corresponding Rewards Are Not Aligned", "body": "The owners of LP tokens that deposit to a gauge are rewarded with Thena emissions. The reward amount is proportional to the amount of votes that the gauge receives. It is updated by the end of each voting period and is fully distributed within one week (i.e. until the next reward update). Each depositor is eligible for a portion of the reward in proportion to their share of the total deposits and the duration of their deposit with respect to the distribution period.  GaugeExtraRewarder contract.  Consider clearly documenting the misalignment between the depositors' per-period contribution and the corresponding rewards (and/or extra rewards) received. Also, consider documenting how the very first depositors in a gauge essentially receive no rewards by the end of the first period.  Update: Acknowledged, not resolved. The Retro-Thena team stated:  The gauges reward distribution is designed as a continuous streamline of rewards. We do not want to limit rewards to be distributed once per epoch as in the Bribes contracts. Before the creation of a new gauge, we provide an estimation of the expected rewards in the UI.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#per-period-deposits-to-a-gauge-and-corresponding-rewards-are-not-aligned", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent and Outdated Solidity Versions", "body": "Different versions of Solidity are used across the contracts. In some contracts, the solidity version is outdated whereas in others the solidity version is floating.  Selecting a Solidity version should always be based on what features each version has, what the codebase could benefit from, as well as the list of known bugs associated with each release. Be aware that compiling and deploying on BSC with 0.8.20 may not work properly as this version introduces a new opcode - PUSH0.  Consider taking advantage of the latest Solidity version to improve the overall efficiency and security of the codebase. Regardless of the Solidity version used, consider keeping it consistent and locking it throughout the codebase to prevent the introduction of bugs due to incompatible future releases.  Update: Resolved in pull request #6 at commit 406075d.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#inconsistent-and-outdated-solidity-versions", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Use of SafeMath Library", "body": "In some contracts, such as GaugeV2, GaugeV2_CL, and GaugeExtraRewarder, the protocol uses the OpenZeppelin SafeMath library for basic arithmetic functions, while using a compiler version above 0.8. However, solc versions above 0.8 contain built-in overflow and underflow protection.  To save gas and maintain consistency with the rest of the codebase, consider using Solidity's built-in arithmetic operators.  Update: Resolved in pull request #6 at commit a0eac56 and in pull request #8 at commit ba97a1d.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unnecessary-use-of-safemath-library", "labels": ["OpenZeppelin"]}, {"title": "Unused State Variables", "body": "The factory and gaugeFactory variables in VoterV3 contract are never used. As a result, their setter functions (setPairFactory, setGaugeFactory) are essentially dead code.  In addition, the TYPE variable and modifier onlyOwner in the Bribes contract are never used.  _VE and  external_bribe are unused in  _VE and  external_bribe in  Consider removing the unused variables and their corresponding setter functions. If the variables are kept to maintain storage layout consistency with previous versions of the contract, consider documenting this fact.  Update: Partially resolved in pull request #6 at commit d720e4f and in pull request #11 at commit d04de75. The Retro-Thena team stated:  Variable TYPE is just for UI and to recognize the contract's type from BscScan.  Variable _VE is just for having extra information in the gauge contract.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unused-state-variables", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "Several variables, parameters and functions throughout the codebase might benefit from better naming. Specifically:  VoterV3.sol  All occurrences of _token representing an array should be renamed to _tokens.  All occurrences of _poolVote representing an array should be renamed to _poolVotes.  totWeightsPerEpoch could be more clearly be totalWeightsPerEpoch.  The blacklist functions could be renamed removeFromWhitelist for more clarity.  gaugesDistributionTimestmap should be renamed gaugeDistributionTimestmap.  isAlive could be isGaugeAlive.  isFactory could be isPairFactory.  GaugeExtraRewarder.sol  stop could be more clearly named paused.  lastDistributedTime could be endOfDistributionPeriod or something similar.  Function onReward could be claimReward.  The parameter lpToken of the onReward function could be userBalance or something similar.  Function setDistributionRate could be updateRewardRate.  Privileged entities thenaMultisig and thenaTeamMultisig could be given more descriptive names or docstrings that designate their distinct responsibilities.  GaugeV2.sol and GaugeV2_CL.sol  DISTRIBUTION address should be named voter and its related modifier onlyDistribution should be named onlyVoter.  Bribes.sol  addRewards could be named addRewardTokens. The same applies to functions addReward and _addReward in the same contract.  Update: Partially resolved in pull request #6 at commit d720e4f. The Retro-Thena team stated:  DISTRIBUTION: this is correct, the gauge is \"standard\" for any distributor and does not depend on voter.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit Imports Are Used", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code, and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are being used.  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged, not resolved.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "The following typographical errors have been discovered:  Lines 221-225 in the Bribes contract`: \"timestmap\" should be \"timestamp\".  Lines 111 and 117 in the Bribes contract: \"of a owner\" should be \"of an owner\".  Lines 53, 763 and 773 in the VoterV3 contract: \"gaugesDistributionTimestmap\" should be \"gaugesDistributionTimestamp\".  Line 182 in the GaugeV2_CL contract: \"sinle\" should be \"single\".  Line 146 in the MinterUpgradeable contract: function calculate_rebate should be calculate_rebase.  Update: Resolved in pull request #6 at commits ecd3134 and d720e4f.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Underscores Conflict with Solidity Style Guide", "body": "The Solidity Style Guide includes a section on how to use underscore prefixes for non-external functions and variables. Throughout the repository, publicly accessible functions and variables are incorrectly named with leading underscores. For instance:  IBribe.sol  function _deposit(uint amount, uint tokenId) external function _withdraw(uint amount, uint tokenId) external  Bribes.sol  function _deposit(uint256 amount, uint256 tokenId) external function _withdraw(uint256 amount, uint256 tokenId) public mapping(uint256 => uint256) public _totalSupply  IVoter.sol  function _ve() external  VoterV3.sol  function _init(address[] memory _tokens, address _permissionsRegistry, address _minter) external function _factories() external function _gaugeFactories() external function _notifyRewardAmount(uint amount) external function _epochTimestamp() public address public _ve  GaugeV2.sol  function _periodFinish() external IERC20 public _VE uint256 public _totalSupply mapping(address => uint256) public _balances  GaugeV2_CL.sol  function _periodFinish() external IERC20 public _VE uint256 public _totalSupply mapping(address => uint256) public _balances  PermissionsRegistry.sol  function __helper_stringToBytes(string memory _input) public function __helper_bytesToString(bytes memory _input) public  Consider fixing all instances of prefixed underscores that conflict with the Solidity Style Guide.  Update: Resolved in pull request #6 at commit 65d8936 and in pull request #8 at commit 200ba8b.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#underscores-conflict-with-solidity-style-guide", "labels": ["OpenZeppelin"]}, {"title": "Redefinition of Solidity Constants", "body": "In numerous places, hardcoded units of time are used rather than the native solidity constants for units of time.  The number 604800 is used instead of 1 weeks:  On line 689 of the VoterV3 contract  On line 835 of the VoterV3 contract  The number 86400 is used instead of 1 days:  On line 878 of the VoterV3 contract  On line 31 of the RewardsDistributor contract  On line 53 of the GaugeExtraRewarder contract  On line 90 of the GaugeV2 contract  On line 94 of the GaugeV2_VL contract  Consider using Solidity's built-in numeric constants instead of hardcoded numbers in order to improve the clarity of the codebase.  Update: Resolved in pull request #6 at commit 47aa201 and in pull request #11 at commit b36ad41.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#redefinition-of-solidity-constants", "labels": ["OpenZeppelin"]}, {"title": "Mutable Variables Never Assigned or Only Assigned Once", "body": "The following variables in the Bribes contract are only assigned once and can be declared immutable:  bribeFactory  ve  The following variables in the GaugeV2 contract are only assigned once and can be declared immutable:  DURATION  TOKEN  isForPair  rewardToken  The following variables in the GaugeV2_CL contract are only assigned once and can be declared immutable:  DURATION  TOKEN  rewardToken  The following variables in the GaugeExtraRewarder contract are never assigned and can be declared constant:  ACC_TOKEN_PRECISION  distributePeriod  Consider declaring variables that are never assigned as constant and variables that are assigned only once as immutable.  Update: Resolved in pull request #6 at commit 7626d97.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#mutable-variables-never-assigned-or-only-assigned-once", "labels": ["OpenZeppelin"]}, {"title": "Incorrect or Misleading Documentation", "body": "On line 114 of the GaugeV2_CL contract, the comment reads \"GaugeProxyL2\" but the distribution address should be that of the VoterV3 contract.  On line 305 of the VoterV3 contract, the comment reads \"Revive a malicious gauge\" but should read \"Revive a killed gauge\" as there is no reason to revive an actively malicious gauge.  On lines 11 and 14 of the PermissionsRegistry contract, the comments suggest that thenaMultisig and thenaTeamMultisig have the same responsibilities and these responsibilities relate to this contract only, while neither is true.  Consider correcting the incorrect or misleading documentation.  Update: Resolved in pull request #6 at commits 86a013e and d720e4f.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#incorrect-or-misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Mixed Use of uint and uint256", "body": "Across the codebase, both uint and uint256 keywords are used to declare unsigned integers of 256 bits in length.  To favor explicitness, consider standardizing all instances to uint256.  Update: Partially resolved in pull request #6 at commit aa2a0f6 and in pull request #11 at commit 4b654a5. There are a few cases where uint is still used.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#mixed-use-of-uint-and-uint256", "labels": ["OpenZeppelin"]}, {"title": "Code Execution Continues When It Should Revert", "body": "In the VoterV3 contract, both attachTokenToGauge and detachTokenFromGauge continue if the checks around tokenId > 0 are not satisfied. In this case, the token is not attached and the overall operation fails.  Consider reverting in the case of a failed operation to better convey the failure to the user.  Update: Resolved in pull request #6 at commit 51711b4. The functions attachTokenToGauge and detachTokenFromGauge have been removed completely.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#code-execution-continues-when-it-should-revert", "labels": ["OpenZeppelin"]}, {"title": "Uncalled External Functions", "body": "In the VoterV3 contract, the functions attachTokenToGauge and detachTokenFromGauge require that the caller be a contract in the isGauge mapping. However, neither of the gauge implementations calls this function.  If these functions are unnecessary, consider removing them.  Update: Resolved in pull request #6 at commit 51711b4.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#uncalled-external-functions", "labels": ["OpenZeppelin"]}, {"title": "Client Reported", "body": "Client Reported", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#client-reported", "labels": ["OpenZeppelin"]}, {"title": "Emergency Mode Cannot Be Deactivated in Gauges", "body": "Because of a typographical error in the stopEmergencyMode function of the contracts GaugeV2 and GaugeV2_CL, once the emergency mode has been activated it can no longer be deactivated.  Update: Resolved in pull request #7 at commit 22b1207.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#emergency-mode-cannot-be-deactivated-in-gauges", "labels": ["OpenZeppelin"]}, {"title": "_gaugeRewarder Cannot Be Reset to Zero", "body": "setGaugeRewarder function in the  _deposit,  _withdraw, and the  _getReward  functions check the  Update: Resolved in pull request #7 at commit a5da2a2.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#_gaugerewarder-cannot-be-reset-to-zero", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings. For example:  Line 18 in IRouterHelper.sol  Line 20 in IRouterHelper.sol  Line 14 in RouterHelper.sol  Line 269 in RouterHelper.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #281 at commits 394d1a7 and 9751c85. The functions were documented in their definitions in the contracts instead of their declarations in the interfaces.", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Locked BNB in Contract", "body": "There are multiple occurrences in SwapRouter.sol where ETH can become locked. For instance:  swapExactTokensForBNBAndRepay  swapExactTokensForBNBAndRepayAtSupportingFee  swapTokensForExactBNBAndRepay  swapTokensForFullBNBDebtAndRepay  Consider removing the payable attribute or adding a withdrawal feature.  Update: Resolved in pull request #281 at commit 7a8044a.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#locked-bnb-in-contract", "labels": ["OpenZeppelin"]}, {"title": "Misleading Docstrings", "body": "Line 811 in SwapRouter.sol states that the function checks if the value is \"greater than\" when it actually checks if the value is \"greater or equal to\".  Consider correcting this docstring.  Update: Resolved in pull request #281 at commit 20e3118.", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#misleading-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Naming Can Be Improved", "body": "In line 16 of CustomErrors.sol, the second parameter is named currentBlock even though the value actually contains timestamp.  In line 29 of TransferHelper.sol, TransferFromFailed can be renamed to SafeTransferFromFailed, making it consistent with other similar error names.  In lines 269 and 293 of SwapRouter.sol, swapAndRepay and swapAndRepayAtSupportingFee can be renamed to swapExactTokensForTokensAndRepay and swapExactTokensForTokensAndRepayAtSupportingFee, making them consistent with other similar function names.  Consider amending the aforementioned names for clarity and consistency.  Update: Resolved in pull request #281 at commit 027835e.", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#naming-can-be-improved", "labels": ["OpenZeppelin"]}, {"title": "Some Convenience Functions Are Missing", "body": "The SwapRouter contract has functions to facilitate supply and repay operations for ERC-20 tokens. However, some of the functions are missing.  Here are some examples of missing functions, although this is not an exhaustive list.  swapExactTokensForBNBAndSupply  swapExactTokensForBNBAndSupplyAtSupportingFee  swapTokensForExactBNBAndSupply  swapTokensForExactBNBAndSupplyAtSupportingFee  Consider adding them to offer more convenience functions to the users.  Update: Resolved in pull request #281 at commits fb66414 and cf6b8cb. All the suggested functions were implemented with the exception of swapTokensForExactBNBAndSupplyAtSupportingFee. The Venus team stated:  New functions added to the SwapRouter contract:  swapExactTokensForBNBAndSupply  swapExactTokensForBNBAndSupplyAtSupportingFee  swapTokensForExactBNBAndSupply  We cannot implement swapTokensForExactBNBAndSupplyAtSupportingFee as swapTokensForExactBNBAtSupportingFee does not exist in the RouterHelper because getting the amount of the tokens (with fees on transfer) to swap for an exact amount of BNB is not possible.", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#some-convenience-functions-are-missing", "labels": ["OpenZeppelin"]}, {"title": "Confusing Use of ETH and BNB in Comments and Function Names", "body": "BNB and ETH are referenced multiple times interchangeably throughout the codebase. For example, in lines 129, 154, 221, and 241. The actual deployment will be on BSC and ETH mentions are a result of PancakeSwap being a Uniswap fork.  To increase the clarity of the codebase, consider changing all mentions of ETH to BNB.  Update: Resolved in pull request #281 at commits bbe298f, 9751c85, and dbf855c.", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#confusing-use-of-eth-and-bnb-in-comments-and-function-names", "labels": ["OpenZeppelin"]}, {"title": "Lack of SPDX License Identifiers", "body": "Throughout the codebase, there are files that lack SPDX license identifiers. For instance:  IRouterHelper.sol  SwapRouter.sol  CustomErrors.sol  IPancakePair.sol  IPancakeSwapV2Factory.sol  IPancakeSwapV2Router.sol  IVBNB.sol  IVtoken.sol  InterfaceComptroller.sol  PancakeLibrary.sol  To avoid legal issues regarding copyright and follow best practices, consider adding SPDX license identifiers to files as suggested by the Solidity documentation.  Update: Resolved in pull request #281 at commit 8b08294.", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#lack-of-spdx-license-identifiers", "labels": ["OpenZeppelin"]}, {"title": "PancakeRouter Functions' Code Can Be Reused", "body": "The SwapRouter contract adapts the swap router logic from the PancakeRouter contract. It also adds code that operates either before or after a swap. The adapted code increases the complexity of the SwapRouter contract which makes it more prone to potential bugs.  Consider calling the PancakeRouter functions instead of adapting their code to the SwapRouter contract.  Update: Acknowledged, not resolved. The Venus team stated:  Our PancakeRouter contract uses a newer Solidity version and reverts with custom errors instead of require statements. We prefer to maintain and use our version.", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#pancakerouter-functions'-code-can-be-reused", "labels": ["OpenZeppelin"]}, {"title": "Outdated Chainlink Interface", "body": "line 201 of ChainlinkOracle, the interface  its documentation. This prevents the usage of deprecated functions in the  Consider updating the interface used in the ChainlinkOracle from AggregatorV2V3Interface to AggregatorV3Interface.  Update: Resolved in pull request #84 at commit ddd4b02.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#outdated-chainlink-interface", "labels": ["OpenZeppelin"]}, {"title": "Misleading Documentation", "body": "The following documentation is misleading:  Line 83 of BoundValidator says \"range error thrown if lower bound is greater than upper bound\" instead of \"range error thrown if lower bound is greater than or equal to upper bound\".  Line 18 of TwapOracle says that the baseUnit signifies the \"decimals of the underlying asset\", but it actually takes the value of 1e{decimals} of the asset.  Line 25 of TwapOracle says that \"XVS-WBNB is not reversed, while WBNB-XVS is\", when in reality the opposite is true.  Consider updating these misleading comments to match the code's intention.  Update: Resolved in pull request #84 at commit f4352f1.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Constants Not Using UPPER_CASE Format", "body": "In TwapOracle.sol the following constants are not using UPPER_CASE format:  The bnbBaseUnit constant declared on line 47  The busdBaseUnit constant declared on line 48  According to the Solidity Style Guide, constants should be named with all capital letters with underscores separating words. For better readability, consider following this convention.  Update: Resolved in pull request #84 at commit 70a2211.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#constants-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "Lack of Idiomatic Code Layout", "body": "According to the Solidity Style Guide, elements inside of contracts, libraries, and interfaces should be in the following order: type declarations, state variables, events, errors, modifiers, and finally functions.  In addition, the guide states that \"functions should be grouped according to their visibility and ordered\" first by the constructor, followed by the receive function (if it exists), the fallback function (if it exists), public functions, internal functions, and finally private functions. In addition, since the contracts are implementation contracts, it is idiomatic to place the initialize function directly below the constructor.  Throughout the codebase, the layouts of the files do not follow the Solidity Style Guide and are not consistent with each other. Consider moving the modifiers, events, errors, and functions in these files to match the Solidity Style Guide.  Update: Acknowledged, not resolved. The Venus team stated:  Ignoring the Pyth Interface because it was copied from the original project and linting would make the diff more complicated when updating.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#lack-of-idiomatic-code-layout", "labels": ["OpenZeppelin"]}, {"title": "Superfluous Casting", "body": "line 305 and  line 307 of  In addition, in lines 182 and 207, the value 18 is unnecessarily cast with the uint256 keyword.  Consider removing the superfluous casting in order to improve the readability of the codebase.  Update: Resolved in pull request #84 at commit 66707bd.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#superfluous-casting", "labels": ["OpenZeppelin"]}, {"title": "Global Namespace Pollution", "body": "In BoundValidator, ChainlinkOracle, PythOracle, and TwapOracle, there are structs defined outside of the contracts and therefore in the global namespace. This pattern is used when there are multiple contract implementations within one source file that need to reference the same structs. However, in these files in the codebase, there is only one implementation contract per file, so this methodology is unnecessary.  Consider either placing these structs inside the contracts' definitions or within the corresponding interfaces to reduce global namespace pollution.  Update: Resolved in pull request #84 at commit 28f4924.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#global-namespace-pollution", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "To favor explicitness and readability, the following locations in the contracts may benefit from better naming:  The interface file names as well as the interfaces themselves could take the format of I{...} as opposed to {...}Interface. For example, VBep20Interface.sol could be named IVBep20.sol.  In ResilientOracle:  The struct field enableFlagsForOracles could be renamed to isEnabled. The function enableOracle could be changed to updateOracleEnablement to reflect both the enablement and disablement of the oracle. The function updatePrice could be changed to updatePivotPrice to provide clarity as to which oracle is being updated. The state variable tokenConfigs could be changed to _tokenConfigs since it is a private variable.  In BinanceOracle:  The variable decimalDelta could be renamed to decimals to avoid confusion with other parts of the codebase, as decimalDelta typically refers to the value 18 - decimals. The function compare could be renamed to _compare since it is an internal function.  In BoundValidator:  The struct ValidateConfig could be renamed to ValidatorConfig or BoundValidatorConfig for consistency.  In TwapOracle:  The struct field isBnbBased could be renamed to isWbnbBased. The function pokeWindowValues could be renamed to _pokeWindowValues since it is an internal function.  Consider renaming as suggested above to improve the consistency and readability of the codebase.  Update: Acknowledged, not resolved. The Venus team stated:  We prefer to reduce the number of changes.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Ungraceful Handling of Function Call", "body": "_getUnderlyingAsset in  getUnderlyingPrice in  _getUnderlyingAsset in  setUnderlyingPrice and  _getUnderlyingPriceInternal in  getUnderlyingPrice in  _getUnderlyingAsset in  Consider handling these cases gracefully using try-catch and returning descriptive error messages.  Update: Acknowledged, not resolved. The Venus team stated:  We prefer to reduce the number of changes.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#ungraceful-handling-of-function-call", "labels": ["OpenZeppelin"]}, {"title": "Extraneous virtual and Visibility Keywords", "body": "Throughout the codebase, there are extraneous virtual and visibility keywords. From what is understood, there are no plans to inherit from existing contracts. Thus, it is best practice to limit the scope to what is designed, thereby removing extraneous virtual keywords and using more restrictive visibility keywords.  Places with unnecessary virtual keywords:  In BoundValidator, in the functions setValidateConfigs, setValidateConfig, and validatePriceWithAnchorPrice  In TwapOracle, in the function _updateTwapInternal  Places with unnecessary internal keywords (replace with private):  In ResilientOracle, in the functions _getMainOraclePrice, _getFallbackOraclePrice and _getUnderlyingAsset  In BinanceOracle, in the function compare  In BoundValidator, in the functions _isWithinAnchor and _getUnderlyingAsset  In ChainlinkOracle, in the functions _getUnderlyingPriceInternal and _getChainlinkPrice  In TwapOracle, in the functions _updateTwapInternal, pokeWindowValues, and _getUnderlyingAsset  Places with unnecessary public keywords (replace with external):  In ResilientOracle, in the function initialize  In BinanceOracle, in the functions initialize and getUnderlyingPrice  In BoundValidator, in the functions initialize and validatePriceWithAnchorPrice  In ChainlinkOracle, in the functions initialize and getUnderlyingPrice  In PythOracle, in the functions initialize and getUnderlyingPrice  In TwapOracle, in the functions initialize and updateTwap  Consider removing extraneous virtual keywords and using more restrictive visibility keywords following the recommendations above.  Update: Resolved in pull request #84 at commit e11f135.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#extraneous-virtual-and-visibility-keywords", "labels": ["OpenZeppelin"]}, {"title": "Multiple Contract Declarations per File", "body": "In the file PythInterface, there is a contract PythStructs, an interface IPyth, and an abstract contract AbstractPyth. To improve understandability and readability for developers and reviewers, it is recommended to include one contract or interface per file.  The contract PythStructs contains no functions, and only two structs. Consider moving these structs into PythOracle. Consider removing AbstractPyth completely, since no contracts inherit it.  The file PancakeLibrary also contains more than one library and interface declaration in the same file. Consider separating the interface and libraries into their own files to improve the readability of the codebase.  Update: Acknowledged, not resolved. The Venus team stated:  We prefer to reduce the number of changes.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#multiple-contract-declarations-per-file", "labels": ["OpenZeppelin"]}, {"title": "Code Redundancy", "body": "We recommend the following high-level refactors to improve the readability, composability and overall quality of the codebase:  In the ResilientOracle contract, the _getFallbackOraclePrice and _getMainOraclePrice functions have very similar code. They can be consolidated into one function to prevent changes in two different places, which increases the space for error in future changes to the codebase.  The _getUnderlyingAsset function is very similar or the same in many contracts, such as ResilientOracle and BoundValidator. Consider moving this functionality to a separate library.  Similarly, the setTokenConfigs and setTokenConfig functions in the ResilientOracle, ChainlinkOracle, TwapOracle, and PythOracle are practically the same and can be moved to a library.  The setDirectPrice and setUnderlyingPrice functions in the ChainlinkOracle contract share almost all their functionality. The setDirectPrice function could be called from the setUnderlyingPrice function after looking up the asset address from the vToken address, or alternatively an internal _setPrice(asset) function that is called from both functions could be introduced.  Update: Acknowledged, not resolved. The Venus team stated:  We prefer to reduce the number of changes.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#code-redundancy", "labels": ["OpenZeppelin"]}, {"title": "Duplicated Event Parameter", "body": "PricePosted event defined has four fields. This event is only used in  line 80 and  line 95. Since in both cases the last two fields (  Update: Resolved in pull request #84 at commit 5d811fd.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#duplicated-event-parameter", "labels": ["OpenZeppelin"]}, {"title": "Incomplete Event Emissions", "body": "The following suggestions are provided to improve the ability of off-chain services to search and filter for specific events:  The PythOracleSet event in the PythOracle contract should emit both the old and new oracle addresses. In the initializer function, it should emit (0, underlyintPythOracle_) and in the setUnderlyingPythOracle function it should emit (old, new), similar to the PricePosted event of the ChainlinkOracle contract, which emits both the old and new oracle price.  The BatchPriceFeedUpdate event in PythInterface does not have any parameters indexed. The chainId field could be indexed.  Update: Partially resolved in pull request #84 at commit cf6a66c. Regarding the first bullet point, the Venus team updated the PythOracleSet event to emit both the old and new oracle addresses. Furthermore, the initializer and setUnderlyingPythOracle functions, which emit this event, have been updated correspondingly. Regarding the second bullet point, the Venus team stated:  Ignoring the Pyth Interface because it was copied from the original project and linting would make the diff more complicated when updating.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#incomplete-event-emissions", "labels": ["OpenZeppelin"]}, {"title": "Lack of Input Validation", "body": "We recommend implementing the following input validations:  In the setOracle function of the ResilientOracle contract, it is advisable to check that for non-MAIN oracles (i.e., PIVOT and FALLBACK), the specified address is different from the MAIN oracle address.  In the setTokenConfig function of the ResilientOracle contract, there are currently no checks in place to ensure that a new configuration does not override an existing one. To address this, it is recommended to verify that the existing token asset address in the tokenConfigs is a zero address. By implementing this validation, updating the oracle for a specific token would only be possible through the setOracle and enableOracle functions, reducing the likelihood of errors.  While this issue does not pose a security risk, the absence of validation on user-controlled parameters may lead to erroneous transactions, particularly if some clients default to sending null parameters when none are specified.  Update: Acknowledged, not resolved. The Venus team stated:  These functions will be executed via Governance, with a timelock of 3 days, and the vote of the community, so there should not be errors in the inputs.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Magic Constant", "body": "The usage of the constant 100e16 on line 123 of BoundValidator.sol lacks sufficient explanation regarding its origin and purpose.  Developers should define a constant variable for every magic value used (including booleans), giving it a clear and self-explanatory name. Additionally, for complex values, inline comments explaining how they were calculated or why they were chosen are highly recommended.  Consider following the Solidity Style Guide to define the constant in UPPER_CASE_WITH_UNDERSCORES format with the corresponding specific public getter to read it.  Update: Partially resolved in pull request #84 at commit c420a18. The Venus team stated:  Mitigated. We added a comment to explain why the multiplication by the constant 1e18 is needed.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#magic-constant", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Repeated Fields in Structs", "body": "ResilientOracle,  TwapOracle,  PythOracle, and  ChainlinkOracle define a  A similar pattern can be observed in the ValidateConfig struct within the BoundValidator contract.  To optimize storage and avoid redundant data, it is recommended to remove the asset field from the structs. Instead, consider utilizing an existing field within the struct or introducing a boolean field to check the configuration's validity.  Update: Acknowledged, not resolved. The Venus team stated:  We prefer to reduce the number of changes.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#unnecessary-repeated-fields-in-structs", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Variable Initialization in initialize", "body": "The boundValidator variable in the ResilientOracle contract is currently set in the initialize function. However, since this variable remains unchanged after initialization, it can be optimized by declaring it as an immutable variable in the constructor.  By making boundValidator immutable, initialization inconsistencies can be avoided, and gas costs can be reduced when accessing it. This is especially beneficial when calling the getUnderlyingPrice function, where accessing boundValidator may occur up to three times.  To improve efficiency and maintain consistency, consider declaring boundValidator as an immutable variable in the constructor of the ResilientOracle contract.  Update: Resolved in pull request #84 at commit 4f56661.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#unnecessary-variable-initialization-in-initialize", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Ordering of Votes", "body": "GovernorCountingFractional.sol, the  ProposalVote struct is defined in the following order:  OpenZeppelin's contracts library as well as in  Compound's Bravo.  _countVote function requires a different order:  In the interest of improving clarity and being less error-prone, consider changing the order of the voteData to require votes in the originally-defined order (againstVotes, forVotes, abstainVotes).  Update: Resolved in pull request #40 at commit 8bea587.", "html_url": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit#inconsistent-ordering-of-votes", "labels": ["OpenZeppelin"]}, {"title": "Change Quorum to Account for Abstain Votes", "body": "The COUNTING_MODE function in the GovernorCountingFractional contract sets the quorum to bravo, meaning that only the For votes are counted to reach the quorum.  Consider changing the quorum to for,abstain to be consistent with OpenZeppelin's GovernorCountingSimple contract.  Update: Resolved in pull request #41 at commit 450b444.", "html_url": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit#change-quorum-to-account-for-abstain-votes", "labels": ["OpenZeppelin"]}, {"title": "Incomplete Docstrings", "body": "Although docstrings are present above the _countVoteNominal and _countVoteFractional functions, they do not provide complete information about the purpose of these functions and the parameters passed to them.  Since the GovernorCountingFractional contract supports rolling votes, once an address has cast a portion of its votes using the _countVoteFractional function, the subsequent votes should be cast by calling the _countVoteFractional function again, even if the votes are in favor of only one option.  Consider adding proper docstrings to the functions, following the NatSpec format, stating the scenarios in which these functions should be called, and mentioning their limitations.  Update: Resolved in pull request #42 at commit c19467a.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit#incomplete-docstrings", "labels": ["OpenZeppelin"]}, {"title": "OpenZeppelin Imports in Incorrect Format", "body": "In GovernorCountingFractional.sol, the current format for importing OpenZeppelin files is import {SomeContract} from \"openzeppelin-contracts/...\". With the current import statement, developers who are using this contract (particularly those who are not using Foundry as their smart contract development toolchain) may run into compilation errors when trying to integrate. For ease of consumption, consider changing the imports' format to import {SomeContract} from \"@openzeppelin/contracts/...\" as described in the OpenZeppelin documentation.  Update: Resolved in pull request #45 at commit 540cf75.", "html_url": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit#openzeppelin-imports-in-incorrect-format", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "To enhance explicitness and readability, there are several areas in the contract that could benefit from more precise and descriptive naming:  The proposalvote variables on line 77 and line 86 are inconsistent with proposalVote, which has camel case and is prevalent both in OpenZeppelin's contracts as well as elsewhere in this contract. Consider renaming it to proposalVote for consistency.  The weight variables on line 107, line 130, and line 159 are not explicit about which weight they are referring to. Consider renaming them to totalWeight for clarity.  The safeWeight variable is not explicit about which safeWeight it is referring to. For more clarity, consider renaming it to safeTotalWeight.  Update: Resolved in pull request #43 at commit 17b820f.", "html_url": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Remove Unnecessary Comments", "body": "To improve readability, consider removing the following comments related to the Foundry forge format:  Lines 6 and 7 of the GovernorCountingFractional contract  Line 207 of the GovernorCountingFractional contract  Update: Resolved in pull request #44 at commit c3bf318.", "html_url": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit#remove-unnecessary-comments", "labels": ["OpenZeppelin"]}, {"title": "Data feeds may be outdated", "body": "Chainlink's documentation recommends validating that prices returned by their feeds are recent and fall within reasonable bounds. The  OracleRouterBase and the  OETHOracleRouter contracts do not validate these properties directly, although the vault  independently requires the price to be within 30% of the expected value. In addition, consider confirming the  updatedAt parameter is suitably recent to ensure users can mint and redeem OUSD and OETH tokens at a reasonable market price.  Update: Resolved in pull request #1491 at commit 9cc9626.  Low Severity", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#data-feeds-may-be-outdated", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "Throughout the codebase there are several parts that do not have docstrings. For instance:  Line 9 in OracleRouter.sol  Line 57 in OracleRouter.sol  Line 77 in OracleRouter.sol  Line 125 in OracleRouter.sol  Line 156 in OracleRouter.sol  Line 159 in OracleRouter.sol  Line 191 in VaultAdmin.sol  Line 750 in VaultCore.sol  In addition, the initialize function of the ConvexEthMetaStrategy contract is missing the @param comment for its _ptokens parameter.  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #1493 at commit 1e6e230.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary token allowance", "body": "The ConvexEthMetaStrategy contract grants an allowance for the Curve pool to spend all WETH tokens. This allowance can also be renewed by the governor. However, the pool accepts ETH directly and never interacts with the WETH token.  In the interest of limiting the attack surface, consider removing this unnecessary allowance.  Update: Resolved in pull request #1494 at commit 1be6d8.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#unnecessary-token-allowance", "labels": ["OpenZeppelin"]}, {"title": "Minting is still possible even if redemptions are not", "body": "When redeeming OUSD or OETH, the corresponding amount of each collateral token is calculated. The operation will fail if any of the tokens drift too far from the expected price. However, when minting new OUSD or OETH, only the deposited collateral needs to be within the acceptable range. This introduces the possibility that users can deposit funds but will be unable to withdraw them.  In the interest of predictability, consider preventing deposits unless all collateral tokens are redeemable. This would help ensure that deposits and withdrawals are enabled and disabled together during unexpected market conditions.  Update: Acknowledged, not resolved. The Origin team stated:  For code simplicity, OUSD/OETH prioritizes protecting the protcool over protecting interacting users. If a user mints with a non-depegged coin when another coin is depegged, this is a benefit for the protocol.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#minting-is-still-possible-even-if-redemptions-are-not", "labels": ["OpenZeppelin"]}, {"title": "Imbalanced token transfers", "body": "The ConvexEthMetaStrategy contract invests the exact deposit amount but withdraws at least the withdrawal amount. This discrepancy means there could be stray ETH remaining in the contract after each withdrawal. Although this ETH is accounted for in the contract balance, it won't be utilized until an administrator invokes the withdrawAll function.  Consider accounting for the contract balance when deciding how many LP tokens to redeem, so that any stray ETH is automatically reused.  Update: Acknowledged, not resolved. The Origin team stated:  Acknowledged. We prefer the contract simplicity and gas reduction of the current method, and are okay having extremely small amounts of dust on the contract that can be cleaned up later.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#imbalanced-token-transfers", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent asset variables", "body": "are set and then the new token variables are  redundantly set. If the contract is initialized with multiple asset pairs, or another asset/platform token pair is  added, the existing  removed, the  A similar observation applies to the ConvexEthMetaStrategy contract, which has variables for WETH and the LP token, even though they are also recorded as the asset and platform token. In this case, the redundant variable will not be overwritten if a new pair of tokens is added, but the other inconsistencies still apply.  In the interest of consistency and predictability, consider using the existing variables to track the asset and share tokens, instead of introducing new ones. The _abstractSetPToken function can be used to ensure there is at most one active asset-share token pair.  Update: Acknowledged, not resolved. The Origin team stated:  Acknowledged. In Generalized4626Strategy, we feel that the redundancy in the variables improves the code's comprehensibility.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#inconsistent-asset-variables", "labels": ["OpenZeppelin"]}, {"title": "Indefinite allowances", "body": "The Generalized4626Strategy and ConvexEthMetaStrategy contracts both approve token allowances for their respective platform contracts. They also include a mechanism for the governor to refresh those allowances. However, there is no mechanism to revoke the allowances if the platform becomes untrustworthy.  Consider allowing the governor to revoke all token allowances.  Update: Acknowledged, not resolved. The Origin team stated:  Funds that are moved to strategies by the vault are immediately deposited to the backing strategy. Because of this, having long-running approvals for the backing strategy is not a concern, since those backing strategies either already have the strategy's funds, or the strategy is empty except for dust.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#indefinite-allowances", "labels": ["OpenZeppelin"]}, {"title": "Possible rounding overcorrection", "body": "When withdrawing ETH, the ConvexEthMetaStrategy first calculates the number of LP tokens to burn. This calculation adds 1 to the conceptual calculation to account for possible rounding errors. However, this means that the calculated value could exceed the contract's LP token balance, and the contract would attempt to redeem more tokens than it has. Consider restricting the redeemed LP tokens to the contract's token balance.  Update: Acknowledged, not resolved. The Origin team stated:  Weve decided to rather retain the over-corrected version of the function and to not do an additional balance check call that would make the function more gas expensive.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#possible-rounding-overcorrection", "labels": ["OpenZeppelin"]}, {"title": "Potentially misleading platform token", "body": "Investment strategies maintain a token mapping that tracks the platform-specific investment token corresponding to each invested asset. Typically, a user can review the deposit and withdrawal events to identify when funds are swapped for the platform token and vice versa.  However, the ConvexEthMetaStrategy invests funds in a two-step process, where ETH is deposited in a Curve pool and then the curve LP tokens are deposited to Convex finance. A user tracking token balances would consider the gauge tokens as representing the investment, since the strategy does not hold any Curve LP tokens, but the events treat the Curve LP token as the platform token. Consider treating the gauge token as the platform token, or including another parameter in the events to distinguish the platform token from the strategy holdings.  Update: Acknowledged, not resolved. The Origin team stated:  There is no ERC-20 token created as a result of deploying the LP token to Gauge. Curve LP tokens are the only ERC-20 token that gets moved around as a consequence of deploying liquidity to Curve and deploying to Convex gauge. Convex Gauge just receives that token and reports its balance when asked. This is how Convex works by design and it is somewhat inconvenient that blockchain explorers like Etherscan are not able to detect automatically that a contract has liquidity deployed in Convex since no ERC-20 has been received as a result.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#potentially-misleading-platform-token", "labels": ["OpenZeppelin"]}, {"title": "Unsafe cast", "body": "The OracleRouterBase contract uses an unsafe cast to convert the signed price to a uint256 type. Consider ensuring the price is positive before performing the type conversion. If desired, this could be achieved with OpenZeppelin's SafeCast library.  Update: Resolved in pull request #1500 at commit 97a2116.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#unsafe-cast", "labels": ["OpenZeppelin"]}, {"title": "State variable visibility not explicitly declared", "body": "Throughout the codebase there are state variables that lack an explicitly declared visibility. For instance:  MIN_DRIFT in OracleRouter.sol  MAX_DRIFT in OracleRouter.sol  FIXED_PRICE in OracleRouter.sol  shareToken in Generalized4626Strategy.sol  assetToken in Generalized4626Strategy.sol  MAX_INT in VaultCore.sol  For clarity, consider always explicitly declaring the visibility of variables, even when the default visibility matches the intended visibility.  Update: Resolved in pull request #1501 at commit 73aaad.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#state-variable-visibility-not-explicitly-declared", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "In VaultCore.sol the imports Strings, IVault and IBasicToken are unused.  In convexEthMetaStrategy.sol the import Helpers is unused.  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #1504 at commit fd28ff.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Multiple contract declarations per file", "body": "Within OracleRouter.sol, there is more than one contract, library or interface declared.  Consider separating the contracts into their own files to make the codebase easier to understand for developers and reviewers.  Update: Acknowledged, not resolved. The Origin team stated:  We prefer one file for these, since the oracle-related contracts are small and deeply interrelated.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#multiple-contract-declarations-per-file", "labels": ["OpenZeppelin"]}, {"title": "TODO comments", "body": "The following TODO comment was found in the codebase. This comment should be tracked in the project's issue backlog.  The TODO comment on line 126 in VaultCore.sol  During development, having well-described TODO/Fixme comments will make the process of tracking and solving them easier. Without this information, these comments might age and important information for the security of the system might be forgotten by the time it is released to production.  Consider removing all instances of TODO/Fixme comments and instead tracking them in the issues backlog. Alternatively, consider linking each inline TODO/Fixme to the corresponding issues backlog entry.  Update: Acknowledged, not resolved. The Origin team stated:  The current code errs on the side of caution. We are still carefully investigating if we can safely make a gas optimization here.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#todo-comments", "labels": ["OpenZeppelin"]}, {"title": "Redundant use of the SafeMath library", "body": "All solidity compiler versions higher than 0.8.0 implement native overflow protection, which makes using SafeMath operations unnecessary for regular arithmetic. Consider removing redundant usage of the SafeMath library from the VaultCore contract to improve code readability and save gas.  Update: Resolved in pull request #1506 at commit 25dff8.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#redundant-use-of-the-safemath-library", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "The codebase contains some typographical errors:  The InitialiseConfig struct should be InitializeConfig to be consistent with the initialize function that it is referencing.  \"seperate\" should be \"separate\".  Update: Resolved in pull request #1507 at commit 8ed275f.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Incomplete generalization", "body": "The Vault code is intended to be generalized to support both OUSD and OETH use cases. However, there are still some values that are only relevant to one of the use cases. For instance:  The token and several variables have \"OUSD\" in their name. This is just one example, but several comments, variables and events throughout the VaultStorage, VaultAdmin and VaultCore contracts reference \"OUSD\" or the ConvexOUSDMetaStrategy.  Some of the comments (e.g., describing the value functions), reference \"ETH\".  The redeem functions are described as returning stablecoins.  Consider generalizing the names and comments to apply them to both use cases.  Update: Acknowledged, will resolve. The Origin team confirmed that they will resolve this issue in the future.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#incomplete-generalization", "labels": ["OpenZeppelin"]}, {"title": "require statements do not check for any conditions", "body": "Within VaultCore.sol there are multiple require statements that do not check for any conditions. For instance:  The require statement on line 657  The require statement on line 688  For clarity, it is recommended to use revert() in situations where require() does not perform any condition checks.  Update: Resolved in pull request #1517 at commit c478296.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#require-statements-do-not-check-for-any-conditions", "labels": ["OpenZeppelin"]}, {"title": "Incorrect decimals type", "body": "caches the token decimals for each supported asset. However, it unnecessarily casts to a  uint256 type from the  the ERC-20 standard. In the interest of consistency, consider retaining the  Update: Acknowledged, will resolve. The Origin team stated that they will resolve the issue in pull request #1516:  Fix needs seperate governance action.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#incorrect-decimals-type", "labels": ["OpenZeppelin"]}, {"title": "Redundant code", "body": "There are several examples of redundant code. For example:  The calculation that determines the amount of LP tokens to burn can be simplified to (_wethAmount + 1) * k. To see why there is no loss of precision, note that it only uses subtractions and multiplications, which always produce exact integer values if they do not overflow.  This line retrieves the OETH balance unnecessarily.  The ConvexEthMetaStrategy is initialized with an _assets array, but its only element (the WETH address) is already passed to the function.  This conversion redundantly casts a uint256 variable to a uint256 type.  Consider simplifying or removing the redundant code.  Update: Resolved in pull request #1514 at commit d689cf2 and at commit bd38222.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#redundant-code", "labels": ["OpenZeppelin"]}, {"title": "Vault coupled to expected collateral", "body": "The Vault contract contains a mechanism to match collateral tokens to their equivalent \"base\" token amount. A similar conversion is used to standardize the price. However, although it is written generically, the GETEXCHANGERATE case is coupled to the rETH token. In particular:  It assumes the existence of a getExchangeRate function, which is not part of a known standard. It would not support the cbETH token, for instance.  It hardcodes an additional 1e18 conversion factor, which assumes the getExchangeRate function returns the ETH value of 1e18 collateral token units.  To simplify the vault, consider moving the token-specific logic into the OracleRouter contract or another adapter contract.  Update: Acknowledged, not resolved. The Origin team stated:  We do plan on keeping conversions to base amounts in the vault for now. This reduces the number of external calls needed, and the number of tokens we need to support is low.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#vault-coupled-to-expected-collateral", "labels": ["OpenZeppelin"]}, {"title": "Custom Selectors could facilitate proxy selector clashing attack", "body": "ink! has a feature that allows developers to hardcode the selector for a given function. This capability enables function name-changing while maintaining the same selector and also facilitates the creation of language-agnostic contract standards.  However, allowing custom selectors in contracts can lead to proxy selector clashing. When a user calls a specific function on an implementation, a matching selector in the proxy can cause unintended execution of code within the proxy. This issue makes it easier for scam projects to create malicious backdoors that are difficult to detect. In contrast to ink!, Solidity requires finding function signatures with matching selectors before taking advantage of this vulnerability, which is not trivial. If such function signatures are found and added, they are likely to raise red flags because the name usually does not make sense to the codebase.  Custom selectors can also confuse third-party monitoring or indexing services that use function selectors to identify specific functions. These services may rely on standard selectors, which are part of standards or belong to community databases such as the 4byte directory. If contracts use custom selectors, these services may fail to recognize and monitor transactions, leading to errors.  Given the potential dangers outlined, it is worth rethinking this feature and looking for an alternative to handle language-agnostic contract standards. Alternatively, requiring the metadata of the implementation contract to build the proxy and preventing the code from being compiled if selector clashing occurs with the implementation may be a viable solution. If the benefits of using custom selectors are not greater than the potential risks, consider removing them.  Update: Acknowledged, will resolve. The progress can be tracked on issue 1643 of the ink repository.", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#custom-selectors-could-facilitate-proxy-selector-clashing-attack", "labels": ["OpenZeppelin"]}, {"title": "Potential contract storage layout overlap in upgradable contracts", "body": "By default, ink! tries to store all storage struct fields under a single storage cell. This behavior causes an issue for upgradable contracts because both the proxy and the implementation write their Packed fields to the same storage key (0x00000000) unless the developer explicitly sets manual keys for the variables inside the implementation contract. As a result, overwrites of the storage could happen.  If the first variable in the implementation is modified, it will change the first variable in the proxy storage layout or some of its bytes, depending on the variable size. The same happens the other way around.  Without sufficient information, developers may fail to properly modify the storage of the implementation contract, which can result in unexpected behavior and potential malfunctioning of the contract. Additionally, this may lead to an unpredictable storage layout, further complicating the matter. Therefore, it is important for developers to ensure they have all the necessary information and take the proper steps to modify storage in order to prevent such issues  Also, there are no validations between upgrades to check whether the storage layout changed. The documentation specified that developers should not change the order in which the contract state variables are declared, nor their type.  Even if the restriction is violated, the compilation process will still succeed, but it may cause confusion in values or failure in the correct reading of storage. These issues can result in severe errors in the application that is using the contract.  Some mitigations to these problems could be:  To avoid clashes, define a set of standard slots to store variables present on the proxy code. The EIP-1967 defined in Ethereum can serve as an inspiration.  Consider adding documentation and examples to illustrate that one of either the implementation or proxy variables needs to use the Lazy collection. The Lazy collection sets the storage keys used for each variable, ensuring that they do not overlap with other variables in the contract.  Implement the cargo contract upgrade command mentioned in the suggestions section. This will retain the storage layout of the implementation and checks that it was not corrupted between upgrades, and check that the variables defined in the proxy were defined using manual keys instead of automatic keys, or that the first position of each variable defined in the proxy does not collide with any of the variables defined in the implementation.  Update: Acknowledged, will resolve. The progress can be tracked on issues 1679 and 1680 of the ink repository.  Medium Severity", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#potential-contract-storage-layout-overlap-in-upgradable-contracts", "labels": ["OpenZeppelin"]}, {"title": "Nonce reset increases the risk of a successful replay attack", "body": "Replay attacks pose a significant security threat to blockchain technologies. To maintain the integrity of signatures in a blockchain network, it is essential to use a nonce, a value that tracks the number of transactions made by a given account.  On Substrate-based blockchains, if an accounts balance drops below the existential deposit, the nonce is reset. This action can compromise the replay protection mechanism and increase the risk of a successful attack. Furthermore, prolonged expiration or deadline periods can also increase the possibility of a replay attack.  Instead of relying solely on the deadline, consider adding an alternative protection mechanism, like enforcing robust domain separators when hashing messages or advising developers to store the signatures used for a given address in the respective contract. Another solution is to keep the nonce even if the accounts balance falls below the minimum required.  Update: Acknowledged, more documentation will be added to make users aware of this behavior. The progress can be followed in issue 178 of the ink-docs repository. The Parity team stated:  This behavior is normal in the Substrate world and the only thing we can do here is highlight it better to newcomers. We will add documentation about this behavior.  Unbounded arrays are not possible in ink! Smart Contracts  By default, ink! tries to store all vector elements under a single storage cell. As a result, querying one item returns all the elements within the vector, but the buffer has a limited capacity (around 16KB in the default configuration). As a consequence, any contract attempting to decode beyond this limit will throw an error, making it impossible to implement certain smart contracts such as ERC20votes extension and EnumerableSet. If the limit is not exceeded, the operations would consume a large amount of gas in the execution, causing interactions with these contracts to be less appealing due to their cost.  The impact of this flaw might be significant because it limits the capabilities for contract developers. Unbounded arrays are essential for many use cases, and the inability to implement them using ink! significantly reduces the range of possibilities for Dapp development.  Consider, if possible, creating another storage collection to store array elements in different slots.  Update: Acknowledged, will resolve. The progress can be tracked on issue 1682 of the ink repository.  Low Severity  Confusing examples  The upgradeable-contracts example shows two ways of implementing upgradeability:  The first one, implemented in the set-code-hash directory, shows how a smart contract written in ink! can be upgraded by updating the implementation logic through the ink::env::set_code_hash function.  The second one, forward-calls, shows how to perform upgrades by using proxies. Similarly to well-known implementations of the Proxy pattern in solidity, the idea in this approach is to forward calls from the Proxy contract to an implementation contract, using the context of the former but the logic of the latter.  The issue lies in the fact that, in the latter, the forward function does not use the implementation of delegatecall but performs a regular call operation instead. As a result, the context and storage used in this example will not be the one of the Proxy, but the implementation, breaking the upgradeability pattern.  It is suggested to improve the documentation of how delegatecall works in ink! by including examples of both upgradeable and non-upgradeable proxies. Additionally, consider updating the mentioned example using delegate instead of regular calls.  Update: Resolved in pull request #1697 and pull request #1704.  Lack of input validation in the decode command  The Cargo contract has a decode command to parse the encoded input or output data and extract the underlying values. The feature has two flags. One to indicate the type of data to decode and the other for data itself that has to be a hex value. However, the current implementation of the function is accepting more bytes than the target type expects, which could cause misinterpretation of the data.  Consider updating the implementation to correctly accept only the expected number of bytes for the target function. This measure will reduce the risk of confusion and unexpected results.  Update: Resolved in pull request #982 at commit 769c112.  Potential clash between proxy and implementation function selectors  ink! allows developers to set custom selectors for the functions defined on a contract as mentioned in Custom Selectors could facilitate proxy selector clashing attack. When this feature is not used, the compute function from the ink crate is used to calculate the function selector instead. This function calculates the selector by hashing the function name and taking its first 4 bytes (similar to how it is done in Solidity).  The issue lies in the fact that the function selector is calculated using only the functions name, ", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#nonce-reset-increases-the-risk-of-a-successful-replay-attack", "labels": ["OpenZeppelin"]}, {"title": "Unbounded arrays are not possible in ink! Smart Contracts", "body": "Unbounded arrays are not possible in ink! Smart Contracts", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#unbounded-arrays-are-not-possible-in-ink!-smart-contracts", "labels": ["OpenZeppelin"]}, {"title": "Confusing examples", "body": "The upgradeable-contracts example shows two ways of implementing upgradeability:  The first one, implemented in the set-code-hash directory, shows how a smart contract written in ink! can be upgraded by updating the implementation logic through the ink::env::set_code_hash function.  The second one, forward-calls, shows how to perform upgrades by using proxies. Similarly to well-known implementations of the Proxy pattern in solidity, the idea in this approach is to forward calls from the Proxy contract to an implementation contract, using the context of the former but the logic of the latter.  The issue lies in the fact that, in the latter, the forward function does not use the implementation of delegatecall but performs a regular call operation instead. As a result, the context and storage used in this example will not be the one of the Proxy, but the implementation, breaking the upgradeability pattern.  It is suggested to improve the documentation of how delegatecall works in ink! by including examples of both upgradeable and non-upgradeable proxies. Additionally, consider updating the mentioned example using delegate instead of regular calls.  Update: Resolved in pull request #1697 and pull request #1704.  Lack of input validation in the decode command  The Cargo contract has a decode command to parse the encoded input or output data and extract the underlying values. The feature has two flags. One to indicate the type of data to decode and the other for data itself that has to be a hex value. However, the current implementation of the function is accepting more bytes than the target type expects, which could cause misinterpretation of the data.  Consider updating the implementation to correctly accept only the expected number of bytes for the target function. This measure will reduce the risk of confusion and unexpected results.  Update: Resolved in pull request #982 at commit 769c112.  Potential clash between proxy and implementation function selectors  ink! allows developers to set custom selectors for the functions defined on a contract as mentioned in Custom Selectors could facilitate proxy selector clashing attack. When this feature is not used, the compute function from the ink crate is used to calculate the function selector instead. This function calculates the selector by hashing the function name and taking its first 4 bytes (similar to how it is done in Solidity).  The issue lies in the fact that the function selector is calculated using only the functions name, without taking into account any other value. This may cause a function selector collision since it is likely to use the same function name in both the proxy and implementation.  Here are some potential mitigations strategies for this issue:  Develop an upgrade command, as mentioned in the suggestions section, to check that there are no repeated function selectors between the proxy and the implementation to which the system is being upgraded.  Develop a new macro attribute named proxy, that could overwrite the implementation of the compute function so that it not only uses the name of the function, but also appends to it the name of the proxy contract, a hash of the name of the proxy contract, or any other item that will make the selector different, and properly document it. Additionally, the proxy macro will improve the readability of the contract itself, since developers and auditors will know the contract will behave like a proxy.  Update: Acknowledged, will resolve. The progress can be tracked on issue 981 of the cargo-contract repository.  Misleading behavior of ManualKey functionality  ink! smart contracts include the ManualKey feature, which allows developers to specify the value of the key for a Mapping or a Lazy collection. However, a potential issue with this feature is that the key can be set to zero in the code while appearing as a different value in the metadata, leading to confusion and possible errors.  To avoid this issue, it may be worth disallowing users from setting the key of a variable to 0 when using ManualKey. Since developers may rely on the value specified in the code, this change could prevent confusion and improve the reliability of the code.  Update: Resolved in pull request #1670 at commit 63c846d.  Non-determinism in ink! contract builds  The process of building ink! contracts using the cargo contract CLI is impacted by various factors that can alter the final product. These factors include the version of Rust, the enabled features, the cargo-contract version, the number of optimization passes, and the build mode. The build process is non-deterministic across different operating systems and architectures.  The non-determinism of the build process creates difficulties in contract verification, which makes it challenging to establish trust in the contract and its reliability, both of which are essential for users.  To address this issue, consider standardizing the build process and providing clear guidelines ", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#confusing-examples", "labels": ["OpenZeppelin"]}, {"title": "Lack of input validation in the decode command", "body": "Lack of input validation in the decode command", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#lack-of-input-validation-in-the-decode-command", "labels": ["OpenZeppelin"]}, {"title": "Potential clash between proxy and implementation function selectors", "body": "ink! allows developers to set custom selectors for the functions defined on a contract as mentioned in Custom Selectors could facilitate proxy selector clashing attack. When this feature is not used, the compute function from the ink crate is used to calculate the function selector instead. This function calculates the selector by hashing the function name and taking its first 4 bytes (similar to how it is done in Solidity).  The issue lies in the fact that the function selector is calculated using only the functions name, without taking into account any other value. This may cause a function selector collision since it is likely to use the same function name in both the proxy and implementation.  Here are some potential mitigations strategies for this issue:  Develop an upgrade command, as mentioned in the suggestions section, to check that there are no repeated function selectors between the proxy and the implementation to which the system is being upgraded.  Develop a new macro attribute named proxy, that could overwrite the implementation of the compute function so that it not only uses the name of the function, but also appends to it the name of the proxy contract, a hash of the name of the proxy contract, or any other item that will make the selector different, and properly document it. Additionally, the proxy macro will improve the readability of the contract itself, since developers and auditors will know the contract will behave like a proxy.  Update: Acknowledged, will resolve. The progress can be tracked on issue 981 of the cargo-contract repository.  Misleading behavior of ManualKey functionality  ink! smart contracts include the ManualKey feature, which allows developers to specify the value of the key for a Mapping or a Lazy collection. However, a potential issue with this feature is that the key can be set to zero in the code while appearing as a different value in the metadata, leading to confusion and possible errors.  To avoid this issue, it may be worth disallowing users from setting the key of a variable to 0 when using ManualKey. Since developers may rely on the value specified in the code, this change could prevent confusion and improve the reliability of the code.  Update: Resolved in pull request #1670 at commit 63c846d.  Non-determinism in ink! contract builds  The process of building ink! contracts using the cargo contract CLI is impacted by various factors that can alter the final product. These factors include the version of Rust, the enabled features, the cargo-contract version, the number of optimization passes, and the build mode. The build process is non-deterministic across different operating systems and architectures.  The non-determinism of the build process creates difficulties in contract verification, which makes it challenging to establish trust in the contract and its reliability, both of which are essential for users.  To address this issue, consider standardizing the build process and providing clear guidelines and notifications to developers at the earliest stages, rather than after the contracts deployment. This approach will ensure that contract verification is straightforward, and users can trust the contract.  Update: Acknowledged, will resolve. The progress can be seen on issue 99 of the ink-docs repository and issue 525 of the cargo-contract repository.  Notes & Additional Information  Incomplete Spanish translations  The Spanish version of the documentation has many pages written in English, causing confusion and making it challenging for Spanish speakers to understand the information.  Consider completing the Spanish translations and disabling them until they are production-ready.  Update: Acknowledged, not resolved yet.  README.md references on internal crates  The internal crates of the ink! repository have a reference to the repositorys main README.md instead of their own, leading to a lack of information about the module and broken image links.  This lack of information can hinder the usability of the internal crates, making it difficult for developers to understand the purpose and usage of each crate. Additionally, broken image links can create a negative impression for users.  Creating individual README.md files for each crate would go a long way in resolving this issue.  Update: Acknowledged, will resolve. The progress can be tracked on issue 1690 of the ink repository.  Conclusions  The security review report has highlighted potential vulnerabilities and provided suggestions for improving the ink! ecosystem. We are pleased to report that working with the Parity team throughout this process has been fantastic. They have been receptive and open to our recommendations, and the weekly meetings were highly productive.  We see great potential in ink! and its tool cargo-contract, which has demonstrated robust security measures and an unwavering commitment to ensuring the safety and security of its users.  Overall, we are confident that ink! and its associ", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#potential-clash-between-proxy-and-implementation-function-selectors", "labels": ["OpenZeppelin"]}, {"title": "Misleading behavior of ManualKey functionality", "body": "Misleading behavior of ManualKey functionality", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#misleading-behavior-of-manualkey-functionality", "labels": ["OpenZeppelin"]}, {"title": "Non-determinism in ink! contract builds", "body": "The process of building ink! contracts using the cargo contract CLI is impacted by various factors that can alter the final product. These factors include the version of Rust, the enabled features, the cargo-contract version, the number of optimization passes, and the build mode. The build process is non-deterministic across different operating systems and architectures.  The non-determinism of the build process creates difficulties in contract verification, which makes it challenging to establish trust in the contract and its reliability, both of which are essential for users.  To address this issue, consider standardizing the build process and providing clear guidelines and notifications to developers at the earliest stages, rather than after the contracts deployment. This approach will ensure that contract verification is straightforward, and users can trust the contract.  Update: Acknowledged, will resolve. The progress can be seen on issue 99 of the ink-docs repository and issue 525 of the cargo-contract repository.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#non-determinism-in-ink!-contract-builds", "labels": ["OpenZeppelin"]}, {"title": "Incomplete Spanish translations", "body": "The Spanish version of the documentation has many pages written in English, causing confusion and making it challenging for Spanish speakers to understand the information.  Consider completing the Spanish translations and disabling them until they are production-ready.  Update: Acknowledged, not resolved yet.  README.md references on internal crates  The internal crates of the ink! repository have a reference to the repositorys main README.md instead of their own, leading to a lack of information about the module and broken image links.  This lack of information can hinder the usability of the internal crates, making it difficult for developers to understand the purpose and usage of each crate. Additionally, broken image links can create a negative impression for users.  Creating individual README.md files for each crate would go a long way in resolving this issue.  Update: Acknowledged, will resolve. The progress can be tracked on issue 1690 of the ink repository.  Conclusions  The security review report has highlighted potential vulnerabilities and provided suggestions for improving the ink! ecosystem. We are pleased to report that working with the Parity team throughout this process has been fantastic. They have been receptive and open to our recommendations, and the weekly meetings were highly productive.  We see great potential in ink! and its tool cargo-contract, which has demonstrated robust security measures and an unwavering commitment to ensuring the safety and security of its users.  Overall, we are confident that ink! and its associated tools will see significant adoption in the future with continued collaboration and ongoing efforts to enhance security. We look forward to seeing the continued evolution and growth of ink!.  For more information about ink!, you can visit the ink! documentation or follow the ink! Twitter. The ink! documentation also has a general explainer on how smart contracts work in Polkadot.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#incomplete-spanish-translations", "labels": ["OpenZeppelin"]}, {"title": "README.md references on internal crates", "body": "README.md references on internal crates", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#readme.md-references-on-internal-crates", "labels": ["OpenZeppelin"]}, {"title": "Malicious Operator Can Dodge Refund", "body": "In the refundCurrentL2Transaction function, the user gets refunded for overpaying in ergs for their L2 transaction. The ETH amount to refund is dependent on the ergs amount and the ergs price. The ergs amount is the maximum value of the operator-provided value and the one calculated by the bootloader. The ergs amount multiplied by the ergs price determines the refund in ETH.  A malicious operator can provide a very large amount of ergs that should be refunded, which will therefore be the chosen refundInErgs value. However, when multiplied by the ergs price, ethToRefund can overflow and lead to a very low refund, effectively stealing funds from the user.  Consider calculating the refund based on the bootloader and operator values individually and then picking the higher amount to protect the fee model against a malicious operator.  Update: Resolved in pull request #208 at commit 57ba2b1.  Medium Severity", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#malicious-operator-can-dodge-refund", "labels": ["OpenZeppelin"]}, {"title": "Users Can Lose Funds in L1ERC20Bridge Implementation Contract", "body": "_mailbox address is written to the bytecode that is deployed. During this invocation of  Specifically, the deposit function of the implementation contract is callable. However, in the implementation contract itself, many variables are not initialized, such as the l2Bridge variable, so it holds the zero-address. Therefore, the deposit function would request an L2 transaction that attempts to finalize the withdrawal by calling the zero-address, thereby triggering the non-reverting fallback function of the EmptyContract. Since this L2 call does not fail, the deposited tokens are locked and irrecoverable, as a call to claimFailedDeposit cannot be proven.  Consider implementing a stricter mechanism that prohibits direct calls to the contract if all or some of its variables were not properly initialized. In addition, consider preventing the initialization of the implementation contract more directly, rather than relying on the implicit behavior of reentrancyGuardInitializer, which lacks visibility.  Update: Acknowledged, not resolved. The Matter Labs team stated:  While we appreciate your insights and suggestions, we do not believe the issue carries a significant security risk. As the contract is intended to be used through a proxy, direct calls to the implementation contract are not recommended. Users could also call any other scam contract.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#users-can-lose-funds-in-l1erc20bridge-implementation-contract", "labels": ["OpenZeppelin"]}, {"title": "Lack of __gap Variable", "body": "The L1ERC20Bridge and L2StandardERC20 contract are intended to be used as logic contracts with a proxy, but do not have a __gap variable. This would become problematic if a subsequent version was to inherit one of these contracts. If the derived version were to have storage variables itself and additional storage variables were subsequently added to the inherited contract, a storage collision would occur.  Consider appending a __gap variable as the last storage variable to these upgradeable contracts, such that the storage slots sum up to a fixed amount (e.g. 50). This will proof any future storage layout changes to the base contract. Note that the __gap variable space will need to be adjusted accordingly as subsequent versions include more storage variables, in order to maintain the fixed amount of slots (e.g. 50).  Update: Acknowledged, not resolved. The Matter Labs team stated:  While we appreciate your insights and suggestions, we do not believe the issue has a significant security risk. Specified contracts are not expected to be inherited, since they are complete logical contracts.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#lack-of-__gap-variable", "labels": ["OpenZeppelin"]}, {"title": "ceilDiv Function Can Overflow", "body": "The ceilDiv function of the bootloader is used throughout the fee model formulas. This function can overflow as the numerator and denominator are added together before they are divided. Although this was not identified as a threat in the current codebase, an issue could be introduced by using this function with unvalidated inputs.  Consider adapting the formula to be safe from overflows.  Update: Resolved in pull request #236 at commit 56b3231.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#ceildiv-function-can-overflow", "labels": ["OpenZeppelin"]}, {"title": "Overflows in Fee Computation", "body": "The bootloader changes in scope involve a few formulas as part of the fee model, and there were a few instances where calculations were performed on user or operator-provided inputs. Unchecked arithmetic (without overflow protection) using these values is generally dangerous and prone to exploits.  One example is the calculated ergs price. If the maxPriorityFeePerErg is sufficiently large and the maxFeePerErg value is increased to match, the maxFeeThatOperatorCouldTake calculation could overflow, resulting in a zero ergs price. The transaction will still be executed but the amount the user pays would be zero. A savvy operator could recognize this scenario and discard the operation, but it does make the system unnecessarily fragile.  We also identified the following cases where potential overflows with user-provided values appear to be unmitigated, although the consequences are limited:  The intrinsicOverhead calculation in the getErgsLimitForTx function  The return value of the getBlockOverheadErgs function  The numerators of the overheadForCircuits, overheadForLength, and overheadForPubdata calculations in the getTransactionUpfrontOverhead function  Lastly, the following functions appear to allow overflows, but they are protected by validations in other parts of the codebase:  In getBaseFee, a large l1GasPrice could cause pubdataBytePriceETH to overflow but the validateOperatorProvidedPrices checks prevent this.  In processL1Tx, toRefundRecipient would negative overflow if the value was too large, but the check on line 1306 prevents this.  In getErgsLimitForTx, ergsLimitForTx would negative overflow if the operatorOverheadForTransaction was too large, but the check on line 1253 prevents this.  Consider applying additional checks to these operations, explicitly documenting where the checks are or why they would not be necessary. Whenever a potential overflow is not mitigated in the same function, consider documenting where the relevant validation can be found. It is advised to check the rest of the bootloader for more potential overflows and underflows. Lastly, it is recommended to validate all changes with proper dynamic testing.  Update: Resolved in pull request #211 at commit 448932e.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#overflows-in-fee-computation", "labels": ["OpenZeppelin"]}, {"title": "Missing Factory Dependencies", "body": "When the L1ERC20Bridge is initialized, the bytecode of the L2 bridge and token proxy are both provided as factory dependencies. This ensures the code is known when the L2 Bridge is deployed, or a new token is created. However, the L2 bridge initialization also deploys the token implementation and proxy beacon. Since neither contract was listed as a factory dependency, they may not be marked as known. Unless they were previously mentioned in an unrelated transaction, the bridge initialization will fail.  Consider including the L2StandardERC20 and the UpgradeableBeacon contracts in the factory dependencies of the bridge initialization transaction.  Update: Acknowledged, will resolve. The Matter Labs team stated:  Acknowledged. The problem can only be encountered at the initialization stage, so we prefer not to change the deployment scripts at the moment. This has been included in the backlog as a refactoring task.  Low Severity", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#missing-factory-dependencies", "labels": ["OpenZeppelin"]}, {"title": "Missing Error Messages in require and revert Statements", "body": "Throughout the bridge and system contracts codebases there are require and revert statements that lack error messages:  The require statement on line 96 of L2StandardERC20.sol  The revert statement on line 116 of L2StandardERC20.sol  The revert statement on line 122 of L2StandardERC20.sol  The revert statement on line 128 of L2StandardERC20.sol  The require statement on line 25 of AccountCodeStorage.sol  The require statement on line 36 of AccountCodeStorage.sol  The require statement on line 50 of AccountCodeStorage.sol  The require statement on line 39 of ContractDeployer.sol  The require statement on line 34 of ImmutableSimulator.sol  Consider including specific, informative error messages in require and revert statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied. In addition, for statements that do contain a message, consider using longer strings instead of a few characters to describe the error.  Update: Resolved in pull request #212 at commit cb93637 and pull request #63 at commit 77e64b5. The Matter Labs team stated:  We did not add error messages to reverts from name/symbol/decimals functions because if the token does not implement that method it should behave exactly the same way as if the function was not declared.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#missing-error-messages-in-require-and-revert-statements", "labels": ["OpenZeppelin"]}, {"title": "L2ERC20Bridge Is Not Upgradeable", "body": "L2ERC20Bridge Is Not Upgradeable", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#l2erc20bridge-is-not-upgradeable", "labels": ["OpenZeppelin"]}, {"title": "Potential EIP-1052 Deviation", "body": "issue, it is possible that opcodes deviate from EVM behavior, which still needs to be explored for other opcodes. For more differences  including unsupported opcodes  visit the EVM compatibility section of the zkSync documentation.  Testing Coverage Recommendations  Due to the complex nature of the system and several subtle deviations from the EVM, we believe this audit would have benefitted from more complete testing coverage, particularly around the bridge messages and new fee mechanics.  While insufficient testing is not necessarily a vulnerability, it implies a high probability of additional hidden vulnerabilities and bugs. Given the complexity of this codebase and the numerous interrelated risk factors, this probability is further increased. Testing provides a full implicit specification along with the exact expected behaviors of the codebase, which is especially important when adding novel functionalities. A lack thereof increases the chances that correctness issues will be missed. It also results in more effort to establish basic correctness and reduces the effort spent exploring edge cases, thereby increasing the chances of missing complex issues.  Moreover, the lack of repeated automated testing of the full specification increases the chances of introducing breaking changes and new vulnerabilities. This applies to both previously audited code and future changes to current code. This is particularly true in this project due to the pace, extent, and complexity of ongoing and planned changes across all parts of the stack (L1, L2, bootloader and system contracts, compiler and zkEVM). Underspecified interfaces and assumptions increase the risk of subtle integration issues, which testing could reduce by enforcing an exhaustive specification.  To address these issues, we recommend implementing a comprehensive multi-level test suite before the next expected audits. Such a test suite should comprise contract-level tests with >90% coverage, per-layer deployment and integration tests that test the deployment scripts as well as the system as a whole, per-layer fork tests for planned upgrades, and cross-chain full integration tests of the entire system. Crucially, the test suite should be documented in a way so that a reviewer can set up and run all these test layers independently of the development team. Some existing examples of such setups can be suggested for use as reference in a follow-up conversation. Implementing such a test suite should be a very high priority to ensure the systems robustness and reduce the risk of vulnerabilities and bugs.  High Severity  Malicious Operator Can Dodge Refund  In the refundCurrentL2Transaction function, the user gets refunded for overpaying in ergs for their L2 transaction. The ETH amount to refund is dependent on the ergs amount and the ergs price. The ergs amount is the maximum value of the operator-provided value and the one calculated by the bootloader. The ergs amount multiplied by the ergs price determines the refund in ETH.  A malicious operator can provide a very large amount of ergs that should be refunded, which will therefore be the chosen refundInErgs value. However, when multiplied by the ergs price, ethToRefund can overflow and lead to a very low refund, effectively stealing funds from the user.  Consider calculating the refund based on the bootloader and operator values individually and then picking the higher amount to protect the fee model against a malicious operator.  Update: Resolved in pull request #208 at commit 57ba2b1.  Medium Severity  Users Can Lose Funds in L1ERC20Bridge Implementation Contract  _mailbox address is written to the bytecode that is deployed. During this invocation of  Specifically, the deposit function of the implementation contract is callable. However, in the implementation contract itself, many variables are not initialized, such as the l2Bridge variable, so it holds the zero-address. Therefore, the deposit function would request an L2 transaction that attempts to finalize the withdrawal by calling the zero-address, thereby triggering the non-reverting fallback function of the EmptyContract. Since this L2 call does not fail, the deposited tokens are locked and irrecoverable, as a call to claimFailedDeposit cannot be proven.  Consider implementing a stricter mechanism that prohibits direct calls to the contract if all or some of its variables were not properly initialized. In addition, consider preventing the initialization of the implementation contract more directly, rather than relying on the implicit behavior of reentrancyGuardInitializer, which lacks visibility.  Update: Acknowledged, not resolved. The Matter Labs team stated:  While we appreciate your insights and suggestions, we do not believe the issue carries a significant security risk. As the contract is intended to be used through a proxy, direct calls to the implementation contract are not recommended. Users could also call any other scam contract.  Lack of __gap ", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#potential-eip-1052-deviation", "labels": ["OpenZeppelin"]}, {"title": "Lack of Events", "body": "In ContractDeployer.sol, there is no event emitted when an AccountAbstractionVersion or an [AccountNonceOrdering] (https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/ContractDeployer.sol#L81) are updated, which makes it challenging to monitor whether an account has updated either of these values.  In addition, the DepositInitiated event should emit the L2 transaction hash, because it may be needed to claim a failed deposit.  Consider emitting and updating these events to facilitate monitoring.  Update: Resolved in pull request #214 at commit d398cce and pull request #63 at commit d0ce4d4.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#lack-of-events", "labels": ["OpenZeppelin"]}, {"title": "setValueUnderNonce Value Is Mutable", "body": "sets a specific _value associated with a particular  While a user cannot reset the _value to 0, they can change it to any other non-zero quantity. This can be misleading for external entities that may be relying on it for particular information about the transaction. More importantly, since no event is emitted, an external party may not know that it has been changed.  Consider requiring that the _value for a particular _key is settable only once. Alternatively, if it is intended to be mutable, consider emitting an event every time it is set.  Update: Resolved in pull request #215 at commit d6fd17d. The Matter Labs team stated:  It is mutable in case users want to store some valuable data under the respective nonce. For example, a user might want to store a mapping such as (uniqueNonce => someInternalConstant).", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#setvalueundernonce-value-is-mutable", "labels": ["OpenZeppelin"]}, {"title": "Implicit Zero Cost Assumption", "body": "The L1ERC20Bridge contract will deploy the Layer 2 token bridge by passing a request to the Mailbox. However, it will not send any ETH. This is acceptable while the stub fee calculation uses a zero fee, but when the calculation is updated, messages that do not pay fees will be rejected.  In the interest of predictability, consider allowing ETH to be sent with the L2 bridge deployment request.  Update: Resolved in pull request #65 at commit 15b3433.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#implicit-zero-cost-assumption", "labels": ["OpenZeppelin"]}, {"title": "Floating Pragma Solidity Version", "body": "bridge and the  system contracts codebases, the version of Solidity used is  Solidity 0.8.8 and above. In addition, there is the usage of  bug detected regarding fixed-length bytes literals. While this bug does not currently affect the codebase, using an updated version will remove the possibility of future errors.  Consider upgrading all contracts to Solidity version 0.8.13 at a minimum, but ideally to the latest version.  Update: Resolved in pull request #66 at commit e422c7f. Regarding the floating point Solidity version, the Matter Labs team stated:  System contracts are exposing the System API to smart contract developers, so the code they write will have to adhere to the same compiler versions limitations. Similarly to OpenZeppelin Smart Contracts libraries, our System Contracts enforce the minimum Solidity version to ensure that they can be properly built, but do not pin a specific version, so we do not prevent the developers from using newer features.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#floating-pragma-solidity-version", "labels": ["OpenZeppelin"]}, {"title": "Unnecessarily Delayed Error Handling", "body": "When depositing ERC-20 tokens, the L1ERC20Bridge contract queries the tokens metadata, and sends the results to the L2ERC20Bridge contract. Any errors are still encoded on L1 and discarded on the L2 bridge. This pattern seems unnecessarily complex, and couples the processing on both sides. Consider detecting errors on L1 and only sending the relevant values over the bridge.  Update: Acknowledged, will resolve. The Matter Labs team stated:  We will take this change into account when further refactoring is done.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#unnecessarily-delayed-error-handling", "labels": ["OpenZeppelin"]}, {"title": "Interface Mismatch", "body": "The isNonceUsed function is defined in the NonceHolder contract, but it is missing in the INonceHolder interface.  Consider aligning the interface with the contract to fully represent its features.  Update: Resolved in pull request #216 at commit c9f1e3c.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#interface-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Variable Visibility Not Explicitly Declared", "body": "Throughout the bridge and system contracts codebases, there are state variables, constants, and immutables that lack an explicitly declared visibility:  The immutable allowList in L1ERC20Bridge.sol  The immutable zkSyncMailbox in L1ERC20Bridge.sol  The constant DEPLOY_L2_BRIDGE_COUNTERPART_ERGS_LIMIT in L1ERC20Bridge.sol  The constant DEFAULT_ERGS_PRICE_PER_PUBDATA in L1ERC20Bridge.sol  The state variable l2TokenProxyBytecodeHash in L2ERC20Bridge.sol  The state variable availableGetters in L2StandardERC20.sol  The constant EMPTY_STRING_KECCAK in AccountCodeStorage.sol  The state variable __DEPRECATED_l2Bridge in L2EthToken.sol  The constant DEPLOY_NONCE_MULTIPLIER in NonceHolder.sol  The constant MAXIMAL_MIN_NONCE_INCREMENT in NonceHolder.sol  For clarity, consider always explicitly declaring the visibility of variables, even when the default visibility matches the intended visibility.  Update: Acknowledged, will resolve. The Matter Labs team stated:  We will take this change into account when further refactoring is done.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#variable-visibility-not-explicitly-declared", "labels": ["OpenZeppelin"]}, {"title": "Code Redundancy", "body": "There are two instances in the codebase where redundant computations are performed:  In the ContractDeployer contract, there is some redundancy in the logic of the create{2}{Account} functions. Consider highlighting their differences and reusing existing logic by having one function call the other.  In the getErgsLimitForTx function of the bootloader, the ergsLimitForTx value is computed a second time after being computed as part of the getVerifiedOperatorOverheadForTx function. This particularly hinders the visibility of the underflow check.  Consider applying the above changes to improve the codes clarity.  Update: Resolved in pull request #218 at commit 5828dc1.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#code-redundancy", "labels": ["OpenZeppelin"]}, {"title": "Inexplicit Fail", "body": "In the L2EthToken contract, if the user attempts to transfer more funds than owned, the function reverts with a Solidity underflow error. This can result in a confusing user experience. Consider explicitly checking this condition and giving the user a proper revert reason if the transfer fails.  Update: Resolved in pull request #217 at commit d4e019f.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#inexplicit-fail", "labels": ["OpenZeppelin"]}, {"title": "Indecisive License", "body": "Throughout the codebase there are several files that state an SPDX license identifier of MIT OR Apache-2.0.  Consider agreeing on one license per file to prevent confusion on how these files can be used.  Update: Resolved in pull request #226 at commit d7c89a5.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#indecisive-license", "labels": ["OpenZeppelin"]}, {"title": "Misplaced Event", "body": "The L2StandardERC20 contract has the BridgeInitialization event defined in the contract, while its other events BridgeMint and BridgeBurn are defined in the IL2StandardToken interface.  Consider defining events in the same place for better visibility.  Update: Resolved in pull request #67 at commit 1de79d9.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#misplaced-event", "labels": ["OpenZeppelin"]}, {"title": "Gas Optimizations", "body": "The following opportunities for gas optimizations were identified:  In the L2StandardERC20 contract, the bridgeInitialize function checks that the l1Address is not the zero address. This is to guarantee that the contract has not been initialized before. However, the contract already has the initializer modifier, so the require statement is redundant.  The l2TokenProxyBytecodeHash variable can be made immutable since it is only set once in the constructor and there is no functionality to change it. The purpose of this variable is solely to determine the address of the L2 Token.  In the _splitRawNonce function a division by a power of two is made. Instead, a right shift by the exponent would be cheaper.  Consider making the above changes to reduce gas consumption.  Update: Partially resolved in pull request #68 at commit b37a19a. The Matter Labs team stated:  We did not implement the second and third suggestions, since immutable is more expensive in L2 contracts (see ImmutableSimulator contract) and the arithmetic operations are well-optimized by our compiler (LLVM backend!).", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Inexplicit Disable of Initialization", "body": "The L2StandardERC20 contract is used as the token logic contract for the bridge. Hence, each token is a beacon proxy instance which refers to the logic of the L2StandardERC20 contract, which is initializable. The actual logic contract is initialized by having the initializer modifier on the constructor, to prevent an attacker from initializing it maliciously.  Instead of using the modifier, consider calling the _disableInitializers function of the Initializable contract explicitly in favor of readability and clarity.  Update: Resolved in pull request #69 at commit 5db383b.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#inexplicit-disable-of-initialization", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Usage of Named Return Variables", "body": "_depositFunds and  l2TokenAddress functions have a return statement instead. On the other hand, the  _getCreate2Salt function. In the  getDeploymentNonce function.  Consider applying one return style for better readability.  Update: Acknowledged, not resolved. The Matter Labs team stated:  It makes sense to follow one style standard, but in practice, we see that different return methods are convenient in different cases, so for now we will stay with what we have. However, we will rethink this when we begin refactoring the codebase.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#inconsistent-usage-of-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Declaration of Integers", "body": "In the bootloader contract, there is an inconsistency in the way memory offsets are declared, with some being expressed in decimals and most others being expressed in hexadecimals. This deviation from a consistent notation can be confusing and make it difficult to understand the purpose and usage of these sizes. For instance:  add(txPtr, 32) in line 470  lt(returnlen, 96) in line 759  sub(returnlen, 0x40) in line 785  returndatacopy(PAYMASTER_CONTEXT_BEGIN_BYTE(), 64, effectiveContextLen) in line 796  Consider using a consistent notation for expressing memory offsets throughout the codebase.  Update: Partially resolved in pull request #219 at commit c022f89. There are more instances similar to the examples mentioned above that can be changed with further refactoring.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#inconsistent-declaration-of-integers", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "To favor explicitness and readability, there are several locations in the contracts that may benefit from better naming:  In L1ERC20Bridge.sol:  The txHash name is inconsistent with _l2TxHash. Consider renaming it to l2TxHash for consistency. The l2TokenFactory is not the factory, but rather the beacon. In fact, the factory is L2ERC20Bridge. Consider renaming it to l2TokenBeacon. The l2ProxyTokenBytecodeHash name is inconsistent with l2TokenProxyBytecodeHash. Consider renaming it to l2TokenProxyBytecodeHash for consistency.  In L2ERC20Bridge.sol:  The l2TokenFactory is not the factory, but rather the beacon. In fact, the factory is L2ERC20Bridge. Consider renaming it to l2TokenBeacon.  In L2StandardERC20.sol:  The BridgeInitialization event  is inconsistent with the other events named BridgeMint and BridgeBurn. Consider renaming it to BridgeInitialize.  In AccountCodeStorage.sol:  The function Utils.isContractConsructing is spelled incorrectly. Consider renaming it to isContractConstructing.  Update: Resolved in pull request #220 at commit d5bf7da and pull request #70 at commit 0cb750b.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "Throughout the codebase imports on the following lines are unused and could be removed:  Import IAccountCodeStorage of ContractDeployer.sol  Import IKnownCodesStorage of ContractDeployer.sol  Import INonceHolder of ContractDeployer.sol  Import IL2StandardToken of L2EthToken.sol  Import IMailbox, L2Log, and L2Message of IL1Bridge.sol  Consider removing unused imports to avoid confusion that could reduce the overall clarity and readability of the codebase.  Update: Resolved in pull request #221 at commit 49dbcf5 and pull request #71 at commit 53beb18.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Theoretical Aggregate ETH Inconsistency", "body": "The forceDeployOnAddresses function attempts to send the specified amount of L2 ETH with each deployment, after collecting the aggregate amount. However, the value sent with each call is implicitly truncated to the least significant 128 bits (henceforth, lower half). This means the most significant 128 bits (upper half) of every value parameter is ignored, which has two implications:  Any deployment that attempts to send more than 2128 Wei will only send the lower half of the amount, leaving the rest in the ContractDeployer contract.  The FORCE_DEPLOYER address can manipulate the upper half of the aggregate amount by setting large values that will be truncated. It can also cause the result to overflow, since the summation occurs inside an unchecked block. If the actual aggregated amount exceeds 2128 Wei and the FORCE_DEPLOYER address manipulates the summation to clear the upper half, they will only need to pay for the lower half of the amount. The rest will come out of the ContractDeployer contracts own balance.  In practice, the total supply will be less than 2128 for the foreseeable future, so neither scenario should be possible. In addition, the FORCE_DEPLOYER is a trusted address that would not be expected to manipulate the deployment configurations. Nevertheless, all assumptions should be enforced wherever possible. In the interest of predictability and local reasoning, consider restricting the ForceDeployment.value parameter to 128 bits. Alternatively, consider requiring the msg.value to be less than 2128 Wei instead of truncating it, which would remove the possible inconsistency for all use cases.  Update: Resolved in pull request #222 at commit 9600e74. The Matter Labs team stated:  The msg.value is not implicitly truncated (if so we would have a larger issue). The compiler checks if the value is less than 2^128, and panics otherwise. The sumOfValues overflow was resolved.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#theoretical-aggregate-eth-inconsistency", "labels": ["OpenZeppelin"]}, {"title": "Checks-Effects-Interactions Recommendation", "body": "The deposit function of the L1ERC20Bridge contract interacts with an untrusted token before updating its own state. Although it is protected by the nonReentrant modifier and there are no reentrancy possibilities in the current codebase, as a matter of good practice, consider moving the token transfer to the end of the function to follow the checks-effects-interactions pattern.  Update: Acknowledge, not resolved. The Matter Labs team stated:  We agree that in general it is more appropriate to use patterns wherever possible. However, in our case, to follow the checks-effects-interactions we would need to remove the calculation of the amount of deposited money, as the balance differs before and after. On other hand, it is difficult for us to imagine a reentrancy attack on this contract and we are already defending against this possibility with a nonReentrant modifier. As a result, we decided not to implement the fix.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#checks-effects-interactions-recommendation", "labels": ["OpenZeppelin"]}, {"title": "Complex Nonce Packing", "body": "The NonceHolder contract uses a single storage slot to pack each accounts deployment nonce and minimum transaction nonce.  Instead of manually splitting and recombining them, consider defining a struct that holds them both. That struct can then be saved in the rawNonces mapping and the individual nonces can be accessed and updated more easily.  Update: Acknowledged, will resolve. The Matter Labs team stated:  We will take this change into account when further refactoring is done.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#complex-nonce-packing", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "Throughout the codebase we identified the following typographical errors:  that used \u2192 that is used in L1ERC20Bridge.sol  the transferring funds \u2192 the transferring of funds in L1ERC20Bridge.sol  which do not \u2192 which it does not in L2StandardERC20.sol  store \u2192 stores in L2ERC20Bridge.sol  initiate \u2192 initiated in L2ERC20Bridge.sol  Deploys \u2192 Deploy in L2ERC20Bridge.sol  eiher \u2192 either in NonceHolder.sol  value value \u2192 value in NonceHolder.sol  server \u2192 serve in NonceHolder.sol  rather rather \u2192 rather in NonceHolder.sol  msg.sneder \u2192 msg.sender in NonceHolder.sol  methodd \u2192 method in NonceHolder.sol  That is means \u2192 That means in bootloader.yul  we need to the ability to \u2192 we need the ability to in bootloader.yul  transfered \u2192 transferred in bootloader.yul  that \u2192 than in bootloader.yul  provides provides \u2192 provides in bootloader.yul  No colission is not possible and No colission is possible \u2192 No collision is possible in ContractDeployer.sol  Consider correcting these typographical errors.  Update: Resolved in pull request #223 at commit 7042d1f, pull request #228 at commit 5398a91, and pull request #72 at commit f0c0544.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unclean Code", "body": "The line that extracts the isSystemCall flag has two sets of redundant brackets that do not clarify the order of operations.  Consider grouping the bit AND operation before the logical != operation, or removing the brackets entirely.  Update: Resolved in pull request #224 at commit ad13199.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#unclean-code", "labels": ["OpenZeppelin"]}, {"title": "Missing and Misleading Documentation", "body": "The following parts of the codebase are lacking documentation:  The _l2TxErgsLimit parameter of the deposit function is undocumented.  The following codes are missing @param statements:  All parameters of the L2StandardERC20 contract. The resultPtr parameter of the processL1Tx function. The _aaVersion parameter of the createAccount and create2Account functions. The _sender parameter of the _performDeployOnAddress function.  The following functions of the bootloader are undocumented:  l2TxExecution l2TxValidation getErgsLimitForTx getOperatorRefundForTx getOperatorOverheadForTx getVerifiedOperatorOverheadForTx l1TxPreparation SCRATCH_SPACE_BEGIN_BYTE  The following documentation is misleading:  The comment on the _l1Token address says Always should be equal to zero, which does not make sense.  The comment on the _l2TokenFactory address says Pre-calculated address of L2 token beacon proxy. However, the address is actually that of the UpgradeableBeacon contract.  The comment on the L2EthToken contract is missing that the bootloader also interacts with it.  The comment on the _hash parameter should state that the account is constructing and is not constructed.  The comment on the KnownCodeStorage contract is wrong since the implementation of the bytecode hash matches this comment.  The comment on the mint function states to be only callable by the ETH bridge. This is obsolete and should refer to the bootloader now.  The comment on the withdraw function states that funds are claimable through finalizeWithdrawal, but the function is actually called finalizeEthWithdrawal.  The comment on the updateNonceOrdering function ignores the fact that the ordering can only be changed from sequential to arbitrary.  The comment on the createAccount function claims to accept a nonce as one of its parameters, however, salt is meant.  The comment on the MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT constant addresses the second extraAbi parameter, while it is actually the first.  The comment mentioning NEW_CODE_HASHES_START_PTR and MAX_NEW_CODE_HASHES does not match any code.  The comment within the getNewAddressCreate function refers to collision resistance with Ethereums CREATE2 but it should be Ethereums CREATE.  Consider adding more documentation to the codebase to enhance its clarity. In addition, consider rephrasing misleading comments to match the intention of the code.  Update: Resolved in pull request #225 at commit 3a28b44, pull request #218 at commit 5828dc1, and pull request #73 at commit 275d73e.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#missing-and-misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Deposit cap not updated on withdrawals", "body": "User deposits are capped by increasing the totalDepositedAmountPerUser counter. However, the counter is not decreased by withdrawals.  As the counter can only be increased, after sufficient usage, all withdrawing users will be locked out of depositing again. This can possibly happen right after the first deposit and withdrawal, if the initial amount is larger than half the cap.  Consider decreasing the per-user cap during withdrawals to allow users to return to the rollup.  Update: Acknowledged, not resolved. The Matter Labs team stated:  The deposit limitations are only enabled in Fair Onboarding Alpha, while only approved partners may deposit funds. This will be removed at Full Launch Alpha, so we treat this issue as an accepted risk.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#deposit-cap-not-updated-on-withdrawals", "labels": ["OpenZeppelin"]}, {"title": "ETH withdrawal within allowed limit could fail", "body": "The protocol enforces an ETH withdraw limit (currently 10% of the total balance) within each 1-day window as a safety mechanism. This is done through the _verifyWithdrawalLimit function in Mailbox.sol. However, this function has a logic flaw that could cause an ETH withdrawal within the limit to fail.  When withdrawal validations occur within the same 1-day window, the function checks the limit in line 215 of Mailbox, as follows:  However, address(this).balance has already changed due to the previous withdrawal within the same day, causing the allowance to be less than the allowed 10%. This could cause any planned withdrawal to fail due to previous withdrawals. Note that a similar issue could also exist in the ERC-20 bridge .  Consider recording address(this).balance when updating s.lastWithdrawalLimitReset, and using it as the base when calculating the daily withdraw limit.  Update: Resolved in pull request #60 at commit 6365a8b. The Matter Labs team decided to completely remove the withdrawal limitation.  Medium Severity", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#eth-withdrawal-within-allowed-limit-could-fail", "labels": ["OpenZeppelin"]}, {"title": "Refund recipient defaults to inaccessible address for contracts", "body": "In _requestL2Transaction, if address(0) is specified as the refund recipient, msg.sender is used by default. However, the msg.sender address will not be controllable by contracts on L2, so any refund, or the bridged ETH amount in case of a failed transaction, will be lost.  Consider disallowing unspecified refund recipients for any ETH transfers, or reverting in the case of an unspecified recipient if the sender is not an EOA.  Update: Resolved in pull request #32 at commit 201c99c.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#refund-recipient-defaults-to-inaccessible-address-for-contracts", "labels": ["OpenZeppelin"]}, {"title": "Formula and documentation mismatch", "body": "The formula for overheadForPublicData uses Tm which is defined as the maximal transaction ergs limit here.  This appears to correspond in code to L2_TX_MAX_GAS_LIMIT:  /// @dev The maximum number of L2 gas that a user can request for an L2 transaction  However, the calculation in code uses the MAX_PUBDATA_PER_BLOCK constant instead, which refers to:  /// @dev The maximum number of the pubdata an L2 operation should be allowed to use.  This corresponds to Pm in the documentation.  These appear to be different quantities, measured in different units, of different magnitudes (80000000 vs 110000). As a result, a denial of service may occur if the overhead is calculated incorrectly (underestimated), which will result in l2GasForTxBody being overestimated, and possibly reverting in _writePriorityOp despite having legitimate values passed as inputs.  Alternatively, as the overhead is underestimated, a larger-than-limit l2GasForTxBody may be submitted, which will cause failures on L2.  Consider adding test cases to the documentation with concrete example values, and implementing these test cases in the codebase test suite to ensure basic compatibility. Additionally, consider documenting in code both the correspondence of the constants to the documentations notation, and the derivation and logic of the formulas implemented in comments in the same file, so that access to external documentation would not prevent the reader from reviewing the code.  Update: Partially resolved in pull request #34 at commit 19c7b81. The Matter Labs team stated:  Acknowledged. For now, we have decided to temporarily remove the overhead. The issue will be fixed once we introduce the block overhead back to our users.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#formula-and-documentation-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Unchecked subtraction underflow", "body": "L2 gas validation performs an unchecked subtraction, and a neighboring comment states that the underflow prevention is enforced by the implementation of the preceding computation. However, the preceding computation takes a large variety of constants and variable parameters, which depending on their values can still cause an underflow.  For example, the calculation of the memory overhead can result in arbitrarily large values depending on the value passed in _encodingLength and the constant BOOTLOADER_TX_ENCODING_SPACE, since both values ranges are not validated.  Note that it is likely that there are additional ways by which the combination of different possible values of constants and inputs could cause the resulting overhead to be higher than the total gas limit.  This may result in an underflow of the unchecked subtraction. In turn, it will likely cause a revert due to subsequent l2GasForTxBody checks.  Consider not using the unchecked subtraction to prevent the underflow, and adding an explicit check to validate the overhead.  Update: Resolved in pull request #54 at commit 94bc1a6.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#unchecked-subtraction-underflow", "labels": ["OpenZeppelin"]}, {"title": "User could deposit more ETH than allowed", "body": "zkSync has implemented a limit on the amount of ETH that can be deposited to L2 per account. However, the code currently has a design flaw that allows users to bypass this limit by exploiting a gas refund scheme. Specifically, in the requestL2Transaction function, the deposited ETH amount is verified using the _l2Value parameter, while the valueToMint parameter is set to msg.value when composing a priority queue transaction.  This means that a user can mint ETH without triggering the limit by setting _l2Value = 0 and using the gas refund when requesting any L2 transactions. Furthermore, even if msg.value was set as the limit amount, the user could run into issues when trying to request L2 transactions from L1 after reaching their limit.  To mitigate this issue, a system design change is needed around L2 gas refunding or ETH bridging limits. However, the specifics of the solution will depend on the overall design and goals of the system. Careful consideration and testing will be needed to ensure that the solution effectively mitigates this issue while also preserving the intended functionality of the system.  Update: Resolved in pull request #32 at commit 201c99c.msg.value is now used to verify the deposited ETH amount, however as we pointed out above, this design choice could mean users might not be able to request L2 transactions after reaching their limit.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#user-could-deposit-more-eth-than-allowed", "labels": ["OpenZeppelin"]}, {"title": "Block overhead limits may be exceeded", "body": "In _getOverheadForTransaction some overhead values can go over their maximum values if the transaction data or the public data posted (e.g., state changes) are large:  _encodingLength can take more memory than allowed by the BOOTLOADER_TX_ENCODING_SPACE.  overheadForPublicData for the transaction can be larger than the MAX_PUBDATA_PER_BLOCK constant.  overheadForComputation can be larger than the L2_TX_MAX_GAS_LIMIT.  Exceeding these values may violate invariants that are important for accurate L2 gas metering.  Consider checking that the encoded transaction length is in the expected range to prevent going over the maximum expected values. Additionally, consider checking that at no point the resulting calculated overhead is larger than the maximum overhead.  Update: Partially resolved in pull request #34 at commit 19c7b81. The Matter Labs team stated:  Acknowledged. We temporarily removed the block overhead, but a fix will be applied when restoring it.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#block-overhead-limits-may-be-exceeded", "labels": ["OpenZeppelin"]}, {"title": "Lack of tests", "body": "There are very few tests for most functionalities.  For example, Mailbox.sol (particularly MailboxFacet) is a key contract for the L1 bridge, and has 360+ lines of code and a large dependency tree of aggregated thousands of lines of non-library solidity code (specific to this codebase). The code implements sensitive functionality with many important details and execution branches. However, there are only four basic tests in mailbox_test.ts:  One test for non-reverting execution of an expected valid input. This tests nothing about the successful execution results.  Three more tests that check reverts in L2ContractsHelper contract.  This means that the entirety of the MailboxFacet functionality is untested in this repository.  Furthermore, as some system-level integration tests exist in another repository, there too, most of the functionality of the Mailbox remains untested:  There are no invocations for the finalizeEthWithdrawal mutative method, or the views proveL2LogInclusion, proveL1ToL2TransactionStatus, and serializeL2Transaction.  There is a single file for L1 functionality that invokes the main requestL2Transaction method. This test file totals around 300 lines of testing code, for which the majority of tests only assert either a revert or a lack of revert.  This leads to several potential issues:  The correctness of the code can only be assessed based on partial, and changing documentation. This is because intended and unintended behavior is not captured in tests.  Introduction of new vulnerabilities for established code in future code changes, since known positive and negative behaviors are not checked automatically.  Higher likelihood of missed vulnerabilities in current and future development and review.  Consider adding contract-level testing to test all branches of execution. Additionally, consider implementing an ongoing measurement of testing coverage as a way to ensure at least 95% coverage.  Update: Partially resolved in pull request #36, pull request #42, pull request #43, pull request #45, pull request #46, pull request #48 and pull request #51. The Matter Labs team stated:  We are working on improving the test coverage over the entire codebase.  Low Severity", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#lack-of-tests", "labels": ["OpenZeppelin"]}, {"title": "Missing documentation", "body": "Docstrings and inline comments are missing in several parts of the codebase with sensitive functionality. For example:  The entirety of L2ContractHelper contract: the functionality is internal, but is complex and coupled with other interfaces (custom encoding of bytecode hashes, custom create2 address derivation, etc).  _getMinimalPriorityTransactionGasLimit: it is possible that this method overestimates / underestimates, or is implemented incorrectly. However, relevant documentation was insufficient to validate this.  Consider including thorough docstrings and inline explanations with references to relevant source files or documentation, allowing readers or maintainers to verify the implementations and their correct usage.  Update: Resolved in pull request #55 at commits 41946cc and 57f702d.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#missing-documentation", "labels": ["OpenZeppelin"]}, {"title": "Revert messages are not informative", "body": "This issue has been reported in the previous Layer 1 Diff Audit (L01  Missing error messages in require statements). Reverts are important logical components, and a lack of revert messages makes them confusing and increases the chance of missing vulnerabilities during a review.  The codebase as a whole has revert messages that consist of two letters and convey no information. Additionally, the two-letter combinations collide (for example po) for different contracts. Crucially, no resource is available to translate the codes into meaningful error messages. Although something is typically mentioned in comments next to the revert, a meaningful error message (or a custom error) is expected since comments can be outdated and cannot be tested.  Consider using informative error messages or custom errors throughout the codebase.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We agree that custom errors will be much more understandable and convenient. At this time, we have no capacity for such a large refactoring, but we have planned it for the next milestone.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#revert-messages-are-not-informative", "labels": ["OpenZeppelin"]}, {"title": "L2 transaction hash is not emitted", "body": "The L2 transaction hash is a needed input during the L1 to L2 transaction flow on chain (in claimFailedDeposit), and for keeping track of L2 inclusion success off chain. However, it is not emitted in events by the callers in _requestDeployTransaction() or during ERC-20 deposit(). As a consequence, off-chain infrastructure (indexers, UIs, analytics dashboards) will not be able to keep track of bridging activity as easily.  Consider emitting the resulting transaction hash in an event after submitting the request in the MailboxFacet.  Update: Resolved. We later found that this was not an issue because the hash was emitted in event NewPriorityRequest as stated by the Matter Labs team:  _requestDeploy is only used for the bridge initialization, so we do not think it may affect off-chain infrastructure (indexers, UIs, analytics dashboards). Moreover, the transaction hashes are emitted in the Mailbox itself.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#l2-transaction-hash-is-not-emitted", "labels": ["OpenZeppelin"]}, {"title": "Diamond proxy holding large bridged ETH balance", "body": "In the current design, ERC-20 bridging uses a separate contract to hold token balances, but MailboxFacet holds and operates the ETH balance. However, since it is implemented as part of the Diamond Proxy, this means that the contract balance is common to all current and future facets of the proxy. This poses several risks:  It exposes the bridged and locked funds to an additional risk of exploit by introducing vulnerabilities in the other facets.  The locked balance is possibly co-mingled with other ETH that may be in use by the other facets.  By adding functionality to handle outbound ETH transfers, it introduces a site for a call to a user-defined destination out of the main proxy that can potentially be leveraged for other future attacks.  Considering that the ETH balance of the bridge may become very large, it may be better to design a system that reduces these risks.  Consider handling ETH deposits and withdrawals by converting them to WETH and using the ERC-20 bridge. This will have the additional benefit of avoiding balance handling code duplication between the MailboxFacet and the ERC-20 bridge, and will also remove the need to make a dangerous ETH transfer call out of the contract.  Update: Acknowledged, not resolved. The Matter Labs team stated:  Holding deposited ETH in the diamond proxy was a difficult decision, but we could not equip an efficient approach and stable fee model in a different way (users send L1 to L2 transactions and receive ETH refunds). So all ETH should be held in one contract (either EthBridge or diamond proxy).", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#diamond-proxy-holding-large-bridged-eth-balance", "labels": ["OpenZeppelin"]}, {"title": "Cross-chain system contract invocation is allowed and undocumented", "body": "System contract addresses can be specified in requestL2Transaction. However, this can cause potential unexpected side effects when executing the transactions on L2 since system contracts are documented to not be intended for direct invocation by users.  For example, if the destination address is set to the system ContractDeployer, it appears that the bootloader will execute it in isSystem mode. This code path is used for the deployment of the ERC-20 bridge in L1ERC20Bridge.initialize.  It is possible that allowing this invocation path from L1 may introduce vulnerabilities and side effects, depending on each specific system contracts access control. This is because L1 and L2 invocation paths in the bootloader are treated differently and may encode different assumptions which may be violated in one path but not in the other. If calling most system contracts is not an expected usage pattern, allowing the users to make these cross-chain calls creates an unnecessary attack surface area.  Consider restricting the addresses allowed to be called from L1. This can be done by checking that the destination address doesnt fall into the system contracts address space. Additionally, consider documenting these usage patterns.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We agree that calling system contracts can be dangerous in general. However, due to the design of L1-to-L2 transactions, we do not see any potential problems with calling system contracts. The same call may be done via L2 by directly calling the system contracts.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#cross-chain-system-contract-invocation-is-allowed-and-undocumented", "labels": ["OpenZeppelin"]}, {"title": "Contract poorly named and structured", "body": "The L2ContractHelper file and contract present several issues that impact readability:  It is named in a way that does not describe its intent or usage. Consider renaming it more appropriately according to its functions (e.g., splitting it into CustomEncodings and L2Addresses).  sendMessageToL1 is unused along with its dependencies (L2_MESSENGER and IL2Messenger). Consider removing it altogether.  The file contains additional constants and interfaces that are not used within it, but are used in other importing files. For example, IContractDeployer or FORCE_DEPLOYER are not used in this file, among others. Consider removing the unused instances.  Update: Resolved in pull request #55 at commits dfb4e4b and e2b2cf0.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#contract-poorly-named-and-structured", "labels": ["OpenZeppelin"]}, {"title": "Local variable shadows state variable", "body": "In Allowlist.sol the _owner local variable shadows the _owner state variable from Ownable.  Consider renaming the local variable to avoid potential errors.  Update: Resolved in pull request #56 at commit 40cd9d0.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#local-variable-shadows-state-variable", "labels": ["OpenZeppelin"]}, {"title": "Facet contract names and filenames do not match", "body": "Facet contracts are suffixed with Facet (e.g., MailboxFacet) but the filenames lack the suffix (e.g., Mailbox.sol).  Consider renaming the files to match the contract names.  Update: Acknowledged, will resolve. The Matter Labs team stated that they will resolve the issue:  We are aware of this, and will address it when higher-priority tasks are solved.  require statement lacking revert message  The require statement in _requestL2Transaction lacks an error message.  Consider adding one to improve the readability and clarity of the codebase.  Update: Resolved in pull request #57 at commit 38b8426.  Naming issues hinder code understanding and readability  To improve the explicitness and readability of the contracts, consider using more descriptive and clear naming in the Allowlist. Some suggestions include:  On line 29, Withdrawal should be WithdrawalLimit.  On line 30, withdrawalLimitation should be enabled.  On line 37, Deposit should be DepositLimit.  On line 60, getTokenWithdrawalLimitData should be getTokenWithdrawalLimit.  On line 62, getTokenDepositLimitData should be getTokenDepositLimit.  On line 28, tokenWithdrawal should be withdrawalLimits.  On line 31, tokenDeposit should be depositLimits.  Update: Acknowledged, will resolve. The Matter Labs team stated that they will resolve the issue:  Good suggestion! We are going to remove the deposit limitation (next milestone), and are already reimplementing the withdrawal limitation in H-02, so we will not apply these changes now.  Refund can be used to split bridged ETH and force transfer  The bridged ETH amount is split between the _l2Value and the gas payment on L2, which is unknown at the time of the L1 submission. The refund mechanism therefore exists to refund the excess gas payment to a user-selected recipient. However, currently the L2 gas cost for an L1 transaction is set to 0 during transaction serialization. Since no gas payment is taken on L2, there is no current need for splitting the ETH amount. Allowing the splitting with no gas costs creates a problem by allowing to split ETH between two destinations.  The ETH refund in case of a successful transaction is always the difference between the msg.value and the user provided _l2Value. In this case, the bridging mechanism has these qualities:  ETH is bridged simultaneously to two addresses (the recipient, and the refund recipient), in quantities determined by the user.  ETH is forced upon the refund recipient even if it is a contract that has no payable fallback and is not able to transfer it later. This is because refunded ETH is transferred without a call (with only a forced balance update).  This makes the bridging interface confusing and error-prone for integrations.  Consider disallowing the splitting of bridged ETH while the L2 gas cost for L1 transactions is 0 by checking that _l2Value is always equal to msg.value.  Update: Acknowledged, not resolved. The Matter Labs team stated:  Acknowledged. L1-to-L2 transactions will become payable in the next milestone.  Unused method  _deriveL2GasPrice is an unused method and can be removed to improve readability and reduce deployment gas costs.  The method could not be audited without usage context.  Update: Acknowledged, not resolved. The Matter Labs team stated:  It is planned to enable paid L1-to-L2 transactions for the next milestone, so we will not remove the method, since we will need to restore it soon.  Grammar and spelling issues  In AddressAliasHelper .sol, consider improving the following comments:  Utility function that converts the address in the L1 that submitted a tx to the inbox to the msg.sender viewed in the L2 should be Utility function converts the address that submitted a tx to the inbox on L1 to the msg.sender viewed on L2.  Utility function that converts the msg.sender viewed in the L2 to the address in the L1 that submitted a tx to the inbox should be Utility function that converts the msg.sender viewed on L2 to the address that submitted a tx to the inbox on L1.  In line 134 of Allowlist.sol, withdrwal should be withdrawal.  Update: Resolved in pull request #59 at commit ce11429.  Inefficient code  Line 500 of mailbox.sol computes the block overhead as  It is not necessary to use Math.max here, as blockOverheadForTransaction is 0 and txSlotOverhead >=0. Consider changing it to blockOverheadForTransaction = txSlotOverhead instead.  Update: Acknowledged, will resolve. The Matter Labs team stated that they will resolve the issue:  Acknowledged. The block overhead is removed for now, but we will fix the issue soon.  Conclusions  During a two-week period, we conducted a differential audit that focused on the codebase changes related to the implementation of new functions such as ETH bridging and gas-related modifications. Our audit identified 2 high-severity issues, 5 medium-severity issues, as well as some low-severity issues and notes. Most of these issues are associated with the newly introduced functions and design decisions. ", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#facet-contract-names-and-filenames-do-not-match", "labels": ["OpenZeppelin"]}, {"title": "require statement lacking revert message", "body": "require statement lacking revert message", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#require-statement-lacking-revert-message", "labels": ["OpenZeppelin"]}, {"title": "Naming issues hinder code understanding and readability", "body": "To improve the explicitness and readability of the contracts, consider using more descriptive and clear naming in the Allowlist. Some suggestions include:  On line 29, Withdrawal should be WithdrawalLimit.  On line 30, withdrawalLimitation should be enabled.  On line 37, Deposit should be DepositLimit.  On line 60, getTokenWithdrawalLimitData should be getTokenWithdrawalLimit.  On line 62, getTokenDepositLimitData should be getTokenDepositLimit.  On line 28, tokenWithdrawal should be withdrawalLimits.  On line 31, tokenDeposit should be depositLimits.  Update: Acknowledged, will resolve. The Matter Labs team stated that they will resolve the issue:  Good suggestion! We are going to remove the deposit limitation (next milestone), and are already reimplementing the withdrawal limitation in H-02, so we will not apply these changes now.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#naming-issues-hinder-code-understanding-and-readability", "labels": ["OpenZeppelin"]}, {"title": "Refund can be used to split bridged ETH and force transfer", "body": "The bridged ETH amount is split between the _l2Value and the gas payment on L2, which is unknown at the time of the L1 submission. The refund mechanism therefore exists to refund the excess gas payment to a user-selected recipient. However, currently the L2 gas cost for an L1 transaction is set to 0 during transaction serialization. Since no gas payment is taken on L2, there is no current need for splitting the ETH amount. Allowing the splitting with no gas costs creates a problem by allowing to split ETH between two destinations.  The ETH refund in case of a successful transaction is always the difference between the msg.value and the user provided _l2Value. In this case, the bridging mechanism has these qualities:  ETH is bridged simultaneously to two addresses (the recipient, and the refund recipient), in quantities determined by the user.  ETH is forced upon the refund recipient even if it is a contract that has no payable fallback and is not able to transfer it later. This is because refunded ETH is transferred without a call (with only a forced balance update).  This makes the bridging interface confusing and error-prone for integrations.  Consider disallowing the splitting of bridged ETH while the L2 gas cost for L1 transactions is 0 by checking that _l2Value is always equal to msg.value.  Update: Acknowledged, not resolved. The Matter Labs team stated:  Acknowledged. L1-to-L2 transactions will become payable in the next milestone.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#refund-can-be-used-to-split-bridged-eth-and-force-transfer", "labels": ["OpenZeppelin"]}, {"title": "Unused method", "body": "_deriveL2GasPrice is an unused method and can be removed to improve readability and reduce deployment gas costs.  The method could not be audited without usage context.  Update: Acknowledged, not resolved. The Matter Labs team stated:  It is planned to enable paid L1-to-L2 transactions for the next milestone, so we will not remove the method, since we will need to restore it soon.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#unused-method", "labels": ["OpenZeppelin"]}, {"title": "Grammar and spelling issues", "body": "In AddressAliasHelper .sol, consider improving the following comments:  Utility function that converts the address in the L1 that submitted a tx to the inbox to the msg.sender viewed in the L2 should be Utility function converts the address that submitted a tx to the inbox on L1 to the msg.sender viewed on L2.  Utility function that converts the msg.sender viewed in the L2 to the address in the L1 that submitted a tx to the inbox should be Utility function that converts the msg.sender viewed on L2 to the address that submitted a tx to the inbox on L1.  In line 134 of Allowlist.sol, withdrwal should be withdrawal.  Update: Resolved in pull request #59 at commit ce11429.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#grammar-and-spelling-issues", "labels": ["OpenZeppelin"]}, {"title": "Inefficient code", "body": "Inefficient code", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#inefficient-code", "labels": ["OpenZeppelin"]}, {"title": "s", "body": "ecurity aement wa prepared by OpenZeppelin.  Table of Content  Table of Content  Summary  Scope  Sytem Overview Privileged Role and Trut Aumption Teting Coverage Recommendation  High Severity  Depoit cap not updated on withdrawal ETH withdrawal within allowed limit could fail  Medium Severity  Refund recipient default to inacceible addre for contract Formula and documentation mimatch Unchecked ubtraction underflow Uer could depoit more ETH than allowed Block overhead limit may be exceeded Lack of tet  Low Severity  Miing documentation Revert meage are not informative L2 tranaction hah i not emitted Diamond proxy holding large bridged ETH balance Cro-chain ytem contract invocation i allowed and undocumented  Note & Additional Information  Contract poorly named and tructured Local variable hadow tate variable Facet contract name and filename do not match require tatement lacking revert meage Naming iue hinder code undertanding and readability Refund can be ued to plit bridged ETH and force tranfer Unued method Grammar and pelling iue Inefficient code  Concluion  Appendix  Extra Monitoring Recommendation  Summary  Type  Rollup  Timeline  From 2023-02-06  To 2023-02-17  Language  Solidity  Total Iue  22 (10\u202freolved, 3\u202fpartially\u202freolved)  Critical Severity Iue  0 (0\u202freolved)  High Severity Iue  2 (1\u202freolved)  Medium Severity Iue  6 (3\u202freolved, 3\u202fpartially\u202freolved)  Low Severity Iue  5 (2\u202freolved)  Note & Additional Information  9 (4\u202freolved)  Scope  We audited change to the matter-lab/zkync-2-contract repoitory at the 3f345ce commit, and conducted full audit of AddreAliaHelper.ol and L2ContractHelper.ol.  In cope were the following contract:  Sytem Overview  zkSync Era i a permiionle general-purpoe ZK rollup that operate imilarly to L1 blockchain and idechain. It enable deployment and interaction with Turing-complete mart contract, which are executed on a pecialized virtual machine called the zkEVM. It important to note that the bytecode for the zkEVM i different from the L1 EVM, but there are Solidity and Vyper compiler available for developing L2 mart contract. A trength of zkSync Era i it protocol for paing meage between L1 and L2. Thi provide a tandard way for uer to interact with mart contract acro both layer.  Privileged Role and Trut Aumption  The governor currently poee a uperpower to upgrade contract intantaneouly and indefinitely freeze them, but thi power i only temporary. In the future, the upgrade proce will be ubject to time lock and the duration of freezing will be limited, thu preventing the governor from exploiting their power.  Teting Coverage Recommendation  Several concern regarding the teting of the current ytem were identified during the audit. While there i a eparate finding highlighting thee concern for the pecific contract within the cope of thi audit, it i important to note the overall ytematic rik here.  Inufficient teting, while not a pecific vulnerability, implie the high probability of additional unfound vulnerabilitie and bug. It alo exacerbate multiple interrelated rik factor in a complex code bae with novel functionality. Thi include a lack of full implicit pecification of the functionality and exact expected behavior that tet normally provide, which increae the chance that correctne iue will be mied. It alo require more effort to etablih baic correctne and reduce the effort pent exploring edge cae, thereby increaing the chance of miing complex iue.  Moreover, the lack of repeated automated teting of the full pecification increae the chance of introducing breaking change and new vulnerabilitie. Thi applie to both previouly audited code and future change to currently audited code. Thi i particularly true in thi project due to the pace, extent, and complexity of ongoing and planned change acro all part of the tack (L1, L2, bootloader and ytem contract, compiler and VM). Underpecified interface and aumption increae the rik of ubtle integration iue, which teting could reduce by enforcing an exhautive pecification.  To addre thee iue, we recommend implementing a comprehenive multi-level tet uite before the next expected audit. Such a tet uite hould comprie contract-level tet with 95%-100% coverage, per layer deployment and integration tet that tet the deployment cript a well a the ytem a a whole, per layer fork tet for planned upgrade, and cro-chain full integration tet of the entire ytem. Crucially, the tet uite hould be documented in a way that a reviewer can et up and run all thee tet layer independently of the development team. Some exiting example of uch etup can be uggeted for ue a reference in a follow-up converation. Implementing uch a tet uite hould be a very high priority to enure the ytem robutne and reduce the rik of vulnerabilitie and bug.  High Severity  Depoit cap not updated on withdrawal  Uer depoit are capped by increaing the totalDepoitedAmountPerUer counter. However, the counter i not decreaed by withdrawal.  A the counter can only be increaed, after ufficient uage", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#s", "labels": ["OpenZeppelin"]}, {"title": "Appendix", "body": "Appendix", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#appendix", "labels": ["OpenZeppelin"]}, {"title": "Extra Monitoring Recommendations", "body": "Extra Monitoring Recommendations", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#extra-monitoring-recommendations", "labels": ["OpenZeppelin"]}, {"title": "Summary", "body": "Type  Rollups  Timeline  From 2023-02-06  To 2023-02-17  Languages  Solidity  Total Issues  22 (10\u202fresolved, 3\u202fpartially\u202fresolved)  Critical Severity Issues  0 (0\u202fresolved)  High Severity Issues  2 (1\u202fresolved)  Medium Severity Issues  6 (3\u202fresolved, 3\u202fpartially\u202fresolved)  Low Severity Issues  5 (2\u202fresolved)  Notes & Additional Information  9 (4\u202fresolved)  Scope  We audited changes to the matter-labs/zksync-2-contracts repository at the 3f345ce commit, and conducted full audits of AddressAliasHelper.sol and L2ContractHelper.sol.  In scope were the following contracts:  System Overview  zkSync Era is a permissionless general-purpose ZK rollup that operates similarly to L1 blockchains and sidechains. It enables deployment and interaction with Turing-complete smart contracts, which are executed on a specialized virtual machine called the zkEVM. Its important to note that the bytecode for the zkEVM is different from the L1 EVM, but there are Solidity and Vyper compilers available for developing L2 smart contracts. A strength of zkSync Era is its protocol for passing messages between L1 and L2. This provides a standard way for users to interact with smart contracts across both layers.  Privileged Roles and Trust Assumptions  The governor currently possesses a superpower to upgrade contracts instantaneously and indefinitely freeze them, but this power is only temporary. In the future, the upgrade process will be subject to time locks and the duration of freezing will be limited, thus preventing the governor from exploiting their power.  Testing Coverage Recommendations  Several concerns regarding the testing of the current system were identified during the audit. While there is a separate finding highlighting these concerns for the specific contracts within the scope of this audit, it is important to note the overall systematic risks here.  Insufficient testing, while not a specific vulnerability, implies the high probability of additional unfound vulnerabilities and bugs. It also exacerbates multiple interrelated risk factors in a complex code base with novel functionality. This includes a lack of full implicit specification of the functionality and exact expected behaviors that tests normally provide, which increases the chances that correctness issues will be missed. It also requires more effort to establish basic correctness and reduces the effort spent exploring edge cases, thereby increasing the chances of missing complex issues.  Moreover, the lack of repeated automated testing of the full specification increases the chances of introducing breaking changes and new vulnerabilities. This applies to both previously audited code and future changes to currently audited code. This is particularly true in this project due to the pace, extent, and complexity of ongoing and planned changes across all parts of the stack (L1, L2, bootloader and system contracts, compiler and VM). Underspecified interfaces and assumptions increase the risk of subtle integration issues, which testing could reduce by enforcing an exhaustive specification.  To address these issues, we recommend implementing a comprehensive multi-level test suite before the next expected audits. Such a test suite should comprise contract-level tests with 95%-100% coverage, per layer deployment and integration tests that test the deployment scripts as well as the system as a whole, per layer fork tests for planned upgrades, and cross-chain full integration tests of the entire system. Crucially, the test suite should be documented in a way that a reviewer can set up and run all these test layers independently of the development team. Some existing examples of such setups can be suggested for use as reference in a follow-up conversation. Implementing such a test suite should be a very high priority to ensure the systems robustness and reduce the risk of vulnerabilities and bugs.  High Severity  Deposit cap not updated on withdrawals  User deposits are capped by increasing the totalDepositedAmountPerUser counter. However, the counter is not decreased by withdrawals.  As the counter can only be increased, after sufficient usage, all withdrawing users will be locked out of depositing again. This can possibly happen right after the first deposit and withdrawal, if the initial amount is larger than half the cap.  Consider decreasing the per-user cap during withdrawals to allow users to return to the rollup.  Update: Acknowledged, not resolved. The Matter Labs team stated:  The deposit limitations are only enabled in Fair Onboarding Alpha, while only approved partners may deposit funds. This will be removed at Full Launch Alpha, so we treat this issue as an accepted risk.  ETH withdrawal within allowed limit could fail  The protocol enforces an ETH withdraw limit (currently 10% of the total balance) within each 1-day window as a safety mechanism. This is done through the _verifyWithdrawalLimit function in Mailbox.sol. However, this function has a logic flaw that c", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#summary", "labels": ["OpenZeppelin"]}, {"title": "Type", "body": "Type", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#type", "labels": ["OpenZeppelin"]}, {"title": "Rollups", "body": "Rollups", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#rollups", "labels": ["OpenZeppelin"]}, {"title": "Timeline", "body": "Timeline", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#timeline", "labels": ["OpenZeppelin"]}, {"title": "From 2023-02-06", "body": "From 2023-02-06", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#from-2023-02-06", "labels": ["OpenZeppelin"]}, {"title": "To 2023-02-17", "body": "To 2023-02-17", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#to-2023-02-17", "labels": ["OpenZeppelin"]}, {"title": "Languages", "body": "Languages", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#languages", "labels": ["OpenZeppelin"]}, {"title": "Solidity", "body": "Total Issues  22 (10\u202fresolved, 3\u202fpartially\u202fresolved)  Critical Severity Issues  0 (0\u202fresolved)  High Severity Issues  2 (1\u202fresolved)  Medium Severity Issues  6 (3\u202fresolved, 3\u202fpartially\u202fresolved)  Low Severity Issues  5 (2\u202fresolved)  Notes & Additional Information  9 (4\u202fresolved)  Scope  We audited changes to the matter-labs/zksync-2-contracts repository at the 3f345ce commit, and conducted full audits of AddressAliasHelper.sol and L2ContractHelper.sol.  In scope were the following contracts:  System Overview  zkSync Era is a permissionless general-purpose ZK rollup that operates similarly to L1 blockchains and sidechains. It enables deployment and interaction with Turing-complete smart contracts, which are executed on a specialized virtual machine called the zkEVM. Its important to note that the bytecode for the zkEVM is different from the L1 EVM, but there are  and Vyper compilers available for developing L2 smart contracts. A strength of zkSync Era is its protocol for passing messages between L1 and L2. This provides a standard way for users to interact with smart contracts across both layers.  Privileged Roles and Trust Assumptions  The governor currently possesses a superpower to upgrade contracts instantaneously and indefinitely freeze them, but this power is only temporary. In the future, the upgrade process will be subject to time locks and the duration of freezing will be limited, thus preventing the governor from exploiting their power.  Testing Coverage Recommendations  Several concerns regarding the testing of the current system were identified during the audit. While there is a separate finding highlighting these concerns for the specific contracts within the scope of this audit, it is important to note the overall systematic risks here.  Insufficient testing, while not a specific vulnerability, implies the high probability of additional unfound vulnerabilities and bugs. It also exacerbates multiple interrelated risk factors in a complex code base with novel functionality. This includes a lack of full implicit specification of the functionality and exact expected behaviors that tests normally provide, which increases the chances that correctness issues will be missed. It also requires more effort to establish basic correctness and reduces the effort spent exploring edge cases, thereby increasing the chances of missing complex issues.  Moreover, the lack of repeated automated testing of the full specification increases the chances of introducing breaking changes and new vulnerabilities. This applies to both previously audited code and future changes to currently audited code. This is particularly true in this project due to the pace, extent, and complexity of ongoing and planned changes across all parts of the stack (L1, L2, bootloader and system contracts, compiler and VM). Underspecified interfaces and assumptions increase the risk of subtle integration issues, which testing could reduce by enforcing an exhaustive specification.  To address these issues, we recommend implementing a comprehensive multi-level test suite before the next expected audits. Such a test suite should comprise contract-level tests with 95%-100% coverage, per layer deployment and integration tests that test the deployment scripts as well as the system as a whole, per layer fork tests for planned upgrades, and cross-chain full integration tests of the entire system. Crucially, the test suite should be documented in a way that a reviewer can set up and run all these test layers independently of the development team. Some existing examples of such setups can be suggested for use as reference in a follow-up conversation. Implementing such a test suite should be a very high priority to ensure the systems robustness and reduce the risk of vulnerabilities and bugs.  High Severity  Deposit cap not updated on withdrawals  User deposits are capped by increasing the totalDepositedAmountPerUser counter. However, the counter is not decreased by withdrawals.  As the counter can only be increased, after sufficient usage, all withdrawing users will be locked out of depositing again. This can possibly happen right after the first deposit and withdrawal, if the initial amount is larger than half the cap.  Consider decreasing the per-user cap during withdrawals to allow users to return to the rollup.  Update: Acknowledged, not resolved. The Matter Labs team stated:  The deposit limitations are only enabled in Fair Onboarding Alpha, while only approved partners may deposit funds. This will be removed at Full Launch Alpha, so we treat this issue as an accepted risk.  ETH withdrawal within allowed limit could fail  The protocol enforces an ETH withdraw limit (currently 10% of the total balance) within each 1-day window as a safety mechanism. This is done through the _verifyWithdrawalLimit function in Mailbox.sol. However, this function has a logic flaw that could cause an ETH withdrawal within the limit to fail.  When withdrawal validations oc", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#solidity", "labels": ["OpenZeppelin"]}, {"title": "Total Issues", "body": "Total Issues", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#total-issues", "labels": ["OpenZeppelin"]}, {"title": "22 (10\u202fresolved, 3\u202fpartially\u202fresolved)", "body": "22 (10\u202fresolved, 3\u202fpartially\u202fresolved)", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#22-(10\u202fresolved,-3\u202fpartially\u202fresolved)", "labels": ["OpenZeppelin"]}, {"title": "Invalid aggregate signature [samples]", "body": "The BLSSignatureAggregator exposes a mechanism to let the bundler validate individual signatures before constructing the bundle. Successful operations are grouped so the bundler can combine their signatures off-chain and the EntryPoint can validate them together on-chain. However, it is possible for an account to construct an operation that will pass the individual-signature check and still fail the combined-signature check.  during the individual validation is different from the one used  during the combined validation, the two validations will be inconsistent even though the signature is the same. This could occur if the  last 4 words of the initCode do not match the public key (because the  expected creation function). It could also occur if the  users validation function (which is not invoked during the individual signature validation) changes the public key that is returned by  If a bundler constructs a bundle with these operations, it will be unable to validate the combined signature and will attribute the fault to the aggregator, which will cause the aggregator to be throttled and user operations with the same aggregator will not be processed.  Consider synchronizing the two validation functions so they both use the same public key.  Update: Resolved in pull request #195 as well as commit 268f103 of pull request #216, which were merged at commits 1cc1c97 and 1f505c5 respectively.  Low Severity  Accounts cannot replace EntryPoint [samples]  The comments describing the initialize function of the SimpleAccount contract claim there should be a mechanism to replace the EntryPoint contract. This does not match the behavior of the function it describes, and in fact, there is no mechanism to replace the EntryPoint contract without upgrading the whole account.  Consider updating the comment to match the behavior, and introducing a mechanism to replace the EntryPoint contract if that functionality is desired.  Update: Resolved in pull request #192 and merged at commit 82685b2. A @dev comment was added to the docstring of the initialize function to clarify that the _entryPoint storage variable is not a parameter of the initializer because an upgrade is required to change the EntryPoint address.  Gnosis safe reverts on signature failure [samples]  documentation for the  correctly follows the specification, however in the  reverts if the signature validation fails. This means the  simulateValidation function will revert without providing a  Consider changing the logic so that validateUserOp returns SIG_VALIDATION_FAILED in all cases where an invalid signature is encountered.  Update: Resolved in pull request #181 and merged at commit 1dfb173.  Imprecise time range [core]  The EntryPoint contract decrements the operation expiry timestamp in order to convert 0 (which should be interpreted as no expiry) to the maximum uint64 value. However, every other possible expiry value is now off by one. In the interest of predictability, consider only modifying the 0 timestamp.  Update: Resolved in pull request #193 and merged at commit 973c0ac.  Incorrect or misleading documentation [core and samples]  Several docstrings and inline comments throughout the code base were found to be incorrect or misleading. In particular:  In BaseAccount.sol:  Line 72: The docstring defines sigTimeRange as signature and time-range for this operation, but it contains the signature validity, not the signature itself.  In BLSSignatureAggregator.sol:  Line 117: The docstring references a call to simulateUserOperation. The function name should be simulateValidation.  In EIP4337Manager.sol:  Line 21: The docstring states the contract inherits GnosisSafeStorage, but it actually inherits GnosisSafe.  In EntryPoint.sol:  Line 180: The comment does not include paymasterAndData as one of the dynamic byte arrays being excluded from MemoryUserOp. Line 393: The docstring states that _validatePaymasterPrepayment validates that the paymaster is staked, but the function does not perform this check.  In IPaymaster.sol:  Lines 25-26: The docstring states that the validUntil and validAfter timestamps are 4 bytes in length, but these are 8-byte (uint64) values.  In IStakeManager.sol:  Line 7, lines 43-44: Docstrings in this contract refer to staking only for paymasters, implying this is the only entity that should stake. Signature aggregators and factories are also required to stake following the same rules as paymasters. Line 45: The docstring makes a reference to the global unstakeDelaySec, which no longer exists. Line 47: The DepositInfo docstring explains that the variable sizes were chosen so that deposit and staked fit into a single uint256 word, but the 3rd parameter stake will also fit.  In SimpleAccount.sol:  Line 52: The comment makes a reference to the execFromEntryPoint function, which no longer exists. Line 57: The docstring for execute says called directly from owner, not by entryPoint, but the _requireFromEntryPointOrOwner function allows execute to", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#invalid-aggregate-signature-[samples]", "labels": ["OpenZeppelin"]}, {"title": "Accounts cannot replace EntryPoint [samples]", "body": "Accounts cannot replace EntryPoint [samples]", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#accounts-cannot-replace-entrypoint-[samples]", "labels": ["OpenZeppelin"]}, {"title": "Gnosis safe reverts on signature failure [samples]", "body": "documentation for the  correctly follows the specification, however in the  reverts if the signature validation fails. This means the  simulateValidation function will revert without providing a  Consider changing the logic so that validateUserOp returns SIG_VALIDATION_FAILED in all cases where an invalid signature is encountered.  Update: Resolved in pull request #181 and merged at commit 1dfb173.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#gnosis-safe-reverts-on-signature-failure-[samples]", "labels": ["OpenZeppelin"]}, {"title": "Imprecise time range [core]", "body": "The EntryPoint contract decrements the operation expiry timestamp in order to convert 0 (which should be interpreted as no expiry) to the maximum uint64 value. However, every other possible expiry value is now off by one. In the interest of predictability, consider only modifying the 0 timestamp.  Update: Resolved in pull request #193 and merged at commit 973c0ac.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#imprecise-time-range-[core]", "labels": ["OpenZeppelin"]}, {"title": "Incorrect or misleading documentation [core and samples]", "body": "Several docstrings and inline comments throughout the code base were found to be incorrect or misleading. In particular:  In BaseAccount.sol:  Line 72: The docstring defines sigTimeRange as signature and time-range for this operation, but it contains the signature validity, not the signature itself.  In BLSSignatureAggregator.sol:  Line 117: The docstring references a call to simulateUserOperation. The function name should be simulateValidation.  In EIP4337Manager.sol:  Line 21: The docstring states the contract inherits GnosisSafeStorage, but it actually inherits GnosisSafe.  In EntryPoint.sol:  Line 180: The comment does not include paymasterAndData as one of the dynamic byte arrays being excluded from MemoryUserOp. Line 393: The docstring states that _validatePaymasterPrepayment validates that the paymaster is staked, but the function does not perform this check.  In IPaymaster.sol:  Lines 25-26: The docstring states that the validUntil and validAfter timestamps are 4 bytes in length, but these are 8-byte (uint64) values.  In IStakeManager.sol:  Line 7, lines 43-44: Docstrings in this contract refer to staking only for paymasters, implying this is the only entity that should stake. Signature aggregators and factories are also required to stake following the same rules as paymasters. Line 45: The docstring makes a reference to the global unstakeDelaySec, which no longer exists. Line 47: The DepositInfo docstring explains that the variable sizes were chosen so that deposit and staked fit into a single uint256 word, but the 3rd parameter stake will also fit.  In SimpleAccount.sol:  Line 52: The comment makes a reference to the execFromEntryPoint function, which no longer exists. Line 57: The docstring for execute says called directly from owner, not by entryPoint, but the _requireFromEntryPointOrOwner function allows execute to be called by the EntryPoint. The comment isnt clear on whether it is a suggestion, or a restriction to be enforced. Lines 75-79: The docstring does not match the initialize function. Lines 89-96: The docstring does not match the _requireFromEntryPointOrOwner function.  In IEntryPoint.sol:  Line 26: The @success parameter is listed in the wrong order.  In UserOperation.sol:  Line 25: The callGasLimit parameter has no @param statement.  Update: Resolved in pull request #194 and pull request #216, which were merged at commits faf305e and 1f505c5 respectively.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#incorrect-or-misleading-documentation-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "Misleading specification [core]", "body": "The EIP states that when a FailedOp is detected, all other operations from the same paymaster should be removed from the current batch. However, this should only apply to FailedOp errors that explicitly mention the paymaster, which imply the paymaster was at fault. Operations that fail for unrelated reasons should not penalize their paymaster.  The EIP also states that userOp validation cannot call the handleOps method. This restriction should also apply to handleAggregatedOps.  Consider clarifying these points in the EIP.  Update: Partially resolved in pull request #196 and merged at 5929ff8. The updated EIP mistakenly refers to the EntryPoints depositTo function as depositFor.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#misleading-specification-[core]", "labels": ["OpenZeppelin"]}, {"title": "Mismatched event parameter [core]", "body": "The StakeLocked event specifies a withdrawTime parameter, but the argument passed in is the new unstake delay. Consider renaming the event parameter to match its actual usage.  Update: Resolved in pull request #197 and merged at commit 545a15c.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#mismatched-event-parameter-[core]", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings [core and samples]", "body": "Throughout the codebase there are several parts that do not have docstrings. For instance:  Line 24 in BLSAccount.sol  Line 39 in BLSAccount.sol  Line 44 in BLSAccount.sol  Line 48 in BLSAccount.sol  Line 20 in BLSSignatureAggregator.sol  Line 48 in BLSSignatureAggregator.sol  Line 106 in BLSSignatureAggregator.sol  Line 10 in IBLSAccount.sol  Line 24 in BasePaymaster.sol  Line 29 in BasePaymaster.sol  Line 31 in BasePaymaster.sol  Line 167 in EntryPoint.sol  Line 18 in StakeManager.sol  Line 11 in EIP4337Fallback.sol  Line 23 in GnosisAccountFactory.sol  Line 67 in IStakeManager.sol  Line 34 in UserOperation.sol  Line 73 in DepositPaymaster.sol  Line 27 in SimpleAccount.sol  Line 31 in SimpleAccount.sol  Line 23 in TestAggregatedAccount.sol  Line 34 in TestAggregatedAccount.sol  Line 16 in TestSignatureAggregator.sol  Line 28 in TestSignatureAggregator.sol  Line 43 in TestSignatureAggregator.sol  Line 40 in TokenPaymaster.sol  Line 6 in Exec.sol  Consider thoroughly documenting all functions and their parameters, especially public APIs. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Partially resolved in pull request #212 and merged at commit eeb93b2. The recommended changes to GnosisAccountFactory.sol were not implemented.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#missing-docstrings-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "Missing error messages in require statements [core and samples]", "body": "Within the codebase there are some require statements that lack error messages:  The require statement on line 105 of BasePaymaster.sol  The require statement on line 49 of DepositPaymaster.sol  The require statement on line 137 of SimpleAccount.sol  Consider including specific, informative error messages in require statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied.  Update: Resolved in pull request #198 and merged at commit 182b7d3. Error messages were added to the deficient require statements in BasePaymaster.sol and DepositPaymaster.sol, and the require statement in SimpleAccount.sol was eliminated as part of a code change.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#missing-error-messages-in-require-statements-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "Missing recommended function [samples]", "body": "states that an aggregated account should support the  BLSAccount contract does not contain a  the getBlsPublicKey function to  Update: Resolved in pull request #199 and merged at commit 12d2ac0. The EIP now uses the getBlsPublicKey function as an example.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#missing-recommended-function-[samples]", "labels": ["OpenZeppelin"]}, {"title": "Uninitialized implementation contract [samples]", "body": "The SimpleAccountFactory creates a new implementation contract but does not initialize it. This means that anyone can initialize the implementation contract to become its owner.  The consequences depend on the version of OpenZeppelin contracts in use. The project requires release 4.2 and later, but release 4.8 is locked. The onlyProxy modifier was introduced in release 4.3.2 to protect the upgrade mechanism. Without this modifier, the owner is authorized to call the upgrade functions on the implementation contract directly, which lets them selfdestruct it.  With the locked version, the implementation owner can execute arbitrary calls from the implementation contract, but should not be able to interfere with the operation of the proxies.  Nevertheless, to reduce the attack surface, consider restricting the versions of OpenZeppelin contracts that are supported and disabling the initializer in the constructor of the SimpleAccount contract, to prevent anyone from claiming ownership.  Update: Resolved in pull request #201 and merged at commit 4004ebf.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#uninitialized-implementation-contract-[samples]", "labels": ["OpenZeppelin"]}, {"title": "Unrestrained revert reason [core]", "body": "FailedOp error where the  line 375 and  line 417) where an untrusted contract can provide the reason, potentially including misleading error codes. For example, the sender  Consider prefixing the externally provided revert reasons with a uniquely identifying error code.  Update: Resolved in pull request #200 and merged at commit 3d8f450.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#unrestrained-revert-reason-[core]", "labels": ["OpenZeppelin"]}, {"title": "Unsafe ABI encoding", "body": "It is not an uncommon practice to use abi.encodeWithSignature or abi.encodeWithSelector to generate calldata for a low-level call. However, the first option is not safe from typographical errors, and the second option is not type-safe. The result is that both of these methods are error-prone and should be considered unsafe.  Within EIP4337Manager.sol, there are some occurrences of unsafe ABI encodings being used:  On line 119  On line 144  Consider replacing all occurrences of unsafe ABI encodings with abi.encodeCall, which checks whether the supplied values actually match the types expected by the called function, and also avoids typographical errors.  Note that a bug related to the use of string literals as inputs to abi.encodeCall was fixed in version 0.8.13, so developers should exercise caution when using this function with earlier versions of Solidity.  Update: Resolved in pull request #220 and merged at commit c0a69bf. The first example is an invalid recommendation because it is encoding an error.  Notes & Additional Information  Declare uint/int as uint256/int256 [core and samples]  codebase, there are multiple instances of  Update: Partially resolved in pull request #215 and merged at commit 998fa7d. Most instances have been addressed but there are some uint types remaining.  File relocation recommendations [samples]  To provide additional clarity regarding whether a given contract file contains core, sample, or test code, consider the following recommendations to move project files:  Within the samples directory, TestAggregatedAccount.sol, TestAggregatedAccountFactory.sol, and TestSignatureAggregator.sol contain test contracts similar to those found in the contracts/test directory. Consider relocating these files to the contracts/test directory.  The bls and gnosis directories contain sample account implementations, but do not reside in the samples directory. Consider moving these items to the samples directory.  Update: Resolved in pull request #217 and merged at commit f82cbbb.  IAccount inheritance anti-pattern  to expose a signature aggregator associated with the account. To add support for handling aggregated user operations, the  must provide a null address for this parameter. This represents an anti-pattern where a base class is aware of features only relevant to a derived class.  To address this case and future enhancements of the protocol, consider replacing the aggregator parameter in validateUserOp with a more generic extensions parameter that can be used to specify the aggregator as well as any future account-specific extensions.  Update: Resolved in pull request #216 and merged at commit 1f505c5.  Implicit size limit [core]  The packSigTimeRange function of the BaseAccount contract implicitly assumes the timestamps fit within 8 bytes. Consider enforcing this assumption by using uint64 parameters.  Update: Resolved in pull request #203 and merged at commit fa46d5b.  Incomplete event history [samples]  The BLSAccount contract emits an event when the public key is changed, but not when it is initialized. To complete the event history, consider emitting the event on initialization as well.  Update: Resolved in pull request #204 and merged at commit 2600d7e.  Lack of indexed parameter [core]  The aggregator parameter in the SignatureAggregatorChanged event is not indexed. Consider indexing the event parameter to avoid hindering the task of off-chain services searching and filtering for specific events.  Update: Resolved in pull request #202 and merged at commit 1633c06.  Naming suggestions [core and samples]  To favor explicitness and readability, there are several locations in the contracts that may benefit from better naming. Our suggestions are:  In BaseAccount.sol:  The packSigTimeRange function is internal but is not prefixed with _. Consider renaming to _packSigTimeRange.  In BasePaymaster.sol:  The packSigTimeRange function is internal but is not prefixed with _. Consider renaming to _packSigTimeRange.  In BLSSignatureAggregator.sol:  Consider renaming all instances of hashPublicKey to publicKeyHash for consistency.  In EIP4337Manager.sol:  Consider renaming the local variable _msgSender to msgSender for consistency.  In IAggregator.sol:  Consider renaming the return value of the aggregateSignatures function from aggregatesSignature to aggregatedSignature.  In IEntryPoint.sol:  The ExecutionResult error uses validBefore instead of validUntil. For consistency, consider changing the parameter name to validUntil. The ReturnInfo structs documentation for the validAfter parameter indicates it is inclusive. Consider renaming it to validFrom throughout the entire codebase. In the AggregatorStakeInfo struct, consider renaming actualAggregator to aggregator (also in the comment here).  In SenderCreator.sol:  In the createSender function, consider renaming the initAddress variable to factory to be consistent with the EntryPoint contract.  In SimpleAccount.sol:  In the addDeposit function, con", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#unsafe-abi-encoding", "labels": ["OpenZeppelin"]}, {"title": "Declare uint/int as uint256/int256 [core and samples]", "body": "Declare uint/int as uint256/int256 [core and samples]", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#declare-uint/int-as-uint256/int256-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "File relocation recommendations [samples]", "body": "To provide additional clarity regarding whether a given contract file contains core, sample, or test code, consider the following recommendations to move project files:  Within the samples directory, TestAggregatedAccount.sol, TestAggregatedAccountFactory.sol, and TestSignatureAggregator.sol contain test contracts similar to those found in the contracts/test directory. Consider relocating these files to the contracts/test directory.  The bls and gnosis directories contain sample account implementations, but do not reside in the samples directory. Consider moving these items to the samples directory.  Update: Resolved in pull request #217 and merged at commit f82cbbb.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#file-relocation-recommendations-[samples]", "labels": ["OpenZeppelin"]}, {"title": "IAccount inheritance anti-pattern", "body": "to expose a signature aggregator associated with the account. To add support for handling aggregated user operations, the  must provide a null address for this parameter. This represents an anti-pattern where a base class is aware of features only relevant to a derived class.  To address this case and future enhancements of the protocol, consider replacing the aggregator parameter in validateUserOp with a more generic extensions parameter that can be used to specify the aggregator as well as any future account-specific extensions.  Update: Resolved in pull request #216 and merged at commit 1f505c5.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#iaccount-inheritance-anti-pattern", "labels": ["OpenZeppelin"]}, {"title": "Implicit size limit [core]", "body": "The packSigTimeRange function of the BaseAccount contract implicitly assumes the timestamps fit within 8 bytes. Consider enforcing this assumption by using uint64 parameters.  Update: Resolved in pull request #203 and merged at commit fa46d5b.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#implicit-size-limit-[core]", "labels": ["OpenZeppelin"]}, {"title": "Incomplete event history [samples]", "body": "The BLSAccount contract emits an event when the public key is changed, but not when it is initialized. To complete the event history, consider emitting the event on initialization as well.  Update: Resolved in pull request #204 and merged at commit 2600d7e.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#incomplete-event-history-[samples]", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed parameter [core]", "body": "The aggregator parameter in the SignatureAggregatorChanged event is not indexed. Consider indexing the event parameter to avoid hindering the task of off-chain services searching and filtering for specific events.  Update: Resolved in pull request #202 and merged at commit 1633c06.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#lack-of-indexed-parameter-[core]", "labels": ["OpenZeppelin"]}]