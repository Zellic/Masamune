[{"title": "Anyone can call  flashLoan  for a receiver [ERC20FlashMint]", "body": "Description: Anyone can call  flashLoan  for a  receiver . An attacker can call flashLoan  repeatedly on a receiver and drain its funds as the receiver contract has to pay back extra  fee . Response: We've implemented EIP-3156. If a receiver pays a fee, they should validate the initiator in onFlashLoan", "html_url": "https://certora.cdn.prismic.io/certora/9316e8fd-9ba1-464b-9b9d-209d9ebd9803_final-report-3.pdf", "labels": ["Certora", "Medium"]}, {"title": "Votes.sol  can only support token supply upto 2^224 - 1", "body": "[Checkpoints.sol push()] Description: Since  Votes.sol  uses  Checkpoints.push , which casts the new value to  uint224 , it is only able to support token supply up till type(uint224).max . If this is indeed the case, they should mention it in the comments as they have done it for  ERC20Votes.sol Response: Votes is an abstraction of the mechanisme that was first introduced in ERC20Votes . Both are limited, by design, to uint224. We will improve Votes  documentation to more clearly reflect that limitation.", "html_url": "https://certora.cdn.prismic.io/certora/9316e8fd-9ba1-464b-9b9d-209d9ebd9803_final-report-3.pdf", "labels": ["Certora", "Informational"]}, {"title": "Extra unnecessary require [Votes.sol getPastTotalSupply()]", "body": "Description: require(blockNumber < block.number)  is checked twice when calling getPastTotalSupply() Response: The redundant require in  getPastTotalSupply  was indeed missed. The check should should indeed be removed from  Votes.sol  to save gas \fSeverity: Informational Issue: Checkpoint Overflow [ERC20Votes.sol, draft-ERC721Votes.sol] Description: Should the number of checkpoints go past 2^32 uint32 index used will no longer function properly resulting in a loss of votes. However, since the property that only one checkpoint per block number is held, this is not believed to be an issue in a realistic time frame The \"key\" art of the Checkpoints is uint32 that is currently used to store block numbers. Having it overflow would be a real issue, but we consider it very unlikelly to ever overflow, at list considering the current Response: chain design. Even if someone was to use block.timestamp based checkpoint to circumvent the unpredictable nature of block number on some L2s (which is a feature that our code doesn't provide out of the box), that overflow would happen in the year 2106.", "html_url": "https://certora.cdn.prismic.io/certora/9316e8fd-9ba1-464b-9b9d-209d9ebd9803_final-report-3.pdf", "labels": ["Certora", "Informational"]}, {"title": "Equal addresses of contract and  msg.sender  [ERC20Wrapper.sol", "body": "depositFor()/withdrawTo()] Description: Contract's address( address(this) ) can be equal to the  msg.sender , thus, it's posssible to deposit/withdraw without limits The hability to mint  ERC20Wrapper  tokens without a counterpart, while apparently not serious, has the ability to create a serious inconsistency between the totalSupply and the amount of underlying token. This could confuse external observer. Additionnaly, extensions of the ERC20Wrapper might include functionnality that use these additionals \"unbacked\" tokens. We will add a check to prevent this. Response:", "html_url": "https://certora.cdn.prismic.io/certora/9316e8fd-9ba1-464b-9b9d-209d9ebd9803_final-report-3.pdf", "labels": ["Certora", "Low"]}, {"title": "Anyone can call  flashLoan  for a receiver [ERC20FlashMint]", "body": "Description: Anyone can call  flashLoan  for a  receiver . An attacker can call flashLoan  repeatedly on a receiver and drain its funds as the receiver contract has to pay back extra  fee . Response: We've implemented EIP-3156. If a receiver pays a fee, they should validate the initiator in onFlashLoan", "html_url": "https://certora.cdn.prismic.io/certora/9316e8fd-9ba1-464b-9b9d-209d9ebd9803_final-report-3.pdf", "labels": ["Certora", "Medium"]}, {"title": "Votes.sol  can only support token supply upto 2^224 - 1", "body": "[Checkpoints.sol push()] Description: Since  Votes.sol  uses  Checkpoints.push , which casts the new value to  uint224 , it is only able to support token supply up till type(uint224).max . If this is indeed the case, they should mention it in the comments as they have done it for  ERC20Votes.sol Response: Votes is an abstraction of the mechanisme that was first introduced in ERC20Votes . Both are limited, by design, to uint224. We will improve Votes  documentation to more clearly reflect that limitation.", "html_url": "https://certora.cdn.prismic.io/certora/9316e8fd-9ba1-464b-9b9d-209d9ebd9803_final-report-3.pdf", "labels": ["Certora", "Informational"]}, {"title": "Extra unnecessary require [Votes.sol getPastTotalSupply()]", "body": "Description: require(blockNumber < block.number)  is checked twice when calling getPastTotalSupply() Response: The redundant require in  getPastTotalSupply  was indeed missed. The check should should indeed be removed from  Votes.sol  to save gas \fSeverity: Informational Issue: Checkpoint Overflow [ERC20Votes.sol, draft-ERC721Votes.sol] Description: Should the number of checkpoints go past 2^32 uint32 index used will no longer function properly resulting in a loss of votes. However, since the property that only one checkpoint per block number is held, this is not believed to be an issue in a realistic time frame The \"key\" art of the Checkpoints is uint32 that is currently used to store block numbers. Having it overflow would be a real issue, but we consider it very unlikelly to ever overflow, at list considering the current Response: chain design. Even if someone was to use block.timestamp based checkpoint to circumvent the unpredictable nature of block number on some L2s (which is a feature that our code doesn't provide out of the box), that overflow would happen in the year 2106.", "html_url": "https://certora.cdn.prismic.io/certora/9316e8fd-9ba1-464b-9b9d-209d9ebd9803_final-report-3.pdf", "labels": ["Certora", "Informational"]}, {"title": "Equal addresses of contract and  msg.sender  [ERC20Wrapper.sol", "body": "depositFor()/withdrawTo()] Description: Contract's address( address(this) ) can be equal to the  msg.sender , thus, it's posssible to deposit/withdraw without limits The hability to mint  ERC20Wrapper  tokens without a counterpart, while apparently not serious, has the ability to create a serious inconsistency between the totalSupply and the amount of underlying token. This could confuse external observer. Additionnaly, extensions of the ERC20Wrapper might include functionnality that use these additionals \"unbacked\" tokens. We will add a check to prevent this. Response:", "html_url": "https://certora.cdn.prismic.io/certora/9316e8fd-9ba1-464b-9b9d-209d9ebd9803_final-report-3.pdf", "labels": ["Certora", "Low"]}, {"title": "User unable to receive LP tokens", "body": "\fIssue: User unable to receive LP tokens user.hasWithdrawnPair  is set to true before the transfer of LP tokens. This results in a  pairBalance(user)  value of 0. This issue was fixed in commit 4804a0a9. Description: Trader Joe Response:", "html_url": "https://certora.cdn.prismic.io/certora/3b96d4be-611f-488e-92dc-89d44f4c8669_TraderJoe.pdf", "labels": ["Certora", "High"]}, {"title": "Reentrancy attack tokens", "body": "if the event is stopped and we can call  emergencyWithdraw() , we can drain the system and take all the eth.  emergencyWithdraw()  calls _safeTransferAVAX()  which uses the low level  call  function to msg.sender  with amount  user.allocation . it sets  user.allocation  to 0 only after the transfer, but in the transfer, we can call emergencyWithdraw()  again and take the  user.allocation  before it's set to 0 until we take all the money from the system. This issue was fixed in commit 578a4d5c. Description: Trader Joe Response:", "html_url": "https://certora.cdn.prismic.io/certora/3b96d4be-611f-488e-92dc-89d44f4c8669_TraderJoe.pdf", "labels": ["Certora", "High"]}, {"title": "Create bad event DOS", "body": "anyone can create an event but there can only be a single event for each token. An attacker can create bad event for all the tokens and prevent anyone from creating an event. (bad event can be one with maxAllocation==0 ). This issue was fixed in commit c750e722. Description: Trader Joe Response:", "html_url": "https://certora.cdn.prismic.io/certora/3b96d4be-611f-488e-92dc-89d44f4c8669_TraderJoe.pdf", "labels": ["Certora", "High"]}, {"title": "LaunchEvent createPair DOS", "body": "\fIssue: LaunchEvent createPair DOS An attacker can call  factory.createPair(address(WAVAX), address(token))  before the LaunchEvent reaches phase three, causing  LaunchEvent.createPair()  to revert on require(factory.getPair(address(WAVAX), address(token)) == address(0)) . This will prevent anyone from creating a pair for the given token. This issue was fixed in commit 93b2fcc9. Description: Trader Joe Response:", "html_url": "https://certora.cdn.prismic.io/certora/3b96d4be-611f-488e-92dc-89d44f4c8669_TraderJoe.pdf", "labels": ["Certora", "High"]}, {"title": "rJoeToken not initialized after setter", "body": "setRJoe(address _rJoe)  only sets the  rJoe  state variable to  _rJoe but doesn\u2019t call  initialize()  on it (the factory constructor also initializes the rJoe token). This issue was fixed in commit 93b2fcc9. Description: Trader Joe Response:", "html_url": "https://certora.cdn.prismic.io/certora/3b96d4be-611f-488e-92dc-89d44f4c8669_TraderJoe.pdf", "labels": ["Certora", "High"]}, {"title": "lastRewardTimestamp is not set in constructor", "body": "Description: Trader Joe Response: A user can transfer joe externally to the contract to make accRJoePerShare  increase by a huge number in the first updatePool() . This issue was fixed in commit 93b2fcc9.", "html_url": "https://certora.cdn.prismic.io/certora/3b96d4be-611f-488e-92dc-89d44f4c8669_TraderJoe.pdf", "labels": ["Certora", "High"]}, {"title": "Anyone can call RocketJoeToken.initialize()", "body": "the initialize() function has no modifier and thus anyone can invoke it Description: before it is called by the RocketJoeFactory. This prevents RocketJoeFactory from being initialized or changing the rJoe state variable. \fIssue: Anyone can call RocketJoeToken.initialize() Trader Joe Response: We acknowledge this issue, but handle it by making sure the contract is initialized properly post-deployment", "html_url": "https://certora.cdn.prismic.io/certora/3b96d4be-611f-488e-92dc-89d44f4c8669_TraderJoe.pdf", "labels": ["Certora", "Medium"]}, {"title": "User unable to receive LP tokens", "body": "\fIssue: User unable to receive LP tokens user.hasWithdrawnPair  is set to true before the transfer of LP tokens. This results in a  pairBalance(user)  value of 0. This issue was fixed in commit 4804a0a9. Description: Trader Joe Response:", "html_url": "https://certora.cdn.prismic.io/certora/3b96d4be-611f-488e-92dc-89d44f4c8669_TraderJoe.pdf", "labels": ["Certora", "High"]}, {"title": "Reentrancy attack tokens", "body": "if the event is stopped and we can call  emergencyWithdraw() , we can drain the system and take all the eth.  emergencyWithdraw()  calls _safeTransferAVAX()  which uses the low level  call  function to msg.sender  with amount  user.allocation . it sets  user.allocation  to 0 only after the transfer, but in the transfer, we can call emergencyWithdraw()  again and take the  user.allocation  before it's set to 0 until we take all the money from the system. This issue was fixed in commit 578a4d5c. Description: Trader Joe Response:", "html_url": "https://certora.cdn.prismic.io/certora/3b96d4be-611f-488e-92dc-89d44f4c8669_TraderJoe.pdf", "labels": ["Certora", "High"]}, {"title": "Create bad event DOS", "body": "anyone can create an event but there can only be a single event for each token. An attacker can create bad event for all the tokens and prevent anyone from creating an event. (bad event can be one with maxAllocation==0 ). This issue was fixed in commit c750e722. Description: Trader Joe Response:", "html_url": "https://certora.cdn.prismic.io/certora/3b96d4be-611f-488e-92dc-89d44f4c8669_TraderJoe.pdf", "labels": ["Certora", "High"]}, {"title": "LaunchEvent createPair DOS", "body": "\fIssue: LaunchEvent createPair DOS An attacker can call  factory.createPair(address(WAVAX), address(token))  before the LaunchEvent reaches phase three, causing  LaunchEvent.createPair()  to revert on require(factory.getPair(address(WAVAX), address(token)) == address(0)) . This will prevent anyone from creating a pair for the given token. This issue was fixed in commit 93b2fcc9. Description: Trader Joe Response:", "html_url": "https://certora.cdn.prismic.io/certora/3b96d4be-611f-488e-92dc-89d44f4c8669_TraderJoe.pdf", "labels": ["Certora", "High"]}, {"title": "rJoeToken not initialized after setter", "body": "setRJoe(address _rJoe)  only sets the  rJoe  state variable to  _rJoe but doesn\u2019t call  initialize()  on it (the factory constructor also initializes the rJoe token). This issue was fixed in commit 93b2fcc9. Description: Trader Joe Response:", "html_url": "https://certora.cdn.prismic.io/certora/3b96d4be-611f-488e-92dc-89d44f4c8669_TraderJoe.pdf", "labels": ["Certora", "High"]}, {"title": "lastRewardTimestamp is not set in constructor", "body": "Description: Trader Joe Response: A user can transfer joe externally to the contract to make accRJoePerShare  increase by a huge number in the first updatePool() . This issue was fixed in commit 93b2fcc9.", "html_url": "https://certora.cdn.prismic.io/certora/3b96d4be-611f-488e-92dc-89d44f4c8669_TraderJoe.pdf", "labels": ["Certora", "High"]}, {"title": "Anyone can call RocketJoeToken.initialize()", "body": "the initialize() function has no modifier and thus anyone can invoke it Description: before it is called by the RocketJoeFactory. This prevents RocketJoeFactory from being initialized or changing the rJoe state variable. \fIssue: Anyone can call RocketJoeToken.initialize() Trader Joe Response: We acknowledge this issue, but handle it by making sure the contract is initialized properly post-deployment", "html_url": "https://certora.cdn.prismic.io/certora/3b96d4be-611f-488e-92dc-89d44f4c8669_TraderJoe.pdf", "labels": ["Certora", "Medium"]}, {"title": "A  staticAToken  user can be owed a large sum of reward by the", "body": "staticAToken  if it's not yet registered Rules Broken: Property #44 -  getClaimableRewards_stable . see violation Description: Consider a reward token ( REW ) distributed through the INCENTIVES_CONTROLLER  to a reward-bearing token that the \fIssue: A  staticAToken  user can be owed a large sum of reward by the staticAToken  if it's not yet registered Concrete Example: StaticAToken  holds. At any time, a  staticAToken  user can invoke any claim method with an array that contains this  REW  token. If this token is not registered in the  StaticATokenLM 's reward list, the user\u02bcs  rewardsIndexOnLastInteraction  will be 0 by default. When, later,  getClaimableRewards()  is called, the rewardsIndexOnLastInteraction  sent to compute the pending rewards will depend on the value of the user's rewardsIndexOnLastInteraction . That value is the one which will be sent if it is non-zero; however, if the value is zero, _startIndex[REW]  will be sent instead. This variable represents a snapshot of the index at the time of registration. However, since the reward isn\u02bct registered, the user\u02bcs index has never been updated, and therefore it is zero. In addition, since the reward isn\u02bct registered the  startIndex[REW]  is 0. that means that the pending rewards will be calculated as:  (balance * currentRewardsIndex)/assetUint This will make the  staticAToken  owe a large amount of rewards to any user who makes a claim before the registration of the asset. In fact, the  staticAToken  may owe one or more of its users a larger amount than the incentive owes to the static Token. 1. Take an initialized  staticAToken  that just started to work with a list of 3 reward tokens that deserve to be collected thanks to the distribution of the incentive controller. 2. On initialization, the contract will register those three tokens in the  staticToken  internal list. 3. User1 is depositing for the first time at a time  t , which updates his user state, i.e. unclaimed, as well as a snapshot of the index at the time of operation. 4. At time  t' > t , a new token, REW , is added to the list of rewards that the  staticAToken  is eligible to claim. 5. Nobody refreshes the reward list in the StaticAToken . 6. User1 take any action he desires, including depositing a lot of money. 7. At time  t'' > t' , after some  REW s are starting to accumulate in the incentive controller for the staticToken 's right, user1 realises that he\u02bcs eligible for his share of REW  and tries to claim it through one of the  claim  functions of the staticAToken . 8. Since the rewards aren\u02bct registered, the user\u02bcs rewardsIndexOnLastInteraction  is never updated and stays at the default value of 0. 9. The pending rewards that  staticToken  is now owed to the user is  [user_balance * (currentIndex - 0)]/assetUnit . This value can be greater than the value actually owed by the incentive controller to the  staticAToken . If user1 is the only user in the system  staticAToken.balanceOf(user) = \fIssue: A  staticAToken  user can be owed a large sum of reward by the staticAToken  if it's not yet registered incentiveController.deservedRewards(asset, reward, staticAToken)  however, the current index of the  staticAToken  on the incentive controller must be greater than 0 because the reward- bearing token (AToken in this case) makes sure to update the code upon transfer (in  handleAction ). Mitigation/Fix: Fixed in PR #29", "html_url": "https://certora.cdn.prismic.io/certora/044181c3-315d-4b7a-9539-dcaa86637a4b_Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "Medium"]}, {"title": "Losing one share worth of assets upon deposit", "body": "Rules Broken: Property #14 -  withdrawCheck . see violation Description: Concrete Example: Suppose a user calls the  deposit()  function with an asset amount anywhere in the range  [x/2, x+1)  AToken. In that case, the deposit()  function will round up the amount of Atokens that needs to be transferred from the sender but will round down the number of staticAToken  shares the receiver gets in return. For example, the user sends x+1 Atokens, but receives only x  staticAtokens . 1. A user calls  deposit()  with an asset amount of 9 underlying tokens. The  fromUnderlying  flag is  false , so the AToken.transferFrom()  function is called. 2. AToken.transferFrom()  function eventually calls the AToken._transfer()  function. This function converts the user- specified underlying asset amount to the number of ATokens by calling the  rayDiv  function with the current rate and asset amount. 3. Due to round-up,  rayDiv  returns 1 AToken, which is equivalent to 18 underlying tokens. 4. 1 AToken is transferred from the user to the staticAToken  contract. 5. The  Deposit()  function proceeds to calculate the shares to be minted to the user.  rayDivRoundDown  is called with the rate and the asset amount (9). Due to round-down, rayDivRoundDown  returns 0. 6. The user gets 0 shares in return for the 1 AToken deposited in the vault. Mitigation/Fix: Fixed in PR #25", "html_url": "https://certora.cdn.prismic.io/certora/044181c3-315d-4b7a-9539-dcaa86637a4b_Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "Low"]}, {"title": "Non-compliance of  deposit()  with the EIP4626 standard", "body": "Rules Broken: Properties #11 & #12 -  depositCheck . see violation \fIssue: Non-compliance of  deposit()  with the EIP4626 standard Description: Concrete Example: As per EIP4626,  deposit()  must revert if all the assets cannot be deposited. In the contract, if the user calls  deposit()  with an amount of underlying assets that are less than the equivalent of half an AToken, the function will end up depositing no assets but will inappropriately fail to revert. 1. A user calls the deposit function with 547 of underlying asset tokens. The  fromUnderlying  flag is  false , so the AToken.transferFrom()  function is called. 2. AToken.transferFrom()  function eventually calls AToken._transfer() . This function converts the user-specified underlying asset amount to the number of  ATokens  by calling rayDiv  with the current rate and asset amount. 3.  rayDiv  function returns  0  as the asset amount is less than  rate/(2RAY) . As a result,  0 ATokens  get transferred from the user to the staticAToken  contract. 4. The function proceeds with the rest of the execution without reverting. Mitigation/Fix: Fixed in PR #25", "html_url": "https://certora.cdn.prismic.io/certora/044181c3-315d-4b7a-9539-dcaa86637a4b_Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "Low"]}, {"title": "Inconsistency of  getUnclaimedRewards()  return value units", "body": "Rules Broken: Property #38 -  rewardsConsistencyWhenInsufficientRewards . see violation Description: All the reward-related methods -  _getPendingRewards() , collectAndUpdateRewards ,  _getClaimableRewards , etc., compute and return values in the reward token units. However, getUnclaimedRewards()  incorrectly assumes that the user's unclaimedReward  amount is stored in  RAY  units and converts it to WAD . This can cause external protocols relying on the getter's result to interpret and function in a false state. Mitigation/Fix: Fixed in PR #24", "html_url": "https://certora.cdn.prismic.io/certora/044181c3-315d-4b7a-9539-dcaa86637a4b_Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "informational"]}, {"title": "Non-compliance of  totalAssets()  and  maxWithdraw  with the", "body": "EIP4626 standard Rules Broken: Property #21 & #26 - totalAssetsMustntRevert , maxWithdrawMustntRevert see violation \fIssue: Non-compliance of  totalAssets()  and  maxWithdraw  with the EIP4626 standard Description: Mitigation/Fix: As per EIP4626, both  maxWithdraw()  and  totalAssets()  mustn't revert by any means. The implementation, however may revert due to overflow when calling  rayMulRoundDown  in the first function and rayMul  in the second. The only way these methods can revert is when  a*b > type(uint256).max , where  a  is the  amount  and  b  is the normalizedIncome . With the following assumptions in mind: (1) type(uint256).max ~=10\u2077\u2077 , (2)  normalizedIncome  will always be around  10^27 , even with some margin on the index, the revert case will occur only when  amount > 10^45 . This is an unreasonably large amount of tokens assuming  token decimals <= 18 . All this makes the compliance violation purely theoretical with the currently used tokens.", "html_url": "https://certora.cdn.prismic.io/certora/044181c3-315d-4b7a-9539-dcaa86637a4b_Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "informational"]}, {"title": "_claimRewardsOnBehalf()  stops handling rewards after it", "body": "encounters address 0 Recommendation: The function  _claimRewardsOnBehalf()  iterates over an array of rewards passed to it by the user via one of the external claim functions. Currently, the function short-circuits at the first occurrence of address 0 in the array - it exits the function by executing  return . Although it is a viable way to handle claims, replacing the  return  with  continue  and being more forgiving to protocols that make mistakes in constructing the array is possible. Mitigation/Fix: Fixed in PR #27", "html_url": "https://certora.cdn.prismic.io/certora/044181c3-315d-4b7a-9539-dcaa86637a4b_Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "A  staticAToken  user can be owed a large sum of reward by the", "body": "staticAToken  if it's not yet registered Rules Broken: Property #44 -  getClaimableRewards_stable . see violation Description: Consider a reward token ( REW ) distributed through the INCENTIVES_CONTROLLER  to a reward-bearing token that the \fIssue: A  staticAToken  user can be owed a large sum of reward by the staticAToken  if it's not yet registered Concrete Example: StaticAToken  holds. At any time, a  staticAToken  user can invoke any claim method with an array that contains this  REW  token. If this token is not registered in the  StaticATokenLM 's reward list, the user\u02bcs  rewardsIndexOnLastInteraction  will be 0 by default. When, later,  getClaimableRewards()  is called, the rewardsIndexOnLastInteraction  sent to compute the pending rewards will depend on the value of the user's rewardsIndexOnLastInteraction . That value is the one which will be sent if it is non-zero; however, if the value is zero, _startIndex[REW]  will be sent instead. This variable represents a snapshot of the index at the time of registration. However, since the reward isn\u02bct registered, the user\u02bcs index has never been updated, and therefore it is zero. In addition, since the reward isn\u02bct registered the  startIndex[REW]  is 0. that means that the pending rewards will be calculated as:  (balance * currentRewardsIndex)/assetUint This will make the  staticAToken  owe a large amount of rewards to any user who makes a claim before the registration of the asset. In fact, the  staticAToken  may owe one or more of its users a larger amount than the incentive owes to the static Token. 1. Take an initialized  staticAToken  that just started to work with a list of 3 reward tokens that deserve to be collected thanks to the distribution of the incentive controller. 2. On initialization, the contract will register those three tokens in the  staticToken  internal list. 3. User1 is depositing for the first time at a time  t , which updates his user state, i.e. unclaimed, as well as a snapshot of the index at the time of operation. 4. At time  t' > t , a new token, REW , is added to the list of rewards that the  staticAToken  is eligible to claim. 5. Nobody refreshes the reward list in the StaticAToken . 6. User1 take any action he desires, including depositing a lot of money. 7. At time  t'' > t' , after some  REW s are starting to accumulate in the incentive controller for the staticToken 's right, user1 realises that he\u02bcs eligible for his share of REW  and tries to claim it through one of the  claim  functions of the staticAToken . 8. Since the rewards aren\u02bct registered, the user\u02bcs rewardsIndexOnLastInteraction  is never updated and stays at the default value of 0. 9. The pending rewards that  staticToken  is now owed to the user is  [user_balance * (currentIndex - 0)]/assetUnit . This value can be greater than the value actually owed by the incentive controller to the  staticAToken . If user1 is the only user in the system  staticAToken.balanceOf(user) = \fIssue: A  staticAToken  user can be owed a large sum of reward by the staticAToken  if it's not yet registered incentiveController.deservedRewards(asset, reward, staticAToken)  however, the current index of the  staticAToken  on the incentive controller must be greater than 0 because the reward- bearing token (AToken in this case) makes sure to update the code upon transfer (in  handleAction ). Mitigation/Fix: Fixed in PR #29", "html_url": "https://certora.cdn.prismic.io/certora/044181c3-315d-4b7a-9539-dcaa86637a4b_Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "Medium"]}, {"title": "Losing one share worth of assets upon deposit", "body": "Rules Broken: Property #14 -  withdrawCheck . see violation Description: Concrete Example: Suppose a user calls the  deposit()  function with an asset amount anywhere in the range  [x/2, x+1)  AToken. In that case, the deposit()  function will round up the amount of Atokens that needs to be transferred from the sender but will round down the number of staticAToken  shares the receiver gets in return. For example, the user sends x+1 Atokens, but receives only x  staticAtokens . 1. A user calls  deposit()  with an asset amount of 9 underlying tokens. The  fromUnderlying  flag is  false , so the AToken.transferFrom()  function is called. 2. AToken.transferFrom()  function eventually calls the AToken._transfer()  function. This function converts the user- specified underlying asset amount to the number of ATokens by calling the  rayDiv  function with the current rate and asset amount. 3. Due to round-up,  rayDiv  returns 1 AToken, which is equivalent to 18 underlying tokens. 4. 1 AToken is transferred from the user to the staticAToken  contract. 5. The  Deposit()  function proceeds to calculate the shares to be minted to the user.  rayDivRoundDown  is called with the rate and the asset amount (9). Due to round-down, rayDivRoundDown  returns 0. 6. The user gets 0 shares in return for the 1 AToken deposited in the vault. Mitigation/Fix: Fixed in PR #25", "html_url": "https://certora.cdn.prismic.io/certora/044181c3-315d-4b7a-9539-dcaa86637a4b_Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "Low"]}, {"title": "Non-compliance of  deposit()  with the EIP4626 standard", "body": "Rules Broken: Properties #11 & #12 -  depositCheck . see violation \fIssue: Non-compliance of  deposit()  with the EIP4626 standard Description: Concrete Example: As per EIP4626,  deposit()  must revert if all the assets cannot be deposited. In the contract, if the user calls  deposit()  with an amount of underlying assets that are less than the equivalent of half an AToken, the function will end up depositing no assets but will inappropriately fail to revert. 1. A user calls the deposit function with 547 of underlying asset tokens. The  fromUnderlying  flag is  false , so the AToken.transferFrom()  function is called. 2. AToken.transferFrom()  function eventually calls AToken._transfer() . This function converts the user-specified underlying asset amount to the number of  ATokens  by calling rayDiv  with the current rate and asset amount. 3.  rayDiv  function returns  0  as the asset amount is less than  rate/(2RAY) . As a result,  0 ATokens  get transferred from the user to the staticAToken  contract. 4. The function proceeds with the rest of the execution without reverting. Mitigation/Fix: Fixed in PR #25", "html_url": "https://certora.cdn.prismic.io/certora/044181c3-315d-4b7a-9539-dcaa86637a4b_Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "Low"]}, {"title": "Inconsistency of  getUnclaimedRewards()  return value units", "body": "Rules Broken: Property #38 -  rewardsConsistencyWhenInsufficientRewards . see violation Description: All the reward-related methods -  _getPendingRewards() , collectAndUpdateRewards ,  _getClaimableRewards , etc., compute and return values in the reward token units. However, getUnclaimedRewards()  incorrectly assumes that the user's unclaimedReward  amount is stored in  RAY  units and converts it to WAD . This can cause external protocols relying on the getter's result to interpret and function in a false state. Mitigation/Fix: Fixed in PR #24", "html_url": "https://certora.cdn.prismic.io/certora/044181c3-315d-4b7a-9539-dcaa86637a4b_Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "informational"]}, {"title": "Non-compliance of  totalAssets()  and  maxWithdraw  with the", "body": "EIP4626 standard Rules Broken: Property #21 & #26 - totalAssetsMustntRevert , maxWithdrawMustntRevert see violation \fIssue: Non-compliance of  totalAssets()  and  maxWithdraw  with the EIP4626 standard Description: Mitigation/Fix: As per EIP4626, both  maxWithdraw()  and  totalAssets()  mustn't revert by any means. The implementation, however may revert due to overflow when calling  rayMulRoundDown  in the first function and rayMul  in the second. The only way these methods can revert is when  a*b > type(uint256).max , where  a  is the  amount  and  b  is the normalizedIncome . With the following assumptions in mind: (1) type(uint256).max ~=10\u2077\u2077 , (2)  normalizedIncome  will always be around  10^27 , even with some margin on the index, the revert case will occur only when  amount > 10^45 . This is an unreasonably large amount of tokens assuming  token decimals <= 18 . All this makes the compliance violation purely theoretical with the currently used tokens.", "html_url": "https://certora.cdn.prismic.io/certora/044181c3-315d-4b7a-9539-dcaa86637a4b_Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "informational"]}, {"title": "_claimRewardsOnBehalf()  stops handling rewards after it", "body": "encounters address 0 Recommendation: The function  _claimRewardsOnBehalf()  iterates over an array of rewards passed to it by the user via one of the external claim functions. Currently, the function short-circuits at the first occurrence of address 0 in the array - it exits the function by executing  return . Although it is a viable way to handle claims, replacing the  return  with  continue  and being more forgiving to protocols that make mistakes in constructing the array is possible. Mitigation/Fix: Fixed in PR #27", "html_url": "https://certora.cdn.prismic.io/certora/044181c3-315d-4b7a-9539-dcaa86637a4b_Formal_Verification_Report_staticAToken-1.pdf", "labels": ["Certora", "Recommendation"]}, {"title": "Creating collateral from nothing by using  transferCollateral", "body": "Description: When calling  transferCollateral()  the new balances of the sender and the recipient are calculated and stored in two steps. Since the calculation is being done first for both users, it is possible to create funds from nothing by specifying  src = dst . In this case the increment of  dst  balance overwrites the decrement of the  src balance, effectively increasing the balance by the amount given. Properties Violated: Total collateral per asset (property #1) Verify transferAsset (property #12) Compound Response: This issue was fixed in commit c0d8a11f424747204ce680f0fe17441368f4d85c.", "html_url": "https://certora.cdn.prismic.io/certora/e7ca6508-fad8-4a41-8588-b3312d8b750e_Compound+Report.pdf", "labels": ["Certora", "Critical"]}, {"title": "Creating base token from nothing by using  transferBase", "body": "\fIssue: Creating base token from nothing by using  transferBase Description: When calling  transferBase()  the new balances of the sender and the recipient are calculated and stored in two steps. Since the calculation is being done first for both users, it is possible to create funds from nothing by specifying  src = dst . In this case the increment of  dst  balance overwrites the decrement of the  src balance, effectively increasing the balance by the amount given. Properties Violated: Total base token (property #5) Verify transferAsset (property #12) Compound This issue was fixed in commit Response: c0d8a11f424747204ce680f0fe17441368f4d85c.", "html_url": "https://certora.cdn.prismic.io/certora/e7ca6508-fad8-4a41-8588-b3312d8b750e_Compound+Report.pdf", "labels": ["Certora", "Critical"]}, {"title": "Wrong calculation of  principalValue", "body": "Description: The function  principalValue()  is using the functions presentValueSupply()  and  presentValueBorrow()  to calculate the principle value. It should use  principalValueSupply()  and principalValueBorrow()  instead. Property Violated: -- Compound This issue was fixed in commit Response: ffac97079f6573cc7cdb8ebc4e024ffce55825e9.", "html_url": "https://certora.cdn.prismic.io/certora/e7ca6508-fad8-4a41-8588-b3312d8b750e_Compound+Report.pdf", "labels": ["Certora", "Critical"]}, {"title": "Incorrect liquidation computation", "body": "Description: When invoking  absorbInternal() ,  accrue()  is being called after the check  isLiquidatable() . In practice, it means that the check whether a user is liquidatable is being done on a non-updated state of the system, i.e. on the state of the user from the last time an update was called. For example, a borrower can be not liquidatable at time $t=0$, then after some time $(t)$ passes and debts accumulate, the borrower enters a liquidatable state at time $t$. If at no point in time $t'\u2265t$ did anybody call the  accrue()  function through a financial action-- withdraw() ,  supply() ,  transfer() --a call to absorbInternal()  will not allow users to absorb the borrower's assets even though in reality he/she should be liquidatable. \fIssue: Property Violated: -- Incorrect liquidation computation Compound This issue was fixed in commit Response: cf066c4995162d5ac7d455a33e442d8dc7cbb2bb.", "html_url": "https://certora.cdn.prismic.io/certora/e7ca6508-fad8-4a41-8588-b3312d8b750e_Compound+Report.pdf", "labels": ["Certora", "Medium"]}, {"title": "Incorrect gain of assets, incorrect option to  buyCollateral", "body": "Description: withdrawReserves()  and  buyCollateral()  use the  getReserves() function to check the present value of  totalSupply  and totalBorrow . If  accrue()  is not called beforehand, the present values may not be fully up-to-date. As a result the calculated reserves amount will be inaccurate. This will prevent the governor from taking out its rightful assets, or mean that  getReserves()  retrieves a larger number than the governance. In addition, one might be able to buy collateral (at a discount) when not appropriate. Property Violated: Balance change vs accrue (property #9) Compound Response: This issue was fixed in commit 59def475c9ca9570f690201b7dd07a3ce1ed1a6b.", "html_url": "https://certora.cdn.prismic.io/certora/e7ca6508-fad8-4a41-8588-b3312d8b750e_Compound+Report.pdf", "labels": ["Certora", "Medium"]}, {"title": "Incorrect collateral representation", "body": "Description: absorbInternal()  sets all of a user's collateral assets to 0, but never updates the user's  assetIn() . This means that even though the collateral balance of a user is 0, the bit is still 'on' such that the function  isInAsset()  will return true. This wastes gas in methods like isBorrowCollateralized() ,  getBorrowLiquidity() , isLiquidatable() ,  getLiquidationMargin() , and absorbInternal()  which count on the correct update of  assetIn when iterating over collateral assets. Property Violated: AssetIn initialized with balance (property #8) Compound This issue was fixed in commit Response: 83211fa995a1e3bb79d98cbfdd453f0ce7f7b2e7. Gas Optimization \faccrue()  can be called in  absorb()  instead of  absorbInternal()  - Currently accrue()  is being called in  absorbInternal()  and therefore being called in every loop iteration over the array of accounts. The accrual can be moved to  absorb()  to save some unnecessary operations. Update of accrual time can be saved in some cases - The update  lastAccrualTime = now_  in  accrue()  can be done inside the  if (timeElapsed > 0)  to save gas on storage. Redundant use of  Safe64()  - The use of  Safe64()  on  asset.scale  in isBorrowCollateralized  and  getBorrowLiquidity  is redundant since scale is already a  uint64 . Redundant assignment of  TotalsCollateral  to memory - In withdrawCollateral()  there is an assignment of  totalsCollateral  into a local variable which is redundant as it's accessed only once throughout the method. Redundant check in  absorbInternal()  - In  absorbInternal()  there is no need to check  if seizeAmount > 0 , because of the  isInAsset()  check beforehand. Redundant assignment of  newBalance  in  absorbInternal()  - In absorbInternal() , a more efficient way to execute the line  newBalance = newBalance < 0 ? int104(0) : newBalance  is by replacing it with  if(newBalance < 0) { newBalance = 0} . All the gas optimization suggestions were implemented in commit 10ca0422e4e983d8384a08c5d19ecb34515b66aa.", "html_url": "https://certora.cdn.prismic.io/certora/e7ca6508-fad8-4a41-8588-b3312d8b750e_Compound+Report.pdf", "labels": ["Certora", "Low"]}, {"title": "Creating collateral from nothing by using  transferCollateral", "body": "Description: When calling  transferCollateral()  the new balances of the sender and the recipient are calculated and stored in two steps. Since the calculation is being done first for both users, it is possible to create funds from nothing by specifying  src = dst . In this case the increment of  dst  balance overwrites the decrement of the  src balance, effectively increasing the balance by the amount given. Properties Violated: Total collateral per asset (property #1) Verify transferAsset (property #12) Compound Response: This issue was fixed in commit c0d8a11f424747204ce680f0fe17441368f4d85c.", "html_url": "https://certora.cdn.prismic.io/certora/e7ca6508-fad8-4a41-8588-b3312d8b750e_Compound+Report.pdf", "labels": ["Certora", "Critical"]}, {"title": "Creating base token from nothing by using  transferBase", "body": "\fIssue: Creating base token from nothing by using  transferBase Description: When calling  transferBase()  the new balances of the sender and the recipient are calculated and stored in two steps. Since the calculation is being done first for both users, it is possible to create funds from nothing by specifying  src = dst . In this case the increment of  dst  balance overwrites the decrement of the  src balance, effectively increasing the balance by the amount given. Properties Violated: Total base token (property #5) Verify transferAsset (property #12) Compound This issue was fixed in commit Response: c0d8a11f424747204ce680f0fe17441368f4d85c.", "html_url": "https://certora.cdn.prismic.io/certora/e7ca6508-fad8-4a41-8588-b3312d8b750e_Compound+Report.pdf", "labels": ["Certora", "Critical"]}, {"title": "Wrong calculation of  principalValue", "body": "Description: The function  principalValue()  is using the functions presentValueSupply()  and  presentValueBorrow()  to calculate the principle value. It should use  principalValueSupply()  and principalValueBorrow()  instead. Property Violated: -- Compound This issue was fixed in commit Response: ffac97079f6573cc7cdb8ebc4e024ffce55825e9.", "html_url": "https://certora.cdn.prismic.io/certora/e7ca6508-fad8-4a41-8588-b3312d8b750e_Compound+Report.pdf", "labels": ["Certora", "Critical"]}, {"title": "Incorrect liquidation computation", "body": "Description: When invoking  absorbInternal() ,  accrue()  is being called after the check  isLiquidatable() . In practice, it means that the check whether a user is liquidatable is being done on a non-updated state of the system, i.e. on the state of the user from the last time an update was called. For example, a borrower can be not liquidatable at time $t=0$, then after some time $(t)$ passes and debts accumulate, the borrower enters a liquidatable state at time $t$. If at no point in time $t'\u2265t$ did anybody call the  accrue()  function through a financial action-- withdraw() ,  supply() ,  transfer() --a call to absorbInternal()  will not allow users to absorb the borrower's assets even though in reality he/she should be liquidatable. \fIssue: Property Violated: -- Incorrect liquidation computation Compound This issue was fixed in commit Response: cf066c4995162d5ac7d455a33e442d8dc7cbb2bb.", "html_url": "https://certora.cdn.prismic.io/certora/e7ca6508-fad8-4a41-8588-b3312d8b750e_Compound+Report.pdf", "labels": ["Certora", "Medium"]}, {"title": "Incorrect gain of assets, incorrect option to  buyCollateral", "body": "Description: withdrawReserves()  and  buyCollateral()  use the  getReserves() function to check the present value of  totalSupply  and totalBorrow . If  accrue()  is not called beforehand, the present values may not be fully up-to-date. As a result the calculated reserves amount will be inaccurate. This will prevent the governor from taking out its rightful assets, or mean that  getReserves()  retrieves a larger number than the governance. In addition, one might be able to buy collateral (at a discount) when not appropriate. Property Violated: Balance change vs accrue (property #9) Compound Response: This issue was fixed in commit 59def475c9ca9570f690201b7dd07a3ce1ed1a6b.", "html_url": "https://certora.cdn.prismic.io/certora/e7ca6508-fad8-4a41-8588-b3312d8b750e_Compound+Report.pdf", "labels": ["Certora", "Medium"]}, {"title": "Incorrect collateral representation", "body": "Description: absorbInternal()  sets all of a user's collateral assets to 0, but never updates the user's  assetIn() . This means that even though the collateral balance of a user is 0, the bit is still 'on' such that the function  isInAsset()  will return true. This wastes gas in methods like isBorrowCollateralized() ,  getBorrowLiquidity() , isLiquidatable() ,  getLiquidationMargin() , and absorbInternal()  which count on the correct update of  assetIn when iterating over collateral assets. Property Violated: AssetIn initialized with balance (property #8) Compound This issue was fixed in commit Response: 83211fa995a1e3bb79d98cbfdd453f0ce7f7b2e7. Gas Optimization \faccrue()  can be called in  absorb()  instead of  absorbInternal()  - Currently accrue()  is being called in  absorbInternal()  and therefore being called in every loop iteration over the array of accounts. The accrual can be moved to  absorb()  to save some unnecessary operations. Update of accrual time can be saved in some cases - The update  lastAccrualTime = now_  in  accrue()  can be done inside the  if (timeElapsed > 0)  to save gas on storage. Redundant use of  Safe64()  - The use of  Safe64()  on  asset.scale  in isBorrowCollateralized  and  getBorrowLiquidity  is redundant since scale is already a  uint64 . Redundant assignment of  TotalsCollateral  to memory - In withdrawCollateral()  there is an assignment of  totalsCollateral  into a local variable which is redundant as it's accessed only once throughout the method. Redundant check in  absorbInternal()  - In  absorbInternal()  there is no need to check  if seizeAmount > 0 , because of the  isInAsset()  check beforehand. Redundant assignment of  newBalance  in  absorbInternal()  - In absorbInternal() , a more efficient way to execute the line  newBalance = newBalance < 0 ? int104(0) : newBalance  is by replacing it with  if(newBalance < 0) { newBalance = 0} . All the gas optimization suggestions were implemented in commit 10ca0422e4e983d8384a08c5d19ecb34515b66aa.", "html_url": "https://certora.cdn.prismic.io/certora/e7ca6508-fad8-4a41-8588-b3312d8b750e_Compound+Report.pdf", "labels": ["Certora", "Low"]}, {"title": "Rules", "body": "Broken: A governance with a voting token that has 0 total supply will consider all current and future proposals to have reached quorum. quorumReachedEffect ,  proposalNotCreatedEffects , proposalInOneState \fA governance with a voting token that has 0 total supply will Issue: consider all current and future proposals to have reached quorum. Description: A voting token with 0 token supply will result in all proposals being considered as having reached quorum. This can be an issue in the case that the token has not been initialized/minted, but this case is not as interesting because there will be no tokens to vote with. A more interesting case can arise if the voting token's  totalSupply  is accidentally set to 0. This will allow all proposals to reach quorum and thus be executable as long as the vote is successful. This is an edge case that should never manifest as long as tokens withhold the invariant that total supply is equal to the sum of all Response: balances, as in this case no one will be able to vote for a proposal and the condition for a successful proposal will never be met (more for votes than against votes).", "html_url": "https://certora.cdn.prismic.io/certora/0f91bd2e-db83-4c02-8bb3-e7d7fc895bde_OZ-final-report.pdf", "labels": ["Certora", "Low"]}, {"title": "Rules", "body": "Broken: Description: TimelockController  should not have additional executors beside the governor ( GovernorTimelockControl._execute() ) None An executor can execute a scheduled operation on the TimelockController  by calling  TimelockController.execute . If the operation was queued using  GovernorTimelockControl.queue , this will cause  GovernorTimelockControl.execute  to revert as the proposal has already been executed by the  TimelockController . (Same issue with calling  TimelockController.cancel ) Agreed, but probably not any significant consequence. The only Response: consequence is that if the proposal is executed directly in the timelock, the \"ProposalExecuted\" event will never be emitted.", "html_url": "https://certora.cdn.prismic.io/certora/0f91bd2e-db83-4c02-8bb3-e7d7fc895bde_OZ-final-report.pdf", "labels": ["Certora", "Low"]}, {"title": "Rules", "body": "Broken: A governance with a voting token that has 0 total supply will consider all current and future proposals to have reached quorum. quorumReachedEffect ,  proposalNotCreatedEffects , proposalInOneState \fA governance with a voting token that has 0 total supply will Issue: consider all current and future proposals to have reached quorum. Description: A voting token with 0 token supply will result in all proposals being considered as having reached quorum. This can be an issue in the case that the token has not been initialized/minted, but this case is not as interesting because there will be no tokens to vote with. A more interesting case can arise if the voting token's  totalSupply  is accidentally set to 0. This will allow all proposals to reach quorum and thus be executable as long as the vote is successful. This is an edge case that should never manifest as long as tokens withhold the invariant that total supply is equal to the sum of all Response: balances, as in this case no one will be able to vote for a proposal and the condition for a successful proposal will never be met (more for votes than against votes).", "html_url": "https://certora.cdn.prismic.io/certora/0f91bd2e-db83-4c02-8bb3-e7d7fc895bde_OZ-final-report.pdf", "labels": ["Certora", "Low"]}, {"title": "Rules", "body": "Broken: Description: TimelockController  should not have additional executors beside the governor ( GovernorTimelockControl._execute() ) None An executor can execute a scheduled operation on the TimelockController  by calling  TimelockController.execute . If the operation was queued using  GovernorTimelockControl.queue , this will cause  GovernorTimelockControl.execute  to revert as the proposal has already been executed by the  TimelockController . (Same issue with calling  TimelockController.cancel ) Agreed, but probably not any significant consequence. The only Response: consequence is that if the proposal is executed directly in the timelock, the \"ProposalExecuted\" event will never be emitted.", "html_url": "https://certora.cdn.prismic.io/certora/0f91bd2e-db83-4c02-8bb3-e7d7fc895bde_OZ-final-report.pdf", "labels": ["Certora", "Low"]}, {"title": "Rules", "body": "Broken: Description: Protocol hijack by single validator transacationDoesNotExistsImpliesNotConfirmed In the  removeTransaction()  function, removing a transaction does not set all its confirmations to false. This leaves the  transactionId that was removed as pre-confirmed, so a following transaction to that transactionId  will be immediately executed (as it already has \fIssue: Protocol hijack by single validator enough votes). An attacker could leverage this to call upgradeContract()  function and take control over the protocol The vulnerable removeTransaction function was removed in aa1a4. Asset value upgrade Calling  upgradeAsset()  on an asset from a low-value token to a high-value token would greatly increase the value a user already owns on that  assetId . This improper increase would cause insolvency. The vulnerable updateAsset function was removed in 62e64. Double execution of same request dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "Critical"]}, {"title": "Rules Broken:", "body": "Description: dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "Critical"]}, {"title": "Rules", "body": "Broken: A malicious validator could migrate a proposal that it wants to duplicate and not sign it on-chain. The malicious validator would call the  migrate()  when ( quorum  - 1) signatures are obtained. This would enable them to sign the proposal off-chain and send it to the Description: other side, while the migrated proposal would also likely be signed and sent. Unless the migration process on this side is tracked very tightly by all good validators and the other side's bridge, it would be impossible to distinguish between such a malicious duplication and an actual case of two proposals with the same request. The vulnerable migrateProposal function was removed in b3179. dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "Critical"]}, {"title": "DOS by a validator frontruns transactions", "body": "Rules Broken: nonDOS A malicious validator can  voteForTransaction  with the id of the future transaction he wants to prevent and then this transaction will not be able to be submitted. This is a DOS to any transaction that the malicious validator wants to prevent and he can even prevent his removal because he can prevent this transaction. The bridge contract is only deployed to networks where consensus is controlled by the same set of validators that controls the contract. For example, the Milkomeda C1 sidechain is run by the bridge contract validators operating under the IBFT consensus. Under honest majority assumption a corrupt validator will not be able to block their removal from the contract for instance because they can be ejected as a validator on the consensus level (bypassing any communication via EVM transactions). Description: dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "High"]}, {"title": "Vote on canceled Unwrapping Proposal", "body": "Rules Broken: \fIssue: Vote on canceled Unwrapping Proposal Validators can vote on a canceled Unwrapping Proposal and may lead to its execution if the quorum is reached. This can happen because there is no way to distinguish between a canceled UPT and a confirmed UPT. The vulnerable migrateProposal function was removed in b3179. Description: dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "High"]}, {"title": "DOS by Reset all voting on unwrappingProposals", "body": "Rules Broken: Description: dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "High"]}, {"title": "Rules", "body": "Broken: Description: dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "Medium"]}, {"title": "unwrapping proposal getting stuck after quorum change", "body": "Rules Broken: Description: If an unwrapping proposal has vote count 'x' that is less than the quorum and the quorum is changed to be less than 'x', the \fIssue: unwrapping proposal getting stuck after quorum change unwrapping proposal will never be executed and will remain stucked because it is flaged as not closed but it's voting had reached the quorum dcSpark Response: Fixed by adding  confirmUnwrappingProposalTransaction . to confirm unwrapping proposal transactions that it's votes had reached the quorum", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "Low"]}, {"title": "Replace to zero validator", "body": "Rules Broken: zeroNotValidator The notnull modifier was missing in the  replaceValidator function meaning a majority could add 0x0 as a validator by mistake. Fixed in 35a12. Description: dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "Low"]}, {"title": "Rules", "body": "Broken: Description: Protocol hijack by single validator transacationDoesNotExistsImpliesNotConfirmed In the  removeTransaction()  function, removing a transaction does not set all its confirmations to false. This leaves the  transactionId that was removed as pre-confirmed, so a following transaction to that transactionId  will be immediately executed (as it already has \fIssue: Protocol hijack by single validator enough votes). An attacker could leverage this to call upgradeContract()  function and take control over the protocol The vulnerable removeTransaction function was removed in aa1a4. Asset value upgrade Calling  upgradeAsset()  on an asset from a low-value token to a high-value token would greatly increase the value a user already owns on that  assetId . This improper increase would cause insolvency. The vulnerable updateAsset function was removed in 62e64. Double execution of same request dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "Critical"]}, {"title": "Rules Broken:", "body": "Description: dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "Critical"]}, {"title": "Rules", "body": "Broken: A malicious validator could migrate a proposal that it wants to duplicate and not sign it on-chain. The malicious validator would call the  migrate()  when ( quorum  - 1) signatures are obtained. This would enable them to sign the proposal off-chain and send it to the Description: other side, while the migrated proposal would also likely be signed and sent. Unless the migration process on this side is tracked very tightly by all good validators and the other side's bridge, it would be impossible to distinguish between such a malicious duplication and an actual case of two proposals with the same request. The vulnerable migrateProposal function was removed in b3179. dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "Critical"]}, {"title": "DOS by a validator frontruns transactions", "body": "Rules Broken: nonDOS A malicious validator can  voteForTransaction  with the id of the future transaction he wants to prevent and then this transaction will not be able to be submitted. This is a DOS to any transaction that the malicious validator wants to prevent and he can even prevent his removal because he can prevent this transaction. The bridge contract is only deployed to networks where consensus is controlled by the same set of validators that controls the contract. For example, the Milkomeda C1 sidechain is run by the bridge contract validators operating under the IBFT consensus. Under honest majority assumption a corrupt validator will not be able to block their removal from the contract for instance because they can be ejected as a validator on the consensus level (bypassing any communication via EVM transactions). Description: dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "High"]}, {"title": "Vote on canceled Unwrapping Proposal", "body": "Rules Broken: \fIssue: Vote on canceled Unwrapping Proposal Validators can vote on a canceled Unwrapping Proposal and may lead to its execution if the quorum is reached. This can happen because there is no way to distinguish between a canceled UPT and a confirmed UPT. The vulnerable migrateProposal function was removed in b3179. Description: dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "High"]}, {"title": "DOS by Reset all voting on unwrappingProposals", "body": "Rules Broken: Description: dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "High"]}, {"title": "Rules", "body": "Broken: Description: dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "Medium"]}, {"title": "unwrapping proposal getting stuck after quorum change", "body": "Rules Broken: Description: If an unwrapping proposal has vote count 'x' that is less than the quorum and the quorum is changed to be less than 'x', the \fIssue: unwrapping proposal getting stuck after quorum change unwrapping proposal will never be executed and will remain stucked because it is flaged as not closed but it's voting had reached the quorum dcSpark Response: Fixed by adding  confirmUnwrappingProposalTransaction . to confirm unwrapping proposal transactions that it's votes had reached the quorum", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "Low"]}, {"title": "Replace to zero validator", "body": "Rules Broken: zeroNotValidator The notnull modifier was missing in the  replaceValidator function meaning a majority could add 0x0 as a validator by mistake. Fixed in 35a12. Description: dcSpark Response:", "html_url": "https://certora.cdn.prismic.io/certora/0c1e0451-41c0-44d2-b8ae-6725d7039413_Formal-Verification-Report-of-dcSpark-Sidechain-Bridge.pdf", "labels": ["Certora", "Low"]}, {"title": "DoS - incorrect handling when depositing underlying tokens", "body": "Description: When depositing an amount of underlying token that isn't a whole multiplication of the liquidity index to the vault, the contract may reach a dirty state that keeps reverting undesirably on every method that calls  accrueYield() . This occurs due to an inaccurate increment of  lastVaultBalance  that doesn't correspond to the actual increment or decrement in the vault's assets following \fIssue: DoS - incorrect handling when depositing underlying tokens deposit()  or  mint() . In such cases,  lastVaultBalance  ends up being greater than  ATOKEN.balanceof(vault) , which causes a revert when the new yield is being calculated. The state can be corrected by increasing the existing assets relative to lastVaultBalance . This may occur naturally due to the fact that the token accrue yield from the pool, but it can also be initiated by sending a gift to the contract. initial state: Consider a valid state where  index = 10 Ray, totalSupply = 100 Ray, totalAsset = 101Ray . Action 1: A user deposits a sum of 91 underlying tokens through the contract. The first action invoked is accrual, which updates the state to lastVaultBalance = _AToken.balanceOf(vault), lastUpdated = now . Action 2: The amount of shares that the assets are worth is calculated through  previewDeposit() . The simulation returns shares = (assets * totalSupply)/totalAssets ~= 90.099 , but after rounding down, the result will be  shares = 90 . Action 3: From the amount of shares, the number of assets supplied to the pool is recalculated with  _convertToAssets  rounding up. The result of this calculation will be  assets = (shares * totalAssets)/totalSupply = 90.9 = 91 . Action 4: The contract sends the 91 assets to the pool, which will mint 9 aToken with a worth of 90 underlying tokens. However,  lastVaultBalance  will be incremented by the full 91 assets that were passed to the function. Post State: At this point, the state of the contract is  index = 10 Ray, totalSupply = 190 Ray, totalAsset = 101 + 90 = 191Ray, lastVaultBalance = 101 + 91 = 192  In this state, any call to  accrueYield()  will perform the calculation  newYield = newVaultBalance - _s.lastVaultBalance which will immediately revert due to underflow. Example: Mitigation/Fix: Fixed in PR#70, merged in commit 32edfe6.", "html_url": "https://certora.cdn.prismic.io/certora/4473e951-37ff-410f-b76d-345a2ee342d0_Aave-Vault-Formal-Verification.pdf", "labels": ["Certora", "Medium"]}, {"title": "Description:", "body": "Grifting - an attacker can prevent other users from withdrawing for a duration of a block An attacker can prevent other users from withdrawing part of their funds, or otherwise force revert by gifting assets to the vault. A gift can be given by directly transferring tokens to the vault at a block where  accrueYield()  is called. By doing this, the malicious player takes  lastVaultBalance  out of sync with _AToken.balanceof(vault) . At this stage, the share-to-asset ratio \fIssue: Grifting - an attacker can prevent other users from withdrawing for a duration of a block used to determine the amount of assets a user deserves for redeeming their shares is using  _AToken.balanceof(vault) . However, upon  redeem() , the withdrawn amount is deducted from lastVaultBalance . This mismatch in balance values may lead to reverting cases when the victim tries to withdraw an amount greater than the recorded  lastVaultBalance . The amount of money that the attacker needs to gift the system in order to execute the attack successfully is determined by the following formula (it does not take rounding into account):  giftAmount > totalAsset(t0) * [1]  where [(totalShares(t0)/BobSharesToRedeem) - 1] totalAssets(t0)  is the  _AToken.balanceOf(vault)  before the gift,  totalShares(t0)  is the amount of shares in the vault before the gift,  BobSharesToRedeem  is the amount of shares the victim desires to redeem, and  giftAmount  is the amount of assets needed to be gifted to the system by the attacker. Simply put, the gift is proportional to the total amount of reserves in the vault prior to the gift. A simple assignment shows that even for a victim that holds a significant share of the pool which is 50%, the amount needing to be gifted is greater than the total reserves that the pool backs up. Note: This is only valid for the same block the gift was transferred. In the next accrual,  lastVaultBalance  is synced, and the user can withdraw their funds. initial state: Consider the valid state  totalAssets = 200, totalShares = 200 , where the entire 200 shares belong to a victim. Step 1: An honest user deposits 1 asset, which grants them 1 share. This brings the state of the contract to  totalAssets = 201, totalShares = 201, lastVaultBalance = 201, lastUpdated = now Step 2: The attacker gifts 3 assets to the vault and takes lastVaultBalance  out of sync with the _AToken.balanceOf(vault) . This brings the state of the contract to totalAssets = 204, totalShares = 201, lastVaultBalance = 201 . Post State: If the victim tries to redeem all their shares, the share-to-asset ratio will evaluate their 200 shares as  200 * 204/201 = 202  assets. When the code gets to the point where it updates lastVaultBalance , the function will revert due to underflow: lastVaultBalance = 201 - 202 . Example: Mitigation/Fix: Fixed in PR#82 merged in commit 385b397. The following 3 issues are derived from the same sequence of initial states and transactions and are a result of the same vulnerability. \fSeverity: Medium Issue: Insolvency - lack of reserves to backup the vault's shares Rules Broken: property #14 -  getClaimableFees_LEQ_ATokenBalance  property #15 -  positiveSupply_imply_positiveAssets Given some initial state, an attacker can cause the protocol to deserve fees amounting to a larger value than its reserves. This means a state of insolvency. The coordinated transaction sequence described below relies on two things: 1. An optimization in the code that omits computation of the fees owed by protocol if such computation was already performed in the same block. 2. Although the vault uses the  _AToken.balanceOf[vault]  to track its reserves, it allows users to bypass the  lastVaultBalance  update (accrual) when gifting money to the protocol. The amount of money that the attacker needs to gift the system in order to execute the attack successfully is determined by the following formula (it does not take rounding into account):  (totalAssets(t0) - Description: [2]  where withdrawnAmount)/feePercentage <= giftAmount totalAssets(t0)  is the  _AToken.balanceOf(vault)  before the gift,  withdrawnAmount  is the amount of assets being withdrawn by the attacker to cause the insolvency,  feePercentage  is the is the fee percentage charges by the vault, and  giftAmount  is the amount of assets needed to be gifted to the system by the attacker. During this griefing attack, the attacker loses a sum of:  giftAmount * (1 - withdrawn_amount/totalAssets(t0)) . We can immediately see that the max loss to the attacker is the gift amount. [2] Example: The following scenario assumes that a 5% fee is deducted by the vault. initial state: Consider the valid state  _accumulatedFees = 700, _AToken.balanceOf(vault) = 1700, lastVaultBalance = 1700, totalSupply = 1000 . From the definition,  totalAssets() = 1700 - 700 = 1000 , the ratio of share-to-asset is  1:1 . Step 1: An attacker is gifting the vault  620  assets by a call to withdrawATokens()  with the vault as the recipient. This updates the state of the contract to be:  _accumulatedFees = 700, _AToken.balanceOf(vault) = 1700, lastVaultBalance = 1080, totalSupply = 380 ,  lastUpdated = now , which implies the share- to-assets ratio is now around  1:2.63 . Step 2: On the same block, the attacker, which holds an adequate amount of shares in the pool, withdraws  970  assets by redeeming  ~369  shares. Due to optimization on the update block,  totalAssets()  is using a stored, outdated amount of fees deserved by the protocol instead of computing the value using  lastVaultBalance . The recorded value \fIssue: Insolvency - lack of reserves to backup the vault's shares is  totalSupply = 1700 - 700 = 1000 . Post State: Following step 2, the state of the contract is now:  _accumulatedFees = 700, _AToken.balanceOf(vault) = 730, lastVaultBalance = 110, totalSupply = ~11 . In the next block ( time > now ), the function getClaimableFees()  returns  700 + 0.05*(730 - 110) = 731 , while  _AToken.balanceOf(vault) = 730 . A call to  withdrawFees() with the entire reserve sum (or less) will cause insolvency, meaning shareholders have no assets to backup their shares. Note: this broken state is \"eternal\". Even without withdrawing fees, once _accrueYield()  is being performed, the state variable _accumulatedFees  will be updated to the \"bad\" value, 731. Mitigation/Fix: Fixed in PR#82 merged in commit 385b397.", "html_url": "https://certora.cdn.prismic.io/certora/4473e951-37ff-410f-b76d-345a2ee342d0_Aave-Vault-Formal-Verification.pdf", "labels": ["Certora", "Medium"]}, {"title": "Complete DoS of the contract due to revert of  totalAssets()", "body": "Rules Broken: property #14 -  getClaimableFees_LEQ_ATokenBalance Description: Following the scenario described in the issue above, the final state constitutes  getClaimableFees() > _AToken.balanceOf(vault) , which, as we explained, will remain eternal once an accrual is being performed at one of the next blocks. This state results in a revert of any call to  totalAssets()  due to the underflow of the definition - ATOKEN.balanceOf(vault) - getClaimableFees() . This practically DoS the system completely since every function calls totalAssets()  through  convertToAssets  or  convertToShares . Mitigation/Fix: Fixed in PR#82 merged in commit 385b397.", "html_url": "https://certora.cdn.prismic.io/certora/4473e951-37ff-410f-b76d-345a2ee342d0_Aave-Vault-Formal-Verification.pdf", "labels": ["Certora", "Medium"]}, {"title": "Misinformation -  previewRedeem()  returns a larger amount of", "body": "assets than an immediate  redeem() Rules Broken: property #14 -  getClaimableFees_LEQ_ATokenBalance Description: Following the scenario described in the previous issue, if instead of performing Step 2, an honest user calls  previewRedeem()  at the same block, the returned value of the preview will be calculated according to the broken ratio ( 1:2.63  shown in the example). If the user calls  redeem()  at the next block, the amount of assets transferred to them will be smaller than expected, according to a lower ratio ( 1:2.55  shown in the example). This is because upon \fIssue: Misinformation -  previewRedeem()  returns a larger amount of assets than an immediate  redeem() redemption,  _accrueYield()  is called, which causes a reduction in totalAssets()  by  feePercentage * (ATOKEN.balanceOf(vault) - lastVaultBalance) . Mitigation/Fix: Fixed in PR#82 merged in commit 385b397.", "html_url": "https://certora.cdn.prismic.io/certora/4473e951-37ff-410f-b76d-345a2ee342d0_Aave-Vault-Formal-Verification.pdf", "labels": ["Certora", "Low"]}, {"title": "Loss of fees, overcharge of fees due to rounding", "body": "Rules Broken: property #13 -  lastVaultBalance_OK Description: The storage variable  _s.lastVaultBalance  marks the portion of reserves for which the vault has already charged fees. In every call to  accrueYield() , the vault charges fees only from the new yield accrued since the last fee charge -  ATOKEN.balanceOf(Vault) - _s.lastVaultBalance . Thus, it is expected that after every accrual, _s.lastVaultBalance  will be equal to  ATOKEN.balanceOf(Vault) . However, the system may reach a mismatch between the two values when depositing to or withdrawing from the vault due to different update mechanisms. While  _s.lastVaultBalance  is being updated with the exact  assets  amount passed to the function, aToken uses rayMath  to update the  ATOKEN.balanceOf(Vault) . While the former is exact, the latter is subject to rounding and may differ from the passed  assets  amount. At the end of a  deposit()  or withdraw() , the vault may reach a state where _s.lastVaultBalance == ATOKEN.balanceOf(Vault) \u00b1 1 . Since this scenario may repeat itself, the vault generally may reach a state where  _s.lastVaultBalance == ATOKEN.balanceOf(Vault) \u00b1 k , where  k  is the number of such occurred deposits or withdraws. For the  +  case, the next time the Vault accrues yield, it will lose its fee from that  k  unaccounted tokens. For the  -  case, the next time that the Vault accrues yield, it will gain money it does not deserve on account of the Vault's users. In some extreme cases, the system may even enter an insolvency similar to the one explained in the insolvency  bug above. Mitigation/Fix: Fixed in PR#86 merged in commit 385b397.", "html_url": "https://certora.cdn.prismic.io/certora/4473e951-37ff-410f-b76d-345a2ee342d0_Aave-Vault-Formal-Verification.pdf", "labels": ["Certora", "Low"]}, {"title": "Frontrun - avoiding fee charges for gifts given to the protocol", "body": "Description: The vault intends to charge fees for any yield generated in the Aave pool. This is done by tracking the vault's balance internally at each state-changing method ( lastVaultBalance ) and ensuring that only changes in aTokens' value are accounted for when calculating the fee. However, due to the \"same block\" optimization that is mentioned in the insolvency issue above, a user can front-run a withdrawFees()  call and ensure that the vault does not charge fees for any gifts given to the protocol at a block where accrual has already occurred. \fIssue: Frontrun - avoiding fee charges for gifts given to the protocol Detailed Attack: 1. A user sees that the vault owner wants to withdraw fees. 2. The user invokes an action that will trigger  accrueYield()  and update the state to  lastUpdated = now . This can be done cheaply by depositing dust in the vault. At this point, there are a few ways that the user can gift money to the protocol, which will not be counted when calculating fees: 3.a. The user can transfer aTokens directly to the vault. 3.b. The user can redeem shares and send the gains directly to the vault. 3.c. The user can gift money directly to the pool by using the  backUnbacked  functionality, for example, and increase the liquidity index. 4. When  withdrawFees()  is invoked, getClaimableFees()  returns the stored  accumulatedFees  instead of recalculating the fee and taking the new yield generated in this block into account. Mitigation/Fix: Fixed in PR#82 merged in commit 385b397.", "html_url": "https://certora.cdn.prismic.io/certora/4473e951-37ff-410f-b76d-345a2ee342d0_Aave-Vault-Formal-Verification.pdf", "labels": ["Certora", "informational"]}, {"title": "Rules Broken:", "body": "Description: Non-compliance of the preview methods with the EIP4626 standard properties: #2 -  previewDeposit_has_NO_threshold  #4 - previewMint_has_NO_threshold  #6 - previewWithdraw_has_NO_threshold  #8 - previewRedeem_has_NO_threshold As per EIP4626, all the preview functions must not take into account any limitation of the system, like those returned by the  max() methods. In the contract, the preview methods do take into account system limitations. For example let  m  be the value returned by maxDeposit() . Then value returned from  previewDeposit(m1)  is identical to the value returned from  previewDeposit(m)  for every m1>m . As per EIP4626, all the preview functions may revert due to other Mitigation/Fix: conditions that would also cause primary functions to revert. Relying on Aave is acceptable, given that primary functions are impacted by its limitations (e.g. users cannot withdraw if there is no available liquidity in the Aave Pool).", "html_url": "https://certora.cdn.prismic.io/certora/4473e951-37ff-410f-b76d-345a2ee342d0_Aave-Vault-Formal-Verification.pdf", "labels": ["Certora", "Informational"]}, {"title": "DoS - incorrect handling when depositing underlying tokens", "body": "Description: When depositing an amount of underlying token that isn't a whole multiplication of the liquidity index to the vault, the contract may reach a dirty state that keeps reverting undesirably on every method that calls  accrueYield() . This occurs due to an inaccurate increment of  lastVaultBalance  that doesn't correspond to the actual increment or decrement in the vault's assets following \fIssue: DoS - incorrect handling when depositing underlying tokens deposit()  or  mint() . In such cases,  lastVaultBalance  ends up being greater than  ATOKEN.balanceof(vault) , which causes a revert when the new yield is being calculated. The state can be corrected by increasing the existing assets relative to lastVaultBalance . This may occur naturally due to the fact that the token accrue yield from the pool, but it can also be initiated by sending a gift to the contract. initial state: Consider a valid state where  index = 10 Ray, totalSupply = 100 Ray, totalAsset = 101Ray . Action 1: A user deposits a sum of 91 underlying tokens through the contract. The first action invoked is accrual, which updates the state to lastVaultBalance = _AToken.balanceOf(vault), lastUpdated = now . Action 2: The amount of shares that the assets are worth is calculated through  previewDeposit() . The simulation returns shares = (assets * totalSupply)/totalAssets ~= 90.099 , but after rounding down, the result will be  shares = 90 . Action 3: From the amount of shares, the number of assets supplied to the pool is recalculated with  _convertToAssets  rounding up. The result of this calculation will be  assets = (shares * totalAssets)/totalSupply = 90.9 = 91 . Action 4: The contract sends the 91 assets to the pool, which will mint 9 aToken with a worth of 90 underlying tokens. However,  lastVaultBalance  will be incremented by the full 91 assets that were passed to the function. Post State: At this point, the state of the contract is  index = 10 Ray, totalSupply = 190 Ray, totalAsset = 101 + 90 = 191Ray, lastVaultBalance = 101 + 91 = 192  In this state, any call to  accrueYield()  will perform the calculation  newYield = newVaultBalance - _s.lastVaultBalance which will immediately revert due to underflow. Example: Mitigation/Fix: Fixed in PR#70, merged in commit 32edfe6.", "html_url": "https://certora.cdn.prismic.io/certora/4473e951-37ff-410f-b76d-345a2ee342d0_Aave-Vault-Formal-Verification.pdf", "labels": ["Certora", "Medium"]}, {"title": "Description:", "body": "Grifting - an attacker can prevent other users from withdrawing for a duration of a block An attacker can prevent other users from withdrawing part of their funds, or otherwise force revert by gifting assets to the vault. A gift can be given by directly transferring tokens to the vault at a block where  accrueYield()  is called. By doing this, the malicious player takes  lastVaultBalance  out of sync with _AToken.balanceof(vault) . At this stage, the share-to-asset ratio \fIssue: Grifting - an attacker can prevent other users from withdrawing for a duration of a block used to determine the amount of assets a user deserves for redeeming their shares is using  _AToken.balanceof(vault) . However, upon  redeem() , the withdrawn amount is deducted from lastVaultBalance . This mismatch in balance values may lead to reverting cases when the victim tries to withdraw an amount greater than the recorded  lastVaultBalance . The amount of money that the attacker needs to gift the system in order to execute the attack successfully is determined by the following formula (it does not take rounding into account):  giftAmount > totalAsset(t0) * [1]  where [(totalShares(t0)/BobSharesToRedeem) - 1] totalAssets(t0)  is the  _AToken.balanceOf(vault)  before the gift,  totalShares(t0)  is the amount of shares in the vault before the gift,  BobSharesToRedeem  is the amount of shares the victim desires to redeem, and  giftAmount  is the amount of assets needed to be gifted to the system by the attacker. Simply put, the gift is proportional to the total amount of reserves in the vault prior to the gift. A simple assignment shows that even for a victim that holds a significant share of the pool which is 50%, the amount needing to be gifted is greater than the total reserves that the pool backs up. Note: This is only valid for the same block the gift was transferred. In the next accrual,  lastVaultBalance  is synced, and the user can withdraw their funds. initial state: Consider the valid state  totalAssets = 200, totalShares = 200 , where the entire 200 shares belong to a victim. Step 1: An honest user deposits 1 asset, which grants them 1 share. This brings the state of the contract to  totalAssets = 201, totalShares = 201, lastVaultBalance = 201, lastUpdated = now Step 2: The attacker gifts 3 assets to the vault and takes lastVaultBalance  out of sync with the _AToken.balanceOf(vault) . This brings the state of the contract to totalAssets = 204, totalShares = 201, lastVaultBalance = 201 . Post State: If the victim tries to redeem all their shares, the share-to-asset ratio will evaluate their 200 shares as  200 * 204/201 = 202  assets. When the code gets to the point where it updates lastVaultBalance , the function will revert due to underflow: lastVaultBalance = 201 - 202 . Example: Mitigation/Fix: Fixed in PR#82 merged in commit 385b397. The following 3 issues are derived from the same sequence of initial states and transactions and are a result of the same vulnerability. \fSeverity: Medium Issue: Insolvency - lack of reserves to backup the vault's shares Rules Broken: property #14 -  getClaimableFees_LEQ_ATokenBalance  property #15 -  positiveSupply_imply_positiveAssets Given some initial state, an attacker can cause the protocol to deserve fees amounting to a larger value than its reserves. This means a state of insolvency. The coordinated transaction sequence described below relies on two things: 1. An optimization in the code that omits computation of the fees owed by protocol if such computation was already performed in the same block. 2. Although the vault uses the  _AToken.balanceOf[vault]  to track its reserves, it allows users to bypass the  lastVaultBalance  update (accrual) when gifting money to the protocol. The amount of money that the attacker needs to gift the system in order to execute the attack successfully is determined by the following formula (it does not take rounding into account):  (totalAssets(t0) - Description: [2]  where withdrawnAmount)/feePercentage <= giftAmount totalAssets(t0)  is the  _AToken.balanceOf(vault)  before the gift,  withdrawnAmount  is the amount of assets being withdrawn by the attacker to cause the insolvency,  feePercentage  is the is the fee percentage charges by the vault, and  giftAmount  is the amount of assets needed to be gifted to the system by the attacker. During this griefing attack, the attacker loses a sum of:  giftAmount * (1 - withdrawn_amount/totalAssets(t0)) . We can immediately see that the max loss to the attacker is the gift amount. [2] Example: The following scenario assumes that a 5% fee is deducted by the vault. initial state: Consider the valid state  _accumulatedFees = 700, _AToken.balanceOf(vault) = 1700, lastVaultBalance = 1700, totalSupply = 1000 . From the definition,  totalAssets() = 1700 - 700 = 1000 , the ratio of share-to-asset is  1:1 . Step 1: An attacker is gifting the vault  620  assets by a call to withdrawATokens()  with the vault as the recipient. This updates the state of the contract to be:  _accumulatedFees = 700, _AToken.balanceOf(vault) = 1700, lastVaultBalance = 1080, totalSupply = 380 ,  lastUpdated = now , which implies the share- to-assets ratio is now around  1:2.63 . Step 2: On the same block, the attacker, which holds an adequate amount of shares in the pool, withdraws  970  assets by redeeming  ~369  shares. Due to optimization on the update block,  totalAssets()  is using a stored, outdated amount of fees deserved by the protocol instead of computing the value using  lastVaultBalance . The recorded value \fIssue: Insolvency - lack of reserves to backup the vault's shares is  totalSupply = 1700 - 700 = 1000 . Post State: Following step 2, the state of the contract is now:  _accumulatedFees = 700, _AToken.balanceOf(vault) = 730, lastVaultBalance = 110, totalSupply = ~11 . In the next block ( time > now ), the function getClaimableFees()  returns  700 + 0.05*(730 - 110) = 731 , while  _AToken.balanceOf(vault) = 730 . A call to  withdrawFees() with the entire reserve sum (or less) will cause insolvency, meaning shareholders have no assets to backup their shares. Note: this broken state is \"eternal\". Even without withdrawing fees, once _accrueYield()  is being performed, the state variable _accumulatedFees  will be updated to the \"bad\" value, 731. Mitigation/Fix: Fixed in PR#82 merged in commit 385b397.", "html_url": "https://certora.cdn.prismic.io/certora/4473e951-37ff-410f-b76d-345a2ee342d0_Aave-Vault-Formal-Verification.pdf", "labels": ["Certora", "Medium"]}, {"title": "Complete DoS of the contract due to revert of  totalAssets()", "body": "Rules Broken: property #14 -  getClaimableFees_LEQ_ATokenBalance Description: Following the scenario described in the issue above, the final state constitutes  getClaimableFees() > _AToken.balanceOf(vault) , which, as we explained, will remain eternal once an accrual is being performed at one of the next blocks. This state results in a revert of any call to  totalAssets()  due to the underflow of the definition - ATOKEN.balanceOf(vault) - getClaimableFees() . This practically DoS the system completely since every function calls totalAssets()  through  convertToAssets  or  convertToShares . Mitigation/Fix: Fixed in PR#82 merged in commit 385b397.", "html_url": "https://certora.cdn.prismic.io/certora/4473e951-37ff-410f-b76d-345a2ee342d0_Aave-Vault-Formal-Verification.pdf", "labels": ["Certora", "Medium"]}, {"title": "Misinformation -  previewRedeem()  returns a larger amount of", "body": "assets than an immediate  redeem() Rules Broken: property #14 -  getClaimableFees_LEQ_ATokenBalance Description: Following the scenario described in the previous issue, if instead of performing Step 2, an honest user calls  previewRedeem()  at the same block, the returned value of the preview will be calculated according to the broken ratio ( 1:2.63  shown in the example). If the user calls  redeem()  at the next block, the amount of assets transferred to them will be smaller than expected, according to a lower ratio ( 1:2.55  shown in the example). This is because upon \fIssue: Misinformation -  previewRedeem()  returns a larger amount of assets than an immediate  redeem() redemption,  _accrueYield()  is called, which causes a reduction in totalAssets()  by  feePercentage * (ATOKEN.balanceOf(vault) - lastVaultBalance) . Mitigation/Fix: Fixed in PR#82 merged in commit 385b397.", "html_url": "https://certora.cdn.prismic.io/certora/4473e951-37ff-410f-b76d-345a2ee342d0_Aave-Vault-Formal-Verification.pdf", "labels": ["Certora", "Low"]}, {"title": "Loss of fees, overcharge of fees due to rounding", "body": "Rules Broken: property #13 -  lastVaultBalance_OK Description: The storage variable  _s.lastVaultBalance  marks the portion of reserves for which the vault has already charged fees. In every call to  accrueYield() , the vault charges fees only from the new yield accrued since the last fee charge -  ATOKEN.balanceOf(Vault) - _s.lastVaultBalance . Thus, it is expected that after every accrual, _s.lastVaultBalance  will be equal to  ATOKEN.balanceOf(Vault) . However, the system may reach a mismatch between the two values when depositing to or withdrawing from the vault due to different update mechanisms. While  _s.lastVaultBalance  is being updated with the exact  assets  amount passed to the function, aToken uses rayMath  to update the  ATOKEN.balanceOf(Vault) . While the former is exact, the latter is subject to rounding and may differ from the passed  assets  amount. At the end of a  deposit()  or withdraw() , the vault may reach a state where _s.lastVaultBalance == ATOKEN.balanceOf(Vault) \u00b1 1 . Since this scenario may repeat itself, the vault generally may reach a state where  _s.lastVaultBalance == ATOKEN.balanceOf(Vault) \u00b1 k , where  k  is the number of such occurred deposits or withdraws. For the  +  case, the next time the Vault accrues yield, it will lose its fee from that  k  unaccounted tokens. For the  -  case, the next time that the Vault accrues yield, it will gain money it does not deserve on account of the Vault's users. In some extreme cases, the system may even enter an insolvency similar to the one explained in the insolvency  bug above. Mitigation/Fix: Fixed in PR#86 merged in commit 385b397.", "html_url": "https://certora.cdn.prismic.io/certora/4473e951-37ff-410f-b76d-345a2ee342d0_Aave-Vault-Formal-Verification.pdf", "labels": ["Certora", "Low"]}, {"title": "Frontrun - avoiding fee charges for gifts given to the protocol", "body": "Description: The vault intends to charge fees for any yield generated in the Aave pool. This is done by tracking the vault's balance internally at each state-changing method ( lastVaultBalance ) and ensuring that only changes in aTokens' value are accounted for when calculating the fee. However, due to the \"same block\" optimization that is mentioned in the insolvency issue above, a user can front-run a withdrawFees()  call and ensure that the vault does not charge fees for any gifts given to the protocol at a block where accrual has already occurred. \fIssue: Frontrun - avoiding fee charges for gifts given to the protocol Detailed Attack: 1. A user sees that the vault owner wants to withdraw fees. 2. The user invokes an action that will trigger  accrueYield()  and update the state to  lastUpdated = now . This can be done cheaply by depositing dust in the vault. At this point, there are a few ways that the user can gift money to the protocol, which will not be counted when calculating fees: 3.a. The user can transfer aTokens directly to the vault. 3.b. The user can redeem shares and send the gains directly to the vault. 3.c. The user can gift money directly to the pool by using the  backUnbacked  functionality, for example, and increase the liquidity index. 4. When  withdrawFees()  is invoked, getClaimableFees()  returns the stored  accumulatedFees  instead of recalculating the fee and taking the new yield generated in this block into account. Mitigation/Fix: Fixed in PR#82 merged in commit 385b397.", "html_url": "https://certora.cdn.prismic.io/certora/4473e951-37ff-410f-b76d-345a2ee342d0_Aave-Vault-Formal-Verification.pdf", "labels": ["Certora", "informational"]}, {"title": "Rules Broken:", "body": "Description: Non-compliance of the preview methods with the EIP4626 standard properties: #2 -  previewDeposit_has_NO_threshold  #4 - previewMint_has_NO_threshold  #6 - previewWithdraw_has_NO_threshold  #8 - previewRedeem_has_NO_threshold As per EIP4626, all the preview functions must not take into account any limitation of the system, like those returned by the  max() methods. In the contract, the preview methods do take into account system limitations. For example let  m  be the value returned by maxDeposit() . Then value returned from  previewDeposit(m1)  is identical to the value returned from  previewDeposit(m)  for every m1>m . As per EIP4626, all the preview functions may revert due to other Mitigation/Fix: conditions that would also cause primary functions to revert. Relying on Aave is acceptable, given that primary functions are impacted by its limitations (e.g. users cannot withdraw if there is no available liquidity in the Aave Pool).", "html_url": "https://certora.cdn.prismic.io/certora/4473e951-37ff-410f-b76d-345a2ee342d0_Aave-Vault-Formal-Verification.pdf", "labels": ["Certora", "Informational"]}, {"title": "Non-compliance of  maxFlashLoan  in the FlashMinter facilitator to", "body": "the EIP3156 standard Description: EIP3156 states that the function  maxFlashLoan  must return the maximum loan possible for the token, and return 0 instead of reverting if the token is not currently supported. The GhoFlashMinter  implmentation, however, may revert if bucketLevel > bucketCapacity . This can happen if the bucket's capacity gets reduced below the bucket's level. Mitigation/Fix: Fixed on commit 038442d.", "html_url": "https://certora.cdn.prismic.io/certora/a227c693-7aa3-471f-a7b2-7148c06a2110_Aave_Gho_Formal_Verification_Report.pdf", "labels": ["Certora", "Low"]}, {"title": "Accumulated interest can be manipulated by the user", "body": "Description: Concrete Example: Calling  rebalanceUserDiscountPerecent  calculates the accumulated interest since the last operation made by the user. As part of this operation, the scaled discount given to the user is burned. This call decreases the total interest accumulated for this debt compared to the case of the exact same position taken without calling rebalance. Consider a user with  scaledBalance = 100 , 50% discount rate and 0 accumulated interest at time  t0 . The global index is 1, 2, and 4 at times  t0 ,  t1 , and  t2  respectively. In the first scenario the user calls  rebalanceUserDiscountPercent  at  t1  which updates the scaled balance to 75 and the accumulated interest to 50. At  t2  the \fIssue: Accumulated interest can be manipulated by the user user does the same call which updates the accumulated interest to 125. If instead, the user does only a single call to rebalanceUserDiscountPerecent  at  t2 , the accumulated interest balance would reach a total of 150. Mitigation/Fix: The use of  rebalanceUserDiscountPercent  or any other function that accumulates the user's interest, results in insignificant benefits for the end user given that the values of the expected configuration of interest and discount rates are low.", "html_url": "https://certora.cdn.prismic.io/certora/a227c693-7aa3-471f-a7b2-7148c06a2110_Aave_Gho_Formal_Verification_Report.pdf", "labels": ["Certora", "Low"]}, {"title": "Using of  WadRayMath.sol  not according to guidelines", "body": "WadRayMath.sol  states that  wadMul/wadDiv  and  rayMul/rayDiv should be called with both operands should have the same format of WAD / RAY  respectively. In  ghoVariableDebtToken.sol  there are multiple occasions where  rayMul  and  rayDiv  are called with the first operand being some token balance (both scaled and not- scaled) which is formatted as  WAD , and the second operand being the index which is formatted as  RAY . The  GhoVariableDebtToken  contains code that belongs to the standard Aave  VariableDebtToken  implementation. Although it is not natural to use  WadRayMath  functions with operands that aren't in the same format, these calculations provides a result with correct format. Description: Mitigation/Fix:", "html_url": "https://certora.cdn.prismic.io/certora/a227c693-7aa3-471f-a7b2-7148c06a2110_Aave_Gho_Formal_Verification_Report.pdf", "labels": ["Certora", "Informational"]}, {"title": "Non-compliance of  maxFlashLoan  in the FlashMinter facilitator to", "body": "the EIP3156 standard Description: EIP3156 states that the function  maxFlashLoan  must return the maximum loan possible for the token, and return 0 instead of reverting if the token is not currently supported. The GhoFlashMinter  implmentation, however, may revert if bucketLevel > bucketCapacity . This can happen if the bucket's capacity gets reduced below the bucket's level. Mitigation/Fix: Fixed on commit 038442d.", "html_url": "https://certora.cdn.prismic.io/certora/a227c693-7aa3-471f-a7b2-7148c06a2110_Aave_Gho_Formal_Verification_Report.pdf", "labels": ["Certora", "Low"]}, {"title": "Accumulated interest can be manipulated by the user", "body": "Description: Concrete Example: Calling  rebalanceUserDiscountPerecent  calculates the accumulated interest since the last operation made by the user. As part of this operation, the scaled discount given to the user is burned. This call decreases the total interest accumulated for this debt compared to the case of the exact same position taken without calling rebalance. Consider a user with  scaledBalance = 100 , 50% discount rate and 0 accumulated interest at time  t0 . The global index is 1, 2, and 4 at times  t0 ,  t1 , and  t2  respectively. In the first scenario the user calls  rebalanceUserDiscountPercent  at  t1  which updates the scaled balance to 75 and the accumulated interest to 50. At  t2  the \fIssue: Accumulated interest can be manipulated by the user user does the same call which updates the accumulated interest to 125. If instead, the user does only a single call to rebalanceUserDiscountPerecent  at  t2 , the accumulated interest balance would reach a total of 150. Mitigation/Fix: The use of  rebalanceUserDiscountPercent  or any other function that accumulates the user's interest, results in insignificant benefits for the end user given that the values of the expected configuration of interest and discount rates are low.", "html_url": "https://certora.cdn.prismic.io/certora/a227c693-7aa3-471f-a7b2-7148c06a2110_Aave_Gho_Formal_Verification_Report.pdf", "labels": ["Certora", "Low"]}, {"title": "Using of  WadRayMath.sol  not according to guidelines", "body": "WadRayMath.sol  states that  wadMul/wadDiv  and  rayMul/rayDiv should be called with both operands should have the same format of WAD / RAY  respectively. In  ghoVariableDebtToken.sol  there are multiple occasions where  rayMul  and  rayDiv  are called with the first operand being some token balance (both scaled and not- scaled) which is formatted as  WAD , and the second operand being the index which is formatted as  RAY . The  GhoVariableDebtToken  contains code that belongs to the standard Aave  VariableDebtToken  implementation. Although it is not natural to use  WadRayMath  functions with operands that aren't in the same format, these calculations provides a result with correct format. Description: Mitigation/Fix:", "html_url": "https://certora.cdn.prismic.io/certora/a227c693-7aa3-471f-a7b2-7148c06a2110_Aave_Gho_Formal_Verification_Report.pdf", "labels": ["Certora", "Informational"]}]