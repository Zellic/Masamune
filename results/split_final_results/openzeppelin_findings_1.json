[{"title": "Potential Irreversibility in venusVAIVaultRate Adjustments", "body": "If the venusVAIVaultRate is mistakenly changed to a very high number in _setVenusVAIVaultRate(), releaseToVault() will overflow.  If there is an attempt to correct the venusVAIVaultRate, releaseToVault will revert due to overflow, impeding any further change to the venusVAIVaultRate.  Consider adding input checks to prevent overflows.  Update: Acknowledged, not resolved. The Venus team stated:  venusVAIVaultRate is set by the governance so the chances of setting it wrong are negligible. For now, we will just acknowledge the issue and no actions are needed from us.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#potential-irreversibility-in-venusvaivaultrate-adjustments", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Function Signature in _setActionsPaused", "body": "The ensureAllowed check in the _setActionsPaused function verifies whether a certain user is allowed to call the function by checking the msg.sender and function signature in the AccessControlManager.  Actions is an enum, and in Solidity  the smallest uint type that is large enough to hold all the values. Since  Actions holds 9 values, it will be mapped to  The correct function signature for the _setActionsPaused function should be 0x2b5d790c.  In this case, since the canonical representation is used instead of the 4-byte signature when setting and checking the signature, the impact is relatively limited.  Update: Resolved in pull request #312 at commit cfaa69a.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#incorrect-function-signature-in-_setactionspaused", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Although many functions in the codebase are well-documented and the code is generally self-explanatory, the codebase could benefit from more complete NatSpec comments for all public and external functions. For instance:  getAssetsIn in MarketFacet.sol  _setLiquidatorContract in SetterFacet.sol  _setVAIMintRate in SetterFacet.sol  _setTreasuryData in SetterFacet.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well.  Update: Resolved in pull request #312 at commit 3909ff7.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Implementation of EIP-2535 Does Not Fully Match the Specification", "body": "The Diamond contract implements the EIP-2535 standard, often referred to as the diamond proxy pattern.  The diamond proxy pattern is a proxy design where the functions are separated into multiple smaller 'facet' contracts. By breaking down the implementation contract into multiple facets, it is possible to build larger and more complex applications without exceeding the contract size limit.  However, there are some mismatches between the current implementation and the official specification worth highlighting:  The diamondCut(IDiamondCut.FacetCut[] memory _diamondCut) function should be diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes calldata _calldata).  The getFacetFunctionSelectors function should be facetFunctionSelectors.  The getAllFacetAddresses function should be facetAddresses.  The Diamond contract does not implement the facets function.  The Diamond contract does not implement the facetAddress function.  The DiamondCut(IDiamondCut.FacetCut[] _diamondCut) event should be DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);.  While the deviations from the specification may not be problematic for this particular use case, they may potentially cause errors in clients interacting with the Diamond contract who expect a fully-compliant implementation of EIP-2535. For example, tools such as Louper will not work as the function signatures of the functions used to inspect the Diamond do not match the ones from the standard.  Therefore, it is advisable to either modify the contract to make it fully compliant or clearly document the expected differences between the Diamond contract and the EIP.  Update: Resolved in pull request #312 at commit 7417d8f.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#implementation-of-eip-2535-does-not-fully-match-the-specification", "labels": ["OpenZeppelin"]}, {"title": "Possible Function Selector Clashing", "body": "Clashing can happen among functions with different names. Every function that is part of a contracts public ABI is identified, at the bytecode level, by a 4-byte identifier. This identifier depends on the function's signature, but since it is only 4 bytes, there is a possibility that two different functions with different function signatures may end up having the same identifier. The Solidity compiler tracks when this happens within the same contract, but not when the collision happens across different ones, such as between a proxy and its logic contract.  Unitroller contract  delegatecalls the  Diamond contract which  delegatecalls the facets. The  The presence of these functions creates the possibility of a function selector clash. This can happen in the following scenarios:  Functions in Unitroller and hardcoded functions in Diamond with the same function selector  Functions in Unitroller and a facet with the same function selector  Hardcoded functions in Diamond and a facet with the same function selector  Note that functions between different facets cannot clash as the diamondCut function prevents adding new functions whose signature is already registered in the Diamond.  Consider checking that no function selector collision is present when adding new functions to the Diamond (using diamondCut) or upgrading the Diamond's implementation. Moving the hardcoded functions in Diamond.sol to a facet will also reduce the chances of a collision going unnoticed.  Update: Acknowledged, not resolved. The Venus team stated:  We have just included the diamondCut functionality in the Diamond.sol file. For now, we will just acknowledge the issue, and no actions are needed from us.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#possible-function-selector-clashing", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Access Allowance to the Comptroller Implementation", "body": "_setVenusSpeeds and  _grantXVS allows  Allowing access from the comptrollerImplementation opens a potential attack path if the implementation were able to do calls to the Unitroller.  Consider disallowing access to these functions from the ComtprollerImplementation.  Update: Resolved in pull request #312 at commit 0aa7e17.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#unnecessary-access-allowance-to-the-comptroller-implementation", "labels": ["OpenZeppelin"]}, {"title": "Non-Explicit Imports", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are being used. Some instances are (but not limited to):  Line 3 of ComptrollerStorage.sol  Line 4 of ComptrollerStorage.sol  Line 5 of ComptrollerStorage.sol  Line 7 of FacetBase.sol  Line 8 of FacetBase.sol  Line 3 of MarketFacet.sol  Line 4 of MarketFacet.sol  Line 3 of PolicyFacet.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Resolved in pull request #312 at commit 6d0a33c.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#non-explicit-imports", "labels": ["OpenZeppelin"]}, {"title": "Not Inheriting From Available Interfaces", "body": "The Diamond has multiple facets, and each facet has its own interface. However, the facet contracts are not explicitly inheriting their interfaces. This can lead to issues if an interface or corresponding contract is modified in a way that would make them incompatible.  Additionally, functions are added to the Diamond by calculating the function signatures from the interfaces instead of the contracts. Therefore it is important that the facet contracts explicitly inherit their respective interfaces to ensure the correct functions are added to the Diamond. For instance:  Diamond does not inherit from IDiamondCut  MarketFacet does not inherit from IMarketFacet  PolicyFacet does not inherit from IPolicyFacet  RewardFacet does not inherit from IRewardFacet  SetterFacet does not inherit from ISetterFacet  To clarify intent, increase the readability of the codebase, and allow the compiler to perform more robust error-checking, consider updating the contracts' inheritance declarations to explicitly inherit from their corresponding interfaces.  Update: Resolved in pull request #312 at commit 50761a0.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#not-inheriting-from-available-interfaces", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Inheritances", "body": "The codebase contains two instances of unnecessary inheritances:  MarketFacet inherits ExponentialNoError. However, FacetBase already inherits ExponentialNoError. Consider removing the explicit inheritance of ExponentialNoError in MarketFacet.  SetterFacet inherits ExponentialNoError. However, FacetBase already inherits ExponentialNoError. Consider removing the explicit inheritance of ExponentialNoError in SetterFacet.  Inheriting a contract multiple times can be confusing and may lead to inconsistencies if the inherited contract is consuming storage slots. While the current version of ExponentialNoError is not consuming any storage slots, consider removing the duplicate inheritance to improve readability.  Update: Resolved in pull request #312 at commit 4c72e43.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#unnecessary-inheritances", "labels": ["OpenZeppelin"]}, {"title": "Lack of SPDX License Identifiers", "body": "Throughout the codebase, there are files that lack SPDX license identifiers. For instance:  ComptrollerStorage.sol  Diamond.sol  FacetBase.sol  MarketFacet.sol  PolicyFacet.sol  RewardFacet.sol  SetterFacet.sol  XVSRewardsHelper.sol  IDiamondCut.sol  IMarketFacet.sol  IPolicyFacet.sol  IRewardFacet.sol  ISetterFacet.sol  To avoid legal issues regarding copyright and follow best practices, consider adding SPDX license identifiers to files as suggested by the Solidity documentation.  Update: Resolved in pull request #312 at commit 0387b34.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#lack-of-spdx-license-identifiers", "labels": ["OpenZeppelin"]}, {"title": "Lack of Indexed Event Parameters", "body": "Throughout the codebase, several events do not have their parameters indexed. For instance:  Line 12 and line 15 of FacetBase.sol  Line 11, line 14, and line 17 of MarketFacet.sol  Line 11 of RewardFacet.sol  All events in SetterFacet.sol  Consider indexing event parameters to improve the ability of off-chain services to search and filter for specific events.  Update: Resolved in pull request #312 at commit 5533343.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Using int/uint Instead of int256/uint256", "body": "In the following contracts, there are instances where int/uint are used instead of int256/uint256:  ComptrollerStorage.sol  FacetBase.sol  MarketFacet.sol  PolicyFacet.sol  SetterFacet.sol  IPolicyFacet.sol  ISetterFacet.sol  In favor of explicitness, consider replacing all instances of int/uint with int256/uint256.  Update: Resolved in pull request #312 at commit 5533343.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#using-int/uint-instead-of-int256/uint256", "labels": ["OpenZeppelin"]}, {"title": "Local Variable Shares Name With Storage Variable", "body": "venusAccrued is declared as a local variable, but there is a storage variable with the same name.  Consider using different names to improve the codebase's readability.  Update: Resolved in pull request #312 at commit 4596c2b.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#local-variable-shares-name-with-storage-variable", "labels": ["OpenZeppelin"]}, {"title": "Constants Not Using UPPER_CASE Format", "body": "In FacetBase.sol, there are several constants that are not using UPPER_CASE format. For instance:  The venusInitialIndex constant declared on line 20  The closeFactorMinMantissa constant declared on line 22  The closeFactorMaxMantissa constant declared on line 24  The collateralFactorMaxMantissa constant declared on line 26  According to the Solidity Style Guide, constants should be named with all capital letters with underscores separating words. For better readability, consider following this convention.  Update: Acknowledged, not resolved. The Venus team stated:  As we have dependencies on external contracts, if we change the convention the public variable venusInitialIndex and its getter will be changed. So for now we can't do the suggested change and will acknowledge the issue.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#constants-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Imports", "body": "Throughout the codebase, there are multiple instances of unnecessary imports that are either unused or already imported by other files.  Import ComptrollerStorage of Diamond.sol which is already imported by Unitroller  Import ErrorReporter of FacetBase.sol which is already imported by VToken  Import ErrorReporter of PolicyFacet.sol which is already imported by VToken  Import ErrorReporter of SetterFacet.sol which is already imported by FacetBase  Import PriceOracle of IMarketFacet.sol  Import PriceOracle of IRewardFacet.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #312 at commit 6d0a33c.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#unnecessary-imports", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Coding Style", "body": "There are general inconsistencies and deviations from the Solidity Style Guide throughout the codebase. Below is a non-exhaustive list of inconsistent coding styles.  While most external function names do not contain an underscore, some begin with one underscore. For example:  _supportMarket  _setVenusSpeeds  _grantXVS  Some functions use named return variables, while others do not. For example:  getFacetFunctionSelectors and getAllFacetAddresses declare named variables for the returned values.  All the other functions in Diamond.sol do not declare a named variable for the return values.  Some facets are importing the ComptrollerErrorReporter contract while other facets are inheriting the ComptrollerErrorReporter contract. For example:  FacetBase is importing the ComptrollerErrorReporter contract and therefore uses ComptrollerErrorReporter.Error.  MarketFacet is inheriting the ComptrollerErrorReporter contract and therefore uses Error.  Consider enforcing a standard coding style, such as the one provided by the Solidity Style Guide, to improve the project's overall readability and consistency. Also, consider using a linter such as Solhint to define a style and analyze the codebase for style deviations.  Update: Partially resolved in pull request #312 at commit 4c72e43. The Venus team stated:  We have not removed _ from external methods as they are setters for the state variables and governance-controlled.", "html_url": "https://blog.openzeppelin.com/venus-protocol-diamond-comptroller-audit#inconsistent-coding-style", "labels": ["OpenZeppelin"]}, {"title": "Wrong State Update in distributeRewards", "body": "There are two types of allocations in the TruStake protocol: strict and loose. In loose allocations, there is no guarantee that the rewards will be distributed to the recipients and the distributeRewards function can only be called by the allocator(distributor). If the allocation is strict, the rewards from the staked MATIC are guaranteed and anyone should be able to call the distributeRewards function to distribute the rewards to the recipient.  When the distributeRewards function is called, it calls the _distributeRewardsUpdateTotal function which distributes the reward and updates the state. The _distributeRewardsUpdateTotal updates the totalAllocated of the msg.sender instead of the distributor. Since anyone can call the distributeRewards function, this leads to wrong state updation.  Update: Resolved in pull request #1 at commit 091b908.  High Severity", "html_url": "https://blog.openzeppelin.com/trufin-audit#wrong-state-update-in-distributerewards", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Calculation of Total Amount Staked", "body": "The TruStakeMATICv2 contract implements the totalStaked function to calculate the total amount of MATIC staked by the vault on the validator. The function incorrectly calculates this, as it divides the amount of shares held by the vault by the exchangeRate, where it should multiply by it.  As the current exchangeRate is 1, the result of the function is still correct. However, if the exchangeRate value changes, the result will be incorrect.  In contrast, the getTotalStake(address user) function from the ValidatorShare contract performs the same operation but multiplies the amount of shares held by the user address passed as a parameter. Additionally, this function takes into account the exchange rate decimals of the validator, making it unnecessary to hardcode it.  Consider using getTotalStake function of the ValidatorShare contract to get the total amount of MATIC staked by the vault. Additionally, consider including additional tests to validate the calculated amount.  Update: Resolved in pull request #1 at commit 89c54da.  Low Severity", "html_url": "https://blog.openzeppelin.com/trufin-audit#incorrect-calculation-of-total-amount-staked", "labels": ["OpenZeppelin"]}, {"title": "Lack of Event Emission After Sensitive Actions", "body": "The following functions do not emit relevant events after executing sensitive actions.  MasterWhiteList contract:  When changing the KYC Passport address  When changing the KYC Reader address  When changing the KYC Registry address  When adding or removing assets from the whitelist  When adding or removing countries from the blacklist  When countries are added to the blacklistedCountries mapping  When a user is removed from the blacklist by being added to the whitelist via addUserToWhitelist function  When a user is removed from the blacklist by being added to the whitelist via addUserToWhitelistWithProvider function  When setting the id for a market maker  Consider emitting events after sensitive changes occur to facilitate tracking and notify off-chain clients following the contracts' activity.  Update: Resolved in pull request #1 at commits 5a95710, 9ea10bf and 71cc3a4.", "html_url": "https://blog.openzeppelin.com/trufin-audit#lack-of-event-emission-after-sensitive-actions", "labels": ["OpenZeppelin"]}, {"title": "Hardcoded Values", "body": "Throughout the codebase, there are several occurrences of literal values with unexplained meanings. For example:  TruStakeMATICv2 contract:  In the totalStaked function, the amount of shares returned by the validator is multiplied by 1e29.  In the isClaimable function, the epochs needed to allow withdrawing are calculated adding 80.  In the setEpsilon function, the parameter is checked against 1e12.  MasterWhitelist contract:  Consider documenting the origin of CODE_RISK and CODE_COUNTRY.  Digits 0 to 4 are often used to represent user types.  In addUserToWhitelistUsingPassport, the passport's AML risk is compared against 5.  To improve the code's readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name.  Update: Resolved in pull request #1 at commits 4b9e4d4 and d0453ae.", "html_url": "https://blog.openzeppelin.com/trufin-audit#hardcoded-values", "labels": ["OpenZeppelin"]}, {"title": "Use of Deprecated Method", "body": "The MasterWhitelist contract uses the balanceOf function from Quadrata's QuadReader contract. According to Quadrata's documentation, this function has been deprecated.  Consider instead using getAttributes function to query for a specific attribute and validate the returned result.  Update: Acknowledged, not resolved. The TruFin team stated:  Not fixed. We have decided not to use this method for a few reasons. This method as it is works well for us and the team at Quadrata has assured us that they do not plan to remove it. Also, this method is free to use, as opposed to the alternative method getAttributes which we would have to pay for.", "html_url": "https://blog.openzeppelin.com/trufin-audit#use-of-deprecated-method", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Some of the following contracts have functions with incomplete or lacking docstrings:  MasterWhitelist.sol  TrueStakeMaticv2.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well.  Also, it is unclear from the documentation how the idMM, whitelistedVaults, whitelistedAssets and whitelistedSwapManagers mappings will integrate with the rest of the system. Consider documenting their use cases.  Update: Resolved in pull request #1 at commits 52525b0 and f7555da.", "html_url": "https://blog.openzeppelin.com/trufin-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "A Future Action Can Lead to a Vulnerability", "body": "In upgradeable contracts, every new version of the implementation contract needs to have all the state variables of the previous implementation in the same layout or else it can lead to a storage collision. Attackers can use this vulnerability to overwrite sensitive information.  55 and  58 of the  Consider keeping the same storage layout throughout all versions of the TruStakeMATICv2 contract and removing the misleading comments.  Update: Resolved in pull request #1 at commit fcd6b61.", "html_url": "https://blog.openzeppelin.com/trufin-audit#a-future-action-can-lead-to-a-vulnerability", "labels": ["OpenZeppelin"]}, {"title": "Removing Market Makers From Whitelist Can Leave Inconsistent State", "body": "The idMM mapping is used to connect a market maker's address to the market maker id they belong to. Key-value pairs are set using either the addMMToWhitelistWithId or the setIdMM functions.  When removing a market maker from the whitelist, only the whitelistedMMs mapping is altered, while idMM remains set. Depending on future integrations with idMM, this could lead to a vulnerability.  When removing a market maker from the whitelist, consider also deleting the corresponding entry from the idMM mapping.  Update: Resolved in pull request #1 at commit 3498b70.", "html_url": "https://blog.openzeppelin.com/trufin-audit#removing-market-makers-from-whitelist-can-leave-inconsistent-state", "labels": ["OpenZeppelin"]}, {"title": "Some Functions Are Not ERC-4626 Compliant", "body": "Since the TruStakeMATICv2 contract is an ERC-4626 vault, it is important that it complies with all the specifications of the standard. Some functionality of the vault diverges from the standard:  The maxDeposit and maxMint functions must not revert under any circumstances.  The maxDeposit function in TruStakeMATICv2 will revert if cap < totalStaked(). The maxMint function would also revert under the same circumstance as it makes a call to the maxDeposit function.  The ERC-4626 standard stipulates that an approved EIP-20 spender is able to call the deposit, mint, withdraw and redeem functions on behalf of the asset/share owner and deposit/withdraw the assets.  In the TruStakeMATICv2 contract, only the owner of the tokens/shares can call these functions.  The standard also stipulates that the withdraw and redeem functions are the functions in which assets are transferred to the recipient. If an implementation requires pre-requesting to the vault before a withdrawal can be performed then those methods should be performed separately.  In TruStakeMATICv2 contract, the withdraw and redeem functions are used to unstake MATIC from the validator. The actual transfer happens by calling the withdrawClaim function after 80 checkpoints.  Contracts that integrate with the TruStakeMATICv2 vault may wrongly assume that the functions are EIP-4626 compliant, which can cause integration problems in the future, potentially leading to a wide range of issues for both parties, including loss of funds.  Consider making all functions ERC-4626 compliant to prevent any integration issues.  Update: Partially resolved in pull request #1 at commit 4514cfb. Functions that are not compliant with the ERC-4626 standard are documented.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/trufin-audit#some-functions-are-not-erc-4626-compliant", "labels": ["OpenZeppelin"]}, {"title": "Commented-out Code", "body": "Throughout the codebase, there are lines of code that have been commented out with //. This can lead to confusion and is detrimental to overall code readability. We have provided a non-exhaustive list of examples below:  Lines 8, 17 and 42 of MasterWhitelist.sol.  Consider removing any unneeded commented-out lines of code.  Update: Resolved in pull request #1 at commit 75d4221.", "html_url": "https://blog.openzeppelin.com/trufin-audit#commented-out-code", "labels": ["OpenZeppelin"]}, {"title": "Gas Inefficiencies", "body": "There are several places across the codebase where changes can be made to improve gas consumption. For example:  Several for loops assign the starting index to a default value, which is unnecessary. See initialize and claimList.  The getDistributors and getRecipients functions can be removed to reduce deployment gas cost, as well as code size. Consider using the default distributors() and recipients() getters instead.  In addUserToWhitelistUsingPassport, consider swapping the calls to hasPassport and isUserBlacklisted. On average, prioritizing require statements that do not involve external calls would return more gas to the user in case the method reverts.  _countryBlacklist is read-only, and can be declared as calldata to save gas.  In deallocate function, consider moving the call to sharePrice after the revert statements, as the share price is only needed if the initial checks pass.  It is recommended that if a storage variable will be read multiple times in the same function, a copy to memory should first be created since reading from storage is expensive. Here are a few of the places where this change could decrease gas cost: allocate, deallocate, distributeAll.  When performing these changes, aim to reach an optimal tradeoff between gas optimization and readability. Having a codebase that is easy to understand reduces the chance of errors in the future and improves transparency for the community.  Update: Resolved in pull request #1 at commits fbfcc80 and 62fbe7b.", "html_url": "https://blog.openzeppelin.com/trufin-audit#gas-inefficiencies", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "In the codebase, there is an import that is unused and could be removed:  Import ERC20Upgradeable of TruStakeMATICv2.sol.  Consider removing the unused import to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #1 at commit 7a93a9c.", "html_url": "https://blog.openzeppelin.com/trufin-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused Named Return Variables", "body": "Named return variables are a way to declare variables that are meant to be used within a function's body for the purpose of being returned as the function's output. They are an alternative to explicit in-line return statements.  In TruStakeMATICv2.sol, there are multiple instances of unused named return variables. For instance:  The unbondNonce return variable in the _unbond function.  The shares return variable in the _convertToShares function.  Consider either using or removing any unused named return variables.  Update: Resolved in pull request #1 at commit f861037.", "html_url": "https://blog.openzeppelin.com/trufin-audit#unused-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit Imports are Used", "body": "The use of non-explicit imports can decrease the code's clarity, and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple definitions exist within the same Solidity file.  Several global imports are being used, such as:  Line 22 of TruStakeMATICv2.sol.  Line 5 of TruStakeMATICv2Storage.sol.  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") everywhere.  Update: Resolved in pull request #1 at commit 84c7f3c.", "html_url": "https://blog.openzeppelin.com/trufin-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "State Variable Visibility Not Explicitly Declared", "body": "Within MasterWhitelist.sol there are multiple state variables that lack an explicitly declared visibility. For instance:  The state variables initialized from line 53 to line 135.  For clarity, consider always explicitly declaring the visibility of variables, even when the default visibility matches the intended visibility.  Update: Resolved in pull request #1 at commit 9bed3dc.", "html_url": "https://blog.openzeppelin.com/trufin-audit#state-variable-visibility-not-explicitly-declared", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed event parameters", "body": "Throughout the codebase, several events do not have their parameters indexed. For instance:  Line 180 of MasterWhitelist.sol  Line 10, line 77, line 172, line 174, line 176, line 178, line 180, line 182, line 184, and line 186 of ITruStakeMATICv2.sol  Consider indexing event parameters to improve the ability of off-chain services to search and filter for specific events.  Update: Resolved in pull request #1 at commits 5c9bba9 and a82a051.", "html_url": "https://blog.openzeppelin.com/trufin-audit#lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "Consider addressing the following typographical errors.  In TruStakeMATICv2Storage.sol:  On line 33 \"phi\" should be \"distPhi\".  On line 43 \"fudns\" should be \"funds\".  In MasterWhitelist.sol:  On line 166 \"the address added to blacklisted\" should be \"the address added to the blacklist\".  On line 564 \"users adds themselves\" should be \"users add themselves\".  Update: Resolved in pull request #1 at commit 2406960.", "html_url": "https://blog.openzeppelin.com/trufin-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Coding Style", "body": "Throughout the codebase, there are several places that have inconsistent code style:  TruStakeMATICv2.sol and TruStakeMATICv2Storage.sol write NatSpec using single-line comments, while other files use block comments.  removeSwapManagerFromWhitelist and removeUserFromBlacklist assign default values instead of using delete.  Consider moving the INF_TIME constant above investigation_period, for better visibility (same for PROV_CODE_MANUAL and CODE_COUNTRY).  The imports in MasterWhitelist.sol are in the order: vendor contracts, Trufin contracts. However, in TruStakeMATICv2.sol they are in the opposite order. Consider having the same order for imports to improve the codebase's readability. The imports should also be grouped with a space in between.  IMasterWhitelist is under the Polygon imports section, not Trufin.  ++i is used consistently across the codebase, except for inside claimList.  investigation_period, investigation_time, KYCPassport, KYCReader and KYCRegistry should use camelCase.  Several comments have no spacing between // and the comments' text. Here are some examples: #1, #2, #3.  Taking into consideration how much value a consistent coding style adds to the projects readability, enforcing a standard coding style with the help of linter tools such as Solhint is recommended.  Update: Resolved in pull request #1 at commits 2da2114, 1989b80 and 0b75e11.", "html_url": "https://blog.openzeppelin.com/trufin-audit#inconsistent-coding-style", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "Some events in MasterWhitelist.sol can benefit from better naming. Specifically:  UserAddedToWhitelist should be addedToWhitelist.  userRemovedFromWhitelist should be removedFromWhitelist.  As these events are used for logging data for all types of roles and not just the user role, considering renaming these events to improve the clarity of the codebase.  Update: Resolved in pull request #1 at commit 50a80ff.", "html_url": "https://blog.openzeppelin.com/trufin-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Unused Variable", "body": "MasterWhitelist uses Quadrata QuadReader to query a user's KYC verification attributes. However, it also stores a pointer to a QuadPassport contract, which is unused.  Moreover, Quadrata's documentation states that QuadPassport contains the logic for onboarding/minting Quadrata Passport, which is not the responsibility of the MasterWhitelist.  Consider removing the KYCPassport storage variable to improve the codebase's quality and reduce gas consumption.  Update: Resolved in pull request #1 at commit 8de5818.", "html_url": "https://blog.openzeppelin.com/trufin-audit#unused-variable", "labels": ["OpenZeppelin"]}, {"title": "Incorrect or Misleading Documentation", "body": "On line 204 of the MasterWhitelist contract, the Natspec comment could be better rephrased as \"_countryBlacklist is an array of the keccak256 hashes of 2 letter country codes\".  In the Types contract, the Natspec comments at the end of the file are misplaced and incomplete.  On lines 7, 50 and 144 of the MasterWhitelist contract, the Natspec comments omit mentioning the swapManager user type.  On line 97 of the MasterWhitelist contract, the Natspec comment could be better rephrased as \"Mapping of users to the kycProvider used for verification\", as it is not the kycProvider that whitelists, but a lawyer or the users themselves.  On line 36 of the TruStakeMATICv2Storage contract, the Natspec comments read \"cap on deposits into the vault\" but it is actually the cap on total amount staked with the validator, which is different because the latter also counts MATIC that was rewarded and restaked.  There were instances in this codebase where function parameters appear in a function signature to comply with the ERC-4626 but are never used within their respective function.  The address parameter of the maxDeposit function The address parameter of the maxMint function To improve clarity, consider documenting the reason for having these unused function parameters.  Consider correcting the missing or misleading documentation.  Update: Resolved in pull request #1 at commit d08ab44.", "html_url": "https://blog.openzeppelin.com/trufin-audit#incorrect-or-misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Potentially unsafe usage of unchecked math", "body": "The following instances of unchecked math were identified:  The operation on line 44 of LandBaseTokenV3.sol  The operation on line 50 of LandBaseTokenV3.sol  The operation on line 57 of LandBaseTokenV3.sol  The operation on line 84 of LandBaseTokenV3.sol  The operation on line 85 of LandBaseTokenV3.sol  The operation on line 228 of LandBaseTokenV3.sol  The operation on line 258 of LandBaseTokenV3.sol  The operation on line 279 of LandBaseTokenV3.sol  The operation on line 293 of LandBaseTokenV3.sol  The operation on line 294 of LandBaseTokenV3.sol  The operation on line 314 of LandBaseTokenV3.sol  The operation on line 317 of LandBaseTokenV3.sol  The operation on line 341 of LandBaseTokenV3.sol  The operation on line 383 of LandBaseTokenV3.sol  The operation on line 390 of LandBaseTokenV3.sol  The operation on line 391 of LandBaseTokenV3.sol  The operation on line 421 of LandBaseTokenV3.sol  The operation on line 486 of LandBaseTokenV3.sol  The operation on line 487 of LandBaseTokenV3.sol  The operation on line 541 of LandBaseTokenV3.sol  The operation on line 543 of LandBaseTokenV3.sol  The operation on line 611 of LandBaseTokenV3.sol  The operation on line 620 of LandBaseTokenV3.sol  The operation on line 40 of LandV3.sol  Consider using the latest Solidity version which has built-in math checks against overflows and underflows. Alternatively, consider using the OpenZeppelin SafeMath library to protect math operations against overflows and underflows for Solidity versions >=0.6.0 and <0.8.0.  Update: Resolved in pull request #909 at commit 37b3dfb. The exists (_isValidQuad) function in the LandBaseTokenV3 contract has been updated to ensure the input quad size is one of the valid sizes. In addition, upon further review from the OpenZeppelin team, it was noted that unchecked math for both the LandBaseTokenV3.sol and LandV3.sol does not introduce potential for overflows or underflows. Also, the Sandbox team stated:  We checked for possible cases of unsafeMath but feel that we have good validation for the values of parameters, which will never cause a safeMath error. We have found one case regarding the possible value of size, which has been handled in the pull request for L-02.  Medium Severity", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#potentially-unsafe-usage-of-unchecked-math", "labels": ["OpenZeppelin"]}, {"title": "Lack of documentation for complex functionality", "body": "The codebase contains several internal functions that perform complex computations but lack sufficient documentation. Further, some state variables have complex implicit assumptions about the values they store that are not documented. This lack of documentation can hinder the maintainability of these functions and variables, making it more challenging for auditors to thoughtfully understand their implications. In particular:  The _mintAndTransferQuad, _checkAndClearOwner, _checkAndClear, and _checkBatchReceiverAcceptQuadAndClearOwner functions in the PolygonLandBaseTokenV2 and LandBaseTokenV3 contracts.  The _owners state variable defined in the ERC721BaseTokenV2 contract in both the Ethereum implementation and Polygon implementation, which is used throughout the LandBaseTokenV3 and PolygonLandBaseTokenV2 contracts. This variable uses a complex storage pattern to record ownership of individual LAND tokens as well as \"quads\". Quads are indexed using a bitmask and the code implicitly assumes that ownership of individual LAND tokens takes precedence over quads. Further, the stored addresses include indicator bits above the 160th bit to mark tokens as burned or have an operator enabled.  To ensure ease of maintainability, consider thoroughly documenting these functions and variables, including both function-level documentation as well as in-line documentation where appropriate.  Update: Resolved in pull request #916 at commit 3d5acc1.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-documentation-for-complex-functionality", "labels": ["OpenZeppelin"]}, {"title": "Lack of input id validation in the _ownerOf function", "body": "Ethereum and  Polygon implementations does not validate that the input  Consider validating that the input ID corresponds to a single token. This can be done by adding additional checks to the function to ensure that only valid token IDs are processed.  Update: Resolved in pull request #921 at commit 97da7fb.  Low Severity", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-input-id-validation-in-the-_ownerof-function", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "The following instances of missing docstrings were identified:  Lines 11 and 32 in ERC721BaseTokenV2.sol  Line 6 in LandBaseTokenV3.sol  Line 9 in LandV3.sol  Lines 4, 5, 7, 9, 11, 13, 19, 25, 31, 37, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, and 65 in IOperatorFilterRegistry.sol  Line 6 in MetaTransactionReceiverV2.sol  Line 5 in SuperOperatorsV2.sol  Lines 12 and 19 in ERC721MandatoryTokenReceiver.sol  Lines 11 and 17 in ERC721TokenReceiver.sol  Line 3 in AddressUtils.sol  Lines 4, 5, 7, 9, 11, 13, 19, 25, 31, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, and 65 in IOperatorFilterRegistry.sol  Lines 16 and 20 in ERC2771Handler.sol  Line 13 in ERC721BaseTokenV2.sol  Line 7 in WithAdminV2.sol  Line 8 in WithSuperOperatorsV2.sol  Line 6 in FxBaseChildTunnelUpgradeable.sol  Line 10 in FxBaseRootTunnelUpgradeable.sol  Lines 12 and 19 in IERC721MandatoryTokenReceiver.sol  Lines 4, 5, 14, and 23 in ILandToken.sol  Lines 6, 7, 13, 21, and 29 in ILandTokenV2.sol  Lines 6, 13, and 19 in IPolygonLand.sol  Lines 4 and 11 in IPolygonLandTunnel.sol  Lines 6 and 7 in IPolygonLandWithSetApproval.sol  Lines 10, and 195 in PolygonLandBaseTokenV2.sol  Line 13 in PolygonLandTunnelV2.sol  Lines 14, 30, and 77 in LandTunnelV2.sol  Lines 122 and 131 of PolygonLandTunnelMigration.sol  Lines 6, 7, and 15 of IPolygonLandV2.sol  Line 38 of LandTunnelMigration.sol  Additionally, there are cases that require further completion:  The return from the supportsInterface function in the LandTunnelV2 contract is undocumented.  The return from the supportsInterface function in the PolygonLandTunnelV2 contract is undocumented.  The _childToken argument to the initialize function in the PolygonLandTunnelV2 contract is undocumented.  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #907 at commit 9ddf8c9.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "require statements with multiple conditions", "body": "The following instances of  were identified:  The require statement on line 43 of LandBaseTokenV3.sol  The require statement on line 44 of LandBaseTokenV3.sol  The require statement on line 140 of LandBaseTokenV3.sol  The require statement on line 227 of LandBaseTokenV3.sol  The require statement on line 228 of LandBaseTokenV3.sol  The require statement on line 420 of LandBaseTokenV3.sol  The require statement on line 421 of LandBaseTokenV3.sol  The require statement on line 658 of LandBaseTokenV3.sol  The require statement on line 38 of PolygonLandBaseTokenV2.sol  The require statement on line 39 of PolygonLandBaseTokenV2.sol  The require statement on line 61 of PolygonLandBaseTokenV2.sol  The require statement on line 611 of PolygonLandBaseTokenV2.sol  The require statement on line 612 of PolygonLandBaseTokenV2.sol  The require statement on line 731 of PolygonLandBaseTokenV2.sol  The require statement on line 103 of PolygonLandTunnelV2.sol  The require statement on line 79 of LandTunnelV2.sol  To simplify the codebase and raise the most helpful error messages for failing require statements, consider having a single require statement per condition.  Update: Resolved in pull request #909 at commit 37b3dfb.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#require-statements-with-multiple-conditions", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission after sensitive actions", "body": "The following functions do not emit relevant events after executing sensitive actions.  Ethereum LAND:  When the _admin variable is set in the initialize function of the ERC721BaseTokenV2 contract  When the filter registry is set in the LandV3 contract  When the LAND contract is registered on the Operator Filterer Registry in the LandV3 contract  Polygon LAND:  When the _admin variable is set in the initialize function of the PolygonLandV2 contract  When the _trustedForwarder is set in the initializer of the ERC2771Handler contract  When the _trustedForwarder is set using the setTrustedForwarder method in the PolygonLandV2 contract  When the filter registry is set in the PolygonLandV2 contract  When the LAND contract is registered on the Operator Filterer Registry in the PolygonLandV2 contract  When the _trustedForwarder is set using the setTrustedForwarder method in the LandTunnelV2 contract  When the _trustedForwarder is set using the setTrustedForwarder method in the PolygonLandTunnelV2 contract  When the maxGasLimitOnL1 and maxAllowedQuads state variables are set in the initialize function in the PolygonLandTunnelV2 contract  When the admin is set in the constructor of the PolygonLandTunnelMigration contract  When the admin is set in the constructor of the LandTunnelMigration contract  Consider emitting events after sensitive changes occur to facilitate tracking and notify any off-chain clients who may be following the contracts' activity.  Update: Resolved in pull request #919 at commit c5bb59b.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-event-emission-after-sensitive-actions", "labels": ["OpenZeppelin"]}, {"title": "Lack of input validation", "body": "Throughout the codebase, there are several functions that lack input validation when changing privileged roles, allowing these roles to be set to the zero address. In particular:  The newAdmin argument of the changeAdmin function in the AdminV2 contract for both implementations  The batchTransferQuadToL2 function in the LandTunnelV2 contract can be called with zero-length arrays for the sizes, xs, and ys arguments. Consider validating that the input arrays have a length of at least 1.  The batchTransferQuadToL1 function in the PolygonLandTunnelV2 contract can be called with zero-length arrays for the sizes, xs, and ys arguments. Consider validating that the input arrays have a length of at least 1.  The setLimit function in the PolygonLandTunnelV2 contract accepts a quad size and the gas limit for that size. The size argument is never validated to ensure it corresponds to a valid quad size of 1, 3, 6, 12, or 24.  The setMaxLimitOnL1 function in the PolygonLandTunnelV2 contract does not validate that the input gas limit is non-zero. If the maxGasOnLimitOnL1 variable is set to zero it would prevent tokens from being transferred to L1 as the gas check within the batchTransferQuadToL1 function will always fail.  Consider adding a check that prevents setting these roles to the zero address and including a separate function for revoking role rights.  Update: Partially resolved in pull request #954 at commit 0f7f68d. The Sandbox team stated:  We decided not to fix the issue on AdminV2 as we want to be able to give up on the admin role.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Operator approval can cause unexpected behavior", "body": "When an operator approval is set, the _owners data stores a flag at the 256th bit (this is done in both implementations, Ethereum and Polygon).  line 357 in the Polygon implementation and on  line 264 in the Ethereum implementation will fail since the 256th bit will never match  Function _checkBatchReceiverAcceptQuadAndClearOwner will fail to clear the owner of a quad with an operator approval set, as it also performs ownership checks following the pattern explained above, specifically, in lines 323 and 343 in the Ethereum implementation and in lines 463 and 483 in the Polygon implementation.  Consider disregarding the operator flag when checking ownership within the _mintAndTransferQuad and _checkBatchReceiverAcceptQuadAndClearOwner functions. Further, if an operator is set for any of the transferred tokens, the operator should be cleared from the operator mapping.  Update: Resolved in pull request #917 at commit 02f7bc8.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#operator-approval-can-cause-unexpected-behavior", "labels": ["OpenZeppelin"]}, {"title": "Lack of storage gap in upgradeable contracts", "body": "Throughout the codebase, there are several contracts that are inherited by upgradeable contracts that do not include a storage gap. In particular:  The ERC2771Handler contract  The ERC721BaseTokenV2 contract  The WithSuperOperatorsV2 contract  The WithAdminV2 contract  If any of these contracts add new storage variables it will overwrite the storage of parent contracts and lead to an incompatible storage layout.  To allow additions of new state variables without compromising the storage compatibility with existing deployments, consider leaving a storage gap at the end of each contract.  Update: Acknowledged, not resolved. The Sandbox team stated:  Those contracts are already deployed on mainnet, therefore we cannot add gaps without breaking the storage.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-storage-gap-in-upgradeable-contracts", "labels": ["OpenZeppelin"]}, {"title": "Setting the root and child tunnel addresses can be front-run", "body": "setFxRootTunnel and  setFxChildTunnel functions defined in the  FxBaseChildTunnelUpgradeable and  FxBaseRootTunnelUpgradeable contracts and the functions are never overridden. Since these functions do not contain any access control, anyone can call them and set the aforementioned addresses to any address except the zero address. If these functions were front-run, the implementation contracts would need to be redeployed as it will not be possible to change these addresses after they have been set.  Consider either including access control on these functions, calling them within the initialize functions, or ensuring that they are called within the same transaction as when the implementation contracts are initialized.  Update: Resolved in pull request #945 at commit b74749c.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#setting-the-root-and-child-tunnel-addresses-can-be-front-run", "labels": ["OpenZeppelin"]}, {"title": "Unused variable", "body": "The PolygonLandTunnelMigration and LandTunnelMigration contracts both define a constant GRID_SIZE that is not used within these contracts.  Consider removing this variable.  Update: Resolved in pull request #942 at commit 8a16ac2.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#unused-variable", "labels": ["OpenZeppelin"]}, {"title": "Missing access control", "body": "The approveNewLandTunnel function in the PolygonLandTunnelMigration contract sets approval for the new land tunnel contract to transfer LAND tokens on behalf of the contract. This function lacks any access control and can be called by anyone.  While this is not directly a security risk as only super-operators are approved to transfer LAND tokens to the contract within the migrateToTunnelWithWithdraw function, consider restricting this function such that only the admin can call it to further secure the contract.  Update: Resolved in pull request #946 at commit 90a111e.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#missing-access-control", "labels": ["OpenZeppelin"]}, {"title": "Files specifying outdated Solidity versions", "body": "The following instances of files specifying outdated Solidity versions were identified:  The pragma statement on line 2 of ERC721BaseTokenV2.sol  The pragma statement on line 2 of LandBaseTokenV3.sol  The pragma statement on line 3 of LandV3.sol  The pragma statement on line 2 of OperatorFiltererUpgradeable.sol  The pragma statement on line 2 of IOperatorFilterRegistry.sol  The pragma statement on line 1 of MetaTransactionReceiverV2.sol  The pragma statement on line 1 of SuperOperatorsV2.sol  The pragma statement on line 1 of ERC721Events.sol  The pragma statement on line 1 of ERC721MandatoryTokenReceiver.sol  The pragma statement on line 9 of ERC721TokenReceiver.sol  The pragma statement on line 1 of AddressUtils.sol  Consider taking advantage of the latest Solidity version to improve the overall readability and security of the codebase. Regardless of which version of Solidity is used, consider pinning the version consistently throughout the codebase to prevent bugs due to incompatible future releases.  Update: Acknowledged, not resolved. The Sandbox team stated:  We decided not to change the solidity version as it causes too many changes.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#files-specifying-outdated-solidity-versions", "labels": ["OpenZeppelin"]}, {"title": "Fuzzing testing opportunities", "body": "The following functions could benefit from fuzzing:  _idInPath of LandBaseTokenV3.sol  _isQuadMinted of LandBaseTokenV3.sol  _getQuadLayer of LandBaseTokenV3.sol  _getQuadById of LandBaseTokenV3.sol  uint2str of LandV3.sol  _isQuadMinted of PolygonLandBaseTokenV2.sol  _getQuadLayer of PolygonLandBaseTokenV2.sol  _idInPath of PolygonLandBaseTokenV2.sol  _getQuadById of PolygonLandBaseTokenV2.sol  Consider performing additional testing for the functions above.  Update: Acknowledged, not resolved. The Sandbox team stated:  Fuzzing testing is not easily possible on the current repository but we're planning to migrate the repository and enable fuzz testing later this year.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#fuzzing-testing-opportunities", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed event parameters", "body": "The following instances could benefit from indexing event parameters:  line 18 of LandBaseTokenV3.sol  line 10 of MetaTransactionReceiverV2.sol  line 9 of SuperOperatorsV2.sol  line 24 of PolygonLandBaseTokenV2.sol  line 25 of PolygonLandTunnelMigration.sol  line 33 of PolygonLandTunnelMigration.sol  line 27 of PolygonLandTunnelV2.sol  line 23 of LandTunnelMigration.sol  Consider indexing event parameters to improve the ability of off-chain services to search and filter for specific events.  Update: Resolved in pull request #902 at commit 83835cd.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Lack of SPDX license identifiers", "body": "The following Solidity files lack the appropriate SPDX license identifiers:  ERC721BaseTokenV2.sol  LandBaseTokenV3.sol  LandV3.sol  MetaTransactionReceiverV2.sol  SuperOperatorsV2.sol  ERC721Events.sol  ERC721MandatoryTokenReceiver.sol  AddressUtils.sol  ERC721TokenReceiver.sol  To avoid legal issues regarding copyright and follow best practices, consider adding SPDX license identifiers to files as suggested by the Solidity documentation.  Update: Resolved in pull request #903 at commit dc4bade.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-spdx-license-identifiers", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit imports are used", "body": "throughout the codebase, which reduces code readability and could lead to conflicts between the names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or if inheritance chains are long.  For instance:  LAND  lines 4-9 of ERC721BaseTokenV2.sol  line 4 of LandBaseTokenV3.sol  lines 5-7 of LandV3.sol  lines 3 and 4 of MetaTransactionReceiverV2.sol  line 3 of SuperOperatorsV2.sol  lines 6-11 of ERC721BaseTokenV2.sol  line 5 of WithAdminV2.sol  lines 5 and 6 of WithSuperOperatorsV2.sol  line 4 of IPolygonLand.sol  lines 5-8 of PolygonLandBaseTokenV2.sol  lines 5-8 of PolygonLandV2.sol  line 4 of IPolygonLandV2.sol  TUNNEL  line 4 of ILandTokenV2.sol  line 4 of IPolygonLandWithSetApproval.sol  lines 4-6 of PolygonLandTunnelMigration.sol  lines 4-11 of PolygonLandTunnelV2.sol  line 4 of LandTunnelMigration.sol  lines 4-9 of LandTunnelV2.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Resolved in pull request #904 at commit 94697a5.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "The following instances of unused imports were identified:  Import ERC721BaseTokenV2 of LandV3.sol  Import PolygonLandBaseToken of PolygonLandTunnelV2.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #905 at commit 4736d01.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused named return variables", "body": "Throughout the codebase there are multiple instances of unused named return variables:  The isOperator return variable in the isApprovedForAll function in ERC721BaseTokenV2.sol.  The trustedForwarder return variable in the getTrustedForwarder function in ERC2771Handler.sol.  The isOperator return variable in the isApprovedForAll function in ERC721BaseTokenV2.sol.  The isMetaTx return variable in the _checkTransfer function in ERC721BaseTokenV2.sol.  The sender return variable in the _msgSender function in PolygonLandTunnelV2.sol.  The sender return variable in the _msgSender function in PolygonLandV2.sol.  The sender return variable in the _msgSender function in LandTunnelV2.sol.  Consider either using or removing any unused named return variables.  Update: Resolved in pull request #906 at commit 697bd41.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#unused-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Lack of EIP-173 support for operator filter registry", "body": "The OpenSea operator filter registry lets a smart contract manage the operators allowed to transfer tokens on behalf of users. If the contract implementing the registry follows EIP-173, the owner is able to manage the registry on behalf of the contract. The PolygonLandV2 contract does not follow EIP-173 but instead has an equivalent admin role.  To enable easier control over the registry and provide access to more functionality without requiring an upgrade to the token contract, consider implementing EIP-173.  Update: Acknowledged, not resolved. The Sandbox team stated:  We decided not to implement the EIP-173 as the OperatorFilterSubscription contract will handle the administration.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-eip-173-support-for-operator-filter-registry", "labels": ["OpenZeppelin"]}, {"title": "Redundant code", "body": "Consider making the following changes to eliminate redundant code:  Ethereum LAND:  The _register function of OperatorFiltererUpgradeable contract in line 24 handles the case where subscriptionOrRegistrantToCopy is the zero address, but this path will never be executed as there is a require statement validating that subscriptionOrRegistrantToCopy != address(0) in the caller function. Consider removing this code path.  Checking if the output of the exists function is true in the mintAndTransferQuad function in the LandBaseTokenV3 contract is unnecessary.  The _checkTransfer function in the ERC721BaseTokenV2 contract will either revert or return true. Returning true from this function is unnecessary.  Polygon LAND:  The _register function of the OperatorFiltererUpgradeable contract in line 27 handles the case where subscriptionOrRegistrantToCopy is the zero address, but this path will never be executed as there is a require statement validating that subscriptionOrRegistrantToCopy != address(0) in the caller function. Consider removing this code path.  Checking if the output of the exists function is true in the mintAndTransferQuad function in the PolygonLandBaseTokenV2 contract is unnecessary.  The _checkTransfer function in the ERC721BaseTokenV2 contract will either revert or return true. Returning true from this function is unnecessary.  When calling the safeTransferFrom function in the PolygonLandV2 contract without the data argument, the onlyAllowedOperator modifier is called twice: once by the safeTransferFrom function without the data argument, and again by the safeTransferFrom function with the data argument.  Update: Partially resolved in pull request #910 at commit 28607d2. The following instances remain unresolved:  Ethereum LAND: The _register function of OperatorFiltererUpgradeable contract in line 24 handles the case where subscriptionOrRegistrantToCopy is the zero address, but this path will never be executed as there is a require statement validating that subscriptionOrRegistrantToCopy != address(0) in the caller function. Consider removing this code path.  Polygon LAND: The _register function of the OperatorFiltererUpgradeable contract in line 27 handles the case where subscriptionOrRegistrantToCopy is the zero address, but this path will never be executed as there is a require statement validating that subscriptionOrRegistrantToCopy != address(0) in the caller function. Consider removing this code path.  In addition, The Sandbox team stated:  We decided not to resolve this issue to keep the code as close as the original one from OpenSea.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#redundant-code", "labels": ["OpenZeppelin"]}, {"title": "Reuse onlyAdmin modifier", "body": "The onlyAdmin modifier can be used instead of the require checks:  In the setMinter function in the PolygonLandBaseTokenV2 contract  In the setSuperOperator function in the WithSuperOperatorsV2 contract  To improve the readability of the codebase, consider using the onlyAdmin modifier instead of the require checks.  Update: Resolved in pull request #911 at commit 6fe419b.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#reuse-onlyadmin-modifier", "labels": ["OpenZeppelin"]}, {"title": "Trusted forwarder validated against operator filter registry", "body": "The trusted forwarder is used throughout the contract to enable meta-transactions. With the addition of the operator filter registry, any transaction initiated by the trusted forwarder will validate the trusted forwarder against the registry as the onlyAllowedOperator modifier checks msg.sender rather than _msgSender.  Consider using _msgSender within the onlyAllowedOperator modifier to reduce gas consumption when performing meta-transactions.  Update: Resolved in pull request #924 at commit 967f133.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#trusted-forwarder-validated-against-operator-filter-registry", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Consider addressing the following typographical errors.  Ethereum LAND:  On line 8 of OperatorFiltererUpgradeable.sol, \"subscibe\" should be \"subscribe\", and \"or copy or just to the subscription provided\" should be \"or copy the subscription provided\".  On line 388 of LandBaseTokenV3.sol, \"when the size is smaller than..\" should be bigger.  On line 470 of LandBaseTokenV3.sol, \"transfered\" should be \"transferred\".  On line 485 of LandBaseTokenV3.sol, \"itereates\" should be \"iterates\".  On line 513 of LandBaseTokenV3.sol, \"ittereated\" should be iterated.  On line 81 of ERC721BaseTokenV2.sol, \"resset\" should be \"reset\".  On line 81 of ERC721BaseTokenV2.sol, \"overriden\" should be \"overridden\".  Polygon LAND:  On line 8 of OperatorFiltererUpgradeable.sol, \"subscibe\" should be \"subscribe\".  On line 8 of OperatorFiltererUpgradeable.sol, \"or copy or just to the subscription provided\" should be \"or copy the subscription provided\".  On line 38 of LandTunnelV2 contract, \"trasnfer\" should be \"transfer\".  On line 51 of LandTunnelV2 contract, \"trasnfer\" should be \"transfer\".  On lines 54-57 of the PolygonLandTunnelMigration contract, \"cant\" should be \"can't\".  On line 142 of PolygonLandTunnelV2 contract, \"trasnfer\" should be \"transfer\".  On line 155 of PolygonLandTunnelV2 contract, \"trasnfer\" should be \"transfer\".  On line 86 of ERC721BaseTokenV2.sol, \"send\" should be \"sender\".  On line 155 of ERC721BaseTokenV2.sol, there should be a space after \"token\".  On line 355 of ERC721BaseTokenV2.sol, \"adddress\" should be \"address\".  On line 373 of ERC721BaseTokenV2.sol, \"adddress\" should be \"address\".  On line 418 of ERC721BaseTokenV2.sol, \"recieving\" should be \"receiving\".  On line 625 of PolygonLandBaseTokenV2.sol, \"transfered\" should be \"transferred\".  On line 640 of PolygonLandBaseTokenV2.sol, \"itereates\" should be \"iterates\".  On line 664 of PolygonLandBaseTokenV2.sol, \"qua\" should be \"quad\".  On line 668 of PolygonLandBaseTokenV2.sol, \"ittereated\" should be \"iterated\".  On line 163 of PolygonLandV2.sol, the double quote \"\" after \"true\" should be a single quote \".  Update: Resolved in pull request #912 at commit e11a210.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unclear event names", "body": "Clear and concise event names are essential for off-chain applications to grasp the intended purpose of the event. However, there are several events in the codebase that lack precisely defined names. In particular:  Ethereum LAND:  The MetaTransactionProcessor event defined in the MetaTransactionReceiverV2 contract  The Minter event defined in the LandBaseTokenV3 contract  The SuperOperator event defined in the SuperOperatorsV2 contract  Polygon LAND:  The Minter event defined in the PolygonLandBaseTokenV2 contract  The SuperOperator event defined in the WithSuperOperatorsV2 contract  Consider renaming these events using descriptive names that provide a clear context of their intended purpose.  Update: Acknowledged, not resolved. The Sandbox team stated:  We decided not to change the event names because those events are already consumed.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#unclear-event-names", "labels": ["OpenZeppelin"]}, {"title": "Lack of attribution", "body": "Throughout the codebase, there are files that have been copied and modified from the OpenSea operator filter registry codebase. The original contracts use the MIT license which requires attribution. In particular:  Ethereum LAND:  OperatorFiltererUpgradeable.sol  IOperatorFilterRegistry.sol  Polygon LAND:  OperatorFiltererUpgradeable.sol  IOperatorFilterRegistry.sol  Consider including a comment in these files attributing the original authors and source.  Update: Resolved in pull request #914 at commit e46d379.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#lack-of-attribution", "labels": ["OpenZeppelin"]}, {"title": "Gas optimizations", "body": "The following opportunities for gas optimization were identified:  Ethereum LAND:  In the _checkTransfer function of the ERC721BaseTokenV2 contract, lines 150 and 151 perform the same check. Consider refactoring the function to avoid duplicated checks.  Using a bitmask to clear the highest 8 bits in the _getX and _getY functions in the LandBaseTokenV3 contract would be more gas efficient.  Polygon LAND:  Using a bitmask to clear the highest 8 bits in the _getX and _getY functions in the PolygonLandBaseTokenV2 contract would be more gas efficient.  Consider optimizing gas consumption by adjusting the aforementioned issues.  Update: Resolved in pull request #915 at commit 2c0b610.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent use of named return values", "body": "The following contracts contain some functions with named return values, and some without.  In Ethereum LAND:  The LandBaseTokenV3 contract  The AddressUtils library  The ERC721BaseTokenV2 contract  In Polygon LAND:  The PolygonLandV2 contract  The PolygonLandBaseTokenV2 contract  The ERC721BaseTokenV2 contract  The ERC2771Handler contract  The LandTunnelV2 contract  The PolygonLandTunnelV2 contract  Consider using named return values consistently throughout every contract and library to provide a clear understanding of the code's behavior.  Update: Resolved in pull request #918 at commit ef05b41.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#inconsistent-use-of-named-return-values", "labels": ["OpenZeppelin"]}, {"title": "Naming issues hinder code understanding and readability", "body": "Throughout the codebase, there are several functions and variables that could be renamed to better reflect their purpose, in particular:  Ethereum LAND:  _checkAndClear function of LandBaseTokenV3 contract.  The landMinted variable in the _mintAndTransferQuad function in the LandBaseTokenV3 contract corresponds to the number of LAND tokens transferred, not minted.  Polygon LAND:  The _checkAndClear function in the PolygonLandBaseTokenV2 contract.  The landMinted variable in the _mintAndTransferQuad function in the PolygonLandBaseTokenV2 contract corresponds to the number of LAND tokens transferred, not minted.  The maxAllowedQuads state variable in the PolygonLandTunnelV2 contract corresponds to the maximum amount of LAND tokens, not quads.  The user address parameter in the mintQuad function of the IPolygonLand interface should be to address  In PolygonLandTunnelV2 contract, gasLimit should be totalGasLimit  The naming of setLimit and setupLimits functions in the PolygonLandTunnelV2 contract is unclear and confusing.  Consider renaming these functions and variables to improve the codebase's readability.  Update: Partially resolved in pull request #922 at commit 0de8738. The Sandbox team stated:  __checkAndClear called in in regroupquad to check it the owner of 1x1 land in a 3x3 quad are owned by the from or not and clears the owner data of any land that is owned by the from address___checkAndClearOwner called during the mintandtransfer to check if the sub quads are owned by the msg.sender and clears it___checkBatchReceiverAcceptQuadAndClearOwner checks if to in the mintandtransfer if is a contract and can handle ERC721(onERC721 receive functions) and clears the owner of 1x1 land for every 1x1 land in the Quad to be mint and transfer___numLandMinted is the cumulative value of number of land tokens that are found to be already minted. numLandMinted variable correspond to number of Land already minted_", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#naming-issues-hinder-code-understanding-and-readability", "labels": ["OpenZeppelin"]}, {"title": "public function that should have external visibility", "body": "The following public function should be external:  The batchTransferQuadToL2 function in the LandTunnelV2 contract.  Consider changing the visibility of this function to external in order to clarify that this function will only be called by external contracts.  Update: Resolved in pull request #947 at commit 0d38cb3.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#public-function-that-should-have-external-visibility", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent ordering of functions", "body": "The codebase generally follows the recommended order in the Solidity Style Guide, however there are some instances where contracts deviate from the style guide. In particular:  In the LandTunnelMigration contract there are functions defined before the constructor.  In the PolygonLandTunnelMigration contract there are functions defined before the constructor.  In the PolygonLandTunnelV2 contract there are functions defined before the initialize function. While not directly part of the Solidity style guide, the initialize function should be considered comparable to a constructor.  To improve the project's overall legibility, consider standardizing ordering throughout the codebase, as recommended by the Solidity Style Guide.  Update: Resolved in pull request #949 at commit a706fe6.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#inconsistent-ordering-of-functions", "labels": ["OpenZeppelin"]}, {"title": "Variables could be immutable", "body": "Throughout the codebase, there are several variables that could be immutable. For instance:  The polygonLand variable in the PolygonLandTunnelMigration contract.  The newLandTunnel variable in the PolygonLandTunnelMigration contract.  The oldLandTunnel variable in the PolygonLandTunnelMigration contract.  The landToken variable in the LandTunnelMigration contract.  The newLandTunnel variable in the LandTunnelMigration contract.  The oldLandTunnel variable in the LandTunnelMigration contract.  To better convey the intended use of variables and to potentially save gas, consider adding the immutable keyword to variables that are only set in the constructor.  Update: Resolved in pull request #953 at commit 6b5b33f.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#variables-could-be-immutable", "labels": ["OpenZeppelin"]}, {"title": "Unused bytes data value", "body": "Throughout the codebase, there are calls for transferring LAND tokens that include the data argument. These calls pass a value of \"0x\" for the data argument which is never used within the calls. In particular:  Within the migrateLandsToTunnel function in the LandTunnelMigration contract.  Within the migrateQuadsToTunnel function in the LandTunnelMigration contract.  Within the migrateLandsToTunnel function in the PolygonLandTunnelMigration contract.  Within the migrateToTunnelWithWithdraw function in the PolygonLandTunnelMigration contract.  Within the migrateQuadsToTunnel function in the PolygonLandTunnelMigration contract.  Consider passing empty bytes data (\"\") to these functions as the input value is never used and consumes unnecessary gas.  Update: Resolved in pull request #952 at commit b949862.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#unused-bytes-data-value", "labels": ["OpenZeppelin"]}, {"title": "Anyone can initialize the implementation contracts", "body": "Initializable contract is added. Since there is no access control on the  _disableInitializers function, introduced in version  4.6.0 of the OpenZeppelin contracts library, from the constructors of the implementation contracts to prevent them from being initialized. In particular, the following implementation contracts should be updated:  PolygonLandV2  LandTunnelV2  PolygonLandTunnelV2  While not a direct security concern, it is a good practice to prevent the implementation contract from being initialized as this could allow an attacker to take over the contract. This would not affect the functionality of the proxy contract as only the storage of the implementation contract would be affected.  Update: Acknowledged, not resolved. The Sandbox team stated:  We decided not to fix this issue as it would require upgrading the OpenZeppelin contracts to 4.6.0, which is not an option for us with the current implementation.", "html_url": "https://blog.openzeppelin.com/land-and-tunnel-audit#anyone-can-initialize-the-implementation-contracts", "labels": ["OpenZeppelin"]}, {"title": "Additional \"Do No Harm\" Principles", "body": "At the request of SphereX, in addition to the usual risks to safety and security, we assessed the risks associated with their \"Do No Harm Principles\". These principles strive to ensure that even if the owner of SphereXEngine is compromised or is malicious, the following statements should hold true:  SphereXEngine is immutable. Even in extreme cases of a malicious operator of SphereXEngine, the maximal potential damage would be limited to reverting transactions for the protected contracts. In that case, SphereXEngines Admin can renounce the malicious operators ownership and restore control.  SphereXProtected does not collide with existing standard libraries/contracts (e.g., we do not store SphereXAdmin on slot 0 to prevent collision with OpenZeppelin Ownable).  The product does not alter the customer's contract logic. It only approves or denies transactions.  Our product cannot alter the state of the customer's contract (apart from predetermined SphereXProtected-related storage slots).  The engine does not censor transactions based on addresses (tx.origin, msg.sender).  Customer's or owner's funds are not processed by or stored inside SphereXEngine at any phase during or after execution of tx.  The SphereXAdmin is always capable of disabling the SphereXEngine, and therefore SphereXEngine's owner is incapable of a DoS or ransom scenario.  SphereXAdmin has no control over the customers' contracts except for: (a) enabling/updating the engine, (b) disabling the engine, and (c) changing SphereXAdmin's address.  Management functions: no one besides SphereXAdmin and SphereXEngine's owner can access management functions for the SphereXProtected and SphereXEngine (respectively).  Risks concerning these principles were considered in our analysis. Although most of the principles hold, there are some important considerations for a few of the principles above:  Regarding principle 5: Some censorship by SphereXEngine is discussed in finding M-05.  Regarding principle 7: Short-term DoS risks caused by malice or false positives are discussed in findings H-03 and M-01.  Regarding principle 8: This holds true as long as SphereXAdmin is controlled by the customer, and not SphereX, as intended in principle #1. This is because setting a reverting engine can disable the customer's contract.  Update: The section above was edited following the fix-review process to reflect the updated state of the codebase, as multiple findings that were related to principles 5, 7, 8, and 9 were resolved.  High Severity", "html_url": "https://blog.openzeppelin.com/spherex-audit#additional-\"do-no-harm\"-principles", "labels": ["OpenZeppelin"]}, {"title": "Call Depth Is Never Explicitly Reset", "body": "The Engine does not explicitly reset the call depth, which can lead to an off-by-one error in certain situations:  If an arbitrary call to the Pre-hook is allowed from an unprotected method in an approved sender (a known client-reported edge case)  In the event of a malicious or incorrectly implemented call to the Pre-hook from a contract mistakenly or maliciously added to approved senders  If an assembly return occurs (another known client-reported edge case)  In scenarios where checks are bypassed due to forceCheck being set to false, the pattern could drift into an unpredictable state because it will not be reset. This could result in the rejection of all ensuing transactions once a check is eventually enforced during a Post-hook invocation (triggered from an external method).  Given its potential to cause a Denial-of-Service (DoS), it will require deactivating the protection mechanism.  Consider introducing explicit recording and invalidation of currentBlockOriginHash for both call flow and transaction flow cases, along with a reset of the call depth when currentBlockOriginHash is invalidated. This approach is valid because a call or a transaction cannot extend over multiple transactions, allowing each new transaction to always start from a depth of 1. In this manner, any drift scenario would only persist for the duration of that transaction instead of indefinitely. Furthermore, it is recommended to include all three scenarios in the testing suite to ensure any state corruption is confined to a single transaction.  Update: Resolved in pull request #6 at commit c95fce7.", "html_url": "https://blog.openzeppelin.com/spherex-audit#call-depth-is-never-explicitly-reset", "labels": ["OpenZeppelin"]}, {"title": "Mutually Exclusive Modes are Allowed at the Same Time", "body": "Both operational modes can be activated simultaneously, which leads to a conflict as their resetting logics are mutually exclusive. Specifically, one mode resets with each new transaction, while the other resets at each external call. The existing documentation further indicates that these modes are intended to operate individually rather than concurrently.  Consider adopting an Enum implementation for the modes to enforce exclusivity. Alternatively, input validation can be added on mode setters to prevent invalid configurations.  Update: Resolved in pull request #10 at commit d221420.", "html_url": "https://blog.openzeppelin.com/spherex-audit#mutually-exclusive-modes-are-allowed-at-the-same-time", "labels": ["OpenZeppelin"]}, {"title": "Loop-Called Methods and MultiCall Contracts Require an Individual Allowance of All Likely Loop Lengths and Combinations", "body": "The current implementation requires explicit permission for each possible loop length if a protected method (internal, public, or external) is invoked within a loop. Furthermore, for contracts using the common MultiCall functionality, every likely combination of called methods will need to be allowed separately. This can result in false positives under these conditions:  For Control Flow (CF): if a protected method is ever called from another protected method within a loop.  For Transaction Flow (TF): in general, even without being called from another protected method.  For TF, this means that a third-party (e.g., an integrating) contract calling any protected method in a loop, or using a MultiCall could experience reverts. This reduces the attractiveness of TF to some integrators, as a protocol cannot realistically prevent third-party integrators from calling its methods within loops or from using MultiCall.  For CF, this means that a protected method should avoid calling another protected method in a loop.  This issue is also applicable to recursion, although recursion is rarely used in high-level methods in Solidity.  Consider prohibiting the instrumentation of calls within loops in integrating protocols, and recommend against using TF for protocols likely to be called by third-party contracts.  Update: Acknowledged. The SphereX team stated:  The customers will be notified of this issue. Internal loops (CF) will be solved by preapproving each number of repetitions within a range discussed with the customer. We plan to invest further research resources to find a generic solution for the TF case.  Medium Severity", "html_url": "https://blog.openzeppelin.com/spherex-audit#loop-called-methods-and-multicall-contracts-require-an-individual-allowance-of-all-likely-loop-lengths-and-combinations", "labels": ["OpenZeppelin"]}, {"title": "currentBlockOriginHash Invalidation Issues Can Lead to False Positives", "body": "Although reported as a known issue, this can be particularly severe in some circumstances:  On some L2s, such as Arbitrum, where block.number is the L1 block number, so it will remain constant for some time. Similarly for Optimism, and zkSync.  In chains that rely on relayers and Account Abstraction (quite possibly zkSync).  This can cause intermittent false positives as the second transaction could be rejected for producing a disallowed pattern.  Consider adding block.timestamp (will help with Arbitrum and Optimism) into the hash. It is possible that block.difficulty, tx.gasPrice, block.baseFee can also help.  Update: Resolved in pull request #11 at commit 51e369f.", "html_url": "https://blog.openzeppelin.com/spherex-audit#currentblockoriginhash-invalidation-issues-can-lead-to-false-positives", "labels": ["OpenZeppelin"]}, {"title": "Potential for Hidden Attack Patterns During the Recording Phase", "body": "The recording phase of the contract could potentially be manipulated by an attacker to obscure harmful patterns within a large number of benign ones. This could allow a malicious user to introduce an attack vector into the list of permitted patterns.  For example, if an attacker discovers a reentrancy vulnerability, they could perform numerous transactions, some of which involve harmless reentrancy (resulting in no loss of funds), with the hope of getting this pattern added to the allow-list.  Once the protection is activated and the total value locked (TVL) within the contract reaches a significant level, the attacker may exploit the allow-listed attack pattern.  Consider filtering the initially recorded patterns, particularly if there are a large number of them.  Update: Acknowledged. The SphereX team stated:  Recommendation accepted. Our research team is working on analyzing and sanitizing the recording phase data (identifying abnormal transactions and analyzing them before approving them into the permissible patterns).", "html_url": "https://blog.openzeppelin.com/spherex-audit#potential-for-hidden-attack-patterns-during-the-recording-phase", "labels": ["OpenZeppelin"]}, {"title": "Client Project Has No Ownership Over the Engine Configuration", "body": "At present, the contract engine is solely governed by a single administrator address. As this address is expected to actively operate the contract, it is most likely to be a Spherex-controlled address. This means that if SphereS, as the admin, fails to cooperate, the client project can only deactivate the protection mechanism or deploy its own engine and update its state. This creates an imbalanced relationship since the client has no direct control over patterns being accepted or rejected.  This issue's severity is exacerbated by a lack of emitted events during both configuration and operation, which would hinder the client from configuring their \"forked\" engine instance.  To address this, consider implementing Role-Based Access Control (RBAC). Under this framework, the client project would have admin control while SphereX is granted an operational role, enabling them to update patterns and other configurations. If the client project is dissatisfied with recent configuration updates, they can take over the operational role, reverse any changes, and maintain the previous protection level. Additionally, consider implementing events such that a community member would be able to reconstruct the state of the Engine with common tools.  Update: Resolved in pull request #14 at commit ec71add.", "html_url": "https://blog.openzeppelin.com/spherex-audit#client-project-has-no-ownership-over-the-engine-configuration", "labels": ["OpenZeppelin"]}, {"title": "No Events Emitted and Lack of External Views in Contracts", "body": "The contracts SphereXProtected and SphereXEngine do not emit events or implement external views. This absence of conventional observability methods demands specialized tools and knowledge to monitor and inspect the operational state of these contracts. Moreover, it impedes the utilization of existing data analysis tools, dashboards, monitoring utilities, and front-end frameworks. This opacity can diminish trust, neutrality, and the overall utility of the system for integrating projects.  This lack of observability can introduce further security risks. For instance, if the engine is deactivated by the admin, whether intentionally or unintentionally, it could go unnoticed due to reliance on specialized monitoring tools and their operators. This will expose the customer to exploits via allowing previously disallowed transaction flows, and expose SphereX to legal and reputational risks.  We recommend implementing comprehensive observability of all state changes using both views and events. The entire current state of the contract should be visible through views and reconstructible via events. Additionally, to facilitate gas savings for the customer, consider providing a feature to control event emission during hook execution, possibly through a configuration or input flag. This feature may be more relevant for deployments on Ethereum L1, as the extra gas cost for emitting events on L2s or sidechains should be insignificant.  Update: Partially resolved in pull request #15 at commit f0a818b. Configuration-related events were added. However, state changes involved in hook execution remain unaccompanied by events, which will make tracking the operation of the engine harder to track off-chain.", "html_url": "https://blog.openzeppelin.com/spherex-audit#no-events-emitted-and-lack-of-external-views-in-contracts", "labels": ["OpenZeppelin"]}, {"title": "Potential Issues in Systems Using Factory and Beacon Patterns", "body": "Various smart contract systems implement patterns that dynamically add contracts to the system based on user actions. Some notable examples include pool creation in AMMs, personal proxies in Maker, and multi-signature (multi-sig) Safe creation. When protected by SphereX, each newly created instance of a factory-created contract would need to be separately added by the admin, preventing the contract from becoming immediately operational upon creation, adding a centralizing step, and adding operational complexity.  Furthermore, performing changes to admin and engine addresses on the dynamically generated contracts will be operationally complex and error-prone.  Moreover, these systems can pose a risk of targeted censorship due to the capability of SphereX to exclude a specific personal proxy address from the allowed senders.  Consider implementing Role-Based Access Control (RBAC) as described in the OpenZeppelin documentation. One possible approach could be creating a SENDER_CONFIG_ROLE with the permissions to add allowed senders. This will allow the general admin to assign this role to the factory contract when needed. Alternatively, consider establishing an additional administrative function that enables a factory contract to independently add a newly created contract as an approved sender.  To resolve the configuration issues, consider utilizing a single contract for updating and querying the configuration in the client's project.  To alleviate the censorship risk, consider separating the storage of factory-added addresses and disallowing the removal of any specific address from that set. Alternatively, consider implementing a long delay for removing senders, such that a censored personal proxy owner will have time to exit the system if both SphereX and the Client project are forced to censor it.  Update: Partially resolved in pull request #27 at commit 052bb05. A role-based system was implemented, allowing factories to add new senders on-chain. The configuration and censorship concerns were not resolved.  Low Severity", "html_url": "https://blog.openzeppelin.com/spherex-audit#potential-issues-in-systems-using-factory-and-beacon-patterns", "labels": ["OpenZeppelin"]}, {"title": "Outdated Solidity Versions", "body": "Throughout the codebase, there are pragma statements that use an outdated version of Solidity. For instance:  The pragma statement on line 4 of ISphereXEngine.sol  The pragma statement on line 4 of SphereXEngine.sol  The pragma statement on line 4 of SphereXProtected.sol  Consider taking advantage of the latest Solidity version to improve the overall readability and security of the codebase by avoiding known bugs and taking advantage of newer language features.  Furthermore, it is highly unlikely that newly deployed customer contracts will use versions of Solidity that are older than 0.8. To accommodate specific clients who may require an older version, code can be back-ported and audited separately for that specific integration as part of the integration audit (which is needed for other reasons as well).  Update: Resolved in pull request #16 at commit 9b6c897.", "html_url": "https://blog.openzeppelin.com/spherex-audit#outdated-solidity-versions", "labels": ["OpenZeppelin"]}, {"title": "Possible Underflow Due to Unnecessary Signed Integers in Interfaces", "body": "SphereXEngine hooks lack validation of the sign of num parameter. This can cause an underflow when adding it to _callDepth in _addCFElement if using a Solidity version older than 0.8. This is unintuitive and error-prone, and is particularly problematic if not all numbers are \"flipped\". For example, two Pre hooks called in sequence, one with positive num, and another with negative, will cause the call depth to go back to starting depth unexpectedly.  In addition to being error-prone, the use of int16 in the signatures of sphereXGuard modifiers in SphereXProtected and hooks in SphereXEngine is redundant. This is because a positive number is always expected for the Pre hooks, and a negative, exactly opposite number is expected for the Post hooks. Thus, the negative sign can always be safely added in the Post hooks, leaving the engine's implementation encapsulated and separated from the interface.  Consider using uint256 for the identifier in all the modifiers and the hooks, and using signed integers only in the internal calls in SphereXEngine. Alternatively, consider adding input validation to the hooks to ensure that the sign is as expected.  Update: Resolved in pull request #6 at commit c95fce7.", "html_url": "https://blog.openzeppelin.com/spherex-audit#possible-underflow-due-to-unnecessary-signed-integers-in-interfaces", "labels": ["OpenZeppelin"]}, {"title": "Transaction Flow Mode Vulnerable to Circumvention Via Flashbot Bundles", "body": "A complex attack transaction (disallowed by the engine) involving multiple calls to the client contract may be subdivided into several transactions and executed in sequence, using a private mempool like flashbots. This may allow circumventing the protection of TF mode by employing different externally owned accounts (EOAs) as tx.origin.  For instance, an attack requiring a sequence of [attacker: action_A, attacker: action_B] could appear as a novel transaction flow pattern if executed from an attacking contract. To circumvent this, the attack could be submitted as a bundle of EOA transactions: [attacker: action_A, decoy: action_C, attacker: action_B]. Each transaction in this bundle would pass transaction flow validation as a separate flow. Although certain attacks, such as flashloan attacks, can't be fragmented in this manner, many other multi-step attacks can be.  Consider documenting this option as a consideration for correctly configuring the engine for the client's security needs.  Update: Acknowledged. The SphereX team stated:  This possible bypass scenario is to be taken into account and will be the subject of future research.", "html_url": "https://blog.openzeppelin.com/spherex-audit#transaction-flow-mode-vulnerable-to-circumvention-via-flashbot-bundles", "labels": ["OpenZeppelin"]}, {"title": "Potential for User Exploitation by Integrating Protocols Through Engine Swapping", "body": "An integrating protocol, even one with an ostensibly limited control area, might exploit the sphereXGuard modifiers as a \"backdoor\" by transitioning to a custom engine implementation.  For instance, a protocol could introduce a custom engine that disallows non-insider users from interacting with it. This restriction could prevent users from managing their assets. This will enable insiders to extract these assets by exploiting protocol-specific mechanisms that depend on unrestricted access. Examples could involve using liquidations for lending protocols or arbitrage for trading protocols.  Consider documenting the trust assumptions of the system such as the expanded control surface and potential centralization risks that can arise, so that they are clear to the user communities of the integrating protocols.  Update: Acknowledged. The SphereX team stated:  We will explicitly state this issue in the trust assumptions of the system. Moreover, we will state in our legal documents that we are not liable for any engine that was not deployed and operated by SphereX.", "html_url": "https://blog.openzeppelin.com/spherex-audit#potential-for-user-exploitation-by-integrating-protocols-through-engine-swapping", "labels": ["OpenZeppelin"]}, {"title": "Potential Risks with Hooks' Internal Visibility", "body": "To minimize the likelihood of erroneous integrations, consider changing the visibility of these methods to private.  Update: Resolved in pull request #19 at commit 1baed67.", "html_url": "https://blog.openzeppelin.com/spherex-audit#potential-risks-with-hooks'-internal-visibility", "labels": ["OpenZeppelin"]}, {"title": "Unrecorded Calls Resulting from try/catch or Low-Level Reverts", "body": "When a protocol employs try/catch or low-level calls anticipated to revert and subsequently relies on these revert messages as part of its operational logic, these calls may not be recorded. This is due to the fact that they revert their changes in the Engine.  An illustrative example can be seen in the counterfactual, always-reverting rollback logic in the Synthetix V3 upgrade module. Here, calls always revert but with varying revert errors.  We recommend documenting this edge case to ensure it is considered during integration audits.  Update: Acknowledged. The SphereX team stated:  We will document this edge case.", "html_url": "https://blog.openzeppelin.com/spherex-audit#unrecorded-calls-resulting-from-try/catch-or-low-level-reverts", "labels": ["OpenZeppelin"]}, {"title": "Potential Loss of Ownership During Transfer", "body": "The SphereXEngine implements a single-step ownership transfer mechanism that is prone to operator errors.  Consider using the Ownable2Step contract from the OpenZeppelin library for a safer transition of ownership. This will increase the contract's flexibility and safeguard against unintended loss of control over the engine. Also, the inclusion of a renounce function should be considered to enable owners to more transparently renounce their ownership.  Update: Resolved in pull request #14 at commit ec71add.", "html_url": "https://blog.openzeppelin.com/spherex-audit#potential-loss-of-ownership-during-transfer", "labels": ["OpenZeppelin"]}, {"title": "SphereXEngine Rule Configuration Methods Poorly Named", "body": "In the implementation of the SphereXEngine contract, the activateRules method allows the owner to deactivate the rules by inputting all 8 bytes as zero. This is counterintuitive as activateRules should logically serve to enable the rules, not deactivate them. The deactivateRules method, meant for rule suspension, becomes redundant as the same action can be performed through the activateRules method.  In order to avoid any misinterpretation or misuse, it is recommended to integrate a validation process within the activateRules method that prevents rule deactivation. Alternatively, one could consider consolidating these functions into a single method, configureRules, that toggles the state of the rules based on the input provided, thus eliminating any redundancy and making the system's interface more intuitive.  Update: Resolved in pull request #10 at commit d221420.", "html_url": "https://blog.openzeppelin.com/spherex-audit#spherexengine-rule-configuration-methods-poorly-named", "labels": ["OpenZeppelin"]}, {"title": "Ownership Transfer in changeSphereXAdmin Method is Error-Prone", "body": "The changeSphereXAdmin method currently allows for a single-step ownership transfer, which can be risky due to potential mistakes leading to loss of control to update the Admin or the Engine address and thus losing the ability to opt out of the SphereX Protect.  Consider using a two-step ownership transfer to provide a safer mechanism. Moreover, the method should also validate that the proposed address conforms to the expected contract interface to ensure correct functionality. Lastly, the method should be made virtual to permit override by integrating contracts with their own access control measures.  Update: Resolved in pull request #14 at commit ec71add.", "html_url": "https://blog.openzeppelin.com/spherex-audit#ownership-transfer-in-changespherexadmin-method-is-error-prone", "labels": ["OpenZeppelin"]}, {"title": "Gas Inefficiencies", "body": "There are many instances throughout the codebase where changes can be made to improve gas consumption. For example:  Consolidate _callDepth, _currentPattern, and _currentBlockOriginHash into a single slot. This can be done using a Struct that defines variables that will fit into a single slot. For example, using uint16 for _callDepth, uint216 for _currentBlockOriginHash, and bytes3 for _currentBlockOriginHash. This optimization reduces storage operations and may save up to 5000-7000 gas per transaction during execution on L1.  Avoid performing multiple storage reads and writes on _callDepth. _currentBlockOriginHash and _currentPattern during _addCFElement by reading once into stack variables, and writing back into storage at the end of the method.  Avoid checking for the active rule twice during _addCFElement by using a separate internal method for each case. Additionally, splitting the method into two distinct methods will make the code more readable, auditable, and testable. This will also make the exclusivity of the modes clear.  Use modifiers with internal methods. By doing so, bytecode size is reduced.  The returnsIfNotActivated check can be performed once in the SphereXGuard modifiers, rather than being checked twice for each hook (Pre and Post).  Performing calculations for values that will not change is suboptimal. deactivateRules() should set the value directly.  Use a more recent version of Solidity to take advantage of compiler gas optimizations for both deployment and execution costs.  Use custom errors implementation (if upgrading to a more recent version of Solidity) to save on deployment cost and failed execution gas cost.  When performing these changes, aim to reach an optimal tradeoff between gas optimizations and readability. Having a codebase that is easy to understand reduces the chance of future errors and improves community transparency.  Update: Partially resolved. Suggestion 1 was implemented in pull request #23 at commit 950a31d. Suggestions 2 and 3 were implemented in pull request #6. Suggestion 7 was implemented in pull request #16. Regarding the other suggestions, the SphereX team stated:  After deeply discussing every gas inefficiency issue, we have reached an optimal tradeoff from our point of view.", "html_url": "https://blog.openzeppelin.com/spherex-audit#gas-inefficiencies", "labels": ["OpenZeppelin"]}, {"title": "SphereXEngine Migration Flow Susceptible to Human Error", "body": "The SphereXEngine migration process is currently prone to errors if it involves multiple smart contracts using SphereXProtected. When SphereXEngine requires a change, the admin of each contract must manually replace the engine address. This approach becomes problematic if any contracts are inadvertently overlooked and continue pointing to an outdated version of the SphereXEngine. This can be particularly problematic, or operationally complex when dealing with a large or dynamic system of contracts (e.g., contracts using a factory pattern).  Consider introducing a periphery contract that enables updating all associated contracts in a single transaction. Alternatively, consider implementing a pattern similar to the beacon proxy pattern. The beacon proxy pattern centralizes the update mechanism and reduces the manual workload. By referencing a single 'beacon' that holds the updated SphereXEngine address, all contracts could automatically reflect the most recent engine version, thus reducing the risk of misalignment and potential system malfunctions.  Update: Acknowledged, not resolved. The SphereX team expressed that a separate config contract is not desirable due to gas costs.", "html_url": "https://blog.openzeppelin.com/spherex-audit#spherexengine-migration-flow-susceptible-to-human-error", "labels": ["OpenZeppelin"]}, {"title": "Confusing Revert Messages", "body": "The current revert messages !SX:DETECTED, !SX:SENDERS and !SX:SPHEREX may confuse users of the integrating protocols due to their lack of descriptiveness. It is recommended to revise these messages to more accurately depict the corresponding issues and context (e.g., \"SphereX error: disallowed tx pattern\"). This change will enhance user understanding and facilitate troubleshooting of contract interaction issues.  Update: Resolved in pull request #22 at commit b533a0b.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/spherex-audit#confusing-revert-messages", "labels": ["OpenZeppelin"]}, {"title": "Non-Explicit Imports Are Used", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code, and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are being used. For instance:  Line 6 of SphereXEngine.sol  Line 7 of SphereXEngine.sol  Line 6 of SphereXProtected.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Resolved in pull request #20 at commit cfdd63c.", "html_url": "https://blog.openzeppelin.com/spherex-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Usage of Small-Size Variables", "body": "The usage of int16 and other small number types is present in several parts of the codebase. It is advisable to refrain from using these types in memory calls, interfaces, and calculations. Only employ them when writing into storage for storage slot packing. Utilizing these smaller size variables can lead to potential issues:  Overflows and underflows in mathematical and casting operations can remain undetected  Increased gas expenditure during execution and larger contract bytecode size  Reduced code readability  Potential precision loss  We recommend using uint256 and int256 types whenever possible instead of smaller sizes. Perform downcasting (safely) only when writing values into storage.  Update: Resolved in pull request #18 at commit 0df3f47.", "html_url": "https://blog.openzeppelin.com/spherex-audit#usage-of-small-size-variables", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "There are typographical errors in the codebase's comments. For example:  \"Poistive\" should be \"Positive\".  \"insturction\" should be \"instruction\".  \"nody\" should be \"body\".  \"rotected\" should be \"protected\".  \"defence\" should be \"defense\".  \"abitrary\" should be \"arbitrary\".  \"visibality\" should be \"visibility\".  \"defenitions\" should be \"definitions\".  \"Technolegie\"s should be \"Technologies\".  Consider scanning the codebase using automated tooling and correcting typographical errors.  Update: Resolved in pull request #21 at commit ed86e8a.", "html_url": "https://blog.openzeppelin.com/spherex-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Misleading Comments", "body": "The following misleading comments were identified:  The comment describing the setMintCapNumerator references a MintCapNumeratorSet event, but it should be MintCapNumeratorChanged.  The comment describing the mint function says the mint time interval \"is initially set to 1 year\", which suggests it could be updated. It is actually a constant and can only be changed if the whole contract is upgraded.  Consider updating the comments accordingly.  Update: Resolved in pull request #50 at commit 2a04393.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#misleading-comments", "labels": ["OpenZeppelin"]}, {"title": "Bridge Can Be Reinitialized", "body": "The L1StandardBridge contains a guard condition to prevent it from being reinitialized. However, it assumes the messenger will be non-zero after initialization, which is not guaranteed by the initialize function. This means it is possible to initialize the other variables and later overwrite them. In practice, the contract will be non-functional until the messenger is set.  Nevertheless, in the interest of predictability, consider ensuring the messenger is non-zero during initialization.  Update: Resolved in pull request #1027 at commit e641f0e.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#bridge-can-be-reinitialized", "labels": ["OpenZeppelin"]}, {"title": "Disable Implementation Contract", "body": "The L1StandardBridge implementation contract sets the messenger to the zero address, but this doesn't prevent it from being initialized.  In the interest of limiting the attack surface, consider ensuring the implementation contract cannot be initialized. This could be achieved by setting the messenger to an unused non-zero address.  Update: Acknowledged, not resolved. The Mantle team stated:  We will use our proxy contract to initialize right after deploying the bridge contract, and the proxy contract will be required to be initialized only once. Even if someone tries to initialize the implementation contract afterwards, it will have no impact on our proxy contract.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#disable-implementation-contract", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "In MantleTokenMigrator.sol the received word is misspelled as recieved in several places. Consider resolving this typographical error.  Update: Resolved in pull request #53 at commit 6b78f54. There have been unrelated changes that removed several instances.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "ETH Handling Can Be Simplified", "body": "reverts on the  the Solidity documentation, without the  Update: Resolved in pull request #45 at commit c662f74.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#eth-handling-can-be-simplified", "labels": ["OpenZeppelin"]}, {"title": "Gas Savings", "body": "The setMintCapNumerator and setTreasury functions can consume less gas by emitting an event first and then changing the storage variable.  For example, the following code snippet  uint256  previousMintCapNumerator  mintCapNumerator  mintCapNumerator  _mintCapNumerator  emit  MintCapNumeratorChanged  msg.sender  previousMintCapNumerator  mintCapNumerator  );  may be rewritten as:  MintCapNumeratorChanged  msg.sender  mintCapNumerator  _mintCapNumerator  );  mintCapNumerator  _mintCapNumerator  Consider rewriting the setMintCapNumerator and setTreasury functions to save gas.  Update: Resolved in pull request #48 at commit 4159ef3.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#gas-savings", "labels": ["OpenZeppelin"]}, {"title": "Imprecise Docstrings", "body": "Some imprecise docstrings have been identified:  The comment describing the parameter for the setMintCapNumerator function does not follow the Ethereum Natural Specification Format (NatSpec) format.  For consistency with the migrateAllBIT description, the migrateBIT description should note that the _amount must be non-zero.  Consider updating the docstrings accordingly.  Update: Resolved in pull request #54 at commits 97d88d6 and 0e76225, and pull request #55 at commit d515706.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#imprecise-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Redundant Cast", "body": "The sweepTokens function of the MantleTokenMigrator contract redundantly casts both known token addresses to the address type. Consider removing the unnecessary cast operations.  Update: Resolved in pull request #44 at commit bb921bf.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#redundant-cast", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Multiple Inheritance", "body": "The L1MantleToken contract inherits from several contracts with redundant dependencies. This means that some of the contracts are inherited both directly and indirectly. For example, inheriting ERC20VotesUpgradeable makes inheriting ERC20PermitUpgradeable and ERC20Upgradeable redundant.  the sequence of initializations more intuitive. However, it also forces the  boilerplate functions that are unrelated to the token's new logic. Our opinion is that removing redundancy from the inheritance chain would make the contract simpler and easier to reason about. Consider limiting the inheritance chain to the necessary contracts (i.e.,  Update: Acknowledged, not resolved. The Mantle team stated:  We prefer not to make modifications to improve explicitness and make the initialization sequence more intuitive.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#unnecessary-multiple-inheritance", "labels": ["OpenZeppelin"]}, {"title": "BIT Token Address Is Used Instead of MNT Token Address", "body": "The bridge contracts have specific logic to handle MNT tokens but the L1StandardBridge contract currently associates the BIT token with the L2 Mantle token. Consider reusing the existing variable to identify the MNT token address.  Note that the L2 token also still references the BIT token and should be updated accordingly.  Update: Resolved in pull request #1075 at commit d140d18. The correct address is now hardcoded instead of reusing the variable.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#bit-token-address-is-used-instead-of-mnt-token-address", "labels": ["OpenZeppelin"]}, {"title": "Unused Function", "body": "The L1StandardBridge has a function to donate ETH to the contract. However, this function is a holdover from the Optimism code base and is not required for a fresh deployment. Consider removing it.  Update: Resolved in pull request #1029 at commit a47a661.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#unused-function", "labels": ["OpenZeppelin"]}, {"title": "Unusable Data Parameter", "body": "All deposits and withdrawals pass an arbitrary data parameter over the bridge. This parameter is emitted in the events on both sides, but is otherwise unused. The documentation claims it is a convenience for external contracts, but it is not passed to the destination and other contracts cannot read the events. Consider clarifying how the parameter could be used, or remove it from the transfer.  Update: Acknowledged, not resolved. The Mantle team stated:  We see this as a data interface reserved for subsequent cross-chain interoperability.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#unusable-data-parameter", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Specialization", "body": "depositing Mantle tokens. However, only the  token mapping validation differs from the generic ERC-20 case, so the  generic ERC-20 logic. This would remove unnecessary withdrawal logic and make the  finalizeMantleWithdrawal function obsolete. Consider simplifying the code accordingly.  Update: Acknowledged, not resolved. The Mantle team stated:  We divided this method mainly to facilitate the addition of necessary restrictions for the L2 native token, and also to facilitate subsequent targeted maintenance.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#unnecessary-specialization", "labels": ["OpenZeppelin"]}, {"title": "Redundant Validation", "body": "The finalizeMantleWithdrawal function validates that it is called from the L2 bridge, but this check is repeated on the finalizeERC20Withdrawal function. Consider removing the redundant validation.  Update: Resolved in pull request #1031 at commit 5fbb898.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#redundant-validation", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Encapsulation", "body": "claims to retrieve tokens from the  takes them from the caller. Similarly, the event  references the caller instead of the  both calling functions pass the message sender as the  Update: Acknowledged, not resolved. The Mantle team stated:  We will consider this in future Mantle Network upgrades.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#incorrect-encapsulation", "labels": ["OpenZeppelin"]}, {"title": "Use of Hardcoded Values", "body": "The L1StandardBridge contract has the address of the MNT token hardcoded. Consider creating a constant variable and using it instead of the hardcoded address for clarity and readability.  Similarly, the L2StandardBridge contract hardcodes the IL2StandardERC20 identifier. Consider using the more expressive type(IL2StandardERC20).interfaceId statement instead.  Update: Acknowledged, not resolved. The Mantle team stated:  We will consider this in future Mantle Network upgrades. For now, we have decided to hardcode this address as we do not foresee the MNT token address changing in the future as the MNT token itself is upgradable.", "html_url": "https://blog.openzeppelin.com/mantle-token-and-bridge-audit#use-of-hardcoded-values", "labels": ["OpenZeppelin"]}, {"title": "ProposalDeleted events can be emitted with non-existent assertionId", "body": "assertionDisputedCallback function does not validate whether its  to be emitted for any  A user can accomplish this by interacting with the OptimisticOracleV3 contract. The OptimisticOracleV3 contract's assertTruth function may be called by any user to assert truths that will be accepted as true unless disputed. This will result in the generation of a new assertionId that will be stored in the oracle's assertions mapping.  disputeAssertion will call  call the  line 369 because the caller is the  line 374 the  Consider adding a check in the assertionDisputedCallback function that ensures the assertionId value maps to a non-zero proposalHash, which ensures the assertion is associated with a proposal.  Update: Resolved in pull request #4486 at commit d880037.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#proposaldeleted-events-can-be-emitted-with-non-existent-assertionid", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission", "body": "The internal _sync function changes the OptimisticOracleV3 contract used by the OptimisticGovernor, but unlike other administrative setter functions, it does not emit an event when a change occurs.  Consider adding a new OptimisticOracleChanged event that is emitted by _sync whenever the finder contract returns a different address than that of the current optimisticOracleV3 variable.  Update: Resolved in pull request #4487 at commit f3ea7a6.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#lack-of-event-emission", "labels": ["OpenZeppelin"]}, {"title": "Lack of contract address check in setEscalationManager", "body": "The setEscalationManager administrative function in OptimisticGovernor does not perform any checks to validate that the _escalationManager address is a contract. Specifying an address where no contract code is deployed could result in unexpected behavior since the OptimisticOracleV3 contract expects that all escalation managers implement EscalationManagerInterface.  Consider using the existing _isContract function to validate the _escalationManager argument.  Update: Resolved in pull request #4488 at commit ed8f3fc.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#lack-of-contract-address-check-in-setescalationmanager", "labels": ["OpenZeppelin"]}, {"title": "Unused event", "body": "SetCollateral event, which can be used to emit an updated  SetBond event, which includes both the  Consider renaming the SetBond event to SetCollateralAndBond, and removing the unused SetCollateral event.  Update: Resolved in pull request #4489 at commit cf6b68f.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#unused-event", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent variable naming", "body": "Some functions in the OptimisticGovernor contract use leading underscores to name either input parameters or local variables in cases where there is no name collision with the contract's storage variables:  proposeTransactions: Input parameters _transactions and _explanation  executeProposal: Input parameter _transactions and local variable _proposalHash  deleteProposalOnUpgrade: Input parameter _proposalHash  _constructClaim: Input parameters _proposalHash and _explanation  For consistency and clarity, consider removing the leading underscore from these parameters, and also updating the corresponding docstrings. Alternatively, consider using the leading underscore consistently throughout the contract.  Update: Resolved in pull request #4490 at commit 8a2f6d5.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#inconsistent-variable-naming", "labels": ["OpenZeppelin"]}, {"title": "Locked ETH", "body": "The executeProposal function has the payable modifier. However, any ETH sent is not used in the function and will be locked in the OptimisticGovernor contract.  Consider removing the payable attribute to avoid potentially locking ETH in the OptimisticGovernor contract.  Update: Resolved in pull request #4491 at commit f417256.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#locked-eth", "labels": ["OpenZeppelin"]}, {"title": "Misleading variable names", "body": "proposalHashes and  assertionIds mapping names misleadingly reflect the contents of one another (i.e.,  To increase clarity, consider swapping the names of the proposalHashes and assertionIds mappings, so that the variable names correspond to the values being stored.  Update: Resolved in pull request #4492 at commit c1e996c.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#misleading-variable-names", "labels": ["OpenZeppelin"]}, {"title": "Redundant code", "body": "Consider making the following changes to eliminate redundant code:  In OptimisticGovernor.sol, msg.sender is used on line 263 to transfer tokens from the proposer to the Optimistic Governor contract, but proposer has already been defined as msg.sender on line 234, so proposer can be used here.  In OptimisticGovernor.sol, line 310 computes the assertionId, but this value was already computed on line 307 inside a require statement. Lines 310 and 307 can be swapped, and proposalHashes[_proposalhash] inside the require statement can be replaced with assertionId.  In StakerInterface.sol, the setDelegate and setDelegator functions are marked virtual, but interface functions are implicitly virtual, so this keyword can be removed.  Update: Resolved in pull request #4493 at commit 835a6ff. The StakerInterface.sol file was not changed. The UMA team stated:  The issue in StakerInterface.sol was not fixed as it is not used by the Optimistic Governor, while the dependent VotingV2 contract is already deployed in production.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-incremental-audit#redundant-code", "labels": ["OpenZeppelin"]}, {"title": "Gauges Rewards Can Be Erroneously Deleted", "body": "Each voting period is supposed to last 1 week. There are two ways for anyone to update the system's period after this time has passed:  Call one of the distribute functions of VoterV3, which in turn calls the Minter contract's update_period function  Call update_period on the Minter contract directly  The second method to update the system's period can allow attackers to delete entire reward distributions which were allocated to gauges. This is attributed to a bug in the _updateFor function, where the calculation incorrectly considers the timestamp of the current active epoch when counting votes, rather than the previous epoch.  More specifically, consider the following attack scenario:  First, the function update_period is called directly on the Minter contract and executes successfully. This means that the active period changes, the gauges' reward for the finished period is notified to the Voter contract, and the index is increased.  vote (or  poke) function is called. As a result, the function  the total votes for _epochTimestamp are equal to zero, as this is the very first vote for the new period. In consequence,  supplyIndex for the gauge is set equal to index without accounting the claimable amount for the period that just ended,  making it impossible for the gauge to ever claim that amount.  An attacker could exploit this vulnerability to cause a complete DoS on the gauges' rewards by voting a small amount on every gauge before their distribute functions are called.  Consider using the previous period's timestamp for calculations in the _updateFor function. As an alternative solution, consider completely removing the gauge's update functionality upon every voting action and relying on the updates triggered by the Voter's distribute functions, which are supposed to take place once per voting period.  Update: Resolved in pull request #2 at commit f2c6688.  High Severity", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#gauges-rewards-can-be-erroneously-deleted", "labels": ["OpenZeppelin"]}, {"title": "GaugeExtraRewarder Accounts for Excessive Rewards", "body": "The function updatePool of the GaugeExtraRewarder contract is supposed to update the pool's information upon every state-changing interaction with the contract. The reward-per-share value is then updated by considering the time interval since the latest update. However, the reward rate value keeps increasing even if the distribution period is over. In this scenario, the variable lastRewardTime is assigned incorrectly, as it should be set equal to the end of the distribution period.  This improper accounting results in users accruing and taking rewards that were meant for other users, and in the worst case, causing the underlying gauge to revert during deposit and withdrawal operations.  Consider updating the implementation of the GaugeExtraRewarder contract so as to properly account for the reward amounts after the end of the distribution period.  Update: Resolved in pull request #3 at commit 6d740eb.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#gaugeextrarewarder-accounts-for-excessive-rewards", "labels": ["OpenZeppelin"]}, {"title": "Killing a Gauge Could Result in Stuck Funds", "body": "When a gauge is killed using the killGauge or killGaugeTotally functions in the VoterV3 contract, the gauge-related data is cleared out. However, it is possible that the killed gauge has already been voted for and its respective vote weight has been added to the period's total vote weight. The period's total weight is not adjusted when a gauge is killed, resulting in the portion of the reward that is committed to that gauge remaining unused and getting stuck in the contract.  More specifically, there are two possible problematic scenarios, regarding the rewards accounting of the current and previous period relative to the time that a gauge is killed.  Effects on the currently active voting period. If a gauge is killed in the middle of a period, it's possible that this gauge has already been voted for by some users, so it already contributes to totalWeightPerEpoch, which is later used to compute the index for that period. As a consequence, the killed gauge's share will eventually remain stuck in the contract. In fact, totalWeightsPerEpoch should be updated when killing a gauge to discard the respective votes and distribute the whole $THE emissions amount to the remaining gauges.  Effects on the previous voting period. It is possible that a gauge is killed at a time when a voting period has been updated but the reward amounts have not been distributed yet. This is possible because updating the period and distributing the respective rewards to the gauges require two separate actions (period update and rewards distribution). In this scenario, the totalWeightsPerEpoch that has been used to compute index includes the killed gauge's weight, even if its share of rewards will not be attributed to it after it's killed. Thus its share will eventually remain unused and stuck in the VoterV3 contract.  When a gauge is killed, consider updating the totalWeightsPerEpoch value of the currently active voting period in order to distribute the whole reward amount to the remaining gauges. In addition, consider consolidating the reward amount notification and the distribution of the gauges' rewards into one single action in order to avoid losing part of the previous period's rewards when a gauge is killed.  Update: Partially resolved in pull request #3 at commit 7864885. The effects on the currently active voting period are handled by updating totalWeightPerEpoch when killing a gauge. Regarding the effects on the previous voting period, the Retro-Thena team stated:  We do not expect any gauge to be killed between a period update and rewards distribution because of our off-chain procedures that make sure to trigger the rewards distribution right after each period update.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#killing-a-gauge-could-result-in-stuck-funds", "labels": ["OpenZeppelin"]}, {"title": "Killed Gauge Can Be Voted For", "body": "temporary and  permanent removal of gauges in the case they are malicious. In order to track the state of a gauge, the  isAlive mapping will be set to either  During the voting phase, there only exists a check to see if the address is a gauge, which doesn't take into account if the gauge is still alive. This check will pass for any gauge temporarily killed, as a temporarily killed gauge will still reside in the isGauge mapping. This means users can vote for killed gauges.  Voting for killed gauges should not be allowed, as it results in reward tokens being allocated towards the gauge without any way to claim them. This means any votes for temporarily killed gauges will lock funds on the VoterV3 contract.  Consider removing the ability to vote from a killed gauge in order to avoid locking funds on the VoterV3 contract.  Update: Resolved in pull request #3 at commit 64bf6c5.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#killed-gauge-can-be-voted-for", "labels": ["OpenZeppelin"]}, {"title": "Users Can Be Locked From Voting", "body": "In the VoterV3 contract, users vote in order to receive rewards from gauges. During each epoch, rewards are reset and users need to vote again, either by calling the poke or vote functions. If a user does not vote in an epoch, they will not receive rewards. Votes do not roll over from epoch to epoch.  Through each method of voting, the _reset function is first called, clearing out the tokenId's previous vote allocation to the gauges. During this reset, internal and external bribes from the votes are cleared by calling the withdraw function of the Bribes contract.  However, if a gauge is destroyed via the killGaugeTotally function, these internal and external Bribes addresses will be cleared while leaving the poolVote mapping populated with votes for pools that are linked to non-existent gauges. This results in the withdraw calls reverting for any voter escrow token that contains uncleared votes for a gauge killed with killGaugeTotally.  Interestingly, these calls should fail during the gauges[_pool] lookup in the _withdraw execution, as that is supposed to be cleared during killGaugeTotally call, but due to another bug, this will return the killed gauge's address.  Similarly, this should be able to be remedied by creating a new gauge for the pool, but in the _createGauge function, there is a requirement for the gauges mapping to hold the zero address, which will not be the case due to the previously mentioned bug.  In order to avoid locking users out of voting, consider adding logic to avoid reverts during _reset calls to tokens which have outstanding votes to totally killed gauges.  Update: Resolved in pull request #3 at commit 35c01c8. The killGaugeTotally function has been completely removed.  Medium Severity", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#users-can-be-locked-from-voting", "labels": ["OpenZeppelin"]}, {"title": "GaugeExtraRewarder's Reward Rate Can Be Set to an Arbitrary Value", "body": "The owner of the GaugeExtraRewarder contract is able to set an arbitrary value as reward rate. However, the reward rate should always be calculated based on the existing reward amount and the distribution period otherwise inconsistent accounting is possible, resulting in unfair rewards distribution among the users.  Consider removing the function setRewardPerSecond and always using setDistributionRate instead in order to avoid inconsistent rewards accounting.  Update: Resolved in pull request #4 at commit e8b757f.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#gaugeextrarewarder's-reward-rate-can-be-set-to-an-arbitrary-value", "labels": ["OpenZeppelin"]}, {"title": "Reward Amount in GaugeExtraRewarder Can Be Overestimated", "body": "The function setDistributionRate of the GaugeExtraRewarder contract first checks that the contract's balance is sufficient to cover the notified reward amount. However, any remaining reward amount from the latest distribution period is not considered during this check, as it is added to the total distributed reward amount only after this check. As a consequence, the final reward amount to be distributed may exceed the contract's reserves.  Consider ensuring that the total reward amount can be covered by the contract's reserves.  Update: Resolved in pull request #4 at commit a1dc83f.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#reward-amount-in-gaugeextrarewarder-can-be-overestimated", "labels": ["OpenZeppelin"]}, {"title": "Wrong Accounting of Extra Rewards Upon Depositing to a Gauge", "body": "Liquidity providers that deposit their tokens to a gauge are entitled to a portion of the extra rewards, if there are any. The extra reward amount is handled by the GaugeExtraRewarder contract and is distributed to the users in proportion to their share of the total staked LP tokens. Thus, each time the total staked amount in the gauge changes (i.e. upon deposit or withdrawal) the extra-reward-per-share value needs to be updated appropriately.  the user's funds are first transferred to the contract and the  onReward function of the  is only called thereafter. The sequence of these two operations is wrong, leading to a miscalculation of  when updating the pool, because the gauge's balance has already been increased by the freshly deposited amount. As a consequence, the users might lose part of their reward.  Consider transferring the user's deposited funds only after calling the onReward function.  Update: Resolved in pull request #4 at commit da9df65.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#wrong-accounting-of-extra-rewards-upon-depositing-to-a-gauge", "labels": ["OpenZeppelin"]}, {"title": "Error-prone Contracts Initialization", "body": "The VoterV3 contract has two separate initialization functions, initialize and _init. It is possible for users to interact with this contract in the invalid state where the initialize function has been called but the _init function has not.  In addition, several other issues appear:  initialize sets minter and permissionRegistry equal to msg.sender. This is incorrect as neither of these contracts are supposed to initialize the Voter contract, nor should they be the same contract.  _init is required to be called by the minter or the permissionRegistry, though neither of these contracts supports this functionality.  On a similar note, the constructor of the PermissionsRegistry contract sets all three entities thenaTeamMultisig, thenaMultisig, and emergencyCouncil equal to msg.sender. While this is technically feasible (e.g. all three lie behind the same multisig), it seems unreasonable to have all three roles handled by the same entity.  Consider having a single initialization function for all upgradeable contracts and assigning reasonable values to the system's parameters during initialization, so the protocol can immediately function in a secure manner.  Update: Acknowledged, not resolved. The Retro-Thena team stated:  Users cannot interact with the protocol before _init is called. This is because createGauge would fail since no token will have been whitelisted yet and vote/reset/poke would also fail since the minter contract, used in _epochTimestamp, would point to an EOA. The msg.sender sets are because of the way we deploy the contracts. The minter (multisig, etc) can be set after deploying the VoterV3/PermissionRegistry contracts. Therefore, function _init must be called before actually going live.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#error-prone-contracts-initialization", "labels": ["OpenZeppelin"]}, {"title": "Risk-prone Accounting in GaugeExtraRewarder", "body": "The GaugeExtraRewarder contract tracks shares by updating internal tracking whenever the onReward function is called. This function is called from the underlying gauge whenever tokens are deposited or withdrawn.  not track the state changes, resulting in the internal accounting of the  Consider updating the accounting method of the GaugeExtraRewarder to accurately track shares on their associated gauge contracts. In order to save gas fees, it may be beneficial to piggyback off of the accounting done on the gauge rather than tracking everything in two places.  Update: Partially resolved in pull request #4 at commit 6b17ff7. The pause functionality for the GaugeExtraRewarder contract has been removed. The accounting method has not been altered, which requires that the users interact with the system when a \"GaugeExtraRewarder\" contract with extra reward amount is deployed in order to start accruing their extra reward share.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#risk-prone-accounting-in-gaugeextrarewarder", "labels": ["OpenZeppelin"]}, {"title": "gauges Mapping Cannot Be Cleared", "body": "deleted then later  retrieved and used as a key to clear the  gauges mapping. This retrieval will always return the zero address, resulting in the pool address never being cleared from the  Additionally, this results in the inability to create a new gauge for a pool whose gauge was killed totally, as the mapping will already have an address set for the given pool.  In order to avoid an invalid gauge state, consider correctly clearing the gauges mapping when killing a gauge totally.  Update: Resolved in pull request #3 at commit 35c01c8. killGaugeTotally has been completely removed.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#gauges-mapping-cannot-be-cleared", "labels": ["OpenZeppelin"]}, {"title": "Whitelist Is Incompatible With Proxies", "body": "The intention of the whitelist is to keep malicious contracts off of the protocol. When whitelisting upgradable contracts, it is possible for a formerly benign whitelisted contract to eventually upgrade into a malicious contract. Because of this, proxy contracts should never be whitelisted.  Consider removing any proxy contracts from the whitelist and introducing documentation around proxies in the whitelist code to avoid future proxies from being whitelisted.  Update: Acknowledged, not resolved. The Retro-Thena team stated:  We do due diligence on the whitelisted projects and we are in contact with them. Some projects (e.g., USDC) need a proxy.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#whitelist-is-incompatible-with-proxies", "labels": ["OpenZeppelin"]}, {"title": "Removing a Role Does Not Remove the Role From All Users", "body": "The removeRole function in the PermissionsRegistry contract allows the Thena multisig to remove roles from the PermissionsRegistry.  When removing roles, the role is removed from the _roles list, but does not remove that role's entries in the hasRole mapping.  typical access control using the  Consider removing all users from the role upon deletion of the role.  Update: Resolved in pull request #4 at commit 8b2b9c1.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#removing-a-role-does-not-remove-the-role-from-all-users", "labels": ["OpenZeppelin"]}, {"title": "Unfair Distribution of Rewards", "body": "In the VoterV3 contract, the _notifyRewardAmount function allows individuals to contribute to the next epoch's total rewards.  Reward distribution is calculated by directly increasing the index parameter. During an _updateFor call, which is called every time a vote is cast to a gauge, the rewards are allocated to the gauges when claimable is updated. Since _updateFor calculates the rewards based off of the current number of votes, the reward will be distributed in proportion to the snapshot of votes in the system when the funds were contributed.  This does not follow the rest of the protocol's calculations, where voters are given rewards at the end of the voting epoch and the votes' distribution is final. Additionally, this could lead to bizarre contributions where a user can contribute a large sum of rewards, but be the only voter in the epoch, resulting in all of the contributed funds being directed to them, signaling a large contribution but really not contributing anything.  In order to match other accounting done in the system and avoid the distribution of rewards based on intermediate voting state, consider changing the _notifyRewardAmount to distribute rewards at the end of the epoch rather than during one.  Update: Resolved in pull request #4 at commit 8f108fd. _notifyRewardAmount has been completely removed.  Low Severity", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unfair-distribution-of-rewards", "labels": ["OpenZeppelin"]}, {"title": "Invalid Entries Remain in _addressToRoles Array", "body": "The function removeRoleFrom of the PermissionsRegistry contract revokes a role from the specified address and is supposed to appropriately update the arrays _roleToAddresses and _addressToRoles.  However, because of a typographical error, the code never loops over the _addressToRoles array, resulting in invalid remaining entries.  Consider fixing the typographical error so that no invalid entries remain in the array.  Update: Resolved in pull request #5 at commit 95d8d25.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#invalid-entries-remain-in-_addresstoroles-array", "labels": ["OpenZeppelin"]}, {"title": "Unsigned Integer Variable Declared and Treated as a Signed Integer", "body": "The rewardDebt field of the Poolnfo struct in the GaugeRewarder contract is declared as a signed integer, though it can never hold a negative value as it is initialized to zero and is monotonically increasing. This leads to essentially unnecessary type casts and is also error-prone in consideration of future updates to the codebase.  Consider declaring variable rewardDebt as an unsigned integer.  Update: Resolved in pull request #5 at commit a2f45d0.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unsigned-integer-variable-declared-and-treated-as-a-signed-integer", "labels": ["OpenZeppelin"]}, {"title": "Unsafe ABI Encoding", "body": "It is not an uncommon practice to use abi.encodeWithSignature or abi.encodeWithSelector to generate calldata for a low-level call. However, the first option is not typo-safe and the second option is not type-safe. The result is that both of these methods are error-prone and should be considered unsafe.  On line 861 of VoterV3 an unsafe ABI encoding is used.  Consider replacing the unsafe ABI encoding with abi.encodeCall, which checks whether the supplied values actually match the types expected by the called function and also avoids errors caused by typos. Alternatively, consider changing the type of the token argument to an IERC20 so normal function calling syntax can be used.  Update: Resolved in pull request #5 at commit c3f6d95.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unsafe-abi-encoding", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings.  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Partially resolved in pull request #5 at commit 7ca7fc1.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "The System Is Not Robust to Delayed Period Updates", "body": "The major functionalities of the protocol (i.e., voting, reward emission, reward distribution) are synchronized on a per-voting-period basis, making the per-period consistency in bookkeeping and accounting a factor of major importance. However, the way that the current implementation refers to a voting period is rather brittle.  More specifically, the unique identifier of a period is its starting timestamp, which is calculated modulo a week's time. When calculating the rewards of a voting period that has ended, that period's id is retrieved by manually subtracting a week's seconds from the current active period's id. However, it is not strictly imposed by the codebase that the time interval between two periods is exactly one week but rather a multiple of a week's time. It is possible, for example, that a period update action continuously fails for longer than a full period. In such a case, it would not be possible to access the past period's data and any reward distribution action would fail silently, essentially locking the reward amount in the contract.  Consider introducing a status for each voting period's phase, so as to be able to distinguish non-existing period timestamps due to delayed updates. As a more radical solution, consider adopting a serial number for uniquely identifying the voting periods and making the period's starting timestamp a separate data entry. This would make the system robust to potential delayed period updates but would also help improve the codebase's readability and overall quality making it less error-prone during future upgrades.  Update: Acknowledged, not resolved. The Retro-Thena team stated:  We ensure that each epoch lasts 1 week and no delays are allowed.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#the-system-is-not-robust-to-delayed-period-updates", "labels": ["OpenZeppelin"]}, {"title": "Voting or Poking Emits Wrong Event", "body": "vote or  poke function in the  _reset which emits the  Hence, both Voted and Abstained events are emitted when a user votes. This could result in off-chain indexers computing the protocol state incorrectly.  Consider removing the Abstained event from the _reset function and only emitting it when a user abstains from voting.  Update: Acknowledged, not resolved. The Retro-Thena team stated:  We will keep it as it is in order to avoid the extra gas costs for loading the event variables to the reset function.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#voting-or-poking-emits-wrong-event", "labels": ["OpenZeppelin"]}, {"title": "Missing Error Messages in require Statements", "body": "Throughout the codebase, there are require statements that lack error messages. There are also some cases, for example line 244 in the GaugeV2 contract, where the error messages are undermined by checks that overflow or underflow.  Consider including specific, informative error messages in require statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied. In addition, consider appropriately modifying the checks of the require statements wherever needed, so that it is not possible to overflow or underflow.  Update: Partially resolved in pull request #5 at commit bd5dc9f and pull request #6 at commit a0eac56. There are still a few require statements that miss an error message.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#missing-error-messages-in-require-statements", "labels": ["OpenZeppelin"]}, {"title": "Code Simplifications", "body": "A number of opportunities for simplification of code were observed. Consider applying the following code simplifications:  Contracts GaugeV2 and GaugeV2_CL can be refactored so that a base contract contains the shared logic.  Line 123 of the GaugeExtraRewarder contract can be simplified as the first condition is already covered by the second.  The functions balanceOfAt, balanceOf, balanceOfOwner, and balanceOfOwnerAt can be refactored to consolidate shared logic.  The functions getReward and getReward in the GaugeV2 contract can be refactored to consolidate shared logic.  The functions earned, earned, and earnedWithTimestamp in the Bribes contract can be refactored to consolidate shared logic.  The functions getReward, getReward, getRewardForOwner, and getRewardForAddress in the Bribes contract can be refactored to consolidate shared logic.  In the _vote function of the VoterV3 contract, the _usedWeight variable contains the same value as _totalWeight is therefore redundant.  The conditions on lines 820-822 of the _updateFor function in the VoterV3 contract can be consolidated into a single if statement.  The functions _updateFor and _updateForAfterDistribution of the VoterV3 contract can be refactored to consolidate shared logic.  The function claimBribes on line 467 and claimFees on line 475 of the VoterV3 contract are identical.  The function claimBribes on line 483 and claimFees on line 490 of the VoterV3 contract are identical.  \u0399n line 366 and line 382 of the _reset function of the VoterV3 contract, there is a call to _epochTimestamp() but the value of _epochTimestamp() has already been stored in the _time variable.  The _reset function in the VoterV3 contract can be refactored as follows:   The if statement on line 370 is redundant as _votes is unsigned and resides inside the check on line 362   The calls to _withdraw on lines 371-372 are only meaningful when the token was last voted in the current active period. If these operations are performed only when this condition is met, the if statement on line 382 can be removed.  In the GaugeV2 contract, the variables fees0 and fees1 are only ever assigned to zero and are therefore redundant.  In the Bribes contract, the if statement on lines 131-133 is redundant, as this case is covered on lines 141-143.  In the Bribes contract, the IERC20Ext interface declaration is unused and can be removed.  In the PermissionsRegistry contract, the functions __helper_stringToBytes and __helper_bytesToString are unused and can be removed.  \u0399n lines 821 and 844 of the VoterV3 contract, the variable _supplied is cast to uint but is already declared as uint256.  The increaseGaugeApprovals function of the VoterV3 contract sets the allowance of _gauge by VoterV3 to type(uint256).max. However, the allowance is already set to type(uint256).max during the gauge creation and the approval will never decrease. Therefore, the increaseGaugeApprovals function is redundant.  Update: Partially resolved in pull request #5 at commit 541bd36. Most of the suggestions were not adopted.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#code-simplifications", "labels": ["OpenZeppelin"]}, {"title": "Lacking Address Checks", "body": "Across the repository, addresses are commonly saved into storage to be used later. When saving addresses, it is best practice to add basic checks to avoid accidentally setting these addresses to incorrect values.  In some cases, these addresses are expected to be set to the address of smart contracts. The best check for this case is using a code length check such as a library that provides an isContract function. Otherwise, a check to ensure the provided address is not the zero address is helpful.  Consider adding address checks to all addresses set in the codebase to help protect against the accidental setting of incorrect addresses.  Update: Resolved in pull request #5 at commit 0f1551f.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#lacking-address-checks", "labels": ["OpenZeppelin"]}, {"title": "No Events Emitted on Sensitive Operations", "body": "There are plenty of functions throughout the codebase that are only called by privileged entities and perform sensitive operations, yet emit no events. Whenever executing highly privileged actions on-chain, it is preferable to emit some sort of logging for easy tracking and increased visibility. Some examples of such sensitive actions include setting a role for an address in the PermissionsRegistry contract, setting a new owner in the Bribes contract, and activating emergency mode in the Gauge contracts.  Consider emitting informative events upon each sensitive operation taking place in the system.  Update: Resolved in pull request #5 at commit ebf6eaa and in pull request #10 at commit b369708.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#no-events-emitted-on-sensitive-operations", "labels": ["OpenZeppelin"]}, {"title": "Recover Function Can Stall Associated Gauge", "body": "The owner of a GaugeExtraRewarder can use the recoverERC20 function to move any ERC20 token from the contract. However, if an amount of the reward token is removed while there are active users, deposit and withdraw operations in the associated gauge contract can fail on the reward transfers due to low balance.  Consider excluding rewardToken when calling function recoverERC20, so as to restrict the owner to only be able to recover funds that have mistakenly been sent to the contract. If the reward token needs to remain recoverable for emergency cases, consider adding a require statement to ensure that the GaugeExtraRewarder contract is stopped before recovering the reward token from the contract.  Update: Resolved in pull request #9 at commit 748e153 and pull request #12 at commit 7693167. For the reward token, the owner can only recover up to the amount that has not yet been accounted for distribution. The Retro-Thena team stated:  The owner of the GaugeExtraRewarder contract is either the project that provides the extra reward amount or the Thena-Retro team.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#recover-function-can-stall-associated-gauge", "labels": ["OpenZeppelin"]}, {"title": "Invalid Votes Are Counted Towards a User's Vote Weight", "body": "line 428 of the  _vote function in the  Consider reverting when a user attempts to vote for an address that is a totally killed, or otherwise invalid gauge.  Update: Resolved in pull request #9 at commit 983da1f.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#invalid-votes-are-counted-towards-a-user's-vote-weight", "labels": ["OpenZeppelin"]}, {"title": "Unused Function Arguments", "body": "The onReward function in the GaugeExtraRewarder contract has two unused arguments: pid and extraData.  To improve the overall clarity, intentionality, and readability of the codebase, consider removing the unused function parameters. This would simplify the calling contract's code as well.  Update: Resolved in pull request #6 at commit 62a11ec.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unused-function-arguments", "labels": ["OpenZeppelin"]}, {"title": "Hardhat console Import Present", "body": "There is a Hardhat console import on line 17 in the VoterV3 contract.  Consider removing Hardhat debugging imports to improve the codebase's readability.  Update: Resolved in pull request #6 at commit 99574c5.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#hardhat-console-import-present", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "In the Bribes and VoterV3 contracts there are some imports that are unused and could be removed:  Import Math of contract Bribes  Import Ownable of contract Bribes  Import Math of contract VoterV3  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #6 at commit 0fc5de4.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused Event", "body": "In the GaugeExtraRewarder contract, the LogOnReward event is unused.  To improve the overall clarity, intentionality, and readability of the codebase, consider emitting or removing the unused event.  Update: Resolved in pull request #6 at commit 158db13.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unused-event", "labels": ["OpenZeppelin"]}, {"title": "Lack of Indexed Event Parameters", "body": "Throughout the codebase, several events do not have their parameters indexed. For instance:  Line 439 of Bribes.sol  Line 443 of Bribes.sol  Line 73 of VoterV3.sol  Consider indexing event parameters to improve the ability of off-chain services to search for and filter for specific events.  Update: Acknowledged, not resolved.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Per-period Deposits to a Gauge and Corresponding Rewards Are Not Aligned", "body": "The owners of LP tokens that deposit to a gauge are rewarded with Thena emissions. The reward amount is proportional to the amount of votes that the gauge receives. It is updated by the end of each voting period and is fully distributed within one week (i.e. until the next reward update). Each depositor is eligible for a portion of the reward in proportion to their share of the total deposits and the duration of their deposit with respect to the distribution period.  GaugeExtraRewarder contract.  Consider clearly documenting the misalignment between the depositors' per-period contribution and the corresponding rewards (and/or extra rewards) received. Also, consider documenting how the very first depositors in a gauge essentially receive no rewards by the end of the first period.  Update: Acknowledged, not resolved. The Retro-Thena team stated:  The gauges reward distribution is designed as a continuous streamline of rewards. We do not want to limit rewards to be distributed once per epoch as in the Bribes contracts. Before the creation of a new gauge, we provide an estimation of the expected rewards in the UI.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#per-period-deposits-to-a-gauge-and-corresponding-rewards-are-not-aligned", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent and Outdated Solidity Versions", "body": "Different versions of Solidity are used across the contracts. In some contracts, the solidity version is outdated whereas in others the solidity version is floating.  Selecting a Solidity version should always be based on what features each version has, what the codebase could benefit from, as well as the list of known bugs associated with each release. Be aware that compiling and deploying on BSC with 0.8.20 may not work properly as this version introduces a new opcode - PUSH0.  Consider taking advantage of the latest Solidity version to improve the overall efficiency and security of the codebase. Regardless of the Solidity version used, consider keeping it consistent and locking it throughout the codebase to prevent the introduction of bugs due to incompatible future releases.  Update: Resolved in pull request #6 at commit 406075d.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#inconsistent-and-outdated-solidity-versions", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Use of SafeMath Library", "body": "In some contracts, such as GaugeV2, GaugeV2_CL, and GaugeExtraRewarder, the protocol uses the OpenZeppelin SafeMath library for basic arithmetic functions, while using a compiler version above 0.8. However, solc versions above 0.8 contain built-in overflow and underflow protection.  To save gas and maintain consistency with the rest of the codebase, consider using Solidity's built-in arithmetic operators.  Update: Resolved in pull request #6 at commit a0eac56 and in pull request #8 at commit ba97a1d.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unnecessary-use-of-safemath-library", "labels": ["OpenZeppelin"]}, {"title": "Unused State Variables", "body": "The factory and gaugeFactory variables in VoterV3 contract are never used. As a result, their setter functions (setPairFactory, setGaugeFactory) are essentially dead code.  In addition, the TYPE variable and modifier onlyOwner in the Bribes contract are never used.  _VE and  external_bribe are unused in  _VE and  external_bribe in  Consider removing the unused variables and their corresponding setter functions. If the variables are kept to maintain storage layout consistency with previous versions of the contract, consider documenting this fact.  Update: Partially resolved in pull request #6 at commit d720e4f and in pull request #11 at commit d04de75. The Retro-Thena team stated:  Variable TYPE is just for UI and to recognize the contract's type from BscScan.  Variable _VE is just for having extra information in the gauge contract.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#unused-state-variables", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "Several variables, parameters and functions throughout the codebase might benefit from better naming. Specifically:  VoterV3.sol  All occurrences of _token representing an array should be renamed to _tokens.  All occurrences of _poolVote representing an array should be renamed to _poolVotes.  totWeightsPerEpoch could be more clearly be totalWeightsPerEpoch.  The blacklist functions could be renamed removeFromWhitelist for more clarity.  gaugesDistributionTimestmap should be renamed gaugeDistributionTimestmap.  isAlive could be isGaugeAlive.  isFactory could be isPairFactory.  GaugeExtraRewarder.sol  stop could be more clearly named paused.  lastDistributedTime could be endOfDistributionPeriod or something similar.  Function onReward could be claimReward.  The parameter lpToken of the onReward function could be userBalance or something similar.  Function setDistributionRate could be updateRewardRate.  Privileged entities thenaMultisig and thenaTeamMultisig could be given more descriptive names or docstrings that designate their distinct responsibilities.  GaugeV2.sol and GaugeV2_CL.sol  DISTRIBUTION address should be named voter and its related modifier onlyDistribution should be named onlyVoter.  Bribes.sol  addRewards could be named addRewardTokens. The same applies to functions addReward and _addReward in the same contract.  Update: Partially resolved in pull request #6 at commit d720e4f. The Retro-Thena team stated:  DISTRIBUTION: this is correct, the gauge is \"standard\" for any distributor and does not depend on voter.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit Imports Are Used", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code, and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are being used.  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged, not resolved.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "The following typographical errors have been discovered:  Lines 221-225 in the Bribes contract`: \"timestmap\" should be \"timestamp\".  Lines 111 and 117 in the Bribes contract: \"of a owner\" should be \"of an owner\".  Lines 53, 763 and 773 in the VoterV3 contract: \"gaugesDistributionTimestmap\" should be \"gaugesDistributionTimestamp\".  Line 182 in the GaugeV2_CL contract: \"sinle\" should be \"single\".  Line 146 in the MinterUpgradeable contract: function calculate_rebate should be calculate_rebase.  Update: Resolved in pull request #6 at commits ecd3134 and d720e4f.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Underscores Conflict with Solidity Style Guide", "body": "The Solidity Style Guide includes a section on how to use underscore prefixes for non-external functions and variables. Throughout the repository, publicly accessible functions and variables are incorrectly named with leading underscores. For instance:  IBribe.sol  function _deposit(uint amount, uint tokenId) external function _withdraw(uint amount, uint tokenId) external  Bribes.sol  function _deposit(uint256 amount, uint256 tokenId) external function _withdraw(uint256 amount, uint256 tokenId) public mapping(uint256 => uint256) public _totalSupply  IVoter.sol  function _ve() external  VoterV3.sol  function _init(address[] memory _tokens, address _permissionsRegistry, address _minter) external function _factories() external function _gaugeFactories() external function _notifyRewardAmount(uint amount) external function _epochTimestamp() public address public _ve  GaugeV2.sol  function _periodFinish() external IERC20 public _VE uint256 public _totalSupply mapping(address => uint256) public _balances  GaugeV2_CL.sol  function _periodFinish() external IERC20 public _VE uint256 public _totalSupply mapping(address => uint256) public _balances  PermissionsRegistry.sol  function __helper_stringToBytes(string memory _input) public function __helper_bytesToString(bytes memory _input) public  Consider fixing all instances of prefixed underscores that conflict with the Solidity Style Guide.  Update: Resolved in pull request #6 at commit 65d8936 and in pull request #8 at commit 200ba8b.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#underscores-conflict-with-solidity-style-guide", "labels": ["OpenZeppelin"]}, {"title": "Redefinition of Solidity Constants", "body": "In numerous places, hardcoded units of time are used rather than the native solidity constants for units of time.  The number 604800 is used instead of 1 weeks:  On line 689 of the VoterV3 contract  On line 835 of the VoterV3 contract  The number 86400 is used instead of 1 days:  On line 878 of the VoterV3 contract  On line 31 of the RewardsDistributor contract  On line 53 of the GaugeExtraRewarder contract  On line 90 of the GaugeV2 contract  On line 94 of the GaugeV2_VL contract  Consider using Solidity's built-in numeric constants instead of hardcoded numbers in order to improve the clarity of the codebase.  Update: Resolved in pull request #6 at commit 47aa201 and in pull request #11 at commit b36ad41.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#redefinition-of-solidity-constants", "labels": ["OpenZeppelin"]}, {"title": "Mutable Variables Never Assigned or Only Assigned Once", "body": "The following variables in the Bribes contract are only assigned once and can be declared immutable:  bribeFactory  ve  The following variables in the GaugeV2 contract are only assigned once and can be declared immutable:  DURATION  TOKEN  isForPair  rewardToken  The following variables in the GaugeV2_CL contract are only assigned once and can be declared immutable:  DURATION  TOKEN  rewardToken  The following variables in the GaugeExtraRewarder contract are never assigned and can be declared constant:  ACC_TOKEN_PRECISION  distributePeriod  Consider declaring variables that are never assigned as constant and variables that are assigned only once as immutable.  Update: Resolved in pull request #6 at commit 7626d97.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#mutable-variables-never-assigned-or-only-assigned-once", "labels": ["OpenZeppelin"]}, {"title": "Incorrect or Misleading Documentation", "body": "On line 114 of the GaugeV2_CL contract, the comment reads \"GaugeProxyL2\" but the distribution address should be that of the VoterV3 contract.  On line 305 of the VoterV3 contract, the comment reads \"Revive a malicious gauge\" but should read \"Revive a killed gauge\" as there is no reason to revive an actively malicious gauge.  On lines 11 and 14 of the PermissionsRegistry contract, the comments suggest that thenaMultisig and thenaTeamMultisig have the same responsibilities and these responsibilities relate to this contract only, while neither is true.  Consider correcting the incorrect or misleading documentation.  Update: Resolved in pull request #6 at commits 86a013e and d720e4f.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#incorrect-or-misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Mixed Use of uint and uint256", "body": "Across the codebase, both uint and uint256 keywords are used to declare unsigned integers of 256 bits in length.  To favor explicitness, consider standardizing all instances to uint256.  Update: Partially resolved in pull request #6 at commit aa2a0f6 and in pull request #11 at commit 4b654a5. There are a few cases where uint is still used.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#mixed-use-of-uint-and-uint256", "labels": ["OpenZeppelin"]}, {"title": "Code Execution Continues When It Should Revert", "body": "In the VoterV3 contract, both attachTokenToGauge and detachTokenFromGauge continue if the checks around tokenId > 0 are not satisfied. In this case, the token is not attached and the overall operation fails.  Consider reverting in the case of a failed operation to better convey the failure to the user.  Update: Resolved in pull request #6 at commit 51711b4. The functions attachTokenToGauge and detachTokenFromGauge have been removed completely.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#code-execution-continues-when-it-should-revert", "labels": ["OpenZeppelin"]}, {"title": "Uncalled External Functions", "body": "In the VoterV3 contract, the functions attachTokenToGauge and detachTokenFromGauge require that the caller be a contract in the isGauge mapping. However, neither of the gauge implementations calls this function.  If these functions are unnecessary, consider removing them.  Update: Resolved in pull request #6 at commit 51711b4.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#uncalled-external-functions", "labels": ["OpenZeppelin"]}, {"title": "Client Reported", "body": "Client Reported", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#client-reported", "labels": ["OpenZeppelin"]}, {"title": "Emergency Mode Cannot Be Deactivated in Gauges", "body": "Because of a typographical error in the stopEmergencyMode function of the contracts GaugeV2 and GaugeV2_CL, once the emergency mode has been activated it can no longer be deactivated.  Update: Resolved in pull request #7 at commit 22b1207.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#emergency-mode-cannot-be-deactivated-in-gauges", "labels": ["OpenZeppelin"]}, {"title": "_gaugeRewarder Cannot Be Reset to Zero", "body": "setGaugeRewarder function in the  _deposit,  _withdraw, and the  _getReward  functions check the  Update: Resolved in pull request #7 at commit a5da2a2.", "html_url": "https://blog.openzeppelin.com/retro-thena-audit#_gaugerewarder-cannot-be-reset-to-zero", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings. For example:  Line 18 in IRouterHelper.sol  Line 20 in IRouterHelper.sol  Line 14 in RouterHelper.sol  Line 269 in RouterHelper.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #281 at commits 394d1a7 and 9751c85. The functions were documented in their definitions in the contracts instead of their declarations in the interfaces.", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Locked BNB in Contract", "body": "There are multiple occurrences in SwapRouter.sol where ETH can become locked. For instance:  swapExactTokensForBNBAndRepay  swapExactTokensForBNBAndRepayAtSupportingFee  swapTokensForExactBNBAndRepay  swapTokensForFullBNBDebtAndRepay  Consider removing the payable attribute or adding a withdrawal feature.  Update: Resolved in pull request #281 at commit 7a8044a.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#locked-bnb-in-contract", "labels": ["OpenZeppelin"]}, {"title": "Misleading Docstrings", "body": "Line 811 in SwapRouter.sol states that the function checks if the value is \"greater than\" when it actually checks if the value is \"greater or equal to\".  Consider correcting this docstring.  Update: Resolved in pull request #281 at commit 20e3118.", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#misleading-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Naming Can Be Improved", "body": "In line 16 of CustomErrors.sol, the second parameter is named currentBlock even though the value actually contains timestamp.  In line 29 of TransferHelper.sol, TransferFromFailed can be renamed to SafeTransferFromFailed, making it consistent with other similar error names.  In lines 269 and 293 of SwapRouter.sol, swapAndRepay and swapAndRepayAtSupportingFee can be renamed to swapExactTokensForTokensAndRepay and swapExactTokensForTokensAndRepayAtSupportingFee, making them consistent with other similar function names.  Consider amending the aforementioned names for clarity and consistency.  Update: Resolved in pull request #281 at commit 027835e.", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#naming-can-be-improved", "labels": ["OpenZeppelin"]}, {"title": "Some Convenience Functions Are Missing", "body": "The SwapRouter contract has functions to facilitate supply and repay operations for ERC-20 tokens. However, some of the functions are missing.  Here are some examples of missing functions, although this is not an exhaustive list.  swapExactTokensForBNBAndSupply  swapExactTokensForBNBAndSupplyAtSupportingFee  swapTokensForExactBNBAndSupply  swapTokensForExactBNBAndSupplyAtSupportingFee  Consider adding them to offer more convenience functions to the users.  Update: Resolved in pull request #281 at commits fb66414 and cf6b8cb. All the suggested functions were implemented with the exception of swapTokensForExactBNBAndSupplyAtSupportingFee. The Venus team stated:  New functions added to the SwapRouter contract:  swapExactTokensForBNBAndSupply  swapExactTokensForBNBAndSupplyAtSupportingFee  swapTokensForExactBNBAndSupply  We cannot implement swapTokensForExactBNBAndSupplyAtSupportingFee as swapTokensForExactBNBAtSupportingFee does not exist in the RouterHelper because getting the amount of the tokens (with fees on transfer) to swap for an exact amount of BNB is not possible.", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#some-convenience-functions-are-missing", "labels": ["OpenZeppelin"]}, {"title": "Confusing Use of ETH and BNB in Comments and Function Names", "body": "BNB and ETH are referenced multiple times interchangeably throughout the codebase. For example, in lines 129, 154, 221, and 241. The actual deployment will be on BSC and ETH mentions are a result of PancakeSwap being a Uniswap fork.  To increase the clarity of the codebase, consider changing all mentions of ETH to BNB.  Update: Resolved in pull request #281 at commits bbe298f, 9751c85, and dbf855c.", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#confusing-use-of-eth-and-bnb-in-comments-and-function-names", "labels": ["OpenZeppelin"]}, {"title": "Lack of SPDX License Identifiers", "body": "Throughout the codebase, there are files that lack SPDX license identifiers. For instance:  IRouterHelper.sol  SwapRouter.sol  CustomErrors.sol  IPancakePair.sol  IPancakeSwapV2Factory.sol  IPancakeSwapV2Router.sol  IVBNB.sol  IVtoken.sol  InterfaceComptroller.sol  PancakeLibrary.sol  To avoid legal issues regarding copyright and follow best practices, consider adding SPDX license identifiers to files as suggested by the Solidity documentation.  Update: Resolved in pull request #281 at commit 8b08294.", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#lack-of-spdx-license-identifiers", "labels": ["OpenZeppelin"]}, {"title": "PancakeRouter Functions' Code Can Be Reused", "body": "The SwapRouter contract adapts the swap router logic from the PancakeRouter contract. It also adds code that operates either before or after a swap. The adapted code increases the complexity of the SwapRouter contract which makes it more prone to potential bugs.  Consider calling the PancakeRouter functions instead of adapting their code to the SwapRouter contract.  Update: Acknowledged, not resolved. The Venus team stated:  Our PancakeRouter contract uses a newer Solidity version and reverts with custom errors instead of require statements. We prefer to maintain and use our version.", "html_url": "https://blog.openzeppelin.com/venus-protocol-swaprouter-audit#pancakerouter-functions'-code-can-be-reused", "labels": ["OpenZeppelin"]}, {"title": "Outdated Chainlink Interface", "body": "line 201 of ChainlinkOracle, the interface  its documentation. This prevents the usage of deprecated functions in the  Consider updating the interface used in the ChainlinkOracle from AggregatorV2V3Interface to AggregatorV3Interface.  Update: Resolved in pull request #84 at commit ddd4b02.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#outdated-chainlink-interface", "labels": ["OpenZeppelin"]}, {"title": "Misleading Documentation", "body": "The following documentation is misleading:  Line 83 of BoundValidator says \"range error thrown if lower bound is greater than upper bound\" instead of \"range error thrown if lower bound is greater than or equal to upper bound\".  Line 18 of TwapOracle says that the baseUnit signifies the \"decimals of the underlying asset\", but it actually takes the value of 1e{decimals} of the asset.  Line 25 of TwapOracle says that \"XVS-WBNB is not reversed, while WBNB-XVS is\", when in reality the opposite is true.  Consider updating these misleading comments to match the code's intention.  Update: Resolved in pull request #84 at commit f4352f1.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Constants Not Using UPPER_CASE Format", "body": "In TwapOracle.sol the following constants are not using UPPER_CASE format:  The bnbBaseUnit constant declared on line 47  The busdBaseUnit constant declared on line 48  According to the Solidity Style Guide, constants should be named with all capital letters with underscores separating words. For better readability, consider following this convention.  Update: Resolved in pull request #84 at commit 70a2211.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#constants-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "Lack of Idiomatic Code Layout", "body": "According to the Solidity Style Guide, elements inside of contracts, libraries, and interfaces should be in the following order: type declarations, state variables, events, errors, modifiers, and finally functions.  In addition, the guide states that \"functions should be grouped according to their visibility and ordered\" first by the constructor, followed by the receive function (if it exists), the fallback function (if it exists), public functions, internal functions, and finally private functions. In addition, since the contracts are implementation contracts, it is idiomatic to place the initialize function directly below the constructor.  Throughout the codebase, the layouts of the files do not follow the Solidity Style Guide and are not consistent with each other. Consider moving the modifiers, events, errors, and functions in these files to match the Solidity Style Guide.  Update: Acknowledged, not resolved. The Venus team stated:  Ignoring the Pyth Interface because it was copied from the original project and linting would make the diff more complicated when updating.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#lack-of-idiomatic-code-layout", "labels": ["OpenZeppelin"]}, {"title": "Superfluous Casting", "body": "line 305 and  line 307 of  In addition, in lines 182 and 207, the value 18 is unnecessarily cast with the uint256 keyword.  Consider removing the superfluous casting in order to improve the readability of the codebase.  Update: Resolved in pull request #84 at commit 66707bd.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#superfluous-casting", "labels": ["OpenZeppelin"]}, {"title": "Global Namespace Pollution", "body": "In BoundValidator, ChainlinkOracle, PythOracle, and TwapOracle, there are structs defined outside of the contracts and therefore in the global namespace. This pattern is used when there are multiple contract implementations within one source file that need to reference the same structs. However, in these files in the codebase, there is only one implementation contract per file, so this methodology is unnecessary.  Consider either placing these structs inside the contracts' definitions or within the corresponding interfaces to reduce global namespace pollution.  Update: Resolved in pull request #84 at commit 28f4924.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#global-namespace-pollution", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "To favor explicitness and readability, the following locations in the contracts may benefit from better naming:  The interface file names as well as the interfaces themselves could take the format of I{...} as opposed to {...}Interface. For example, VBep20Interface.sol could be named IVBep20.sol.  In ResilientOracle:  The struct field enableFlagsForOracles could be renamed to isEnabled. The function enableOracle could be changed to updateOracleEnablement to reflect both the enablement and disablement of the oracle. The function updatePrice could be changed to updatePivotPrice to provide clarity as to which oracle is being updated. The state variable tokenConfigs could be changed to _tokenConfigs since it is a private variable.  In BinanceOracle:  The variable decimalDelta could be renamed to decimals to avoid confusion with other parts of the codebase, as decimalDelta typically refers to the value 18 - decimals. The function compare could be renamed to _compare since it is an internal function.  In BoundValidator:  The struct ValidateConfig could be renamed to ValidatorConfig or BoundValidatorConfig for consistency.  In TwapOracle:  The struct field isBnbBased could be renamed to isWbnbBased. The function pokeWindowValues could be renamed to _pokeWindowValues since it is an internal function.  Consider renaming as suggested above to improve the consistency and readability of the codebase.  Update: Acknowledged, not resolved. The Venus team stated:  We prefer to reduce the number of changes.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Ungraceful Handling of Function Call", "body": "_getUnderlyingAsset in  getUnderlyingPrice in  _getUnderlyingAsset in  setUnderlyingPrice and  _getUnderlyingPriceInternal in  getUnderlyingPrice in  _getUnderlyingAsset in  Consider handling these cases gracefully using try-catch and returning descriptive error messages.  Update: Acknowledged, not resolved. The Venus team stated:  We prefer to reduce the number of changes.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#ungraceful-handling-of-function-call", "labels": ["OpenZeppelin"]}, {"title": "Extraneous virtual and Visibility Keywords", "body": "Throughout the codebase, there are extraneous virtual and visibility keywords. From what is understood, there are no plans to inherit from existing contracts. Thus, it is best practice to limit the scope to what is designed, thereby removing extraneous virtual keywords and using more restrictive visibility keywords.  Places with unnecessary virtual keywords:  In BoundValidator, in the functions setValidateConfigs, setValidateConfig, and validatePriceWithAnchorPrice  In TwapOracle, in the function _updateTwapInternal  Places with unnecessary internal keywords (replace with private):  In ResilientOracle, in the functions _getMainOraclePrice, _getFallbackOraclePrice and _getUnderlyingAsset  In BinanceOracle, in the function compare  In BoundValidator, in the functions _isWithinAnchor and _getUnderlyingAsset  In ChainlinkOracle, in the functions _getUnderlyingPriceInternal and _getChainlinkPrice  In TwapOracle, in the functions _updateTwapInternal, pokeWindowValues, and _getUnderlyingAsset  Places with unnecessary public keywords (replace with external):  In ResilientOracle, in the function initialize  In BinanceOracle, in the functions initialize and getUnderlyingPrice  In BoundValidator, in the functions initialize and validatePriceWithAnchorPrice  In ChainlinkOracle, in the functions initialize and getUnderlyingPrice  In PythOracle, in the functions initialize and getUnderlyingPrice  In TwapOracle, in the functions initialize and updateTwap  Consider removing extraneous virtual keywords and using more restrictive visibility keywords following the recommendations above.  Update: Resolved in pull request #84 at commit e11f135.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#extraneous-virtual-and-visibility-keywords", "labels": ["OpenZeppelin"]}, {"title": "Multiple Contract Declarations per File", "body": "In the file PythInterface, there is a contract PythStructs, an interface IPyth, and an abstract contract AbstractPyth. To improve understandability and readability for developers and reviewers, it is recommended to include one contract or interface per file.  The contract PythStructs contains no functions, and only two structs. Consider moving these structs into PythOracle. Consider removing AbstractPyth completely, since no contracts inherit it.  The file PancakeLibrary also contains more than one library and interface declaration in the same file. Consider separating the interface and libraries into their own files to improve the readability of the codebase.  Update: Acknowledged, not resolved. The Venus team stated:  We prefer to reduce the number of changes.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#multiple-contract-declarations-per-file", "labels": ["OpenZeppelin"]}, {"title": "Code Redundancy", "body": "We recommend the following high-level refactors to improve the readability, composability and overall quality of the codebase:  In the ResilientOracle contract, the _getFallbackOraclePrice and _getMainOraclePrice functions have very similar code. They can be consolidated into one function to prevent changes in two different places, which increases the space for error in future changes to the codebase.  The _getUnderlyingAsset function is very similar or the same in many contracts, such as ResilientOracle and BoundValidator. Consider moving this functionality to a separate library.  Similarly, the setTokenConfigs and setTokenConfig functions in the ResilientOracle, ChainlinkOracle, TwapOracle, and PythOracle are practically the same and can be moved to a library.  The setDirectPrice and setUnderlyingPrice functions in the ChainlinkOracle contract share almost all their functionality. The setDirectPrice function could be called from the setUnderlyingPrice function after looking up the asset address from the vToken address, or alternatively an internal _setPrice(asset) function that is called from both functions could be introduced.  Update: Acknowledged, not resolved. The Venus team stated:  We prefer to reduce the number of changes.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#code-redundancy", "labels": ["OpenZeppelin"]}, {"title": "Duplicated Event Parameter", "body": "PricePosted event defined has four fields. This event is only used in  line 80 and  line 95. Since in both cases the last two fields (  Update: Resolved in pull request #84 at commit 5d811fd.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#duplicated-event-parameter", "labels": ["OpenZeppelin"]}, {"title": "Incomplete Event Emissions", "body": "The following suggestions are provided to improve the ability of off-chain services to search and filter for specific events:  The PythOracleSet event in the PythOracle contract should emit both the old and new oracle addresses. In the initializer function, it should emit (0, underlyintPythOracle_) and in the setUnderlyingPythOracle function it should emit (old, new), similar to the PricePosted event of the ChainlinkOracle contract, which emits both the old and new oracle price.  The BatchPriceFeedUpdate event in PythInterface does not have any parameters indexed. The chainId field could be indexed.  Update: Partially resolved in pull request #84 at commit cf6a66c. Regarding the first bullet point, the Venus team updated the PythOracleSet event to emit both the old and new oracle addresses. Furthermore, the initializer and setUnderlyingPythOracle functions, which emit this event, have been updated correspondingly. Regarding the second bullet point, the Venus team stated:  Ignoring the Pyth Interface because it was copied from the original project and linting would make the diff more complicated when updating.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#incomplete-event-emissions", "labels": ["OpenZeppelin"]}, {"title": "Lack of Input Validation", "body": "We recommend implementing the following input validations:  In the setOracle function of the ResilientOracle contract, it is advisable to check that for non-MAIN oracles (i.e., PIVOT and FALLBACK), the specified address is different from the MAIN oracle address.  In the setTokenConfig function of the ResilientOracle contract, there are currently no checks in place to ensure that a new configuration does not override an existing one. To address this, it is recommended to verify that the existing token asset address in the tokenConfigs is a zero address. By implementing this validation, updating the oracle for a specific token would only be possible through the setOracle and enableOracle functions, reducing the likelihood of errors.  While this issue does not pose a security risk, the absence of validation on user-controlled parameters may lead to erroneous transactions, particularly if some clients default to sending null parameters when none are specified.  Update: Acknowledged, not resolved. The Venus team stated:  These functions will be executed via Governance, with a timelock of 3 days, and the vote of the community, so there should not be errors in the inputs.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Magic Constant", "body": "The usage of the constant 100e16 on line 123 of BoundValidator.sol lacks sufficient explanation regarding its origin and purpose.  Developers should define a constant variable for every magic value used (including booleans), giving it a clear and self-explanatory name. Additionally, for complex values, inline comments explaining how they were calculated or why they were chosen are highly recommended.  Consider following the Solidity Style Guide to define the constant in UPPER_CASE_WITH_UNDERSCORES format with the corresponding specific public getter to read it.  Update: Partially resolved in pull request #84 at commit c420a18. The Venus team stated:  Mitigated. We added a comment to explain why the multiplication by the constant 1e18 is needed.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#magic-constant", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Repeated Fields in Structs", "body": "ResilientOracle,  TwapOracle,  PythOracle, and  ChainlinkOracle define a  A similar pattern can be observed in the ValidateConfig struct within the BoundValidator contract.  To optimize storage and avoid redundant data, it is recommended to remove the asset field from the structs. Instead, consider utilizing an existing field within the struct or introducing a boolean field to check the configuration's validity.  Update: Acknowledged, not resolved. The Venus team stated:  We prefer to reduce the number of changes.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#unnecessary-repeated-fields-in-structs", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Variable Initialization in initialize", "body": "The boundValidator variable in the ResilientOracle contract is currently set in the initialize function. However, since this variable remains unchanged after initialization, it can be optimized by declaring it as an immutable variable in the constructor.  By making boundValidator immutable, initialization inconsistencies can be avoided, and gas costs can be reduced when accessing it. This is especially beneficial when calling the getUnderlyingPrice function, where accessing boundValidator may occur up to three times.  To improve efficiency and maintain consistency, consider declaring boundValidator as an immutable variable in the constructor of the ResilientOracle contract.  Update: Resolved in pull request #84 at commit 4f56661.", "html_url": "https://blog.openzeppelin.com/venus-protocol-oracles-audit#unnecessary-variable-initialization-in-initialize", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Ordering of Votes", "body": "GovernorCountingFractional.sol, the  ProposalVote struct is defined in the following order:  OpenZeppelin's contracts library as well as in  Compound's Bravo.  _countVote function requires a different order:  In the interest of improving clarity and being less error-prone, consider changing the order of the voteData to require votes in the originally-defined order (againstVotes, forVotes, abstainVotes).  Update: Resolved in pull request #40 at commit 8bea587.", "html_url": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit#inconsistent-ordering-of-votes", "labels": ["OpenZeppelin"]}, {"title": "Change Quorum to Account for Abstain Votes", "body": "The COUNTING_MODE function in the GovernorCountingFractional contract sets the quorum to bravo, meaning that only the For votes are counted to reach the quorum.  Consider changing the quorum to for,abstain to be consistent with OpenZeppelin's GovernorCountingSimple contract.  Update: Resolved in pull request #41 at commit 450b444.", "html_url": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit#change-quorum-to-account-for-abstain-votes", "labels": ["OpenZeppelin"]}, {"title": "Incomplete Docstrings", "body": "Although docstrings are present above the _countVoteNominal and _countVoteFractional functions, they do not provide complete information about the purpose of these functions and the parameters passed to them.  Since the GovernorCountingFractional contract supports rolling votes, once an address has cast a portion of its votes using the _countVoteFractional function, the subsequent votes should be cast by calling the _countVoteFractional function again, even if the votes are in favor of only one option.  Consider adding proper docstrings to the functions, following the NatSpec format, stating the scenarios in which these functions should be called, and mentioning their limitations.  Update: Resolved in pull request #42 at commit c19467a.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit#incomplete-docstrings", "labels": ["OpenZeppelin"]}, {"title": "OpenZeppelin Imports in Incorrect Format", "body": "In GovernorCountingFractional.sol, the current format for importing OpenZeppelin files is import {SomeContract} from \"openzeppelin-contracts/...\". With the current import statement, developers who are using this contract (particularly those who are not using Foundry as their smart contract development toolchain) may run into compilation errors when trying to integrate. For ease of consumption, consider changing the imports' format to import {SomeContract} from \"@openzeppelin/contracts/...\" as described in the OpenZeppelin documentation.  Update: Resolved in pull request #45 at commit 540cf75.", "html_url": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit#openzeppelin-imports-in-incorrect-format", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "To enhance explicitness and readability, there are several areas in the contract that could benefit from more precise and descriptive naming:  The proposalvote variables on line 77 and line 86 are inconsistent with proposalVote, which has camel case and is prevalent both in OpenZeppelin's contracts as well as elsewhere in this contract. Consider renaming it to proposalVote for consistency.  The weight variables on line 107, line 130, and line 159 are not explicit about which weight they are referring to. Consider renaming them to totalWeight for clarity.  The safeWeight variable is not explicit about which safeWeight it is referring to. For more clarity, consider renaming it to safeTotalWeight.  Update: Resolved in pull request #43 at commit 17b820f.", "html_url": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Remove Unnecessary Comments", "body": "To improve readability, consider removing the following comments related to the Foundry forge format:  Lines 6 and 7 of the GovernorCountingFractional contract  Line 207 of the GovernorCountingFractional contract  Update: Resolved in pull request #44 at commit c3bf318.", "html_url": "https://blog.openzeppelin.com/scopelift-flexible-voting-audit#remove-unnecessary-comments", "labels": ["OpenZeppelin"]}, {"title": "Data feeds may be outdated", "body": "Chainlink's documentation recommends validating that prices returned by their feeds are recent and fall within reasonable bounds. The  OracleRouterBase and the  OETHOracleRouter contracts do not validate these properties directly, although the vault  independently requires the price to be within 30% of the expected value. In addition, consider confirming the  updatedAt parameter is suitably recent to ensure users can mint and redeem OUSD and OETH tokens at a reasonable market price.  Update: Resolved in pull request #1491 at commit 9cc9626.  Low Severity", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#data-feeds-may-be-outdated", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "Throughout the codebase there are several parts that do not have docstrings. For instance:  Line 9 in OracleRouter.sol  Line 57 in OracleRouter.sol  Line 77 in OracleRouter.sol  Line 125 in OracleRouter.sol  Line 156 in OracleRouter.sol  Line 159 in OracleRouter.sol  Line 191 in VaultAdmin.sol  Line 750 in VaultCore.sol  In addition, the initialize function of the ConvexEthMetaStrategy contract is missing the @param comment for its _ptokens parameter.  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #1493 at commit 1e6e230.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary token allowance", "body": "The ConvexEthMetaStrategy contract grants an allowance for the Curve pool to spend all WETH tokens. This allowance can also be renewed by the governor. However, the pool accepts ETH directly and never interacts with the WETH token.  In the interest of limiting the attack surface, consider removing this unnecessary allowance.  Update: Resolved in pull request #1494 at commit 1be6d8.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#unnecessary-token-allowance", "labels": ["OpenZeppelin"]}, {"title": "Minting is still possible even if redemptions are not", "body": "When redeeming OUSD or OETH, the corresponding amount of each collateral token is calculated. The operation will fail if any of the tokens drift too far from the expected price. However, when minting new OUSD or OETH, only the deposited collateral needs to be within the acceptable range. This introduces the possibility that users can deposit funds but will be unable to withdraw them.  In the interest of predictability, consider preventing deposits unless all collateral tokens are redeemable. This would help ensure that deposits and withdrawals are enabled and disabled together during unexpected market conditions.  Update: Acknowledged, not resolved. The Origin team stated:  For code simplicity, OUSD/OETH prioritizes protecting the protcool over protecting interacting users. If a user mints with a non-depegged coin when another coin is depegged, this is a benefit for the protocol.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#minting-is-still-possible-even-if-redemptions-are-not", "labels": ["OpenZeppelin"]}, {"title": "Imbalanced token transfers", "body": "The ConvexEthMetaStrategy contract invests the exact deposit amount but withdraws at least the withdrawal amount. This discrepancy means there could be stray ETH remaining in the contract after each withdrawal. Although this ETH is accounted for in the contract balance, it won't be utilized until an administrator invokes the withdrawAll function.  Consider accounting for the contract balance when deciding how many LP tokens to redeem, so that any stray ETH is automatically reused.  Update: Acknowledged, not resolved. The Origin team stated:  Acknowledged. We prefer the contract simplicity and gas reduction of the current method, and are okay having extremely small amounts of dust on the contract that can be cleaned up later.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#imbalanced-token-transfers", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent asset variables", "body": "are set and then the new token variables are  redundantly set. If the contract is initialized with multiple asset pairs, or another asset/platform token pair is  added, the existing  removed, the  A similar observation applies to the ConvexEthMetaStrategy contract, which has variables for WETH and the LP token, even though they are also recorded as the asset and platform token. In this case, the redundant variable will not be overwritten if a new pair of tokens is added, but the other inconsistencies still apply.  In the interest of consistency and predictability, consider using the existing variables to track the asset and share tokens, instead of introducing new ones. The _abstractSetPToken function can be used to ensure there is at most one active asset-share token pair.  Update: Acknowledged, not resolved. The Origin team stated:  Acknowledged. In Generalized4626Strategy, we feel that the redundancy in the variables improves the code's comprehensibility.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#inconsistent-asset-variables", "labels": ["OpenZeppelin"]}, {"title": "Indefinite allowances", "body": "The Generalized4626Strategy and ConvexEthMetaStrategy contracts both approve token allowances for their respective platform contracts. They also include a mechanism for the governor to refresh those allowances. However, there is no mechanism to revoke the allowances if the platform becomes untrustworthy.  Consider allowing the governor to revoke all token allowances.  Update: Acknowledged, not resolved. The Origin team stated:  Funds that are moved to strategies by the vault are immediately deposited to the backing strategy. Because of this, having long-running approvals for the backing strategy is not a concern, since those backing strategies either already have the strategy's funds, or the strategy is empty except for dust.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#indefinite-allowances", "labels": ["OpenZeppelin"]}, {"title": "Possible rounding overcorrection", "body": "When withdrawing ETH, the ConvexEthMetaStrategy first calculates the number of LP tokens to burn. This calculation adds 1 to the conceptual calculation to account for possible rounding errors. However, this means that the calculated value could exceed the contract's LP token balance, and the contract would attempt to redeem more tokens than it has. Consider restricting the redeemed LP tokens to the contract's token balance.  Update: Acknowledged, not resolved. The Origin team stated:  Weve decided to rather retain the over-corrected version of the function and to not do an additional balance check call that would make the function more gas expensive.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#possible-rounding-overcorrection", "labels": ["OpenZeppelin"]}, {"title": "Potentially misleading platform token", "body": "Investment strategies maintain a token mapping that tracks the platform-specific investment token corresponding to each invested asset. Typically, a user can review the deposit and withdrawal events to identify when funds are swapped for the platform token and vice versa.  However, the ConvexEthMetaStrategy invests funds in a two-step process, where ETH is deposited in a Curve pool and then the curve LP tokens are deposited to Convex finance. A user tracking token balances would consider the gauge tokens as representing the investment, since the strategy does not hold any Curve LP tokens, but the events treat the Curve LP token as the platform token. Consider treating the gauge token as the platform token, or including another parameter in the events to distinguish the platform token from the strategy holdings.  Update: Acknowledged, not resolved. The Origin team stated:  There is no ERC-20 token created as a result of deploying the LP token to Gauge. Curve LP tokens are the only ERC-20 token that gets moved around as a consequence of deploying liquidity to Curve and deploying to Convex gauge. Convex Gauge just receives that token and reports its balance when asked. This is how Convex works by design and it is somewhat inconvenient that blockchain explorers like Etherscan are not able to detect automatically that a contract has liquidity deployed in Convex since no ERC-20 has been received as a result.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#potentially-misleading-platform-token", "labels": ["OpenZeppelin"]}, {"title": "Unsafe cast", "body": "The OracleRouterBase contract uses an unsafe cast to convert the signed price to a uint256 type. Consider ensuring the price is positive before performing the type conversion. If desired, this could be achieved with OpenZeppelin's SafeCast library.  Update: Resolved in pull request #1500 at commit 97a2116.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#unsafe-cast", "labels": ["OpenZeppelin"]}, {"title": "State variable visibility not explicitly declared", "body": "Throughout the codebase there are state variables that lack an explicitly declared visibility. For instance:  MIN_DRIFT in OracleRouter.sol  MAX_DRIFT in OracleRouter.sol  FIXED_PRICE in OracleRouter.sol  shareToken in Generalized4626Strategy.sol  assetToken in Generalized4626Strategy.sol  MAX_INT in VaultCore.sol  For clarity, consider always explicitly declaring the visibility of variables, even when the default visibility matches the intended visibility.  Update: Resolved in pull request #1501 at commit 73aaad.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#state-variable-visibility-not-explicitly-declared", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "In VaultCore.sol the imports Strings, IVault and IBasicToken are unused.  In convexEthMetaStrategy.sol the import Helpers is unused.  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #1504 at commit fd28ff.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Multiple contract declarations per file", "body": "Within OracleRouter.sol, there is more than one contract, library or interface declared.  Consider separating the contracts into their own files to make the codebase easier to understand for developers and reviewers.  Update: Acknowledged, not resolved. The Origin team stated:  We prefer one file for these, since the oracle-related contracts are small and deeply interrelated.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#multiple-contract-declarations-per-file", "labels": ["OpenZeppelin"]}, {"title": "TODO comments", "body": "The following TODO comment was found in the codebase. This comment should be tracked in the project's issue backlog.  The TODO comment on line 126 in VaultCore.sol  During development, having well-described TODO/Fixme comments will make the process of tracking and solving them easier. Without this information, these comments might age and important information for the security of the system might be forgotten by the time it is released to production.  Consider removing all instances of TODO/Fixme comments and instead tracking them in the issues backlog. Alternatively, consider linking each inline TODO/Fixme to the corresponding issues backlog entry.  Update: Acknowledged, not resolved. The Origin team stated:  The current code errs on the side of caution. We are still carefully investigating if we can safely make a gas optimization here.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#todo-comments", "labels": ["OpenZeppelin"]}, {"title": "Redundant use of the SafeMath library", "body": "All solidity compiler versions higher than 0.8.0 implement native overflow protection, which makes using SafeMath operations unnecessary for regular arithmetic. Consider removing redundant usage of the SafeMath library from the VaultCore contract to improve code readability and save gas.  Update: Resolved in pull request #1506 at commit 25dff8.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#redundant-use-of-the-safemath-library", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "The codebase contains some typographical errors:  The InitialiseConfig struct should be InitializeConfig to be consistent with the initialize function that it is referencing.  \"seperate\" should be \"separate\".  Update: Resolved in pull request #1507 at commit 8ed275f.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Incomplete generalization", "body": "The Vault code is intended to be generalized to support both OUSD and OETH use cases. However, there are still some values that are only relevant to one of the use cases. For instance:  The token and several variables have \"OUSD\" in their name. This is just one example, but several comments, variables and events throughout the VaultStorage, VaultAdmin and VaultCore contracts reference \"OUSD\" or the ConvexOUSDMetaStrategy.  Some of the comments (e.g., describing the value functions), reference \"ETH\".  The redeem functions are described as returning stablecoins.  Consider generalizing the names and comments to apply them to both use cases.  Update: Acknowledged, will resolve. The Origin team confirmed that they will resolve this issue in the future.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#incomplete-generalization", "labels": ["OpenZeppelin"]}, {"title": "require statements do not check for any conditions", "body": "Within VaultCore.sol there are multiple require statements that do not check for any conditions. For instance:  The require statement on line 657  The require statement on line 688  For clarity, it is recommended to use revert() in situations where require() does not perform any condition checks.  Update: Resolved in pull request #1517 at commit c478296.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#require-statements-do-not-check-for-any-conditions", "labels": ["OpenZeppelin"]}, {"title": "Incorrect decimals type", "body": "caches the token decimals for each supported asset. However, it unnecessarily casts to a  uint256 type from the  the ERC-20 standard. In the interest of consistency, consider retaining the  Update: Acknowledged, will resolve. The Origin team stated that they will resolve the issue in pull request #1516:  Fix needs seperate governance action.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#incorrect-decimals-type", "labels": ["OpenZeppelin"]}, {"title": "Redundant code", "body": "There are several examples of redundant code. For example:  The calculation that determines the amount of LP tokens to burn can be simplified to (_wethAmount + 1) * k. To see why there is no loss of precision, note that it only uses subtractions and multiplications, which always produce exact integer values if they do not overflow.  This line retrieves the OETH balance unnecessarily.  The ConvexEthMetaStrategy is initialized with an _assets array, but its only element (the WETH address) is already passed to the function.  This conversion redundantly casts a uint256 variable to a uint256 type.  Consider simplifying or removing the redundant code.  Update: Resolved in pull request #1514 at commit d689cf2 and at commit bd38222.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#redundant-code", "labels": ["OpenZeppelin"]}, {"title": "Vault coupled to expected collateral", "body": "The Vault contract contains a mechanism to match collateral tokens to their equivalent \"base\" token amount. A similar conversion is used to standardize the price. However, although it is written generically, the GETEXCHANGERATE case is coupled to the rETH token. In particular:  It assumes the existence of a getExchangeRate function, which is not part of a known standard. It would not support the cbETH token, for instance.  It hardcodes an additional 1e18 conversion factor, which assumes the getExchangeRate function returns the ETH value of 1e18 collateral token units.  To simplify the vault, consider moving the token-specific logic into the OracleRouter contract or another adapter contract.  Update: Acknowledged, not resolved. The Origin team stated:  We do plan on keeping conversions to base amounts in the vault for now. This reduces the number of external calls needed, and the number of tokens we need to support is low.", "html_url": "https://blog.openzeppelin.com/origin-oeth-integration-audit#vault-coupled-to-expected-collateral", "labels": ["OpenZeppelin"]}, {"title": "Custom Selectors could facilitate proxy selector clashing attack", "body": "ink! has a feature that allows developers to hardcode the selector for a given function. This capability enables function name-changing while maintaining the same selector and also facilitates the creation of language-agnostic contract standards.  However, allowing custom selectors in contracts can lead to proxy selector clashing. When a user calls a specific function on an implementation, a matching selector in the proxy can cause unintended execution of code within the proxy. This issue makes it easier for scam projects to create malicious backdoors that are difficult to detect. In contrast to ink!, Solidity requires finding function signatures with matching selectors before taking advantage of this vulnerability, which is not trivial. If such function signatures are found and added, they are likely to raise red flags because the name usually does not make sense to the codebase.  Custom selectors can also confuse third-party monitoring or indexing services that use function selectors to identify specific functions. These services may rely on standard selectors, which are part of standards or belong to community databases such as the 4byte directory. If contracts use custom selectors, these services may fail to recognize and monitor transactions, leading to errors.  Given the potential dangers outlined, it is worth rethinking this feature and looking for an alternative to handle language-agnostic contract standards. Alternatively, requiring the metadata of the implementation contract to build the proxy and preventing the code from being compiled if selector clashing occurs with the implementation may be a viable solution. If the benefits of using custom selectors are not greater than the potential risks, consider removing them.  Update: Acknowledged, will resolve. The progress can be tracked on issue 1643 of the ink repository.", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#custom-selectors-could-facilitate-proxy-selector-clashing-attack", "labels": ["OpenZeppelin"]}, {"title": "Potential contract storage layout overlap in upgradable contracts", "body": "By default, ink! tries to store all storage struct fields under a single storage cell. This behavior causes an issue for upgradable contracts because both the proxy and the implementation write their Packed fields to the same storage key (0x00000000) unless the developer explicitly sets manual keys for the variables inside the implementation contract. As a result, overwrites of the storage could happen.  If the first variable in the implementation is modified, it will change the first variable in the proxy storage layout or some of its bytes, depending on the variable size. The same happens the other way around.  Without sufficient information, developers may fail to properly modify the storage of the implementation contract, which can result in unexpected behavior and potential malfunctioning of the contract. Additionally, this may lead to an unpredictable storage layout, further complicating the matter. Therefore, it is important for developers to ensure they have all the necessary information and take the proper steps to modify storage in order to prevent such issues  Also, there are no validations between upgrades to check whether the storage layout changed. The documentation specified that developers should not change the order in which the contract state variables are declared, nor their type.  Even if the restriction is violated, the compilation process will still succeed, but it may cause confusion in values or failure in the correct reading of storage. These issues can result in severe errors in the application that is using the contract.  Some mitigations to these problems could be:  To avoid clashes, define a set of standard slots to store variables present on the proxy code. The EIP-1967 defined in Ethereum can serve as an inspiration.  Consider adding documentation and examples to illustrate that one of either the implementation or proxy variables needs to use the Lazy collection. The Lazy collection sets the storage keys used for each variable, ensuring that they do not overlap with other variables in the contract.  Implement the cargo contract upgrade command mentioned in the suggestions section. This will retain the storage layout of the implementation and checks that it was not corrupted between upgrades, and check that the variables defined in the proxy were defined using manual keys instead of automatic keys, or that the first position of each variable defined in the proxy does not collide with any of the variables defined in the implementation.  Update: Acknowledged, will resolve. The progress can be tracked on issues 1679 and 1680 of the ink repository.  Medium Severity", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#potential-contract-storage-layout-overlap-in-upgradable-contracts", "labels": ["OpenZeppelin"]}, {"title": "Nonce reset increases the risk of a successful replay attack", "body": "Replay attacks pose a significant security threat to blockchain technologies. To maintain the integrity of signatures in a blockchain network, it is essential to use a nonce, a value that tracks the number of transactions made by a given account.  On Substrate-based blockchains, if an accounts balance drops below the existential deposit, the nonce is reset. This action can compromise the replay protection mechanism and increase the risk of a successful attack. Furthermore, prolonged expiration or deadline periods can also increase the possibility of a replay attack.  Instead of relying solely on the deadline, consider adding an alternative protection mechanism, like enforcing robust domain separators when hashing messages or advising developers to store the signatures used for a given address in the respective contract. Another solution is to keep the nonce even if the accounts balance falls below the minimum required.  Update: Acknowledged, more documentation will be added to make users aware of this behavior. The progress can be followed in issue 178 of the ink-docs repository. The Parity team stated:  This behavior is normal in the Substrate world and the only thing we can do here is highlight it better to newcomers. We will add documentation about this behavior.  Unbounded arrays are not possible in ink! Smart Contracts  By default, ink! tries to store all vector elements under a single storage cell. As a result, querying one item returns all the elements within the vector, but the buffer has a limited capacity (around 16KB in the default configuration). As a consequence, any contract attempting to decode beyond this limit will throw an error, making it impossible to implement certain smart contracts such as ERC20votes extension and EnumerableSet. If the limit is not exceeded, the operations would consume a large amount of gas in the execution, causing interactions with these contracts to be less appealing due to their cost.  The impact of this flaw might be significant because it limits the capabilities for contract developers. Unbounded arrays are essential for many use cases, and the inability to implement them using ink! significantly reduces the range of possibilities for Dapp development.  Consider, if possible, creating another storage collection to store array elements in different slots.  Update: Acknowledged, will resolve. The progress can be tracked on issue 1682 of the ink repository.  Low Severity  Confusing examples  The upgradeable-contracts example shows two ways of implementing upgradeability:  The first one, implemented in the set-code-hash directory, shows how a smart contract written in ink! can be upgraded by updating the implementation logic through the ink::env::set_code_hash function.  The second one, forward-calls, shows how to perform upgrades by using proxies. Similarly to well-known implementations of the Proxy pattern in solidity, the idea in this approach is to forward calls from the Proxy contract to an implementation contract, using the context of the former but the logic of the latter.  The issue lies in the fact that, in the latter, the forward function does not use the implementation of delegatecall but performs a regular call operation instead. As a result, the context and storage used in this example will not be the one of the Proxy, but the implementation, breaking the upgradeability pattern.  It is suggested to improve the documentation of how delegatecall works in ink! by including examples of both upgradeable and non-upgradeable proxies. Additionally, consider updating the mentioned example using delegate instead of regular calls.  Update: Resolved in pull request #1697 and pull request #1704.  Lack of input validation in the decode command  The Cargo contract has a decode command to parse the encoded input or output data and extract the underlying values. The feature has two flags. One to indicate the type of data to decode and the other for data itself that has to be a hex value. However, the current implementation of the function is accepting more bytes than the target type expects, which could cause misinterpretation of the data.  Consider updating the implementation to correctly accept only the expected number of bytes for the target function. This measure will reduce the risk of confusion and unexpected results.  Update: Resolved in pull request #982 at commit 769c112.  Potential clash between proxy and implementation function selectors  ink! allows developers to set custom selectors for the functions defined on a contract as mentioned in Custom Selectors could facilitate proxy selector clashing attack. When this feature is not used, the compute function from the ink crate is used to calculate the function selector instead. This function calculates the selector by hashing the function name and taking its first 4 bytes (similar to how it is done in Solidity).  The issue lies in the fact that the function selector is calculated using only the functions name, without taking into account any other value. This may cause a function selector collision since it is likely to use the same function name in both the proxy and implementation.  Here are some potential mitigations strategies for this issue:  Develop an upgrade command, as mentioned in the suggestions section, to check that there are no repeated function selectors between the proxy and the implementation to which the system is being upgraded.  Develop a new macro attribute named proxy, that could overwrite the implementation of the compute function so that it not only uses the name of the function, but also appends to it the name of the proxy contract, a hash of the name of the proxy contract, or any other item that will make the selector different, and properly document it. Additionally, the proxy macro will improve the readability of the contract itself, since developers and auditors will know the contract will behave like a proxy.  Update: Acknowledged, will resolve. The progress can be tracked on issue 981 of the cargo-contract repository.  Misleading behavior of ManualKey functionality  ink! smart contracts include the ManualKey feature, which allows developers to specify the value of the key for a Mapping or a Lazy collection. However, a potential issue with this feature is that the key can be set to zero in the code while appearing as a different value in the metadata, leading to confusion and possible errors.  To avoid this issue, it may be worth disallowing users from setting the key of a variable to 0 when using ManualKey. Since developers may rely on the value specified in the code, this change could prevent confusion and improve the reliability of the code.  Update: Resolved in pull request #1670 at commit 63c846d.  Non-determinism in ink! contract builds  The process of building ink! contracts using the cargo contract CLI is impacted by various factors that can alter the final product. These factors include the version of Rust, the enabled features, the cargo-contract version, the number of optimization passes, and the build mode. The build process is non-deterministic across different operating systems and architectures.  The non-determinism of the build process creates difficulties in contract verification, which makes it challenging to establish trust in the contract and its reliability, both of which are essential for users.  To address this issue, consider standardizing the build process and providing clear guidelines and notifications to developers at the earliest stages, rather than after the contracts deployment. This approach will ensure that contract verification is straightforward, and users can trust the contract.  Update: Acknowledged, will resolve. The progress can be seen on issue 99 of the ink-docs repository and issue 525 of the cargo-contract repository.  Notes & Additional Information  Incomplete Spanish translations  The Spanish version of the documentation has many pages written in English, causing confusion and making it challenging for Spanish speakers to understand the information.  Consider completing the Spanish translations and disabling them until they are production-ready.  Update: Acknowledged, not resolved yet.  README.md references on internal crates  The internal crates of the ink! repository have a reference to the repositorys main README.md instead of their own, leading to a lack of information about the module and broken image links.  This lack of information can hinder the usability of the internal crates, making it difficult for developers to understand the purpose and usage of each crate. Additionally, broken image links can create a negative impression for users.  Creating individual README.md files for each crate would go a long way in resolving this issue.  Update: Acknowledged, will resolve. The progress can be tracked on issue 1690 of the ink repository.  Conclusions  The security review report has highlighted potential vulnerabilities and provided suggestions for improving the ink! ecosystem. We are pleased to report that working with the Parity team throughout this process has been fantastic. They have been receptive and open to our recommendations, and the weekly meetings were highly productive.  We see great potential in ink! and its tool cargo-contract, which has demonstrated robust security measures and an unwavering commitment to ensuring the safety and security of its users.  Overall, we are confident that ink! and its associated tools will see significant adoption in the future with continued collaboration and ongoing efforts to enhance security. We look forward to seeing the continued evolution and growth of ink!.  For more information about ink!, you can visit the ink! documentation or follow the ink! Twitter. The ink! documentation also has a general explainer on how smart contracts work in Polkadot.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#nonce-reset-increases-the-risk-of-a-successful-replay-attack", "labels": ["OpenZeppelin"]}, {"title": "Unbounded arrays are not possible in ink! Smart Contracts", "body": "Unbounded arrays are not possible in ink! Smart Contracts", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#unbounded-arrays-are-not-possible-in-ink!-smart-contracts", "labels": ["OpenZeppelin"]}, {"title": "Confusing examples", "body": "The upgradeable-contracts example shows two ways of implementing upgradeability:  The first one, implemented in the set-code-hash directory, shows how a smart contract written in ink! can be upgraded by updating the implementation logic through the ink::env::set_code_hash function.  The second one, forward-calls, shows how to perform upgrades by using proxies. Similarly to well-known implementations of the Proxy pattern in solidity, the idea in this approach is to forward calls from the Proxy contract to an implementation contract, using the context of the former but the logic of the latter.  The issue lies in the fact that, in the latter, the forward function does not use the implementation of delegatecall but performs a regular call operation instead. As a result, the context and storage used in this example will not be the one of the Proxy, but the implementation, breaking the upgradeability pattern.  It is suggested to improve the documentation of how delegatecall works in ink! by including examples of both upgradeable and non-upgradeable proxies. Additionally, consider updating the mentioned example using delegate instead of regular calls.  Update: Resolved in pull request #1697 and pull request #1704.  Lack of input validation in the decode command  The Cargo contract has a decode command to parse the encoded input or output data and extract the underlying values. The feature has two flags. One to indicate the type of data to decode and the other for data itself that has to be a hex value. However, the current implementation of the function is accepting more bytes than the target type expects, which could cause misinterpretation of the data.  Consider updating the implementation to correctly accept only the expected number of bytes for the target function. This measure will reduce the risk of confusion and unexpected results.  Update: Resolved in pull request #982 at commit 769c112.  Potential clash between proxy and implementation function selectors  ink! allows developers to set custom selectors for the functions defined on a contract as mentioned in Custom Selectors could facilitate proxy selector clashing attack. When this feature is not used, the compute function from the ink crate is used to calculate the function selector instead. This function calculates the selector by hashing the function name and taking its first 4 bytes (similar to how it is done in Solidity).  The issue lies in the fact that the function selector is calculated using only the functions name, without taking into account any other value. This may cause a function selector collision since it is likely to use the same function name in both the proxy and implementation.  Here are some potential mitigations strategies for this issue:  Develop an upgrade command, as mentioned in the suggestions section, to check that there are no repeated function selectors between the proxy and the implementation to which the system is being upgraded.  Develop a new macro attribute named proxy, that could overwrite the implementation of the compute function so that it not only uses the name of the function, but also appends to it the name of the proxy contract, a hash of the name of the proxy contract, or any other item that will make the selector different, and properly document it. Additionally, the proxy macro will improve the readability of the contract itself, since developers and auditors will know the contract will behave like a proxy.  Update: Acknowledged, will resolve. The progress can be tracked on issue 981 of the cargo-contract repository.  Misleading behavior of ManualKey functionality  ink! smart contracts include the ManualKey feature, which allows developers to specify the value of the key for a Mapping or a Lazy collection. However, a potential issue with this feature is that the key can be set to zero in the code while appearing as a different value in the metadata, leading to confusion and possible errors.  To avoid this issue, it may be worth disallowing users from setting the key of a variable to 0 when using ManualKey. Since developers may rely on the value specified in the code, this change could prevent confusion and improve the reliability of the code.  Update: Resolved in pull request #1670 at commit 63c846d.  Non-determinism in ink! contract builds  The process of building ink! contracts using the cargo contract CLI is impacted by various factors that can alter the final product. These factors include the version of Rust, the enabled features, the cargo-contract version, the number of optimization passes, and the build mode. The build process is non-deterministic across different operating systems and architectures.  The non-determinism of the build process creates difficulties in contract verification, which makes it challenging to establish trust in the contract and its reliability, both of which are essential for users.  To address this issue, consider standardizing the build process and providing clear guidelines and notifications to developers at the earliest stages, rather than after the contracts deployment. This approach will ensure that contract verification is straightforward, and users can trust the contract.  Update: Acknowledged, will resolve. The progress can be seen on issue 99 of the ink-docs repository and issue 525 of the cargo-contract repository.  Notes & Additional Information  Incomplete Spanish translations  The Spanish version of the documentation has many pages written in English, causing confusion and making it challenging for Spanish speakers to understand the information.  Consider completing the Spanish translations and disabling them until they are production-ready.  Update: Acknowledged, not resolved yet.  README.md references on internal crates  The internal crates of the ink! repository have a reference to the repositorys main README.md instead of their own, leading to a lack of information about the module and broken image links.  This lack of information can hinder the usability of the internal crates, making it difficult for developers to understand the purpose and usage of each crate. Additionally, broken image links can create a negative impression for users.  Creating individual README.md files for each crate would go a long way in resolving this issue.  Update: Acknowledged, will resolve. The progress can be tracked on issue 1690 of the ink repository.  Conclusions  The security review report has highlighted potential vulnerabilities and provided suggestions for improving the ink! ecosystem. We are pleased to report that working with the Parity team throughout this process has been fantastic. They have been receptive and open to our recommendations, and the weekly meetings were highly productive.  We see great potential in ink! and its tool cargo-contract, which has demonstrated robust security measures and an unwavering commitment to ensuring the safety and security of its users.  Overall, we are confident that ink! and its associated tools will see significant adoption in the future with continued collaboration and ongoing efforts to enhance security. We look forward to seeing the continued evolution and growth of ink!.  For more information about ink!, you can visit the ink! documentation or follow the ink! Twitter. The ink! documentation also has a general explainer on how smart contracts work in Polkadot.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#confusing-examples", "labels": ["OpenZeppelin"]}, {"title": "Lack of input validation in the decode command", "body": "Lack of input validation in the decode command", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#lack-of-input-validation-in-the-decode-command", "labels": ["OpenZeppelin"]}, {"title": "Potential clash between proxy and implementation function selectors", "body": "ink! allows developers to set custom selectors for the functions defined on a contract as mentioned in Custom Selectors could facilitate proxy selector clashing attack. When this feature is not used, the compute function from the ink crate is used to calculate the function selector instead. This function calculates the selector by hashing the function name and taking its first 4 bytes (similar to how it is done in Solidity).  The issue lies in the fact that the function selector is calculated using only the functions name, without taking into account any other value. This may cause a function selector collision since it is likely to use the same function name in both the proxy and implementation.  Here are some potential mitigations strategies for this issue:  Develop an upgrade command, as mentioned in the suggestions section, to check that there are no repeated function selectors between the proxy and the implementation to which the system is being upgraded.  Develop a new macro attribute named proxy, that could overwrite the implementation of the compute function so that it not only uses the name of the function, but also appends to it the name of the proxy contract, a hash of the name of the proxy contract, or any other item that will make the selector different, and properly document it. Additionally, the proxy macro will improve the readability of the contract itself, since developers and auditors will know the contract will behave like a proxy.  Update: Acknowledged, will resolve. The progress can be tracked on issue 981 of the cargo-contract repository.  Misleading behavior of ManualKey functionality  ink! smart contracts include the ManualKey feature, which allows developers to specify the value of the key for a Mapping or a Lazy collection. However, a potential issue with this feature is that the key can be set to zero in the code while appearing as a different value in the metadata, leading to confusion and possible errors.  To avoid this issue, it may be worth disallowing users from setting the key of a variable to 0 when using ManualKey. Since developers may rely on the value specified in the code, this change could prevent confusion and improve the reliability of the code.  Update: Resolved in pull request #1670 at commit 63c846d.  Non-determinism in ink! contract builds  The process of building ink! contracts using the cargo contract CLI is impacted by various factors that can alter the final product. These factors include the version of Rust, the enabled features, the cargo-contract version, the number of optimization passes, and the build mode. The build process is non-deterministic across different operating systems and architectures.  The non-determinism of the build process creates difficulties in contract verification, which makes it challenging to establish trust in the contract and its reliability, both of which are essential for users.  To address this issue, consider standardizing the build process and providing clear guidelines and notifications to developers at the earliest stages, rather than after the contracts deployment. This approach will ensure that contract verification is straightforward, and users can trust the contract.  Update: Acknowledged, will resolve. The progress can be seen on issue 99 of the ink-docs repository and issue 525 of the cargo-contract repository.  Notes & Additional Information  Incomplete Spanish translations  The Spanish version of the documentation has many pages written in English, causing confusion and making it challenging for Spanish speakers to understand the information.  Consider completing the Spanish translations and disabling them until they are production-ready.  Update: Acknowledged, not resolved yet.  README.md references on internal crates  The internal crates of the ink! repository have a reference to the repositorys main README.md instead of their own, leading to a lack of information about the module and broken image links.  This lack of information can hinder the usability of the internal crates, making it difficult for developers to understand the purpose and usage of each crate. Additionally, broken image links can create a negative impression for users.  Creating individual README.md files for each crate would go a long way in resolving this issue.  Update: Acknowledged, will resolve. The progress can be tracked on issue 1690 of the ink repository.  Conclusions  The security review report has highlighted potential vulnerabilities and provided suggestions for improving the ink! ecosystem. We are pleased to report that working with the Parity team throughout this process has been fantastic. They have been receptive and open to our recommendations, and the weekly meetings were highly productive.  We see great potential in ink! and its tool cargo-contract, which has demonstrated robust security measures and an unwavering commitment to ensuring the safety and security of its users.  Overall, we are confident that ink! and its associated tools will see significant adoption in the future with continued collaboration and ongoing efforts to enhance security. We look forward to seeing the continued evolution and growth of ink!.  For more information about ink!, you can visit the ink! documentation or follow the ink! Twitter. The ink! documentation also has a general explainer on how smart contracts work in Polkadot.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#potential-clash-between-proxy-and-implementation-function-selectors", "labels": ["OpenZeppelin"]}, {"title": "Misleading behavior of ManualKey functionality", "body": "Misleading behavior of ManualKey functionality", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#misleading-behavior-of-manualkey-functionality", "labels": ["OpenZeppelin"]}, {"title": "Non-determinism in ink! contract builds", "body": "The process of building ink! contracts using the cargo contract CLI is impacted by various factors that can alter the final product. These factors include the version of Rust, the enabled features, the cargo-contract version, the number of optimization passes, and the build mode. The build process is non-deterministic across different operating systems and architectures.  The non-determinism of the build process creates difficulties in contract verification, which makes it challenging to establish trust in the contract and its reliability, both of which are essential for users.  To address this issue, consider standardizing the build process and providing clear guidelines and notifications to developers at the earliest stages, rather than after the contracts deployment. This approach will ensure that contract verification is straightforward, and users can trust the contract.  Update: Acknowledged, will resolve. The progress can be seen on issue 99 of the ink-docs repository and issue 525 of the cargo-contract repository.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#non-determinism-in-ink!-contract-builds", "labels": ["OpenZeppelin"]}, {"title": "Incomplete Spanish translations", "body": "The Spanish version of the documentation has many pages written in English, causing confusion and making it challenging for Spanish speakers to understand the information.  Consider completing the Spanish translations and disabling them until they are production-ready.  Update: Acknowledged, not resolved yet.  README.md references on internal crates  The internal crates of the ink! repository have a reference to the repositorys main README.md instead of their own, leading to a lack of information about the module and broken image links.  This lack of information can hinder the usability of the internal crates, making it difficult for developers to understand the purpose and usage of each crate. Additionally, broken image links can create a negative impression for users.  Creating individual README.md files for each crate would go a long way in resolving this issue.  Update: Acknowledged, will resolve. The progress can be tracked on issue 1690 of the ink repository.  Conclusions  The security review report has highlighted potential vulnerabilities and provided suggestions for improving the ink! ecosystem. We are pleased to report that working with the Parity team throughout this process has been fantastic. They have been receptive and open to our recommendations, and the weekly meetings were highly productive.  We see great potential in ink! and its tool cargo-contract, which has demonstrated robust security measures and an unwavering commitment to ensuring the safety and security of its users.  Overall, we are confident that ink! and its associated tools will see significant adoption in the future with continued collaboration and ongoing efforts to enhance security. We look forward to seeing the continued evolution and growth of ink!.  For more information about ink!, you can visit the ink! documentation or follow the ink! Twitter. The ink! documentation also has a general explainer on how smart contracts work in Polkadot.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#incomplete-spanish-translations", "labels": ["OpenZeppelin"]}, {"title": "README.md references on internal crates", "body": "README.md references on internal crates", "html_url": "https://blog.openzeppelin.com/security-review-ink-cargo-contract#readme.md-references-on-internal-crates", "labels": ["OpenZeppelin"]}, {"title": "Malicious Operator Can Dodge Refund", "body": "In the refundCurrentL2Transaction function, the user gets refunded for overpaying in ergs for their L2 transaction. The ETH amount to refund is dependent on the ergs amount and the ergs price. The ergs amount is the maximum value of the operator-provided value and the one calculated by the bootloader. The ergs amount multiplied by the ergs price determines the refund in ETH.  A malicious operator can provide a very large amount of ergs that should be refunded, which will therefore be the chosen refundInErgs value. However, when multiplied by the ergs price, ethToRefund can overflow and lead to a very low refund, effectively stealing funds from the user.  Consider calculating the refund based on the bootloader and operator values individually and then picking the higher amount to protect the fee model against a malicious operator.  Update: Resolved in pull request #208 at commit 57ba2b1.  Medium Severity", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#malicious-operator-can-dodge-refund", "labels": ["OpenZeppelin"]}, {"title": "Users Can Lose Funds in L1ERC20Bridge Implementation Contract", "body": "_mailbox address is written to the bytecode that is deployed. During this invocation of  Specifically, the deposit function of the implementation contract is callable. However, in the implementation contract itself, many variables are not initialized, such as the l2Bridge variable, so it holds the zero-address. Therefore, the deposit function would request an L2 transaction that attempts to finalize the withdrawal by calling the zero-address, thereby triggering the non-reverting fallback function of the EmptyContract. Since this L2 call does not fail, the deposited tokens are locked and irrecoverable, as a call to claimFailedDeposit cannot be proven.  Consider implementing a stricter mechanism that prohibits direct calls to the contract if all or some of its variables were not properly initialized. In addition, consider preventing the initialization of the implementation contract more directly, rather than relying on the implicit behavior of reentrancyGuardInitializer, which lacks visibility.  Update: Acknowledged, not resolved. The Matter Labs team stated:  While we appreciate your insights and suggestions, we do not believe the issue carries a significant security risk. As the contract is intended to be used through a proxy, direct calls to the implementation contract are not recommended. Users could also call any other scam contract.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#users-can-lose-funds-in-l1erc20bridge-implementation-contract", "labels": ["OpenZeppelin"]}, {"title": "Lack of __gap Variable", "body": "The L1ERC20Bridge and L2StandardERC20 contract are intended to be used as logic contracts with a proxy, but do not have a __gap variable. This would become problematic if a subsequent version was to inherit one of these contracts. If the derived version were to have storage variables itself and additional storage variables were subsequently added to the inherited contract, a storage collision would occur.  Consider appending a __gap variable as the last storage variable to these upgradeable contracts, such that the storage slots sum up to a fixed amount (e.g. 50). This will proof any future storage layout changes to the base contract. Note that the __gap variable space will need to be adjusted accordingly as subsequent versions include more storage variables, in order to maintain the fixed amount of slots (e.g. 50).  Update: Acknowledged, not resolved. The Matter Labs team stated:  While we appreciate your insights and suggestions, we do not believe the issue has a significant security risk. Specified contracts are not expected to be inherited, since they are complete logical contracts.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#lack-of-__gap-variable", "labels": ["OpenZeppelin"]}, {"title": "ceilDiv Function Can Overflow", "body": "The ceilDiv function of the bootloader is used throughout the fee model formulas. This function can overflow as the numerator and denominator are added together before they are divided. Although this was not identified as a threat in the current codebase, an issue could be introduced by using this function with unvalidated inputs.  Consider adapting the formula to be safe from overflows.  Update: Resolved in pull request #236 at commit 56b3231.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#ceildiv-function-can-overflow", "labels": ["OpenZeppelin"]}, {"title": "Overflows in Fee Computation", "body": "The bootloader changes in scope involve a few formulas as part of the fee model, and there were a few instances where calculations were performed on user or operator-provided inputs. Unchecked arithmetic (without overflow protection) using these values is generally dangerous and prone to exploits.  One example is the calculated ergs price. If the maxPriorityFeePerErg is sufficiently large and the maxFeePerErg value is increased to match, the maxFeeThatOperatorCouldTake calculation could overflow, resulting in a zero ergs price. The transaction will still be executed but the amount the user pays would be zero. A savvy operator could recognize this scenario and discard the operation, but it does make the system unnecessarily fragile.  We also identified the following cases where potential overflows with user-provided values appear to be unmitigated, although the consequences are limited:  The intrinsicOverhead calculation in the getErgsLimitForTx function  The return value of the getBlockOverheadErgs function  The numerators of the overheadForCircuits, overheadForLength, and overheadForPubdata calculations in the getTransactionUpfrontOverhead function  Lastly, the following functions appear to allow overflows, but they are protected by validations in other parts of the codebase:  In getBaseFee, a large l1GasPrice could cause pubdataBytePriceETH to overflow but the validateOperatorProvidedPrices checks prevent this.  In processL1Tx, toRefundRecipient would negative overflow if the value was too large, but the check on line 1306 prevents this.  In getErgsLimitForTx, ergsLimitForTx would negative overflow if the operatorOverheadForTransaction was too large, but the check on line 1253 prevents this.  Consider applying additional checks to these operations, explicitly documenting where the checks are or why they would not be necessary. Whenever a potential overflow is not mitigated in the same function, consider documenting where the relevant validation can be found. It is advised to check the rest of the bootloader for more potential overflows and underflows. Lastly, it is recommended to validate all changes with proper dynamic testing.  Update: Resolved in pull request #211 at commit 448932e.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#overflows-in-fee-computation", "labels": ["OpenZeppelin"]}, {"title": "Missing Factory Dependencies", "body": "When the L1ERC20Bridge is initialized, the bytecode of the L2 bridge and token proxy are both provided as factory dependencies. This ensures the code is known when the L2 Bridge is deployed, or a new token is created. However, the L2 bridge initialization also deploys the token implementation and proxy beacon. Since neither contract was listed as a factory dependency, they may not be marked as known. Unless they were previously mentioned in an unrelated transaction, the bridge initialization will fail.  Consider including the L2StandardERC20 and the UpgradeableBeacon contracts in the factory dependencies of the bridge initialization transaction.  Update: Acknowledged, will resolve. The Matter Labs team stated:  Acknowledged. The problem can only be encountered at the initialization stage, so we prefer not to change the deployment scripts at the moment. This has been included in the backlog as a refactoring task.  Low Severity", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#missing-factory-dependencies", "labels": ["OpenZeppelin"]}, {"title": "Missing Error Messages in require and revert Statements", "body": "Throughout the bridge and system contracts codebases there are require and revert statements that lack error messages:  The require statement on line 96 of L2StandardERC20.sol  The revert statement on line 116 of L2StandardERC20.sol  The revert statement on line 122 of L2StandardERC20.sol  The revert statement on line 128 of L2StandardERC20.sol  The require statement on line 25 of AccountCodeStorage.sol  The require statement on line 36 of AccountCodeStorage.sol  The require statement on line 50 of AccountCodeStorage.sol  The require statement on line 39 of ContractDeployer.sol  The require statement on line 34 of ImmutableSimulator.sol  Consider including specific, informative error messages in require and revert statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied. In addition, for statements that do contain a message, consider using longer strings instead of a few characters to describe the error.  Update: Resolved in pull request #212 at commit cb93637 and pull request #63 at commit 77e64b5. The Matter Labs team stated:  We did not add error messages to reverts from name/symbol/decimals functions because if the token does not implement that method it should behave exactly the same way as if the function was not declared.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#missing-error-messages-in-require-and-revert-statements", "labels": ["OpenZeppelin"]}, {"title": "L2ERC20Bridge Is Not Upgradeable", "body": "L2ERC20Bridge Is Not Upgradeable", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#l2erc20bridge-is-not-upgradeable", "labels": ["OpenZeppelin"]}, {"title": "Potential EIP-1052 Deviation", "body": "issue, it is possible that opcodes deviate from EVM behavior, which still needs to be explored for other opcodes. For more differences  including unsupported opcodes  visit the EVM compatibility section of the zkSync documentation.  Testing Coverage Recommendations  Due to the complex nature of the system and several subtle deviations from the EVM, we believe this audit would have benefitted from more complete testing coverage, particularly around the bridge messages and new fee mechanics.  While insufficient testing is not necessarily a vulnerability, it implies a high probability of additional hidden vulnerabilities and bugs. Given the complexity of this codebase and the numerous interrelated risk factors, this probability is further increased. Testing provides a full implicit specification along with the exact expected behaviors of the codebase, which is especially important when adding novel functionalities. A lack thereof increases the chances that correctness issues will be missed. It also results in more effort to establish basic correctness and reduces the effort spent exploring edge cases, thereby increasing the chances of missing complex issues.  Moreover, the lack of repeated automated testing of the full specification increases the chances of introducing breaking changes and new vulnerabilities. This applies to both previously audited code and future changes to current code. This is particularly true in this project due to the pace, extent, and complexity of ongoing and planned changes across all parts of the stack (L1, L2, bootloader and system contracts, compiler and zkEVM). Underspecified interfaces and assumptions increase the risk of subtle integration issues, which testing could reduce by enforcing an exhaustive specification.  To address these issues, we recommend implementing a comprehensive multi-level test suite before the next expected audits. Such a test suite should comprise contract-level tests with >90% coverage, per-layer deployment and integration tests that test the deployment scripts as well as the system as a whole, per-layer fork tests for planned upgrades, and cross-chain full integration tests of the entire system. Crucially, the test suite should be documented in a way so that a reviewer can set up and run all these test layers independently of the development team. Some existing examples of such setups can be suggested for use as reference in a follow-up conversation. Implementing such a test suite should be a very high priority to ensure the systems robustness and reduce the risk of vulnerabilities and bugs.  High Severity  Malicious Operator Can Dodge Refund  In the refundCurrentL2Transaction function, the user gets refunded for overpaying in ergs for their L2 transaction. The ETH amount to refund is dependent on the ergs amount and the ergs price. The ergs amount is the maximum value of the operator-provided value and the one calculated by the bootloader. The ergs amount multiplied by the ergs price determines the refund in ETH.  A malicious operator can provide a very large amount of ergs that should be refunded, which will therefore be the chosen refundInErgs value. However, when multiplied by the ergs price, ethToRefund can overflow and lead to a very low refund, effectively stealing funds from the user.  Consider calculating the refund based on the bootloader and operator values individually and then picking the higher amount to protect the fee model against a malicious operator.  Update: Resolved in pull request #208 at commit 57ba2b1.  Medium Severity  Users Can Lose Funds in L1ERC20Bridge Implementation Contract  _mailbox address is written to the bytecode that is deployed. During this invocation of  Specifically, the deposit function of the implementation contract is callable. However, in the implementation contract itself, many variables are not initialized, such as the l2Bridge variable, so it holds the zero-address. Therefore, the deposit function would request an L2 transaction that attempts to finalize the withdrawal by calling the zero-address, thereby triggering the non-reverting fallback function of the EmptyContract. Since this L2 call does not fail, the deposited tokens are locked and irrecoverable, as a call to claimFailedDeposit cannot be proven.  Consider implementing a stricter mechanism that prohibits direct calls to the contract if all or some of its variables were not properly initialized. In addition, consider preventing the initialization of the implementation contract more directly, rather than relying on the implicit behavior of reentrancyGuardInitializer, which lacks visibility.  Update: Acknowledged, not resolved. The Matter Labs team stated:  While we appreciate your insights and suggestions, we do not believe the issue carries a significant security risk. As the contract is intended to be used through a proxy, direct calls to the implementation contract are not recommended. Users could also call any other scam contract.  Lack of __gap Variable  The L1ERC20Bridge and L2StandardERC20 contract are intended to be used as logic contracts with a proxy, but do not have a __gap variable. This would become problematic if a subsequent version was to inherit one of these contracts. If the derived version were to have storage variables itself and additional storage variables were subsequently added to the inherited contract, a storage collision would occur.  Consider appending a __gap variable as the last storage variable to these upgradeable contracts, such that the storage slots sum up to a fixed amount (e.g. 50). This will proof any future storage layout changes to the base contract. Note that the __gap variable space will need to be adjusted accordingly as subsequent versions include more storage variables, in order to maintain the fixed amount of slots (e.g. 50).  Update: Acknowledged, not resolved. The Matter Labs team stated:  While we appreciate your insights and suggestions, we do not believe the issue has a significant security risk. Specified contracts are not expected to be inherited, since they are complete logical contracts.  ceilDiv Function Can Overflow  The ceilDiv function of the bootloader is used throughout the fee model formulas. This function can overflow as the numerator and denominator are added together before they are divided. Although this was not identified as a threat in the current codebase, an issue could be introduced by using this function with unvalidated inputs.  Consider adapting the formula to be safe from overflows.  Update: Resolved in pull request #236 at commit 56b3231.  Overflows in Fee Computation  The bootloader changes in scope involve a few formulas as part of the fee model, and there were a few instances where calculations were performed on user or operator-provided inputs. Unchecked arithmetic (without overflow protection) using these values is generally dangerous and prone to exploits.  One example is the calculated ergs price. If the maxPriorityFeePerErg is sufficiently large and the maxFeePerErg value is increased to match, the maxFeeThatOperatorCouldTake calculation could overflow, resulting in a zero ergs price. The transaction will still be executed but the amount the user pays would be zero. A savvy operator could recognize this scenario and discard the operation, but it does make the system unnecessarily fragile.  We also identified the following cases where potential overflows with user-provided values appear to be unmitigated, although the consequences are limited:  The intrinsicOverhead calculation in the getErgsLimitForTx function  The return value of the getBlockOverheadErgs function  The numerators of the overheadForCircuits, overheadForLength, and overheadForPubdata calculations in the getTransactionUpfrontOverhead function  Lastly, the following functions appear to allow overflows, but they are protected by validations in other parts of the codebase:  In getBaseFee, a large l1GasPrice could cause pubdataBytePriceETH to overflow but the validateOperatorProvidedPrices checks prevent this.  In processL1Tx, toRefundRecipient would negative overflow if the value was too large, but the check on line 1306 prevents this.  In getErgsLimitForTx, ergsLimitForTx would negative overflow if the operatorOverheadForTransaction was too large, but the check on line 1253 prevents this.  Consider applying additional checks to these operations, explicitly documenting where the checks are or why they would not be necessary. Whenever a potential overflow is not mitigated in the same function, consider documenting where the relevant validation can be found. It is advised to check the rest of the bootloader for more potential overflows and underflows. Lastly, it is recommended to validate all changes with proper dynamic testing.  Update: Resolved in pull request #211 at commit 448932e.  Missing Factory Dependencies  When the L1ERC20Bridge is initialized, the bytecode of the L2 bridge and token proxy are both provided as factory dependencies. This ensures the code is known when the L2 Bridge is deployed, or a new token is created. However, the L2 bridge initialization also deploys the token implementation and proxy beacon. Since neither contract was listed as a factory dependency, they may not be marked as known. Unless they were previously mentioned in an unrelated transaction, the bridge initialization will fail.  Consider including the L2StandardERC20 and the UpgradeableBeacon contracts in the factory dependencies of the bridge initialization transaction.  Update: Acknowledged, will resolve. The Matter Labs team stated:  Acknowledged. The problem can only be encountered at the initialization stage, so we prefer not to change the deployment scripts at the moment. This has been included in the backlog as a refactoring task.  Low Severity  Missing Error Messages in require and revert Statements  Throughout the bridge and system contracts codebases there are require and revert statements that lack error messages:  The require statement on line 96 of L2StandardERC20.sol  The revert statement on line 116 of L2StandardERC20.sol  The revert statement on line 122 of L2StandardERC20.sol  The revert statement on line 128 of L2StandardERC20.sol  The require statement on line 25 of AccountCodeStorage.sol  The require statement on line 36 of AccountCodeStorage.sol  The require statement on line 50 of AccountCodeStorage.sol  The require statement on line 39 of ContractDeployer.sol  The require statement on line 34 of ImmutableSimulator.sol  Consider including specific, informative error messages in require and revert statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied. In addition, for statements that do contain a message, consider using longer strings instead of a few characters to describe the error.  Update: Resolved in pull request #212 at commit cb93637 and pull request #63 at commit 77e64b5. The Matter Labs team stated:  We did not add error messages to reverts from name/symbol/decimals functions because if the token does not implement that method it should behave exactly the same way as if the function was not declared.  L2ERC20Bridge Is Not Upgradeable  The L1ERC20Bridge and L2ERC20Bridge contracts manage the ERC-20 token bridge for the Layer 1 and Layer 2 sides respectively. These two bridge contracts are intertwined, as L1 tokens are locked into the L1ERC20Bridge in order to mint the corresponding L2 tokens. Currently, these L1 tokens can only be unlocked in the event of a withdrawal that is initialized through L2ERC20Bridge. In the event of an undiscovered bug in the L2 bridge, the only way to upgrade it would be to redeploy a new L1 bridge (since it is not upgradeable).  The new L1ERC20Bridge contract would then be intertwined with a new L2ERC20Bridge. One drawback of this approach is the inconvenience of re-deploying a new L1 contract every time there is a desire to change the L2 contract. In addition, each ERC-20 token minted on a different L2 bridge would generate a new L2 address, creating multiple copies of the same L1 token in L2. Consider making the L2ERC20Bridge upgradable by making it an implementation contract behind a proxy. However, note that even without this upgradeability of the L2 bridge, the upgradeability of the L1 bridge would still prevent L1 tokens from being locked forever.  Update: Resolved at commit b51d4c3.    getCodeHash function of the  EIP-1052 standard dictates that the return of precompile contracts should be either  setting them to their real code hash or to an arbitrary value during a  forced deployment, thereby causing an inconsistency with EIP-1052.  Consider conforming to EIP-1052 by adding additional checks to ensure that the precompile contracts return either of the values defined in the specification.  Update: Resolved in pull request #213 at commit 98cb968. The Matter Labs team stated:  We also added the correct codehash/codesize for the zero-address.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#potential-eip-1052-deviation", "labels": ["OpenZeppelin"]}, {"title": "Lack of Events", "body": "In ContractDeployer.sol, there is no event emitted when an AccountAbstractionVersion or an [AccountNonceOrdering] (https://github.com/matter-labs/system-contracts/blob/191246a878f1493a5ed5f0fa6d79af4ce3e7eb8f/contracts/ContractDeployer.sol#L81) are updated, which makes it challenging to monitor whether an account has updated either of these values.  In addition, the DepositInitiated event should emit the L2 transaction hash, because it may be needed to claim a failed deposit.  Consider emitting and updating these events to facilitate monitoring.  Update: Resolved in pull request #214 at commit d398cce and pull request #63 at commit d0ce4d4.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#lack-of-events", "labels": ["OpenZeppelin"]}, {"title": "setValueUnderNonce Value Is Mutable", "body": "sets a specific _value associated with a particular  While a user cannot reset the _value to 0, they can change it to any other non-zero quantity. This can be misleading for external entities that may be relying on it for particular information about the transaction. More importantly, since no event is emitted, an external party may not know that it has been changed.  Consider requiring that the _value for a particular _key is settable only once. Alternatively, if it is intended to be mutable, consider emitting an event every time it is set.  Update: Resolved in pull request #215 at commit d6fd17d. The Matter Labs team stated:  It is mutable in case users want to store some valuable data under the respective nonce. For example, a user might want to store a mapping such as (uniqueNonce => someInternalConstant).", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#setvalueundernonce-value-is-mutable", "labels": ["OpenZeppelin"]}, {"title": "Implicit Zero Cost Assumption", "body": "The L1ERC20Bridge contract will deploy the Layer 2 token bridge by passing a request to the Mailbox. However, it will not send any ETH. This is acceptable while the stub fee calculation uses a zero fee, but when the calculation is updated, messages that do not pay fees will be rejected.  In the interest of predictability, consider allowing ETH to be sent with the L2 bridge deployment request.  Update: Resolved in pull request #65 at commit 15b3433.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#implicit-zero-cost-assumption", "labels": ["OpenZeppelin"]}, {"title": "Floating Pragma Solidity Version", "body": "bridge and the  system contracts codebases, the version of Solidity used is  Solidity 0.8.8 and above. In addition, there is the usage of  bug detected regarding fixed-length bytes literals. While this bug does not currently affect the codebase, using an updated version will remove the possibility of future errors.  Consider upgrading all contracts to Solidity version 0.8.13 at a minimum, but ideally to the latest version.  Update: Resolved in pull request #66 at commit e422c7f. Regarding the floating point Solidity version, the Matter Labs team stated:  System contracts are exposing the System API to smart contract developers, so the code they write will have to adhere to the same compiler versions limitations. Similarly to OpenZeppelin Smart Contracts libraries, our System Contracts enforce the minimum Solidity version to ensure that they can be properly built, but do not pin a specific version, so we do not prevent the developers from using newer features.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#floating-pragma-solidity-version", "labels": ["OpenZeppelin"]}, {"title": "Unnecessarily Delayed Error Handling", "body": "When depositing ERC-20 tokens, the L1ERC20Bridge contract queries the tokens metadata, and sends the results to the L2ERC20Bridge contract. Any errors are still encoded on L1 and discarded on the L2 bridge. This pattern seems unnecessarily complex, and couples the processing on both sides. Consider detecting errors on L1 and only sending the relevant values over the bridge.  Update: Acknowledged, will resolve. The Matter Labs team stated:  We will take this change into account when further refactoring is done.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#unnecessarily-delayed-error-handling", "labels": ["OpenZeppelin"]}, {"title": "Interface Mismatch", "body": "The isNonceUsed function is defined in the NonceHolder contract, but it is missing in the INonceHolder interface.  Consider aligning the interface with the contract to fully represent its features.  Update: Resolved in pull request #216 at commit c9f1e3c.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#interface-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Variable Visibility Not Explicitly Declared", "body": "Throughout the bridge and system contracts codebases, there are state variables, constants, and immutables that lack an explicitly declared visibility:  The immutable allowList in L1ERC20Bridge.sol  The immutable zkSyncMailbox in L1ERC20Bridge.sol  The constant DEPLOY_L2_BRIDGE_COUNTERPART_ERGS_LIMIT in L1ERC20Bridge.sol  The constant DEFAULT_ERGS_PRICE_PER_PUBDATA in L1ERC20Bridge.sol  The state variable l2TokenProxyBytecodeHash in L2ERC20Bridge.sol  The state variable availableGetters in L2StandardERC20.sol  The constant EMPTY_STRING_KECCAK in AccountCodeStorage.sol  The state variable __DEPRECATED_l2Bridge in L2EthToken.sol  The constant DEPLOY_NONCE_MULTIPLIER in NonceHolder.sol  The constant MAXIMAL_MIN_NONCE_INCREMENT in NonceHolder.sol  For clarity, consider always explicitly declaring the visibility of variables, even when the default visibility matches the intended visibility.  Update: Acknowledged, will resolve. The Matter Labs team stated:  We will take this change into account when further refactoring is done.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#variable-visibility-not-explicitly-declared", "labels": ["OpenZeppelin"]}, {"title": "Code Redundancy", "body": "There are two instances in the codebase where redundant computations are performed:  In the ContractDeployer contract, there is some redundancy in the logic of the create{2}{Account} functions. Consider highlighting their differences and reusing existing logic by having one function call the other.  In the getErgsLimitForTx function of the bootloader, the ergsLimitForTx value is computed a second time after being computed as part of the getVerifiedOperatorOverheadForTx function. This particularly hinders the visibility of the underflow check.  Consider applying the above changes to improve the codes clarity.  Update: Resolved in pull request #218 at commit 5828dc1.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#code-redundancy", "labels": ["OpenZeppelin"]}, {"title": "Inexplicit Fail", "body": "In the L2EthToken contract, if the user attempts to transfer more funds than owned, the function reverts with a Solidity underflow error. This can result in a confusing user experience. Consider explicitly checking this condition and giving the user a proper revert reason if the transfer fails.  Update: Resolved in pull request #217 at commit d4e019f.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#inexplicit-fail", "labels": ["OpenZeppelin"]}, {"title": "Indecisive License", "body": "Throughout the codebase there are several files that state an SPDX license identifier of MIT OR Apache-2.0.  Consider agreeing on one license per file to prevent confusion on how these files can be used.  Update: Resolved in pull request #226 at commit d7c89a5.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#indecisive-license", "labels": ["OpenZeppelin"]}, {"title": "Misplaced Event", "body": "The L2StandardERC20 contract has the BridgeInitialization event defined in the contract, while its other events BridgeMint and BridgeBurn are defined in the IL2StandardToken interface.  Consider defining events in the same place for better visibility.  Update: Resolved in pull request #67 at commit 1de79d9.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#misplaced-event", "labels": ["OpenZeppelin"]}, {"title": "Gas Optimizations", "body": "The following opportunities for gas optimizations were identified:  In the L2StandardERC20 contract, the bridgeInitialize function checks that the l1Address is not the zero address. This is to guarantee that the contract has not been initialized before. However, the contract already has the initializer modifier, so the require statement is redundant.  The l2TokenProxyBytecodeHash variable can be made immutable since it is only set once in the constructor and there is no functionality to change it. The purpose of this variable is solely to determine the address of the L2 Token.  In the _splitRawNonce function a division by a power of two is made. Instead, a right shift by the exponent would be cheaper.  Consider making the above changes to reduce gas consumption.  Update: Partially resolved in pull request #68 at commit b37a19a. The Matter Labs team stated:  We did not implement the second and third suggestions, since immutable is more expensive in L2 contracts (see ImmutableSimulator contract) and the arithmetic operations are well-optimized by our compiler (LLVM backend!).", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Inexplicit Disable of Initialization", "body": "The L2StandardERC20 contract is used as the token logic contract for the bridge. Hence, each token is a beacon proxy instance which refers to the logic of the L2StandardERC20 contract, which is initializable. The actual logic contract is initialized by having the initializer modifier on the constructor, to prevent an attacker from initializing it maliciously.  Instead of using the modifier, consider calling the _disableInitializers function of the Initializable contract explicitly in favor of readability and clarity.  Update: Resolved in pull request #69 at commit 5db383b.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#inexplicit-disable-of-initialization", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Usage of Named Return Variables", "body": "_depositFunds and  l2TokenAddress functions have a return statement instead. On the other hand, the  _getCreate2Salt function. In the  getDeploymentNonce function.  Consider applying one return style for better readability.  Update: Acknowledged, not resolved. The Matter Labs team stated:  It makes sense to follow one style standard, but in practice, we see that different return methods are convenient in different cases, so for now we will stay with what we have. However, we will rethink this when we begin refactoring the codebase.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#inconsistent-usage-of-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Declaration of Integers", "body": "In the bootloader contract, there is an inconsistency in the way memory offsets are declared, with some being expressed in decimals and most others being expressed in hexadecimals. This deviation from a consistent notation can be confusing and make it difficult to understand the purpose and usage of these sizes. For instance:  add(txPtr, 32) in line 470  lt(returnlen, 96) in line 759  sub(returnlen, 0x40) in line 785  returndatacopy(PAYMASTER_CONTEXT_BEGIN_BYTE(), 64, effectiveContextLen) in line 796  Consider using a consistent notation for expressing memory offsets throughout the codebase.  Update: Partially resolved in pull request #219 at commit c022f89. There are more instances similar to the examples mentioned above that can be changed with further refactoring.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#inconsistent-declaration-of-integers", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "To favor explicitness and readability, there are several locations in the contracts that may benefit from better naming:  In L1ERC20Bridge.sol:  The txHash name is inconsistent with _l2TxHash. Consider renaming it to l2TxHash for consistency. The l2TokenFactory is not the factory, but rather the beacon. In fact, the factory is L2ERC20Bridge. Consider renaming it to l2TokenBeacon. The l2ProxyTokenBytecodeHash name is inconsistent with l2TokenProxyBytecodeHash. Consider renaming it to l2TokenProxyBytecodeHash for consistency.  In L2ERC20Bridge.sol:  The l2TokenFactory is not the factory, but rather the beacon. In fact, the factory is L2ERC20Bridge. Consider renaming it to l2TokenBeacon.  In L2StandardERC20.sol:  The BridgeInitialization event  is inconsistent with the other events named BridgeMint and BridgeBurn. Consider renaming it to BridgeInitialize.  In AccountCodeStorage.sol:  The function Utils.isContractConsructing is spelled incorrectly. Consider renaming it to isContractConstructing.  Update: Resolved in pull request #220 at commit d5bf7da and pull request #70 at commit 0cb750b.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "Throughout the codebase imports on the following lines are unused and could be removed:  Import IAccountCodeStorage of ContractDeployer.sol  Import IKnownCodesStorage of ContractDeployer.sol  Import INonceHolder of ContractDeployer.sol  Import IL2StandardToken of L2EthToken.sol  Import IMailbox, L2Log, and L2Message of IL1Bridge.sol  Consider removing unused imports to avoid confusion that could reduce the overall clarity and readability of the codebase.  Update: Resolved in pull request #221 at commit 49dbcf5 and pull request #71 at commit 53beb18.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Theoretical Aggregate ETH Inconsistency", "body": "The forceDeployOnAddresses function attempts to send the specified amount of L2 ETH with each deployment, after collecting the aggregate amount. However, the value sent with each call is implicitly truncated to the least significant 128 bits (henceforth, lower half). This means the most significant 128 bits (upper half) of every value parameter is ignored, which has two implications:  Any deployment that attempts to send more than 2128 Wei will only send the lower half of the amount, leaving the rest in the ContractDeployer contract.  The FORCE_DEPLOYER address can manipulate the upper half of the aggregate amount by setting large values that will be truncated. It can also cause the result to overflow, since the summation occurs inside an unchecked block. If the actual aggregated amount exceeds 2128 Wei and the FORCE_DEPLOYER address manipulates the summation to clear the upper half, they will only need to pay for the lower half of the amount. The rest will come out of the ContractDeployer contracts own balance.  In practice, the total supply will be less than 2128 for the foreseeable future, so neither scenario should be possible. In addition, the FORCE_DEPLOYER is a trusted address that would not be expected to manipulate the deployment configurations. Nevertheless, all assumptions should be enforced wherever possible. In the interest of predictability and local reasoning, consider restricting the ForceDeployment.value parameter to 128 bits. Alternatively, consider requiring the msg.value to be less than 2128 Wei instead of truncating it, which would remove the possible inconsistency for all use cases.  Update: Resolved in pull request #222 at commit 9600e74. The Matter Labs team stated:  The msg.value is not implicitly truncated (if so we would have a larger issue). The compiler checks if the value is less than 2^128, and panics otherwise. The sumOfValues overflow was resolved.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#theoretical-aggregate-eth-inconsistency", "labels": ["OpenZeppelin"]}, {"title": "Checks-Effects-Interactions Recommendation", "body": "The deposit function of the L1ERC20Bridge contract interacts with an untrusted token before updating its own state. Although it is protected by the nonReentrant modifier and there are no reentrancy possibilities in the current codebase, as a matter of good practice, consider moving the token transfer to the end of the function to follow the checks-effects-interactions pattern.  Update: Acknowledge, not resolved. The Matter Labs team stated:  We agree that in general it is more appropriate to use patterns wherever possible. However, in our case, to follow the checks-effects-interactions we would need to remove the calculation of the amount of deposited money, as the balance differs before and after. On other hand, it is difficult for us to imagine a reentrancy attack on this contract and we are already defending against this possibility with a nonReentrant modifier. As a result, we decided not to implement the fix.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#checks-effects-interactions-recommendation", "labels": ["OpenZeppelin"]}, {"title": "Complex Nonce Packing", "body": "The NonceHolder contract uses a single storage slot to pack each accounts deployment nonce and minimum transaction nonce.  Instead of manually splitting and recombining them, consider defining a struct that holds them both. That struct can then be saved in the rawNonces mapping and the individual nonces can be accessed and updated more easily.  Update: Acknowledged, will resolve. The Matter Labs team stated:  We will take this change into account when further refactoring is done.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#complex-nonce-packing", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "Throughout the codebase we identified the following typographical errors:  that used \u2192 that is used in L1ERC20Bridge.sol  the transferring funds \u2192 the transferring of funds in L1ERC20Bridge.sol  which do not \u2192 which it does not in L2StandardERC20.sol  store \u2192 stores in L2ERC20Bridge.sol  initiate \u2192 initiated in L2ERC20Bridge.sol  Deploys \u2192 Deploy in L2ERC20Bridge.sol  eiher \u2192 either in NonceHolder.sol  value value \u2192 value in NonceHolder.sol  server \u2192 serve in NonceHolder.sol  rather rather \u2192 rather in NonceHolder.sol  msg.sneder \u2192 msg.sender in NonceHolder.sol  methodd \u2192 method in NonceHolder.sol  That is means \u2192 That means in bootloader.yul  we need to the ability to \u2192 we need the ability to in bootloader.yul  transfered \u2192 transferred in bootloader.yul  that \u2192 than in bootloader.yul  provides provides \u2192 provides in bootloader.yul  No colission is not possible and No colission is possible \u2192 No collision is possible in ContractDeployer.sol  Consider correcting these typographical errors.  Update: Resolved in pull request #223 at commit 7042d1f, pull request #228 at commit 5398a91, and pull request #72 at commit f0c0544.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unclean Code", "body": "The line that extracts the isSystemCall flag has two sets of redundant brackets that do not clarify the order of operations.  Consider grouping the bit AND operation before the logical != operation, or removing the brackets entirely.  Update: Resolved in pull request #224 at commit ad13199.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#unclean-code", "labels": ["OpenZeppelin"]}, {"title": "Missing and Misleading Documentation", "body": "The following parts of the codebase are lacking documentation:  The _l2TxErgsLimit parameter of the deposit function is undocumented.  The following codes are missing @param statements:  All parameters of the L2StandardERC20 contract. The resultPtr parameter of the processL1Tx function. The _aaVersion parameter of the createAccount and create2Account functions. The _sender parameter of the _performDeployOnAddress function.  The following functions of the bootloader are undocumented:  l2TxExecution l2TxValidation getErgsLimitForTx getOperatorRefundForTx getOperatorOverheadForTx getVerifiedOperatorOverheadForTx l1TxPreparation SCRATCH_SPACE_BEGIN_BYTE  The following documentation is misleading:  The comment on the _l1Token address says Always should be equal to zero, which does not make sense.  The comment on the _l2TokenFactory address says Pre-calculated address of L2 token beacon proxy. However, the address is actually that of the UpgradeableBeacon contract.  The comment on the L2EthToken contract is missing that the bootloader also interacts with it.  The comment on the _hash parameter should state that the account is constructing and is not constructed.  The comment on the KnownCodeStorage contract is wrong since the implementation of the bytecode hash matches this comment.  The comment on the mint function states to be only callable by the ETH bridge. This is obsolete and should refer to the bootloader now.  The comment on the withdraw function states that funds are claimable through finalizeWithdrawal, but the function is actually called finalizeEthWithdrawal.  The comment on the updateNonceOrdering function ignores the fact that the ordering can only be changed from sequential to arbitrary.  The comment on the createAccount function claims to accept a nonce as one of its parameters, however, salt is meant.  The comment on the MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT constant addresses the second extraAbi parameter, while it is actually the first.  The comment mentioning NEW_CODE_HASHES_START_PTR and MAX_NEW_CODE_HASHES does not match any code.  The comment within the getNewAddressCreate function refers to collision resistance with Ethereums CREATE2 but it should be Ethereums CREATE.  Consider adding more documentation to the codebase to enhance its clarity. In addition, consider rephrasing misleading comments to match the intention of the code.  Update: Resolved in pull request #225 at commit 3a28b44, pull request #218 at commit 5828dc1, and pull request #73 at commit 275d73e.", "html_url": "https://blog.openzeppelin.com/zksync-fee-model-and-token-bridge-audit#missing-and-misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Deposit cap not updated on withdrawals", "body": "User deposits are capped by increasing the totalDepositedAmountPerUser counter. However, the counter is not decreased by withdrawals.  As the counter can only be increased, after sufficient usage, all withdrawing users will be locked out of depositing again. This can possibly happen right after the first deposit and withdrawal, if the initial amount is larger than half the cap.  Consider decreasing the per-user cap during withdrawals to allow users to return to the rollup.  Update: Acknowledged, not resolved. The Matter Labs team stated:  The deposit limitations are only enabled in Fair Onboarding Alpha, while only approved partners may deposit funds. This will be removed at Full Launch Alpha, so we treat this issue as an accepted risk.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#deposit-cap-not-updated-on-withdrawals", "labels": ["OpenZeppelin"]}, {"title": "ETH withdrawal within allowed limit could fail", "body": "The protocol enforces an ETH withdraw limit (currently 10% of the total balance) within each 1-day window as a safety mechanism. This is done through the _verifyWithdrawalLimit function in Mailbox.sol. However, this function has a logic flaw that could cause an ETH withdrawal within the limit to fail.  When withdrawal validations occur within the same 1-day window, the function checks the limit in line 215 of Mailbox, as follows:  However, address(this).balance has already changed due to the previous withdrawal within the same day, causing the allowance to be less than the allowed 10%. This could cause any planned withdrawal to fail due to previous withdrawals. Note that a similar issue could also exist in the ERC-20 bridge .  Consider recording address(this).balance when updating s.lastWithdrawalLimitReset, and using it as the base when calculating the daily withdraw limit.  Update: Resolved in pull request #60 at commit 6365a8b. The Matter Labs team decided to completely remove the withdrawal limitation.  Medium Severity", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#eth-withdrawal-within-allowed-limit-could-fail", "labels": ["OpenZeppelin"]}, {"title": "Refund recipient defaults to inaccessible address for contracts", "body": "In _requestL2Transaction, if address(0) is specified as the refund recipient, msg.sender is used by default. However, the msg.sender address will not be controllable by contracts on L2, so any refund, or the bridged ETH amount in case of a failed transaction, will be lost.  Consider disallowing unspecified refund recipients for any ETH transfers, or reverting in the case of an unspecified recipient if the sender is not an EOA.  Update: Resolved in pull request #32 at commit 201c99c.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#refund-recipient-defaults-to-inaccessible-address-for-contracts", "labels": ["OpenZeppelin"]}, {"title": "Formula and documentation mismatch", "body": "The formula for overheadForPublicData uses Tm which is defined as the maximal transaction ergs limit here.  This appears to correspond in code to L2_TX_MAX_GAS_LIMIT:  /// @dev The maximum number of L2 gas that a user can request for an L2 transaction  However, the calculation in code uses the MAX_PUBDATA_PER_BLOCK constant instead, which refers to:  /// @dev The maximum number of the pubdata an L2 operation should be allowed to use.  This corresponds to Pm in the documentation.  These appear to be different quantities, measured in different units, of different magnitudes (80000000 vs 110000). As a result, a denial of service may occur if the overhead is calculated incorrectly (underestimated), which will result in l2GasForTxBody being overestimated, and possibly reverting in _writePriorityOp despite having legitimate values passed as inputs.  Alternatively, as the overhead is underestimated, a larger-than-limit l2GasForTxBody may be submitted, which will cause failures on L2.  Consider adding test cases to the documentation with concrete example values, and implementing these test cases in the codebase test suite to ensure basic compatibility. Additionally, consider documenting in code both the correspondence of the constants to the documentations notation, and the derivation and logic of the formulas implemented in comments in the same file, so that access to external documentation would not prevent the reader from reviewing the code.  Update: Partially resolved in pull request #34 at commit 19c7b81. The Matter Labs team stated:  Acknowledged. For now, we have decided to temporarily remove the overhead. The issue will be fixed once we introduce the block overhead back to our users.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#formula-and-documentation-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Unchecked subtraction underflow", "body": "L2 gas validation performs an unchecked subtraction, and a neighboring comment states that the underflow prevention is enforced by the implementation of the preceding computation. However, the preceding computation takes a large variety of constants and variable parameters, which depending on their values can still cause an underflow.  For example, the calculation of the memory overhead can result in arbitrarily large values depending on the value passed in _encodingLength and the constant BOOTLOADER_TX_ENCODING_SPACE, since both values ranges are not validated.  Note that it is likely that there are additional ways by which the combination of different possible values of constants and inputs could cause the resulting overhead to be higher than the total gas limit.  This may result in an underflow of the unchecked subtraction. In turn, it will likely cause a revert due to subsequent l2GasForTxBody checks.  Consider not using the unchecked subtraction to prevent the underflow, and adding an explicit check to validate the overhead.  Update: Resolved in pull request #54 at commit 94bc1a6.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#unchecked-subtraction-underflow", "labels": ["OpenZeppelin"]}, {"title": "User could deposit more ETH than allowed", "body": "zkSync has implemented a limit on the amount of ETH that can be deposited to L2 per account. However, the code currently has a design flaw that allows users to bypass this limit by exploiting a gas refund scheme. Specifically, in the requestL2Transaction function, the deposited ETH amount is verified using the _l2Value parameter, while the valueToMint parameter is set to msg.value when composing a priority queue transaction.  This means that a user can mint ETH without triggering the limit by setting _l2Value = 0 and using the gas refund when requesting any L2 transactions. Furthermore, even if msg.value was set as the limit amount, the user could run into issues when trying to request L2 transactions from L1 after reaching their limit.  To mitigate this issue, a system design change is needed around L2 gas refunding or ETH bridging limits. However, the specifics of the solution will depend on the overall design and goals of the system. Careful consideration and testing will be needed to ensure that the solution effectively mitigates this issue while also preserving the intended functionality of the system.  Update: Resolved in pull request #32 at commit 201c99c.msg.value is now used to verify the deposited ETH amount, however as we pointed out above, this design choice could mean users might not be able to request L2 transactions after reaching their limit.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#user-could-deposit-more-eth-than-allowed", "labels": ["OpenZeppelin"]}, {"title": "Block overhead limits may be exceeded", "body": "In _getOverheadForTransaction some overhead values can go over their maximum values if the transaction data or the public data posted (e.g., state changes) are large:  _encodingLength can take more memory than allowed by the BOOTLOADER_TX_ENCODING_SPACE.  overheadForPublicData for the transaction can be larger than the MAX_PUBDATA_PER_BLOCK constant.  overheadForComputation can be larger than the L2_TX_MAX_GAS_LIMIT.  Exceeding these values may violate invariants that are important for accurate L2 gas metering.  Consider checking that the encoded transaction length is in the expected range to prevent going over the maximum expected values. Additionally, consider checking that at no point the resulting calculated overhead is larger than the maximum overhead.  Update: Partially resolved in pull request #34 at commit 19c7b81. The Matter Labs team stated:  Acknowledged. We temporarily removed the block overhead, but a fix will be applied when restoring it.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#block-overhead-limits-may-be-exceeded", "labels": ["OpenZeppelin"]}, {"title": "Lack of tests", "body": "There are very few tests for most functionalities.  For example, Mailbox.sol (particularly MailboxFacet) is a key contract for the L1 bridge, and has 360+ lines of code and a large dependency tree of aggregated thousands of lines of non-library solidity code (specific to this codebase). The code implements sensitive functionality with many important details and execution branches. However, there are only four basic tests in mailbox_test.ts:  One test for non-reverting execution of an expected valid input. This tests nothing about the successful execution results.  Three more tests that check reverts in L2ContractsHelper contract.  This means that the entirety of the MailboxFacet functionality is untested in this repository.  Furthermore, as some system-level integration tests exist in another repository, there too, most of the functionality of the Mailbox remains untested:  There are no invocations for the finalizeEthWithdrawal mutative method, or the views proveL2LogInclusion, proveL1ToL2TransactionStatus, and serializeL2Transaction.  There is a single file for L1 functionality that invokes the main requestL2Transaction method. This test file totals around 300 lines of testing code, for which the majority of tests only assert either a revert or a lack of revert.  This leads to several potential issues:  The correctness of the code can only be assessed based on partial, and changing documentation. This is because intended and unintended behavior is not captured in tests.  Introduction of new vulnerabilities for established code in future code changes, since known positive and negative behaviors are not checked automatically.  Higher likelihood of missed vulnerabilities in current and future development and review.  Consider adding contract-level testing to test all branches of execution. Additionally, consider implementing an ongoing measurement of testing coverage as a way to ensure at least 95% coverage.  Update: Partially resolved in pull request #36, pull request #42, pull request #43, pull request #45, pull request #46, pull request #48 and pull request #51. The Matter Labs team stated:  We are working on improving the test coverage over the entire codebase.  Low Severity", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#lack-of-tests", "labels": ["OpenZeppelin"]}, {"title": "Missing documentation", "body": "Docstrings and inline comments are missing in several parts of the codebase with sensitive functionality. For example:  The entirety of L2ContractHelper contract: the functionality is internal, but is complex and coupled with other interfaces (custom encoding of bytecode hashes, custom create2 address derivation, etc).  _getMinimalPriorityTransactionGasLimit: it is possible that this method overestimates / underestimates, or is implemented incorrectly. However, relevant documentation was insufficient to validate this.  Consider including thorough docstrings and inline explanations with references to relevant source files or documentation, allowing readers or maintainers to verify the implementations and their correct usage.  Update: Resolved in pull request #55 at commits 41946cc and 57f702d.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#missing-documentation", "labels": ["OpenZeppelin"]}, {"title": "Revert messages are not informative", "body": "This issue has been reported in the previous Layer 1 Diff Audit (L01  Missing error messages in require statements). Reverts are important logical components, and a lack of revert messages makes them confusing and increases the chance of missing vulnerabilities during a review.  The codebase as a whole has revert messages that consist of two letters and convey no information. Additionally, the two-letter combinations collide (for example po) for different contracts. Crucially, no resource is available to translate the codes into meaningful error messages. Although something is typically mentioned in comments next to the revert, a meaningful error message (or a custom error) is expected since comments can be outdated and cannot be tested.  Consider using informative error messages or custom errors throughout the codebase.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We agree that custom errors will be much more understandable and convenient. At this time, we have no capacity for such a large refactoring, but we have planned it for the next milestone.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#revert-messages-are-not-informative", "labels": ["OpenZeppelin"]}, {"title": "L2 transaction hash is not emitted", "body": "The L2 transaction hash is a needed input during the L1 to L2 transaction flow on chain (in claimFailedDeposit), and for keeping track of L2 inclusion success off chain. However, it is not emitted in events by the callers in _requestDeployTransaction() or during ERC-20 deposit(). As a consequence, off-chain infrastructure (indexers, UIs, analytics dashboards) will not be able to keep track of bridging activity as easily.  Consider emitting the resulting transaction hash in an event after submitting the request in the MailboxFacet.  Update: Resolved. We later found that this was not an issue because the hash was emitted in event NewPriorityRequest as stated by the Matter Labs team:  _requestDeploy is only used for the bridge initialization, so we do not think it may affect off-chain infrastructure (indexers, UIs, analytics dashboards). Moreover, the transaction hashes are emitted in the Mailbox itself.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#l2-transaction-hash-is-not-emitted", "labels": ["OpenZeppelin"]}, {"title": "Diamond proxy holding large bridged ETH balance", "body": "In the current design, ERC-20 bridging uses a separate contract to hold token balances, but MailboxFacet holds and operates the ETH balance. However, since it is implemented as part of the Diamond Proxy, this means that the contract balance is common to all current and future facets of the proxy. This poses several risks:  It exposes the bridged and locked funds to an additional risk of exploit by introducing vulnerabilities in the other facets.  The locked balance is possibly co-mingled with other ETH that may be in use by the other facets.  By adding functionality to handle outbound ETH transfers, it introduces a site for a call to a user-defined destination out of the main proxy that can potentially be leveraged for other future attacks.  Considering that the ETH balance of the bridge may become very large, it may be better to design a system that reduces these risks.  Consider handling ETH deposits and withdrawals by converting them to WETH and using the ERC-20 bridge. This will have the additional benefit of avoiding balance handling code duplication between the MailboxFacet and the ERC-20 bridge, and will also remove the need to make a dangerous ETH transfer call out of the contract.  Update: Acknowledged, not resolved. The Matter Labs team stated:  Holding deposited ETH in the diamond proxy was a difficult decision, but we could not equip an efficient approach and stable fee model in a different way (users send L1 to L2 transactions and receive ETH refunds). So all ETH should be held in one contract (either EthBridge or diamond proxy).", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#diamond-proxy-holding-large-bridged-eth-balance", "labels": ["OpenZeppelin"]}, {"title": "Cross-chain system contract invocation is allowed and undocumented", "body": "System contract addresses can be specified in requestL2Transaction. However, this can cause potential unexpected side effects when executing the transactions on L2 since system contracts are documented to not be intended for direct invocation by users.  For example, if the destination address is set to the system ContractDeployer, it appears that the bootloader will execute it in isSystem mode. This code path is used for the deployment of the ERC-20 bridge in L1ERC20Bridge.initialize.  It is possible that allowing this invocation path from L1 may introduce vulnerabilities and side effects, depending on each specific system contracts access control. This is because L1 and L2 invocation paths in the bootloader are treated differently and may encode different assumptions which may be violated in one path but not in the other. If calling most system contracts is not an expected usage pattern, allowing the users to make these cross-chain calls creates an unnecessary attack surface area.  Consider restricting the addresses allowed to be called from L1. This can be done by checking that the destination address doesnt fall into the system contracts address space. Additionally, consider documenting these usage patterns.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We agree that calling system contracts can be dangerous in general. However, due to the design of L1-to-L2 transactions, we do not see any potential problems with calling system contracts. The same call may be done via L2 by directly calling the system contracts.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#cross-chain-system-contract-invocation-is-allowed-and-undocumented", "labels": ["OpenZeppelin"]}, {"title": "Contract poorly named and structured", "body": "The L2ContractHelper file and contract present several issues that impact readability:  It is named in a way that does not describe its intent or usage. Consider renaming it more appropriately according to its functions (e.g., splitting it into CustomEncodings and L2Addresses).  sendMessageToL1 is unused along with its dependencies (L2_MESSENGER and IL2Messenger). Consider removing it altogether.  The file contains additional constants and interfaces that are not used within it, but are used in other importing files. For example, IContractDeployer or FORCE_DEPLOYER are not used in this file, among others. Consider removing the unused instances.  Update: Resolved in pull request #55 at commits dfb4e4b and e2b2cf0.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#contract-poorly-named-and-structured", "labels": ["OpenZeppelin"]}, {"title": "Local variable shadows state variable", "body": "In Allowlist.sol the _owner local variable shadows the _owner state variable from Ownable.  Consider renaming the local variable to avoid potential errors.  Update: Resolved in pull request #56 at commit 40cd9d0.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#local-variable-shadows-state-variable", "labels": ["OpenZeppelin"]}, {"title": "Facet contract names and filenames do not match", "body": "Facet contracts are suffixed with Facet (e.g., MailboxFacet) but the filenames lack the suffix (e.g., Mailbox.sol).  Consider renaming the files to match the contract names.  Update: Acknowledged, will resolve. The Matter Labs team stated that they will resolve the issue:  We are aware of this, and will address it when higher-priority tasks are solved.  require statement lacking revert message  The require statement in _requestL2Transaction lacks an error message.  Consider adding one to improve the readability and clarity of the codebase.  Update: Resolved in pull request #57 at commit 38b8426.  Naming issues hinder code understanding and readability  To improve the explicitness and readability of the contracts, consider using more descriptive and clear naming in the Allowlist. Some suggestions include:  On line 29, Withdrawal should be WithdrawalLimit.  On line 30, withdrawalLimitation should be enabled.  On line 37, Deposit should be DepositLimit.  On line 60, getTokenWithdrawalLimitData should be getTokenWithdrawalLimit.  On line 62, getTokenDepositLimitData should be getTokenDepositLimit.  On line 28, tokenWithdrawal should be withdrawalLimits.  On line 31, tokenDeposit should be depositLimits.  Update: Acknowledged, will resolve. The Matter Labs team stated that they will resolve the issue:  Good suggestion! We are going to remove the deposit limitation (next milestone), and are already reimplementing the withdrawal limitation in H-02, so we will not apply these changes now.  Refund can be used to split bridged ETH and force transfer  The bridged ETH amount is split between the _l2Value and the gas payment on L2, which is unknown at the time of the L1 submission. The refund mechanism therefore exists to refund the excess gas payment to a user-selected recipient. However, currently the L2 gas cost for an L1 transaction is set to 0 during transaction serialization. Since no gas payment is taken on L2, there is no current need for splitting the ETH amount. Allowing the splitting with no gas costs creates a problem by allowing to split ETH between two destinations.  The ETH refund in case of a successful transaction is always the difference between the msg.value and the user provided _l2Value. In this case, the bridging mechanism has these qualities:  ETH is bridged simultaneously to two addresses (the recipient, and the refund recipient), in quantities determined by the user.  ETH is forced upon the refund recipient even if it is a contract that has no payable fallback and is not able to transfer it later. This is because refunded ETH is transferred without a call (with only a forced balance update).  This makes the bridging interface confusing and error-prone for integrations.  Consider disallowing the splitting of bridged ETH while the L2 gas cost for L1 transactions is 0 by checking that _l2Value is always equal to msg.value.  Update: Acknowledged, not resolved. The Matter Labs team stated:  Acknowledged. L1-to-L2 transactions will become payable in the next milestone.  Unused method  _deriveL2GasPrice is an unused method and can be removed to improve readability and reduce deployment gas costs.  The method could not be audited without usage context.  Update: Acknowledged, not resolved. The Matter Labs team stated:  It is planned to enable paid L1-to-L2 transactions for the next milestone, so we will not remove the method, since we will need to restore it soon.  Grammar and spelling issues  In AddressAliasHelper .sol, consider improving the following comments:  Utility function that converts the address in the L1 that submitted a tx to the inbox to the msg.sender viewed in the L2 should be Utility function converts the address that submitted a tx to the inbox on L1 to the msg.sender viewed on L2.  Utility function that converts the msg.sender viewed in the L2 to the address in the L1 that submitted a tx to the inbox should be Utility function that converts the msg.sender viewed on L2 to the address that submitted a tx to the inbox on L1.  In line 134 of Allowlist.sol, withdrwal should be withdrawal.  Update: Resolved in pull request #59 at commit ce11429.  Inefficient code  Line 500 of mailbox.sol computes the block overhead as  It is not necessary to use Math.max here, as blockOverheadForTransaction is 0 and txSlotOverhead >=0. Consider changing it to blockOverheadForTransaction = txSlotOverhead instead.  Update: Acknowledged, will resolve. The Matter Labs team stated that they will resolve the issue:  Acknowledged. The block overhead is removed for now, but we will fix the issue soon.  Conclusions  During a two-week period, we conducted a differential audit that focused on the codebase changes related to the implementation of new functions such as ETH bridging and gas-related modifications. Our audit identified 2 high-severity issues, 5 medium-severity issues, as well as some low-severity issues and notes. Most of these issues are associated with the newly introduced functions and design decisions. Working with the Matter Labs team continues to be a great experience.  Appendix  Extra Monitoring Recommendations  While we have recommended monitoring solutions for the system in the past, it is important to also consider new monitoring solutions for the recently added functions.  Technical  Medium: Since the current system design relies on the operator to cover the gas cost of the rollup process associated with L1, consider monitoring the ETH balance of the operators address to ensure the system operates smoothly.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#facet-contract-names-and-filenames-do-not-match", "labels": ["OpenZeppelin"]}, {"title": "require statement lacking revert message", "body": "require statement lacking revert message", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#require-statement-lacking-revert-message", "labels": ["OpenZeppelin"]}, {"title": "Naming issues hinder code understanding and readability", "body": "To improve the explicitness and readability of the contracts, consider using more descriptive and clear naming in the Allowlist. Some suggestions include:  On line 29, Withdrawal should be WithdrawalLimit.  On line 30, withdrawalLimitation should be enabled.  On line 37, Deposit should be DepositLimit.  On line 60, getTokenWithdrawalLimitData should be getTokenWithdrawalLimit.  On line 62, getTokenDepositLimitData should be getTokenDepositLimit.  On line 28, tokenWithdrawal should be withdrawalLimits.  On line 31, tokenDeposit should be depositLimits.  Update: Acknowledged, will resolve. The Matter Labs team stated that they will resolve the issue:  Good suggestion! We are going to remove the deposit limitation (next milestone), and are already reimplementing the withdrawal limitation in H-02, so we will not apply these changes now.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#naming-issues-hinder-code-understanding-and-readability", "labels": ["OpenZeppelin"]}, {"title": "Refund can be used to split bridged ETH and force transfer", "body": "The bridged ETH amount is split between the _l2Value and the gas payment on L2, which is unknown at the time of the L1 submission. The refund mechanism therefore exists to refund the excess gas payment to a user-selected recipient. However, currently the L2 gas cost for an L1 transaction is set to 0 during transaction serialization. Since no gas payment is taken on L2, there is no current need for splitting the ETH amount. Allowing the splitting with no gas costs creates a problem by allowing to split ETH between two destinations.  The ETH refund in case of a successful transaction is always the difference between the msg.value and the user provided _l2Value. In this case, the bridging mechanism has these qualities:  ETH is bridged simultaneously to two addresses (the recipient, and the refund recipient), in quantities determined by the user.  ETH is forced upon the refund recipient even if it is a contract that has no payable fallback and is not able to transfer it later. This is because refunded ETH is transferred without a call (with only a forced balance update).  This makes the bridging interface confusing and error-prone for integrations.  Consider disallowing the splitting of bridged ETH while the L2 gas cost for L1 transactions is 0 by checking that _l2Value is always equal to msg.value.  Update: Acknowledged, not resolved. The Matter Labs team stated:  Acknowledged. L1-to-L2 transactions will become payable in the next milestone.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#refund-can-be-used-to-split-bridged-eth-and-force-transfer", "labels": ["OpenZeppelin"]}, {"title": "Unused method", "body": "_deriveL2GasPrice is an unused method and can be removed to improve readability and reduce deployment gas costs.  The method could not be audited without usage context.  Update: Acknowledged, not resolved. The Matter Labs team stated:  It is planned to enable paid L1-to-L2 transactions for the next milestone, so we will not remove the method, since we will need to restore it soon.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#unused-method", "labels": ["OpenZeppelin"]}, {"title": "Grammar and spelling issues", "body": "In AddressAliasHelper .sol, consider improving the following comments:  Utility function that converts the address in the L1 that submitted a tx to the inbox to the msg.sender viewed in the L2 should be Utility function converts the address that submitted a tx to the inbox on L1 to the msg.sender viewed on L2.  Utility function that converts the msg.sender viewed in the L2 to the address in the L1 that submitted a tx to the inbox should be Utility function that converts the msg.sender viewed on L2 to the address that submitted a tx to the inbox on L1.  In line 134 of Allowlist.sol, withdrwal should be withdrawal.  Update: Resolved in pull request #59 at commit ce11429.", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#grammar-and-spelling-issues", "labels": ["OpenZeppelin"]}, {"title": "Inefficient code", "body": "Inefficient code", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#inefficient-code", "labels": ["OpenZeppelin"]}, {"title": "s", "body": "ecurity aement wa prepared by OpenZeppelin.  Table of Content  Table of Content  Summary  Scope  Sytem Overview Privileged Role and Trut Aumption Teting Coverage Recommendation  High Severity  Depoit cap not updated on withdrawal ETH withdrawal within allowed limit could fail  Medium Severity  Refund recipient default to inacceible addre for contract Formula and documentation mimatch Unchecked ubtraction underflow Uer could depoit more ETH than allowed Block overhead limit may be exceeded Lack of tet  Low Severity  Miing documentation Revert meage are not informative L2 tranaction hah i not emitted Diamond proxy holding large bridged ETH balance Cro-chain ytem contract invocation i allowed and undocumented  Note & Additional Information  Contract poorly named and tructured Local variable hadow tate variable Facet contract name and filename do not match require tatement lacking revert meage Naming iue hinder code undertanding and readability Refund can be ued to plit bridged ETH and force tranfer Unued method Grammar and pelling iue Inefficient code  Concluion  Appendix  Extra Monitoring Recommendation  Summary  Type  Rollup  Timeline  From 2023-02-06  To 2023-02-17  Language  Solidity  Total Iue  22 (10\u202freolved, 3\u202fpartially\u202freolved)  Critical Severity Iue  0 (0\u202freolved)  High Severity Iue  2 (1\u202freolved)  Medium Severity Iue  6 (3\u202freolved, 3\u202fpartially\u202freolved)  Low Severity Iue  5 (2\u202freolved)  Note & Additional Information  9 (4\u202freolved)  Scope  We audited change to the matter-lab/zkync-2-contract repoitory at the 3f345ce commit, and conducted full audit of AddreAliaHelper.ol and L2ContractHelper.ol.  In cope were the following contract:  Sytem Overview  zkSync Era i a permiionle general-purpoe ZK rollup that operate imilarly to L1 blockchain and idechain. It enable deployment and interaction with Turing-complete mart contract, which are executed on a pecialized virtual machine called the zkEVM. It important to note that the bytecode for the zkEVM i different from the L1 EVM, but there are Solidity and Vyper compiler available for developing L2 mart contract. A trength of zkSync Era i it protocol for paing meage between L1 and L2. Thi provide a tandard way for uer to interact with mart contract acro both layer.  Privileged Role and Trut Aumption  The governor currently poee a uperpower to upgrade contract intantaneouly and indefinitely freeze them, but thi power i only temporary. In the future, the upgrade proce will be ubject to time lock and the duration of freezing will be limited, thu preventing the governor from exploiting their power.  Teting Coverage Recommendation  Several concern regarding the teting of the current ytem were identified during the audit. While there i a eparate finding highlighting thee concern for the pecific contract within the cope of thi audit, it i important to note the overall ytematic rik here.  Inufficient teting, while not a pecific vulnerability, implie the high probability of additional unfound vulnerabilitie and bug. It alo exacerbate multiple interrelated rik factor in a complex code bae with novel functionality. Thi include a lack of full implicit pecification of the functionality and exact expected behavior that tet normally provide, which increae the chance that correctne iue will be mied. It alo require more effort to etablih baic correctne and reduce the effort pent exploring edge cae, thereby increaing the chance of miing complex iue.  Moreover, the lack of repeated automated teting of the full pecification increae the chance of introducing breaking change and new vulnerabilitie. Thi applie to both previouly audited code and future change to currently audited code. Thi i particularly true in thi project due to the pace, extent, and complexity of ongoing and planned change acro all part of the tack (L1, L2, bootloader and ytem contract, compiler and VM). Underpecified interface and aumption increae the rik of ubtle integration iue, which teting could reduce by enforcing an exhautive pecification.  To addre thee iue, we recommend implementing a comprehenive multi-level tet uite before the next expected audit. Such a tet uite hould comprie contract-level tet with 95%-100% coverage, per layer deployment and integration tet that tet the deployment cript a well a the ytem a a whole, per layer fork tet for planned upgrade, and cro-chain full integration tet of the entire ytem. Crucially, the tet uite hould be documented in a way that a reviewer can et up and run all thee tet layer independently of the development team. Some exiting example of uch etup can be uggeted for ue a reference in a follow-up converation. Implementing uch a tet uite hould be a very high priority to enure the ytem robutne and reduce the rik of vulnerabilitie and bug.  High Severity  Depoit cap not updated on withdrawal  Uer depoit are capped by increaing the totalDepoitedAmountPerUer counter. However, the counter i not decreaed by withdrawal.  A the counter can only be increaed, after ufficient uage, all withdrawing uer will be locked out of depoiting again. Thi can poibly happen right after the firt depoit and withdrawal, if the initial amount i larger than half the cap.  Conider decreaing the per-uer cap during withdrawal to allow uer to return to the rollup.  Update: Acknowledged, not reolved. The Matter Lab team tated:  The depoit limitation are only enabled in Fair Onboarding Alpha, while only approved partner may depoit fund. Thi will be removed at Full Launch Alpha, o we treat thi iue a an accepted rik.  ETH withdrawal within allowed limit could fail  The protocol enforce an ETH withdraw limit (currently 10% of the total balance) within each 1-day window a a afety mechanim. Thi i done through the _verifyWithdrawalLimit function in Mailbox.ol. However, thi function ha a logic flaw that could caue an ETH withdrawal within the limit to fail.  When withdrawal validation occur within the ame 1-day window, the function check the limit in line 215 of Mailbox, a follow:  However, addre(thi).balance ha already changed due to the previou withdrawal within the ame day, cauing the allowance to be le than the allowed 10%. Thi could caue any planned withdrawal to fail due to previou withdrawal. Note that a imilar iue could alo exit in the ERC-20 bridge .  Conider recording addre(thi).balance when updating .latWithdrawalLimitReet, and uing it a the bae when calculating the daily withdraw limit.  Update: Reolved in pull requet #60 at commit 6365a8b. The Matter Lab team decided to completely remove the withdrawal limitation.  Medium Severity  Refund recipient default to inacceible addre for contract  In _requetL2Tranaction, if addre(0) i pecified a the refund recipient, mg.ender i ued by default. However, the mg.ender addre will not be controllable by contract on L2, o any refund, or the bridged ETH amount in cae of a failed tranaction, will be lot.  Conider diallowing unpecified refund recipient for any ETH tranfer, or reverting in the cae of an unpecified recipient if the ender i not an EOA.  Update: Reolved in pull requet #32 at commit 201c99c.  Formula and documentation mimatch  The formula for overheadForPublicData ue Tm which i defined a the maximal tranaction erg limit here.  Thi appear to correpond in code to L2_TX_MAX_GAS_LIMIT:  /// @dev The maximum number of L2 ga that a uer can requet for an L2 tranaction  However, the calculation in code ue the MAX_PUBDATA_PER_BLOCK contant intead, which refer to:  /// @dev The maximum number of the pubdata an L2 operation hould be allowed to ue.  Thi correpond to Pm in the documentation.  Thee appear to be different quantitie, meaured in different unit, of different magnitude (80000000 v 110000). A a reult, a denial of ervice may occur if the overhead i calculated incorrectly (underetimated), which will reult in l2GaForTxBody being overetimated, and poibly reverting in _writePriorityOp depite having legitimate value paed a input.  Alternatively, a the overhead i underetimated, a larger-than-limit l2GaForTxBody may be ubmitted, which will caue failure on L2.  Conider adding tet cae to the documentation with concrete example value, and implementing thee tet cae in the codebae tet uite to enure baic compatibility. Additionally, conider documenting in code both the correpondence of the contant to the documentation notation, and the derivation and logic of the formula implemented in comment in the ame file, o that acce to external documentation would not prevent the reader from reviewing the code.  Update: Partially reolved in pull requet #34 at commit 19c7b81. The Matter Lab team tated:  Acknowledged. For now, we have decided to temporarily remove the overhead. The iue will be fixed once we introduce the block overhead back to our uer.  Unchecked ubtraction underflow  L2 ga validation perform an unchecked ubtraction, and a neighboring comment tate that the underflow prevention i enforced by the implementation of the preceding computation. However, the preceding computation take a large variety of contant and variable parameter, which depending on their value can till caue an underflow.  For example, the calculation of the memory overhead can reult in arbitrarily large value depending on the value paed in _encodingLength and the contant BOOTLOADER_TX_ENCODING_SPACE, ince both value range are not validated.  Note that it i likely that there are additional way by which the combination of different poible value of contant and input could caue the reulting overhead to be higher than the total ga limit.  Thi may reult in an underflow of the unchecked ubtraction. In turn, it will likely caue a revert due to ubequent l2GaForTxBody check.  Conider not uing the unchecked ubtraction to prevent the underflow, and adding an explicit check to validate the overhead.  Update: Reolved in pull requet #54 at commit 94bc1a6.  Uer could depoit more ETH than allowed  zkSync ha implemented a limit on the amount of ETH that can be depoited to L2 per account. However, the code currently ha a deign flaw that allow uer to bypa thi limit by exploiting a ga refund cheme. Specifically, in the requetL2Tranaction function, the depoited ETH amount i verified uing the _l2Value parameter, while the valueToMint parameter i et to mg.value when compoing a priority queue tranaction.  Thi mean that a uer can mint ETH without triggering the limit by etting _l2Value = 0 and uing the ga refund when requeting any L2 tranaction. Furthermore, even if mg.value wa et a the limit amount, the uer could run into iue when trying to requet L2 tranaction from L1 after reaching their limit.  To mitigate thi iue, a ytem deign change i needed around L2 ga refunding or ETH bridging limit. However, the pecific of the olution will depend on the overall deign and goal of the ytem. Careful conideration and teting will be needed to enure that the olution effectively mitigate thi iue while alo preerving the intended functionality of the ytem.  Update: Reolved in pull requet #32 at commit 201c99c.mg.value i now ued to verify the depoited ETH amount, however a we pointed out above, thi deign choice could mean uer might not be able to requet L2 tranaction after reaching their limit.  Block overhead limit may be exceeded  In _getOverheadForTranaction ome overhead value can go over their maximum value if the tranaction data or the public data poted (e.g., tate change) are large:  _encodingLength can take more memory than allowed by the BOOTLOADER_TX_ENCODING_SPACE.  overheadForPublicData for the tranaction can be larger than the MAX_PUBDATA_PER_BLOCK contant.  overheadForComputation can be larger than the L2_TX_MAX_GAS_LIMIT.  Exceeding thee value may violate invariant that are important for accurate L2 ga metering.  Conider checking that the encoded tranaction length i in the expected range to prevent going over the maximum expected value. Additionally, conider checking that at no point the reulting calculated overhead i larger than the maximum overhead.  Update: Partially reolved in pull requet #34 at commit 19c7b81. The Matter Lab team tated:  Acknowledged. We temporarily removed the block overhead, but a fix will be applied when retoring it.  Lack of tet  There are very few tet for mot functionalitie.  For example, Mailbox.ol (particularly MailboxFacet) i a key contract for the L1 bridge, and ha 360+ line of code and a large dependency tree of aggregated thouand of line of non-library olidity code (pecific to thi codebae). The code implement enitive functionality with many important detail and execution branche. However, there are only four baic tet in mailbox_tet.t:  One tet for non-reverting execution of an expected valid input. Thi tet nothing about the ucceful execution reult.  Three more tet that check revert in L2ContractHelper contract.  Thi mean that the entirety of the MailboxFacet functionality i unteted in thi repoitory.  Furthermore, a ome ytem-level integration tet exit in another repoitory, there too, mot of the functionality of the Mailbox remain unteted:  There are no invocation for the finalizeEthWithdrawal mutative method, or the view proveL2LogIncluion, proveL1ToL2TranactionStatu, and erializeL2Tranaction.  There i a ingle file for L1 functionality that invoke the main requetL2Tranaction method. Thi tet file total around 300 line of teting code, for which the majority of tet only aert either a revert or a lack of revert.  Thi lead to everal potential iue:  The correctne of the code can only be aeed baed on partial, and changing documentation. Thi i becaue intended and unintended behavior i not captured in tet.  Introduction of new vulnerabilitie for etablihed code in future code change, ince known poitive and negative behavior are not checked automatically.  Higher likelihood of mied vulnerabilitie in current and future development and review.  Conider adding contract-level teting to tet all branche of execution. Additionally, conider implementing an ongoing meaurement of teting coverage a a way to enure at leat 95% coverage.  Update: Partially reolved in pull requet #36, pull requet #42, pull requet #43, pull requet #45, pull requet #46, pull requet #48 and pull requet #51. The Matter Lab team tated:  We are working on improving the tet coverage over the entire codebae.  Low Severity  Miing documentation  Doctring and inline comment are miing in everal part of the codebae with enitive functionality. For example:  The entirety of L2ContractHelper contract: the functionality i internal, but i complex and coupled with other interface (cutom encoding of bytecode hahe, cutom create2 addre derivation, etc).  _getMinimalPriorityTranactionGaLimit: it i poible that thi method overetimate / underetimate, or i implemented incorrectly. However, relevant documentation wa inufficient to validate thi.  Conider including thorough doctring and inline explanation with reference to relevant ource file or documentation, allowing reader or maintainer to verify the implementation and their correct uage.  Update: Reolved in pull requet #55 at commit 41946cc and 57f702d.  Revert meage are not informative  Thi iue ha been reported in the previou Layer 1 Diff Audit (L01  Miing error meage in require tatement). Revert are important logical component, and a lack of revert meage make them confuing and increae the chance of miing vulnerabilitie during a review.  The codebae a a whole ha revert meage that conit of two letter and convey no information. Additionally, the two-letter combination collide (for example po) for different contract. Crucially, no reource i available to tranlate the code into meaningful error meage. Although omething i typically mentioned in comment next to the revert, a meaningful error meage (or a cutom error) i expected ince comment can be outdated and cannot be teted.  Conider uing informative error meage or cutom error throughout the codebae.  Update: Acknowledged, not reolved. The Matter Lab team tated:  We agree that cutom error will be much more undertandable and convenient. At thi time, we have no capacity for uch a large refactoring, but we have planned it for the next miletone.  L2 tranaction hah i not emitted  The L2 tranaction hah i a needed input during the L1 to L2 tranaction flow on chain (in claimFailedDepoit), and for keeping track of L2 incluion ucce off chain. However, it i not emitted in event by the caller in _requetDeployTranaction() or during ERC-20 depoit(). A a conequence, off-chain infratructure (indexer, UI, analytic dahboard) will not be able to keep track of bridging activity a eaily.  Conider emitting the reulting tranaction hah in an event after ubmitting the requet in the MailboxFacet.  Update: Reolved. We later found that thi wa not an iue becaue the hah wa emitted in event NewPriorityRequet a tated by the Matter Lab team:  _requetDeploy i only ued for the bridge initialization, o we do not think it may affect off-chain infratructure (indexer, UI, analytic dahboard). Moreover, the tranaction hahe are emitted in the Mailbox itelf.  Diamond proxy holding large bridged ETH balance  In the current deign, ERC-20 bridging ue a eparate contract to hold token balance, but MailboxFacet hold and operate the ETH balance. However, ince it i implemented a part of the Diamond Proxy, thi mean that the contract balance i common to all current and future facet of the proxy. Thi poe everal rik:  It expoe the bridged and locked fund to an additional rik of exploit by introducing vulnerabilitie in the other facet.  The locked balance i poibly co-mingled with other ETH that may be in ue by the other facet.  By adding functionality to handle outbound ETH tranfer, it introduce a ite for a call to a uer-defined detination out of the main proxy that can potentially be leveraged for other future attack.  Conidering that the ETH balance of the bridge may become very large, it may be better to deign a ytem that reduce thee rik.  Conider handling ETH depoit and withdrawal by converting them to WETH and uing the ERC-20 bridge. Thi will have the additional benefit of avoiding balance handling code duplication between the MailboxFacet and the ERC-20 bridge, and will alo remove the need to make a dangerou ETH tranfer call out of the contract.  Update: Acknowledged, not reolved. The Matter Lab team tated:  Holding depoited ETH in the diamond proxy wa a difficult deciion, but we could not equip an efficient approach and table fee model in a different way (uer end L1 to L2 tranaction and receive ETH refund). So all ETH hould be held in one contract (either EthBridge or diamond proxy).  Cro-chain ytem contract invocation i allowed and undocumented  Sytem contract addree can be pecified in requetL2Tranaction. However, thi can caue potential unexpected ide effect when executing the tranaction on L2 ince ytem contract are documented to not be intended for direct invocation by uer.  For example, if the detination addre i et to the ytem ContractDeployer, it appear that the bootloader will execute it in iSytem mode. Thi code path i ued for the deployment of the ERC-20 bridge in L1ERC20Bridge.initialize.  It i poible that allowing thi invocation path from L1 may introduce vulnerabilitie and ide effect, depending on each pecific ytem contract acce control. Thi i becaue L1 and L2 invocation path in the bootloader are treated differently and may encode different aumption which may be violated in one path but not in the other. If calling mot ytem contract i not an expected uage pattern, allowing the uer to make thee cro-chain call create an unneceary attack urface area.  Conider retricting the addree allowed to be called from L1. Thi can be done by checking that the detination addre doent fall into the ytem contract addre pace. Additionally, conider documenting thee uage pattern.  Update: Acknowledged, not reolved. The Matter Lab team tated:  We agree that calling ytem contract can be dangerou in general. However, due to the deign of L1-to-L2 tranaction, we do not ee any potential problem with calling ytem contract. The ame call may be d", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#s", "labels": ["OpenZeppelin"]}, {"title": "Appendix", "body": "Appendix", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#appendix", "labels": ["OpenZeppelin"]}, {"title": "Extra Monitoring Recommendations", "body": "Extra Monitoring Recommendations", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#extra-monitoring-recommendations", "labels": ["OpenZeppelin"]}, {"title": "Summary", "body": "Type  Rollups  Timeline  From 2023-02-06  To 2023-02-17  Languages  Solidity  Total Issues  22 (10\u202fresolved, 3\u202fpartially\u202fresolved)  Critical Severity Issues  0 (0\u202fresolved)  High Severity Issues  2 (1\u202fresolved)  Medium Severity Issues  6 (3\u202fresolved, 3\u202fpartially\u202fresolved)  Low Severity Issues  5 (2\u202fresolved)  Notes & Additional Information  9 (4\u202fresolved)  Scope  We audited changes to the matter-labs/zksync-2-contracts repository at the 3f345ce commit, and conducted full audits of AddressAliasHelper.sol and L2ContractHelper.sol.  In scope were the following contracts:  System Overview  zkSync Era is a permissionless general-purpose ZK rollup that operates similarly to L1 blockchains and sidechains. It enables deployment and interaction with Turing-complete smart contracts, which are executed on a specialized virtual machine called the zkEVM. Its important to note that the bytecode for the zkEVM is different from the L1 EVM, but there are Solidity and Vyper compilers available for developing L2 smart contracts. A strength of zkSync Era is its protocol for passing messages between L1 and L2. This provides a standard way for users to interact with smart contracts across both layers.  Privileged Roles and Trust Assumptions  The governor currently possesses a superpower to upgrade contracts instantaneously and indefinitely freeze them, but this power is only temporary. In the future, the upgrade process will be subject to time locks and the duration of freezing will be limited, thus preventing the governor from exploiting their power.  Testing Coverage Recommendations  Several concerns regarding the testing of the current system were identified during the audit. While there is a separate finding highlighting these concerns for the specific contracts within the scope of this audit, it is important to note the overall systematic risks here.  Insufficient testing, while not a specific vulnerability, implies the high probability of additional unfound vulnerabilities and bugs. It also exacerbates multiple interrelated risk factors in a complex code base with novel functionality. This includes a lack of full implicit specification of the functionality and exact expected behaviors that tests normally provide, which increases the chances that correctness issues will be missed. It also requires more effort to establish basic correctness and reduces the effort spent exploring edge cases, thereby increasing the chances of missing complex issues.  Moreover, the lack of repeated automated testing of the full specification increases the chances of introducing breaking changes and new vulnerabilities. This applies to both previously audited code and future changes to currently audited code. This is particularly true in this project due to the pace, extent, and complexity of ongoing and planned changes across all parts of the stack (L1, L2, bootloader and system contracts, compiler and VM). Underspecified interfaces and assumptions increase the risk of subtle integration issues, which testing could reduce by enforcing an exhaustive specification.  To address these issues, we recommend implementing a comprehensive multi-level test suite before the next expected audits. Such a test suite should comprise contract-level tests with 95%-100% coverage, per layer deployment and integration tests that test the deployment scripts as well as the system as a whole, per layer fork tests for planned upgrades, and cross-chain full integration tests of the entire system. Crucially, the test suite should be documented in a way that a reviewer can set up and run all these test layers independently of the development team. Some existing examples of such setups can be suggested for use as reference in a follow-up conversation. Implementing such a test suite should be a very high priority to ensure the systems robustness and reduce the risk of vulnerabilities and bugs.  High Severity  Deposit cap not updated on withdrawals  User deposits are capped by increasing the totalDepositedAmountPerUser counter. However, the counter is not decreased by withdrawals.  As the counter can only be increased, after sufficient usage, all withdrawing users will be locked out of depositing again. This can possibly happen right after the first deposit and withdrawal, if the initial amount is larger than half the cap.  Consider decreasing the per-user cap during withdrawals to allow users to return to the rollup.  Update: Acknowledged, not resolved. The Matter Labs team stated:  The deposit limitations are only enabled in Fair Onboarding Alpha, while only approved partners may deposit funds. This will be removed at Full Launch Alpha, so we treat this issue as an accepted risk.  ETH withdrawal within allowed limit could fail  The protocol enforces an ETH withdraw limit (currently 10% of the total balance) within each 1-day window as a safety mechanism. This is done through the _verifyWithdrawalLimit function in Mailbox.sol. However, this function has a logic flaw that could cause an ETH withdrawal within the limit to fail.  When withdrawal validations occur within the same 1-day window, the function checks the limit in line 215 of Mailbox, as follows:  However, address(this).balance has already changed due to the previous withdrawal within the same day, causing the allowance to be less than the allowed 10%. This could cause any planned withdrawal to fail due to previous withdrawals. Note that a similar issue could also exist in the ERC-20 bridge .  Consider recording address(this).balance when updating s.lastWithdrawalLimitReset, and using it as the base when calculating the daily withdraw limit.  Update: Resolved in pull request #60 at commit 6365a8b. The Matter Labs team decided to completely remove the withdrawal limitation.  Medium Severity  Refund recipient defaults to inaccessible address for contracts  In _requestL2Transaction, if address(0) is specified as the refund recipient, msg.sender is used by default. However, the msg.sender address will not be controllable by contracts on L2, so any refund, or the bridged ETH amount in case of a failed transaction, will be lost.  Consider disallowing unspecified refund recipients for any ETH transfers, or reverting in the case of an unspecified recipient if the sender is not an EOA.  Update: Resolved in pull request #32 at commit 201c99c.  Formula and documentation mismatch  The formula for overheadForPublicData uses Tm which is defined as the maximal transaction ergs limit here.  This appears to correspond in code to L2_TX_MAX_GAS_LIMIT:  /// @dev The maximum number of L2 gas that a user can request for an L2 transaction  However, the calculation in code uses the MAX_PUBDATA_PER_BLOCK constant instead, which refers to:  /// @dev The maximum number of the pubdata an L2 operation should be allowed to use.  This corresponds to Pm in the documentation.  These appear to be different quantities, measured in different units, of different magnitudes (80000000 vs 110000). As a result, a denial of service may occur if the overhead is calculated incorrectly (underestimated), which will result in l2GasForTxBody being overestimated, and possibly reverting in _writePriorityOp despite having legitimate values passed as inputs.  Alternatively, as the overhead is underestimated, a larger-than-limit l2GasForTxBody may be submitted, which will cause failures on L2.  Consider adding test cases to the documentation with concrete example values, and implementing these test cases in the codebase test suite to ensure basic compatibility. Additionally, consider documenting in code both the correspondence of the constants to the documentations notation, and the derivation and logic of the formulas implemented in comments in the same file, so that access to external documentation would not prevent the reader from reviewing the code.  Update: Partially resolved in pull request #34 at commit 19c7b81. The Matter Labs team stated:  Acknowledged. For now, we have decided to temporarily remove the overhead. The issue will be fixed once we introduce the block overhead back to our users.  Unchecked subtraction underflow  L2 gas validation performs an unchecked subtraction, and a neighboring comment states that the underflow prevention is enforced by the implementation of the preceding computation. However, the preceding computation takes a large variety of constants and variable parameters, which depending on their values can still cause an underflow.  For example, the calculation of the memory overhead can result in arbitrarily large values depending on the value passed in _encodingLength and the constant BOOTLOADER_TX_ENCODING_SPACE, since both values ranges are not validated.  Note that it is likely that there are additional ways by which the combination of different possible values of constants and inputs could cause the resulting overhead to be higher than the total gas limit.  This may result in an underflow of the unchecked subtraction. In turn, it will likely cause a revert due to subsequent l2GasForTxBody checks.  Consider not using the unchecked subtraction to prevent the underflow, and adding an explicit check to validate the overhead.  Update: Resolved in pull request #54 at commit 94bc1a6.  User could deposit more ETH than allowed  zkSync has implemented a limit on the amount of ETH that can be deposited to L2 per account. However, the code currently has a design flaw that allows users to bypass this limit by exploiting a gas refund scheme. Specifically, in the requestL2Transaction function, the deposited ETH amount is verified using the _l2Value parameter, while the valueToMint parameter is set to msg.value when composing a priority queue transaction.  This means that a user can mint ETH without triggering the limit by setting _l2Value = 0 and using the gas refund when requesting any L2 transactions. Furthermore, even if msg.value was set as the limit amount, the user could run into issues when trying to request L2 transactions from L1 after reaching their limit.  To mitigate this issue, a system design change is needed around L2 gas refunding or ETH bridging limits. However, the specifics of the solution will depend on the overall design and goals of the system. Careful consideration and testing will be needed to ensure that the solution effectively mitigates this issue while also preserving the intended functionality of the system.  Update: Resolved in pull request #32 at commit 201c99c.msg.value is now used to verify the deposited ETH amount, however as we pointed out above, this design choice could mean users might not be able to request L2 transactions after reaching their limit.  Block overhead limits may be exceeded  In _getOverheadForTransaction some overhead values can go over their maximum values if the transaction data or the public data posted (e.g., state changes) are large:  _encodingLength can take more memory than allowed by the BOOTLOADER_TX_ENCODING_SPACE.  overheadForPublicData for the transaction can be larger than the MAX_PUBDATA_PER_BLOCK constant.  overheadForComputation can be larger than the L2_TX_MAX_GAS_LIMIT.  Exceeding these values may violate invariants that are important for accurate L2 gas metering.  Consider checking that the encoded transaction length is in the expected range to prevent going over the maximum expected values. Additionally, consider checking that at no point the resulting calculated overhead is larger than the maximum overhead.  Update: Partially resolved in pull request #34 at commit 19c7b81. The Matter Labs team stated:  Acknowledged. We temporarily removed the block overhead, but a fix will be applied when restoring it.  Lack of tests  There are very few tests for most functionalities.  For example, Mailbox.sol (particularly MailboxFacet) is a key contract for the L1 bridge, and has 360+ lines of code and a large dependency tree of aggregated thousands of lines of non-library solidity code (specific to this codebase). The code implements sensitive functionality with many important details and execution branches. However, there are only four basic tests in mailbox_test.ts:  One test for non-reverting execution of an expected valid input. This tests nothing about the successful execution results.  Three more tests that check reverts in L2ContractsHelper contract.  This means that the entirety of the MailboxFacet functionality is untested in this repository.  Furthermore, as some system-level integration tests exist in another repository, there too, most of the functionality of the Mailbox remains untested:  There are no invocations for the finalizeEthWithdrawal mutative method, or the views proveL2LogInclusion, proveL1ToL2TransactionStatus, and serializeL2Transaction.  There is a single file for L1 functionality that invokes the main requestL2Transaction method. This test file totals around 300 lines of testing code, for which the majority of tests only assert either a revert or a lack of revert.  This leads to several potential issues:  The correctness of the code can only be assessed based on partial, and changing documentation. This is because intended and unintended behavior is not captured in tests.  Introduction of new vulnerabilities for established code in future code changes, since known positive and negative behaviors are not checked automatically.  Higher likelihood of missed vulnerabilities in current and future development and review.  Consider adding contract-level testing to test all branches of execution. Additionally, consider implementing an ongoing measurement of testing coverage as a way to ensure at least 95% coverage.  Update: Partially resolved in pull request #36, pull request #42, pull request #43, pull request #45, pull request #46, pull request #48 and pull request #51. The Matter Labs team stated:  We are working on improving the test coverage over the entire codebase.  Low Severity  Missing documentation  Docstrings and inline comments are missing in several parts of the codebase with sensitive functionality. For example:  The entirety of L2ContractHelper contract: the functionality is internal, but is complex and coupled with other interfaces (custom encoding of bytecode hashes, custom create2 address derivation, etc).  _getMinimalPriorityTransactionGasLimit: it is possible that this method overestimates / underestimates, or is implemented incorrectly. However, relevant documentation was insufficient to validate this.  Consider including thorough docstrings and inline explanations with references to relevant source files or documentation, allowing readers or maintainers to verify the implementations and their correct usage.  Update: Resolved in pull request #55 at commits 41946cc and 57f702d.  Revert messages are not informative  This issue has been reported in the previous Layer 1 Diff Audit (L01  Missing error messages in require statements). Reverts are important logical components, and a lack of revert messages makes them confusing and increases the chance of missing vulnerabilities during a review.  The codebase as a whole has revert messages that consist of two letters and convey no information. Additionally, the two-letter combinations collide (for example po) for different contracts. Crucially, no resource is available to translate the codes into meaningful error messages. Although something is typically mentioned in comments next to the revert, a meaningful error message (or a custom error) is expected since comments can be outdated and cannot be tested.  Consider using informative error messages or custom errors throughout the codebase.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We agree that custom errors will be much more understandable and convenient. At this time, we have no capacity for such a large refactoring, but we have planned it for the next milestone.  L2 transaction hash is not emitted  The L2 transaction hash is a needed input during the L1 to L2 transaction flow on chain (in claimFailedDeposit), and for keeping track of L2 inclusion success off chain. However, it is not emitted in events by the callers in _requestDeployTransaction() or during ERC-20 deposit(). As a consequence, off-chain infrastructure (indexers, UIs, analytics dashboards) will not be able to keep track of bridging activity as easily.  Consider emitting the resulting transaction hash in an event after submitting the request in the MailboxFacet.  Update: Resolved. We later found that this was not an issue because the hash was emitted in event NewPriorityRequest as stated by the Matter Labs team:  _requestDeploy is only used for the bridge initialization, so we do not think it may affect off-chain infrastructure (indexers, UIs, analytics dashboards). Moreover, the transaction hashes are emitted in the Mailbox itself.  Diamond proxy holding large bridged ETH balance  In the current design, ERC-20 bridging uses a separate contract to hold token balances, but MailboxFacet holds and operates the ETH balance. However, since it is implemented as part of the Diamond Proxy, this means that the contract balance is common to all current and future facets of the proxy. This poses several risks:  It exposes the bridged and locked funds to an additional risk of exploit by introducing vulnerabilities in the other facets.  The locked balance is possibly co-mingled with other ETH that may be in use by the other facets.  By adding functionality to handle outbound ETH transfers, it introduces a site for a call to a user-defined destination out of the main proxy that can potentially be leveraged for other future attacks.  Considering that the ETH balance of the bridge may become very large, it may be better to design a system that reduces these risks.  Consider handling ETH deposits and withdrawals by converting them to WETH and using the ERC-20 bridge. This will have the additional benefit of avoiding balance handling code duplication between the MailboxFacet and the ERC-20 bridge, and will also remove the need to make a dangerous ETH transfer call out of the contract.  Update: Acknowledged, not resolved. The Matter Labs team stated:  Holding deposited ETH in the diamond proxy was a difficult decision, but we could not equip an efficient approach and stable fee model in a different way (users send L1 to L2 transactions and receive ETH refunds). So all ETH should be held in one contract (either EthBridge or diamond proxy).  Cross-chain system contract invocation is allowed and undocumented  System contract addresses can be specified in requestL2Transaction. However, this can cause potential unexpected side effects when executing the transactions on L2 since system contracts are documented to not be intended for direct invocation by users.  For example, if the destination address is set to the system ContractDeployer, it appears that the bootloader will execute it in isSystem mode. This code path is used for the deployment of the ERC-20 bridge in L1ERC20Bridge.initialize.  It is possible that allowing this invocation path from L1 may introduce vulnerabilities and side effects, depending on each specific system contracts access control. This is because L1 and L2 invocation paths in the bootloader are treated differently and may encode different assumptions which may be violated in one path but not in the other. If calling most system contracts is not an expected usage pattern, allowing the users to make these cross-chain calls creates an unnecessary attack surface area.  Consider restricting the addresses allowed to be called from L1. This can be done by checking that the destination address doesnt fall into the system contracts address space. Additionally, consider documenting these usage patterns.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We agree that calling system contracts can be dangerous in general. However, due to the design of L1-to-L2 transactions, we do not see any potential problems with calling system contracts. The same call may be don", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#summary", "labels": ["OpenZeppelin"]}, {"title": "Type", "body": "Type", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#type", "labels": ["OpenZeppelin"]}, {"title": "Rollups", "body": "Rollups", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#rollups", "labels": ["OpenZeppelin"]}, {"title": "Timeline", "body": "Timeline", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#timeline", "labels": ["OpenZeppelin"]}, {"title": "From 2023-02-06", "body": "From 2023-02-06", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#from-2023-02-06", "labels": ["OpenZeppelin"]}, {"title": "To 2023-02-17", "body": "To 2023-02-17", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#to-2023-02-17", "labels": ["OpenZeppelin"]}, {"title": "Languages", "body": "Languages", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#languages", "labels": ["OpenZeppelin"]}, {"title": "Solidity", "body": "and Vyper compilers available for developing L2 smart contracts. A strength of zkSync Era is its protocol for passing messages between L1 and L2. This provides a standard way for users to interact with smart contracts across both layers.  Privileged Roles and Trust Assumptions  The governor currently possesses a superpower to upgrade contracts instantaneously and indefinitely freeze them, but this power is only temporary. In the future, the upgrade process will be subject to time locks and the duration of freezing will be limited, thus preventing the governor from exploiting their power.  Testing Coverage Recommendations  Several concerns regarding the testing of the current system were identified during the audit. While there is a separate finding highlighting these concerns for the specific contracts within the scope of this audit, it is important to note the overall systematic risks here.  Insufficient testing, while not a specific vulnerability, implies the high probability of additional unfound vulnerabilities and bugs. It also exacerbates multiple interrelated risk factors in a complex code base with novel functionality. This includes a lack of full implicit specification of the functionality and exact expected behaviors that tests normally provide, which increases the chances that correctness issues will be missed. It also requires more effort to establish basic correctness and reduces the effort spent exploring edge cases, thereby increasing the chances of missing complex issues.  Moreover, the lack of repeated automated testing of the full specification increases the chances of introducing breaking changes and new vulnerabilities. This applies to both previously audited code and future changes to currently audited code. This is particularly true in this project due to the pace, extent, and complexity of ongoing and planned changes across all parts of the stack (L1, L2, bootloader and system contracts, compiler and VM). Underspecified interfaces and assumptions increase the risk of subtle integration issues, which testing could reduce by enforcing an exhaustive specification.  To address these issues, we recommend implementing a comprehensive multi-level test suite before the next expected audits. Such a test suite should comprise contract-level tests with 95%-100% coverage, per layer deployment and integration tests that test the deployment scripts as well as the system as a whole, per layer fork tests for planned upgrades, and cross-chain full integration tests of the entire system. Crucially, the test suite should be documented in a way that a reviewer can set up and run all these test layers independently of the development team. Some existing examples of such setups can be suggested for use as reference in a follow-up conversation. Implementing such a test suite should be a very high priority to ensure the systems robustness and reduce the risk of vulnerabilities and bugs.  High Severity  Deposit cap not updated on withdrawals  User deposits are capped by increasing the totalDepositedAmountPerUser counter. However, the counter is not decreased by withdrawals.  As the counter can only be increased, after sufficient usage, all withdrawing users will be locked out of depositing again. This can possibly happen right after the first deposit and withdrawal, if the initial amount is larger than half the cap.  Consider decreasing the per-user cap during withdrawals to allow users to return to the rollup.  Update: Acknowledged, not resolved. The Matter Labs team stated:  The deposit limitations are only enabled in Fair Onboarding Alpha, while only approved partners may deposit funds. This will be removed at Full Launch Alpha, so we treat this issue as an accepted risk.  ETH withdrawal within allowed limit could fail  The protocol enforces an ETH withdraw limit (currently 10% of the total balance) within each 1-day window as a safety mechanism. This is done through the _verifyWithdrawalLimit function in Mailbox.sol. However, this function has a logic flaw that could cause an ETH withdrawal within the limit to fail.  When withdrawal validations occur within the same 1-day window, the function checks the limit in line 215 of Mailbox, as follows:  However, address(this).balance has already changed due to the previous withdrawal within the same day, causing the allowance to be less than the allowed 10%. This could cause any planned withdrawal to fail due to previous withdrawals. Note that a similar issue could also exist in the ERC-20 bridge .  Consider recording address(this).balance when updating s.lastWithdrawalLimitReset, and using it as the base when calculating the daily withdraw limit.  Update: Resolved in pull request #60 at commit 6365a8b. The Matter Labs team decided to completely remove the withdrawal limitation.  Medium Severity  Refund recipient defaults to inaccessible address for contracts  In _requestL2Transaction, if address(0) is specified as the refund recipient, msg.sender is used by default. However, the msg.sender address will not be controllable by contracts on L2, so any refund, or the bridged ETH amount in case of a failed transaction, will be lost.  Consider disallowing unspecified refund recipients for any ETH transfers, or reverting in the case of an unspecified recipient if the sender is not an EOA.  Update: Resolved in pull request #32 at commit 201c99c.  Formula and documentation mismatch  The formula for overheadForPublicData uses Tm which is defined as the maximal transaction ergs limit here.  This appears to correspond in code to L2_TX_MAX_GAS_LIMIT:  /// @dev The maximum number of L2 gas that a user can request for an L2 transaction  However, the calculation in code uses the MAX_PUBDATA_PER_BLOCK constant instead, which refers to:  /// @dev The maximum number of the pubdata an L2 operation should be allowed to use.  This corresponds to Pm in the documentation.  These appear to be different quantities, measured in different units, of different magnitudes (80000000 vs 110000). As a result, a denial of service may occur if the overhead is calculated incorrectly (underestimated), which will result in l2GasForTxBody being overestimated, and possibly reverting in _writePriorityOp despite having legitimate values passed as inputs.  Alternatively, as the overhead is underestimated, a larger-than-limit l2GasForTxBody may be submitted, which will cause failures on L2.  Consider adding test cases to the documentation with concrete example values, and implementing these test cases in the codebase test suite to ensure basic compatibility. Additionally, consider documenting in code both the correspondence of the constants to the documentations notation, and the derivation and logic of the formulas implemented in comments in the same file, so that access to external documentation would not prevent the reader from reviewing the code.  Update: Partially resolved in pull request #34 at commit 19c7b81. The Matter Labs team stated:  Acknowledged. For now, we have decided to temporarily remove the overhead. The issue will be fixed once we introduce the block overhead back to our users.  Unchecked subtraction underflow  L2 gas validation performs an unchecked subtraction, and a neighboring comment states that the underflow prevention is enforced by the implementation of the preceding computation. However, the preceding computation takes a large variety of constants and variable parameters, which depending on their values can still cause an underflow.  For example, the calculation of the memory overhead can result in arbitrarily large values depending on the value passed in _encodingLength and the constant BOOTLOADER_TX_ENCODING_SPACE, since both values ranges are not validated.  Note that it is likely that there are additional ways by which the combination of different possible values of constants and inputs could cause the resulting overhead to be higher than the total gas limit.  This may result in an underflow of the unchecked subtraction. In turn, it will likely cause a revert due to subsequent l2GasForTxBody checks.  Consider not using the unchecked subtraction to prevent the underflow, and adding an explicit check to validate the overhead.  Update: Resolved in pull request #54 at commit 94bc1a6.  User could deposit more ETH than allowed  zkSync has implemented a limit on the amount of ETH that can be deposited to L2 per account. However, the code currently has a design flaw that allows users to bypass this limit by exploiting a gas refund scheme. Specifically, in the requestL2Transaction function, the deposited ETH amount is verified using the _l2Value parameter, while the valueToMint parameter is set to msg.value when composing a priority queue transaction.  This means that a user can mint ETH without triggering the limit by setting _l2Value = 0 and using the gas refund when requesting any L2 transactions. Furthermore, even if msg.value was set as the limit amount, the user could run into issues when trying to request L2 transactions from L1 after reaching their limit.  To mitigate this issue, a system design change is needed around L2 gas refunding or ETH bridging limits. However, the specifics of the solution will depend on the overall design and goals of the system. Careful consideration and testing will be needed to ensure that the solution effectively mitigates this issue while also preserving the intended functionality of the system.  Update: Resolved in pull request #32 at commit 201c99c.msg.value is now used to verify the deposited ETH amount, however as we pointed out above, this design choice could mean users might not be able to request L2 transactions after reaching their limit.  Block overhead limits may be exceeded  In _getOverheadForTransaction some overhead values can go over their maximum values if the transaction data or the public data posted (e.g., state changes) are large:  _encodingLength can take more memory than allowed by the BOOTLOADER_TX_ENCODING_SPACE.  overheadForPublicData for the transaction can be larger than the MAX_PUBDATA_PER_BLOCK constant.  overheadForComputation can be larger than the L2_TX_MAX_GAS_LIMIT.  Exceeding these values may violate invariants that are important for accurate L2 gas metering.  Consider checking that the encoded transaction length is in the expected range to prevent going over the maximum expected values. Additionally, consider checking that at no point the resulting calculated overhead is larger than the maximum overhead.  Update: Partially resolved in pull request #34 at commit 19c7b81. The Matter Labs team stated:  Acknowledged. We temporarily removed the block overhead, but a fix will be applied when restoring it.  Lack of tests  There are very few tests for most functionalities.  For example, Mailbox.sol (particularly MailboxFacet) is a key contract for the L1 bridge, and has 360+ lines of code and a large dependency tree of aggregated thousands of lines of non-library solidity code (specific to this codebase). The code implements sensitive functionality with many important details and execution branches. However, there are only four basic tests in mailbox_test.ts:  One test for non-reverting execution of an expected valid input. This tests nothing about the successful execution results.  Three more tests that check reverts in L2ContractsHelper contract.  This means that the entirety of the MailboxFacet functionality is untested in this repository.  Furthermore, as some system-level integration tests exist in another repository, there too, most of the functionality of the Mailbox remains untested:  There are no invocations for the finalizeEthWithdrawal mutative method, or the views proveL2LogInclusion, proveL1ToL2TransactionStatus, and serializeL2Transaction.  There is a single file for L1 functionality that invokes the main requestL2Transaction method. This test file totals around 300 lines of testing code, for which the majority of tests only assert either a revert or a lack of revert.  This leads to several potential issues:  The correctness of the code can only be assessed based on partial, and changing documentation. This is because intended and unintended behavior is not captured in tests.  Introduction of new vulnerabilities for established code in future code changes, since known positive and negative behaviors are not checked automatically.  Higher likelihood of missed vulnerabilities in current and future development and review.  Consider adding contract-level testing to test all branches of execution. Additionally, consider implementing an ongoing measurement of testing coverage as a way to ensure at least 95% coverage.  Update: Partially resolved in pull request #36, pull request #42, pull request #43, pull request #45, pull request #46, pull request #48 and pull request #51. The Matter Labs team stated:  We are working on improving the test coverage over the entire codebase.  Low Severity  Missing documentation  Docstrings and inline comments are missing in several parts of the codebase with sensitive functionality. For example:  The entirety of L2ContractHelper contract: the functionality is internal, but is complex and coupled with other interfaces (custom encoding of bytecode hashes, custom create2 address derivation, etc).  _getMinimalPriorityTransactionGasLimit: it is possible that this method overestimates / underestimates, or is implemented incorrectly. However, relevant documentation was insufficient to validate this.  Consider including thorough docstrings and inline explanations with references to relevant source files or documentation, allowing readers or maintainers to verify the implementations and their correct usage.  Update: Resolved in pull request #55 at commits 41946cc and 57f702d.  Revert messages are not informative  This issue has been reported in the previous Layer 1 Diff Audit (L01  Missing error messages in require statements). Reverts are important logical components, and a lack of revert messages makes them confusing and increases the chance of missing vulnerabilities during a review.  The codebase as a whole has revert messages that consist of two letters and convey no information. Additionally, the two-letter combinations collide (for example po) for different contracts. Crucially, no resource is available to translate the codes into meaningful error messages. Although something is typically mentioned in comments next to the revert, a meaningful error message (or a custom error) is expected since comments can be outdated and cannot be tested.  Consider using informative error messages or custom errors throughout the codebase.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We agree that custom errors will be much more understandable and convenient. At this time, we have no capacity for such a large refactoring, but we have planned it for the next milestone.  L2 transaction hash is not emitted  The L2 transaction hash is a needed input during the L1 to L2 transaction flow on chain (in claimFailedDeposit), and for keeping track of L2 inclusion success off chain. However, it is not emitted in events by the callers in _requestDeployTransaction() or during ERC-20 deposit(). As a consequence, off-chain infrastructure (indexers, UIs, analytics dashboards) will not be able to keep track of bridging activity as easily.  Consider emitting the resulting transaction hash in an event after submitting the request in the MailboxFacet.  Update: Resolved. We later found that this was not an issue because the hash was emitted in event NewPriorityRequest as stated by the Matter Labs team:  _requestDeploy is only used for the bridge initialization, so we do not think it may affect off-chain infrastructure (indexers, UIs, analytics dashboards). Moreover, the transaction hashes are emitted in the Mailbox itself.  Diamond proxy holding large bridged ETH balance  In the current design, ERC-20 bridging uses a separate contract to hold token balances, but MailboxFacet holds and operates the ETH balance. However, since it is implemented as part of the Diamond Proxy, this means that the contract balance is common to all current and future facets of the proxy. This poses several risks:  It exposes the bridged and locked funds to an additional risk of exploit by introducing vulnerabilities in the other facets.  The locked balance is possibly co-mingled with other ETH that may be in use by the other facets.  By adding functionality to handle outbound ETH transfers, it introduces a site for a call to a user-defined destination out of the main proxy that can potentially be leveraged for other future attacks.  Considering that the ETH balance of the bridge may become very large, it may be better to design a system that reduces these risks.  Consider handling ETH deposits and withdrawals by converting them to WETH and using the ERC-20 bridge. This will have the additional benefit of avoiding balance handling code duplication between the MailboxFacet and the ERC-20 bridge, and will also remove the need to make a dangerous ETH transfer call out of the contract.  Update: Acknowledged, not resolved. The Matter Labs team stated:  Holding deposited ETH in the diamond proxy was a difficult decision, but we could not equip an efficient approach and stable fee model in a different way (users send L1 to L2 transactions and receive ETH refunds). So all ETH should be held in one contract (either EthBridge or diamond proxy).  Cross-chain system contract invocation is allowed and undocumented  System contract addresses can be specified in requestL2Transaction. However, this can cause potential unexpected side effects when executing the transactions on L2 since system contracts are documented to not be intended for direct invocation by users.  For example, if the destination address is set to the system ContractDeployer, it appears that the bootloader will execute it in isSystem mode. This code path is used for the deployment of the ERC-20 bridge in L1ERC20Bridge.initialize.  It is possible that allowing this invocation path from L1 may introduce vulnerabilities and side effects, depending on each specific system contracts access control. This is because L1 and L2 invocation paths in the bootloader are treated differently and may encode different assumptions which may be violated in one path but not in the other. If calling most system contracts is not an expected usage pattern, allowing the users to make these cross-chain calls creates an unnecessary attack surface area.  Consider restricting the addresses allowed to be called from L1. This can be done by checking that the destination address doesnt fall into the system contracts address space. Additionally, consider documenting these usage patterns.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We agree that calling system contracts can be dangerous in general. However, due to the design of L1-to-L2 transactions, we do not see any potential problems with calling system contracts. The same call may be done via L2 by directly calling the system contracts.  Notes & Additional Information  Contract poorly named and structured  The L2ContractHelper file and contract present several issues that impact readability:  It is named in a way that does not describe its intent or usage. Consider renaming it more appropriately according to its functions (e.g., splitting it into CustomEncodings and L2Addresses).  sendMessageToL1 is unused along with its dependencies (L2_MESSENGER and IL2Messenger). Consider removing it altogether.  The file contains additional constants and interfaces that are not used within it, but are used in other importing files. For example, IContractDeployer or FORCE_DEPLOYER are not used in this file, among others. Consider removing the unused instances.  Update: Resolved in pull request #55 at commits dfb4e4b and e2b2cf0.  Local variable shadows state variable  In Allowlist.sol the _owner local variable shadows the _owner state variable", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#solidity", "labels": ["OpenZeppelin"]}, {"title": "Total Issues", "body": "Total Issues", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#total-issues", "labels": ["OpenZeppelin"]}, {"title": "22 (10\u202fresolved, 3\u202fpartially\u202fresolved)", "body": "22 (10\u202fresolved, 3\u202fpartially\u202fresolved)", "html_url": "https://blog.openzeppelin.com/zksync-l1-diff-audit-february-2023#22-(10\u202fresolved,-3\u202fpartially\u202fresolved)", "labels": ["OpenZeppelin"]}, {"title": "Invalid aggregate signature [samples]", "body": "The BLSSignatureAggregator exposes a mechanism to let the bundler validate individual signatures before constructing the bundle. Successful operations are grouped so the bundler can combine their signatures off-chain and the EntryPoint can validate them together on-chain. However, it is possible for an account to construct an operation that will pass the individual-signature check and still fail the combined-signature check.  during the individual validation is different from the one used  during the combined validation, the two validations will be inconsistent even though the signature is the same. This could occur if the  last 4 words of the initCode do not match the public key (because the  expected creation function). It could also occur if the  users validation function (which is not invoked during the individual signature validation) changes the public key that is returned by  If a bundler constructs a bundle with these operations, it will be unable to validate the combined signature and will attribute the fault to the aggregator, which will cause the aggregator to be throttled and user operations with the same aggregator will not be processed.  Consider synchronizing the two validation functions so they both use the same public key.  Update: Resolved in pull request #195 as well as commit 268f103 of pull request #216, which were merged at commits 1cc1c97 and 1f505c5 respectively.  Low Severity  Accounts cannot replace EntryPoint [samples]  The comments describing the initialize function of the SimpleAccount contract claim there should be a mechanism to replace the EntryPoint contract. This does not match the behavior of the function it describes, and in fact, there is no mechanism to replace the EntryPoint contract without upgrading the whole account.  Consider updating the comment to match the behavior, and introducing a mechanism to replace the EntryPoint contract if that functionality is desired.  Update: Resolved in pull request #192 and merged at commit 82685b2. A @dev comment was added to the docstring of the initialize function to clarify that the _entryPoint storage variable is not a parameter of the initializer because an upgrade is required to change the EntryPoint address.  Gnosis safe reverts on signature failure [samples]  documentation for the  correctly follows the specification, however in the  reverts if the signature validation fails. This means the  simulateValidation function will revert without providing a  Consider changing the logic so that validateUserOp returns SIG_VALIDATION_FAILED in all cases where an invalid signature is encountered.  Update: Resolved in pull request #181 and merged at commit 1dfb173.  Imprecise time range [core]  The EntryPoint contract decrements the operation expiry timestamp in order to convert 0 (which should be interpreted as no expiry) to the maximum uint64 value. However, every other possible expiry value is now off by one. In the interest of predictability, consider only modifying the 0 timestamp.  Update: Resolved in pull request #193 and merged at commit 973c0ac.  Incorrect or misleading documentation [core and samples]  Several docstrings and inline comments throughout the code base were found to be incorrect or misleading. In particular:  In BaseAccount.sol:  Line 72: The docstring defines sigTimeRange as signature and time-range for this operation, but it contains the signature validity, not the signature itself.  In BLSSignatureAggregator.sol:  Line 117: The docstring references a call to simulateUserOperation. The function name should be simulateValidation.  In EIP4337Manager.sol:  Line 21: The docstring states the contract inherits GnosisSafeStorage, but it actually inherits GnosisSafe.  In EntryPoint.sol:  Line 180: The comment does not include paymasterAndData as one of the dynamic byte arrays being excluded from MemoryUserOp. Line 393: The docstring states that _validatePaymasterPrepayment validates that the paymaster is staked, but the function does not perform this check.  In IPaymaster.sol:  Lines 25-26: The docstring states that the validUntil and validAfter timestamps are 4 bytes in length, but these are 8-byte (uint64) values.  In IStakeManager.sol:  Line 7, lines 43-44: Docstrings in this contract refer to staking only for paymasters, implying this is the only entity that should stake. Signature aggregators and factories are also required to stake following the same rules as paymasters. Line 45: The docstring makes a reference to the global unstakeDelaySec, which no longer exists. Line 47: The DepositInfo docstring explains that the variable sizes were chosen so that deposit and staked fit into a single uint256 word, but the 3rd parameter stake will also fit.  In SimpleAccount.sol:  Line 52: The comment makes a reference to the execFromEntryPoint function, which no longer exists. Line 57: The docstring for execute says called directly from owner, not by entryPoint, but the _requireFromEntryPointOrOwner function allows execute to be called by the EntryPoint. The comment isnt clear on whether it is a suggestion, or a restriction to be enforced. Lines 75-79: The docstring does not match the initialize function. Lines 89-96: The docstring does not match the _requireFromEntryPointOrOwner function.  In IEntryPoint.sol:  Line 26: The @success parameter is listed in the wrong order.  In UserOperation.sol:  Line 25: The callGasLimit parameter has no @param statement.  Update: Resolved in pull request #194 and pull request #216, which were merged at commits faf305e and 1f505c5 respectively.  Misleading specification [core]  The EIP states that when a FailedOp is detected, all other operations from the same paymaster should be removed from the current batch. However, this should only apply to FailedOp errors that explicitly mention the paymaster, which imply the paymaster was at fault. Operations that fail for unrelated reasons should not penalize their paymaster.  The EIP also states that userOp validation cannot call the handleOps method. This restriction should also apply to handleAggregatedOps.  Consider clarifying these points in the EIP.  Update: Partially resolved in pull request #196 and merged at 5929ff8. The updated EIP mistakenly refers to the EntryPoints depositTo function as depositFor.  Mismatched event parameter [core]  The StakeLocked event specifies a withdrawTime parameter, but the argument passed in is the new unstake delay. Consider renaming the event parameter to match its actual usage.  Update: Resolved in pull request #197 and merged at commit 545a15c.  Missing docstrings [core and samples]  Throughout the codebase there are several parts that do not have docstrings. For instance:  Line 24 in BLSAccount.sol  Line 39 in BLSAccount.sol  Line 44 in BLSAccount.sol  Line 48 in BLSAccount.sol  Line 20 in BLSSignatureAggregator.sol  Line 48 in BLSSignatureAggregator.sol  Line 106 in BLSSignatureAggregator.sol  Line 10 in IBLSAccount.sol  Line 24 in BasePaymaster.sol  Line 29 in BasePaymaster.sol  Line 31 in BasePaymaster.sol  Line 167 in EntryPoint.sol  Line 18 in StakeManager.sol  Line 11 in EIP4337Fallback.sol  Line 23 in GnosisAccountFactory.sol  Line 67 in IStakeManager.sol  Line 34 in UserOperation.sol  Line 73 in DepositPaymaster.sol  Line 27 in SimpleAccount.sol  Line 31 in SimpleAccount.sol  Line 23 in TestAggregatedAccount.sol  Line 34 in TestAggregatedAccount.sol  Line 16 in TestSignatureAggregator.sol  Line 28 in TestSignatureAggregator.sol  Line 43 in TestSignatureAggregator.sol  Line 40 in TokenPaymaster.sol  Line 6 in Exec.sol  Consider thoroughly documenting all functions and their parameters, especially public APIs. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Partially resolved in pull request #212 and merged at commit eeb93b2. The recommended changes to GnosisAccountFactory.sol were not implemented.  Missing error messages in require statements [core and samples]  Within the codebase there are some require statements that lack error messages:  The require statement on line 105 of BasePaymaster.sol  The require statement on line 49 of DepositPaymaster.sol  The require statement on line 137 of SimpleAccount.sol  Consider including specific, informative error messages in require statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied.  Update: Resolved in pull request #198 and merged at commit 182b7d3. Error messages were added to the deficient require statements in BasePaymaster.sol and DepositPaymaster.sol, and the require statement in SimpleAccount.sol was eliminated as part of a code change.  Missing recommended function [samples]  states that an aggregated account should support the  BLSAccount contract does not contain a  the getBlsPublicKey function to  Update: Resolved in pull request #199 and merged at commit 12d2ac0. The EIP now uses the getBlsPublicKey function as an example.  Uninitialized implementation contract [samples]  The SimpleAccountFactory creates a new implementation contract but does not initialize it. This means that anyone can initialize the implementation contract to become its owner.  The consequences depend on the version of OpenZeppelin contracts in use. The project requires release 4.2 and later, but release 4.8 is locked. The onlyProxy modifier was introduced in release 4.3.2 to protect the upgrade mechanism. Without this modifier, the owner is authorized to call the upgrade functions on the implementation contract directly, which lets them selfdestruct it.  With the locked version, the implementation owner can execute arbitrary calls from the implementation contract, but should not be able to interfere with the operation of the proxies.  Nevertheless, to reduce the attack surface, consider restricting the versions of OpenZeppelin contracts that are supported and disabling the initializer in the constructor of the SimpleAccount contract, to prevent anyone from claiming ownership.  Update: Resolved in pull request #201 and merged at commit 4004ebf.  Unrestrained revert reason [core]  FailedOp error where the  line 375 and  line 417) where an untrusted contract can provide the reason, potentially including misleading error codes. For example, the sender  Consider prefixing the externally provided revert reasons with a uniquely identifying error code.  Update: Resolved in pull request #200 and merged at commit 3d8f450.  Unsafe ABI encoding  It is not an uncommon practice to use abi.encodeWithSignature or abi.encodeWithSelector to generate calldata for a low-level call. However, the first option is not safe from typographical errors, and the second option is not type-safe. The result is that both of these methods are error-prone and should be considered unsafe.  Within EIP4337Manager.sol, there are some occurrences of unsafe ABI encodings being used:  On line 119  On line 144  Consider replacing all occurrences of unsafe ABI encodings with abi.encodeCall, which checks whether the supplied values actually match the types expected by the called function, and also avoids typographical errors.  Note that a bug related to the use of string literals as inputs to abi.encodeCall was fixed in version 0.8.13, so developers should exercise caution when using this function with earlier versions of Solidity.  Update: Resolved in pull request #220 and merged at commit c0a69bf. The first example is an invalid recommendation because it is encoding an error.  Notes & Additional Information  Declare uint/int as uint256/int256 [core and samples]  codebase, there are multiple instances of  Update: Partially resolved in pull request #215 and merged at commit 998fa7d. Most instances have been addressed but there are some uint types remaining.  File relocation recommendations [samples]  To provide additional clarity regarding whether a given contract file contains core, sample, or test code, consider the following recommendations to move project files:  Within the samples directory, TestAggregatedAccount.sol, TestAggregatedAccountFactory.sol, and TestSignatureAggregator.sol contain test contracts similar to those found in the contracts/test directory. Consider relocating these files to the contracts/test directory.  The bls and gnosis directories contain sample account implementations, but do not reside in the samples directory. Consider moving these items to the samples directory.  Update: Resolved in pull request #217 and merged at commit f82cbbb.  IAccount inheritance anti-pattern  to expose a signature aggregator associated with the account. To add support for handling aggregated user operations, the  must provide a null address for this parameter. This represents an anti-pattern where a base class is aware of features only relevant to a derived class.  To address this case and future enhancements of the protocol, consider replacing the aggregator parameter in validateUserOp with a more generic extensions parameter that can be used to specify the aggregator as well as any future account-specific extensions.  Update: Resolved in pull request #216 and merged at commit 1f505c5.  Implicit size limit [core]  The packSigTimeRange function of the BaseAccount contract implicitly assumes the timestamps fit within 8 bytes. Consider enforcing this assumption by using uint64 parameters.  Update: Resolved in pull request #203 and merged at commit fa46d5b.  Incomplete event history [samples]  The BLSAccount contract emits an event when the public key is changed, but not when it is initialized. To complete the event history, consider emitting the event on initialization as well.  Update: Resolved in pull request #204 and merged at commit 2600d7e.  Lack of indexed parameter [core]  The aggregator parameter in the SignatureAggregatorChanged event is not indexed. Consider indexing the event parameter to avoid hindering the task of off-chain services searching and filtering for specific events.  Update: Resolved in pull request #202 and merged at commit 1633c06.  Naming suggestions [core and samples]  To favor explicitness and readability, there are several locations in the contracts that may benefit from better naming. Our suggestions are:  In BaseAccount.sol:  The packSigTimeRange function is internal but is not prefixed with _. Consider renaming to _packSigTimeRange.  In BasePaymaster.sol:  The packSigTimeRange function is internal but is not prefixed with _. Consider renaming to _packSigTimeRange.  In BLSSignatureAggregator.sol:  Consider renaming all instances of hashPublicKey to publicKeyHash for consistency.  In EIP4337Manager.sol:  Consider renaming the local variable _msgSender to msgSender for consistency.  In IAggregator.sol:  Consider renaming the return value of the aggregateSignatures function from aggregatesSignature to aggregatedSignature.  In IEntryPoint.sol:  The ExecutionResult error uses validBefore instead of validUntil. For consistency, consider changing the parameter name to validUntil. The ReturnInfo structs documentation for the validAfter parameter indicates it is inclusive. Consider renaming it to validFrom throughout the entire codebase. In the AggregatorStakeInfo struct, consider renaming actualAggregator to aggregator (also in the comment here).  In SenderCreator.sol:  In the createSender function, consider renaming the initAddress variable to factory to be consistent with the EntryPoint contract.  In SimpleAccount.sol:  In the addDeposit function, consider renaming the req variable to success.  In StakeManager.sol:  internalIncrementDeposit is an internal function that uses internal as its prefix instead of _. Consider changing to _incrementDeposit. The getStakeInfo function is internal but not prefixed with _. Consider renaming the function to _getStakeInfo. Consider renaming the addr parameter of getStakeInfo to account. Consider removing the leading underscore from all instances of _unstakeDelaySec in StakeManager now that there is no longer a storage variable named unstakeDelaySec.  Update: Resolved in pull request #221 and merged at commit 7bd9909.  Inconsistent ordering [core and samples]  The Solidity Style Guide specifies a recommended order for the layout of elements within a contract file in order to facilitate finding declarations grouped together in predictable locations. Within the codebase, this recommendation is not followed in several places:  In BLSAccount.sol: The PublicKeyChanged event is defined between two functions.  In BLSSignatureAggregator.sol: Constant value N is defined between two functions.  In IEntryPoint.sol: Starting at line 70, error and struct definitions are intermingled with function definitions.  In IPaymaster.sol: The PostOpMode enum is defined after all functions.  In SimpleAccount.sol: The _entryPoint variable, SimpleAccountInitialized event, and onlyOwner modifier are defined after several function definitions.  To improve the projects overall legibility, consider standardizing ordering throughout the codebase, as recommended by the Solidity Style Guide.  Update: Partially resolved in pull request #211 and merged at commit ca1b649. In IEntryPoint.sol, the error definitions were relocated but several struct definitions remain defined in between functions.  Stake size inconsistency [core]  The StakeManager allows deposits up to the maximum uint112 value, but the stake must be strictly less than the maximum unit112 value. Consider using the same maximum in both cases for consistency.  Update: Resolved in pull request #209 at commit 419b7b0.  TODO comments [core and samples]  The following instances of TODO comments were found in the codebase:  Line 305 in EntryPoint.sol  Line 52 in EIP4337Manager.sol  Line 57 in TokenPaymaster.sol  TODO comments are more likely to be overlooked and remain unresolved if they are not being tracked formally as issues. Over time, important information regarding the original motivation, plan, and supporting details may be lost. Consider removing all instances of TODO comments and tracking them in the issues backlog instead. Alternatively, consider linking each inline TODO to the corresponding issues backlog entry.  Update: Resolved in pull request #218 and merged at commit 80d5c89. The first example is obsolete. The other two are not TODOs and were changed to Note.  Typographical errors [core and samples]  Consider addressing the following typographical errors:  In BaseAccount.sol:  Line 70: chain-id should be chain id. Line 76: The an account should be If an account.  In BLSAccount.sol:  Line 9: public-key should be public key in this context. Line 12: a BLS public should be a BLS public key. Line 19: Mutable values slots should be Mutable value slots.  In BLSAccountFactory.sol:  Line 11: Based n should be Based on. Line 27: public-key should be public key in this context.  In BLSHelper.sol:  Line 32: (x2 y2, z2) should be (x2, y2, z2).  Line 137: Doubles a points should be Doubles a point.  In BLSSignatureAggregator.sol:  Line 34: to short should be too short. Line 89: public-key should be public key in this context; remove 1 space between value and using. Line 155: remove 1 space between stake and or.  In DepositPaymaster.sol:  Line 14: deposit should be deposits.  In EIP4337Manager.sol:  Line 106: prevent mistaken replaceEIP4337Manager to disable should be prevents mistaken replaceEIP4337Manager from disabling.  In EntryPoint.sol:  Line 50: into into should be index into. Line 69: deliberately caused should be not deliberately caused. Line 80: UserOperation should be UserOperations or user operations. Line 180: except that should be except for. Line 180: Missing closing parenthesis. Line 522: if it is was should be if it was. Line 552: A50 should be AA50. Line 560: A51 should be AA51.  In IAccount.sol:  Line 29: The an account should be If an account.  In IAggregatedAccount.sol:  Line 9: account, that support should be account that supports. Line 11: valiate should be validate.  In IAggregator.sol:  Line 20: ", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#invalid-aggregate-signature-[samples]", "labels": ["OpenZeppelin"]}, {"title": "Accounts cannot replace EntryPoint [samples]", "body": "Accounts cannot replace EntryPoint [samples]", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#accounts-cannot-replace-entrypoint-[samples]", "labels": ["OpenZeppelin"]}, {"title": "Gnosis safe reverts on signature failure [samples]", "body": "documentation for the  correctly follows the specification, however in the  reverts if the signature validation fails. This means the  simulateValidation function will revert without providing a  Consider changing the logic so that validateUserOp returns SIG_VALIDATION_FAILED in all cases where an invalid signature is encountered.  Update: Resolved in pull request #181 and merged at commit 1dfb173.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#gnosis-safe-reverts-on-signature-failure-[samples]", "labels": ["OpenZeppelin"]}, {"title": "Imprecise time range [core]", "body": "The EntryPoint contract decrements the operation expiry timestamp in order to convert 0 (which should be interpreted as no expiry) to the maximum uint64 value. However, every other possible expiry value is now off by one. In the interest of predictability, consider only modifying the 0 timestamp.  Update: Resolved in pull request #193 and merged at commit 973c0ac.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#imprecise-time-range-[core]", "labels": ["OpenZeppelin"]}, {"title": "Incorrect or misleading documentation [core and samples]", "body": "Several docstrings and inline comments throughout the code base were found to be incorrect or misleading. In particular:  In BaseAccount.sol:  Line 72: The docstring defines sigTimeRange as signature and time-range for this operation, but it contains the signature validity, not the signature itself.  In BLSSignatureAggregator.sol:  Line 117: The docstring references a call to simulateUserOperation. The function name should be simulateValidation.  In EIP4337Manager.sol:  Line 21: The docstring states the contract inherits GnosisSafeStorage, but it actually inherits GnosisSafe.  In EntryPoint.sol:  Line 180: The comment does not include paymasterAndData as one of the dynamic byte arrays being excluded from MemoryUserOp. Line 393: The docstring states that _validatePaymasterPrepayment validates that the paymaster is staked, but the function does not perform this check.  In IPaymaster.sol:  Lines 25-26: The docstring states that the validUntil and validAfter timestamps are 4 bytes in length, but these are 8-byte (uint64) values.  In IStakeManager.sol:  Line 7, lines 43-44: Docstrings in this contract refer to staking only for paymasters, implying this is the only entity that should stake. Signature aggregators and factories are also required to stake following the same rules as paymasters. Line 45: The docstring makes a reference to the global unstakeDelaySec, which no longer exists. Line 47: The DepositInfo docstring explains that the variable sizes were chosen so that deposit and staked fit into a single uint256 word, but the 3rd parameter stake will also fit.  In SimpleAccount.sol:  Line 52: The comment makes a reference to the execFromEntryPoint function, which no longer exists. Line 57: The docstring for execute says called directly from owner, not by entryPoint, but the _requireFromEntryPointOrOwner function allows execute to be called by the EntryPoint. The comment isnt clear on whether it is a suggestion, or a restriction to be enforced. Lines 75-79: The docstring does not match the initialize function. Lines 89-96: The docstring does not match the _requireFromEntryPointOrOwner function.  In IEntryPoint.sol:  Line 26: The @success parameter is listed in the wrong order.  In UserOperation.sol:  Line 25: The callGasLimit parameter has no @param statement.  Update: Resolved in pull request #194 and pull request #216, which were merged at commits faf305e and 1f505c5 respectively.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#incorrect-or-misleading-documentation-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "Misleading specification [core]", "body": "The EIP states that when a FailedOp is detected, all other operations from the same paymaster should be removed from the current batch. However, this should only apply to FailedOp errors that explicitly mention the paymaster, which imply the paymaster was at fault. Operations that fail for unrelated reasons should not penalize their paymaster.  The EIP also states that userOp validation cannot call the handleOps method. This restriction should also apply to handleAggregatedOps.  Consider clarifying these points in the EIP.  Update: Partially resolved in pull request #196 and merged at 5929ff8. The updated EIP mistakenly refers to the EntryPoints depositTo function as depositFor.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#misleading-specification-[core]", "labels": ["OpenZeppelin"]}, {"title": "Mismatched event parameter [core]", "body": "The StakeLocked event specifies a withdrawTime parameter, but the argument passed in is the new unstake delay. Consider renaming the event parameter to match its actual usage.  Update: Resolved in pull request #197 and merged at commit 545a15c.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#mismatched-event-parameter-[core]", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings [core and samples]", "body": "Throughout the codebase there are several parts that do not have docstrings. For instance:  Line 24 in BLSAccount.sol  Line 39 in BLSAccount.sol  Line 44 in BLSAccount.sol  Line 48 in BLSAccount.sol  Line 20 in BLSSignatureAggregator.sol  Line 48 in BLSSignatureAggregator.sol  Line 106 in BLSSignatureAggregator.sol  Line 10 in IBLSAccount.sol  Line 24 in BasePaymaster.sol  Line 29 in BasePaymaster.sol  Line 31 in BasePaymaster.sol  Line 167 in EntryPoint.sol  Line 18 in StakeManager.sol  Line 11 in EIP4337Fallback.sol  Line 23 in GnosisAccountFactory.sol  Line 67 in IStakeManager.sol  Line 34 in UserOperation.sol  Line 73 in DepositPaymaster.sol  Line 27 in SimpleAccount.sol  Line 31 in SimpleAccount.sol  Line 23 in TestAggregatedAccount.sol  Line 34 in TestAggregatedAccount.sol  Line 16 in TestSignatureAggregator.sol  Line 28 in TestSignatureAggregator.sol  Line 43 in TestSignatureAggregator.sol  Line 40 in TokenPaymaster.sol  Line 6 in Exec.sol  Consider thoroughly documenting all functions and their parameters, especially public APIs. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Partially resolved in pull request #212 and merged at commit eeb93b2. The recommended changes to GnosisAccountFactory.sol were not implemented.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#missing-docstrings-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "Missing error messages in require statements [core and samples]", "body": "Within the codebase there are some require statements that lack error messages:  The require statement on line 105 of BasePaymaster.sol  The require statement on line 49 of DepositPaymaster.sol  The require statement on line 137 of SimpleAccount.sol  Consider including specific, informative error messages in require statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied.  Update: Resolved in pull request #198 and merged at commit 182b7d3. Error messages were added to the deficient require statements in BasePaymaster.sol and DepositPaymaster.sol, and the require statement in SimpleAccount.sol was eliminated as part of a code change.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#missing-error-messages-in-require-statements-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "Missing recommended function [samples]", "body": "states that an aggregated account should support the  BLSAccount contract does not contain a  the getBlsPublicKey function to  Update: Resolved in pull request #199 and merged at commit 12d2ac0. The EIP now uses the getBlsPublicKey function as an example.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#missing-recommended-function-[samples]", "labels": ["OpenZeppelin"]}, {"title": "Uninitialized implementation contract [samples]", "body": "The SimpleAccountFactory creates a new implementation contract but does not initialize it. This means that anyone can initialize the implementation contract to become its owner.  The consequences depend on the version of OpenZeppelin contracts in use. The project requires release 4.2 and later, but release 4.8 is locked. The onlyProxy modifier was introduced in release 4.3.2 to protect the upgrade mechanism. Without this modifier, the owner is authorized to call the upgrade functions on the implementation contract directly, which lets them selfdestruct it.  With the locked version, the implementation owner can execute arbitrary calls from the implementation contract, but should not be able to interfere with the operation of the proxies.  Nevertheless, to reduce the attack surface, consider restricting the versions of OpenZeppelin contracts that are supported and disabling the initializer in the constructor of the SimpleAccount contract, to prevent anyone from claiming ownership.  Update: Resolved in pull request #201 and merged at commit 4004ebf.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#uninitialized-implementation-contract-[samples]", "labels": ["OpenZeppelin"]}, {"title": "Unrestrained revert reason [core]", "body": "FailedOp error where the  line 375 and  line 417) where an untrusted contract can provide the reason, potentially including misleading error codes. For example, the sender  Consider prefixing the externally provided revert reasons with a uniquely identifying error code.  Update: Resolved in pull request #200 and merged at commit 3d8f450.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#unrestrained-revert-reason-[core]", "labels": ["OpenZeppelin"]}, {"title": "Unsafe ABI encoding", "body": "It is not an uncommon practice to use abi.encodeWithSignature or abi.encodeWithSelector to generate calldata for a low-level call. However, the first option is not safe from typographical errors, and the second option is not type-safe. The result is that both of these methods are error-prone and should be considered unsafe.  Within EIP4337Manager.sol, there are some occurrences of unsafe ABI encodings being used:  On line 119  On line 144  Consider replacing all occurrences of unsafe ABI encodings with abi.encodeCall, which checks whether the supplied values actually match the types expected by the called function, and also avoids typographical errors.  Note that a bug related to the use of string literals as inputs to abi.encodeCall was fixed in version 0.8.13, so developers should exercise caution when using this function with earlier versions of Solidity.  Update: Resolved in pull request #220 and merged at commit c0a69bf. The first example is an invalid recommendation because it is encoding an error.  Notes & Additional Information  Declare uint/int as uint256/int256 [core and samples]  codebase, there are multiple instances of  Update: Partially resolved in pull request #215 and merged at commit 998fa7d. Most instances have been addressed but there are some uint types remaining.  File relocation recommendations [samples]  To provide additional clarity regarding whether a given contract file contains core, sample, or test code, consider the following recommendations to move project files:  Within the samples directory, TestAggregatedAccount.sol, TestAggregatedAccountFactory.sol, and TestSignatureAggregator.sol contain test contracts similar to those found in the contracts/test directory. Consider relocating these files to the contracts/test directory.  The bls and gnosis directories contain sample account implementations, but do not reside in the samples directory. Consider moving these items to the samples directory.  Update: Resolved in pull request #217 and merged at commit f82cbbb.  IAccount inheritance anti-pattern  to expose a signature aggregator associated with the account. To add support for handling aggregated user operations, the  must provide a null address for this parameter. This represents an anti-pattern where a base class is aware of features only relevant to a derived class.  To address this case and future enhancements of the protocol, consider replacing the aggregator parameter in validateUserOp with a more generic extensions parameter that can be used to specify the aggregator as well as any future account-specific extensions.  Update: Resolved in pull request #216 and merged at commit 1f505c5.  Implicit size limit [core]  The packSigTimeRange function of the BaseAccount contract implicitly assumes the timestamps fit within 8 bytes. Consider enforcing this assumption by using uint64 parameters.  Update: Resolved in pull request #203 and merged at commit fa46d5b.  Incomplete event history [samples]  The BLSAccount contract emits an event when the public key is changed, but not when it is initialized. To complete the event history, consider emitting the event on initialization as well.  Update: Resolved in pull request #204 and merged at commit 2600d7e.  Lack of indexed parameter [core]  The aggregator parameter in the SignatureAggregatorChanged event is not indexed. Consider indexing the event parameter to avoid hindering the task of off-chain services searching and filtering for specific events.  Update: Resolved in pull request #202 and merged at commit 1633c06.  Naming suggestions [core and samples]  To favor explicitness and readability, there are several locations in the contracts that may benefit from better naming. Our suggestions are:  In BaseAccount.sol:  The packSigTimeRange function is internal but is not prefixed with _. Consider renaming to _packSigTimeRange.  In BasePaymaster.sol:  The packSigTimeRange function is internal but is not prefixed with _. Consider renaming to _packSigTimeRange.  In BLSSignatureAggregator.sol:  Consider renaming all instances of hashPublicKey to publicKeyHash for consistency.  In EIP4337Manager.sol:  Consider renaming the local variable _msgSender to msgSender for consistency.  In IAggregator.sol:  Consider renaming the return value of the aggregateSignatures function from aggregatesSignature to aggregatedSignature.  In IEntryPoint.sol:  The ExecutionResult error uses validBefore instead of validUntil. For consistency, consider changing the parameter name to validUntil. The ReturnInfo structs documentation for the validAfter parameter indicates it is inclusive. Consider renaming it to validFrom throughout the entire codebase. In the AggregatorStakeInfo struct, consider renaming actualAggregator to aggregator (also in the comment here).  In SenderCreator.sol:  In the createSender function, consider renaming the initAddress variable to factory to be consistent with the EntryPoint contract.  In SimpleAccount.sol:  In the addDeposit function, consider renaming the req variable to success.  In StakeManager.sol:  internalIncrementDeposit is an internal function that uses internal as its prefix instead of _. Consider changing to _incrementDeposit. The getStakeInfo function is internal but not prefixed with _. Consider renaming the function to _getStakeInfo. Consider renaming the addr parameter of getStakeInfo to account. Consider removing the leading underscore from all instances of _unstakeDelaySec in StakeManager now that there is no longer a storage variable named unstakeDelaySec.  Update: Resolved in pull request #221 and merged at commit 7bd9909.  Inconsistent ordering [core and samples]  The Solidity Style Guide specifies a recommended order for the layout of elements within a contract file in order to facilitate finding declarations grouped together in predictable locations. Within the codebase, this recommendation is not followed in several places:  In BLSAccount.sol: The PublicKeyChanged event is defined between two functions.  In BLSSignatureAggregator.sol: Constant value N is defined between two functions.  In IEntryPoint.sol: Starting at line 70, error and struct definitions are intermingled with function definitions.  In IPaymaster.sol: The PostOpMode enum is defined after all functions.  In SimpleAccount.sol: The _entryPoint variable, SimpleAccountInitialized event, and onlyOwner modifier are defined after several function definitions.  To improve the projects overall legibility, consider standardizing ordering throughout the codebase, as recommended by the Solidity Style Guide.  Update: Partially resolved in pull request #211 and merged at commit ca1b649. In IEntryPoint.sol, the error definitions were relocated but several struct definitions remain defined in between functions.  Stake size inconsistency [core]  The StakeManager allows deposits up to the maximum uint112 value, but the stake must be strictly less than the maximum unit112 value. Consider using the same maximum in both cases for consistency.  Update: Resolved in pull request #209 at commit 419b7b0.  TODO comments [core and samples]  The following instances of TODO comments were found in the codebase:  Line 305 in EntryPoint.sol  Line 52 in EIP4337Manager.sol  Line 57 in TokenPaymaster.sol  TODO comments are more likely to be overlooked and remain unresolved if they are not being tracked formally as issues. Over time, important information regarding the original motivation, plan, and supporting details may be lost. Consider removing all instances of TODO comments and tracking them in the issues backlog instead. Alternatively, consider linking each inline TODO to the corresponding issues backlog entry.  Update: Resolved in pull request #218 and merged at commit 80d5c89. The first example is obsolete. The other two are not TODOs and were changed to Note.  Typographical errors [core and samples]  Consider addressing the following typographical errors:  In BaseAccount.sol:  Line 70: chain-id should be chain id. Line 76: The an account should be If an account.  In BLSAccount.sol:  Line 9: public-key should be public key in this context. Line 12: a BLS public should be a BLS public key. Line 19: Mutable values slots should be Mutable value slots.  In BLSAccountFactory.sol:  Line 11: Based n should be Based on. Line 27: public-key should be public key in this context.  In BLSHelper.sol:  Line 32: (x2 y2, z2) should be (x2, y2, z2).  Line 137: Doubles a points should be Doubles a point.  In BLSSignatureAggregator.sol:  Line 34: to short should be too short. Line 89: public-key should be public key in this context; remove 1 space between value and using. Line 155: remove 1 space between stake and or.  In DepositPaymaster.sol:  Line 14: deposit should be deposits.  In EIP4337Manager.sol:  Line 106: prevent mistaken replaceEIP4337Manager to disable should be prevents mistaken replaceEIP4337Manager from disabling.  In EntryPoint.sol:  Line 50: into into should be index into. Line 69: deliberately caused should be not deliberately caused. Line 80: UserOperation should be UserOperations or user operations. Line 180: except that should be except for. Line 180: Missing closing parenthesis. Line 522: if it is was should be if it was. Line 552: A50 should be AA50. Line 560: A51 should be AA51.  In IAccount.sol:  Line 29: The an account should be If an account.  In IAggregatedAccount.sol:  Line 9: account, that support should be account that supports. Line 11: valiate should be validate.  In IAggregator.sol:  Line 20: return should be returns. Line 20: Sentence ends with a colon. Line 23: Missing closing parenthesis.  In IEntryPoint.sol:  Line 118: factor should be factory. Line 129: factor should be factory.  In IPaymaster.sol:  Line 13: agree should be agrees. Line 24: validation,) should be validation). Line 48: Now its should be Now its.  In IStakeManager.sol:  Line 22: Docstring copy-paste error from line 29. Line 51: allow should be allows.  In SimpleAccount.sol:  Line 65: transaction should be transactions.  In TestAggregatedAccount.sol:  Line 18: Mutable values slots should be Mutable value slots.  In TestAggregatedAccountFactory.sol:  Line 10: Based n should be Based on.  In TokenPaymaster.sol:  Line 11: define itself should be defines itself. Line 14: Missing closing double quote on getTokenValueOfEth. Line 66: The sentence is incomplete.  In UserOperation.sol:  Line 16: field hold should be field holds. Line 16: paymaster-specific-data should be paymaster-specific data; also remove quotes around this phrase.  Update: Resolved in pull request #219 and merged at commit b4ce311.  Unused imports [samples]  Throughout the codebase imports on the following lines are unused and could be removed:  Import console of BLSSignatureAggregator.sol  Import EIP4337Manager of EIP4337Fallback.sol  Import Exec of GnosisAccountFactory.sol  Import IAggregator of IAggregatedAccount.sol  Import UserOperation of IAggregatedAccount.sol  Import Ownable of DepositPaymaster.sol  Import BaseAccount of TestAggregatedAccount.sol  Import SimpleAccount of TestSignatureAggregator.sol  Import console in TestSignatureAggregator.sol  Import SimpleAccount of TokenPaymaster.sol  Consider removing unused imports to avoid confusion that could reduce the overall clarity and readability of the codebase.  Update: Resolved in pull request #206 and merged at commit e019bbd.  Unused interface [core]  The ICreate2Deployer.sol import was removed from EntryPoint.sol in pull request #144, but the file still exists in the interfaces directory. None of the contracts import this file.  Consider deleting the unused interface file.  Update: Resolved in pull request #205 and merged at commit 679ac11.  References to previously used wallet terminology [samples]  Throughout the codebase, an effort has been made to change the term wallet to account, e.g. SimpleWallet was renamed SimpleAccount. However, some wallet references remain in various comments:  Line 13 of BLSAccountFactory.sol  Line 9 of GnosisAccountFactory.sol  Line 12 of TestAggregatedAccountFactory.sol  Line 14 of VerifyingPaymaster.sol  Line 16 of VerifyingPaymaster.sol  To avoid confusion, consider replacing these instances of wallet with account.  Update: Resolved in pull request #210 and merged at commit d6a2db7.  Conclusions  One high severity issue was found. Several changes were proposed to improve the codes overall quality and reduce the attack surface.  Appendix  Monitoring Recommendations  While audits help in identifying potential security risks, the Ethereum Foundation is encouraged to also incorporate automated monitoring of on-chain contract activity, and activity within the new mempool, into their operations. Ongoing monitoring of deployed contracts helps in identifying potential threats and issues affecting the production environment. In this case, it may also provide useful information about how the system is being used or misused. Consider monitoring the following items:  User operations that have unusually high or low gas parameters may indicate a general misunderstanding of the system, or could identify unexpected economic opportunities in some kinds of transactions.  Operations or paymasters that consistently fail validation in the mempool could indicate a misunderstanding of the system, or an attempted denial-of-service attack.  Transactions that use non-standard accounts, factories, and aggregators could reveal interesting use cases, or unnecessary restrictions in the current design.  Any bundle that reverts on-chain may indicate a problem with the clients, or an edge case in the specified restrictions.  Operations where any of the participants have unusually low stake may provide useful insight into the risks that bundlers are willing to accept.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#unsafe-abi-encoding", "labels": ["OpenZeppelin"]}, {"title": "Declare uint/int as uint256/int256 [core and samples]", "body": "Declare uint/int as uint256/int256 [core and samples]", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#declare-uint/int-as-uint256/int256-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "File relocation recommendations [samples]", "body": "To provide additional clarity regarding whether a given contract file contains core, sample, or test code, consider the following recommendations to move project files:  Within the samples directory, TestAggregatedAccount.sol, TestAggregatedAccountFactory.sol, and TestSignatureAggregator.sol contain test contracts similar to those found in the contracts/test directory. Consider relocating these files to the contracts/test directory.  The bls and gnosis directories contain sample account implementations, but do not reside in the samples directory. Consider moving these items to the samples directory.  Update: Resolved in pull request #217 and merged at commit f82cbbb.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#file-relocation-recommendations-[samples]", "labels": ["OpenZeppelin"]}, {"title": "IAccount inheritance anti-pattern", "body": "to expose a signature aggregator associated with the account. To add support for handling aggregated user operations, the  must provide a null address for this parameter. This represents an anti-pattern where a base class is aware of features only relevant to a derived class.  To address this case and future enhancements of the protocol, consider replacing the aggregator parameter in validateUserOp with a more generic extensions parameter that can be used to specify the aggregator as well as any future account-specific extensions.  Update: Resolved in pull request #216 and merged at commit 1f505c5.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#iaccount-inheritance-anti-pattern", "labels": ["OpenZeppelin"]}, {"title": "Implicit size limit [core]", "body": "The packSigTimeRange function of the BaseAccount contract implicitly assumes the timestamps fit within 8 bytes. Consider enforcing this assumption by using uint64 parameters.  Update: Resolved in pull request #203 and merged at commit fa46d5b.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#implicit-size-limit-[core]", "labels": ["OpenZeppelin"]}, {"title": "Incomplete event history [samples]", "body": "The BLSAccount contract emits an event when the public key is changed, but not when it is initialized. To complete the event history, consider emitting the event on initialization as well.  Update: Resolved in pull request #204 and merged at commit 2600d7e.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#incomplete-event-history-[samples]", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed parameter [core]", "body": "The aggregator parameter in the SignatureAggregatorChanged event is not indexed. Consider indexing the event parameter to avoid hindering the task of off-chain services searching and filtering for specific events.  Update: Resolved in pull request #202 and merged at commit 1633c06.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#lack-of-indexed-parameter-[core]", "labels": ["OpenZeppelin"]}, {"title": "Naming suggestions [core and samples]", "body": "To favor explicitness and readability, there are several locations in the contracts that may benefit from better naming. Our suggestions are:  In BaseAccount.sol:  The packSigTimeRange function is internal but is not prefixed with _. Consider renaming to _packSigTimeRange.  In BasePaymaster.sol:  The packSigTimeRange function is internal but is not prefixed with _. Consider renaming to _packSigTimeRange.  In BLSSignatureAggregator.sol:  Consider renaming all instances of hashPublicKey to publicKeyHash for consistency.  In EIP4337Manager.sol:  Consider renaming the local variable _msgSender to msgSender for consistency.  In IAggregator.sol:  Consider renaming the return value of the aggregateSignatures function from aggregatesSignature to aggregatedSignature.  In IEntryPoint.sol:  The ExecutionResult error uses validBefore instead of validUntil. For consistency, consider changing the parameter name to validUntil. The ReturnInfo structs documentation for the validAfter parameter indicates it is inclusive. Consider renaming it to validFrom throughout the entire codebase. In the AggregatorStakeInfo struct, consider renaming actualAggregator to aggregator (also in the comment here).  In SenderCreator.sol:  In the createSender function, consider renaming the initAddress variable to factory to be consistent with the EntryPoint contract.  In SimpleAccount.sol:  In the addDeposit function, consider renaming the req variable to success.  In StakeManager.sol:  internalIncrementDeposit is an internal function that uses internal as its prefix instead of _. Consider changing to _incrementDeposit. The getStakeInfo function is internal but not prefixed with _. Consider renaming the function to _getStakeInfo. Consider renaming the addr parameter of getStakeInfo to account. Consider removing the leading underscore from all instances of _unstakeDelaySec in StakeManager now that there is no longer a storage variable named unstakeDelaySec.  Update: Resolved in pull request #221 and merged at commit 7bd9909.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#naming-suggestions-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent ordering [core and samples]", "body": "The Solidity Style Guide specifies a recommended order for the layout of elements within a contract file in order to facilitate finding declarations grouped together in predictable locations. Within the codebase, this recommendation is not followed in several places:  In BLSAccount.sol: The PublicKeyChanged event is defined between two functions.  In BLSSignatureAggregator.sol: Constant value N is defined between two functions.  In IEntryPoint.sol: Starting at line 70, error and struct definitions are intermingled with function definitions.  In IPaymaster.sol: The PostOpMode enum is defined after all functions.  In SimpleAccount.sol: The _entryPoint variable, SimpleAccountInitialized event, and onlyOwner modifier are defined after several function definitions.  To improve the projects overall legibility, consider standardizing ordering throughout the codebase, as recommended by the Solidity Style Guide.  Update: Partially resolved in pull request #211 and merged at commit ca1b649. In IEntryPoint.sol, the error definitions were relocated but several struct definitions remain defined in between functions.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#inconsistent-ordering-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "Stake size inconsistency [core]", "body": "The StakeManager allows deposits up to the maximum uint112 value, but the stake must be strictly less than the maximum unit112 value. Consider using the same maximum in both cases for consistency.  Update: Resolved in pull request #209 at commit 419b7b0.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#stake-size-inconsistency-[core]", "labels": ["OpenZeppelin"]}, {"title": "TODO comments [core and samples]", "body": "The following instances of TODO comments were found in the codebase:  Line 305 in EntryPoint.sol  Line 52 in EIP4337Manager.sol  Line 57 in TokenPaymaster.sol  TODO comments are more likely to be overlooked and remain unresolved if they are not being tracked formally as issues. Over time, important information regarding the original motivation, plan, and supporting details may be lost. Consider removing all instances of TODO comments and tracking them in the issues backlog instead. Alternatively, consider linking each inline TODO to the corresponding issues backlog entry.  Update: Resolved in pull request #218 and merged at commit 80d5c89. The first example is obsolete. The other two are not TODOs and were changed to Note.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#todo-comments-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors [core and samples]", "body": "Consider addressing the following typographical errors:  In BaseAccount.sol:  Line 70: chain-id should be chain id. Line 76: The an account should be If an account.  In BLSAccount.sol:  Line 9: public-key should be public key in this context. Line 12: a BLS public should be a BLS public key. Line 19: Mutable values slots should be Mutable value slots.  In BLSAccountFactory.sol:  Line 11: Based n should be Based on. Line 27: public-key should be public key in this context.  In BLSHelper.sol:  Line 32: (x2 y2, z2) should be (x2, y2, z2).  Line 137: Doubles a points should be Doubles a point.  In BLSSignatureAggregator.sol:  Line 34: to short should be too short. Line 89: public-key should be public key in this context; remove 1 space between value and using. Line 155: remove 1 space between stake and or.  In DepositPaymaster.sol:  Line 14: deposit should be deposits.  In EIP4337Manager.sol:  Line 106: prevent mistaken replaceEIP4337Manager to disable should be prevents mistaken replaceEIP4337Manager from disabling.  In EntryPoint.sol:  Line 50: into into should be index into. Line 69: deliberately caused should be not deliberately caused. Line 80: UserOperation should be UserOperations or user operations. Line 180: except that should be except for. Line 180: Missing closing parenthesis. Line 522: if it is was should be if it was. Line 552: A50 should be AA50. Line 560: A51 should be AA51.  In IAccount.sol:  Line 29: The an account should be If an account.  In IAggregatedAccount.sol:  Line 9: account, that support should be account that supports. Line 11: valiate should be validate.  In IAggregator.sol:  Line 20: return should be returns. Line 20: Sentence ends with a colon. Line 23: Missing closing parenthesis.  In IEntryPoint.sol:  Line 118: factor should be factory. Line 129: factor should be factory.  In IPaymaster.sol:  Line 13: agree should be agrees. Line 24: validation,) should be validation). Line 48: Now its should be Now its.  In IStakeManager.sol:  Line 22: Docstring copy-paste error from line 29. Line 51: allow should be allows.  In SimpleAccount.sol:  Line 65: transaction should be transactions.  In TestAggregatedAccount.sol:  Line 18: Mutable values slots should be Mutable value slots.  In TestAggregatedAccountFactory.sol:  Line 10: Based n should be Based on.  In TokenPaymaster.sol:  Line 11: define itself should be defines itself. Line 14: Missing closing double quote on getTokenValueOfEth. Line 66: The sentence is incomplete.  In UserOperation.sol:  Line 16: field hold should be field holds. Line 16: paymaster-specific-data should be paymaster-specific data; also remove quotes around this phrase.  Update: Resolved in pull request #219 and merged at commit b4ce311.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#typographical-errors-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "Unused imports [samples]", "body": "Throughout the codebase imports on the following lines are unused and could be removed:  Import console of BLSSignatureAggregator.sol  Import EIP4337Manager of EIP4337Fallback.sol  Import Exec of GnosisAccountFactory.sol  Import IAggregator of IAggregatedAccount.sol  Import UserOperation of IAggregatedAccount.sol  Import Ownable of DepositPaymaster.sol  Import BaseAccount of TestAggregatedAccount.sol  Import SimpleAccount of TestSignatureAggregator.sol  Import console in TestSignatureAggregator.sol  Import SimpleAccount of TokenPaymaster.sol  Consider removing unused imports to avoid confusion that could reduce the overall clarity and readability of the codebase.  Update: Resolved in pull request #206 and merged at commit e019bbd.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#unused-imports-[samples]", "labels": ["OpenZeppelin"]}, {"title": "Unused interface [core]", "body": "The ICreate2Deployer.sol import was removed from EntryPoint.sol in pull request #144, but the file still exists in the interfaces directory. None of the contracts import this file.  Consider deleting the unused interface file.  Update: Resolved in pull request #205 and merged at commit 679ac11.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#unused-interface-[core]", "labels": ["OpenZeppelin"]}, {"title": "References to previously used \u201cwallet\u201d terminology [samples]", "body": "Throughout the codebase, an effort has been made to change the term wallet to account, e.g. SimpleWallet was renamed SimpleAccount. However, some wallet references remain in various comments:  Line 13 of BLSAccountFactory.sol  Line 9 of GnosisAccountFactory.sol  Line 12 of TestAggregatedAccountFactory.sol  Line 14 of VerifyingPaymaster.sol  Line 16 of VerifyingPaymaster.sol  To avoid confusion, consider replacing these instances of wallet with account.  Update: Resolved in pull request #210 and merged at commit d6a2db7.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#references-to-previously-used-\u201cwallet\u201d-terminology-[samples]", "labels": ["OpenZeppelin"]}, {"title": "BaseBridgeReceiver can be rendered inoperable by incorrectly setting the localTimelock", "body": "The intricate relationship between the BaseBridgeReceiver and TimeLock contracts requires extra caution when updating the localTimelock in the BaseBridgeReceiver, as an incorrect update could render the entire contract inoperable. The following errors must be avoided:  Setting the new localTimelock value to an address that does not implement the Timelock interface (this includes sending the zero address by mistake)  Setting the localTimelock variable to an address that implements the Timelock interface, but with an admin (or pendingAdmin) variable that is not set to the address of the BaseBridgeReceiver contract  If either of these two events were to happen, the BaseBridgeReceiver contract would be unable to successfully send any new messages to the Timelock contract and, as a result, would not be able to update its own localTimelock variable to address this issue.  Update: Resolved in pull request 665 at commit 1ffc7e9.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#basebridgereceiver-can-be-rendered-inoperable-by-incorrectly-setting-the-localtimelock", "labels": ["OpenZeppelin"]}, {"title": "Proposals cannot be canceled", "body": "A proposal can queue its transactions in the Timelock contract by processing the message through the BaseBridgeReceiver contract.  However, even though the Timelock contract allows the admin address (in this case, the BaseBridgeReceiver contract) to cancel a certain transaction, the BaseBridgeReceiver contract does not implement the functionality to call that method.  This means that if a transaction needs to be canceled, a new proposal would need to be passed to change the admin address to an EOA or a contract that has the ability to cancel transactions. After the proposal is passed, it would need to be executed, and then the problematic transaction can finally be manually canceled.  Moreover, as the executeProposal function from the BaseBridgeReceiver contract is not access-controlled, any user may notice that a faulty or malicious transaction is queued and ready to be executed and the protocol will not have the option to stop them from executing it.  Consider implementing the functionality to cancel a transaction in the BaseBridgeReceiver contract.  Update: Acknowledged, not resolved. The Compound team stated:  L2Timelock proposals cannot be canceled by design.  Transactions begin as a proposal on L1. The L1 proposal is placed in the L1 Timelock (where it can be canceled), is queued for a period of time, and then is executed.  The execution of the L1 proposal results in the transaction being enqueued on the L2. It is in a pending state for a period of time, but as far as governance is concerned it is as though the proposal has already been executed.  We accept that once a transaction is enqueued on the L2, there is no way to cancel it.  Canceling an L2 proposal would require granting the authority to cancel to some entity on the L2; this is undesirable since the ability to cancel proposals is also a power that could be used maliciously.  Low Severity", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#proposals-cannot-be-canceled", "labels": ["OpenZeppelin"]}, {"title": "Reversions in Polygon will not be seen in Ethereum", "body": "The protocol implements the functionality to send sensitive governor actions from Ethereum to the Polygon network by using its bridge.  However, due to the unidirectional path of such instructions, the mainnet governor will always assume that orders sent to Polygon were submitted correctly. This means that in case of a reverted proposal when processing the message, the governor will not be aware of it and it will not allow to retry the same proposal without going through the entire lifecycle again.  Consider handling failed submissions of proposals and completing the loop back from Polygon to Ethereum to allow retriable proposals.  Update: Acknowledged, not resolved. The Compound team stated:  Comets approach to L2s is unidirectional by design. Creating an omnidirectional loop would increase complexity and potentially create additional vectors for malicious activity.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#reversions-in-polygon-will-not-be-seen-in-ethereum", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent transaction expiry", "body": "executeTransaction function from the  BaseBridgeReciever contract only considers a transaction valid if the transaction blocks timestamp is instead  Consider updating the contracts logic to agree on the expiration of a transaction.  Update: Resolved in pull request 666 at commit fcb9ef3.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#inconsistent-transaction-expiry", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent usage of uint across loops", "body": "In the BaseBridgeReceiver contract, the processMessage function uses a uint8 variable type to process a message and iterate over its targets.  However, when executing proposals, the for loop utilizes a uint variable type.  Even though the index of the for loop is not protected against overflow, in the unlikely case that more than 256 transactions are sent in a single proposal, the transaction would revert as there would be an identical transaction already queued.  Consider using the same type in both loops for consistency, or documenting the reason for having different implicit loop bounds. Additionally, consider removing the unchecked statement to reduce the attack vector when overflowing.  Update: Resolved in pull request 666 at commit 55712fb.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#inconsistent-usage-of-uint-across-loops", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed parameter", "body": "Within BaseBridgeReceiver.sol, line 20 does not have the event parameters indexed.  Consider indexing event parameters to improve the off-chain services ability to search and filter for specific events.  Update: Resolved in pull request 666 at commit 4b9bcb5.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#lack-of-indexed-parameter", "labels": ["OpenZeppelin"]}, {"title": "Missing distinction between queued and ready-to-execute state", "body": "In the BaseBridgeReceiver contract, the state function returns the state of a given proposal. Currently, the possible state values are: queued, expired, or executed.  However, it is important to distinguish between transactions that are still in queue and require more time before being executed, and those that can already be executed.  This is especially important as the executeProposal function checks that the proposal is in the queued state, but does not check if the proposal can already be executed. As a result, some transactions that are queued but not ready to be executed will pass the initial check, and the transaction will only revert once the executeTransaction function from the Timelock contract is called.  Consider adding another state that indicates that the proposal is queued and can already be executed.  Update: Acknowledged, not resolved. The Compound team stated:  The net benefit of this change would simply be that the error thrown would be thrown by the BaseBridgeReceiver instead of being thrown by the Timelock. These two approaches seem functionally equivalent; we will not make this update.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#missing-distinction-between-queued-and-ready-to-execute-state", "labels": ["OpenZeppelin"]}, {"title": "Identical transactions can be executed inside the same proposal", "body": "When a proposal is sent through the Polygon bridge, the BaseBridgeReceiver contract processes it by queuing all transactions that are included in the proposal to the Timelock contract.  The Timelock contract validates that each transaction is unique by using the hash of the parameters of the transaction as the identifier. However, it is possible to send a duplicated transaction because of how the signature parameter of the function signature is included in the data parameter.  This is caused by how the method abi.encode is used when queuing the transactions. It is possible to send an identical transaction twice by sending the first transaction with the function signature and a second one with the 4 bytes function selector attached to the data field. This would create two different hashes, which causes the requirement to be satisfied when the proposal is being executed, and as a result the same transaction would be executed twice.  When queuing transactions, consider using the packed callData output instead of relying on the signature and data fields for getting the txHash.  Update: Acknowledged, not resolved. The Compound team stated:  Executing identical transactions isnt a problem for us (theres nothing especially malicious that could be done by executing the same transaction twice. In fact, its a leftover limitation of the original Timelock implementation that youre unable to take the same action multiple times (though there isnt an obvious use case to do so). We are hoping to keep the L2 Timelock contracts as similar as possible to the version deployed to mainnet, so we will leave this code as it is.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#identical-transactions-can-be-executed-inside-the-same-proposal", "labels": ["OpenZeppelin"]}, {"title": "Unused return value from executeTransaction", "body": "The executeTransaction function from the Timelock contract has a return value that contains the output from the target.call call.  However, the return value is not used in the executeProposal function from the BaseBridgeReceiver contract. This makes it impossible to access the return value of a transaction that is executed by the BaseBridgeReceiver contract, which may be useful for debugging erratic or unintended behaviors.  Consider retrieving these outputs from the executeTransaction function calls in the executeProposal function.  Update: Acknowledged, not resolved. The Compound team stated:  Its unclear if exposing these return values would actually improve our ability to debug or monitor execution of transactions, especially given that reverted transactions wont emit any events or return any values. We will not make an update related to this recommendation.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#unused-return-value-from-executetransaction", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Nomenclature", "body": "There are a few instances where item names are inconsistent:  FXChild.sol contains an interface named IFxMessageProcessor. Consider matching the name of the interface with the files name.  The processMessageFromRoot function from the IFxMessageProcessor interface has a parameter named rootMessageSender. This interface is implemented in the PolygonBridgeReceiver contract but the parameters name has changed to messageSender. Consider being consistent when implementing the functionality.  Within the BaseBridgeReceiver contract, if a proposal is expired, an error is thrown labeled as ProposalNotQueued. The name of this error could be misleading to a viewer. Consider changing the name of the event to reflect the current behavior, or even better, consider adding a new event to reflect such status.  The Timelock allows the execution of a proposal after a certain delay but before a certain expiry time. This window is labeled as a GRACE_PERIOD, which is usually used to describe the time after a deadline but before penalties are enforced. This can be confusing. Consider using a different term such as EXECUTION_PERIOD to describe the window when proposal execution is allowed.  Update: Partially resolved in pull request 666 at commit ccba0d9. The Compound team stated:  GRACE_PERIOD: Will not update; we want to keep the Timelock interface as it is.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#inconsistent-nomenclature", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "The Timelock, ITimelock, FxChild, and PolygonBridgeReceiver contracts are missing documentation for their functions.  A lack of documentation hinders reviewers understanding of the codes intention which is fundamental to accurately assess not only security but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Partially resolved in pull request 666 at commit ccba0d9. The Compound team stated:  Timelock  No change; we want to keep Timelock as similar as possible to the existing implementationFxChild  Will not add docstrings; this is a vendor contract.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit imports are used", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code, and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are being used. For instance:  line 4 of BaseBridgeReceiver.sol  line 4 of PolygonBridgeReceiver.sol  line 5 of PolygonBridgeReceiver.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged, not resolved. The Compound team stated:  Our existing codebase uses non-explicit imports exclusively. We will continue to use non-explicit imports for consistency.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Same configuration values as Mainnet deployment", "body": "The Polygon deployment configuration is almost an exact copy of the Mainnet deployment configuration.  One difference is that the Polygon configuration contains USDT. In the past, Compound has refrained from using USDT as collateral, which causes an inconsistency across the protocol.  Moreover, during the first stages of a deployment, it is recommended to use conservative and stable values for the economic dynamics. Using the same values as the already established mainnet market could cause instabilities when using those from scratch.  Consider reviewing the configuration to ensure such values are correct for the Polygon deployment.  Update: Acknowledged, will resolve. The Compound team stated:  Will update; the configuration values in #598 are not final.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#same-configuration-values-as-mainnet-deployment", "labels": ["OpenZeppelin"]}, {"title": "Inconsistency between backlog and implementation", "body": "The pull request 598 contains a comment specifying that the deployment configuration should have a supplyCap value of 0, while its current value is 500000e18.  It seems the Compound Team is aware of this and will make this change prior to deployment.  Consider updating the supplyCap from the Polygon deployment configuration to zero.  Update: Acknowledged, will resolve. The Compound team stated:  Will update; the configuration values in #598 are not final.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#inconsistency-between-backlog-and-implementation", "labels": ["OpenZeppelin"]}, {"title": "Burn percentage applies retroactively", "body": "When creating an assertion, the minimum bond depends on the current value of the configurable burn percentage. Asserters and disputers would reasonably expect their reward to be the bond reduced by the burnedBondPercentage at the time the assertion was originally made. However, in contrast to other configurable parameters, the burn percentage is not cached, resulting in the actual reward being reduced by the most recent value at the time of settlement.  Consider caching the burn percentage and using it consistently throughout the life of an assertion.  Update: Acknowledged, not resolved. The UMA team stated:  Weve decided to not make this change. The implications of the issue presented here is that the voters vote to change the bond burn percentage after an assertion is disputed with the goal of stealing it from the disputer (for example setting the bond burn percentage to 100% after an assertion is made). We feel that this is a non-issue as the reputational damage of the DVM doing this would destroy the project and the cost to the protocol would be more than the value extracted from taking the reward.  Additionally, we are at the stack depth for the assertion object and adding an additional property to an assertion (bond burn percentage at assertion time) would require additional data structures or other refactors to accommodate this that we dont want to do at this time.  Low Severity", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#burn-percentage-applies-retroactively", "labels": ["OpenZeppelin"]}, {"title": "Arbitration resolution can be modified", "body": "setArbitrationResolution function in the  resolvedPrice result in the  Consider restricting the setArbitrationResolution function to only allow setting the resolution once per requestId.  Update: Resolved in pull request #4319 with commit 76bed2a.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#arbitration-resolution-can-be-modified", "labels": ["OpenZeppelin"]}, {"title": "Lack of access control on potentially sensitive functions", "body": "In the BaseEscalationManager contract, the following public functions may benefit from access control:  requestPrice  assertionResolvedCallback  assertionDisputedCallback  Currently anyone can call these functions, which can result in them executing state-changing logic in an unintended context.  Consider implementing appropriate access control on these functions so that only the expected instance(s) of the OptimisticAsserter contract can call them.  Update: Resolved in pull request #4334 with commit dd99434.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#lack-of-access-control-on-potentially-sensitive-functions", "labels": ["OpenZeppelin"]}, {"title": "Erroneous docstrings and comments", "body": "Consider fixing the following docstrings and inline comments:  In OptimisticAsserter.sol, the comment on line 88 claims the caller is the asserter, but that is not necessarily true.  In FullPolicyEscalationManager.sol, comments on line 161, line 171, and line 180 for the respective setDisputeCallerInWhitelist, setWhitelistedAssertingCallers, and setWhitelistedAsserters functions state Adds a \u2026 to the whitelist. In reality, the functions can both add and remove from the whitelists.  Update: Resolved in pull request #4320 with commit b943b23.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#erroneous-docstrings-and-comments", "labels": ["OpenZeppelin"]}, {"title": "Missing or incomplete docstrings", "body": "Several contracts and functions in the codebase lack complete documentation:  In BaseEscalationManager.sol:  assertionResolvedCallback has undocumented assertionId and assertedTruthfully parameters. assertionDisputedCallback has an undocumented assertionId parameter.  In EscalationManagerInterface.sol:  The interface is undocumented. All functions and structs are undocumented.  In FullPolicyEscalationManager.sol:  setDisputeCallerInWhitelist has an undocumented value parameter. setWhitelistedAssertingCallers has an undocumented value parameter. setWhitelistedAsserters has an undocumented value parameter.  In OptimisticAsserter.sol:  assertTruthWithDefaults has an undocumented asserter parameter. assertTruth has an undocumented return value. getCurrentTimestamp has an undocumented return value. Functions marked internal are undocumented.  In OptimisticAsserterInterface.sol:  The interface is undocumented. All functions are undocumented. The structs are only partially documented.  In OptimisticAsserterCallbackRecipientInterface.sol:  The interface is undocumented. All functions are undocumented.  Incomplete documentation hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and facilitate maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted.  Consider thoroughly documenting all functions and their parameters. When writing docstrings, especially for publicly-exposed functions, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #4342 with commit c831b8c.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#missing-or-incomplete-docstrings", "labels": ["OpenZeppelin"]}, {"title": "No check for final fee when adding currency to whitelist", "body": "When a currency is whitelisted and cached in the OptimisticAsserter contract, it is assumed that the Store contract will have a final fee set for the currency address. If the final fee has not been set, then assertions can be posted without a bond.  Prior to whitelisting a currency, consider adding a check that ensures the final fee from the Store contract is non-zero in the syncUmaParams and _validateAndCacheCurrency functions.  Update: Acknowledged, not resolved. The UMA team stated:  Weve decided to not make this change. There should never be collateral currencies added that dont have a final fee by DVM. If this was to occur, it would not pose too much of an issue within the system as 0 bonded assertions dont really enable you to do much other than spam the DVM. if you were to spam the DVM with this technique we can delete the requests at the DVM level.  Added to this (and more importantly) there is a feature of having zero-sized bonds in one important situation: testnets. It is really convenient to not have to force users on testnets to approve and pay collateral currencies when making simple tests as this strictly increases the friction with using the system.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#no-check-for-final-fee-when-adding-currency-to-whitelist", "labels": ["OpenZeppelin"]}, {"title": "BaseEscalationManager is not declared abstract", "body": "The requestPrice and getPrice functions in the BaseEscalationManager contract are stubs that do not perform any oracle actions. Additionally, the getPrice function has a return type of int256 but does not return any value. In its current state, this base contract does not implement a fully functional escalation manager.  Consider making the BaseEscalationManager contract abstract and removing the function body of the getPrice function to force implementation by derived contracts.  Update: Acknowledged, not resolved. The UMA team stated:  We think its better for this to not be abstract as it makes derived contracts easier and shorter to implement; if you dont care about a particular feature then you just do nothing and it defaults to the disabled/simple behavior. For example if you dont care about disabling disputes then the base implementation just returns true for isDisputeAllowed. By making this abstract wed force implementing contracts to have to declare and implement things, even if they dont care about that functionality.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#baseescalationmanager-is-not-declared-abstract", "labels": ["OpenZeppelin"]}, {"title": "Constant not using UPPER_CASE format", "body": "In OptimisticAsserter.sol, the defaultIdentifier constant is not declared using UPPER_CASE format.  According to the Solidity Style Guide, constants should be named in all capital letters with underscores separating words. For better readability, consider following this convention.  Update: Acknowledged, not resolved. The UMA team stated:  While it goes against the solidity styling guide, wed like to keep this lowercase so that the accessor function optimisticAsserter.defaultIdentifier() looks the same as the other assessors of similar type (optimisticAsserter.defaultCurrency() and optimisticAsserter.defaultLiveness()).", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#constant-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "Escalation managers are bound by DVM constraints", "body": "The OptimisticAsserter contract is designed to allow disputed assertions to be arbitrated by either the UMA Data Verification Mechanism (DVM) or an escalation manager contract specified by the asserter. The arbitrateViaEscalationManager setting controls whether the DVM or escalation manager will act as the oracle for arbitration.  Even when an escalation manager is chosen instead of the DVM, the assertTruth function still performs checks that are DVM-specific:  These are restrictions put in place in order to interact with the DVM, but they are not necessarily required by a generic escalation manager. These restrictions force all escalation managers to use the same currencies as the DVM for bond payment, and also impose a minimum bond amount based on the DVM final fee that is unrelated to each escalation managers costs. The identifiers supported by each escalation manager must also match those supported by the DVM.  Additionally, while the existing design allows the DVM to collect a fee for providing oracle services, it does not allow an escalation manager to collect any fee to cover its potential cost for providing the same service. Moreover, since the usage fee and burn amount are coupled, none of the bond is burned when the escalation manager is used as an oracle.  To provide a more generic and flexible design, consider uncoupling escalation managers from the constraints of the DVM and allowing all oracles to specify their supported identifiers, currencies, and fees. Applying an equal treatment to all oracles should allow for the removal of special-case logic for handling different oracle types.  Update: Resolved in pull request #4343 with commit 25d22a9. The oracleFee computed in settleAssertion is now collected in all dispute cases, even when the escalation manager is used as the oracle, to ensure that there is always a fee associated with any dispute. Additionally, the UMA team stated:  The feature of using escalation manager for dispute arbitration is designed only as a fallback mechanism to allow integrating partners to unplug from UMA DVM if it is considered under risk of being corrupted. This is not meant to be feature-full replacement of existing UMA Oracle system, thus we kept the same DVM constraints also when arbitrating disputes within the escalation manager. Otherwise it would require escalation managers to implement their own whitelisting and fee management mechanisms that is too much overhead just for the fallback scenario.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#escalation-managers-are-bound-by-dvm-constraints", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed parameters", "body": "Within the codebase, some events do not have their parameters indexed. Indexing event parameters facilitates the task of off-chain services searching and filtering for specific events. In particular, the following events may benefit from the addition of the indexed keyword to certain parameters:  In FullPolicyEscalationManager.sol:  DisputeCallerWhitelistSet event: Consider indexing address disputeCaller.  AssertingCallerWhitelistSet event: Consider indexing address assertingCaller.  AssertingWhitelistSet event: Consider indexing address asserter.  Update: Resolved in pull request #4323 with commit 6ad9643.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#lack-of-indexed-parameters", "labels": ["OpenZeppelin"]}, {"title": "Argument name mismatch between interface and implementation", "body": "getMinimumBond function in the  OptimisticAsserterInterface interface is named  OptimisticAsserter contract on  line 358.  For clarity, consider renaming one of the arguments so the interface matches the implementation.  Update: Resolved in pull request #4324 with commit dffb20e.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#argument-name-mismatch-between-interface-and-implementation", "labels": ["OpenZeppelin"]}, {"title": "Missing event parameter", "body": "In contrast to the AssertionMade and AssertionSettled events, the AssertionDisputed event does not emit the calling address. Consider including it for completeness.  Update: Resolved in pull request #4325 with commit 9c37198.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#missing-event-parameter", "labels": ["OpenZeppelin"]}, {"title": "Lack of SPDX license identifiers", "body": "All of the contract files in the escalation-manager directory lack SPDX license identifiers.  To avoid legal issues regarding copyright and follow best practices, consider adding SPDX license identifiers to files, as suggested by the Solidity documentation.  Update: Resolved in pull request #4326 with commit 5e36c85.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#lack-of-spdx-license-identifiers", "labels": ["OpenZeppelin"]}, {"title": "Multicall is payable", "body": "The multicall function of the MultiCaller contract is declared payable but does not accept any ETH. In the interest of clarity, consider removing the payable keyword.  Update: Resolved in pull request #4327 with commit 1d416c9.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#multicall-is-payable", "labels": ["OpenZeppelin"]}, {"title": "Missing check for non-zero address before calling external function", "body": "_isDisputeAllowed function in the  policy is to not validate disputers when no escalation manager is specified, so the function will  exit early instead of invoking a function on the zero address.  Nevertheless, in the interest of local reasoning, consider adding a zero-address check on the em address prior to using it to make external function calls. Also consider swapping line 449 and line 450 so that the em address assignment is only made when this variable is required.  Update: Resolved in pull request #4336 with commit 9543282.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#missing-check-for-non-zero-address-before-calling-external-function", "labels": ["OpenZeppelin"]}, {"title": "Redundant code", "body": "Consider addressing the following instances of redundant code within the codebase:  The override keyword can be removed from all functions in the BaseEscalationManager contract.  The requestId is computed on line 89 and line 155 in the FullPolicyEscalationManager contract. Consider deduplicating this code by creating a shared getRequestId function. Additionally, consider making this function publicly available for user convenience.  Within the FullPolicyEscalationManger contract, the require statement in the configureEscalationManager function can be simplified:require(!_blockByAsserter || (_blockByAsserter && _blockByAssertingCaller), \"Cannot block only by asserter\");Execution can only reach the (_blockByAsserter && _blockByAssertingCaller) condition if the first condition !_blockByAsserter evaluates to false, which means the second condition will always evaluate to (true && _blockByAssertingCaller). This further reduces to just _blockByAssertingCaller.  The lookup of assertions[assertionId].escalationManagerSettings.escalationManager happens on lines 435, 443, 449, 471, 472, 480, and 481 in the OptimisticAsserter contract. Consider modifying the existing _getEscalationManager function to return an address type, and using it in all the identified locations other than line 435 to perform the escalationManager lookup. This change would also enable the removal of the address() cast that occurs on line 414 where _getEscalationManager is currently used.  In the _callbackOnAssertionResolve and _callbackOnAssertionDispute functions within the OptimisticAsserter contract, the lookup of assertions[assertionId].callbackRecipient and assertions[assertionId].escalationManagerSettings.escalationManager happens twice within each functions scope. In each case, consider storing the value obtained from the first lookup in a local variable for reuse.  The return statement in the assertTruth function is redundant because assertionId is a named return variable in the function specification. Consider removing this return statement.  Update: Partially resolved in pull request #4335 with commit 59b13d3. The _isDisputeAllowed function still performs the lookup assertions[assertionId].escalationManagerSettings.escalationManager instead of using the _getEscalationManager function.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#redundant-code", "labels": ["OpenZeppelin"]}, {"title": "Public functions that could be declared external", "body": "In Solidity, functions with public visibility can be used both internally and externally. In the case a function is only ever used externally, it is best practice to limit the visibility to external rather than public. Below is a list of functions that have public visibility that can be limited to external visibility in the OptimisticAsserter contract:  assertTruthWithDefaults  disputeAssertion  settleAndGetAssertionResult  To improve the explicitness of the codebase, and to reduce gas usage, consider changing the visibility of these functions to external.  Update: Resolved in pull request #4337 with commit bbe05e1.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#public-functions-that-could-be-declared-external", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Consider correcting the following typographical errors:  In BaseEscalationManager.sol:  Line 34: if the dispute should be true if the dispute.  Line 55: Optimistic should be Optimistic Asserter.  In FullPolicyEscalationManager.sol:  Line 12: a whitelistedDisputeCallers should be whitelistedDisputeCallers.  Line 101: Assertor should be Asserter.  Line 161: disputerCaller should be disputeCaller.  In OptimisticAsserter.sol:  Line 122: security properties the assertion should be security properties for the assertion.  Line 128: Must be a pre-approved. is an incomplete sentence.  Line 132: should be bytes32 should be 0.  Line 180: Set should be set.  Line 218: cant should be cant.  In OptimisticAsserterInterface.sol:  Line 10: SS should be SSM.  Update: Resolved in pull request #4339 with commit 97be5e6.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unused import", "body": "In EscalationManagerInterface.sol, the import OptimisticAsserterInterface.sol is unused and could be removed.  Consider removing unused imports to avoid confusion that could reduce the overall clarity and readability of the codebase.  Update: Resolved in pull request #4338 with commit e4f47ee.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#unused-import", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent use of named return variables", "body": "stampAssertion,  getMinimumBond, and  getCurrentTime do not assign names. None of the internal functions use named variables, making them consistent with each other but inconsistent with the external/public functions. Additionally, the following functions have unused named variables:  assertTruthWithDefaults,  settleAndGetAssertionResult,  getAssertion, and  getAssertionResult.  When choosing to use named return variables, consider using them in a consistent manner throughout all functions within the same contract.  Update: Resolved in pull request #4341 with commit 59364ce. The unused named return variables were removed.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#inconsistent-use-of-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Use of magic numbers", "body": "The OptimisticAsserter and FullPolicyEscalationManager contracts use the constant value 1e18 in the settleAssertion and getPrice functions without documenting the values meaning.  Literal values in the codebase without an explained meaning make the code harder to understand and maintain, thus hindering the experience of developers, auditors, and external contributors alike. To improve the codes readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name.  Update: Resolved in pull request #4340 with commit 5ba00f8. The OptimisticAsserter and FullPolicyEscalationManager contracts now independently define a numericalTrue constant equal to 1e18 and provide an explanatory comment.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#use-of-magic-numbers", "labels": ["OpenZeppelin"]}, {"title": "Useless Assertion Check", "body": "The assertEq function in the bootloader compares two values. If they are not equal, it throws an error. There are two issues with this implementation:  The function compares the value of the value1 parameter to itself, which means the comparison will always be true and the function serves no purpose.  The function header includes the value1 parameter twice, which causes a compile-time error when using a Solidity compiler such as solc.  Consider correcting the comparison by checking two distinct variables. Additionally, ensure that the custom zkEVM compiler throws an error when declaring two variables with the same name in the same scope.  Update: Resolved in pull request #133 at commit 6e3c054.  High Severity", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#useless-assertion-check", "labels": ["OpenZeppelin"]}, {"title": "Non-Standard Transaction Hash", "body": "The BootloaderUtilities contract generates transaction hashes for different types based on the transaction data, including the signature. The signature includes a v value that encodes a parity bit y for address recovery purposes. The way that the parity bit is encoded into v depends on the type of transaction:  For legacy transaction hashes, v can be either 27 + y, or 35 + chainid * 2 + y when the chainid is included (Ethereum Yellowpaper, page 5).  For EIP2930 and EIP1559 transactions, v is simply encoded as y (either 0 or 1).  v must be either 27 or 28. This causes problems in the legacy transaction hash function because, when the  35 + block.chainid * 2 is added to v. But, since  Additionally, in the EIP-2930 and EIP-1559 transaction hash functions, the v value is again fetched as either 27 or 28 and encoded as such, even though it should be 0 or 1 as defined by the standard. Hence, the transaction hashes generated by these functions are also non-standard.  Consider fixing this by deriving the correct value from the v value that is given or changing the way the v value is enforced in the first place.  Update: Resolved in pull request #157 at commits 3472d28 and 471a450.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#non-standard-transaction-hash", "labels": ["OpenZeppelin"]}, {"title": "Unbound RLP Length Encoding", "body": "The RLPEncoder library allows the encoding of bytes and list-type values. These dynamic types need to be prefixed to indicate the type and length of the data. The type is indicated through an offset:  0x80 for bytes  0xc0 for a list  The length encoding depends on the length itself:  Length < 56: The length is added onto the offset.  Bytes 1st byte range: [0x80, 0xb7] List 1st byte range: [0xc0, 0xf7]  Length \u2265 56: The length of the data is encoded between offset and data. The length of the length in bytes is added onto the offset.  Bytes 1st byte range: [0xb8, 0xbf] List 1st byte range: [0xf8, 0xff]  Visualization of 2.:  In the (2.) case, we can see that the encoding of the length can at most be 8 bytes long. However, in the RLP library a length of up to 32 bytes is taken as input to encode the length. Hence, when encoding a length equal or greater than 2**64, the length encoding requires 9 or more bytes. This bound violation ends up in a corrupted encoding. For instance, a byte encoding could thereby end up as a list encoding.  This issue was not identified as a problem for the codebase in scope, as the length to encode is based on transaction data, which is unlikely to be of size 2**64 or greater. However, as this library finds adoptions across other projects, the current implementation could lead to severe issues or introduction of vulnerabilities if not used properly.  Consider checking that the length to encode is bound to 2**64 - 1.  Update: Resolved in pull requests #134 and #160 at commits 61b8138 and 6e45486.  Medium Severity", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#unbound-rlp-length-encoding", "labels": ["OpenZeppelin"]}, {"title": "Overshadowing and Uncaptured Returns", "body": "In the bootloader contract, the function setTxOrigin has a return value success, which is overshadowed by a local variable of the same name within the function scope. In the solc Solidity compiler this triggers a compiler error.  Additionally, the setTxOrigin function is called from the top level without capturing its return value, which causes another compiler error in solc and might lead to unexpected outcomes when using other compilers.  The same issue applies to the precompileCall function, which has a return value that is not captured when it is called inside the nearCallPanic function.  To address these issues, consider removing all unused return values.  Update: Resolved in pull request #135 at commit 45c04f9.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#overshadowing-and-uncaptured-returns", "labels": ["OpenZeppelin"]}, {"title": "String Literal Exceeds 32 Bytes Limit", "body": "In the bootloader contract, the string literal Tx data offset is not in correct place is used as an input to the assertionError function. It exceeds the 32-byte limit for string literals in Yul, which leads to a compile error with the solc Solidity compiler. The usage of another compiler might lead to a similar error or silently discard parts of the string.  To avoid any possible compiler and runtime issues, consider making the string shorter by removing or abbreviating some of the words.  Update: Resolved in pull request #136 at commit d506790.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#string-literal-exceeds-32-bytes-limit", "labels": ["OpenZeppelin"]}, {"title": "Unprotected Initialization Function", "body": "In the L2EthToken contract, an unresolved comment acknowledges the fact that the initialization function is unprotected and anyone could set the l2Bridge address if they call the function before the legitimate operator. The comment describes the problem without presenting a solution.  Consider using the TypeScript-based templating system that is already present in the codebase to inject a constant address that limits the initialization call to one specific msg.sender.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We plan to rethink the approach of bridging ether in the new upgrade, the issue will be resolved there.  Low Severity", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#unprotected-initialization-function", "labels": ["OpenZeppelin"]}, {"title": "Documentation and Code Mismatch", "body": "In the bootloader contract a few instances of a mismatch between the contract and documentation were identified:  The MAX_POSTOP_SLOT constant is documented to account for 4 slots which are required for the encoding of the callPostOp call. However, the implementation accounts for 7 slots.  The MAX_MEM_SIZE constant is of size 2**24, while it is described as 2**16.  In the callPostOp function, the txResult parameter is described as 0 if successful and 1 otherwise. However, the txResult value is coming from low-level call that returns 1 if being successful and 0 otherwise. Proceeding forward, this result is correctly handled through the ExecutionResult enum, thereby affecting the documentation only.  The setErgsPrice function is incorrectly documented as Set the new value for the tx origin context value.  The lengthToWords function is implemented differently from what the name and documentation are indicating. From the description it suggest to return the number of words needed for a specified length of bytes. However, the implementation returns the next bigger bytes length of words that are needed. The implementation is also inefficient and can be simplified.  In the RLPEncoder library, the comment on line 7 describes the size as equal to 14 bytes (dec), while 0x14 bytes (hex) is the correct size.  In the BootloaderUtilities contract, the comment on line 21 refers to signedHash while signedTxHash is the correct identifier name.  In the L2EthToken contract, the transferFromTo function claims to rely on SameMath which is probably referring to a SafeMath library which is also not used in that function.  Consider correcting the above mismatches to be precise about the implementation and its documentation to ease code review.  Update: Resolved in pull requests #137 and #161 at commits 68f99cb, 7b66b8a, and e09b067.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#documentation-and-code-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Incompatible Function Syntax", "body": "In the bootloader contract, the function getFarCallABI is declared with a list of parameters ending with a trailing comma.  However, the Solidity compiler solc does not support the declaration of Yul functions with a parameter list containing a trailing comma.  Consider removing the trailing comma and ensure that your codebase maintains as much compatibility with the Solidity compiler whenever possible.  Update: Resolved in pull request #138 at commit 5e1cf33.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#incompatible-function-syntax", "labels": ["OpenZeppelin"]}, {"title": "Inexplicit Fail in Bridge Burn", "body": "The bridgeBurn function in the L2EthToken contract adjusts a users balance without checking their current balance first. This could result in an underflow error, which is providing insufficient information to the user.  To prevent this issue, consider adding a require statement to explicitly fail with a descriptive error string if the users balance is exceeded.  Update: Resolved in pull request #139 at commit 2053757.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#inexplicit-fail-in-bridge-burn", "labels": ["OpenZeppelin"]}, {"title": "Inexplicit Imports", "body": "In the BootloaderUtilities and MsgValueSimulator contract, the Constants.sol file inexplicitly imports all constants. This hinders the visibility of what other components are actually used within the contract.  Consider changing the imports to explicitly import specific constants for better code clarity.  Update: Resolved in pull request #156 at commit 94c79a5.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#inexplicit-imports", "labels": ["OpenZeppelin"]}, {"title": "Lack of Revert Messages", "body": "In the L2EthToken contract, the require statements in line 36-37, 42, and 54-58 lack an error message.  Consider adding the error message to fail more explicitly and ease debugging.  Update: Resolved in pull request #140 at commit be287c9.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#lack-of-revert-messages", "labels": ["OpenZeppelin"]}, {"title": "Mismatch Between Interface and Implementation", "body": "The BootloaderUtilities contract imports the IBootloaderUtilities interface, but the contract does not inherit from this interface. It appears that the intent may have been to inherit from the interface, but due to this oversight, there is a mismatch between the function names and return types in the interface and the contract.  In the interface, the function is defined as:  But in the contract, it is defined as:  This inconsistency may result in errors or unexpected behavior.  Consider inheriting from the IBootloaderUtilities interface in the BootloaderUtilities contract to ensure that the function names and return types are consistent and match the intended functionality. This will improve the reliability and maintainability of the codebase.  Update: Resolved in pull request #141 at commit 827aad6.  Missing Interface for L2EthToken  The L2EthToken contract implements two interfaces to enforce compliance with their respective functions. However, the contract also implements the standard ERC-20 functions name, symbol, decimals, and totalSupply.  Currently, nothing prevents misspellings and there is no convenient way to call these functions through address to interface conversion.  Consider either integrating them into one of the existing interfaces or defining an additional interface PartialERC20.  Update: Resolved in pull requests #142 and #162 at commits f6fbaa9 and 5082111.  Imprecise Naming of Transaction Struct Elements  In the bootloader contract, inside of the validateTypedTxStructure function, it is stated that the first and second reserved slots of the transaction struct are used to store the nonce and value, respectively. These values are common to all types of transactions and could also be stored as explicit elements of the transaction struct.  To improve the code clarity, consider adding dedicated entries to the transaction struct for these common elements.  Update: Resolved in pull request #143 at commits af4c5b9 and cd55ab2.  TypeScript Constant Names Are Inconsistent  The bootloader contract includes constants that are defined in TypeScript code with the format , and are replaced with their actual values during compilation. These constants, which are often used for selectors, may or may not be padded with zeros. However, the names of these constants do not consistently indicate whether they have been padded or not, which is important for determining the memory layout in the bootloader.  To improve the clarity and consistency of the codebase, consider using consistent naming conventions for constants that indicate whether they have been padded or not.  Update: Resolved in pull request #144 at commit 8ca44a7.  Unused Functions  The following internal functions are defined in the bootloader contract, but appear to be unused:  ETH_L2_TOKEN_ADDR  min  ETH_CALL_ERR_CODE  UNACCEPTABLE_ERGS_PRICE_ERR_CODE  TX_VALIDATION_FAILED_ERR_CODE  To improve the codebase, consider either using these functions or removing them. Removing unused functions can help to reduce clutter and make the code easier to understand.  Update: Resolved in pull request #145 at commit 316c54a. The Matter Labs team stated:  We removed all unused constants except _ERR_CODES, which are used in the server. We want to avoid any confusion when starting to use such error codes in bootloader.  Wrong EIP-712 Transaction Type Check  In the validateTypedTxStructure function of the bootloader, the EIP-712 txType is checked against 112, while it is supposed to be 113.  Following the execution flow, it can be seen in the getTransactionHashes function that a call reverts if the transaction type does not match one of 0, 1, 2, or 113. So for a transaction of type 113, the foreseen checks in the bootloader are skipped. This means the reserved slots can be arbitrary. However, no negative consequences were identified.  Consider correcting the transaction type check from 112 to 113. Further, consider implementing a default case and using the unused valid return variable to fail early if the transaction type does not match.  Update: Resolved in pull request #146 at commit c343256.  Notes & Additional Information  Code Redundancy  BootloaderUtilities contract, different types of transactions are encoded and hashed. These transaction types share similarities in their encoding which leads to redundancy of code. For instance, both the legacy and EIP-2930 type transaction have the consecutively encoded fields  Consider moving some parts of the encoding into a function to reuse the code for both transaction types.  Update: Acknowledged, not resolved. The Matter Labs team stated:  Specifically in the specified places, we choose readability over performance.  Commented-out Code  In the bootloader.yul file, the two constants in Solidity code format dummyAddress and BOOTLOADER_ADDRESS are commented out and seem obsolete.  Consider removing the commented-out code as well as the comments describing them.  Update: Resolved in pull request #147 at commit 7c344be.  Extra Code  In the bootloader contract, the computation of a switch statement condition in the transaction processing includes unnecessary code that makes the code harder to read. The variables txType and isL1Tx are not used elsewhere in the function. Additionally, the FROM_L1_TX_TYPE variable appears to be a constant, but it is not declared as such.  To improve the clarity and readability of the code, consider simplifying the switch statement computation and properly declaring variables as constants if they are intended to be constant.  Update: Resolved in pull requests #148 and #158 at commits 613636f and cdc301f.  Inconsistent Declaration of Constants  There is an inconsistency in the way constants are declared in the code, with some being declared as functions and others being declared as variables. This deviation from a consistent pattern can be confusing and make it difficult to understand the purpose and usage of these constants. The following constants are declared as variables:  TX_DESCRIPTION_SIZE  TXS_IN_BLOCK_LAST_PTR  Consider using a consistent method for declaring constants throughout the code as functions. This will improve the readability and understandability of the code and make it easier for others to work with it.  Update: Resolved in pull request #149 at commits c7042cd and fee4b5b.  Inconsistent Declaration of Integers  In the bootloader contract, there is an inconsistency in the way memory offsets are declared in the codebase, with some being expressed in decimal and others being expressed in hexadecimal. This deviation from a consistent notation can be confusing and make it difficult to understand the purpose and usage of these sizes. For instance:  add(0x20, txDataOffset) in line 291  add(0x20, txDataOffset) in line 300  mstore(txDataOffset, 0x20) in line 431  add(txDataOffset, 0x20) in line 797  add(txDataOffset, 0x20) in line 1170  add(dataPtr, 0x20) in line 1400  Consider using a consistent notation for expressing memory offsets throughout the codebase.  Update: Resolved in pull request #150 at commit ecdbebd.  Performance Optimization  In the bootloader contract, we have identified several opportunities for performance optimization:  In the validateTypedTxStructure function, when checking if the reservedDynamicLength value is not zero, consider loading the length from the getReservedDynamicPtr pointer directly to skip the lengthToWords computation.  In the callAccountMethod function, consider using the existing txDataOffset pointer instead of advancing the txDataWithHashesOffset a second time to save an add.  In the function call to executeL1Tx, consider propagating the given innerTxDataOffset instead of recalculating it in the function itself.  In the getFarCallAbi function, dataOffset and memoryPage are zero and could be skipped. Consider starting with the shifted dataStart value instead.  The executeL2Tx function is only called within the ZKSYNC_NEAR_CALL_executeL2Tx() function where the from transaction value is present. Consider propagating that from value to the executeL2Tx call instead of recomputing it.  Update: Partially resolved in pull request #151 at commit fe92113. The Matter Labs team stated:  Partially fixed, we decided to keep better readability over performance in a place where optimization is hard to implement or may confuse the reader. Also, please note that the compiler could do such an optimization, because we have an LLVM backend.  TODOs Are Present in the Codebase  In the bootloader contract, there are incomplete implementations and missing functionality in the codebase, as indicated by the presence of TODO comments. This can make it difficult to understand the intended functionality and behavior of the code, and may also make it difficult to properly test and maintain the codebase. For instance:  make user pay for sending back the L1 message  (SMA-1220): refunds are not supported as of now  (SMA-1220): support refunds [\u2026]  Consider completing the implementations and addressing the missing functionality. This will improve the overall quality and reliability of the codebase and make it easier for others to work with it.  Update: Acknowledged, not resolved. The Matter Labs team stated:  The issue will be resolved in upcoming upgrades.  Typographical Errors  In the codebase the following typographical errors were identified:  shoud \u2192 should  Firsly \u2192 Firstly  succedes \u2192 succeeds  Reseting \u2192 Resetting  mainntet \u2192 mainnet  only one higher \u2192 only the first one above  again \u2192 against  Consider correcting these and any further issues.  Update: Resolved in pull request #152 at commits 9dd29e3 and 630625f.  Unexpected Negation in Inclusion Logic  bootloader contract, the constant  line 1523, the inclusion of a block is determined by negating the value of  To improve readability, consider using the non-negated form exclusively to specify which code should be included. For example, using  to include the block when BOOTLOADER_TYPE is set to proved_block, and  to include the block when BOOTLOADER_TYPE is set to playground_block.  Update: Resolved in pull request #153 at commit 9b9d534.  Unintuitive Naming  In the bootloader contract, two occurrences of unintuitive variable naming were identified:  The naming of RESERVED_FREE_SLOTS is somewhat confusing, as it suggests that the slots are both reserved and free at the same time. In reality, the reserved slots may be free, but most of the slots will be pre-filled.  The terms txInnerDataOffset and innerTxDataOffset are both used for semantically similar parameters. This inconsistency in naming can be confusing and limit the ability to easily search for all occurrences.  Consider using more consistent and intuitive naming conventions for variables and terms in the codebase.  Update: Resolved in pull request #163 at commit 83931d4.  Unused Imports  In the BootloaderUtilities contract the  IBootloaderUtilities interface,  SystemContractHelper library, and  Constants file  are imported but never used.  Consider using or removing them.  Update: Resolved in pull request #154 at commit 26523a2. The IBootloaderUtilities interface is now used as part of the L-06 fix.  Unused Variable  The encodedChainId variable in the BootloaderUtilities contract is unused.  Similarly, in the bootloader contract the variables from and ergsLimit remain unused within the ZKSYNC_NEAR_CALL_validateTx function.  Consider removing these unused variables.  Update: Resolved in pull request #155 at commit bca9d68.  Conclusions  This is the third report of the engagement. The audit lasted for 4 weeks, during which we had the opportunity to work closely with the Matter Labs team. They were very responsive in answering our questions and provided us with extensive and dedicated documentation that was extremely useful.  The scope of the audit included the bootloader as well as three more layer 2 system contracts with corresponding interfaces and one library. The bootloader is a complex component that orchestrates various system contracts in order to execute layer 2 transactions and log them to layer 1. It is a unique piece of software and therefore very interesting to audit.  During the audit, we identified several issues, including one critical and two high severity issue, as well as a number of medium and lower severity issues. Overall, the audit was successful in identifying issues and providing recommendations for improvement.  Appendix  Monitoring Recommendations  While audits help in identifying code-level issues in the current implementation and potentially the code deployed in production, we encourage the Matter Labs team to consider incorporating monitoring activities in the production environment. To ensure the security of the project, we use both on-chain and node monitoring to identify potential threats and issues. With the goal of providing a comprehensive security assessment, we recommend the following measures:  On-Chain Monitoring  Critical: Monitor which addresses act as an EOA and trigger a warning when code is deployed on that address. In case this happens unwillingly, the incident could mean loss of power for that EOA by having a malicious contract acting on behalf of that user.  High: The implemented account abstraction allows the creation of custom accounts. Custom accounts may implement calls with the isSystem call flag set. This is a sensitive functionality which enables impersonation of the message sender through mimic calls. Unintentional usage of this flag could mean loss of funds through impersonation by a malicious party.  Node Monitoring  Low: The vmHook memory data of the bootloader can be leveraged by the node operator to check whether execution flow of the bootloader is as intended. Any violation to the control flow integrity could mean a compromise of the system.  Low: The bootloader is responsible for collecting transaction fees for the operator address. The operator can verify that the fees received on-chain match the fees defined in the raw transaction data received by the node. If there is a discrepancy, it could indicate a problem with the implementation of fee management.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#mismatch-between-interface-and-implementation", "labels": ["OpenZeppelin"]}, {"title": "Missing Interface for L2EthToken", "body": "Missing Interface for L2EthToken", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#missing-interface-for-l2ethtoken", "labels": ["OpenZeppelin"]}, {"title": "Imprecise Naming of Transaction Struct Elements", "body": "In the bootloader contract, inside of the validateTypedTxStructure function, it is stated that the first and second reserved slots of the transaction struct are used to store the nonce and value, respectively. These values are common to all types of transactions and could also be stored as explicit elements of the transaction struct.  To improve the code clarity, consider adding dedicated entries to the transaction struct for these common elements.  Update: Resolved in pull request #143 at commits af4c5b9 and cd55ab2.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#imprecise-naming-of-transaction-struct-elements", "labels": ["OpenZeppelin"]}, {"title": "TypeScript Constant Names Are Inconsistent", "body": "The bootloader contract includes constants that are defined in TypeScript code with the format , and are replaced with their actual values during compilation. These constants, which are often used for selectors, may or may not be padded with zeros. However, the names of these constants do not consistently indicate whether they have been padded or not, which is important for determining the memory layout in the bootloader.  To improve the clarity and consistency of the codebase, consider using consistent naming conventions for constants that indicate whether they have been padded or not.  Update: Resolved in pull request #144 at commit 8ca44a7.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#typescript-constant-names-are-inconsistent", "labels": ["OpenZeppelin"]}, {"title": "Unused Functions", "body": "The following internal functions are defined in the bootloader contract, but appear to be unused:  ETH_L2_TOKEN_ADDR  min  ETH_CALL_ERR_CODE  UNACCEPTABLE_ERGS_PRICE_ERR_CODE  TX_VALIDATION_FAILED_ERR_CODE  To improve the codebase, consider either using these functions or removing them. Removing unused functions can help to reduce clutter and make the code easier to understand.  Update: Resolved in pull request #145 at commit 316c54a. The Matter Labs team stated:  We removed all unused constants except _ERR_CODES, which are used in the server. We want to avoid any confusion when starting to use such error codes in bootloader.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#unused-functions", "labels": ["OpenZeppelin"]}, {"title": "Wrong EIP-712 Transaction Type Check", "body": "In the validateTypedTxStructure function of the bootloader, the EIP-712 txType is checked against 112, while it is supposed to be 113.  Following the execution flow, it can be seen in the getTransactionHashes function that a call reverts if the transaction type does not match one of 0, 1, 2, or 113. So for a transaction of type 113, the foreseen checks in the bootloader are skipped. This means the reserved slots can be arbitrary. However, no negative consequences were identified.  Consider correcting the transaction type check from 112 to 113. Further, consider implementing a default case and using the unused valid return variable to fail early if the transaction type does not match.  Update: Resolved in pull request #146 at commit c343256.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#wrong-eip-712-transaction-type-check", "labels": ["OpenZeppelin"]}, {"title": "Code Redundancy", "body": "BootloaderUtilities contract, different types of transactions are encoded and hashed. These transaction types share similarities in their encoding which leads to redundancy of code. For instance, both the legacy and EIP-2930 type transaction have the consecutively encoded fields  Consider moving some parts of the encoding into a function to reuse the code for both transaction types.  Update: Acknowledged, not resolved. The Matter Labs team stated:  Specifically in the specified places, we choose readability over performance.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#code-redundancy", "labels": ["OpenZeppelin"]}, {"title": "Commented-out Code", "body": "In the bootloader.yul file, the two constants in Solidity code format dummyAddress and BOOTLOADER_ADDRESS are commented out and seem obsolete.  Consider removing the commented-out code as well as the comments describing them.  Update: Resolved in pull request #147 at commit 7c344be.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#commented-out-code", "labels": ["OpenZeppelin"]}, {"title": "Extra Code", "body": "In the bootloader contract, the computation of a switch statement condition in the transaction processing includes unnecessary code that makes the code harder to read. The variables txType and isL1Tx are not used elsewhere in the function. Additionally, the FROM_L1_TX_TYPE variable appears to be a constant, but it is not declared as such.  To improve the clarity and readability of the code, consider simplifying the switch statement computation and properly declaring variables as constants if they are intended to be constant.  Update: Resolved in pull requests #148 and #158 at commits 613636f and cdc301f.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#extra-code", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Declaration of Constants", "body": "There is an inconsistency in the way constants are declared in the code, with some being declared as functions and others being declared as variables. This deviation from a consistent pattern can be confusing and make it difficult to understand the purpose and usage of these constants. The following constants are declared as variables:  TX_DESCRIPTION_SIZE  TXS_IN_BLOCK_LAST_PTR  Consider using a consistent method for declaring constants throughout the code as functions. This will improve the readability and understandability of the code and make it easier for others to work with it.  Update: Resolved in pull request #149 at commits c7042cd and fee4b5b.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#inconsistent-declaration-of-constants", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Declaration of Integers", "body": "In the bootloader contract, there is an inconsistency in the way memory offsets are declared in the codebase, with some being expressed in decimal and others being expressed in hexadecimal. This deviation from a consistent notation can be confusing and make it difficult to understand the purpose and usage of these sizes. For instance:  add(0x20, txDataOffset) in line 291  add(0x20, txDataOffset) in line 300  mstore(txDataOffset, 0x20) in line 431  add(txDataOffset, 0x20) in line 797  add(txDataOffset, 0x20) in line 1170  add(dataPtr, 0x20) in line 1400  Consider using a consistent notation for expressing memory offsets throughout the codebase.  Update: Resolved in pull request #150 at commit ecdbebd.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#inconsistent-declaration-of-integers", "labels": ["OpenZeppelin"]}, {"title": "Performance Optimization", "body": "In the bootloader contract, we have identified several opportunities for performance optimization:  In the validateTypedTxStructure function, when checking if the reservedDynamicLength value is not zero, consider loading the length from the getReservedDynamicPtr pointer directly to skip the lengthToWords computation.  In the callAccountMethod function, consider using the existing txDataOffset pointer instead of advancing the txDataWithHashesOffset a second time to save an add.  In the function call to executeL1Tx, consider propagating the given innerTxDataOffset instead of recalculating it in the function itself.  In the getFarCallAbi function, dataOffset and memoryPage are zero and could be skipped. Consider starting with the shifted dataStart value instead.  The executeL2Tx function is only called within the ZKSYNC_NEAR_CALL_executeL2Tx() function where the from transaction value is present. Consider propagating that from value to the executeL2Tx call instead of recomputing it.  Update: Partially resolved in pull request #151 at commit fe92113. The Matter Labs team stated:  Partially fixed, we decided to keep better readability over performance in a place where optimization is hard to implement or may confuse the reader. Also, please note that the compiler could do such an optimization, because we have an LLVM backend.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#performance-optimization", "labels": ["OpenZeppelin"]}, {"title": "TODOs Are Present in the Codebase", "body": "In the bootloader contract, there are incomplete implementations and missing functionality in the codebase, as indicated by the presence of TODO comments. This can make it difficult to understand the intended functionality and behavior of the code, and may also make it difficult to properly test and maintain the codebase. For instance:  make user pay for sending back the L1 message  (SMA-1220): refunds are not supported as of now  (SMA-1220): support refunds [\u2026]  Consider completing the implementations and addressing the missing functionality. This will improve the overall quality and reliability of the codebase and make it easier for others to work with it.  Update: Acknowledged, not resolved. The Matter Labs team stated:  The issue will be resolved in upcoming upgrades.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#todos-are-present-in-the-codebase", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "In the codebase the following typographical errors were identified:  shoud \u2192 should  Firsly \u2192 Firstly  succedes \u2192 succeeds  Reseting \u2192 Resetting  mainntet \u2192 mainnet  only one higher \u2192 only the first one above  again \u2192 against  Consider correcting these and any further issues.  Update: Resolved in pull request #152 at commits 9dd29e3 and 630625f.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unexpected Negation in Inclusion Logic", "body": "bootloader contract, the constant  line 1523, the inclusion of a block is determined by negating the value of  To improve readability, consider using the non-negated form exclusively to specify which code should be included. For example, using  to include the block when BOOTLOADER_TYPE is set to proved_block, and  to include the block when BOOTLOADER_TYPE is set to playground_block.  Update: Resolved in pull request #153 at commit 9b9d534.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#unexpected-negation-in-inclusion-logic", "labels": ["OpenZeppelin"]}, {"title": "Unintuitive Naming", "body": "In the bootloader contract, two occurrences of unintuitive variable naming were identified:  The naming of RESERVED_FREE_SLOTS is somewhat confusing, as it suggests that the slots are both reserved and free at the same time. In reality, the reserved slots may be free, but most of the slots will be pre-filled.  The terms txInnerDataOffset and innerTxDataOffset are both used for semantically similar parameters. This inconsistency in naming can be confusing and limit the ability to easily search for all occurrences.  Consider using more consistent and intuitive naming conventions for variables and terms in the codebase.  Update: Resolved in pull request #163 at commit 83931d4.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#unintuitive-naming", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "In the BootloaderUtilities contract the  IBootloaderUtilities interface,  SystemContractHelper library, and  Constants file  are imported but never used.  Consider using or removing them.  Update: Resolved in pull request #154 at commit 26523a2. The IBootloaderUtilities interface is now used as part of the L-06 fix.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused Variable", "body": "The encodedChainId variable in the BootloaderUtilities contract is unused.  Similarly, in the bootloader contract the variables from and ergsLimit remain unused within the ZKSYNC_NEAR_CALL_validateTx function.  Consider removing these unused variables.  Update: Resolved in pull request #155 at commit bca9d68.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#unused-variable", "labels": ["OpenZeppelin"]}, {"title": "Potential DoS in rebalance feature", "body": "BullStrategy relies on a rebalancing mechanism coded into the  AuctionBull contract to rebalance the strategys ETH exposure against the Crab strategy and/or Eulers loan. The rebalancing mechanism works with a special EOA, namely the  auctionManager that calls either the  fullRebalance or  leverageRebalance functions in the contract. In the case of a  The full rebalance works by collecting signed user bids off-chain, and then relaying them to be processed on-chain as orders. Despite orders being validated off-chain, by the time they are actually processed and included in a block there could be many ways in which individual orders fail during a rebalance. Some of them are:  Lack of allowance in tokens transfer: the user might have provided a valid approval first, but then revoked it by front running the rebalance transaction.  Lack of funds: the user might have no funds when submitting the order, or might have transferred them away after right before the rebalance transaction takes places.  Wrong signature (the ECDSA check might fail).  Wrong order on-chain (orders are not finally ordered from best to worst).  Very tight expiration set: the order might be expired by the time its confirmed in high gas price scenarios.  Sending a certain amount of WETH to the AuctionBull contract when depositing into Crab might cause the formula that calculates how much WETH is needed from Uniswap to revert, since it can become a negative number, thus forcing the rebalance to revert. This can be fixed by keeping an internal accounting of how much WETH the contract got from the traders orders instead of checking the entire contract balance.  Signing a lot of valid orders with a competitive price will force the rebalance transaction to use up a lot of gas since there are many safety checks involved and transfers of funds. An attacker can craft enough valid orders from different wallets and IPs in order to build up a list of orders so large that it will use more than the maximum gas per block (30M gas units at the time of writing). Consider ordering Orders not only by price, but also keeping in mind the order quantity.  There is no check of whether all the funds pulled from traders are enough to cover the entire rebalance. It is assumed so, and it eventually reverts at the very end when not enough funds can be pulled into the proper contract. Consider checking if a partial rebalance can be achieved with the pulled orders while still keeping acceptable CR and delta values.  If anyone forces ETH into the BullStrategy contract, it will be converted into WETH and transferred into AuctionBull when performing a full rebalance that needs to withdraw from Crab. Additionally, if Eulers current collateral is larger than the target collateral, it will sell the entire WETH balance for USDC in order to repay some debt. The same effect can be achieved by sending USDC to the AuctionBull contract directly. If its higher than Eulers debt, repayments will never be possible on full rebalances when withdrawing from Crab and repaying Eulers debt. It doesnt need to be that large of an amount though, since some USDC will be bought via Uniswap. Consider checking how much unexpected WETH balance AuctionBull has, or implementing a farm function that will allow the owner to sweep the extra WETH.  The borrow operation from Euler can fail if theres not enough USDC available for borrowing. A third party can temporarily borrow enough from the lending pool prior to the rebalance in order to make sure there will never be enough USDC to rebalance the strategy. Theres no way to recover from this, apart from waiting / depositing more collateral from another account in order to increase available USDC to borrow. A similar approach was used recently by an attacker on Aave.  Given the different possibilities of how a rebalance can be forced to revert, consider taking all of them into account for the off-chain orders selection and ordering algorithms, but also when it comes to doing safety checks and operations on-chain.  Also consider always using a private transaction relay service (such as FlashBots) to broadcast the rebalance transaction in order to avoid these potential attacks.  Update: Partially resolved in PR #789 by implementing a farm function that allows the contract owner to retrieve any asset balance from AuctionBull, and expanding the pre-existing farm function within BullStrategy so ETH, WETH and USDC can also be recovered by the owner if necessary.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#potential-dos-in-rebalance-feature", "labels": ["OpenZeppelin"]}, {"title": "Artificial asset balance inflation", "body": "All the contracts in scope are susceptible to an asset balance inflation attack, where a user might send ETH or any ERC20 token directly to the protocol contracts.  For ETH specifically, the only way to do so is by making use of an intermediate contract that uses selfdestruct to force funds directly into any protocol contract, bypassing the receive require statements in place.  farm function can recover stray ERC20 token balances (except the  excluded ones), but there is no general way to withdraw ETH. One interesting side effect from the rebalancing mechanism is that  wrapping the entire ETH balance into  transferring it out of  AuctionBull.  How this can be exploited by a malicious third party is unclear, since the team did not find any attack vector that could exploit that. However, heavily relying on the use of balanceOf(address(this)) in many instances across the codebase might pose some risk of an inflation attack.  Consider whether it is safe to leave the doors open for such scenarios and whether it is relevant to include some mitigations, such as implementing a less strict farm function to be used across all contracts, or having a restricted function to retrieve stuck ETH.  Update: Partially resolved in PR #789 by implementing a farm function that allows the contract owner to retrieve any asset balance from AuctionBull, and expanding the pre-existing farm function within BullStrategy so ETH, WETH and USDC can also be recovered by the owner if necessary.  However, the farm function within BullStrategy should be restricted when attempting to recover ETH if the Squeeth controller is shut down, since all user funds will be sitting in ETH during that time.  Low Severity", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#artificial-asset-balance-inflation", "labels": ["OpenZeppelin"]}, {"title": "Rebalances are subject to sandwich attacks", "body": "Rebalancing transactions are very meaningful events within the strategy lifecycle. Potentially large amounts of WETH and USDC might be involved, and given the necessary use of Uniswap V3 pools in any scenario (apart from OTC auctions) there are two potential scenarios in which placing a transaction before and after the rebalancing might be beneficial for a third party:  In the case of a third party willing to profit off the protocol, a wethLimitPrice is specified in both the leverageRebalance and fullRebalance. This value determines the maximum slippage for each swap, so special care should be placed on the calculation of this value and the tolerance parameters in order to avoid being sandwiched out of this slippage.  A rebalancing event inevitably carries some costs for all the strategy depositors due to slippage, price impact and spread. This cost will always be a percentage of the entire strategy portfolio value. Any investor within the strategy can sandwich the rebalance transaction in order to exit before it happens, and re-enter it immediately afterwards. The incurred cost of doing so might be much lower than the rebalancing costs, so if executed correctly, they would avoid that extra cost at the expense of the rest of the depositors. Consider adding some restrictions in the depositing and withdrawing frequency (i.e. an individual user cannot deposit and withdraw on the same block).  In both cases, consider if these are relevant risks and always relay the rebalancing transaction through a private relay like FlashBots in order to avoid undesired reverts due to DoS attacks, and unexpected losses in slippage due to sandwich attacks.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#rebalances-are-subject-to-sandwich-attacks", "labels": ["OpenZeppelin"]}, {"title": "Duplicated code", "body": "There are instances of duplicated code within the codebase. This can lead to issues later on in the development lifecycle, and leaves the project more prone to the introduction of errors. Errors can inadvertently be introduced when functionality changes are not replicated across all instances of code that should be identical. One example of duplicated code is the function _calcWsqueethToMintAndFee which is defined both in the FlashBull and AuctionBull contracts.  Instead of duplicating code, consider having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#duplicated-code", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "Throughout the codebase there are several parts that do not have docstrings. Some examples are:  Line 408 of the AuctionBull contract  Line 96 of the LeverageBull contract  Line 105 of the LeverageBull contract  Line 121 of the LeverageBull contract  Additionally, the AuctionBull NatSpec documentation is incorrect, since it is referencing the FlashBull contract instead.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in PR #775, PR #776, PR #818 and PR #822.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Missing error messages in require statements", "body": "Throughout the codebase there are require statements that lack error messages. For instance:  The require statement on line 202 of AuctionBull.sol  The require statement on line 126 of FlashBull.sol  Contrast this with the BullStrategys identical line 90 require statement, which includes an error message.  Consider including specific, informative error messages in all require statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied. This should also improve consistency across several contracts.  Update: Resolved in PR #776.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#missing-error-messages-in-require-statements", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed parameters", "body": "Throughout the codebase, events do not have their parameters indexed. Some examples are:  line 139 of the AuctionBull contract  line 54 of the BullStrategy contract  line 101 of the FlashBull contract  line 59 of the LeverageBull contract  Consider indexing event parameters to avoid hindering off-chain services searching and filtering for specific events.  Update: Resolved in PR #748.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#lack-of-indexed-parameters", "labels": ["OpenZeppelin"]}, {"title": "Outdated solidity versions", "body": "Throughout the codebase there are pragma statements that use an outdated version of Solidity. For instance:  The pragma statement on line 2 of the AuctionBull contract  The pragma statement on line 2 of the BullStrategy contract  The pragma statement on line 2 of the EmergencyShutdown contract  The pragma statement on line 2 of the FlashBull contract  The pragma statement on line 2 of the LeverageBull contract  Consider taking advantage of the latest Solidity version to improve the overall readability and security of the codebase.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#outdated-solidity-versions", "labels": ["OpenZeppelin"]}, {"title": "Unused function parameter", "body": "Within the AuctionBull contract at the _pushFundsFromOrders function, the _isDepositingInCrab parameter is not used.  To improve the overall clarity, intentionality, and readability of the codebase, consider removing any unused function parameters.  Update: Resolved in PR #779.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#unused-function-parameter", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "Throughout the codebase, imports on the following lines are unused and could be removed:  Line 10 of the EmergencyShutdown.sol contract  Line 10 of the FlashBull.sol contract  Line 5 of the IBullStrategy.sol contract (eventually consider if the defined interface should extend from the imported one)  Consider removing unused imports to avoid confusion that could reduce the overall clarity and readability of the codebase.  Update: Resolved in commit ab8226c.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent event emission parameters", "body": "Throughout the codebase, some inconsistencies were found regarding event emission parameters.  Events presenting an incorrect parameter ordering include:  The SetCap event has its old and new value parameters in a different order than the SetShutdownContract event. This causes the setShutdownContract function to emit the event with the parameters in the wrong order.  This different parameter ordering issue also occurs within AuctionBulls setAuctionManager event.  Consider emitting both events with the same parameter ordering for consistency, and to avoid hindering the task of off-chain event analysis.  Additionally, events missing important parameters include:  When using the flashDeposit and flashWithdraw functions, both the Deposit and Withdraw events are fired specifying msg.sender as the depositor, which will always resolve to the FlashBull contract address.  The specific events FlashDeposit and FlashWithdraw do not contain any information about the actual user performing the flash deposit / withdrawal.  Consider refactoring the event emission logic for deposits and withdrawals so that information is complete and accurate.  Update: Partially resolved in PR #785. The Opyn team updated the specified setter events to follow a consistent parameter ordering, and added a parameter to both the FlashDeposit and FlashWithdraw events to indicate the user who performed the action. However, both the Deposit and Withdraw events still do not contain information about the original user, since they will always emit the FlashBull contract address as the from and to parameters respectively.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#inconsistent-event-emission-parameters", "labels": ["OpenZeppelin"]}, {"title": "Not checking ERC20 transfers return parameter", "body": "In the LeverageBull contract, there are several calls to the EIP20 standard transfer and transferFrom. These calls return a bool parameter that is not checked. In the scenarios that the team explored, this is not a security issue since every token involved provides reverts in the code for failing transfers.  However, as new tokens may be integrated in the future, usage of this pattern could cause issues because new tokens could lack this reverting behavior.  Consider always using the SafeERC20 contract from OpenZeppelin to wrap for such calls, or evaluating the return parameter to be true.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#not-checking-erc20-transfers-return-parameter", "labels": ["OpenZeppelin"]}, {"title": "Unnamed return parameters", "body": "There are many occurrences in the codebase where returned parameters are not named. Some examples are:  In the _calcWsqueethToMintAndFee, _calcSharesToMint and _getCrabVaultDetails functions of the FlashBull contract  In the _getCurrentDeltaAndCollatRatio, getCurrentDeltaAndCollatRatio, _calcWPowerPerpAmountFromCrab and _calcWsqueethToMintAndFee functions of the AuctionBull contract  Consider adding and using named return parameters to improve explicitness and readability.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#unnamed-return-parameters", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission for sensitive actions", "body": "In contrast to the Crab Strategy, Bull Strategy withdrawals performed when Squeeth contracts have been shutdown do not emit events.  Consider emitting descriptive events in order to properly track these sensitive actions.  Update: Resolved in PR #748.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#lack-of-event-emission-for-sensitive-actions", "labels": ["OpenZeppelin"]}, {"title": "Misleading parameter passing", "body": "When depositing into the strategy directly with Crab tokens, there is a mixed use of the variables _crabAmount and bullToMint. The first one refers to the amount of Crab tokens being deposited, while the latter represents the amount of Bull tokens to be minted.  There are a few occurrences around the code where these two variables are used indistinctly:  When total Bull supply is zero, the variable passed to the _mint function is _crabAmount, when it should be bullToMint.  When calling _leverageDeposit, the documentation states that the second parameter should be the amount of Crab tokens being deposited, but the passed parameter is bullToMint.  Even though these variables might have the exact same value, using them indistinctly hinders readability and is error-prone. Consider using the appropriate variable each time.  Update: Resolved in PR #778.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#misleading-parameter-passing", "labels": ["OpenZeppelin"]}, {"title": "Inconsistency in quote currency setup", "body": "Upon LeverageBull construction, USDC is defined as a state variable that will hold the quoteCurrency for the debt component within Euler. Its address is fetched via calling the quoteCurrency function within the controller, but the decimals difference between WETH and USDC is hardcoded to be 12 as a constant.  Within the Controller contract, it is not assumed nor stated that the quote currency is USDC.  Consider dynamically fetching the number of decimals of the quote currency and calculating the decimals difference against WETH.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#inconsistency-in-quote-currency-setup", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent coding style", "body": "The codebase presents some code style inconsistencies.  _checkFullRebalanceClearingPrice function is using  _checkRebalanceLimitPrice function.  Consider using the same math functions for both situations.  Update: Resolved in PR #780.  Enum null values are used with a meaningful purpose  Throughout the codebase, every enum definition matches the value 0 to some meaningful state.  Some examples can be found within the AuctionBull and FlashBull contracts.  When a variable using those enums is not set, they will default to the null value, potentially causing confusion over whether it is an actual value or a null state.  Consider using NULL as the first enum state in order to avoid using a meaningful state on null values.  Gas optimizations  Notable gas cost improvements were found throughout the codebase. Some examples include:  Order struct is not efficiently packed.  When the auction contract performs a fullRebalance in order to withdraw ETH from Crab, oSQTH is bought from traders, pulled into AuctionBull and then pulled from BullStrategy, which in turn approves CrabStrategy to pull them. Finally, CrabStrategy ends up executing a transferFrom to get them. Trader funds could be pulled directly into CrabStrategy to get significant gas savings on auctions.  When performing a leverageRebalance, given isSellingUsdc = true, WETH tokens are transferred from the Uniswap pool into the AuctionBull contract, only to have them pulled from BullStrategy so they can be deposited within Euler.  Consider refactoring the code, so that intermediate transfers and approvals can be removed in order to get significant gas savings.  Update: Partially resolved in PR #744 by granting infinite approval for the relevant tokens on both FlashBull and BullStrategy constructors instead of on every individual deposit and withdrawal. Additionally, a small gas optimization was added in PR #743 to avoid repeating the same function call several times. Notice that each individual point above still applies. Moreover, having infinite allowances must be weighted against potential bugs introduced in the future that might take advantage of such approvals.  Typo in event parameter names  In both the TransferToOrder and TransferFromOrder events, the second parameter should be named quantity instead of quanity.  Update: Resolved in PR #748.  Conclusions  No high or critical vulnerabilities have been found. Even though the system presents complex integrations and a non-trivial design, we are happy to see robustness and prevention of small edge cases and scenarios. Given the overall complexity and the out-of-scope parts of the project, we wanted to explicitly highlight the sensitive out-of-scope parts of the system that need special attention. Finally, we appreciated that the project came with a comprehensive test suite, and that the team provided detailed and specific documentation.  Update: The team resolved the majority of the issues and refactored the code, additionally changing the name of some contracts. We recommend ensuring that the new changes are properly tested and that overall coverage is not affected.  Appendix  Monitoring Recommendations  BullStrategy is a complex trading strategy that needs periodic rebalancing. Since these rebalancing events are critical for the strategy to work as expected, we recommend the following sensitive actions to be monitored:  Monitor all restricted functions (functions only called by the multisig owner) to ensure that all actions are authorized by the team and that the values they set are in line with their expectations (especially those related to the emergency shutdown protocol).  Monitor the functions flashDeposit, deposit, flashWithdraw and withdraw for large deposits / withdrawals.  This can also be extended by all privileged roles actions, so that the community can always check for unexpected special actions.  The liquidity pools used by the project are normal Uniswap v3 pools, and the TWAP oracle is used to retrieve price data from them. Monitoring pool activities for abnormal behaviours might be useful for the team in order to prevent unwanted scenarios in high volatility or manipulation attempts.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#inconsistent-coding-style", "labels": ["OpenZeppelin"]}, {"title": "Enum null values are used with a meaningful purpose", "body": "Enum null values are used with a meaningful purpose", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#enum-null-values-are-used-with-a-meaningful-purpose", "labels": ["OpenZeppelin"]}, {"title": "Gas optimizations", "body": "Notable gas cost improvements were found throughout the codebase. Some examples include:  Order struct is not efficiently packed.  When the auction contract performs a fullRebalance in order to withdraw ETH from Crab, oSQTH is bought from traders, pulled into AuctionBull and then pulled from BullStrategy, which in turn approves CrabStrategy to pull them. Finally, CrabStrategy ends up executing a transferFrom to get them. Trader funds could be pulled directly into CrabStrategy to get significant gas savings on auctions.  When performing a leverageRebalance, given isSellingUsdc = true, WETH tokens are transferred from the Uniswap pool into the AuctionBull contract, only to have them pulled from BullStrategy so they can be deposited within Euler.  Consider refactoring the code, so that intermediate transfers and approvals can be removed in order to get significant gas savings.  Update: Partially resolved in PR #744 by granting infinite approval for the relevant tokens on both FlashBull and BullStrategy constructors instead of on every individual deposit and withdrawal. Additionally, a small gas optimization was added in PR #743 to avoid repeating the same function call several times. Notice that each individual point above still applies. Moreover, having infinite allowances must be weighted against potential bugs introduced in the future that might take advantage of such approvals.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Typo in event parameter names", "body": "In both the TransferToOrder and TransferFromOrder events, the second parameter should be named quantity instead of quanity.  Update: Resolved in PR #748.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#typo-in-event-parameter-names", "labels": ["OpenZeppelin"]}, {"title": "Funds held in ETHAdapter can be drained by anyone", "body": "Funds held in ETHAdapter can be drained by anyone", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#funds-held-in-ethadapter-can-be-drained-by-anyone", "labels": ["OpenZeppelin"]}, {"title": "Incorrect assetsOf calculation", "body": "Incorrect assetsOf calculation", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#incorrect-assetsof-calculation", "labels": ["OpenZeppelin"]}, {"title": "Incorrect recalculation of shares during deposit", "body": "When a user deposits to the STETHVault, the amount of shares they are expected to receive is recalculated after stETH is transferred from the depositor to the vault. Since the vaults idle assets have not yet been updated, the transferred stETH is incorrectly included in the conversion calculation. This may cause the spentCap to be incorrectly updated and the Deposit event to emit a smaller value of shares than what will actually be issued when the deposit is processed.  totalIdleAssets decrement and _restoreCap logic in the  refund function in  Update: Resolved in PR#118, with commit db0c86daa2d52d1f92e59ae852cade40be351b82 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#incorrect-recalculation-of-shares-during-deposit", "labels": ["OpenZeppelin"]}, {"title": "Negative rebase of stETH could prevent a round from ending", "body": "When a round ends, the amount of underlying assets currently in the vault is subtracted from the amount of assets the vault contained in the previous round. This calculation assumes a positive yield, but the underlying asset stETH is able to rebase in both a positive and negative direction due to the potential for slashing. In the case where Lido is slashed, totalAssets can be less than lastRoundAssets. Consequently, the subtraction would cause an underflow, which would prevent the controller from being able to end the round until totalAssets is greater than lastRoundAssets.  Consider placing the logic that calculates and transfers any investment yield generated by the vault in an if statement that only occurs when totalAssets is greater than lastRoundAssets. This allows any yield generated from the options strategy to still be transferred to the vault and prevents the accrued interest arithmetic from reverting.  Update: Resolved in PR#100, with commit a756b4d8ead7fce109e9daf51c218eb952454487 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#negative-rebase-of-steth-could-prevent-a-round-from-ending", "labels": ["OpenZeppelin"]}, {"title": "Non-standard ERC-4626 vault functionality", "body": "There are multiple locations in the ERC-4626 BaseVault that do not conform to ERC-4626 specifications:  previewWithdraw does not include withdrawal fees  maxDeposit does not return 0 when deposits are disabled  maxMint does not return 0 when withdrawals are disabled  maxWithdraw does not return 0 when withdrawals are disabled  Consider correcting the above issues to meet the ERC-4626 specifications, allowing future vault developers to expect certain protocol behaviors.  Update: Partially resolved in PR#132, with commit 87e7de33e0a7a699263624641305a8e06ec178b2 being the last one added. The issues regarding maxDeposit, maxMint, maxWithdraw and maxRedeem have been resolved and these functions now return 0 when deposits or withdrawals are disabled. The previewWithdraw function does not include withdrawal fees. However, we note that there is ambiguity in how fees on withdrawal should be implemented according to EIP-4626, and that previewWithdraw does return the correct number of shares that would be burned in a withdraw call. Docstrings have been added to previewWithdraw and withdraw to inform integrators of the presence of withdrawal fees.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#non-standard-erc-4626-vault-functionality", "labels": ["OpenZeppelin"]}, {"title": "Phantom permit functions callable from child vault", "body": "BaseVault implements a  mintWithPermit and  depositWithPermit function, even though the vaults underlying asset is intended to be  stETH, which does not have a  STETHVault to explicitly revert when called. In the  fallback function. However, this both provides a potentially inaccurate error message and is subject to different behavior if the stETH contract undergoes an upgrade. Further, tokens containing  phantom permit functions are known to exist, which would not revert on failure. Setting a precedent of explicitly reverting when calling unsupported  Update: Resolved in PR#123, with commit fd3ca22cedc414f9e6f5fbed34ad725ca509bff2 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#phantom-permit-functions-callable-from-child-vault", "labels": ["OpenZeppelin"]}, {"title": "Refunds will be over-credited in a negative yield event", "body": "Deposits added to the queue are point-in-time stETH balance amounts. The stETH token rebases to account for yield, and in the event of slashing, may be subject to a negative yield. In the event that a stETH token rebase is negative between the time a user deposits and calls for a refund, the vault will over credit the user by the rebase difference.  Consider handling the deposits in the queue in stETH share amounts to account for rebase changes on refunds.  Update: Acknowledged, not resolved. Pods Finance team stated:  Although we agree with the issue, we wont prioritize it right now. It would require us to implement a secondary share queue system that would require few parts of the code to change. We will prioritize this issue in a future version.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#refunds-will-be-over-credited-in-a-negative-yield-event", "labels": ["OpenZeppelin"]}, {"title": "Vault can be placed back into vulnerable low supply state", "body": "The BaseVault contract inherits an issue common to ERC-4626 implementations known as the donation attack. When shares are minted to users, they are calculated by multiplying the deposited assets by a ratio of the existing shares to current assets. The result of this calculation is then rounded down, following the ERC specifications. The problem arises when the value of totalAssets is manipulated to induce unfavorable rounding for new users depositing into the vault at the benefit of users who already own shares of the vault. Since totalAssets is calculated using the balance of underlying assets, it can be manipulated via direct transfers or donations of stETH to the vault. The most extreme example of this attack could occur when a user is the first to enter the vault, because when supply is sufficiently low, the capital requirement to perform an economically beneficial donation attack is also low.  The Pods Finance team is aware of this issue and has taken measures to make the attack more difficult to execute, such as by creating a minimum initial deposit requirement. While this does successfully enforce a minimum initial deposit for the first round, it does not prevent the total supply of shares from falling below the safety threshold throughout the life of the vault. For example, if an early user put forth the minimum initial deposit and then the rest of the queue held dust amounts, the same user could withdraw far below the minimum initial deposit amount in the next round and the vault would be back in a vulnerable state.  Consider taking steps to ensure the supply of vault shares does not go below the minimum initial deposit amount. One way to do this would be for the Pods Finance team to contribute their own initial deposit to the vault that they can guarantee will not be withdrawn. Discussions around other techniques used to protect from this attack can be seen in issue 3706 of the openzeppelin-contracts repository.  Update: Acknowledged, will resolve. Pods Finance team stated:  Pods Finance will follow the recommendations and will contribute their own initial deposit to the vault that they can guarantee will not be withdrawn.  Low Severity", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#vault-can-be-placed-back-into-vulnerable-low-supply-state", "labels": ["OpenZeppelin"]}, {"title": "Magic numbers are used", "body": "Although constants are generally used correctly throughout the codebase, there are a few occurrences of literal values being used with unexplained meaning inside of ETHAdapter. For example, the following blocks use hardcoded values:  In the constructor, the pools coins function is called with arguments 0 and 1.  In the functions convertToETH and convertToSTETH, the pools get_dy function is called with arguments 0 and 1 with no explanation.  In the deposit function, the pools exchange function is called with arguments 0 and 1 without explanation.  To improve the codes readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. Consider adding an inline comment explaining how the magic numbers are calculated or why they are chosen for complex values.  Update: Resolved in PR#103, with commit 87e7de33e0a7a699263624641305a8e06ec178b2 being the last one added.  Misplaced totalAssets function implementation  STETHVault contract implementation, the  totalAssets function is overridden and updated in order to account for the assets that have been transferred to the vault contract but have not  been processed yet. However, the accounting for idle assets within a vault is primarily implemented in the  BaseVault contract. Consequently, if a vault were to inherit the  default implementation of  Consider moving the implementation of totalAssets to the BaseVault contract. totalAssets can additionally be marked virtual so contracts that inherit BaseVault can optionally choose to implement their own functionality.  Update: Resolved in PR#117, with commit 2a82f1126c14c713b19a08cdf32690e52bb4c43d being the last one added.  Missing docstrings  Throughout the codebase, there are several parts that do not have docstrings. For instance:  Line 5 in IConfigurationManager  Lines 11-28 in IConfigurationManager  Line 5 in ICurvePool  Lines 12-19 in ICurvePool  Line 8 in IVault  Line 5 in CastUint  Line 7 in Capped  Line 11 in ETHAdapter  Line 28 in ETHAdapter  Line 32 in ETHAdapter  Line 40 in ETHAdapter  Line 52 in ETHAdapter  Line 66 in ETHAdapter  Line 77 in ETHAdapter  Line 91 in ETHAdapter  Line 11 in Migration  Line 26 in Migration  Line 47 in Migration  This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security but also correctness. Additionally, docstrings improve readability and maintenance.  Consider thoroughly inserting documentation above each contract, interface, library, function, state variable, event, and custom error. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in PR#122, with commit 32df444b20be010b5f1da7f42a69fcbeec61fdda being the last one added.  Missing ConfigurationManager check during vault initialization  constructor in the  state variable is set. However, there is no check to ensure the passed-in  VAULT_CONTROLLER parameter set for the vault contract that is being created. Having the  Consider adding a check in the constructor of the BaseVault contract to ensure calling getParameter with the address of the vault being created, and VAULT_CONTROLLER does not return the zero address.  Update: Acknowledged, not resolved. Pods Finance team stated:  Instead of enforcing it at the code level, that would require us to deploy the vault using CREATE2 in order to know in advance the vault address, we will monitor the VAULT_CONTROLLER variable to make sure that it was set after the deploy.  Share price calculations should never result in a zero value  The share price represents the amount of stETH needed to mint one vault share. When the number of vault shares that has been minted thus far is zero, the share price should simply be the ratio of the underlying assets decimals to the vaults decimals. There were multiple share price calculations in the STETHVault contract that incorrectly returned zero in this scenario:  the lastSharePrice instantiation in the _afterRoundStart function  the currentSharePrice calculation in the _afterRoundStart function  the lack of endSharePrice calculation when supply is zero in the _afterRoundEnd function  the startSharePrice calculation in the _afterRoundEnd function  convertToAssets function that is inherited from OpenZeppelins  ERC-4626 contract instead of the manual calculations, as it contains logic to handle this edge case. Additionally, when instantiating  Update: Resolved in PR#109, with commit 88e0b18fa497ce86194ab5ac8b9cc346ecfb3b75 being the last one added.  The sharePrice function should not revert  sharePrice function in the  calculates the amount of stETH needed in order to mint one vault share. However, the calculation does not take into account that  Consider calling convertToAssets(10**sharePriceDecimals) in the sharePrice function instead of using the manual calculation, as convertToAssets handles the zero shares edge case.  Update: Resolved in PR#104, with commit 9264f9dc5a5676da381dc6e86768971ffd5415d8 being the last one added.  spentCap can be skewed due to rebasing tokens  Capped contract that is used to indicate how many shares have been minted. This variable is first updated when a user  deposits. However, shares are not issued for a user until their deposit has been  processed. The share conversion rate is subject to change during that time-frame due to stETH being a rebasing token. Therefore, when  _restoreCap is called during a withdraw, the number of shares accounted for in  Consider adding spentCap to the ConfigurationManager as a parameter, and updating calculations in Capped to add and subtract to that value instead of using a local state variable. This would allow the owner of the ConfigurationManager contract to adjust spentCap if the skew becomes too large.  Update: Acknowledged, not resolved. Pods Finance team stated:  The cap is a temporary feature. As of now, it is possible to workaround this issue and increase the cap through the ConfigurationManager if needed.  Use of deprecated function for setting token allowances  Throughout the codebase there were multiple locations where the deprecated safeApprove function was used to set allowances:  Line 352 in BaseVault  Line 35 in Migration  Line 57 in Migration  Line 43 in ETHAdapter  Line 112 in ETHAdapter  If in any of these locations an allowance is carried over for more than the duration of a transaction, safeApprove may revert in subsequent transactions. Consider replacing the instances of safeApprove with the recommended safeIncreaseAllowance or safeDecreaseAllowance instead.  Update: Resolved in PR#105, with commit 7e6bdbcb3d1fff657c81810750521fa0278e4a07 being the last one added.  Notes & Additional Information  Inconsistent use of named return variables  Named return variables are a way to declare variables that are meant to be used inside a function body and returned at the end of the function. This is an alternative to the explicit return statement to provide function outputs.  Throughout the codebase, there are instances of inconsistent use of named return variables:  The deposit function in ETHAdapter has a named return variable declared that is not used.  The startRound function in IVault declares a named return variable, while its implementation in BaseVault does not.  The handleMigration function in IVault declares a named return variable, while its implementation in BaseVault does not.  Consider improving consistency and either using or removing any unused named return variables.  Update: Resolved in PR#110, with commit f2459432bbdc423c15c501cd277d72ae4fdefd70 being the last one added.  Inflexible initial deposit  The current minimum initial deposit is defined as 10**decimals of the underlying token. This strategy may be inflexible for certain edge-case tokens. For example, a vault that has an underlying asset of wBTC would require an initial deposit of $16,600 at todays market price. Additionally, if a vault were to have an underlying asset with very few decimals, it is possible that the capital requirement intended to prevent a donation attack may be insufficient.  If the Pods Finance team ever intends to offer vaults with wBTC or other edge case tokens as underlying assets, consider allowing the minimum initial deposit to be configurable at deployment.  Update: Acknowledged, not resolved. Pods Finance team stated:  As stated above, Pods Finance will contribute their own initial deposit to the vault that they can guarantee will not be withdrawn. Depositing one whole wBTC wont be a problem. For the small decimals tokens, Pods Finance team will deposit an initial deposit bigger than the minimum.  Lack of indexed parameters  The VaultAllowanceSet event in IConigurationManager does not have the newVault parameter indexed.  Consider indexing event parameters to avoid hindering the task of off-chain services searching and filtering for specific events.  Update: Resolved in PR#105, with commit 7e6bdbcb3d1fff657c81810750521fa0278e4a07 being the last one added.  Lack of zero address checks  Throughout the codebase, there are several functions where the zero address could be passed as an argument but is not explicitly checked:  migrate function in BaseVault.sol  migrate function in Migration.sol  migrateWithPermit function in Migration.sol  setVaultMigration function in ConfigurationManager.sol  Zero address checks prevent operations from potentially occurring on the zero address, and allows developers to return clear error messages instead of having a function fail in a less-obvious way.  Consider adding zero address checks to the above functions.  Update: Resolved in PR#124 and PR#129, with commits bb7be233253bb96589486cc700a9889f716e34a1 and 771aa5bf7453405d91310035be65eab698ccfdb1 being the last ones added.  Mismatched event parameters  Multiple event definitions contain uint256 parameters for roundId, but the value emitted is a uint32:  RoundStarted in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  RoundEnded in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  DepositProcessed in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  DepositRefunded in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  For clearer code and potential gas savings, consider aligning variable types within event definitions and event emissions.  Update: Resolved in PR#113, with commit 135c912b843b64937f9eb4069e1c0fc8b312cd80 being the last one added.  Non-explicit imports are used  Non-explicit imports are used inside the codebase, which reduces code readability and could lead to conflicts between the names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Within ConfigurationManager, global imports are being used. For instance:  Line 5 in ConfigurationManager  Line 6 in ConfigurationManager  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Resolved in PR#102, with commit b059e07c90ae62b4a37ffd596ba05bcd997a16b8 being the last one added.  Use of uint32 for round timestamp limits vault lifetime  rounds end by placing the current  can begin. When  Consider expanding the round timestamp to a uint40 or larger to drastically increase the shelf life of the BaseVault.  Update: Resolved in PR#107, with commit d26b0ee274f4cec28fad2a9f0df3e340ee8fc887 being the last one added.  Conclusions  No critical or high severity issues were found in this second audit. Several medium severity issues were discovered, many of which stemmed from complications related to directly integrating with the rebasable stETH token. Overall, the codebase shows a marked improvement from the first audit. The Pods Finance team was able to leverage pre-existing OpenZeppelin contract implementations and other libraries as part of their fixes for the first audit, which helped reduce the attack surface of their contracts. Additional recommendations have been proposed to further reduce the attack surface of the contracts.  Appendix  Monitoring Recommendation  While audits help in identifying code-level issues in the current implementation and potentially the code deployed to production, we encourage the Pods Finance team to consider incorporating monitoring activities in the production environment. Ongoing monitoring of deployed contracts helps in identifying potential threats and issues that may affect the protocol. With the goal of providing a complete security assessment, we want to raise several actions addressing trust assumptions and out-of-scope components that may benefit from on-chain monitoring:  Minimum balance invariant of the stETHvv contract: consider monitoring the underlying balance of stETH in the vault contract to ensure it is always greater than or equal to the MIN_INITIAL_ASSETS balance. This can be done on a per-block basis by checking the stETH balance of the vault at a previous block number with the stETH balance of the vault at the most recent block number.  Low liquidity in the ETH/stETH Curve pool: consider monitoring the liquidity in the ETH/stETH Curve pool to ensure that the ETHAdapter contract does not encounter a situation where exchanges are failing or large slippage is occurring due to low liquidity in the corresponding Curve pool.  Negative rebase event of stETH due to the potential for Lido to be slashed: consider monitoring the balance of stETH in the stETHvv contract along with Withdraw, EndRoundData, and DepositRefunded events. The respective events indicate when stETH is transferred from the vault. If the balance of the contract were to decrease not as a direct result of any of the aforementioned events, it could be an indication of a negative stETH rebase event.  Privileged role activities such as those performed by the Owner of the ConfigurationManager contract, the controller of the vault, and the investor of the vault: consider monitoring events related, but not limited to, ownership changes, vault configuration modifications, and transfers initiated by the investor address to somewhere other than the vault as these may signal private key compromise of a privileged role.  Additionally, the team may wish to explore options for monitoring Lido node status so that they may be able to predict if a negative stETH rebase will occur in the near future.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#magic-numbers-are-used", "labels": ["OpenZeppelin"]}, {"title": "Misplaced totalAssets function implementation", "body": "Misplaced totalAssets function implementation", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#misplaced-totalassets-function-implementation", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings. For instance:  Line 5 in IConfigurationManager  Lines 11-28 in IConfigurationManager  Line 5 in ICurvePool  Lines 12-19 in ICurvePool  Line 8 in IVault  Line 5 in CastUint  Line 7 in Capped  Line 11 in ETHAdapter  Line 28 in ETHAdapter  Line 32 in ETHAdapter  Line 40 in ETHAdapter  Line 52 in ETHAdapter  Line 66 in ETHAdapter  Line 77 in ETHAdapter  Line 91 in ETHAdapter  Line 11 in Migration  Line 26 in Migration  Line 47 in Migration  This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security but also correctness. Additionally, docstrings improve readability and maintenance.  Consider thoroughly inserting documentation above each contract, interface, library, function, state variable, event, and custom error. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in PR#122, with commit 32df444b20be010b5f1da7f42a69fcbeec61fdda being the last one added.  Missing ConfigurationManager check during vault initialization  constructor in the  state variable is set. However, there is no check to ensure the passed-in  VAULT_CONTROLLER parameter set for the vault contract that is being created. Having the  Consider adding a check in the constructor of the BaseVault contract to ensure calling getParameter with the address of the vault being created, and VAULT_CONTROLLER does not return the zero address.  Update: Acknowledged, not resolved. Pods Finance team stated:  Instead of enforcing it at the code level, that would require us to deploy the vault using CREATE2 in order to know in advance the vault address, we will monitor the VAULT_CONTROLLER variable to make sure that it was set after the deploy.  Share price calculations should never result in a zero value  The share price represents the amount of stETH needed to mint one vault share. When the number of vault shares that has been minted thus far is zero, the share price should simply be the ratio of the underlying assets decimals to the vaults decimals. There were multiple share price calculations in the STETHVault contract that incorrectly returned zero in this scenario:  the lastSharePrice instantiation in the _afterRoundStart function  the currentSharePrice calculation in the _afterRoundStart function  the lack of endSharePrice calculation when supply is zero in the _afterRoundEnd function  the startSharePrice calculation in the _afterRoundEnd function  convertToAssets function that is inherited from OpenZeppelins  ERC-4626 contract instead of the manual calculations, as it contains logic to handle this edge case. Additionally, when instantiating  Update: Resolved in PR#109, with commit 88e0b18fa497ce86194ab5ac8b9cc346ecfb3b75 being the last one added.  The sharePrice function should not revert  sharePrice function in the  calculates the amount of stETH needed in order to mint one vault share. However, the calculation does not take into account that  Consider calling convertToAssets(10**sharePriceDecimals) in the sharePrice function instead of using the manual calculation, as convertToAssets handles the zero shares edge case.  Update: Resolved in PR#104, with commit 9264f9dc5a5676da381dc6e86768971ffd5415d8 being the last one added.  spentCap can be skewed due to rebasing tokens  Capped contract that is used to indicate how many shares have been minted. This variable is first updated when a user  deposits. However, shares are not issued for a user until their deposit has been  processed. The share conversion rate is subject to change during that time-frame due to stETH being a rebasing token. Therefore, when  _restoreCap is called during a withdraw, the number of shares accounted for in  Consider adding spentCap to the ConfigurationManager as a parameter, and updating calculations in Capped to add and subtract to that value instead of using a local state variable. This would allow the owner of the ConfigurationManager contract to adjust spentCap if the skew becomes too large.  Update: Acknowledged, not resolved. Pods Finance team stated:  The cap is a temporary feature. As of now, it is possible to workaround this issue and increase the cap through the ConfigurationManager if needed.  Use of deprecated function for setting token allowances  Throughout the codebase there were multiple locations where the deprecated safeApprove function was used to set allowances:  Line 352 in BaseVault  Line 35 in Migration  Line 57 in Migration  Line 43 in ETHAdapter  Line 112 in ETHAdapter  If in any of these locations an allowance is carried over for more than the duration of a transaction, safeApprove may revert in subsequent transactions. Consider replacing the instances of safeApprove with the recommended safeIncreaseAllowance or safeDecreaseAllowance instead.  Update: Resolved in PR#105, with commit 7e6bdbcb3d1fff657c81810750521fa0278e4a07 being the last one added.  Notes & Additional Information  Inconsistent use of named return variables  Named return variables are a way to declare variables that are meant to be used inside a function body and returned at the end of the function. This is an alternative to the explicit return statement to provide function outputs.  Throughout the codebase, there are instances of inconsistent use of named return variables:  The deposit function in ETHAdapter has a named return variable declared that is not used.  The startRound function in IVault declares a named return variable, while its implementation in BaseVault does not.  The handleMigration function in IVault declares a named return variable, while its implementation in BaseVault does not.  Consider improving consistency and either using or removing any unused named return variables.  Update: Resolved in PR#110, with commit f2459432bbdc423c15c501cd277d72ae4fdefd70 being the last one added.  Inflexible initial deposit  The current minimum initial deposit is defined as 10**decimals of the underlying token. This strategy may be inflexible for certain edge-case tokens. For example, a vault that has an underlying asset of wBTC would require an initial deposit of $16,600 at todays market price. Additionally, if a vault were to have an underlying asset with very few decimals, it is possible that the capital requirement intended to prevent a donation attack may be insufficient.  If the Pods Finance team ever intends to offer vaults with wBTC or other edge case tokens as underlying assets, consider allowing the minimum initial deposit to be configurable at deployment.  Update: Acknowledged, not resolved. Pods Finance team stated:  As stated above, Pods Finance will contribute their own initial deposit to the vault that they can guarantee will not be withdrawn. Depositing one whole wBTC wont be a problem. For the small decimals tokens, Pods Finance team will deposit an initial deposit bigger than the minimum.  Lack of indexed parameters  The VaultAllowanceSet event in IConigurationManager does not have the newVault parameter indexed.  Consider indexing event parameters to avoid hindering the task of off-chain services searching and filtering for specific events.  Update: Resolved in PR#105, with commit 7e6bdbcb3d1fff657c81810750521fa0278e4a07 being the last one added.  Lack of zero address checks  Throughout the codebase, there are several functions where the zero address could be passed as an argument but is not explicitly checked:  migrate function in BaseVault.sol  migrate function in Migration.sol  migrateWithPermit function in Migration.sol  setVaultMigration function in ConfigurationManager.sol  Zero address checks prevent operations from potentially occurring on the zero address, and allows developers to return clear error messages instead of having a function fail in a less-obvious way.  Consider adding zero address checks to the above functions.  Update: Resolved in PR#124 and PR#129, with commits bb7be233253bb96589486cc700a9889f716e34a1 and 771aa5bf7453405d91310035be65eab698ccfdb1 being the last ones added.  Mismatched event parameters  Multiple event definitions contain uint256 parameters for roundId, but the value emitted is a uint32:  RoundStarted in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  RoundEnded in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  DepositProcessed in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  DepositRefunded in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  For clearer code and potential gas savings, consider aligning variable types within event definitions and event emissions.  Update: Resolved in PR#113, with commit 135c912b843b64937f9eb4069e1c0fc8b312cd80 being the last one added.  Non-explicit imports are used  Non-explicit imports are used inside the codebase, which reduces code readability and could lead to conflicts between the names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Within ConfigurationManager, global imports are being used. For instance:  Line 5 in ConfigurationManager  Line 6 in ConfigurationManager  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Resolved in PR#102, with commit b059e07c90ae62b4a37ffd596ba05bcd997a16b8 being the last one added.  Use of uint32 for round timestamp limits vault lifetime  rounds end by placing the current  can begin. When  Consider expanding the round timestamp to a uint40 or larger to drastically increase the shelf life of the BaseVault.  Update: Resolved in PR#107, with commit d26b0ee274f4cec28fad2a9f0df3e340ee8fc887 being the last one added.  Conclusions  No critical or high severity issues were found in this second audit. Several medium severity issues were discovered, many of which stemmed from complications related to directly integrating with the rebasable stETH token. Overall, the codebase shows a marked improvement from the first audit. The Pods Finance team was able to leverage pre-existing OpenZeppelin contract implementations and other libraries as part of their fixes for the first audit, which helped reduce the attack surface of their contracts. Additional recommendations have been proposed to further reduce the attack surface of the contracts.  Appendix  Monitoring Recommendation  While audits help in identifying code-level issues in the current implementation and potentially the code deployed to production, we encourage the Pods Finance team to consider incorporating monitoring activities in the production environment. Ongoing monitoring of deployed contracts helps in identifying potential threats and issues that may affect the protocol. With the goal of providing a complete security assessment, we want to raise several actions addressing trust assumptions and out-of-scope components that may benefit from on-chain monitoring:  Minimum balance invariant of the stETHvv contract: consider monitoring the underlying balance of stETH in the vault contract to ensure it is always greater than or equal to the MIN_INITIAL_ASSETS balance. This can be done on a per-block basis by checking the stETH balance of the vault at a previous block number with the stETH balance of the vault at the most recent block number.  Low liquidity in the ETH/stETH Curve pool: consider monitoring the liquidity in the ETH/stETH Curve pool to ensure that the ETHAdapter contract does not encounter a situation where exchanges are failing or large slippage is occurring due to low liquidity in the corresponding Curve pool.  Negative rebase event of stETH due to the potential for Lido to be slashed: consider monitoring the balance of stETH in the stETHvv contract along with Withdraw, EndRoundData, and DepositRefunded events. The respective events indicate when stETH is transferred from the vault. If the balance of the contract were to decrease not as a direct result of any of the aforementioned events, it could be an indication of a negative stETH rebase event.  Privileged role activities such as those performed by the Owner of the ConfigurationManager contract, the controller of the vault, and the investor of the vault: consider monitoring events related, but not limited to, ownership changes, vault configuration modifications, and transfers initiated by the investor address to somewhere other than the vault as these may signal private key compromise of a privileged role.  Additionally, the team may wish to explore options for monitoring Lido node status so that they may be able to predict if a negative stETH rebase will occur in the near future.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Missing ConfigurationManager check during vault initialization", "body": "Missing ConfigurationManager check during vault initialization", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#missing-configurationmanager-check-during-vault-initialization", "labels": ["OpenZeppelin"]}, {"title": "Share price calculations should never result in a zero value", "body": "The share price represents the amount of stETH needed to mint one vault share. When the number of vault shares that has been minted thus far is zero, the share price should simply be the ratio of the underlying assets decimals to the vaults decimals. There were multiple share price calculations in the STETHVault contract that incorrectly returned zero in this scenario:  the lastSharePrice instantiation in the _afterRoundStart function  the currentSharePrice calculation in the _afterRoundStart function  the lack of endSharePrice calculation when supply is zero in the _afterRoundEnd function  the startSharePrice calculation in the _afterRoundEnd function  convertToAssets function that is inherited from OpenZeppelins  ERC-4626 contract instead of the manual calculations, as it contains logic to handle this edge case. Additionally, when instantiating  Update: Resolved in PR#109, with commit 88e0b18fa497ce86194ab5ac8b9cc346ecfb3b75 being the last one added.  The sharePrice function should not revert  sharePrice function in the  calculates the amount of stETH needed in order to mint one vault share. However, the calculation does not take into account that  Consider calling convertToAssets(10**sharePriceDecimals) in the sharePrice function instead of using the manual calculation, as convertToAssets handles the zero shares edge case.  Update: Resolved in PR#104, with commit 9264f9dc5a5676da381dc6e86768971ffd5415d8 being the last one added.  spentCap can be skewed due to rebasing tokens  Capped contract that is used to indicate how many shares have been minted. This variable is first updated when a user  deposits. However, shares are not issued for a user until their deposit has been  processed. The share conversion rate is subject to change during that time-frame due to stETH being a rebasing token. Therefore, when  _restoreCap is called during a withdraw, the number of shares accounted for in  Consider adding spentCap to the ConfigurationManager as a parameter, and updating calculations in Capped to add and subtract to that value instead of using a local state variable. This would allow the owner of the ConfigurationManager contract to adjust spentCap if the skew becomes too large.  Update: Acknowledged, not resolved. Pods Finance team stated:  The cap is a temporary feature. As of now, it is possible to workaround this issue and increase the cap through the ConfigurationManager if needed.  Use of deprecated function for setting token allowances  Throughout the codebase there were multiple locations where the deprecated safeApprove function was used to set allowances:  Line 352 in BaseVault  Line 35 in Migration  Line 57 in Migration  Line 43 in ETHAdapter  Line 112 in ETHAdapter  If in any of these locations an allowance is carried over for more than the duration of a transaction, safeApprove may revert in subsequent transactions. Consider replacing the instances of safeApprove with the recommended safeIncreaseAllowance or safeDecreaseAllowance instead.  Update: Resolved in PR#105, with commit 7e6bdbcb3d1fff657c81810750521fa0278e4a07 being the last one added.  Notes & Additional Information  Inconsistent use of named return variables  Named return variables are a way to declare variables that are meant to be used inside a function body and returned at the end of the function. This is an alternative to the explicit return statement to provide function outputs.  Throughout the codebase, there are instances of inconsistent use of named return variables:  The deposit function in ETHAdapter has a named return variable declared that is not used.  The startRound function in IVault declares a named return variable, while its implementation in BaseVault does not.  The handleMigration function in IVault declares a named return variable, while its implementation in BaseVault does not.  Consider improving consistency and either using or removing any unused named return variables.  Update: Resolved in PR#110, with commit f2459432bbdc423c15c501cd277d72ae4fdefd70 being the last one added.  Inflexible initial deposit  The current minimum initial deposit is defined as 10**decimals of the underlying token. This strategy may be inflexible for certain edge-case tokens. For example, a vault that has an underlying asset of wBTC would require an initial deposit of $16,600 at todays market price. Additionally, if a vault were to have an underlying asset with very few decimals, it is possible that the capital requirement intended to prevent a donation attack may be insufficient.  If the Pods Finance team ever intends to offer vaults with wBTC or other edge case tokens as underlying assets, consider allowing the minimum initial deposit to be configurable at deployment.  Update: Acknowledged, not resolved. Pods Finance team stated:  As stated above, Pods Finance will contribute their own initial deposit to the vault that they can guarantee will not be withdrawn. Depositing one whole wBTC wont be a problem. For the small decimals tokens, Pods Finance team will deposit an initial deposit bigger than the minimum.  Lack of indexed parameters  The VaultAllowanceSet event in IConigurationManager does not have the newVault parameter indexed.  Consider indexing event parameters to avoid hindering the task of off-chain services searching and filtering for specific events.  Update: Resolved in PR#105, with commit 7e6bdbcb3d1fff657c81810750521fa0278e4a07 being the last one added.  Lack of zero address checks  Throughout the codebase, there are several functions where the zero address could be passed as an argument but is not explicitly checked:  migrate function in BaseVault.sol  migrate function in Migration.sol  migrateWithPermit function in Migration.sol  setVaultMigration function in ConfigurationManager.sol  Zero address checks prevent operations from potentially occurring on the zero address, and allows developers to return clear error messages instead of having a function fail in a less-obvious way.  Consider adding zero address checks to the above functions.  Update: Resolved in PR#124 and PR#129, with commits bb7be233253bb96589486cc700a9889f716e34a1 and 771aa5bf7453405d91310035be65eab698ccfdb1 being the last ones added.  Mismatched event parameters  Multiple event definitions contain uint256 parameters for roundId, but the value emitted is a uint32:  RoundStarted in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  RoundEnded in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  DepositProcessed in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  DepositRefunded in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  For clearer code and potential gas savings, consider aligning variable types within event definitions and event emissions.  Update: Resolved in PR#113, with commit 135c912b843b64937f9eb4069e1c0fc8b312cd80 being the last one added.  Non-explicit imports are used  Non-explicit imports are used inside the codebase, which reduces code readability and could lead to conflicts between the names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Within ConfigurationManager, global imports are being used. For instance:  Line 5 in ConfigurationManager  Line 6 in ConfigurationManager  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Resolved in PR#102, with commit b059e07c90ae62b4a37ffd596ba05bcd997a16b8 being the last one added.  Use of uint32 for round timestamp limits vault lifetime  rounds end by placing the current  can begin. When  Consider expanding the round timestamp to a uint40 or larger to drastically increase the shelf life of the BaseVault.  Update: Resolved in PR#107, with commit d26b0ee274f4cec28fad2a9f0df3e340ee8fc887 being the last one added.  Conclusions  No critical or high severity issues were found in this second audit. Several medium severity issues were discovered, many of which stemmed from complications related to directly integrating with the rebasable stETH token. Overall, the codebase shows a marked improvement from the first audit. The Pods Finance team was able to leverage pre-existing OpenZeppelin contract implementations and other libraries as part of their fixes for the first audit, which helped reduce the attack surface of their contracts. Additional recommendations have been proposed to further reduce the attack surface of the contracts.  Appendix  Monitoring Recommendation  While audits help in identifying code-level issues in the current implementation and potentially the code deployed to production, we encourage the Pods Finance team to consider incorporating monitoring activities in the production environment. Ongoing monitoring of deployed contracts helps in identifying potential threats and issues that may affect the protocol. With the goal of providing a complete security assessment, we want to raise several actions addressing trust assumptions and out-of-scope components that may benefit from on-chain monitoring:  Minimum balance invariant of the stETHvv contract: consider monitoring the underlying balance of stETH in the vault contract to ensure it is always greater than or equal to the MIN_INITIAL_ASSETS balance. This can be done on a per-block basis by checking the stETH balance of the vault at a previous block number with the stETH balance of the vault at the most recent block number.  Low liquidity in the ETH/stETH Curve pool: consider monitoring the liquidity in the ETH/stETH Curve pool to ensure that the ETHAdapter contract does not encounter a situation where exchanges are failing or large slippage is occurring due to low liquidity in the corresponding Curve pool.  Negative rebase event of stETH due to the potential for Lido to be slashed: consider monitoring the balance of stETH in the stETHvv contract along with Withdraw, EndRoundData, and DepositRefunded events. The respective events indicate when stETH is transferred from the vault. If the balance of the contract were to decrease not as a direct result of any of the aforementioned events, it could be an indication of a negative stETH rebase event.  Privileged role activities such as those performed by the Owner of the ConfigurationManager contract, the controller of the vault, and the investor of the vault: consider monitoring events related, but not limited to, ownership changes, vault configuration modifications, and transfers initiated by the investor address to somewhere other than the vault as these may signal private key compromise of a privileged role.  Additionally, the team may wish to explore options for monitoring Lido node status so that they may be able to predict if a negative stETH rebase will occur in the near future.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#share-price-calculations-should-never-result-in-a-zero-value", "labels": ["OpenZeppelin"]}, {"title": "The sharePrice function should not revert", "body": "The sharePrice function should not revert", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#the-shareprice-function-should-not-revert", "labels": ["OpenZeppelin"]}, {"title": "spentCap can be skewed due to rebasing tokens", "body": "spentCap can be skewed due to rebasing tokens", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#spentcap-can-be-skewed-due-to-rebasing-tokens", "labels": ["OpenZeppelin"]}, {"title": "Use of deprecated function for setting token allowances", "body": "Throughout the codebase there were multiple locations where the deprecated safeApprove function was used to set allowances:  Line 352 in BaseVault  Line 35 in Migration  Line 57 in Migration  Line 43 in ETHAdapter  Line 112 in ETHAdapter  If in any of these locations an allowance is carried over for more than the duration of a transaction, safeApprove may revert in subsequent transactions. Consider replacing the instances of safeApprove with the recommended safeIncreaseAllowance or safeDecreaseAllowance instead.  Update: Resolved in PR#105, with commit 7e6bdbcb3d1fff657c81810750521fa0278e4a07 being the last one added.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#use-of-deprecated-function-for-setting-token-allowances", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent use of named return variables", "body": "Named return variables are a way to declare variables that are meant to be used inside a function body and returned at the end of the function. This is an alternative to the explicit return statement to provide function outputs.  Throughout the codebase, there are instances of inconsistent use of named return variables:  The deposit function in ETHAdapter has a named return variable declared that is not used.  The startRound function in IVault declares a named return variable, while its implementation in BaseVault does not.  The handleMigration function in IVault declares a named return variable, while its implementation in BaseVault does not.  Consider improving consistency and either using or removing any unused named return variables.  Update: Resolved in PR#110, with commit f2459432bbdc423c15c501cd277d72ae4fdefd70 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#inconsistent-use-of-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Inflexible initial deposit", "body": "The current minimum initial deposit is defined as 10**decimals of the underlying token. This strategy may be inflexible for certain edge-case tokens. For example, a vault that has an underlying asset of wBTC would require an initial deposit of $16,600 at todays market price. Additionally, if a vault were to have an underlying asset with very few decimals, it is possible that the capital requirement intended to prevent a donation attack may be insufficient.  If the Pods Finance team ever intends to offer vaults with wBTC or other edge case tokens as underlying assets, consider allowing the minimum initial deposit to be configurable at deployment.  Update: Acknowledged, not resolved. Pods Finance team stated:  As stated above, Pods Finance will contribute their own initial deposit to the vault that they can guarantee will not be withdrawn. Depositing one whole wBTC wont be a problem. For the small decimals tokens, Pods Finance team will deposit an initial deposit bigger than the minimum.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#inflexible-initial-deposit", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed parameters", "body": "The VaultAllowanceSet event in IConigurationManager does not have the newVault parameter indexed.  Consider indexing event parameters to avoid hindering the task of off-chain services searching and filtering for specific events.  Update: Resolved in PR#105, with commit 7e6bdbcb3d1fff657c81810750521fa0278e4a07 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#lack-of-indexed-parameters", "labels": ["OpenZeppelin"]}, {"title": "Lack of zero address checks", "body": "Throughout the codebase, there are several functions where the zero address could be passed as an argument but is not explicitly checked:  migrate function in BaseVault.sol  migrate function in Migration.sol  migrateWithPermit function in Migration.sol  setVaultMigration function in ConfigurationManager.sol  Zero address checks prevent operations from potentially occurring on the zero address, and allows developers to return clear error messages instead of having a function fail in a less-obvious way.  Consider adding zero address checks to the above functions.  Update: Resolved in PR#124 and PR#129, with commits bb7be233253bb96589486cc700a9889f716e34a1 and 771aa5bf7453405d91310035be65eab698ccfdb1 being the last ones added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#lack-of-zero-address-checks", "labels": ["OpenZeppelin"]}, {"title": "Mismatched event parameters", "body": "Multiple event definitions contain uint256 parameters for roundId, but the value emitted is a uint32:  RoundStarted in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  RoundEnded in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  DepositProcessed in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  DepositRefunded in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  For clearer code and potential gas savings, consider aligning variable types within event definitions and event emissions.  Update: Resolved in PR#113, with commit 135c912b843b64937f9eb4069e1c0fc8b312cd80 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#mismatched-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit imports are used", "body": "inside the codebase, which reduces code readability and could lead to conflicts between the names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Within ConfigurationManager, global imports are being used. For instance:  Line 5 in ConfigurationManager  Line 6 in ConfigurationManager  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Resolved in PR#102, with commit b059e07c90ae62b4a37ffd596ba05bcd997a16b8 being the last one added.  Use of uint32 for round timestamp limits vault lifetime  rounds end by placing the current  can begin. When  Consider expanding the round timestamp to a uint40 or larger to drastically increase the shelf life of the BaseVault.  Update: Resolved in PR#107, with commit d26b0ee274f4cec28fad2a9f0df3e340ee8fc887 being the last one added.  Conclusions  No critical or high severity issues were found in this second audit. Several medium severity issues were discovered, many of which stemmed from complications related to directly integrating with the rebasable stETH token. Overall, the codebase shows a marked improvement from the first audit. The Pods Finance team was able to leverage pre-existing OpenZeppelin contract implementations and other libraries as part of their fixes for the first audit, which helped reduce the attack surface of their contracts. Additional recommendations have been proposed to further reduce the attack surface of the contracts.  Appendix  Monitoring Recommendation  While audits help in identifying code-level issues in the current implementation and potentially the code deployed to production, we encourage the Pods Finance team to consider incorporating monitoring activities in the production environment. Ongoing monitoring of deployed contracts helps in identifying potential threats and issues that may affect the protocol. With the goal of providing a complete security assessment, we want to raise several actions addressing trust assumptions and out-of-scope components that may benefit from on-chain monitoring:  Minimum balance invariant of the stETHvv contract: consider monitoring the underlying balance of stETH in the vault contract to ensure it is always greater than or equal to the MIN_INITIAL_ASSETS balance. This can be done on a per-block basis by checking the stETH balance of the vault at a previous block number with the stETH balance of the vault at the most recent block number.  Low liquidity in the ETH/stETH Curve pool: consider monitoring the liquidity in the ETH/stETH Curve pool to ensure that the ETHAdapter contract does not encounter a situation where exchanges are failing or large slippage is occurring due to low liquidity in the corresponding Curve pool.  Negative rebase event of stETH due to the potential for Lido to be slashed: consider monitoring the balance of stETH in the stETHvv contract along with Withdraw, EndRoundData, and DepositRefunded events. The respective events indicate when stETH is transferred from the vault. If the balance of the contract were to decrease not as a direct result of any of the aforementioned events, it could be an indication of a negative stETH rebase event.  Privileged role activities such as those performed by the Owner of the ConfigurationManager contract, the controller of the vault, and the investor of the vault: consider monitoring events related, but not limited to, ownership changes, vault configuration modifications, and transfers initiated by the investor address to somewhere other than the vault as these may signal private key compromise of a privileged role.  Additionally, the team may wish to explore options for monitoring Lido node status so that they may be able to predict if a negative stETH rebase will occur in the near future.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Use of uint32 for round timestamp limits vault lifetime", "body": "Use of uint32 for round timestamp limits vault lifetime", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#use-of-uint32-for-round-timestamp-limits-vault-lifetime", "labels": ["OpenZeppelin"]}, {"title": "DepositQueue can become permanently locked", "body": "STETHVault, they first join a  DepositQueue. While being part of the  refund their deposit or wait until the round ends for their deposit to be  processed. Both of these actions will then call the underlying  remove function in order to restructure the  The issue is that the remove function performs gas-intensive operations that drastically limit the upper bound on the queue size, which we conservatively estimate to be in the magnitude of a few thousands. With a large enough queue, any transaction attempting to refund or process even a single deposit will exceed the block gas limit of 30,000,000 gas. This could occur due to organic user growth, or a malicious actor may choose to send dust amounts of stETH to the vault from different addresses to take up positions in the queue. Without the ability to process or refund users, all current and future deposits made to the vault would be locked in the DepositQueue.  Consider accounting for the gas usage of all queue operations and ensuring they cannot reasonably exceed the block gas limit. Some recommendations to consider:  Refactor the DepositQueue so that operations such as remove can be performed in significantly less (and preferably constant) gas  Introduce a maximum capacity to the DepositQueue size to guarantee it can be processed each round  Apply a minimum investment requirement to deter attackers from spamming the queue with dust amounts of stETH  Use a different data structure for the DepositQueue, such as an EnumerableMap, to reduce code maintenance overhead and ensure necessary operations can be performed in constant gas  Update: Fixed in commit e05f165.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#depositqueue-can-become-permanently-locked", "labels": ["OpenZeppelin"]}, {"title": "Miscounted assets breaking system invariants", "body": "When processing queued deposits, the amount of assets that have been processed are accounted for in the processedDeposits variable and used to calculate the amount of shares to be minted. This variable is reset to 0 at the beginning of each round.  removed from  totalAssets. When the queue is processed the next time, the  totalAssets value already contains the amount of assets processed during the round. By  adding the processedDeposits to the totalAssets again, the previously processed amount is double counted, which leads to an incorrect calculation for the amount of shares minted to the next depositor in the queue.  This penalizes depositors by minting fewer shares if they are not included in the first call of the processQueuedDeposits function. This issue is particularly severe if each deposit is processed individually. Hence it breaks the system invariant that the number of splits should not modify the result when processing the deposits.  Additionally, this means users not processed in the first round may receive fewer assets than they deposited when they redeem their shares. This breaks another important system invariant that 100% withdrawal in stETH should always be equal to or higher than the initial deposit amount.  Consider correcting the total asset calculation to ensure the processed amount is accounted for accurately.  Update: Fixed in PR#54, with commit 3ad9b76 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#miscounted-assets-breaking-system-invariants", "labels": ["OpenZeppelin"]}, {"title": "The vault can be drained one share at a time", "body": "During the withdrawal process, users can specify the amount of assets to withdraw, which is then rounded down to shares.  When the asset amount specified by the user is less than the minimum amount that can be converted to a unit share, the shares argument is zero in the internal withdraw function but the assets argument is not. Hence, with zero shares, all internal calls can succeed and a non-zero amount of asset token will be transferred out to the receiver without burning any shares. This process can be repeated many times to drain the entire vault. The attack can also be executed with any asset amount by burning a rounded-down amount of shares and extracting the excess assets.  Since the vault is expected to become more valuable over time due to its yield strategy, this could lead to a profitable attack when one share is worth more than the cost.  Consider rounding up the shares for a given amount of assets during withdrawal.  Update: Fixed in PR#46, with commit 5ac5e3c being the last one added.  High Severity  Function withdraw can disable endRound  endRound() function any time after a round starts to remove a portion of the accrued interest from the vault to the  _afterRoundEnd hook, the  _beforeWithdraw() hook, where the withdrawn shares are rounded down to the corresponding asset value, which is subsequently subtracted from the  This may cause the lastRoundAssets to be more than the totalAssets() when a user calls the withdraw function. This can result in a revert due to underflow. In such a case, the controller cannot end a round and must wait for the accrued interest to accumulate enough value.  Consider keeping track of the withdrawn asset directly. Also, consider making sure the key system functionality is not impeded by users actions.  Update: Fixed in PR#73, with commit b258ca9 being the last one added.  Reentrancy risk in depositing to the queue  The internal _deposit function handles user deposits, transferring a specified amount of stETH from msg.sender to the vault. Before moving the funds, it adds the deposit to the queue, which is processed later by the processQueuedDeposits function.  As the underlying token could have hooks that allow the token sender to execute code before the transfer (e.g., ERC777 standard), a malicious user could use those hooks to re-enter the deposit function multiple times.  This re-entrancy will result in an increment in the receiver balance on the queue, even though this balance will not correspond to the actual amount deposited into the vault.  In the current implementation, the _deposit function in the BaseVault contract is overridden by the implementation in the STETHVault, which has the correct order of operation. However, the BaseVault is likely to be inherited by future vaults, so it is crucial to have the correct _deposit implementation in this contract in case it is not overridden.  Consider reordering the calls, doing the transfer first, and then adding the receiver to the queue to prevent this reentrancy scenario. Also, consider using OpenZeppelins ERC4626 implementation, which already has this solution implemented.  Update: Fixed in PR#41, with commit 2ffcb1e being the last one added.  Rounding up in minting shares  When processing the queued deposits, shares are minted to the receiver in the queue according to the amount of assets deposited. However, the amount of shares minted is always rounded up. This means that one can always receive 1 vault share with a 1-wei deposit.  As the vault is expected to be increasing in value from yield rewards, 1 vault share will be worth more than 1 wei asset eventually. A malicious user can spam the deposit queue with 1-wei deposit from many accounts to get 1 share each and then redeem them for more assets when each share is worth more.  Consider rounding down when minting vault shares.  Update: Fixed in PR#46, with commit 5ac5e3c being the last one added.  Medium Severity  Non-existent permit function  mintWithPermit and  depositWithPermit function intended to allow users to transfer assets to the vault in a single transaction. However, the vaults underlying asset is intended to be  stETH which does not have a  fallback function.  Consider removing the mintWithPermit and depositWithPermit functions. We note that wstETH does have a permit function for future considerations.  Update: Acknowledged, and will not fix. Pods Finance teams statement for this issue:  We decided not to fix this issue because we may implement assets similar to LIDO as the yield source where they may have permit functionality (aTokens, for instance).  Funds held in ETHAdapter can be drained by anyone  ETHAdapter contract is used as a proxy to allow users to interact with the vault through sending and receiving ETH instead of stETH. The adapter achieves this by converting ETH and stETH through a curve pool and then forwarding interactions to and from the vault. In the course of a normal  withdrawal or  redemption transaction, the  converts all of its stETH to ETH, and then sends its entire ETH balance to the receiving address.  The issue is that the ETHAdapter sends its full balance to the receiver each time, meaning any ETH or stETH that is mistakenly sent to it can be drained by any user who performs a withdrawal or redemption on the ETHAdapter. This is exacerbated by the fact that the vault is passed in as a parameter, potentially allowing a user to perform withdrawals and redemptions without interacting with the actual stETH vault.  Consider transferring out the exchanged balance from the curve pool to the receiver instead of the entire balance of the ETHAdapter. Also consider implementing a rescue or sweep function to allow the recovery of funds that are accidentally sent to the ETHAdapter.  Update: Acknowledged, will not fix. Pods Finance teams statement:  For now, we do not want to take action in case of funds sends by mistake to our contract. We see this as a low-priority issue.  Incorrect calculations  We found the following instances of incorrect calculations in view functions that are not currently called internally:  In the previewWithdraw function, the DENOMINATOR over invertedFee is always bigger than 1 when the fee is non-zero. Hence, the final returned shares are always an overestimate. Further, the withdrawFeeRatio is multiplied to shares instead of assets as in other instances such as _getFee. Consider correcting the withdrawal fee calculation.  The calculation in the assetsOf function over-estimates the actual commitment by an additional committedAssets. Consider removing the extra component.  Update: Partially fixed in commit 6d37029 in PR#75. previewWithdraw does not include fees as stated in the EIP.  Math library is vulnerable to shadow overflow  The AuxMath library is a custom auxiliary math library that performs multiplication and division with rounding specifications.  mulDivUp and  mulDivDown first compute the multiplication of a  current implementation will not give the right result in such a case.  Consider using OpenZeppelins Math library which implements the mulDiv function that is developed especially considering these scenarios and is widely accepted in the ecosystem.  Update: Fixed in commit 2a8c58a.  Maximum mintable and depositable amounts returned are incorrect  availableCap. Similarly, the  maxMint and  maxDeposit functions do not account for the  EIP4626 standard, these functions must return the real amount that can be minted or deposited.  Consider changing the maxMint and maxDeposit functions to return a value that accounts for the availableCap.  Update: Fixed in PR#42, with commit 3159de5 being the last one added.  Refund does not restore the cap  When a user deposits into the vault by joining the deposit queue, the corresponding shares, yet to be minted, are deducted from the spending cap immediately. The spending cap is restored only at withdrawal when the shares are burned.  If one user decides to use the refund function to leave the queue before the round ends, the spending cap will not be restored. When the cap is not zero, a malicious user with a sufficiently large amount of assets could repeatedly deposit and refund to reach the cap limit and stop other eligible users from joining the queue.  Note that the spendCap variable cannot be manually restored, but the owner can reset the cap to a higher value to unlock the deposit.  Consider accounting for the available cap during refunds from the queue.  Update: Fixed in commit 4a2e475.  Refund can be over-credited in a negative yield event  Deposits added to the queue are point in time stETH balance amounts. The stETH token balance rebases regularly to account for yield, and in the event of slashing, may be subject to a negative yield. In the event that a stETH token rebase is negative between the time a user deposits and calls for a refund, the vault will over credit the user by the rebase difference.  Consider handling the deposits in the queue in shares instead of balances to account for rebase changes on refunds.  Update: Acknowledged, will not fix. Pods Finance teams statement:  Although we agree with the issue, we wont prioritize it right now because of timing. In case of a slashing event, we can refund the vault, transferring funds directly to the contract.  Parallel share cap setting  The configuration manager determines the maximum vault shares available for minting. When setting a new cap through the setCap function, the target contract address is checked for the zero address, and a SetCap event is emitted.  However, the underlying setParameter function can be called directly to change the maximum vault shares available. This will bypass the zero address check and emit a ParameterSet event instead of the expected SetCap event.  Consider ensuring consistency between the two mechanisms in setting the share cap. Depending on the desired outcome, this could involve removing the setParameter function and adding individual get and set functions for all necessary configuration parameters.  Update: Fixed in commit cbe61d0.  Low Severity  Gas inefficiencies  There are many instances throughout the codebase where changes can be made to improve gas consumption. For example:  public functions might consume more gas than external functions. This is because with public functions, the EVM copies inputs (especially dynamic-sized arrays) into memory, while it reads from calldata if the function is external, which is cheaper. Throughout the codebase there are public functions like mintWithPermit, convertToSTETH, convertToETH, decimals, symbol, name and assetsOf that might be declared as external. Consider reviewing the entire codebase for more instances.  The function toAddress has a conditional statement that returns the zero address if the value passed is equal to zero. This additional check increases the gas consumption and does not add any benefit even if the provided value is equal to zero.  Initializing a variable to its default value causes unnecessary gas expense. Consider correcting such instances in processedDeposits, isProcessingDeposits, roundAccruedInterest, endSharePrice and the while loop counter inside the remove function.  The for loop inside the refund function does not cache the result of depositQueue.size() and perform unnecessary operations on each iteration. The same issue occurs in the last while loop of the remove function.  Performing calculations for values that will not change is suboptimal. Some examples are: name, symbol and the operation 10**sharePriceDecimals.  Use shorter string messages for required statements or switch entirely to a custom errors implementation to save on deployment cost and failed execution gas cost.  When performing these changes, aim to reach an optimal tradeoff between gas optimization and readability. Having a codebase that is easy to understand reduces the chance of future errors and improves community transparency.  Update: Partially fixed in PR#81, with commit 6f1bb8e being the last one added.  Inconsistent name and symbol  BaseVault, passed to the  STETHVault implementation. All vaults that use the same underlying asset and inherit from  hashedName when calculating the domain separator by the  EIP712 standard. Although this does not represent a risk, it is  recommended that the name sent to the  Also, the name and symbol defined in the BaseVault constructor are inconsistently overridden in the STETHVault implementation.  To avoid complications and improve code clarity, consider passing both the name and symbol from the STETHVault contract as parameters to maintain consistency. This also saves calculating the name and symbol at every call, thus saving more gas.  Update: Fixed in commit 61a9996.  Misleading comments  Comments are meant to be helpful and describe the intent of the code block. However, in multiple parts of the codebase, comments are not consistent with the code that is written or do not add any value to the reader. These are some examples:  The function _deposit in both the STETHVault and BaseVault contracts does not create any shares even though the comments say so.  The description of each parameter on setParameter, getParameter and getGlobalParameter does not add any value to the reader.  The target parameter on setParameter has a wrong description.  The function _spendCap has the same description as availableCap.  Consider correcting the comments to not mislead users or developers and write comments that add value to the reader. This will improve code clarity and consistency between docstrings and contract implementations.  Update: Fixed in commit 3ad59d0.  Missing docstrings  Throughout the codebase, there are several files that do not have docstrings. For instance:  The ConfigurationManager contract has no docstrings for any of its state variables.  The IConfigurationManager interface does not have any docstrings.  Although the ICurvePool interface is for an external contract, docstrings need to be added to explain the interface purpose and why each function is used within the codebase.  The IERC4626 interface has no docstrings for the interface description and also for any of its events.  The IVault interface has no docstrings for the interface description and also for any of its events and errors.  The AuxMath library does not have any docstrings.  The CastUint library has no docstrings for the library description.  The DepositQueueLib library just has some inline comments inside the remove function.  The Capped contract has no docstrings for the contract description, state variables, constructor, and its custom error.  The ETHAdapter contract just has some inline comments for the receive function.  The Migration contract does not have any docstrings.  The BaseVault contract has no docstrings for some of its state variables (configuration, _asset, currentRoundId, isProcessingDeposits, EMERGENCY_INTERVAL, processedDeposits, _lastEndRound and depositQueue), the constructor, and the functions depositWithPermit and mintWithPermit.  The STETHVault contract has no docstrings for some of its state variables (sharePriceDecimals, lastRoundAssets, lastSharePrice, and investor) and the constructor. Adding comments in the internal function _afterRoundEnd can be beneficial for easy understanding of its purpose.  This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security but also correctness. Additionally, docstrings improve readability and easy maintenance.  Consider thoroughly inserting documentation above each contract, interface, library, function, state variable, event, and custom errors. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.  Processing order alters queue indexes  Any user may process deposits in the queue after a round ends. After deposits are processed, the section of the queue they were held in is removed. This means that any user who processes deposits will be changing the size and indexes of the queue for all others. This may lead to reverted transactions if an index that was previously thought to be in range no longer exists in the queue. It may also lead to some processing of unintended indexes and others missing their targeted indexes in the queue.  Consider having additional validations on the queue size and indexes to ensure the correct transactions are executed without going out of bounds.  Update: Fixed in commit e05f165.  Refunds are subject to high gas costs and a potential DoS  Refunds are processed by searching the entire queue front to back for a users position. Currently, the gas price to refund increases linearly based on the users position in the queue. Users that have joined the queue later in the round will incur a more significant gas penalty and, in an extreme case, could be prevented from refunding.  Consider keeping track of a users queue position alongside other attributes for easier retrieval and update.  Update: Fixed in commit e05f165.  Remove function does not revert if startIndex is greater than or equal to endIndex  The remove function is responsible for removing records from the queue. When called, it checks if the endIndex is greater than the startIndex to execute the functions implementation. The issue is that if the condition is not met, the transaction is not reverted, and the code execution continues. This could cause processQueuedDeposits to fail silently when the indexes are not valid.  Although it does not currently cause any errors other than spending gas unnecessarily, consider rolling back the transaction if the condition is met to avoid unwanted behaviors.  Update: Fixed in commit e05f165.  Migration risks  The system allows users to migrate their shares to a new vault with the same underlying asset. There are a few risks regarding the current migration mechanism design.  Unclear migration path: Currently, two migration mechanisms exist. A user can either call the migrate function in the old vault or through the exclusive Migration contract. There is no clarity on which route is preferred as both essentially perform the same functionality. Consider removing duplicate actions that can lead to user confusion.  Incomplete migration: In both migration routes, users first redeem their shares from the old vault and then re-deposit the assets into the new vault. If the queueing system works the same way in the new vault, this only lets the user join the deposit queue. Hence the migration is not complete until the queued deposits are processed with the shares minted. Consider documenting this to make it clear to users who migrate.  Migration re-usability: The Migration contract sets both the old vault and the new vault addresses as immutable variables in the constructor. This limits its use case to one single migration. It would not be reusable across multiple vaults with the same underlying assets and different investment strategies.  Not robust against trapped funds: When assets are present in the Migration contract due to direct transfers or mistaken withdrawals, the entire balance of the contract will be deposited to the new vault by the next user. This design is not resistant to genuine user mistakes and prohibits recovering user funds. Consider using the returned value from the redeem function to migrate the correct amount of assets and establishing a sweep or rescue function for funds locked in the contract.  Update: Partially fixed in commit d97672d.  Unnecessarily complex code  The investmentYield and the investmentAmount are transferred back and forth from the vault to the same investor account. Instead of making two separate transactions, one can compare the two values and reach the final balance in one", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#the-vault-can-be-drained-one-share-at-a-time", "labels": ["OpenZeppelin"]}, {"title": "Function withdraw can disable endRound", "body": "Function withdraw can disable endRound", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#function-withdraw-can-disable-endround", "labels": ["OpenZeppelin"]}, {"title": "Reentrancy risk in depositing to the queue", "body": "The internal _deposit function handles user deposits, transferring a specified amount of stETH from msg.sender to the vault. Before moving the funds, it adds the deposit to the queue, which is processed later by the processQueuedDeposits function.  As the underlying token could have hooks that allow the token sender to execute code before the transfer (e.g., ERC777 standard), a malicious user could use those hooks to re-enter the deposit function multiple times.  This re-entrancy will result in an increment in the receiver balance on the queue, even though this balance will not correspond to the actual amount deposited into the vault.  In the current implementation, the _deposit function in the BaseVault contract is overridden by the implementation in the STETHVault, which has the correct order of operation. However, the BaseVault is likely to be inherited by future vaults, so it is crucial to have the correct _deposit implementation in this contract in case it is not overridden.  Consider reordering the calls, doing the transfer first, and then adding the receiver to the queue to prevent this reentrancy scenario. Also, consider using OpenZeppelins ERC4626 implementation, which already has this solution implemented.  Update: Fixed in PR#41, with commit 2ffcb1e being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#reentrancy-risk-in-depositing-to-the-queue", "labels": ["OpenZeppelin"]}, {"title": "Rounding up in minting shares", "body": "When processing the queued deposits, shares are minted to the receiver in the queue according to the amount of assets deposited. However, the amount of shares minted is always rounded up. This means that one can always receive 1 vault share with a 1-wei deposit.  As the vault is expected to be increasing in value from yield rewards, 1 vault share will be worth more than 1 wei asset eventually. A malicious user can spam the deposit queue with 1-wei deposit from many accounts to get 1 share each and then redeem them for more assets when each share is worth more.  Consider rounding down when minting vault shares.  Update: Fixed in PR#46, with commit 5ac5e3c being the last one added.  Medium Severity", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#rounding-up-in-minting-shares", "labels": ["OpenZeppelin"]}, {"title": "Non-existent permit function", "body": "mintWithPermit and  depositWithPermit function intended to allow users to transfer assets to the vault in a single transaction. However, the vaults underlying asset is intended to be  stETH which does not have a  fallback function.  Consider removing the mintWithPermit and depositWithPermit functions. We note that wstETH does have a permit function for future considerations.  Update: Acknowledged, and will not fix. Pods Finance teams statement for this issue:  We decided not to fix this issue because we may implement assets similar to LIDO as the yield source where they may have permit functionality (aTokens, for instance).", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#non-existent-permit-function", "labels": ["OpenZeppelin"]}, {"title": "Funds held in ETHAdapter can be drained by anyone", "body": "ETHAdapter contract is used as a proxy to allow users to interact with the vault through sending and receiving ETH instead of stETH. The adapter achieves this by converting ETH and stETH through a curve pool and then forwarding interactions to and from the vault. In the course of a normal  withdrawal or  redemption transaction, the  converts all of its stETH to ETH, and then sends its entire ETH balance to the receiving address.  The issue is that the ETHAdapter sends its full balance to the receiver each time, meaning any ETH or stETH that is mistakenly sent to it can be drained by any user who performs a withdrawal or redemption on the ETHAdapter. This is exacerbated by the fact that the vault is passed in as a parameter, potentially allowing a user to perform withdrawals and redemptions without interacting with the actual stETH vault.  Consider transferring out the exchanged balance from the curve pool to the receiver instead of the entire balance of the ETHAdapter. Also consider implementing a rescue or sweep function to allow the recovery of funds that are accidentally sent to the ETHAdapter.  Update: Acknowledged, will not fix. Pods Finance teams statement:  For now, we do not want to take action in case of funds sends by mistake to our contract. We see this as a low-priority issue.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#funds-held-in-ethadapter-can-be-drained-by-anyone", "labels": ["OpenZeppelin"]}, {"title": "Incorrect calculations", "body": "We found the following instances of incorrect calculations in view functions that are not currently called internally:  In the previewWithdraw function, the DENOMINATOR over invertedFee is always bigger than 1 when the fee is non-zero. Hence, the final returned shares are always an overestimate. Further, the withdrawFeeRatio is multiplied to shares instead of assets as in other instances such as _getFee. Consider correcting the withdrawal fee calculation.  The calculation in the assetsOf function over-estimates the actual commitment by an additional committedAssets. Consider removing the extra component.  Update: Partially fixed in commit 6d37029 in PR#75. previewWithdraw does not include fees as stated in the EIP.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#incorrect-calculations", "labels": ["OpenZeppelin"]}, {"title": "Math library is vulnerable to shadow overflow", "body": "The AuxMath library is a custom auxiliary math library that performs multiplication and division with rounding specifications.  mulDivUp and  mulDivDown first compute the multiplication of a  current implementation will not give the right result in such a case.  Consider using OpenZeppelins Math library which implements the mulDiv function that is developed especially considering these scenarios and is widely accepted in the ecosystem.  Update: Fixed in commit 2a8c58a.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#math-library-is-vulnerable-to-shadow-overflow", "labels": ["OpenZeppelin"]}, {"title": "Maximum mintable and depositable amounts returned are incorrect", "body": "availableCap. Similarly, the  maxMint and  maxDeposit functions do not account for the  EIP4626 standard, these functions must return the real amount that can be minted or deposited.  Consider changing the maxMint and maxDeposit functions to return a value that accounts for the availableCap.  Update: Fixed in PR#42, with commit 3159de5 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#maximum-mintable-and-depositable-amounts-returned-are-incorrect", "labels": ["OpenZeppelin"]}, {"title": "Refund does not restore the cap", "body": "When a user deposits into the vault by joining the deposit queue, the corresponding shares, yet to be minted, are deducted from the spending cap immediately. The spending cap is restored only at withdrawal when the shares are burned.  If one user decides to use the refund function to leave the queue before the round ends, the spending cap will not be restored. When the cap is not zero, a malicious user with a sufficiently large amount of assets could repeatedly deposit and refund to reach the cap limit and stop other eligible users from joining the queue.  Note that the spendCap variable cannot be manually restored, but the owner can reset the cap to a higher value to unlock the deposit.  Consider accounting for the available cap during refunds from the queue.  Update: Fixed in commit 4a2e475.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#refund-does-not-restore-the-cap", "labels": ["OpenZeppelin"]}, {"title": "Refund can be over-credited in a negative yield event", "body": "Deposits added to the queue are point in time stETH balance amounts. The stETH token balance rebases regularly to account for yield, and in the event of slashing, may be subject to a negative yield. In the event that a stETH token rebase is negative between the time a user deposits and calls for a refund, the vault will over credit the user by the rebase difference.  Consider handling the deposits in the queue in shares instead of balances to account for rebase changes on refunds.  Update: Acknowledged, will not fix. Pods Finance teams statement:  Although we agree with the issue, we wont prioritize it right now because of timing. In case of a slashing event, we can refund the vault, transferring funds directly to the contract.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#refund-can-be-over-credited-in-a-negative-yield-event", "labels": ["OpenZeppelin"]}, {"title": "Parallel share cap setting", "body": "The configuration manager determines the maximum vault shares available for minting. When setting a new cap through the setCap function, the target contract address is checked for the zero address, and a SetCap event is emitted.  However, the underlying setParameter function can be called directly to change the maximum vault shares available. This will bypass the zero address check and emit a ParameterSet event instead of the expected SetCap event.  Consider ensuring consistency between the two mechanisms in setting the share cap. Depending on the desired outcome, this could involve removing the setParameter function and adding individual get and set functions for all necessary configuration parameters.  Update: Fixed in commit cbe61d0.  Low Severity", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#parallel-share-cap-setting", "labels": ["OpenZeppelin"]}, {"title": "Gas inefficiencies", "body": "There are many instances throughout the codebase where changes can be made to improve gas consumption. For example:  public functions might consume more gas than external functions. This is because with public functions, the EVM copies inputs (especially dynamic-sized arrays) into memory, while it reads from calldata if the function is external, which is cheaper. Throughout the codebase there are public functions like mintWithPermit, convertToSTETH, convertToETH, decimals, symbol, name and assetsOf that might be declared as external. Consider reviewing the entire codebase for more instances.  The function toAddress has a conditional statement that returns the zero address if the value passed is equal to zero. This additional check increases the gas consumption and does not add any benefit even if the provided value is equal to zero.  Initializing a variable to its default value causes unnecessary gas expense. Consider correcting such instances in processedDeposits, isProcessingDeposits, roundAccruedInterest, endSharePrice and the while loop counter inside the remove function.  The for loop inside the refund function does not cache the result of depositQueue.size() and perform unnecessary operations on each iteration. The same issue occurs in the last while loop of the remove function.  Performing calculations for values that will not change is suboptimal. Some examples are: name, symbol and the operation 10**sharePriceDecimals.  Use shorter string messages for required statements or switch entirely to a custom errors implementation to save on deployment cost and failed execution gas cost.  When performing these changes, aim to reach an optimal tradeoff between gas optimization and readability. Having a codebase that is easy to understand reduces the chance of future errors and improves community transparency.  Update: Partially fixed in PR#81, with commit 6f1bb8e being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#gas-inefficiencies", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent name and symbol", "body": "BaseVault, passed to the  STETHVault implementation. All vaults that use the same underlying asset and inherit from  hashedName when calculating the domain separator by the  EIP712 standard. Although this does not represent a risk, it is  recommended that the name sent to the  Also, the name and symbol defined in the BaseVault constructor are inconsistently overridden in the STETHVault implementation.  To avoid complications and improve code clarity, consider passing both the name and symbol from the STETHVault contract as parameters to maintain consistency. This also saves calculating the name and symbol at every call, thus saving more gas.  Update: Fixed in commit 61a9996.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#inconsistent-name-and-symbol", "labels": ["OpenZeppelin"]}, {"title": "Misleading comments", "body": "Comments are meant to be helpful and describe the intent of the code block. However, in multiple parts of the codebase, comments are not consistent with the code that is written or do not add any value to the reader. These are some examples:  The function _deposit in both the STETHVault and BaseVault contracts does not create any shares even though the comments say so.  The description of each parameter on setParameter, getParameter and getGlobalParameter does not add any value to the reader.  The target parameter on setParameter has a wrong description.  The function _spendCap has the same description as availableCap.  Consider correcting the comments to not mislead users or developers and write comments that add value to the reader. This will improve code clarity and consistency between docstrings and contract implementations.  Update: Fixed in commit 3ad59d0.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#misleading-comments", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "Throughout the codebase, there are several files that do not have docstrings. For instance:  The ConfigurationManager contract has no docstrings for any of its state variables.  The IConfigurationManager interface does not have any docstrings.  Although the ICurvePool interface is for an external contract, docstrings need to be added to explain the interface purpose and why each function is used within the codebase.  The IERC4626 interface has no docstrings for the interface description and also for any of its events.  The IVault interface has no docstrings for the interface description and also for any of its events and errors.  The AuxMath library does not have any docstrings.  The CastUint library has no docstrings for the library description.  The DepositQueueLib library just has some inline comments inside the remove function.  The Capped contract has no docstrings for the contract description, state variables, constructor, and its custom error.  The ETHAdapter contract just has some inline comments for the receive function.  The Migration contract does not have any docstrings.  The BaseVault contract has no docstrings for some of its state variables (configuration, _asset, currentRoundId, isProcessingDeposits, EMERGENCY_INTERVAL, processedDeposits, _lastEndRound and depositQueue), the constructor, and the functions depositWithPermit and mintWithPermit.  The STETHVault contract has no docstrings for some of its state variables (sharePriceDecimals, lastRoundAssets, lastSharePrice, and investor) and the constructor. Adding comments in the internal function _afterRoundEnd can be beneficial for easy understanding of its purpose.  This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security but also correctness. Additionally, docstrings improve readability and easy maintenance.  Consider thoroughly inserting documentation above each contract, interface, library, function, state variable, event, and custom errors. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Processing order alters queue indexes", "body": "Any user may process deposits in the queue after a round ends. After deposits are processed, the section of the queue they were held in is removed. This means that any user who processes deposits will be changing the size and indexes of the queue for all others. This may lead to reverted transactions if an index that was previously thought to be in range no longer exists in the queue. It may also lead to some processing of unintended indexes and others missing their targeted indexes in the queue.  Consider having additional validations on the queue size and indexes to ensure the correct transactions are executed without going out of bounds.  Update: Fixed in commit e05f165.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#processing-order-alters-queue-indexes", "labels": ["OpenZeppelin"]}, {"title": "Refunds are subject to high gas costs and a potential DoS", "body": "Refunds are processed by searching the entire queue front to back for a users position. Currently, the gas price to refund increases linearly based on the users position in the queue. Users that have joined the queue later in the round will incur a more significant gas penalty and, in an extreme case, could be prevented from refunding.  Consider keeping track of a users queue position alongside other attributes for easier retrieval and update.  Update: Fixed in commit e05f165.  Remove function does not revert if startIndex is greater than or equal to endIndex  The remove function is responsible for removing records from the queue. When called, it checks if the endIndex is greater than the startIndex to execute the functions implementation. The issue is that if the condition is not met, the transaction is not reverted, and the code execution continues. This could cause processQueuedDeposits to fail silently when the indexes are not valid.  Although it does not currently cause any errors other than spending gas unnecessarily, consider rolling back the transaction if the condition is met to avoid unwanted behaviors.  Update: Fixed in commit e05f165.  Migration risks  The system allows users to migrate their shares to a new vault with the same underlying asset. There are a few risks regarding the current migration mechanism design.  Unclear migration path: Currently, two migration mechanisms exist. A user can either call the migrate function in the old vault or through the exclusive Migration contract. There is no clarity on which route is preferred as both essentially perform the same functionality. Consider removing duplicate actions that can lead to user confusion.  Incomplete migration: In both migration routes, users first redeem their shares from the old vault and then re-deposit the assets into the new vault. If the queueing system works the same way in the new vault, this only lets the user join the deposit queue. Hence the migration is not complete until the queued deposits are processed with the shares minted. Consider documenting this to make it clear to users who migrate.  Migration re-usability: The Migration contract sets both the old vault and the new vault addresses as immutable variables in the constructor. This limits its use case to one single migration. It would not be reusable across multiple vaults with the same underlying assets and different investment strategies.  Not robust against trapped funds: When assets are present in the Migration contract due to direct transfers or mistaken withdrawals, the entire balance of the contract will be deposited to the new vault by the next user. This design is not resistant to genuine user mistakes and prohibits recovering user funds. Consider using the returned value from the redeem function to migrate the correct amount of assets and establishing a sweep or rescue function for funds locked in the contract.  Update: Partially fixed in commit d97672d.  Unnecessarily complex code  The investmentYield and the investmentAmount are transferred back and forth from the vault to the same investor account. Instead of making two separate transactions, one can compare the two values and reach the final balance in one transaction.  Consider simplifying the code for clarity and readability.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We actively preferred to leave the code in the back-and-forth way, so its easier to understand the flow of funds of the operations.  Notes & Additional Information  Magic numbers are used  Although constants are generally used correctly throughout the codebase, there are a few occurrences of literal values being used with unexplained meaning. For example, the following blocks use hardcoded values:  In the constructor of the ETHAdapter contract, the pools coins method is called with arguments 0 and 1, with no explanation.  In the functions convertToETH and convertToSTETH, the pools get_dy method is called with arguments 0 and 1 with no explanation.  In the deposit function, the pools exchange method is called with arguments 0 and 1, with no explanation.  To improve the codes readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. Consider adding an inline comment explaining how they are calculated or why they are chosen for complex values.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.  Multiple conditions for error handling statements  Throughout the codebase there are require statements and custom error blocks that need multiple conditions to be satisfied. For instance:  In the constructor of the ETHAdapter contract there is a require statement that checks if coin 0 from the pool is equal to the ETH address and if coin 1 is equal to stETH address. If one of the conditions is not met, there is no error message to indicate why the transaction was reverted.  The migrate function in the BaseVault contract has a conditional block that checks if the vault is not allowed and if the destination vault does not have the same underlying asset as the current vault. Although the custom error that is thrown is not wrong, it might be better if these two validations are separated to return more specific error messages.  The onlyRoundStarter modifier has a custom error block that checks if less than a week has passed since the last end round and if the caller is different from the controller. If the conditions are met, the error returned is that the caller is not the controller. Consider separating both conditions in order to throw a more specific error message.  To simplify the codebase and to raise the most helpful error messages for failing blocks, consider having a single require statement with an appropriate error message or a single custom error block per condition.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.  Naming issues hinder code understanding and readability  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  Function withdrawFeeRatio can be changed to getWithdrawFeeRatio. The current name suggests that the action is the withdrawal of fee ratio but what it actually does is to query the WITHDRAW_FEE_RATIO value.  Error ConfigurationManager__InvalidCapTarget can be changed to ConfigurationManager__TargetCannotBeTheZeroAddress or something similar, since the only invalid target is the zero address.  Update: Fixed in commit 88ce562.  Non-explicit imports are used  Non-explicit imports are used throughout the codebase, which reduces code readability and could lead to conflicts between names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long. For instance, but not limited to:  Lines 5-14 of BaseVault.sol  Lines 5-9 of EthAdapter.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.  Outdated Solidity version  All contracts within the codebase use compiler version 0.8.9, an old version with various bugs that have been fixed in later releases.  Consider taking advantage of the latest Solidity version to improve the overall quality and security of the codebase.  Update: Fixed in commit 93956a9 in PR#66.  State variable visibility not explicitly declared  Throughout the codebase, there are state variables that lack explicitly declared visibility. For instance:  CAP in ConfigurationManager.sol  ETH_ADDRESS in ETHAdapter.sol  STETH_ADDRESS in ETHAdapter.sol  from in Migration.sol  to in Migration.sol  For clarity, consider always explicitly declaring the visibility of variables, even when the default visibility matches the intended visibility.  Update: Fixed in PR#64, with commit a3eb939 being the last one added.  Style inconsistencies  Style inconsistencies can be seen throughout the codebase. For example:  Some functions use require statements for error handling and others use custom errors. In general custom errors are preferred over require statements.  The naming convention for events is not clear. Some use, like StartRound, the functions name with the first letter capitalized, and others, like FeeCollected, describe the action that was executed. Consider following only one convention on the entire codebase.  The constant investorRatio does not use all capital letters with underscores separating words but all other constants in the codebase do. Consider changing it to INVESTOR_RATIO.  Update: Fixed in commit cf6ae4d.  Typographical errors  Across the codebase, there are some typographical errors in the comments. Some examples are:  ConfiguratorManager should be ConfigurationManager.  MAX_WITDRAW_FEE should be MAX_WITHDRAW_FEE.  splitted should be split.  Consider correcting the above and any further typos in favor of correctness and readability.  Update: Fixed in PR#41 commit a515964 and PR#69 commit 4ec70cb.  Unnecessary arguments  We found some internal functions with unused arguments in the implementation, hence are unnecessary to be defined in the base contract. For example:  The _afterRoundStart(uint256) function does not require an argument in the implementation but is defined with an argument in the base contract.  The _beforeWithdraw(uint256 shares, uint256) function does not require a second argument but is defined with a second argument in the base contract.  Consider removing unnecessary arguments for clarity and readability.  Update: Fixed in commit f100925.  Unnecessary implementation  The following instances of internal virtual functions are implemented in BaseVault.sol, which are later overridden by a different implementation in STETHVault.sol.  The _withdraw function is overridden by the same implementation.  The _deposit function is overridden by a different implementation.  Consider removing unnecessary implementations for readability and maintenance.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.  Unused Code  The global address and the getGlobalParameter() function of the ConfigurationManager contract are supposed to manage global configurations that do not depend on a specific vault. However, the purpose of those entities is unclear, as they are not used anywhere in the codebase.  To avoid confusion and favor explicitness, consider documenting the purpose of these functions and variables. If they are not expected to be used, consider removing them from the codebase to reduce the codes size and attack surface.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.  Unused imports  Throughout the codebase imports on the following lines are unused and could be removed:  draft-IERC20Permit in BaseVault  IConfigurationManager in ETHAdapter  Consider removing unused imports to avoid confusion and improve the overall readability of the codebase.  Update: Fixed in commits b702189 and 89869ad.  Unused named return variable  Throughout the codebase, there are several occasions where named return variables are declared but not used. For instance:  newShares on migrate and migrateWithPermit functions  stETHAmount on convertToSTETH  ethAmount on convertToETH  depositedAssets on _deposit on both STETHVault and BaseVault  roundId on startRound  shares on maxMint, maxRedeem, deposit, convertToShares, and previewDeposit  assets on maxWithdraw, maxDeposit, convertToAssets, and previewMint  effectiveAmount on _stETHTransferFrom  Consider adding those variables to function implementations or remove them.  Update: Fixed in commit 1228184.  Conclusions  Three critical and three high-severity issues are found among various lower-severity issues. The system documentation and diagrams provided by the Pods Finance team made it easier for the auditors to assess and comprehend the code. Throughout the audit, the team has been responsive and active in responding to questions and suggestions from the auditors.  Given the number of important issues raised, we believe there could be more undiscovered issues, and we anticipate a significant refactor to the codebase. If this turns out to be the case, we highly recommend another round of audits on the new code.  Update as of November 15th:  The Pods Finance team considerably refactored the codebase to address many findings that were initially reported; however, another critical issue was discovered during the fix-review process. OpenZeppelin worked with the Pods Finance team to address this issue, though we noted that the fix-review process was limited in assessing security issues within the significant changes made to the codebase. OpenZeppelin strongly recommended the Pods Finance team obtain a full code re-audit and the Pods Finance team is proceeding with that.  Appendix I: Monitoring Recommendation  With the goal of providing a complete security solution, we have identified several actions that might benefit from on-chain monitoring to provide useful alerts and insights about on-chain protocol activities. Here are some example scenarios that would benefit from monitoring:  Deposits to the vault with dust or large amounts. This could represent a potential threat to manipulate vault share calculations.  Privileged role activities such as those performed by the Owner of the ConfigurationManager, the Controller of the vault, and the Investor of the vault. Consider monitoring events related, but not limited to, ownership changes, vault configuration modifications, and transfers initiated by the Investor to somewhere other than the vault as these may signal key compromise of a privileged role.  Appendix II: Issue noted during fix-review process  Critical Issue: Malicious user can manipulate shares calculation and steal deposits  As part of the fixes developed and provided during the fix-review process, it was noted that the current queue setup could potentially be exploited by Maximum Extractable Value (MEV) searchers if the endRound transaction is sent through the public mempool.  In the scenario when the MEV searcher has sufficient liquidity, the following strategy can be viable.  Deposit one wei to the queue before endRound.  Back-run the endRound transaction with a transaction that  direct transfers an amount equal to the max of the queued amounts plus one wei. reorders the queue by bringing up the searchers one wei to the head. processes the reordered queue in one go.  In this way, the MEV searcher gets one share while everyone else gets zero shares due to the rounding in the division. Since no deposit or withdrawal is possible during the processing period, the MEV searcher waits until either the next startRound or one week has passed. Then the searcher can redeem its shares and remove the entire liquidity from the vault. We note that the searcher may need to back-run the startRound transaction to ensure that its one share is not diluted by further large sum deposits. Now, the vault is back to zero shares, zero liquidity and the same attack can be repeated.  In case the MEV searcher does not have enough liquidity, a milder version of the same strategy can be carried out by processing only part of the queue with the correct ordering.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#refunds-are-subject-to-high-gas-costs-and-a-potential-dos", "labels": ["OpenZeppelin"]}, {"title": "Remove function does not revert if startIndex is greater than or equal to endIndex", "body": "Remove function does not revert if startIndex is greater than or equal to endIndex", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#remove-function-does-not-revert-if-startindex-is-greater-than-or-equal-to-endindex", "labels": ["OpenZeppelin"]}, {"title": "Migration risks", "body": "The system allows users to migrate their shares to a new vault with the same underlying asset. There are a few risks regarding the current migration mechanism design.  Unclear migration path: Currently, two migration mechanisms exist. A user can either call the migrate function in the old vault or through the exclusive Migration contract. There is no clarity on which route is preferred as both essentially perform the same functionality. Consider removing duplicate actions that can lead to user confusion.  Incomplete migration: In both migration routes, users first redeem their shares from the old vault and then re-deposit the assets into the new vault. If the queueing system works the same way in the new vault, this only lets the user join the deposit queue. Hence the migration is not complete until the queued deposits are processed with the shares minted. Consider documenting this to make it clear to users who migrate.  Migration re-usability: The Migration contract sets both the old vault and the new vault addresses as immutable variables in the constructor. This limits its use case to one single migration. It would not be reusable across multiple vaults with the same underlying assets and different investment strategies.  Not robust against trapped funds: When assets are present in the Migration contract due to direct transfers or mistaken withdrawals, the entire balance of the contract will be deposited to the new vault by the next user. This design is not resistant to genuine user mistakes and prohibits recovering user funds. Consider using the returned value from the redeem function to migrate the correct amount of assets and establishing a sweep or rescue function for funds locked in the contract.  Update: Partially fixed in commit d97672d.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#migration-risks", "labels": ["OpenZeppelin"]}, {"title": "Unnecessarily complex code", "body": "The investmentYield and the investmentAmount are transferred back and forth from the vault to the same investor account. Instead of making two separate transactions, one can compare the two values and reach the final balance in one transaction.  Consider simplifying the code for clarity and readability.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We actively preferred to leave the code in the back-and-forth way, so its easier to understand the flow of funds of the operations.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#unnecessarily-complex-code", "labels": ["OpenZeppelin"]}, {"title": "Magic numbers are used", "body": "Although constants are generally used correctly throughout the codebase, there are a few occurrences of literal values being used with unexplained meaning. For example, the following blocks use hardcoded values:  In the constructor of the ETHAdapter contract, the pools coins method is called with arguments 0 and 1, with no explanation.  In the functions convertToETH and convertToSTETH, the pools get_dy method is called with arguments 0 and 1 with no explanation.  In the deposit function, the pools exchange method is called with arguments 0 and 1, with no explanation.  To improve the codes readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. Consider adding an inline comment explaining how they are calculated or why they are chosen for complex values.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#magic-numbers-are-used", "labels": ["OpenZeppelin"]}, {"title": "Multiple conditions for error handling statements", "body": "Throughout the codebase there are require statements and custom error blocks that need multiple conditions to be satisfied. For instance:  In the constructor of the ETHAdapter contract there is a require statement that checks if coin 0 from the pool is equal to the ETH address and if coin 1 is equal to stETH address. If one of the conditions is not met, there is no error message to indicate why the transaction was reverted.  The migrate function in the BaseVault contract has a conditional block that checks if the vault is not allowed and if the destination vault does not have the same underlying asset as the current vault. Although the custom error that is thrown is not wrong, it might be better if these two validations are separated to return more specific error messages.  The onlyRoundStarter modifier has a custom error block that checks if less than a week has passed since the last end round and if the caller is different from the controller. If the conditions are met, the error returned is that the caller is not the controller. Consider separating both conditions in order to throw a more specific error message.  To simplify the codebase and to raise the most helpful error messages for failing blocks, consider having a single require statement with an appropriate error message or a single custom error block per condition.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#multiple-conditions-for-error-handling-statements", "labels": ["OpenZeppelin"]}, {"title": "Naming issues hinder code understanding and readability", "body": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  Function withdrawFeeRatio can be changed to getWithdrawFeeRatio. The current name suggests that the action is the withdrawal of fee ratio but what it actually does is to query the WITHDRAW_FEE_RATIO value.  Error ConfigurationManager__InvalidCapTarget can be changed to ConfigurationManager__TargetCannotBeTheZeroAddress or something similar, since the only invalid target is the zero address.  Update: Fixed in commit 88ce562.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#naming-issues-hinder-code-understanding-and-readability", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit imports are used", "body": "throughout the codebase, which reduces code readability and could lead to conflicts between names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long. For instance, but not limited to:  Lines 5-14 of BaseVault.sol  Lines 5-9 of EthAdapter.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Outdated Solidity version", "body": "All contracts within the codebase use compiler version 0.8.9, an old version with various bugs that have been fixed in later releases.  Consider taking advantage of the latest Solidity version to improve the overall quality and security of the codebase.  Update: Fixed in commit 93956a9 in PR#66.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#outdated-solidity-version", "labels": ["OpenZeppelin"]}, {"title": "State variable visibility not explicitly declared", "body": "Throughout the codebase, there are state variables that lack explicitly declared visibility. For instance:  CAP in ConfigurationManager.sol  ETH_ADDRESS in ETHAdapter.sol  STETH_ADDRESS in ETHAdapter.sol  from in Migration.sol  to in Migration.sol  For clarity, consider always explicitly declaring the visibility of variables, even when the default visibility matches the intended visibility.  Update: Fixed in PR#64, with commit a3eb939 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#state-variable-visibility-not-explicitly-declared", "labels": ["OpenZeppelin"]}, {"title": "Style inconsistencies", "body": "can be seen throughout the codebase. For example:  Some functions use require statements for error handling and others use custom errors. In general custom errors are preferred over require statements.  The naming convention for events is not clear. Some use, like StartRound, the functions name with the first letter capitalized, and others, like FeeCollected, describe the action that was executed. Consider following only one convention on the entire codebase.  The constant investorRatio does not use all capital letters with underscores separating words but all other constants in the codebase do. Consider changing it to INVESTOR_RATIO.  Update: Fixed in commit cf6ae4d.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#style-inconsistencies", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Across the codebase, there are some typographical errors in the comments. Some examples are:  ConfiguratorManager should be ConfigurationManager.  MAX_WITDRAW_FEE should be MAX_WITHDRAW_FEE.  splitted should be split.  Consider correcting the above and any further typos in favor of correctness and readability.  Update: Fixed in PR#41 commit a515964 and PR#69 commit 4ec70cb.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary arguments", "body": "We found some internal functions with unused arguments in the implementation, hence are unnecessary to be defined in the base contract. For example:  The _afterRoundStart(uint256) function does not require an argument in the implementation but is defined with an argument in the base contract.  The _beforeWithdraw(uint256 shares, uint256) function does not require a second argument but is defined with a second argument in the base contract.  Consider removing unnecessary arguments for clarity and readability.  Update: Fixed in commit f100925.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#unnecessary-arguments", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary implementation", "body": "The following instances of internal virtual functions are implemented in BaseVault.sol, which are later overridden by a different implementation in STETHVault.sol.  The _withdraw function is overridden by the same implementation.  The _deposit function is overridden by a different implementation.  Consider removing unnecessary implementations for readability and maintenance.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#unnecessary-implementation", "labels": ["OpenZeppelin"]}, {"title": "Unused Code", "body": "The global address and the getGlobalParameter() function of the ConfigurationManager contract are supposed to manage global configurations that do not depend on a specific vault. However, the purpose of those entities is unclear, as they are not used anywhere in the codebase.  To avoid confusion and favor explicitness, consider documenting the purpose of these functions and variables. If they are not expected to be used, consider removing them from the codebase to reduce the codes size and attack surface.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#unused-code", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "Throughout the codebase imports on the following lines are unused and could be removed:  draft-IERC20Permit in BaseVault  IConfigurationManager in ETHAdapter  Consider removing unused imports to avoid confusion and improve the overall readability of the codebase.  Update: Fixed in commits b702189 and 89869ad.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused named return variable", "body": "Throughout the codebase, there are several occasions where named return variables are declared but not used. For instance:  newShares on migrate and migrateWithPermit functions  stETHAmount on convertToSTETH  ethAmount on convertToETH  depositedAssets on _deposit on both STETHVault and BaseVault  roundId on startRound  shares on maxMint, maxRedeem, deposit, convertToShares, and previewDeposit  assets on maxWithdraw, maxDeposit, convertToAssets, and previewMint  effectiveAmount on _stETHTransferFrom  Consider adding those variables to function implementations or remove them.  Update: Fixed in commit 1228184.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#unused-named-return-variable", "labels": ["OpenZeppelin"]}, {"title": "Storage collision leads to failure of the system", "body": "In the Storage.sol file, the AppStorage struct keeps track of all stored values for the layer 1 system as part of the Diamond proxy pattern. The first entry of this struct is the DiamondCutStorage struct for the deployed code version and the UpgradeStorage struct for the audited and to-be-upgraded version. Both are used to track upgrade data for the DiamondCut facet.  As seen by comparing their entries, the structs have changed in size. Originally, DiamondCutStorage occupied 7 storage slots, while UpgradeStorage only occupies 2. Respectively, the slots of all following variables in the AppStorage struct shift, thereby resulting in a storage collision. Due to this desynchronization of storage, the entire system functionality would break and come to a halt.  For instance, the new governor address slot would match the former lastDiamondFreezeTimestamp value. Hence, by applying the upgrade, the operator loses the governor privilege. As such, the ability to perform further upgrades is lost and no other mechanism of recovery is present in the system. Moreover, the new verifier mapping would match the old securityCouncilMembers mapping. Thus, former council members would become validators. Since all stored block info would be lost, the validators could not commit any new blocks anyways.  In order to apply the upgrade in spite of the storage collision, one could re-initialize the AppStorage during the initialization stage of the same exact Diamond upgrade. However, properly overwriting the mappings does not seem feasible from a gas consumption perspective. Additionally, it requires a diligent off-chain data collection of all mapping data in need of overwrites. In conclusion, missing this opportunity is very probably and likely to fail.  Consider leaving the former struct as is and only appending new data to the end of the AppStorage struct. Thoroughly document that while DiamondCutStorage is unused, it must remain a member of AppStorage. Additionally, create a machine-readable artefact describing the deployed AppStorage layout, and integrate a check against it in your CI system.  Update: Resolved in commit cd417be.  Medium Severity  Arbitrary l2Logs length can lead to unprovable blocks and log inclusion  In the ExecutorFacet contract, the layer 2 logs are processed as part of committing blocks to layer 1. These layer 2 logs have a structured format and are used to extract data of what happened on the layer 2 chain. The size of the layer 2 logs byte data should be fixed. However, this is not checked, which raises the following concerns:  All logs affect the commitment that is later used for proof verification. Any mismatched log data would result in an unprovable commitment and would need to be reverted.  In the Mailbox facet, it can be checked whether specific logs were emitted as part of a block by performing a Merkle inclusion check with a proof length of 9. In the event of more than 512 logs per block, their inclusion cannot be proven.  The constant L2_TO_L1_LOGS_COMMITMENT_BYTES is unused.  Consider making use of the constant to check the size of the layer 2 logs such that the aforementioned concerns are eliminated.  Update: Resolved in commits 39e83ee and 7dceb6b.  Governor can immediately execute diamond upgrades  In the executeUpgrade function of the DiamondCut facet, the Boolean value upgradeNoticePeriodPassed indicates whether the upgrade waiting period has passed. However, the value is never used, thereby allowing the governor role to propose and immediately execute a transparent proposal without the need of council approval. This could have a severe impact for a rogue governor.  Consider checking that the Boolean value holds true such that the implementation reflects the original intention.  Update: Resolved in commits ba31745 and 65ad664.  Low Severity  Missing error messages in require statements  Within Executor.sol there are multiple require statements that lack error messages. For instance:  The require statement on line 43  The require statement on line 45  The require statement on line 291  Consider including specific, informative error messages in require statements in order to improve code clarity and facilitate troubleshooting whenever a requirement is not satisfied.  Update: Resolved in commit 6f446e6.  Require statement with multiple conditions  There is a require statement in the AllowList contract that requires multiple conditions to be satisfied.  In order to simplify the codebase and raise the most helpful error messages for failing require statements, consider having a single require statement per condition.  Update: Resolved in commit 33cb3f5.  Lack of explicit proposal id  In the DiamondCut contract, the proposeShadowUpgrade function checks the equality of its parameter _proposalId to the current proposal id incremented by one. In contrast, the proposeTransparentUpgrade function auto increments the current proposal id obtained from storage and does not require passing an additional parameter.  Consider adding the _proposalId as an additional parameter to the proposeTransparentUpgrade function to provide a consistent proposal flow and avoid any confusion related to the proposal id.  Update: Resolved in commit c70dda0.  Reimplementation of library functionality  Throughout the codebase we found two occurrences of re-implemented functionality that is available in community-vetted Solidity libraries:  The two-step ownable control flow implemented in the AllowList contract is equivalent to the functionality implemented in the OpenZeppelin Ownable2Step contract. Consider extending the Ownable2Step contract with the AllowList functionality.  The SafeCast library is a copied code snippet from the OpenZeppelin library. Consider replacing the imports and removing the custom SafeCast library.  In order to prevent implementation mistakes, consider applying the above changes, leveraging the community-vetted and battle-tested libraries.  Update: Resolved in commit 60b66b0.  Notes & Additional Information  NewOwner event should emit old and new state  The NewOwner event emits the new owner whenever the pending owner accepts ownership of the AllowList contract.  Consider emitting both the old and new owner to allow for better traceability of ownership changes via off-chain clients.  Update: Resolved. The Matter Labs team stated:  We implemented L04 and inherited the Ownable2Step contract so no change is needed.  Gas optimizations  A few places in the codebase could benefit from gas optimization, for example:  In the senderCanCallFunction modifier, instead of casting the function signature from msg.data, consider using msg.sig.  The loop in the Executor facet could have incremented currentTotalBlocksVerified once, instead of doing it twice in line 237 and line 250.  In the Executor facet, the proveBlocks() function performs a safety check to ensure that the number of verified blocks is smaller or equal to the total blocks committed. Consider to fail early by placing the require statement before the proof verification process, i.e., after the loop of committed block checks in line 252.  Consider optimizing these code sections to make them more gas efficient.  Update: Resolved in commit 894c0c8.  Invalid docstring  The interface IExecutor.sol specifies a docstring for the ergsPerPubdataByteInBlock variable, but this variable has already been removed in this code update.  Consider removing this docstring.  Update: Resolved in commit 9bdec5a.  Unused constants  Within the Config.sol file, there are a few constants that are defined but never used throughout the codebase. For instance:  L2_TO_L1_LOGS_COMMITMENT_BYTES  INITIAL_STORAGE_CHANGES_COMMITMENT_BYTES  REPEATED_STORAGE_CHANGES_COMMITMENT_BYTES  Consider either using these constants, documenting why they are left in the code, or removing them.  Update: Resolved in commit 526a3fe.  Files import non-existent contract  The files Storage.sol and IGovernance.sol import the file Verifier.sol, but the file does not exist.  Consider removing these imports.  Update: Resolved, not an issue. The Matter Labs team stated:  The Verifier.sol contract is generated by the server according to the public keys. So, the import file exists, but in a non-explicit way.  Indecisive licensing  Throughout the codebase there are several files that state an SPDX license identifier of MIT OR Apache-2.0.  Consider agreeing on one license per file to prevent confusion on how these files can be used.  Update: Resolved in commit a5fafe5.  Interface and implementation mismatch  In the Getters facet, the function isFacetFreezable is implemented even though it is not defined in the IGetters interface.  In the Governance facet, the function setPorterAvailability has the Boolean parameter _zkPorterIsAvailable while it is called _isPorterAvailable in the IGovernance interface.  Consider correcting the above differences.  Update: Resolved in commit 74eb251.  Non-explicit imports are used  Throughout the codebase, non-explicit imports are used, which reduces code readability and could lead to conflicts between the names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Following the principle that clearer code is better code, consider using a named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.  Typographical errors  In the AllowList contract a typographical error was identified where The address that the owner proposed as one that will replace its should be The address proposed by an owner to replace their address.  Consider fixing this error and any other typographical errors for readability and explicitness.  Update: Resolved in commit e337941.  Conclusions  This diff audit of the layer 1 contracts was conducted over the course of one week. We audited the latest changes to the codebase since the fix review process was completed by the Matter Labs team on October 19th, 2022. For the most part, the changes were high-level, but also new features were implemented, which have improved the codebase overall.  However, as these changes perform an upgrade to already deployed contracts, a critical issue was identified. Further, two medium severity issues were found, as well as five low severity issues.  Working with the Matter Labs team continues to be a great experience as they provide extensive explanations and documentation in a timely manner.  Appendix  Monitoring Recommendations  While audits help in identifying code-level issues in the current implementation and potentially the code deployed in production, we encourage the Matter Labs team to consider incorporating monitoring activities in the production environment. Ongoing monitoring of deployed contracts helps in identifying potential threats and issues affecting the production environment. Hence, with the goal of providing a complete security assessment, we want to extend the recommendations of our previous audit based on the new features.  Upgrades: The Diamond pattern is still the central piece of upgradeability. However, the proposal of upgrades is split into two functions: a transparent mode and a shadow mode. These respectively emit the events ProposeTransparentUpgrade and ProposeShadowUpgrade. While the transparent mode works as the previous proposal, the shadow mode allows upgrades with unexposed diamond cuts. Nonetheless, this upgrade must be approved by the security council and does not underlie the time delay.  As the upgrade can be ambiguous, these proposals and executions should be thoroughly monitored.  Governance: The governance aspect of the layer 1 contracts got extended by an AllowList contract. The owner of the contract can thereby manage different access modes for a target address:  Public  Anyone can call everything.  SpecialAccessOnly  Dedicated addresses can call dedicated functions.  Closed  No one can call anything.  Contracts enable the allowlist by applying a modifier to the respective functions. The modifier then checks against the AllowList contract to determine whether the caller is eligible to make the call.  As part of maintaining this allowlist, the following events are emitted:  UpdateAccessMode  changing the high-level permission  UpdateCallPermission  changing the permission per caller, target, and function  NewPendingOwner  initiating a new owner for the allowlist  NewOwner  acceping the ownership of the allowlist  It is important to monitor whether suspicious addresses are given the permission to call sensitive functions of the system. Unplanned changes to the access mode could also indicate a DoS (Denial-of-Service) attack. Lastly, any changes to the function-critical owner role should carefully be tracked.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#storage-collision-leads-to-failure-of-the-system", "labels": ["OpenZeppelin"]}, {"title": "Arbitrary l2Logs length can lead to unprovable blocks and log inclusion", "body": "Arbitrary l2Logs length can lead to unprovable blocks and log inclusion", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#arbitrary-l2logs-length-can-lead-to-unprovable-blocks-and-log-inclusion", "labels": ["OpenZeppelin"]}, {"title": "Governor can immediately execute diamond upgrades", "body": "In the executeUpgrade function of the DiamondCut facet, the Boolean value upgradeNoticePeriodPassed indicates whether the upgrade waiting period has passed. However, the value is never used, thereby allowing the governor role to propose and immediately execute a transparent proposal without the need of council approval. This could have a severe impact for a rogue governor.  Consider checking that the Boolean value holds true such that the implementation reflects the original intention.  Update: Resolved in commits ba31745 and 65ad664.  Low Severity", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#governor-can-immediately-execute-diamond-upgrades", "labels": ["OpenZeppelin"]}, {"title": "Missing error messages in require statements", "body": "Within Executor.sol there are multiple require statements that lack error messages. For instance:  The require statement on line 43  The require statement on line 45  The require statement on line 291  Consider including specific, informative error messages in require statements in order to improve code clarity and facilitate troubleshooting whenever a requirement is not satisfied.  Update: Resolved in commit 6f446e6.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#missing-error-messages-in-require-statements", "labels": ["OpenZeppelin"]}, {"title": "Require statement with multiple conditions", "body": "There is a require statement in the AllowList contract that requires multiple conditions to be satisfied.  In order to simplify the codebase and raise the most helpful error messages for failing require statements, consider having a single require statement per condition.  Update: Resolved in commit 33cb3f5.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#require-statement-with-multiple-conditions", "labels": ["OpenZeppelin"]}, {"title": "Lack of explicit proposal id", "body": "In the DiamondCut contract, the proposeShadowUpgrade function checks the equality of its parameter _proposalId to the current proposal id incremented by one. In contrast, the proposeTransparentUpgrade function auto increments the current proposal id obtained from storage and does not require passing an additional parameter.  Consider adding the _proposalId as an additional parameter to the proposeTransparentUpgrade function to provide a consistent proposal flow and avoid any confusion related to the proposal id.  Update: Resolved in commit c70dda0.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#lack-of-explicit-proposal-id", "labels": ["OpenZeppelin"]}, {"title": "Reimplementation of library functionality", "body": "Throughout the codebase we found two occurrences of re-implemented functionality that is available in community-vetted Solidity libraries:  The two-step ownable control flow implemented in the AllowList contract is equivalent to the functionality implemented in the OpenZeppelin Ownable2Step contract. Consider extending the Ownable2Step contract with the AllowList functionality.  The SafeCast library is a copied code snippet from the OpenZeppelin library. Consider replacing the imports and removing the custom SafeCast library.  In order to prevent implementation mistakes, consider applying the above changes, leveraging the community-vetted and battle-tested libraries.  Update: Resolved in commit 60b66b0.  Notes & Additional Information  NewOwner event should emit old and new state  The NewOwner event emits the new owner whenever the pending owner accepts ownership of the AllowList contract.  Consider emitting both the old and new owner to allow for better traceability of ownership changes via off-chain clients.  Update: Resolved. The Matter Labs team stated:  We implemented L04 and inherited the Ownable2Step contract so no change is needed.  Gas optimizations  A few places in the codebase could benefit from gas optimization, for example:  In the senderCanCallFunction modifier, instead of casting the function signature from msg.data, consider using msg.sig.  The loop in the Executor facet could have incremented currentTotalBlocksVerified once, instead of doing it twice in line 237 and line 250.  In the Executor facet, the proveBlocks() function performs a safety check to ensure that the number of verified blocks is smaller or equal to the total blocks committed. Consider to fail early by placing the require statement before the proof verification process, i.e., after the loop of committed block checks in line 252.  Consider optimizing these code sections to make them more gas efficient.  Update: Resolved in commit 894c0c8.  Invalid docstring  The interface IExecutor.sol specifies a docstring for the ergsPerPubdataByteInBlock variable, but this variable has already been removed in this code update.  Consider removing this docstring.  Update: Resolved in commit 9bdec5a.  Unused constants  Within the Config.sol file, there are a few constants that are defined but never used throughout the codebase. For instance:  L2_TO_L1_LOGS_COMMITMENT_BYTES  INITIAL_STORAGE_CHANGES_COMMITMENT_BYTES  REPEATED_STORAGE_CHANGES_COMMITMENT_BYTES  Consider either using these constants, documenting why they are left in the code, or removing them.  Update: Resolved in commit 526a3fe.  Files import non-existent contract  The files Storage.sol and IGovernance.sol import the file Verifier.sol, but the file does not exist.  Consider removing these imports.  Update: Resolved, not an issue. The Matter Labs team stated:  The Verifier.sol contract is generated by the server according to the public keys. So, the import file exists, but in a non-explicit way.  Indecisive licensing  Throughout the codebase there are several files that state an SPDX license identifier of MIT OR Apache-2.0.  Consider agreeing on one license per file to prevent confusion on how these files can be used.  Update: Resolved in commit a5fafe5.  Interface and implementation mismatch  In the Getters facet, the function isFacetFreezable is implemented even though it is not defined in the IGetters interface.  In the Governance facet, the function setPorterAvailability has the Boolean parameter _zkPorterIsAvailable while it is called _isPorterAvailable in the IGovernance interface.  Consider correcting the above differences.  Update: Resolved in commit 74eb251.  Non-explicit imports are used  Throughout the codebase, non-explicit imports are used, which reduces code readability and could lead to conflicts between the names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Following the principle that clearer code is better code, consider using a named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.  Typographical errors  In the AllowList contract a typographical error was identified where The address that the owner proposed as one that will replace its should be The address proposed by an owner to replace their address.  Consider fixing this error and any other typographical errors for readability and explicitness.  Update: Resolved in commit e337941.  Conclusions  This diff audit of the layer 1 contracts was conducted over the course of one week. We audited the latest changes to the codebase since the fix review process was completed by the Matter Labs team on October 19th, 2022. For the most part, the changes were high-level, but also new features were implemented, which have improved the codebase overall.  However, as these changes perform an upgrade to already deployed contracts, a critical issue was identified. Further, two medium severity issues were found, as well as five low severity issues.  Working with the Matter Labs team continues to be a great experience as they provide extensive explanations and documentation in a timely manner.  Appendix  Monitoring Recommendations  While audits help in identifying code-level issues in the current implementation and potentially the code deployed in production, we encourage the Matter Labs team to consider incorporating monitoring activities in the production environment. Ongoing monitoring of deployed contracts helps in identifying potential threats and issues affecting the production environment. Hence, with the goal of providing a complete security assessment, we want to extend the recommendations of our previous audit based on the new features.  Upgrades: The Diamond pattern is still the central piece of upgradeability. However, the proposal of upgrades is split into two functions: a transparent mode and a shadow mode. These respectively emit the events ProposeTransparentUpgrade and ProposeShadowUpgrade. While the transparent mode works as the previous proposal, the shadow mode allows upgrades with unexposed diamond cuts. Nonetheless, this upgrade must be approved by the security council and does not underlie the time delay.  As the upgrade can be ambiguous, these proposals and executions should be thoroughly monitored.  Governance: The governance aspect of the layer 1 contracts got extended by an AllowList contract. The owner of the contract can thereby manage different access modes for a target address:  Public  Anyone can call everything.  SpecialAccessOnly  Dedicated addresses can call dedicated functions.  Closed  No one can call anything.  Contracts enable the allowlist by applying a modifier to the respective functions. The modifier then checks against the AllowList contract to determine whether the caller is eligible to make the call.  As part of maintaining this allowlist, the following events are emitted:  UpdateAccessMode  changing the high-level permission  UpdateCallPermission  changing the permission per caller, target, and function  NewPendingOwner  initiating a new owner for the allowlist  NewOwner  acceping the ownership of the allowlist  It is important to monitor whether suspicious addresses are given the permission to call sensitive functions of the system. Unplanned changes to the access mode could also indicate a DoS (Denial-of-Service) attack. Lastly, any changes to the function-critical owner role should carefully be tracked.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#reimplementation-of-library-functionality", "labels": ["OpenZeppelin"]}, {"title": "NewOwner event should emit old and new state", "body": "NewOwner event should emit old and new state", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#newowner-event-should-emit-old-and-new-state", "labels": ["OpenZeppelin"]}, {"title": "Gas optimizations", "body": "A few places in the codebase could benefit from gas optimization, for example:  In the senderCanCallFunction modifier, instead of casting the function signature from msg.data, consider using msg.sig.  The loop in the Executor facet could have incremented currentTotalBlocksVerified once, instead of doing it twice in line 237 and line 250.  In the Executor facet, the proveBlocks() function performs a safety check to ensure that the number of verified blocks is smaller or equal to the total blocks committed. Consider to fail early by placing the require statement before the proof verification process, i.e., after the loop of committed block checks in line 252.  Consider optimizing these code sections to make them more gas efficient.  Update: Resolved in commit 894c0c8.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Invalid docstring", "body": "The interface IExecutor.sol specifies a docstring for the ergsPerPubdataByteInBlock variable, but this variable has already been removed in this code update.  Consider removing this docstring.  Update: Resolved in commit 9bdec5a.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#invalid-docstring", "labels": ["OpenZeppelin"]}, {"title": "Unused constants", "body": "Within the Config.sol file, there are a few constants that are defined but never used throughout the codebase. For instance:  L2_TO_L1_LOGS_COMMITMENT_BYTES  INITIAL_STORAGE_CHANGES_COMMITMENT_BYTES  REPEATED_STORAGE_CHANGES_COMMITMENT_BYTES  Consider either using these constants, documenting why they are left in the code, or removing them.  Update: Resolved in commit 526a3fe.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#unused-constants", "labels": ["OpenZeppelin"]}, {"title": "Files import non-existent contract", "body": "The files Storage.sol and IGovernance.sol import the file Verifier.sol, but the file does not exist.  Consider removing these imports.  Update: Resolved, not an issue. The Matter Labs team stated:  The Verifier.sol contract is generated by the server according to the public keys. So, the import file exists, but in a non-explicit way.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#files-import-non-existent-contract", "labels": ["OpenZeppelin"]}, {"title": "Indecisive licensing", "body": "Throughout the codebase there are several files that state an SPDX license identifier of MIT OR Apache-2.0.  Consider agreeing on one license per file to prevent confusion on how these files can be used.  Update: Resolved in commit a5fafe5.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#indecisive-licensing", "labels": ["OpenZeppelin"]}, {"title": "Interface and implementation mismatch", "body": "In the Getters facet, the function isFacetFreezable is implemented even though it is not defined in the IGetters interface.  In the Governance facet, the function setPorterAvailability has the Boolean parameter _zkPorterIsAvailable while it is called _isPorterAvailable in the IGovernance interface.  Consider correcting the above differences.  Update: Resolved in commit 74eb251.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#interface-and-implementation-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit imports are used", "body": "Throughout the codebase, non-explicit imports are used, which reduces code readability and could lead to conflicts between the names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Following the principle that clearer code is better code, consider using a named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "In the AllowList contract a typographical error was identified where The address that the owner proposed as one that will replace its should be The address proposed by an owner to replace their address.  Consider fixing this error and any other typographical errors for readability and explicitness.  Update: Resolved in commit e337941.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Lack of validation in EmergencyProposer setQuorum and setMinimumWaitTime", "body": "Lack of validation in EmergencyProposer setQuorum and setMinimumWaitTime", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#lack-of-validation-in-emergencyproposer-setquorum-and-setminimumwaittime", "labels": ["OpenZeppelin"]}, {"title": "Governor contract can create emergency proposals", "body": "The EmergencyProposal contract is used to construct an emergency recovery transaction that bypasses the standard voting process. The intention is to provide an alternate execution path that can be utilized to fix an incorrectly configured VotingV2 contract.  Any user can propose an emergency transaction via the emergencyPropose function, but the size of the required bond is expected to be large enough that it is unlikely that an individual or the UMA team would be able to sufficiently fund the bond amount on their own. Proposals are executed using the emergencyExecute function in the GovernorV2 contract. The executor address has the sole ability to call this function, giving it veto power over any proposal. The UMA team controls the executor address.  There is currently no restriction that would prevent using the standard voting process to create a transaction that results in the GovernorV2 contract calling the emergencyPropose function to create a proposal. While this is highly unlikely as this transaction would need to pass a standard voting process, this could potentially introduce undesired effects and deviate from the expected functioning of the contract.  An example of an unexpected interaction is that a GovernorV2 emergency proposal can not be slashed by using the slashProposal function, as the slash mechanism transfers the slashed amount to the GovernorV2 address.  To avoid unexpected or undesirable behavior, consider preventing the GovernorV2 contract from being able to execute the emergencyPropose function.  Update: Fixed as of commit 41a03995087d2e63d047075582ef49783074ba48 in PR #4151.  Incorrect public visibility  query and retrieve prices from a previous voting contract. However, the function  is defined with  _requireRegisteredContract check used by the  Consider changing the visibility of _getPriceFromPreviousVotingContract from public to private.  Update: Fixed as of commit 4f1c1d741d67959ab69acdf8ff70f7eb4d65f429 in PR #4154.  Lack of address validation in setExecutor  In the EmergencyProposal contract, the function setExecutor allows the owner of the contract to set a new executor. However, the function does not validate that the newExecutor address is not the zero address before updating the value.  Consider adding validation to prevent an unintended change that sets the executor to the zero address.  Update: Resolved, not an issue. Ability to set executor to zero is a feature of the UMA platform. UMAs statement:  The audit fix proposes adding address validation to the setExecutor function such that this value cant be set to the zero address. We choose to do nothing for this issue as being able to set the executor to the zero address is a feature: this acts to disable the emergencyProposer system, thereby disabling the emergency logic. This could be, for example, an upgrade path for the emergency proposal system or a path forward if governance deems the emergency proposal logic redundant.  Missing documentation  Several functions within the codebase have missing or incomplete documentation:  In PR #4110:  The _stakeTo function in the Staker contract has no docstring  In PR #4118:  The _previousVotingContract parameter has no corresponding @param line in the VotingV2 constructor docstring  The _getPriceFromPreviousVotingContract function in VotingV2 has no docstring  In PR #4128:  The emergencyPropose function in EmergencyProposer returns a value but its docstring has no corresponding @return line  In PR #4135:  The getCurrentTime function in VotingV2Test has no docstring  The commitVote function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The revealVote function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The commitAndEmitEncryptedVote function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The getPendingPriceRequestsArray function in VotingV2Test has no docstring  The getPriceRequestStatuses function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The retrieveRewardsOnMigratedVotingContract function in VotingV2 returns a value but its docstring has no corresponding @return line  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions that implement sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec). Also consider providing explanatory comments for all events, structs, and storage variables that indicate their intended purpose.  Update: Partially fixed as of commit e729b6ba86529598326ec80083cdfbaf8541b94c in PR #4155. UMAs statement:  It has been decided not to add docstring in the test contracts as this is not done through the rest of the repo.  Missing error messages in require statements  Within VotingV2.sol there are require statements that lack error messages. For instance:  The require statement on line 257 of VotingV2.sol  The require statement on line 265 of VotingV2.sol  The require statement on line 486 of VotingV2.sol  The require statement on line 704 of VotingV2.sol  The require statement on line 928 of VotingV2.sol  The require statement on line 964 of VotingV2.sol  The require statement on line 971 of VotingV2.sol  We are aware error messages were removed to reduce the contract size, however their absence makes interacting or debugging the contract more difficult.  Consider including specific, informative error messages in require statements to improve overall code clarity and to facilitate troubleshooting whenever a requirement is not satisfied.  Update: Fixed as of commit a88a022a9a5b02c9cd0526c7fc2e72a094d02813 in PR #4173.  Missing modifier onlyIfNotMigrated enables new price requests on migrated contracts  onlyIfNotMigrated and its underlying private function  _requireNotMigrated are used to ensure that the voting contract being called is the most recent voting contract deployed. This prevents users from requesting prices and voting on price requests on an outdated voting contract. However,  requestGovernanceAction and  signalRequestsAsSpamForDeletion. Both of these functions will call  Consider adding the onlyIfNotMigrated modifier to the functions requestGovernanceAction and signalRequestsAsSpamForDeletion.  Update: Fixed as of commit e62b25249441fc827f3fd6a336ed31d887c93dad in PR #4157.  Missing test coverage  Pull request #4117 adds a new retrieveRewardsOnMigratedVotingContract function to the VotingV2 contract, in order to enable voters to claim their rewards from the previous voting contract. However, this pull request does not include any test coverage for the newly added function.  Without an automated test for this function, manual testing is required to determine if the current implementation matches the functionss expected behavior, which is error prone and deviates from the goal of continuous integration.  Consider adding test coverage for the new retrieveRewardsOnMigratedVotingContract function.  Update: Resolved, not an issue. Tests were included but fell outside the scope of the audit. UMAs statement:  Test coverage was actually already added for this function, but in a separate PR to when the logic was added. This was added in an adjacent PR where we proposed to decrease the contract bytecode. The test for this logic can be found here.  Nonintuitive behavior of payable transactions in executeEmergencyProposal  In the EmergencyProposal contract, the executeEmergencyProposal function iterates through the transactions submitted on the proposal and executes them. However, only the first element in the array is able to execute a payable transaction, as the first element of the proposed transactions will transfer the entirety of the contract ETH balance, meaning that subsequent transactions will have a value of zero.  Consider documenting this behavior thoroughly as it may not be obvious or intuitive to the proposal submitter.  Update: Fixed as of commit 3b6239aa8b38610247674c952ba7379de898d4b6 in PR #4158. Further clarification provided by UMA regarding the behavior of the executeEmergencyProposal function:  The emergency proposer forwards its entire balance (presumably the amount sent by the caller) to the governor in the first transaction. However, the governor could spend that balance over multiple transactions. The only requirement is that the execution transaction has the total of all ETH sent in all emergency execution transactions.  require statements with multiple conditions  Throughout the codebase there are require statements that contain multiple conditions. For instance:  The require statement on line 202 of Staker.sol  The require statement on line 267 of VotingV2.sol  The require statement on line 762 of VotingV2.sol  The require statement on line 801 of VotingV2.sol  The require statement on line 986 of VotingV2.sol  Bundling multiple conditions into a single require statement reduces the contract size, but also prevents being able to provide a separate error message for each failure case.  Consider isolating each condition in its own require statement, to facilitate specific user-friendly error messages for every required condition.  Update: Acknowledged, and will not fix. UMAs statement:  We wont add this suggestion because of bytecode limitations.  Unlocked Solidity version pragma  There are two locations where the Solidity version used is ^0.8.0:  PR #4128, EmergencyProposerTest.sol, line 2  PR #4121, VotingUpgraderV2.sol, line 2  This version string allows compilation with any version of Solidity from 0.8.0 up to the latest release. This may lead to unexpected behavior if the code is deployed with a different Solidity version than was used during testing. Further, allowing old versions of Solidity leaves the code potentially vulnerable to known security bugs which have already been patched. The official guidance is to always use the latest Solidity release when deploying contracts. When a bug is discovered that affects a range of Solidity versions, the general policy of the Solidity team is to only apply the fix to the latest release (i.e. no backporting of security updates).  Consider locking the version pragma to the same Solidity version used during development and testing. Also consider setting this version to be the latest release.  Update: Fixed as of commit abb30bb58fdf222a6d28363922b179043cea755c in PR #4159 and commit 3be4710c3868ca553e8ab87a815febf939fe021f in PR #4178._  Notes & Additional Information  Lack of immutable identifier  VotingUpgraderV2 contract, the mutable state variables  only set once within the constructor. Consider declaring these state variables as immutable to increase gas efficiency and enhance the clarity of your codebase.  Update: Fixed as of commit 1c77938f762f7bc55a387dbccab11b9a86a464bf in PR #4160.  Misleading documentation  The codebase contains several occurrences of misleading or incorrect documentation:  VotingUpgraderV2:  The comment on  line 41 Existing governor is the only one who can initiate the upgrade appears to be a copy & paste error from  line 38 which is identical. Consider rewriting the comment.  The comment on  line 52 Addresses to upgrade does not apply to the  line 53. Consider rewriting the comment.  The comment on  line 62 Removes an address from the whitelist does not apply to the  Update: Fixed as of commit 77c2370cd2d86920429e658c157941c019fbf697 in PR #4152 and commit 3be4710c3868ca553e8ab87a815febf939fe021f in PR #4178.  Non-explicit imports are used  Non-explicit imports are used inside the codebase, which reduces code readability and could lead to conflicts between names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  For example, the DesignatedVotingV2 contracts import block can be rewritten more explicitly as:  The usage of explicit imports makes it clear that StakerInterface is provided by Stakeable.sol, and that OracleInterfaces is provided by Constants.sol.  Update: Acknowledged, and will not fix. UMAs statement:  Although it is a good suggestion, we have decided not to incorporate it for consistency with the rest of the imports in the other contracts.  Unnecessary modifier in setDelegate and setDelegator  In the Staker contract, the functions setDelegate and setDelegator use the nonReentrant modifier. This is not required as these two functions are only updating the state and cannot be exploited through a reentrancy attack.  Consider removing the nonReentrant modifier from these functions.  Update: Fixed as of commit 04dac164d4c8b026403aecb75730c7bc24f4400c in PR #4156.  Redundant code  Consider making the following changes to eliminate unnecessary code:  In PR #4110, Staker.sol:  line 246: The override keyword can be removed from the withdrawAndRestake function  In PR #4135, VotingV2.sol:  lines 978-980: The uint256(i) casts can be replaced with the variable i because i is already declared as a uint256 type on line 976 line 1045: (rewards) can be changed to rewards  Update: Fixed as of commit d5ab183d3a37a2114db7c3a6269ae66c932d1286 in PR #4162.  Redundant event parameters  In the EmergencyProposer contract, the following events all contain a uint256 lockedTokens parameter:  EmergencyProposalRemoved  EmergencyProposalSlashed  EmergencyProposalExecuted  In each case, when these events are emitted, the value of lockedTokens remains constant for a given proposal, which effectively provides no information because the value never changes.  Update: Acknowledged, and will not fix. UMAs statement:  The value of lockedTokens is constant across all events of the same emergency proposal during its lifecycle. However, to facilitate individual reading of the events, we have opted to leave it as is.  Drift between test and production contracts  commitVote,  revealVote, and  commitAndEmitEncryptedVote functions. While these functions were removed from the version of the  added to the  Consider removing the functions added to the VotingV2Test contract that are no longer present in the VotingV2 contract, and update tests accordingly.  Update: Acknowledged, and will not fix. UMAs statement:  We have decided not to incorporate these changes. Updates to the tests could take a long time compared to the outcome.  Typographical errors  Consider addressing the following typographical errors:  In EmergencyProposer.sol (PR #4128):  line 82: action.. should be action.  In Staker.sol (PR #4110):  line 113: users wallet should be users wallet line 241: msg.sender(voter or delegate) should be msg.sender (voter or delegate) (add 1 space)  In VotingV2.sol (PR #4117):  line 962: be either a should be be either line 1119: removed from should be removed from (delete 1 space)  In VotingV2.sol (PR #4118):  line 249: Must be set to 0x0 for production environments that use live time. refers to the deleted _timerAddress parameter and should be deleted  In VotingV2.sol (PR #4139):  line 499: participates should be participant  In VotingV2.js (PR #4139):  line 3123: not posable should be not possible  Update: Fixed as of commit c311e0a53c8b3a0ddb00fcea79341baca42d142a in PR #4165.  Unnecessary non-empty return value on success  _getPriceOrError in the  returns three values: *  comment on  return a non-empty string even when the price was successfully retrieved. Because the string message  is only used in the error case, users will never see the Returned from previous contract string.  Consider returning an empty string when _getPriceOrError returns true.  Update: Fixed as of commit 0aef75d2fe05488c31b462484c57277ee30e9cb0 in PR #4163.  Unnecessary public visibility in executeEmergencyProposal  In the EmergencyProposer contract, the executeEmergencyProposal function has public visibility. This is not required as the function is not called within the contract.  Consider changing the visibility of the executeEmergencyProposal function to external.  Update: Fixed as of commit fd4813895c1f113f71b03ac9cf79c5ab22710514 in PR #4166.  Unused imports  In the EmergencyProposer contract, the following files are imported but not used:  Constants.sol  OracleAncillaryInterface.sol  AdminIdentifierLib.sol  To improve readability and avoid confusion, consider removing the unused imports.  Update: Fixed as of commit a16bed5abe1de184c689ece8bb5e56e3c183f3e8 in PR #4164.  Unused variables  Within the EmergencyProposer contract, several variables are defined but not used:  The finder state variable is initialized in the constructor, but otherwise is not used  The currentId state variable is never used  To improve readability and avoid confusion, consider removing the unused variables.  Update: Fixed as of commit 5f7567e7c9686ae68565a09fe4db49a2cd29a2f4 in PR #4167.  Conclusions  A single medium severity issue was found. Some recommendations were also made to improve the quality of the codebase.  There were multiple changes regarding VotingV2 that were done to reduce the contract bytecode size as it was reaching the limit. However, some of these changes included removing errors from require statements or grouping multiple conditions into a single statement. These changes make it more difficult for a user to debug failures when interacting with a contract and make the codebase less readable.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#governor-contract-can-create-emergency-proposals", "labels": ["OpenZeppelin"]}, {"title": "Incorrect public visibility", "body": "Incorrect public visibility", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#incorrect-public-visibility", "labels": ["OpenZeppelin"]}, {"title": "Lack of address validation in setExecutor", "body": "Lack of address validation in setExecutor", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#lack-of-address-validation-in-setexecutor", "labels": ["OpenZeppelin"]}, {"title": "Missing documentation", "body": "Several functions within the codebase have missing or incomplete documentation:  In PR #4110:  The _stakeTo function in the Staker contract has no docstring  In PR #4118:  The _previousVotingContract parameter has no corresponding @param line in the VotingV2 constructor docstring  The _getPriceFromPreviousVotingContract function in VotingV2 has no docstring  In PR #4128:  The emergencyPropose function in EmergencyProposer returns a value but its docstring has no corresponding @return line  In PR #4135:  The getCurrentTime function in VotingV2Test has no docstring  The commitVote function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The revealVote function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The commitAndEmitEncryptedVote function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The getPendingPriceRequestsArray function in VotingV2Test has no docstring  The getPriceRequestStatuses function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The retrieveRewardsOnMigratedVotingContract function in VotingV2 returns a value but its docstring has no corresponding @return line  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions that implement sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec). Also consider providing explanatory comments for all events, structs, and storage variables that indicate their intended purpose.  Update: Partially fixed as of commit e729b6ba86529598326ec80083cdfbaf8541b94c in PR #4155. UMAs statement:  It has been decided not to add docstring in the test contracts as this is not done through the rest of the repo.  Missing error messages in require statements  Within VotingV2.sol there are require statements that lack error messages. For instance:  The require statement on line 257 of VotingV2.sol  The require statement on line 265 of VotingV2.sol  The require statement on line 486 of VotingV2.sol  The require statement on line 704 of VotingV2.sol  The require statement on line 928 of VotingV2.sol  The require statement on line 964 of VotingV2.sol  The require statement on line 971 of VotingV2.sol  We are aware error messages were removed to reduce the contract size, however their absence makes interacting or debugging the contract more difficult.  Consider including specific, informative error messages in require statements to improve overall code clarity and to facilitate troubleshooting whenever a requirement is not satisfied.  Update: Fixed as of commit a88a022a9a5b02c9cd0526c7fc2e72a094d02813 in PR #4173.  Missing modifier onlyIfNotMigrated enables new price requests on migrated contracts  onlyIfNotMigrated and its underlying private function  _requireNotMigrated are used to ensure that the voting contract being called is the most recent voting contract deployed. This prevents users from requesting prices and voting on price requests on an outdated voting contract. However,  requestGovernanceAction and  signalRequestsAsSpamForDeletion. Both of these functions will call  Consider adding the onlyIfNotMigrated modifier to the functions requestGovernanceAction and signalRequestsAsSpamForDeletion.  Update: Fixed as of commit e62b25249441fc827f3fd6a336ed31d887c93dad in PR #4157.  Missing test coverage  Pull request #4117 adds a new retrieveRewardsOnMigratedVotingContract function to the VotingV2 contract, in order to enable voters to claim their rewards from the previous voting contract. However, this pull request does not include any test coverage for the newly added function.  Without an automated test for this function, manual testing is required to determine if the current implementation matches the functionss expected behavior, which is error prone and deviates from the goal of continuous integration.  Consider adding test coverage for the new retrieveRewardsOnMigratedVotingContract function.  Update: Resolved, not an issue. Tests were included but fell outside the scope of the audit. UMAs statement:  Test coverage was actually already added for this function, but in a separate PR to when the logic was added. This was added in an adjacent PR where we proposed to decrease the contract bytecode. The test for this logic can be found here.  Nonintuitive behavior of payable transactions in executeEmergencyProposal  In the EmergencyProposal contract, the executeEmergencyProposal function iterates through the transactions submitted on the proposal and executes them. However, only the first element in the array is able to execute a payable transaction, as the first element of the proposed transactions will transfer the entirety of the contract ETH balance, meaning that subsequent transactions will have a value of zero.  Consider documenting this behavior thoroughly as it may not be obvious or intuitive to the proposal submitter.  Update: Fixed as of commit 3b6239aa8b38610247674c952ba7379de898d4b6 in PR #4158. Further clarification provided by UMA regarding the behavior of the executeEmergencyProposal function:  The emergency proposer forwards its entire balance (presumably the amount sent by the caller) to the governor in the first transaction. However, the governor could spend that balance over multiple transactions. The only requirement is that the execution transaction has the total of all ETH sent in all emergency execution transactions.  require statements with multiple conditions  Throughout the codebase there are require statements that contain multiple conditions. For instance:  The require statement on line 202 of Staker.sol  The require statement on line 267 of VotingV2.sol  The require statement on line 762 of VotingV2.sol  The require statement on line 801 of VotingV2.sol  The require statement on line 986 of VotingV2.sol  Bundling multiple conditions into a single require statement reduces the contract size, but also prevents being able to provide a separate error message for each failure case.  Consider isolating each condition in its own require statement, to facilitate specific user-friendly error messages for every required condition.  Update: Acknowledged, and will not fix. UMAs statement:  We wont add this suggestion because of bytecode limitations.  Unlocked Solidity version pragma  There are two locations where the Solidity version used is ^0.8.0:  PR #4128, EmergencyProposerTest.sol, line 2  PR #4121, VotingUpgraderV2.sol, line 2  This version string allows compilation with any version of Solidity from 0.8.0 up to the latest release. This may lead to unexpected behavior if the code is deployed with a different Solidity version than was used during testing. Further, allowing old versions of Solidity leaves the code potentially vulnerable to known security bugs which have already been patched. The official guidance is to always use the latest Solidity release when deploying contracts. When a bug is discovered that affects a range of Solidity versions, the general policy of the Solidity team is to only apply the fix to the latest release (i.e. no backporting of security updates).  Consider locking the version pragma to the same Solidity version used during development and testing. Also consider setting this version to be the latest release.  Update: Fixed as of commit abb30bb58fdf222a6d28363922b179043cea755c in PR #4159 and commit 3be4710c3868ca553e8ab87a815febf939fe021f in PR #4178._  Notes & Additional Information  Lack of immutable identifier  VotingUpgraderV2 contract, the mutable state variables  only set once within the constructor. Consider declaring these state variables as immutable to increase gas efficiency and enhance the clarity of your codebase.  Update: Fixed as of commit 1c77938f762f7bc55a387dbccab11b9a86a464bf in PR #4160.  Misleading documentation  The codebase contains several occurrences of misleading or incorrect documentation:  VotingUpgraderV2:  The comment on  line 41 Existing governor is the only one who can initiate the upgrade appears to be a copy & paste error from  line 38 which is identical. Consider rewriting the comment.  The comment on  line 52 Addresses to upgrade does not apply to the  line 53. Consider rewriting the comment.  The comment on  line 62 Removes an address from the whitelist does not apply to the  Update: Fixed as of commit 77c2370cd2d86920429e658c157941c019fbf697 in PR #4152 and commit 3be4710c3868ca553e8ab87a815febf939fe021f in PR #4178.  Non-explicit imports are used  Non-explicit imports are used inside the codebase, which reduces code readability and could lead to conflicts between names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  For example, the DesignatedVotingV2 contracts import block can be rewritten more explicitly as:  The usage of explicit imports makes it clear that StakerInterface is provided by Stakeable.sol, and that OracleInterfaces is provided by Constants.sol.  Update: Acknowledged, and will not fix. UMAs statement:  Although it is a good suggestion, we have decided not to incorporate it for consistency with the rest of the imports in the other contracts.  Unnecessary modifier in setDelegate and setDelegator  In the Staker contract, the functions setDelegate and setDelegator use the nonReentrant modifier. This is not required as these two functions are only updating the state and cannot be exploited through a reentrancy attack.  Consider removing the nonReentrant modifier from these functions.  Update: Fixed as of commit 04dac164d4c8b026403aecb75730c7bc24f4400c in PR #4156.  Redundant code  Consider making the following changes to eliminate unnecessary code:  In PR #4110, Staker.sol:  line 246: The override keyword can be removed from the withdrawAndRestake function  In PR #4135, VotingV2.sol:  lines 978-980: The uint256(i) casts can be replaced with the variable i because i is already declared as a uint256 type on line 976 line 1045: (rewards) can be changed to rewards  Update: Fixed as of commit d5ab183d3a37a2114db7c3a6269ae66c932d1286 in PR #4162.  Redundant event parameters  In the EmergencyProposer contract, the following events all contain a uint256 lockedTokens parameter:  EmergencyProposalRemoved  EmergencyProposalSlashed  EmergencyProposalExecuted  In each case, when these events are emitted, the value of lockedTokens remains constant for a given proposal, which effectively provides no information because the value never changes.  Update: Acknowledged, and will not fix. UMAs statement:  The value of lockedTokens is constant across all events of the same emergency proposal during its lifecycle. However, to facilitate individual reading of the events, we have opted to leave it as is.  Drift between test and production contracts  commitVote,  revealVote, and  commitAndEmitEncryptedVote functions. While these functions were removed from the version of the  added to the  Consider removing the functions added to the VotingV2Test contract that are no longer present in the VotingV2 contract, and update tests accordingly.  Update: Acknowledged, and will not fix. UMAs statement:  We have decided not to incorporate these changes. Updates to the tests could take a long time compared to the outcome.  Typographical errors  Consider addressing the following typographical errors:  In EmergencyProposer.sol (PR #4128):  line 82: action.. should be action.  In Staker.sol (PR #4110):  line 113: users wallet should be users wallet line 241: msg.sender(voter or delegate) should be msg.sender (voter or delegate) (add 1 space)  In VotingV2.sol (PR #4117):  line 962: be either a should be be either line 1119: removed from should be removed from (delete 1 space)  In VotingV2.sol (PR #4118):  line 249: Must be set to 0x0 for production environments that use live time. refers to the deleted _timerAddress parameter and should be deleted  In VotingV2.sol (PR #4139):  line 499: participates should be participant  In VotingV2.js (PR #4139):  line 3123: not posable should be not possible  Update: Fixed as of commit c311e0a53c8b3a0ddb00fcea79341baca42d142a in PR #4165.  Unnecessary non-empty return value on success  _getPriceOrError in the  returns three values: *  comment on  return a non-empty string even when the price was successfully retrieved. Because the string message  is only used in the error case, users will never see the Returned from previous contract string.  Consider returning an empty string when _getPriceOrError returns true.  Update: Fixed as of commit 0aef75d2fe05488c31b462484c57277ee30e9cb0 in PR #4163.  Unnecessary public visibility in executeEmergencyProposal  In the EmergencyProposer contract, the executeEmergencyProposal function has public visibility. This is not required as the function is not called within the contract.  Consider changing the visibility of the executeEmergencyProposal function to external.  Update: Fixed as of commit fd4813895c1f113f71b03ac9cf79c5ab22710514 in PR #4166.  Unused imports  In the EmergencyProposer contract, the following files are imported but not used:  Constants.sol  OracleAncillaryInterface.sol  AdminIdentifierLib.sol  To improve readability and avoid confusion, consider removing the unused imports.  Update: Fixed as of commit a16bed5abe1de184c689ece8bb5e56e3c183f3e8 in PR #4164.  Unused variables  Within the EmergencyProposer contract, several variables are defined but not used:  The finder state variable is initialized in the constructor, but otherwise is not used  The currentId state variable is never used  To improve readability and avoid confusion, consider removing the unused variables.  Update: Fixed as of commit 5f7567e7c9686ae68565a09fe4db49a2cd29a2f4 in PR #4167.  Conclusions  A single medium severity issue was found. Some recommendations were also made to improve the quality of the codebase.  There were multiple changes regarding VotingV2 that were done to reduce the contract bytecode size as it was reaching the limit. However, some of these changes included removing errors from require statements or grouping multiple conditions into a single statement. These changes make it more difficult for a user to debug failures when interacting with a contract and make the codebase less readable.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#missing-documentation", "labels": ["OpenZeppelin"]}, {"title": "Missing error messages in require statements", "body": "Missing error messages in require statements", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#missing-error-messages-in-require-statements", "labels": ["OpenZeppelin"]}, {"title": "Missing modifier onlyIfNotMigrated enables new price requests on migrated contracts", "body": "Missing modifier onlyIfNotMigrated enables new price requests on migrated contracts", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#missing-modifier-onlyifnotmigrated-enables-new-price-requests-on-migrated-contracts", "labels": ["OpenZeppelin"]}, {"title": "Missing test coverage", "body": "Pull request #4117 adds a new retrieveRewardsOnMigratedVotingContract function to the VotingV2 contract, in order to enable voters to claim their rewards from the previous voting contract. However, this pull request does not include any test coverage for the newly added function.  Without an automated test for this function, manual testing is required to determine if the current implementation matches the functionss expected behavior, which is error prone and deviates from the goal of continuous integration.  Consider adding test coverage for the new retrieveRewardsOnMigratedVotingContract function.  Update: Resolved, not an issue. Tests were included but fell outside the scope of the audit. UMAs statement:  Test coverage was actually already added for this function, but in a separate PR to when the logic was added. This was added in an adjacent PR where we proposed to decrease the contract bytecode. The test for this logic can be found here.  Nonintuitive behavior of payable transactions in executeEmergencyProposal  In the EmergencyProposal contract, the executeEmergencyProposal function iterates through the transactions submitted on the proposal and executes them. However, only the first element in the array is able to execute a payable transaction, as the first element of the proposed transactions will transfer the entirety of the contract ETH balance, meaning that subsequent transactions will have a value of zero.  Consider documenting this behavior thoroughly as it may not be obvious or intuitive to the proposal submitter.  Update: Fixed as of commit 3b6239aa8b38610247674c952ba7379de898d4b6 in PR #4158. Further clarification provided by UMA regarding the behavior of the executeEmergencyProposal function:  The emergency proposer forwards its entire balance (presumably the amount sent by the caller) to the governor in the first transaction. However, the governor could spend that balance over multiple transactions. The only requirement is that the execution transaction has the total of all ETH sent in all emergency execution transactions.  require statements with multiple conditions  Throughout the codebase there are require statements that contain multiple conditions. For instance:  The require statement on line 202 of Staker.sol  The require statement on line 267 of VotingV2.sol  The require statement on line 762 of VotingV2.sol  The require statement on line 801 of VotingV2.sol  The require statement on line 986 of VotingV2.sol  Bundling multiple conditions into a single require statement reduces the contract size, but also prevents being able to provide a separate error message for each failure case.  Consider isolating each condition in its own require statement, to facilitate specific user-friendly error messages for every required condition.  Update: Acknowledged, and will not fix. UMAs statement:  We wont add this suggestion because of bytecode limitations.  Unlocked Solidity version pragma  There are two locations where the Solidity version used is ^0.8.0:  PR #4128, EmergencyProposerTest.sol, line 2  PR #4121, VotingUpgraderV2.sol, line 2  This version string allows compilation with any version of Solidity from 0.8.0 up to the latest release. This may lead to unexpected behavior if the code is deployed with a different Solidity version than was used during testing. Further, allowing old versions of Solidity leaves the code potentially vulnerable to known security bugs which have already been patched. The official guidance is to always use the latest Solidity release when deploying contracts. When a bug is discovered that affects a range of Solidity versions, the general policy of the Solidity team is to only apply the fix to the latest release (i.e. no backporting of security updates).  Consider locking the version pragma to the same Solidity version used during development and testing. Also consider setting this version to be the latest release.  Update: Fixed as of commit abb30bb58fdf222a6d28363922b179043cea755c in PR #4159 and commit 3be4710c3868ca553e8ab87a815febf939fe021f in PR #4178._  Notes & Additional Information  Lack of immutable identifier  VotingUpgraderV2 contract, the mutable state variables  only set once within the constructor. Consider declaring these state variables as immutable to increase gas efficiency and enhance the clarity of your codebase.  Update: Fixed as of commit 1c77938f762f7bc55a387dbccab11b9a86a464bf in PR #4160.  Misleading documentation  The codebase contains several occurrences of misleading or incorrect documentation:  VotingUpgraderV2:  The comment on  line 41 Existing governor is the only one who can initiate the upgrade appears to be a copy & paste error from  line 38 which is identical. Consider rewriting the comment.  The comment on  line 52 Addresses to upgrade does not apply to the  line 53. Consider rewriting the comment.  The comment on  line 62 Removes an address from the whitelist does not apply to the  Update: Fixed as of commit 77c2370cd2d86920429e658c157941c019fbf697 in PR #4152 and commit 3be4710c3868ca553e8ab87a815febf939fe021f in PR #4178.  Non-explicit imports are used  Non-explicit imports are used inside the codebase, which reduces code readability and could lead to conflicts between names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  For example, the DesignatedVotingV2 contracts import block can be rewritten more explicitly as:  The usage of explicit imports makes it clear that StakerInterface is provided by Stakeable.sol, and that OracleInterfaces is provided by Constants.sol.  Update: Acknowledged, and will not fix. UMAs statement:  Although it is a good suggestion, we have decided not to incorporate it for consistency with the rest of the imports in the other contracts.  Unnecessary modifier in setDelegate and setDelegator  In the Staker contract, the functions setDelegate and setDelegator use the nonReentrant modifier. This is not required as these two functions are only updating the state and cannot be exploited through a reentrancy attack.  Consider removing the nonReentrant modifier from these functions.  Update: Fixed as of commit 04dac164d4c8b026403aecb75730c7bc24f4400c in PR #4156.  Redundant code  Consider making the following changes to eliminate unnecessary code:  In PR #4110, Staker.sol:  line 246: The override keyword can be removed from the withdrawAndRestake function  In PR #4135, VotingV2.sol:  lines 978-980: The uint256(i) casts can be replaced with the variable i because i is already declared as a uint256 type on line 976 line 1045: (rewards) can be changed to rewards  Update: Fixed as of commit d5ab183d3a37a2114db7c3a6269ae66c932d1286 in PR #4162.  Redundant event parameters  In the EmergencyProposer contract, the following events all contain a uint256 lockedTokens parameter:  EmergencyProposalRemoved  EmergencyProposalSlashed  EmergencyProposalExecuted  In each case, when these events are emitted, the value of lockedTokens remains constant for a given proposal, which effectively provides no information because the value never changes.  Update: Acknowledged, and will not fix. UMAs statement:  The value of lockedTokens is constant across all events of the same emergency proposal during its lifecycle. However, to facilitate individual reading of the events, we have opted to leave it as is.  Drift between test and production contracts  commitVote,  revealVote, and  commitAndEmitEncryptedVote functions. While these functions were removed from the version of the  added to the  Consider removing the functions added to the VotingV2Test contract that are no longer present in the VotingV2 contract, and update tests accordingly.  Update: Acknowledged, and will not fix. UMAs statement:  We have decided not to incorporate these changes. Updates to the tests could take a long time compared to the outcome.  Typographical errors  Consider addressing the following typographical errors:  In EmergencyProposer.sol (PR #4128):  line 82: action.. should be action.  In Staker.sol (PR #4110):  line 113: users wallet should be users wallet line 241: msg.sender(voter or delegate) should be msg.sender (voter or delegate) (add 1 space)  In VotingV2.sol (PR #4117):  line 962: be either a should be be either line 1119: removed from should be removed from (delete 1 space)  In VotingV2.sol (PR #4118):  line 249: Must be set to 0x0 for production environments that use live time. refers to the deleted _timerAddress parameter and should be deleted  In VotingV2.sol (PR #4139):  line 499: participates should be participant  In VotingV2.js (PR #4139):  line 3123: not posable should be not possible  Update: Fixed as of commit c311e0a53c8b3a0ddb00fcea79341baca42d142a in PR #4165.  Unnecessary non-empty return value on success  _getPriceOrError in the  returns three values: *  comment on  return a non-empty string even when the price was successfully retrieved. Because the string message  is only used in the error case, users will never see the Returned from previous contract string.  Consider returning an empty string when _getPriceOrError returns true.  Update: Fixed as of commit 0aef75d2fe05488c31b462484c57277ee30e9cb0 in PR #4163.  Unnecessary public visibility in executeEmergencyProposal  In the EmergencyProposer contract, the executeEmergencyProposal function has public visibility. This is not required as the function is not called within the contract.  Consider changing the visibility of the executeEmergencyProposal function to external.  Update: Fixed as of commit fd4813895c1f113f71b03ac9cf79c5ab22710514 in PR #4166.  Unused imports  In the EmergencyProposer contract, the following files are imported but not used:  Constants.sol  OracleAncillaryInterface.sol  AdminIdentifierLib.sol  To improve readability and avoid confusion, consider removing the unused imports.  Update: Fixed as of commit a16bed5abe1de184c689ece8bb5e56e3c183f3e8 in PR #4164.  Unused variables  Within the EmergencyProposer contract, several variables are defined but not used:  The finder state variable is initialized in the constructor, but otherwise is not used  The currentId state variable is never used  To improve readability and avoid confusion, consider removing the unused variables.  Update: Fixed as of commit 5f7567e7c9686ae68565a09fe4db49a2cd29a2f4 in PR #4167.  Conclusions  A single medium severity issue was found. Some recommendations were also made to improve the quality of the codebase.  There were multiple changes regarding VotingV2 that were done to reduce the contract bytecode size as it was reaching the limit. However, some of these changes included removing errors from require statements or grouping multiple conditions into a single statement. These changes make it more difficult for a user to debug failures when interacting with a contract and make the codebase less readable.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#missing-test-coverage", "labels": ["OpenZeppelin"]}, {"title": "Nonintuitive behavior of payable transactions in executeEmergencyProposal", "body": "Nonintuitive behavior of payable transactions in executeEmergencyProposal", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#nonintuitive-behavior-of-payable-transactions-in-executeemergencyproposal", "labels": ["OpenZeppelin"]}, {"title": "require statements with multiple conditions", "body": "require statements with multiple conditions", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#require-statements-with-multiple-conditions", "labels": ["OpenZeppelin"]}, {"title": "Unlocked Solidity version pragma", "body": "There are two locations where the Solidity version used is ^0.8.0:  PR #4128, EmergencyProposerTest.sol, line 2  PR #4121, VotingUpgraderV2.sol, line 2  This version string allows compilation with any version of Solidity from 0.8.0 up to the latest release. This may lead to unexpected behavior if the code is deployed with a different Solidity version than was used during testing. Further, allowing old versions of Solidity leaves the code potentially vulnerable to known security bugs which have already been patched. The official guidance is to always use the latest Solidity release when deploying contracts. When a bug is discovered that affects a range of Solidity versions, the general policy of the Solidity team is to only apply the fix to the latest release (i.e. no backporting of security updates).  Consider locking the version pragma to the same Solidity version used during development and testing. Also consider setting this version to be the latest release.  Update: Fixed as of commit abb30bb58fdf222a6d28363922b179043cea755c in PR #4159 and commit 3be4710c3868ca553e8ab87a815febf939fe021f in PR #4178._  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#unlocked-solidity-version-pragma", "labels": ["OpenZeppelin"]}, {"title": "Lack of immutable identifier", "body": "VotingUpgraderV2 contract, the mutable state variables  only set once within the constructor. Consider declaring these state variables as immutable to increase gas efficiency and enhance the clarity of your codebase.  Update: Fixed as of commit 1c77938f762f7bc55a387dbccab11b9a86a464bf in PR #4160.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#lack-of-immutable-identifier", "labels": ["OpenZeppelin"]}, {"title": "Misleading documentation", "body": "The codebase contains several occurrences of misleading or incorrect documentation:  VotingUpgraderV2:  The comment on  line 41 Existing governor is the only one who can initiate the upgrade appears to be a copy & paste error from  line 38 which is identical. Consider rewriting the comment.  The comment on  line 52 Addresses to upgrade does not apply to the  line 53. Consider rewriting the comment.  The comment on  line 62 Removes an address from the whitelist does not apply to the  Update: Fixed as of commit 77c2370cd2d86920429e658c157941c019fbf697 in PR #4152 and commit 3be4710c3868ca553e8ab87a815febf939fe021f in PR #4178.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit imports are used", "body": "inside the codebase, which reduces code readability and could lead to conflicts between names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  For example, the DesignatedVotingV2 contracts import block can be rewritten more explicitly as:  The usage of explicit imports makes it clear that StakerInterface is provided by Stakeable.sol, and that OracleInterfaces is provided by Constants.sol.  Update: Acknowledged, and will not fix. UMAs statement:  Although it is a good suggestion, we have decided not to incorporate it for consistency with the rest of the imports in the other contracts.  Unnecessary modifier in setDelegate and setDelegator  In the Staker contract, the functions setDelegate and setDelegator use the nonReentrant modifier. This is not required as these two functions are only updating the state and cannot be exploited through a reentrancy attack.  Consider removing the nonReentrant modifier from these functions.  Update: Fixed as of commit 04dac164d4c8b026403aecb75730c7bc24f4400c in PR #4156.  Redundant code  Consider making the following changes to eliminate unnecessary code:  In PR #4110, Staker.sol:  line 246: The override keyword can be removed from the withdrawAndRestake function  In PR #4135, VotingV2.sol:  lines 978-980: The uint256(i) casts can be replaced with the variable i because i is already declared as a uint256 type on line 976 line 1045: (rewards) can be changed to rewards  Update: Fixed as of commit d5ab183d3a37a2114db7c3a6269ae66c932d1286 in PR #4162.  Redundant event parameters  In the EmergencyProposer contract, the following events all contain a uint256 lockedTokens parameter:  EmergencyProposalRemoved  EmergencyProposalSlashed  EmergencyProposalExecuted  In each case, when these events are emitted, the value of lockedTokens remains constant for a given proposal, which effectively provides no information because the value never changes.  Update: Acknowledged, and will not fix. UMAs statement:  The value of lockedTokens is constant across all events of the same emergency proposal during its lifecycle. However, to facilitate individual reading of the events, we have opted to leave it as is.  Drift between test and production contracts  commitVote,  revealVote, and  commitAndEmitEncryptedVote functions. While these functions were removed from the version of the  added to the  Consider removing the functions added to the VotingV2Test contract that are no longer present in the VotingV2 contract, and update tests accordingly.  Update: Acknowledged, and will not fix. UMAs statement:  We have decided not to incorporate these changes. Updates to the tests could take a long time compared to the outcome.  Typographical errors  Consider addressing the following typographical errors:  In EmergencyProposer.sol (PR #4128):  line 82: action.. should be action.  In Staker.sol (PR #4110):  line 113: users wallet should be users wallet line 241: msg.sender(voter or delegate) should be msg.sender (voter or delegate) (add 1 space)  In VotingV2.sol (PR #4117):  line 962: be either a should be be either line 1119: removed from should be removed from (delete 1 space)  In VotingV2.sol (PR #4118):  line 249: Must be set to 0x0 for production environments that use live time. refers to the deleted _timerAddress parameter and should be deleted  In VotingV2.sol (PR #4139):  line 499: participates should be participant  In VotingV2.js (PR #4139):  line 3123: not posable should be not possible  Update: Fixed as of commit c311e0a53c8b3a0ddb00fcea79341baca42d142a in PR #4165.  Unnecessary non-empty return value on success  _getPriceOrError in the  returns three values: *  comment on  return a non-empty string even when the price was successfully retrieved. Because the string message  is only used in the error case, users will never see the Returned from previous contract string.  Consider returning an empty string when _getPriceOrError returns true.  Update: Fixed as of commit 0aef75d2fe05488c31b462484c57277ee30e9cb0 in PR #4163.  Unnecessary public visibility in executeEmergencyProposal  In the EmergencyProposer contract, the executeEmergencyProposal function has public visibility. This is not required as the function is not called within the contract.  Consider changing the visibility of the executeEmergencyProposal function to external.  Update: Fixed as of commit fd4813895c1f113f71b03ac9cf79c5ab22710514 in PR #4166.  Unused imports  In the EmergencyProposer contract, the following files are imported but not used:  Constants.sol  OracleAncillaryInterface.sol  AdminIdentifierLib.sol  To improve readability and avoid confusion, consider removing the unused imports.  Update: Fixed as of commit a16bed5abe1de184c689ece8bb5e56e3c183f3e8 in PR #4164.  Unused variables  Within the EmergencyProposer contract, several variables are defined but not used:  The finder state variable is initialized in the constructor, but otherwise is not used  The currentId state variable is never used  To improve readability and avoid confusion, consider removing the unused variables.  Update: Fixed as of commit 5f7567e7c9686ae68565a09fe4db49a2cd29a2f4 in PR #4167.  Conclusions  A single medium severity issue was found. Some recommendations were also made to improve the quality of the codebase.  There were multiple changes regarding VotingV2 that were done to reduce the contract bytecode size as it was reaching the limit. However, some of these changes included removing errors from require statements or grouping multiple conditions into a single statement. These changes make it more difficult for a user to debug failures when interacting with a contract and make the codebase less readable.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary modifier in setDelegate and setDelegator", "body": "Unnecessary modifier in setDelegate and setDelegator", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#unnecessary-modifier-in-setdelegate-and-setdelegator", "labels": ["OpenZeppelin"]}, {"title": "Redundant code", "body": "Consider making the following changes to eliminate unnecessary code:  In PR #4110, Staker.sol:  line 246: The override keyword can be removed from the withdrawAndRestake function  In PR #4135, VotingV2.sol:  lines 978-980: The uint256(i) casts can be replaced with the variable i because i is already declared as a uint256 type on line 976 line 1045: (rewards) can be changed to rewards  Update: Fixed as of commit d5ab183d3a37a2114db7c3a6269ae66c932d1286 in PR #4162.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#redundant-code", "labels": ["OpenZeppelin"]}, {"title": "Redundant event parameters", "body": "In the EmergencyProposer contract, the following events all contain a uint256 lockedTokens parameter:  EmergencyProposalRemoved  EmergencyProposalSlashed  EmergencyProposalExecuted  In each case, when these events are emitted, the value of lockedTokens remains constant for a given proposal, which effectively provides no information because the value never changes.  Update: Acknowledged, and will not fix. UMAs statement:  The value of lockedTokens is constant across all events of the same emergency proposal during its lifecycle. However, to facilitate individual reading of the events, we have opted to leave it as is.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#redundant-event-parameters", "labels": ["OpenZeppelin"]}]