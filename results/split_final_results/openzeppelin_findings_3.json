[{"title": "Lack of documentation", "body": "Throughout the codebase, we found several instances where documentation was lacking. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted. For instance:  The functions and variables in the OgvStaking contract lack documentation.  The functions and some variables in the RewardsSource contract lack documentation.  The setInflation function should explicitly state:  The start time of the first slope may lie in the future, which allows an implicit configuration of a zero slope before the first start time. The end time of the end slope will always be set to infinity (type(uint64).max), which implies that unless Slope.ratePerDay is set to zero in the last slope a potentially unbounded number of OGV tokens could be minted.  In the OgvStaking contract, when a user stakes OGV tokens before the epoch time is reached, the tokens are locked for the specified duration after epoch. Hence, the tokens are locked for longer than expected. Users might be unaware of this behavior, so consider documenting it explicitly.  Consider thoroughly documenting the aforementioned code using the NatSpec format to increase the understandability of the codebase.  Update: Fixed in pull request #102.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#lack-of-documentation", "labels": ["OpenZeppelin"]}, {"title": "Voting token name and symbol are mixed up", "body": "In the OgvStaking contract the return values of the name and symbol functions are mixed up. Also, following this blog post from March 29, 2022, it is stated that the token symbol will be veOGV instead of OGVe.  Consider swapping the return values to correctly reflect the token parameters as well as renaming the symbol to match the announcement.  Update: Fixed in pull request #93.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#voting-token-name-and-symbol-are-mixed-up", "labels": ["OpenZeppelin"]}, {"title": "Gas savings", "body": "Throughout the codebase we found some instances that could be improved to save gas:  In the setInflation function of the RewardsSource contract, gas can be saved with the following changes:  Consider writing slopes.length to the stack with uint256 slopesLength = slopes.length; and using that variable instead of reading from memory each time. Additionally, the last overwrite of minSlopeStart for index i = slopes.length - 1 is not needed. Consider moving it within the condition two lines above for a minor gas optimization.  To calculate staking rewards the internal function _calcRewards iterates through an array of up to 48 slopes to compute the results that have been accumulated since it was last called. While the computation appears to be correct, many conditions lead to an unnecessary iteration of the entire array:  The gas optimization to return zero for the nextSlopeIndex has not been applied consistently, it is missing for the condition last >= block.timestamp. The condition rangeEnd < slopeStart leads the loop to continue with the next iteration, while the correct behavior would be to break, because no future slope can match a rangeEnd in the past. The condition slopeEnd < rangeEnd will never be true and is not the condition that corresponds to the comment No future slope could match. Consider replacing it with the condition rangeEnd < slopeEnd which holds when no future slope can match. To skip slope iterations when range limits match the slope limits, the conditions need to include the equal case. Hence, change to rangeStart >= slopeEnd, rangeEnd <= slopeStart, and slopeEnd >= rangeEnd.  Consider applying the above changes to make the code more gas efficient while maintaining its readability.  Update: Partially fixed in pull request #86 and #87. The unnecessary slopeEnd < rangeEnd check is unchanged. In addition, the slope iterations are still not skipped when range limits match slope limits.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#gas-savings", "labels": ["OpenZeppelin"]}, {"title": "Undocumented magic numbers", "body": "In the Governance contract the constructor uses several magic numbers to define key characteristics of the deployed system. This includes proposal delay, voting period, and voting threshold as well as the time extension in the case of a late quorum. Moreover, the magic numbers lack documentation and implicitly assume a fixed block time of 15 seconds.  Consider documenting these numbers more explicitly by describing their purpose and provide contextual information regarding time spans and average block times, such that it is easier for anyone to understand the characteristics.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#undocumented-magic-numbers", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "In RewardsSource the following imports are not used:  ERC20Votes  ERC20Permit  PRBMathUD60x18  Consider removing the imports.  ogv. However, no ERC20-functions are called on it. Consider declaring  Update: Fixed in pull request #94.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Missing license identifier", "body": "In the RewardsSource.sol and OgvStaking.sol files, a SPDX-license-identifier comment is missing.  Consider adding the MIT license identifier in accordance with the rest of the codebase.  Update: Fixed in pull request #95.", "html_url": "https://blog.openzeppelin.com/origin-governance-audit#missing-license-identifier", "labels": ["OpenZeppelin"]}, {"title": "Operators are implicitly trusted", "body": "In the current design of the payment system, the operator role wields a significant amount of power. A buyer cannot initiate a payment without the approval of an operator, and a seller must rely on an operator to vouch for the transfer of their asset.  to be good actors in the system. However, there are four possible scenarios where operators could behave maliciously:  Operator as a buyer: Both the buyer and operator need to agree upon the PaymentInput data. But theres nothing restricting an operator from also acting as a buyer, in which case they can approve their own transactions. More importantly, acting as a buyer an operator could defraud a seller by obtaining a refund even though the asset was received. After the sellers asset is transferred, the operator could either create a signed AssetTransferResult with the wasSuccessful field set to false, or not sign an AssetTransferResult at all. The operator could then call refund or refundAndWithdraw after the payment window has expired, and obtain their full payment amount even though the sellers item was successfully transferred.  Operator as a seller: The contracts do not restrict an operator from also being a seller in a transaction they are responsible for monitoring. In this case, an operator could register as a seller and post an item for sale. After a buyer initiates payment, the operator could craft an AssetTransferResult with the wasSuccessful field set to true, but then choose not to transfer the asset. The operator could then call finalize or finalizeAndWithdraw with the signed AssetTransferResult, prior to the payment window expiring, thus receiving payment for an asset that was never delivered.  Operator colluding with a buyer: Similar to the case where the operator and the buyer are the same, an operator could work together with a buyer in an attempt to obtain a refund for a transferred asset. As before, the operator could create a signed AssetTransferResult with wasSuccessful set to false, even though the asset was transferred.  Operator colluding with a seller: Similar to the case where the operator and the seller are the same, an operator could work in conjunction with a seller who owns an item of value. As before, the operator would create a signed AssetTransferResult with wasSuccessful set to true, even though the seller did not transfer the asset.  An operator should always be an observer of transactions and never participate as a buyer or seller. To prevent misuse of the power granted to an operator, consider adding checks which ensure that the buyer and seller addresses in the PaymentInput struct can never be the same as the operator address for the same payment transaction. Also consider revisiting the trust assumptions that allow an operator entity to independently vouch for the success or failure of an asset transfer via the AssetTransferResult mechanism, and how the system can guarantee that an asset transfer result is always produced.  Update: Not an issue. After discussing with the Freeverse team, we have concluded that the system is designed with a trust assumption that the role of operator will always be in the favor of the system. Additionally, the team has applied the fixes in the codebase to ensure that an operator cannot be a buyer or a seller, this is fixed as of commit 714e99e of PR #2.  Medium Severity", "html_url": "https://blog.openzeppelin.com/freeverse-audit#operators-are-implicitly-trusted", "labels": ["OpenZeppelin"]}, {"title": "Potential loss of access to funds if payment window is incorrectly set", "body": "The _paymentWindow variable within the PaymentsERC20 contract stores the maximum amount of time allowed for an asset transfer to be completed once a payment starts. The default value is 30 days and during this time, the buyers funds remain locked. If the buyer tries to obtain a refund before the payment window has expired, the refund request will not be accepted.  The PaymentsERC20 contract has a setPaymentWindow function that allows the contract owner to adjust the payment window for future payments. This function does not impose a limit on the chosen window size, making it possible to set the value so high that obtaining a refund from an asset transfer that failed to complete would effectively be impossible.  To prevent potential loss of access to funds, within the setPaymentWindow function, consider adding an upper limit on the payment window duration that the function will accept.  Update: Fixed as of commit a476fa1 of PR #3.  Low Severity", "html_url": "https://blog.openzeppelin.com/freeverse-audit#potential-loss-of-access-to-funds-if-payment-window-is-incorrectly-set", "labels": ["OpenZeppelin"]}, {"title": "Duplicate code", "body": "Duplication of code is error prone because the repeated implementations can get out of sync as the codebase evolves, potentially leading to unexpected behavior. There two instances of code duplication in the PaymentsERC20 contract:  The majority of the code in the pay and relayedPay functions in PaymentsERC20 is duplicated. Once the initial checks are completed in each case, all of the remaining steps are identical. Lines 102-123 in relayedPay are nearly identical to lines 141-162 in pay, with the only difference being line 106 vs line 145, which are functionally equivalent in setting the operator. Consider creating a shared private function for this duplicate code.  The maxFundsAvailable function makes calls to the external ERC20 contract in order to obtain the buyers approved spend allowance for the PaymentERC20 contract and the buyers token balance in their wallet. To obtain allowance and balance information from the external contract, PaymentERC20 implements allowance and erc20BalanceOf view functions that make respective calls to the allowance and balanceOf functions of the IERC20 interface. However, when maxFundsAvailable performs the allowance and balance queries, it calls the provided allowance function, but not the provided balanceOf function. In the latter case, IERC20.balanceOf() is called directly, duplicating the code in the erc20BalanceOf function. Consider using the erc20BalanceOf function to obtain the external token balance erc20Balance.  Update: Fixed as of commit 645f3f4 of PR #1.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#duplicate-code", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent and lack of indexed event parameters", "body": "Paid event has an unindexed  BuyerRefunded and  Payin events.  DefaultFeesCollector and  UniversalFeesCollector events do not apply the  DefaultOperator and  UniverseOperator events do not apply the  Indexed parameters are useful for quick offchain indexing of logs. Consider indexing applicable event parameters to support the searching and filtering abilities of offchain services.  Update: Fixed as of commit 745c035 of PR #4.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#inconsistent-and-lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "The following functions in the codebase lack documentation:  All the functions, events, and state variables in the FeesCollectors contract are missing docstrings  All the functions, events, and state variables in the Operators contract are missing docstrings  The PaymentInput and AssetTransferResult structs in the IEIP712Verifier interface have no comments explaining any of the fields  None of the events in the IPaymentsERC20 interface have any documentation  There are no docstrings in the MyToken contract to explain the contracts purpose  This lack of documentation hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Fixed as of commit d311775 of PR #5. However, there are a few typographical errors in the newly added docstrings:  In the docstring above the MyToken contract, implementation is misspelled as implentation  In the docstring above the AssetTransferResult struct, ASSET_TRANSFERRING is misspelled as ASSET_TRANSFERING; PR #26 moves this line to ISignableStructs.sol", "html_url": "https://blog.openzeppelin.com/freeverse-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "No check that seller is already registered", "body": "The registerAsSeller function in the PaymentsERC20 contract emits a NewSeller event when a user calls it. There is no check in registerAsSeller to determine if a user address is already registered, so this function will emit a NewSeller event every time it is called. Depending on how the event log is used, this may lead to incorrect behavior by external observers of the contract if a user calls the function more than once.  Consider checking the existing bool value of _isRegisteredSeller when registerAsSeller is called, and reverting if the user is already registered.  Update: Fixed as of commit 6c7a698 of PR #6.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#no-check-that-seller-is-already-registered", "labels": ["OpenZeppelin"]}, {"title": "Naming issues hinder code understanding and readability", "body": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Some suggestions are:  States enum in the IPaymentsERC20 interface should be State enum  In the EIP712Verifier, the variable name inp is confusing as it indicates both PaymentInput and AssetTransferResult structs. Consider having different names for different parameters.  Throughout the PaymentsERC20 contract, the local variable name for Payment struct is p.  Consider having a meaningful naming convention for variables instead of using single letters such as p or abbreviated words such as inp.  Update: Fixed as of commit 4c2dc66 of PR #7.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#naming-issues-hinder-code-understanding-and-readability", "labels": ["OpenZeppelin"]}, {"title": "Registration process is not clearly documented", "body": "The PaymentsERC20 contract allows a seller to register themselves by calling the registerAsSeller function. However, the system allows purchase of assets from unregistered sellers if the _isSellerRegistrationRequired flag is not set. In the scenario where _isSellerRegistrationRequired is set to false, any calls to registerAsSeller would be meaningless and would result in seller paying for the gas used for making this unnecessary transaction.  The codebase fails to document the meaning of registration, the advantage of being a registered seller, and why is it okay to disable this process.  Consider adding proper documentation as to why this process is required in the system and the scenarios in which it can be changed or disabled.  Update: Fixed as of commit 65269d9 of PR #8. However, there is a typographical error in the newly added docstring. In the README and docstring in the PaymentsERC20 contract, executed is misspelled as exectuted.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/freeverse-audit#registration-process-is-not-clearly-documented", "labels": ["OpenZeppelin"]}, {"title": "Constant set by constructor not marked immutable", "body": "The PaymentsERC20 contract sets the value of the _erc20 storage variable at construction time and has no mechanism to change the value afterward. This variable can be marked as immutable to save on gas costs when reading the value.  Consider marking this variable immutable in order to save users gas fees.  Update: Fixed as of commit 0f8028c of PR #10.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#constant-set-by-constructor-not-marked-immutable", "labels": ["OpenZeppelin"]}, {"title": "Contract file and contract name do not match", "body": "The ERC20Token.sol file, which is used only for test purposes and is not deployed, contains the MyToken contract. To follow common coding conventions, consider renaming ERC20Token.sol to MyToken.sol so that the contract name and the filename are the same.  Update: Fixed as of commit 2172356 of PR #11.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#contract-file-and-contract-name-do-not-match", "labels": ["OpenZeppelin"]}, {"title": "Use of draft EIP code", "body": "uses OpenZeppelins  implementation of the draft  EIP712 standard for hashing and signing of struct data. Until the EIP712 proposal is finalized, it is possible that the standard will change, which could require updates to the  Consider refactoring the code to allow EIP712Verifier to be deployed as a separate contract that could be upgraded in isolation in the event of a change to the draft EIP712 standard.  Update: Fixed as of commit d08c9f0 of PR #26.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#use-of-draft-eip-code", "labels": ["OpenZeppelin"]}, {"title": "Imports not grouped together", "body": "The following contracts have a docstring inserted in between the import statements:  EIP712Verifier.sol  import on line 16 is separated from the imports on lines 4-5  IPaymentsERC20.sol  import on line 41 is separated from the imports on lines 4-6  PaymentsERC20.sol  import on line 41 is separated from the imports on lines 4-6  To favor code clarity, consider rearranging the file contents in each case to group all of the import statements together.  Update: Fixed as of commit 2bba4d4 of PR #13.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#imports-not-grouped-together", "labels": ["OpenZeppelin"]}, {"title": "Misleading documentation", "body": "For clarity, consider revising the following comments which may cause confusion:  In IEIP712Verifier.sol, lines 10-11 state:  However, the contract defines two structures and two verify functions, not just PaymentInput and verifyPayment as indicated by the docstring.  However, the contract defines two structures and two verify functions, not just PaymentInput and verifyPayment as indicated by the docstring.  In PaymentsERC20.sol, lines 18-20:  This docstring could be misinterpreted to mean that both buyerSig and operatorSig are required to start a payment, i.e. that both functions must be called. If buyerSig is provided, the operators signature is provided by signing the relayedPay transaction, and similarly if operatorSig is provided, the buyers signature is provided by signing the pay transaction. This comment is also repeated in IPaymentsERC20.sol and README.md.  Update: Fixed as of commit f580cf5 of PR #14.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Mismatched parameter name between interface and contract", "body": "AssetTransferResult calldata inp, but the corresponding  names the same parameter result instead of  @inheritdoc tag used for  To avoid confusion, consider renaming these parameters so that the names match each other, and match the corresponding docstring @param tag.  Update: Fixed as of commit 4c2dc66 of PR #7.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#mismatched-parameter-name-between-interface-and-contract", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Consider addressing the following typographical errors:  In IPaymentsERC20.sol:  line 12: success of failure should be success or failure  line 16: all of buyers received tokens should be all tokens received from the buyer  line 24: has non-zero local balance should be has a non-zero local balance  line 28: States Machine should be State Machine  line 34: the a payment should be the payment  line 36: throught should be throughout  line 47: Payin should be PayIn  line 232: ot check should be to check  In PaymentsERC20.sol:  line 12: success of failure should be success or failure  line 16: all of buyers received tokens should be all tokens received from the buyer  line 24: has non-zero local balance should be has a non-zero local balance  line 28: States Machine should be State Machine  line 34: the a payment should be the payment  line 36: throught should be throughout  In README.md:  line 16: success of failure should be success or failure  line 19: recevied should be received  line 20: all of buyers received tokens should be all tokens received from the buyer  line 28: has non-zero local balance should be has a non-zero local balance  line 32 and line 46: States Machine should be State Machine  line 40: throught should be throughout  Update: Fixed as of commit fa5cb16 of PR #15.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary use of uint16", "body": "feeBPS variable whose type is  expects feeBPS to be a uint256 value, so  an explicit cast to uint256 is performed when the function is called by  Consider changing the feeBPS variable type from uint16 to uint256.  Update: Fixed as of commit 3e21d35 of PR #17.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#unnecessary-use-of-uint16", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary inheritance", "body": "The FeesCollectors contract inherits from the Operators contract, effectively concatenating the two independent contracts. These contracts do not share any state or functions that require the use of inheritance.  Ownable, and  PaymentsERC20 to inherit from both  Update: Fixed as of commit cf5e0ea of PR #18.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#unnecessary-inheritance", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "To improve readability and avoid confusion, consider removing the following unused imports:  In the IPaymentsERC20 contract:  IERC20.sol  FeesCollectors.sol  EIP712Verifier.sol  In the IEIP712Verifier contract:  draft-EIP712.sol  ECDSA.sol  Update: Fixed as of commit b633fdc of PR #19.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "No functionality to withdraw portion of funds", "body": "finalizeAndWithdraw,  refundAndWithdraw or the  withdraw functions which in-turn calls the private  _withdraw function. This  checks the balance of the caller and  transfers the entire balance to the callers address.  Although there are no security concerns with withdrawing the entire balance, it might be advisable to have an option of withdrawing a portion of funds to provide a better user experience. For example, if a user has made a profit on selling an asset, they might want to withdraw only the profitable amount and reuse the remaining funds for future trades. In the current scenario, the user would be forced to take out all of their balance and then transfer funds back to the system in order to engage with future trades, and subsequently pay for the gas for making the additional transaction.  Consider adding functionality that allows the users to withdraw a portion of their funds.  Update: Fixed as of commit 20af988 of PR #23.", "html_url": "https://blog.openzeppelin.com/freeverse-audit#no-functionality-to-withdraw-portion-of-funds", "labels": ["OpenZeppelin"]}, {"title": "Invalid Beneficiary", "body": "The setPaymentDelegation function of the Accounts contract allows a validator to set the zero address as their beneficiary with a non-zero payment fraction. In this scenario, the reward distribution mechanism will attempt to mint tokens to the zero address, which will revert. Consequently, neither the validator nor their group will receive the epoch payment.  Consider preventing validators from setting a zero beneficiary with a non-zero payment fraction. Additionally, in the interest of clearly signaling user intentions, consider introducing a deletePaymentDelegation function so the setPaymentDelegation function can disallow any zero beneficiary.  Update: Fixed in pull request #9283.  Low Severity", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part1#invalid-beneficiary", "labels": ["OpenZeppelin"]}, {"title": "Version not incremented", "body": "PR #8993 adds new rewards delegation functionality to the Accounts and Validators contracts, but does not increment the version functions. Consider incrementing the MINOR version of both contracts in line with the contract versioning system.  Update: Fixed in pull request #9256. The PR also increments the MAJOR version of the ExchangeBRL contract.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part1#version-not-incremented", "labels": ["OpenZeppelin"]}, {"title": "Comments should be linted", "body": "In PR #9041, both the ExchangeBRL and StableTokenBRL contracts have inconsistent indentation.  Consider linting the comments in order to increase readability of the codebase.  Update: Fixed in pull request #9285.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part1#comments-should-be-linted", "labels": ["OpenZeppelin"]}, {"title": "Inadequate NatSpec", "body": "We identified the following instances of incorrect or incomplete NatSpec comments:  in the getPaymentDelegation function of the Accounts contract:  the @param account statement is missing the @return statement describes both values returned as a single value instead of two separate values the @return statement should note that the fraction parameter is a FixidityLib value, or has 24 decimals of precision  in the initialize function of the Exchange contract:  the @param stableTokenIdentifier statement is in the wrong order.  throughout the codebase, the getVersionNumber functions share a common issue:  the @return statement describes all four values returned as a single value instead of four separate values during this review we identified this issue in the ExchangeBRL, StableTokenBRL, Validators, Exchange, and ExchangeEUR contracts this issue is replicated across the codebase and is found in code outside the scope of this review  In order to keep the codebase well documented, consider updating the NatSpec comments.  Update: Partially fixed in pull request #9270. The remaining fixes are being tracked in issue #9242 and issue #9268.  The Celo team states:  The issue with @return statements exists throughout the contracts code base, including many contracts that were outside the scope of this audit. For consistency, and to get them all in one go, well keep singular @returns for now, but have created #9268 to fix this throughout our smart contracts in the immediate future.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part1#inadequate-natspec", "labels": ["OpenZeppelin"]}, {"title": "Recalculated constant", "body": "The grandamento test file imports the SECONDS_IN_A_WEEK variable, but recalculates its value multiple times. For improved code clarity, consider using the constant.  Update: Fixed in pull request #9269.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part1#recalculated-constant", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "The codebase contains the following typographical errors:  FixidyLib should be FixidityLib  vaidator should be validator  Consider correcting these errors to improve code readability.  Update: Fixed in pull request #9250.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part1#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Improper use of solhint-disable", "body": "solhint-disable will disable a feature of solhint until it is re-enabled with solhint-enable or until the end of the file. Using solhint-disable with an unmatched solhint-enable creates code that is prone to errors when updating it in the future.  PR #9041, both the  ExchangeBRLProxy and  StableTokenBRLProxy contracts use  Update: Issue is scheduled for a future fix, it is tracked by issue #9245.  The Celo team states:  Agreed that solhint-disable-next-line would be better. That said, the current risk of these unmatched solhint-disableds causing problems is minimal  these contracts exist solely to create new named proxies, and are meant to have exactly the code of the original Proxy contract, so they inherit from it and add nothing new, and we dont expect ever modifying them to add anything new.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part1#improper-use-of-solhint-disable", "labels": ["OpenZeppelin"]}, {"title": "Missing oracle can cause unexpected behavior", "body": "Prior to pull request #9367, the addToken function in the Reserve contract checked that an oracle exists for the token being added, and the oracle returns a non-zero exchange rate. These checks ensured that every token in the _tokens array had a corresponding oracle.  With the oracle checks removed from addToken by this pull request, it is possible to enter a state where the token has been added but the oracle doesnt exist yet. However, the getReserveRatio function in the Reserve contract assumes that every token has a corresponding oracle that returns non-zero exchange rate values. If no oracle exists for a specific token, the converted price calculation will result in a divide-by-zero error.  The following contracts also contain code which can incorrectly divide by zero if queried with an oracle that is returning zero:  getGasPriceMinimum of GasPriceMinimum  getTargetTotalEpochPaymentsInGold of EpochRewards  Consider implementing additional logic that excludes tokens without oracles from the reserve ratio calculation, as well as including checks to ensure helpful errors are thrown rather than divide-by-zero errors.  Update: Partially fixed. The getReserveRatio function was fixed in PR #9527. Both getGasPriceMinimum and getTargetTotalEpochPaymentsInGold remain unchanged. Celos statement for this issue:  Updating getGasPriceMinimum is not critical, as the only reasonable behavior when there is no oracle report is to revert (could be nicer to fail with a relevant require message, but this is an edge case). Updating getTargetTotalEpochPaymentsInGold is not necessary as it only ever converts from cUSD (not other cStables), which already has an oracle rate.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part2#missing-oracle-can-cause-unexpected-behavior", "labels": ["OpenZeppelin"]}, {"title": "Incorrect version number", "body": "Pull request #9252 changes the behavior of the setSpread function in Exchange.sol, but does not update the version reported by the getVersionNumber function.  Consider incrementing the patch number returned by getVersionNumber in order to adhere to the smart contract release process.  Update: Fixed in PR #8334.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part2#incorrect-version-number", "labels": ["OpenZeppelin"]}, {"title": "Documentation mismatch", "body": "it is required to have at least one oracle report. The documentation points to  line number 223 in the  #9367 removed that code from the  Consider updating the online Celo documentation to accurately reflect the new behavior of the addToken function.  Update: Fixed in PR #312 of the celo-org/docs repository.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part2#documentation-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent code", "body": "In pull request #9252, code was added in order to ensure newly set spread values are valid. The change updated the setSpread function in the Exchange contract.  Similar to the Exchange contract, the GrandaMento contract includes an implementation of setSpread which already has a bounds check, however the two implementations differ in terms of logic and error messages.  In favor of consistent code across the repository, consider updating the code to make both implementations match.  Update: Fixed in PR #9459.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part2#inconsistent-code", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent test coverage", "body": "#9369 introduced a new  getPendingWithdrawals function can run out of gas if the number of pending withdrawals is excessive. In the pull request, a new test case for  lockedgold.ts, but the corresponding test for  To improve code coverage, consider restoring the test that was removed and providing equivalent test cases for both functions.  Update: Fixed in PR #9460.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-7-part2#inconsistent-test-coverage", "labels": ["OpenZeppelin"]}, {"title": "Malicious user can register a scanner under any owner", "body": "The ScannerRegistryCore contract implements the functionality to allow the registration and minting of new scanners.  New scanners are meant to be registered by either calling the register function from the scanners address or through the trusted forwarder, or by the admin when calling the adminRegister function. These functions then call the _register function which implements the rest of the registration.  However, this _register function is marked as a public function, meaning that any user could skip the checks and register a scanner in the same way as the admin does it.  In favor of restricting the admin functionalities to regular users, consider changing the visibility of the _register function to internal.  Update: Fixed on commit 11bb25a9034f19be44315203713bf94d138698b8 in pull request 49.  Medium Severity  __gap missing in upgradeable contracts  The contracts VestingWallet and VestingWalletV2 do not contain a __gap variable although they are upgradeable.  Consider adding a correct __gap variable to these contracts, or documenting a plan for managing storage collisions when upgrading the Vesting Wallet. Additionally, since upgradeable contracts with __gaps are used in many places within the contracts, consider implementing quality control steps for upgradeable contract development. For instance, make it a priority to check all __gap variables before pushing any new code commits, as well as leaving comments next to all variables in a contract indicating which storage slots they belong in. Consider leaving deprecated variables in the code, and leaving comments about the fact that they were deprecated to avoid confusion for future developers. Finally, consider implementing a predictable inheritance structure for all contracts and documenting it within each contract. Implementing these steps will reduce the surface for error and in the long run may save developer time by removing confusion about the storage layout of the contracts.  Update: Fixed on commit 9b37ac5d4b852954552c69e33bf7f35de051d5b3 in pull request 50. The original VestingWallet contract without upgradeability slots was kept as the VestingWalletV0 contract and further extensions of it now include the __gap slots variable.  Lack of event emission after sensitive actions  The following function do not emit relevant events after executing sensitive actions.  The sweep function of the FortaStaking contract, after the SWEEPER_ROLE role withdraws all mistakenly sent tokens to the contract.  Consider emitting events after sensitive changes take place (including the first event emission in the constructor when appropriate), to facilitate tracking and notify off-chain clients following the contracts activity  Update: Fixes on commit d0934556c8331ccb806a606622bbd8b9f10c301b in pull request 51.  Unclear initialization of inherited contracts  The StakeAwareUpgradeable contract is inherited by a few contracts, such as the ScannerRegistryEnable contract, and therefore any other contract that inherits from those, such as the ScannerRegistry contract.  However, even though the ScannerRegistry contract implements the initialize function that initializes all the respective imports, there is no call to the __StakeAwareUpgradeable_init function from the StakeAwareUpgradeable contract. Furthermore, there is no single location in the whole codebase that would call the initializer to set the respective stake controller.  Moreover, the FortaStaking contract is inheriting the functionalities from the ERC1155SupplyUpgradeable contract but its __ERC1155Supply_init function is never initialized.  Consider calling all the respective initialization functions when inheriting functionalities from other contracts.  Update: Fixed on commit b7f5eb26fdb87a5c45392d6a6468d873a86ea450 in pull request 52. More documentation was added to describe the lack of initialization on upgraded contracts.  Lack of validation  Throughout the codebase, there are places where a proper input/output validation is lacking. In particular:  In the Router contract, when adding or removing an element from the routing table, the methods return a boolean to inform the success of the call, but this output is never used or validated by the Router contract.  Similarly to the case from above, in the ScannerRegistryManaged contract, when adding or removing a manager from storage, its methods output is never validated.  In Routed.sol, the variable assignment in lines 13 and 25 are not validating if the address corresponds to a contract or if it is the zero address.  In the FortaStaking contract it is possible to initiate a withdrawal and set in storage a deadline for a inexistent stake, emit several events during the process, and trigger an external hook.  A lack of validation on user-controlled parameters may result in erroneous or failing transactions that are difficult to debug. To avoid this, consider adding input and output validation to address the concerns raised above and in any other place when appropriate.  Update: Partially fixed on commit 85d6bd7518efd3a759789225b7dc07d4c26fa7fd in pull request 53. The team has acknowledged the lack of validation but it will not be enforced on all the mentioned places. The teams response for the issue:  NOTE: ignoring EnumerableSet.add() bool output; We dont care if already added.  Staked funds might get soft-stuck  FortaStaking contract implements the functionality to allow holders to stake their funds (vested or not) into a subject and collect rewards by doing so. The contract uses 2 different accounting systems to handle the assets: a  Distribution type based for the asset in stake units and the inner  ERC1155 accounting system for the associated shares. When a user  stakes, the contract  mints new active shares. When a user  wants to withdraw, the contract  burns those active shares and  mints inactive ones.  When minting these ERC1155, the _doSafeTransferAcceptanceCheck hook will get triggered and it would check if the destinatary is a ERC1155Receiver implementer or not when it detects that the address has code in it.  However, if the minting process happens during the constructor of a non-fully compatible ERC1155 wallet, the FortaStaking contract would treat the destinatary as a regular EOA during the minting process. Then, once it is deployed, the wallet will not be able to mint new shares due to the same _doSafeTransferAcceptanceCheck hook as it will get triggered, failing at the same validation that was skipped on the first deposit.  This means that when the wallet starts the process to withdraw the assets, the transaction will fail during the minting of inactive shares. Nevertheless, the user may transfer those active shares to a fully compatible wallet to then initiate the withdrawal process once again.  In favor of improving the usability of the protocol, consider documenting the requirements that 3rd party wallets would need to be able to fully interact with it either during the deployment stage or once it has been deployed.  Update: Fixed on commit d13be24e8b84ffc59eb04ded2d03841a69996434 in pull request 54.  L2 tokens could get stuck  The release function in the StakingEscrow contract allows users to send tokens from the StakingEscrow contract to another account on L2. However, in order to preserve the vesting schedule, FORT tokens are NOT allowed to be transferred unless they have been accounted for by pendingReward.  Typically if tokens are received as rewards from the staking contract, pendingReward will be increased. However, if tokens are sent directly to this contract, it will not increase pendingReward and the tokens will not be transferable. Instead, users will only be able to bridge their FORT tokens, subjecting them to the vesting schedule on L1.  Consider implementing some accounting to allow for users to transfer FORT tokens to this contract, and afterwards transfer them out via the release function. Alternatively, consider making a clear warning to any StakingEscrow contract users that FORT tokens transferred to the contract will not be release-able and will be subjected to vesting.  Update: Fixed on commit 9d821024623005808eddd6765d8260f1d2a2301d in pull request 55. A warning has been added to let users know about this behavior.  Slashing process could be reverted  When a certain subject under-performed or has done actions against the correct operation of the protocol, the SLASHER_ROLE role can slash that subject and all the users that have staked on it by calling the slash function from the FortaStaking contract. After the value that should be taken from inactive and active stake is computed, the slashed funds are transferred to the _treasury address.  initialization of the contract or by the  setTreasury function, the whole slashing mechanism will not work because the  does not allow to transfer tokens to the zero address.  In order to prevent the possible reversion of the slashing process, consider always validating that the _treasury address is not zero when initializing the contract or when a new treasury address is being set.  Update: Fixed on commit b2c4d5aa398530d1ae5af14cf84eb438a377af5e in pull request 56.  Low Severity  TODOs and comments implying unfinished code  There are TODO comments and other comments implying unfinished codes in the codebase. These should be tracked in the projects issues backlog. In particular:  Line 38 of AgentRegistryCore.sol.  Line 54 of AgentRegistryCore.sol.  Line 35 of Router.sol, which seems to imply the development effort here is unfinished.  During development, having well described TODO comments will make the process of tracking and solving them easier. Without that information, these comments might tend to rot and important information for the security of the system might be forgotten by the time it is released to production.  These TODO comments should at least have a brief description of the task pending to do, and a link to the corresponding issue in the project repository.  Consider updating these comments to add this information. For completeness and traceability, a signature and a timestamp can be added.  Update: Fixed on commit d02065f071cd94d1361e00ff2b5208f71d76d014 in pull request 73 and on commit 1f19717cc711522afb05299c8c3e05238484de0d in pull request 75. However, now the AGENT_ADMIN_ROLE role can ban any creation by frontrunning the senders transaction and changing the frontRunningDelay variable.  Add information in _emitHook calls  _emitHook function for the hook hook_afterStakeChanged. However, this hook only includes two parameters:  deposit,  initiateWithdrawal,  withdraw, and the  slash functions.  If it is eventually needed to determine which user triggered a stake change, which users stake has changed, by how much a stake has changed, or what function resulted in the stake change, a call into the FortaStaking contract will be needed, possibly alongside complex logic in an external contract.  Consider passing relevant data with the calls to _emitHook, such as _msgSender and changeInStake. Doing so will make it easier for the contract receiving the hook to interpret what has happened. Additionally, consider documenting the purposes of the hooks for future development, so it is clear exactly which data may be needed from the hook_afterStakeChanged call.  Update: Fixed on commit 0d91a544de1540459b71167dfdf318bb11acf6a6 in pull request 76.  Inconsistent slot size for upgrades  Throughout the whole codebase, several contracts are allowed to be upgradable in order to improve/extend the functionalities or to fix a vulnerability. To mitigate the possibility of having a storage collision, those contracts define an array at the bottom of the contract that its length added to the number of variables defined in the contract adds to a fix number, usually 50.  However, there are contracts in which the sum is not consistent with the rest of the codebase. In particular:  The ScannerRegistryManaged contract whose sum adds up to 45.  The StakeAwareUpgradeable contract whose sum adds up to 5.  The AgentRegistryCore contract whose sum adds up to 45.  In order to improve the codes readability, prevent future storage collisions on contracts that may have less storage slots available, and to be consistent with the rest of the code, consider fixing all the respective places where the sum does not add up to a common fixed number. Furthermore, consider documenting as in-line comments all the variables that took one of those places as documentation for the __gap variable as an exercise to double corroborate its final length.  Update: Fixed in pull request 45 and on commit 4a49ba4bdc53702fe199d06d249a0e961ee8385b in pull request 77. The team has explicitly described the slot usages in those files and added upgradeability information in the README.md file to mitigate future problems.  Potential for hash collisions with frontrun protection  Within AgentRegistryCore.sol, calls to the frontrunProtected modifier utilize abi.encodePacked to create a unique hash of some commited data.  However, by using two dynamic parameters next to each other (both in createAgent and in updateAgent), hashes can be easily forged simply by adjusting metadata and chainIds, such that an agent may be created or updated incorrectly.  By simply using abi.encode rather than abi.encodePacked, such collisions from dynamic parameters being adjacent can be avoided. Consider using abi.encode here instead.  Update: Fixed on commit 2a7391dff896384174ca49ff960d889120961a4e in pull request 57.  Implement a remove-whitelist functionality  Currently, to prevent tokens from being transferred while within the vesting schedule, a WHITELIST_ROLE is defined and checked in FortaCommon._beforeTokenTransfer. The user or contract can only transfer tokens if whitelisted. Eventually, the whitelist requirement is planned to be removed via a contract upgrade.  Since contract upgrades are notoriously risky due to storage slot assignment issues, and since the removal of the whitelist functionality is planned for future development, consider implementing an access controlled remove whitelist functionality in the existing contract which disables the whitelist. This will also give users greater confidence about the future state of the system and allow development which may depend on the future system design to proceed more smoothly.  Update: Fixed on commit dd558f1017eee429e8d66d9d151de3adf1d02a6d in pull request 58.  Implicit casting  Throughout the codebase, an instance of implicit casting between types has been detected.  FortaStakingUtils library, in lines  10 and  18, the  Whenever a different type of variable is needed, consider either checking and casting the variable into the desired type or using OpenZeppelins SafeCast library which provides overflow checking when casting from one type of number to another.  Update: Fixed on commit 2ff21729d1daeb06d830b8a239dcb8d9fd7b9dfd in pull request 59.  Incomplete interfaces  The IRouter interface should have an externally accessed function which is not being declared in the interface, the version getter function.  Consider declaring all externally accessed functions without access control so users and developers can make use of interfaces when using the protocol.  Update: Fixed on commit a1f8eee474259c7b408932a7abc567116859c106 in pull request 74. Versioned contracts now inherit from the IVersioned interface which declares the getter.  Disabled scanners and agents may appear to be linked  Within Dispatch.sol, the mappings scannerToAgents and agentToScanners should store correct linkages between agents and scanners.  If an agent or scanner is disabled, they are not allowed to be linked. Thus, it follows that if scanners or agents which are linked are then disabled, the link should be removed. However, this is not enforced  a scanner or agent may be disabled, but the values in scannerToAgents and agentsToScanners may not reflect this.  Consider adding a programmatical way to remove links whenever an agent or scanner is disabled. Consider that, since a single agent or scanner may have multiple instances it is linked to, the unlinking process may involve calling unlink multiple times. This may mean adding a limit to the number of links for a single instance. Alternatively, consider documenting this behavior clearly for any 3rd-party developers, and encouraging them to double-check that both the scanner and agent are enabled when querying linked pairs.  Update: Acknowledge, but will not fix. The Forta teams statement for the issue:  Product requirements not clear yet, addressed in the conversation thread but we will not take action yet (since assigner software is doing that labor now).  Magic numbers are used  Throughout the codebase, there are occurrences of literal values with unexplained meaning. For example, the operation to get the maximum slashable stake in the FortaStaking contract uses explicit numbers during the calculation without documenting the reasons of such values.  To improve the codes readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. For complex values, consider adding an inline comment explaining how they were calculated or why they were chosen.  Update: Fixed on commit 802b183505f637d1f4ec97a64b2c8b3d58057096 in pull request 60.  Non-registered scanners default to non-disabled states  The ScannerRegistryEnable contract implements the functionality for enabling and disabling scanners, among other actions, and it uses bit maps to keep track of their states.  enabling a scanner, the  _scannerEnable internal function uses the inverse assignment, meaning that a  registered as a ERC721 and have  enough stake on top of it, its default un-registered behavior resembles a non-disabled scanner.  Even though this does not possess a security risk per se, in order to improve the readability of the code and reduce the attack surface, consider using a different state from the default one when enabling new scanners.  Update: Acknowledged, will not fix. Forta teams statement for this issue:  It is true that the logic is inverted, and in a chain without min stake, an Agent/Scanner will be enabled (not disabled) on creation. This is acceptable to us because of several reasons: Registries are deployed in production, so we cant invert the logic of _disableFlags without downtime. _disableFlag at 1 does not just mean disabled, it is the permission of the wallet that disabled the scanner (uint8, or rather Permission enum) so having a value that means scanner registered the first time but not enabled yet might complicate things further.  Semantic overload  The ScannerRegistryEnable contract implements the functionality for enabling and disabling scanners, but it also extends the functionality of the registration process.  When registering a new scanner, the contract checks if the minimum stake for the scanner type is greater than zero. This value is changed by the admin in the FortaStaking contract and it is meant to define a threshold value instead of an enabled status.  This is known as Semantic Overload. If the multiple meanings of the variables and states are not totally clear when making changes to the code, it can introduce severe vulnerabilities. We strongly discourage its usage if possible.  Consider explicitly setting independent flags to represent the state of the scanners instead of using the same variable for different purposes.  Update: Fixed on commit 1869a5ab8461c106e283a2d23e857d8435a8587b in pull request 78. Now, the scanner registration process checks if a certain chain is activated by using an explicit flag.  Deviation from specifications  The StakingEscrow contract implements the functionality to allow users who have vested tokens in L1 to be able to interact, participate, and stake those assets in the protocol. By doing so, the protocol could disburse rewards to users which would be collectable by calling the release", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#malicious-user-can-register-a-scanner-under-any-owner", "labels": ["OpenZeppelin"]}, {"title": "__gap missing in upgradeable contracts", "body": "__gap missing in upgradeable contracts", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#__gap-missing-in-upgradeable-contracts", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission after sensitive actions", "body": "The following function do not emit relevant events after executing sensitive actions.  The sweep function of the FortaStaking contract, after the SWEEPER_ROLE role withdraws all mistakenly sent tokens to the contract.  Consider emitting events after sensitive changes take place (including the first event emission in the constructor when appropriate), to facilitate tracking and notify off-chain clients following the contracts activity  Update: Fixes on commit d0934556c8331ccb806a606622bbd8b9f10c301b in pull request 51.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#lack-of-event-emission-after-sensitive-actions", "labels": ["OpenZeppelin"]}, {"title": "Unclear initialization of inherited contracts", "body": "The StakeAwareUpgradeable contract is inherited by a few contracts, such as the ScannerRegistryEnable contract, and therefore any other contract that inherits from those, such as the ScannerRegistry contract.  However, even though the ScannerRegistry contract implements the initialize function that initializes all the respective imports, there is no call to the __StakeAwareUpgradeable_init function from the StakeAwareUpgradeable contract. Furthermore, there is no single location in the whole codebase that would call the initializer to set the respective stake controller.  Moreover, the FortaStaking contract is inheriting the functionalities from the ERC1155SupplyUpgradeable contract but its __ERC1155Supply_init function is never initialized.  Consider calling all the respective initialization functions when inheriting functionalities from other contracts.  Update: Fixed on commit b7f5eb26fdb87a5c45392d6a6468d873a86ea450 in pull request 52. More documentation was added to describe the lack of initialization on upgraded contracts.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#unclear-initialization-of-inherited-contracts", "labels": ["OpenZeppelin"]}, {"title": "Lack of validation", "body": "Throughout the codebase, there are places where a proper input/output validation is lacking. In particular:  In the Router contract, when adding or removing an element from the routing table, the methods return a boolean to inform the success of the call, but this output is never used or validated by the Router contract.  Similarly to the case from above, in the ScannerRegistryManaged contract, when adding or removing a manager from storage, its methods output is never validated.  In Routed.sol, the variable assignment in lines 13 and 25 are not validating if the address corresponds to a contract or if it is the zero address.  In the FortaStaking contract it is possible to initiate a withdrawal and set in storage a deadline for a inexistent stake, emit several events during the process, and trigger an external hook.  A lack of validation on user-controlled parameters may result in erroneous or failing transactions that are difficult to debug. To avoid this, consider adding input and output validation to address the concerns raised above and in any other place when appropriate.  Update: Partially fixed on commit 85d6bd7518efd3a759789225b7dc07d4c26fa7fd in pull request 53. The team has acknowledged the lack of validation but it will not be enforced on all the mentioned places. The teams response for the issue:  NOTE: ignoring EnumerableSet.add() bool output; We dont care if already added.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#lack-of-validation", "labels": ["OpenZeppelin"]}, {"title": "Staked funds might get soft-stuck", "body": "FortaStaking contract implements the functionality to allow holders to stake their funds (vested or not) into a subject and collect rewards by doing so. The contract uses 2 different accounting systems to handle the assets: a  Distribution type based for the asset in stake units and the inner  ERC1155 accounting system for the associated shares. When a user  stakes, the contract  mints new active shares. When a user  wants to withdraw, the contract  burns those active shares and  mints inactive ones.  When minting these ERC1155, the _doSafeTransferAcceptanceCheck hook will get triggered and it would check if the destinatary is a ERC1155Receiver implementer or not when it detects that the address has code in it.  However, if the minting process happens during the constructor of a non-fully compatible ERC1155 wallet, the FortaStaking contract would treat the destinatary as a regular EOA during the minting process. Then, once it is deployed, the wallet will not be able to mint new shares due to the same _doSafeTransferAcceptanceCheck hook as it will get triggered, failing at the same validation that was skipped on the first deposit.  This means that when the wallet starts the process to withdraw the assets, the transaction will fail during the minting of inactive shares. Nevertheless, the user may transfer those active shares to a fully compatible wallet to then initiate the withdrawal process once again.  In favor of improving the usability of the protocol, consider documenting the requirements that 3rd party wallets would need to be able to fully interact with it either during the deployment stage or once it has been deployed.  Update: Fixed on commit d13be24e8b84ffc59eb04ded2d03841a69996434 in pull request 54.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#staked-funds-might-get-soft-stuck", "labels": ["OpenZeppelin"]}, {"title": "L2 tokens could get stuck", "body": "The release function in the StakingEscrow contract allows users to send tokens from the StakingEscrow contract to another account on L2. However, in order to preserve the vesting schedule, FORT tokens are NOT allowed to be transferred unless they have been accounted for by pendingReward.  Typically if tokens are received as rewards from the staking contract, pendingReward will be increased. However, if tokens are sent directly to this contract, it will not increase pendingReward and the tokens will not be transferable. Instead, users will only be able to bridge their FORT tokens, subjecting them to the vesting schedule on L1.  Consider implementing some accounting to allow for users to transfer FORT tokens to this contract, and afterwards transfer them out via the release function. Alternatively, consider making a clear warning to any StakingEscrow contract users that FORT tokens transferred to the contract will not be release-able and will be subjected to vesting.  Update: Fixed on commit 9d821024623005808eddd6765d8260f1d2a2301d in pull request 55. A warning has been added to let users know about this behavior.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#l2-tokens-could-get-stuck", "labels": ["OpenZeppelin"]}, {"title": "Slashing process could be reverted", "body": "When a certain subject under-performed or has done actions against the correct operation of the protocol, the SLASHER_ROLE role can slash that subject and all the users that have staked on it by calling the slash function from the FortaStaking contract. After the value that should be taken from inactive and active stake is computed, the slashed funds are transferred to the _treasury address.  initialization of the contract or by the  setTreasury function, the whole slashing mechanism will not work because the  does not allow to transfer tokens to the zero address.  In order to prevent the possible reversion of the slashing process, consider always validating that the _treasury address is not zero when initializing the contract or when a new treasury address is being set.  Update: Fixed on commit b2c4d5aa398530d1ae5af14cf84eb438a377af5e in pull request 56.  Low Severity", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#slashing-process-could-be-reverted", "labels": ["OpenZeppelin"]}, {"title": "TODOs and comments implying unfinished code", "body": "There are TODO comments and other comments implying unfinished codes in the codebase. These should be tracked in the projects issues backlog. In particular:  Line 38 of AgentRegistryCore.sol.  Line 54 of AgentRegistryCore.sol.  Line 35 of Router.sol, which seems to imply the development effort here is unfinished.  During development, having well described TODO comments will make the process of tracking and solving them easier. Without that information, these comments might tend to rot and important information for the security of the system might be forgotten by the time it is released to production.  These TODO comments should at least have a brief description of the task pending to do, and a link to the corresponding issue in the project repository.  Consider updating these comments to add this information. For completeness and traceability, a signature and a timestamp can be added.  Update: Fixed on commit d02065f071cd94d1361e00ff2b5208f71d76d014 in pull request 73 and on commit 1f19717cc711522afb05299c8c3e05238484de0d in pull request 75. However, now the AGENT_ADMIN_ROLE role can ban any creation by frontrunning the senders transaction and changing the frontRunningDelay variable.  Add information in _emitHook calls  _emitHook function for the hook hook_afterStakeChanged. However, this hook only includes two parameters:  deposit,  initiateWithdrawal,  withdraw, and the  slash functions.  If it is eventually needed to determine which user triggered a stake change, which users stake has changed, by how much a stake has changed, or what function resulted in the stake change, a call into the FortaStaking contract will be needed, possibly alongside complex logic in an external contract.  Consider passing relevant data with the calls to _emitHook, such as _msgSender and changeInStake. Doing so will make it easier for the contract receiving the hook to interpret what has happened. Additionally, consider documenting the purposes of the hooks for future development, so it is clear exactly which data may be needed from the hook_afterStakeChanged call.  Update: Fixed on commit 0d91a544de1540459b71167dfdf318bb11acf6a6 in pull request 76.  Inconsistent slot size for upgrades  Throughout the whole codebase, several contracts are allowed to be upgradable in order to improve/extend the functionalities or to fix a vulnerability. To mitigate the possibility of having a storage collision, those contracts define an array at the bottom of the contract that its length added to the number of variables defined in the contract adds to a fix number, usually 50.  However, there are contracts in which the sum is not consistent with the rest of the codebase. In particular:  The ScannerRegistryManaged contract whose sum adds up to 45.  The StakeAwareUpgradeable contract whose sum adds up to 5.  The AgentRegistryCore contract whose sum adds up to 45.  In order to improve the codes readability, prevent future storage collisions on contracts that may have less storage slots available, and to be consistent with the rest of the code, consider fixing all the respective places where the sum does not add up to a common fixed number. Furthermore, consider documenting as in-line comments all the variables that took one of those places as documentation for the __gap variable as an exercise to double corroborate its final length.  Update: Fixed in pull request 45 and on commit 4a49ba4bdc53702fe199d06d249a0e961ee8385b in pull request 77. The team has explicitly described the slot usages in those files and added upgradeability information in the README.md file to mitigate future problems.  Potential for hash collisions with frontrun protection  Within AgentRegistryCore.sol, calls to the frontrunProtected modifier utilize abi.encodePacked to create a unique hash of some commited data.  However, by using two dynamic parameters next to each other (both in createAgent and in updateAgent), hashes can be easily forged simply by adjusting metadata and chainIds, such that an agent may be created or updated incorrectly.  By simply using abi.encode rather than abi.encodePacked, such collisions from dynamic parameters being adjacent can be avoided. Consider using abi.encode here instead.  Update: Fixed on commit 2a7391dff896384174ca49ff960d889120961a4e in pull request 57.  Implement a remove-whitelist functionality  Currently, to prevent tokens from being transferred while within the vesting schedule, a WHITELIST_ROLE is defined and checked in FortaCommon._beforeTokenTransfer. The user or contract can only transfer tokens if whitelisted. Eventually, the whitelist requirement is planned to be removed via a contract upgrade.  Since contract upgrades are notoriously risky due to storage slot assignment issues, and since the removal of the whitelist functionality is planned for future development, consider implementing an access controlled remove whitelist functionality in the existing contract which disables the whitelist. This will also give users greater confidence about the future state of the system and allow development which may depend on the future system design to proceed more smoothly.  Update: Fixed on commit dd558f1017eee429e8d66d9d151de3adf1d02a6d in pull request 58.  Implicit casting  Throughout the codebase, an instance of implicit casting between types has been detected.  FortaStakingUtils library, in lines  10 and  18, the  Whenever a different type of variable is needed, consider either checking and casting the variable into the desired type or using OpenZeppelins SafeCast library which provides overflow checking when casting from one type of number to another.  Update: Fixed on commit 2ff21729d1daeb06d830b8a239dcb8d9fd7b9dfd in pull request 59.  Incomplete interfaces  The IRouter interface should have an externally accessed function which is not being declared in the interface, the version getter function.  Consider declaring all externally accessed functions without access control so users and developers can make use of interfaces when using the protocol.  Update: Fixed on commit a1f8eee474259c7b408932a7abc567116859c106 in pull request 74. Versioned contracts now inherit from the IVersioned interface which declares the getter.  Disabled scanners and agents may appear to be linked  Within Dispatch.sol, the mappings scannerToAgents and agentToScanners should store correct linkages between agents and scanners.  If an agent or scanner is disabled, they are not allowed to be linked. Thus, it follows that if scanners or agents which are linked are then disabled, the link should be removed. However, this is not enforced  a scanner or agent may be disabled, but the values in scannerToAgents and agentsToScanners may not reflect this.  Consider adding a programmatical way to remove links whenever an agent or scanner is disabled. Consider that, since a single agent or scanner may have multiple instances it is linked to, the unlinking process may involve calling unlink multiple times. This may mean adding a limit to the number of links for a single instance. Alternatively, consider documenting this behavior clearly for any 3rd-party developers, and encouraging them to double-check that both the scanner and agent are enabled when querying linked pairs.  Update: Acknowledge, but will not fix. The Forta teams statement for the issue:  Product requirements not clear yet, addressed in the conversation thread but we will not take action yet (since assigner software is doing that labor now).  Magic numbers are used  Throughout the codebase, there are occurrences of literal values with unexplained meaning. For example, the operation to get the maximum slashable stake in the FortaStaking contract uses explicit numbers during the calculation without documenting the reasons of such values.  To improve the codes readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. For complex values, consider adding an inline comment explaining how they were calculated or why they were chosen.  Update: Fixed on commit 802b183505f637d1f4ec97a64b2c8b3d58057096 in pull request 60.  Non-registered scanners default to non-disabled states  The ScannerRegistryEnable contract implements the functionality for enabling and disabling scanners, among other actions, and it uses bit maps to keep track of their states.  enabling a scanner, the  _scannerEnable internal function uses the inverse assignment, meaning that a  registered as a ERC721 and have  enough stake on top of it, its default un-registered behavior resembles a non-disabled scanner.  Even though this does not possess a security risk per se, in order to improve the readability of the code and reduce the attack surface, consider using a different state from the default one when enabling new scanners.  Update: Acknowledged, will not fix. Forta teams statement for this issue:  It is true that the logic is inverted, and in a chain without min stake, an Agent/Scanner will be enabled (not disabled) on creation. This is acceptable to us because of several reasons: Registries are deployed in production, so we cant invert the logic of _disableFlags without downtime. _disableFlag at 1 does not just mean disabled, it is the permission of the wallet that disabled the scanner (uint8, or rather Permission enum) so having a value that means scanner registered the first time but not enabled yet might complicate things further.  Semantic overload  The ScannerRegistryEnable contract implements the functionality for enabling and disabling scanners, but it also extends the functionality of the registration process.  When registering a new scanner, the contract checks if the minimum stake for the scanner type is greater than zero. This value is changed by the admin in the FortaStaking contract and it is meant to define a threshold value instead of an enabled status.  This is known as Semantic Overload. If the multiple meanings of the variables and states are not totally clear when making changes to the code, it can introduce severe vulnerabilities. We strongly discourage its usage if possible.  Consider explicitly setting independent flags to represent the state of the scanners instead of using the same variable for different purposes.  Update: Fixed on commit 1869a5ab8461c106e283a2d23e857d8435a8587b in pull request 78. Now, the scanner registration process checks if a certain chain is activated by using an explicit flag.  Deviation from specifications  The StakingEscrow contract implements the functionality to allow users who have vested tokens in L1 to be able to interact, participate, and stake those assets in the protocol. By doing so, the protocol could disburse rewards to users which would be collectable by calling the release function, where the documentation states that even if these assets are sent to a non-whitelisted address, the tokens will arrive but those will get stuck.  However, due to the _beforeTokenTransfer function hook being called during any regular transfer of ERC20 tokens, it will not be possible to send those assets to a non-whitelisted address.  Consider either updating the documentation to reflect the current behavior of the protocol or fixing the implementation to follow the specifications.  Update: Fixed. Now the documentation reflects what it is implemented in the code.  Reentrancy possibility due to _doSafeTransferAcceptanceCheck  After calling the _mint function in the FortaStaking contract, the function _doSafeTransferAcceptanceCheck from the ERC1155Upgradeable contract will get called, which will hand over control to the to address.  deposit and  initiateWithdrawal functions both make a call to the  Update: Fixed on commit 0d91a544de1540459b71167dfdf318bb11acf6a6 in pull request 76. Some hooks have been removed until an implementation makes use of them.  Notes & Additional Information  Add bridge exit instructions  Currently in the codebase, there is no obvious way to release tokens from the Polygon POS bridge. According to their documentation, the exit function will need to be called on Ethereum to release tokens sent from Polygon to Ethereum.  This may not be clear to users who transfer tokens from L2 to L1. The only locations in the code referencing the exit function are within the IRootChainManager interface and within the mock for RootChainManager. Notably, in the mock, the function is not implemented. It appears that the exit functionality may not have been fully implemented as intended.  Consider implementing instructions for users to exit from the Polygon bridge. To make it easier for users, consider calling the function from within contracts they are already interacting with, and ensure that instructions for using these functions are clear. Make sure to test all exit functionality thoroughly. Alternatively, consider writing a guide for users to exit on their own, and include it within the Forta documentation. Tests for such instructions should also be performed.  Update: Not fixed. The Forta team has acknowledged the issue and will fix it in the future. Their response for the issue:  We will add this to the public docs, thanks for the note.  Suggestion: add hooks which revert on failure  Currently in the codebase, the Router and Routed contracts allow for adding hooks via the _emitHook function to different contracts throughout the Forta codebase. Notably, different target contracts can be added and changed for each hook at any time, and all hooks will not revert the overall call if they revert.  It appears that this architecture exists for handling an unplanned future architecture. Therefore, consider also adding functionality which allows for hooks which MUST succeed, or revert the outer call if they revert. Note that this suggestion is merely for better future development experience, and does not arise from any security issue.  Update: Fixed on commit 1f19717cc711522afb05299c8c3e05238484de0d in pull request 75. Now, depending on how the routing table is set, a certain signature may require that the external transaction has to be successful in order to proceed.  Add explicit warning about the Forwarder  The Forwarder contract allows for users to sign messages, and for them to be executed by other EOAs by presenting a valid signature. It includes nonces for replay protection for such transactions. However, users should be made explicitly aware that failing transactions will NOT consume a nonce. This is because the _verifyAndConsumeNonce function cannot store any data within a reverting transaction. Meaning, any transactions which revert can be broadcast again at any point in the future, by any user, and may succeed at that time.  Although this is briefly mentioned in the linked README, consider adding an explicit inline warning that nonces are not consumed in failing transactions, unlike normal ethereum transactions. Users should be made aware that to remedy this, they should make use of the deadline functionality, or that they will need to successfully broadcast a transaction which succeeds with the same nonce to cancel another. Additionally, consider adding a cancelTransaction function, which simply validates a signature and consumes the nonce.  Update: Not fixed. After discussing potential solutions, the security implications of a fix were deemed non-trivial and would require more time. The Forta team plans to address this in future development efforts.  Gas optimizations  There are a few spots identified in the code which could be optimized for gas consumption.  On line 372 of FortaStaking.sol, a call to the availableReward function is made. This calls the subjectToActive method. On line 373, another call to the subjectToActive method is made. Making a single call to subjectToActive to utilize in both locations could save gas.  In StakingEscrowFactory.sol, the immutable value template is declared as an instance of the StakingEscrow contract. However, it is only ever used in the codebase when it is casted to an address. Instead of storing it as type StaingEscrow, store it as type address to save gas during the deployment and the runtime execution.  Consider correcting these two instances for more efficient gas usage when interacting with the Forta codebase.  Update: Fixed on commmit f60dec0d8beaf0153af55dabbffd647eb04db0ab in pull request 62.  Inconsistent format in error messages  Error messages throughout the code base were found to be following different formats. In particular, some messages are formatted Contract name::function name: error message, whereas others are not.  So as to favor readability and ease debugging, consider always following a consistent format in error messages and, furthermore, consider adapting all revert messages to the \"Contract name::function name: error message\" format.  Update: Fixed on commit 2004980310db61537c0fac7be8f62b0de0aa6fb6 in pull request 79.  Misleading documentation  Throughout the codebase, there are places of misleading documentation. In particular:  The FortaBridgedPolygon contract implements the functionality to handle the bridge of asset between the 2 networks. When depositing funds in the root chain, the childChainManagerProxy address will call the deposit function to mint the respective tokens in the child chain. The in-line documentation also states that To avoid token locked on the parent chains not being correctly represented on the child chain, this should NEVER revert. Consequently, we might have to temporarily grant WHITELIST_ROLE to the receiver, however the _mint function can revert if the _maxSupply value is reached.  In the Router contract, the in-line documentation states that the contract should be BaseComponentUpgradeable, because BaseComponentUpgradeable is Routed where it should say shouldnt be instead.  In the FortaStaking contract, the sweep function allows to withdraw any token that was mistakenly sent to the contract. However, the documentation suggest that the function sweeps all the tokens at the same time, even though the function takes one at a time.  Consider fixing the documentation so users are aware of the real behavior of the protocol.  Update: Fixed on commit ab3fdc505ea5804d0e4991e28d0f0b143ef56a64 in pull request 63.  Missing Docstrings  Many of the contracts and functions in the Forta Token codebase lack documentation. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Fixed on commit 8d89e975f27328ddcfa98147751e4745b95df877 in pull request 80.  Naming issues  There are many areas in the codebase which we feel better naming could greatly benefit development and reviewers understanding of the code. In particular:  Within Forwarder.sol, there are two functions named getNonce. Consider renaming one or both of them to indicate the difference between the two functions.  Within Dispatch.sol, function agentsFor should be renamed to numAgentsFor since it returns the number of agents for a scanner. Similarly, function scannersFor should be renamed to numScannersFor.  Within Dispatch.sol, function agentsAt should be renamed to agentAt since it returns only a single agent. Similarly, function scannersAt should be renamed to scannerAt.  Within VestingWalletV2.sol, function setHistoricalBalanceBridged should be renamed to setHistoricalBalanceMin to better represent what it does. Similarly, function ", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#todos-and-comments-implying-unfinished-code", "labels": ["OpenZeppelin"]}, {"title": "Add information in _emitHook calls", "body": "Add information in _emitHook calls", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#add-information-in-_emithook-calls", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent slot size for upgrades", "body": "Throughout the whole codebase, several contracts are allowed to be upgradable in order to improve/extend the functionalities or to fix a vulnerability. To mitigate the possibility of having a storage collision, those contracts define an array at the bottom of the contract that its length added to the number of variables defined in the contract adds to a fix number, usually 50.  However, there are contracts in which the sum is not consistent with the rest of the codebase. In particular:  The ScannerRegistryManaged contract whose sum adds up to 45.  The StakeAwareUpgradeable contract whose sum adds up to 5.  The AgentRegistryCore contract whose sum adds up to 45.  In order to improve the codes readability, prevent future storage collisions on contracts that may have less storage slots available, and to be consistent with the rest of the code, consider fixing all the respective places where the sum does not add up to a common fixed number. Furthermore, consider documenting as in-line comments all the variables that took one of those places as documentation for the __gap variable as an exercise to double corroborate its final length.  Update: Fixed in pull request 45 and on commit 4a49ba4bdc53702fe199d06d249a0e961ee8385b in pull request 77. The team has explicitly described the slot usages in those files and added upgradeability information in the README.md file to mitigate future problems.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#inconsistent-slot-size-for-upgrades", "labels": ["OpenZeppelin"]}, {"title": "Potential for hash collisions with frontrun protection", "body": "Within AgentRegistryCore.sol, calls to the frontrunProtected modifier utilize abi.encodePacked to create a unique hash of some commited data.  However, by using two dynamic parameters next to each other (both in createAgent and in updateAgent), hashes can be easily forged simply by adjusting metadata and chainIds, such that an agent may be created or updated incorrectly.  By simply using abi.encode rather than abi.encodePacked, such collisions from dynamic parameters being adjacent can be avoided. Consider using abi.encode here instead.  Update: Fixed on commit 2a7391dff896384174ca49ff960d889120961a4e in pull request 57.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#potential-for-hash-collisions-with-frontrun-protection", "labels": ["OpenZeppelin"]}, {"title": "Implement a remove-whitelist functionality", "body": "Currently, to prevent tokens from being transferred while within the vesting schedule, a WHITELIST_ROLE is defined and checked in FortaCommon._beforeTokenTransfer. The user or contract can only transfer tokens if whitelisted. Eventually, the whitelist requirement is planned to be removed via a contract upgrade.  Since contract upgrades are notoriously risky due to storage slot assignment issues, and since the removal of the whitelist functionality is planned for future development, consider implementing an access controlled remove whitelist functionality in the existing contract which disables the whitelist. This will also give users greater confidence about the future state of the system and allow development which may depend on the future system design to proceed more smoothly.  Update: Fixed on commit dd558f1017eee429e8d66d9d151de3adf1d02a6d in pull request 58.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#implement-a-remove-whitelist-functionality", "labels": ["OpenZeppelin"]}, {"title": "Implicit casting", "body": "Throughout the codebase, an instance of implicit casting between types has been detected.  FortaStakingUtils library, in lines  10 and  18, the  Whenever a different type of variable is needed, consider either checking and casting the variable into the desired type or using OpenZeppelins SafeCast library which provides overflow checking when casting from one type of number to another.  Update: Fixed on commit 2ff21729d1daeb06d830b8a239dcb8d9fd7b9dfd in pull request 59.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#implicit-casting", "labels": ["OpenZeppelin"]}, {"title": "Incomplete interfaces", "body": "The IRouter interface should have an externally accessed function which is not being declared in the interface, the version getter function.  Consider declaring all externally accessed functions without access control so users and developers can make use of interfaces when using the protocol.  Update: Fixed on commit a1f8eee474259c7b408932a7abc567116859c106 in pull request 74. Versioned contracts now inherit from the IVersioned interface which declares the getter.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#incomplete-interfaces", "labels": ["OpenZeppelin"]}, {"title": "Disabled scanners and agents may appear to be linked", "body": "Within Dispatch.sol, the mappings scannerToAgents and agentToScanners should store correct linkages between agents and scanners.  If an agent or scanner is disabled, they are not allowed to be linked. Thus, it follows that if scanners or agents which are linked are then disabled, the link should be removed. However, this is not enforced  a scanner or agent may be disabled, but the values in scannerToAgents and agentsToScanners may not reflect this.  Consider adding a programmatical way to remove links whenever an agent or scanner is disabled. Consider that, since a single agent or scanner may have multiple instances it is linked to, the unlinking process may involve calling unlink multiple times. This may mean adding a limit to the number of links for a single instance. Alternatively, consider documenting this behavior clearly for any 3rd-party developers, and encouraging them to double-check that both the scanner and agent are enabled when querying linked pairs.  Update: Acknowledge, but will not fix. The Forta teams statement for the issue:  Product requirements not clear yet, addressed in the conversation thread but we will not take action yet (since assigner software is doing that labor now).", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#disabled-scanners-and-agents-may-appear-to-be-linked", "labels": ["OpenZeppelin"]}, {"title": "Magic numbers are used", "body": "Throughout the codebase, there are occurrences of literal values with unexplained meaning. For example, the operation to get the maximum slashable stake in the FortaStaking contract uses explicit numbers during the calculation without documenting the reasons of such values.  To improve the codes readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. For complex values, consider adding an inline comment explaining how they were calculated or why they were chosen.  Update: Fixed on commit 802b183505f637d1f4ec97a64b2c8b3d58057096 in pull request 60.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#magic-numbers-are-used", "labels": ["OpenZeppelin"]}, {"title": "Non-registered scanners default to non-disabled states", "body": "The ScannerRegistryEnable contract implements the functionality for enabling and disabling scanners, among other actions, and it uses bit maps to keep track of their states.  enabling a scanner, the  _scannerEnable internal function uses the inverse assignment, meaning that a  registered as a ERC721 and have  enough stake on top of it, its default un-registered behavior resembles a non-disabled scanner.  Even though this does not possess a security risk per se, in order to improve the readability of the code and reduce the attack surface, consider using a different state from the default one when enabling new scanners.  Update: Acknowledged, will not fix. Forta teams statement for this issue:  It is true that the logic is inverted, and in a chain without min stake, an Agent/Scanner will be enabled (not disabled) on creation. This is acceptable to us because of several reasons: Registries are deployed in production, so we cant invert the logic of _disableFlags without downtime. _disableFlag at 1 does not just mean disabled, it is the permission of the wallet that disabled the scanner (uint8, or rather Permission enum) so having a value that means scanner registered the first time but not enabled yet might complicate things further.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#non-registered-scanners-default-to-non-disabled-states", "labels": ["OpenZeppelin"]}, {"title": "Semantic overload", "body": "The ScannerRegistryEnable contract implements the functionality for enabling and disabling scanners, but it also extends the functionality of the registration process.  When registering a new scanner, the contract checks if the minimum stake for the scanner type is greater than zero. This value is changed by the admin in the FortaStaking contract and it is meant to define a threshold value instead of an enabled status.  This is known as Semantic Overload. If the multiple meanings of the variables and states are not totally clear when making changes to the code, it can introduce severe vulnerabilities. We strongly discourage its usage if possible.  Consider explicitly setting independent flags to represent the state of the scanners instead of using the same variable for different purposes.  Update: Fixed on commit 1869a5ab8461c106e283a2d23e857d8435a8587b in pull request 78. Now, the scanner registration process checks if a certain chain is activated by using an explicit flag.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#semantic-overload", "labels": ["OpenZeppelin"]}, {"title": "Deviation from specifications", "body": "The StakingEscrow contract implements the functionality to allow users who have vested tokens in L1 to be able to interact, participate, and stake those assets in the protocol. By doing so, the protocol could disburse rewards to users which would be collectable by calling the release function, where the documentation states that even if these assets are sent to a non-whitelisted address, the tokens will arrive but those will get stuck.  However, due to the _beforeTokenTransfer function hook being called during any regular transfer of ERC20 tokens, it will not be possible to send those assets to a non-whitelisted address.  Consider either updating the documentation to reflect the current behavior of the protocol or fixing the implementation to follow the specifications.  Update: Fixed. Now the documentation reflects what it is implemented in the code.  Reentrancy possibility due to _doSafeTransferAcceptanceCheck  After calling the _mint function in the FortaStaking contract, the function _doSafeTransferAcceptanceCheck from the ERC1155Upgradeable contract will get called, which will hand over control to the to address.  deposit and  initiateWithdrawal functions both make a call to the  Update: Fixed on commit 0d91a544de1540459b71167dfdf318bb11acf6a6 in pull request 76. Some hooks have been removed until an implementation makes use of them.  Notes & Additional Information  Add bridge exit instructions  Currently in the codebase, there is no obvious way to release tokens from the Polygon POS bridge. According to their documentation, the exit function will need to be called on Ethereum to release tokens sent from Polygon to Ethereum.  This may not be clear to users who transfer tokens from L2 to L1. The only locations in the code referencing the exit function are within the IRootChainManager interface and within the mock for RootChainManager. Notably, in the mock, the function is not implemented. It appears that the exit functionality may not have been fully implemented as intended.  Consider implementing instructions for users to exit from the Polygon bridge. To make it easier for users, consider calling the function from within contracts they are already interacting with, and ensure that instructions for using these functions are clear. Make sure to test all exit functionality thoroughly. Alternatively, consider writing a guide for users to exit on their own, and include it within the Forta documentation. Tests for such instructions should also be performed.  Update: Not fixed. The Forta team has acknowledged the issue and will fix it in the future. Their response for the issue:  We will add this to the public docs, thanks for the note.  Suggestion: add hooks which revert on failure  Currently in the codebase, the Router and Routed contracts allow for adding hooks via the _emitHook function to different contracts throughout the Forta codebase. Notably, different target contracts can be added and changed for each hook at any time, and all hooks will not revert the overall call if they revert.  It appears that this architecture exists for handling an unplanned future architecture. Therefore, consider also adding functionality which allows for hooks which MUST succeed, or revert the outer call if they revert. Note that this suggestion is merely for better future development experience, and does not arise from any security issue.  Update: Fixed on commit 1f19717cc711522afb05299c8c3e05238484de0d in pull request 75. Now, depending on how the routing table is set, a certain signature may require that the external transaction has to be successful in order to proceed.  Add explicit warning about the Forwarder  The Forwarder contract allows for users to sign messages, and for them to be executed by other EOAs by presenting a valid signature. It includes nonces for replay protection for such transactions. However, users should be made explicitly aware that failing transactions will NOT consume a nonce. This is because the _verifyAndConsumeNonce function cannot store any data within a reverting transaction. Meaning, any transactions which revert can be broadcast again at any point in the future, by any user, and may succeed at that time.  Although this is briefly mentioned in the linked README, consider adding an explicit inline warning that nonces are not consumed in failing transactions, unlike normal ethereum transactions. Users should be made aware that to remedy this, they should make use of the deadline functionality, or that they will need to successfully broadcast a transaction which succeeds with the same nonce to cancel another. Additionally, consider adding a cancelTransaction function, which simply validates a signature and consumes the nonce.  Update: Not fixed. After discussing potential solutions, the security implications of a fix were deemed non-trivial and would require more time. The Forta team plans to address this in future development efforts.  Gas optimizations  There are a few spots identified in the code which could be optimized for gas consumption.  On line 372 of FortaStaking.sol, a call to the availableReward function is made. This calls the subjectToActive method. On line 373, another call to the subjectToActive method is made. Making a single call to subjectToActive to utilize in both locations could save gas.  In StakingEscrowFactory.sol, the immutable value template is declared as an instance of the StakingEscrow contract. However, it is only ever used in the codebase when it is casted to an address. Instead of storing it as type StaingEscrow, store it as type address to save gas during the deployment and the runtime execution.  Consider correcting these two instances for more efficient gas usage when interacting with the Forta codebase.  Update: Fixed on commmit f60dec0d8beaf0153af55dabbffd647eb04db0ab in pull request 62.  Inconsistent format in error messages  Error messages throughout the code base were found to be following different formats. In particular, some messages are formatted Contract name::function name: error message, whereas others are not.  So as to favor readability and ease debugging, consider always following a consistent format in error messages and, furthermore, consider adapting all revert messages to the \"Contract name::function name: error message\" format.  Update: Fixed on commit 2004980310db61537c0fac7be8f62b0de0aa6fb6 in pull request 79.  Misleading documentation  Throughout the codebase, there are places of misleading documentation. In particular:  The FortaBridgedPolygon contract implements the functionality to handle the bridge of asset between the 2 networks. When depositing funds in the root chain, the childChainManagerProxy address will call the deposit function to mint the respective tokens in the child chain. The in-line documentation also states that To avoid token locked on the parent chains not being correctly represented on the child chain, this should NEVER revert. Consequently, we might have to temporarily grant WHITELIST_ROLE to the receiver, however the _mint function can revert if the _maxSupply value is reached.  In the Router contract, the in-line documentation states that the contract should be BaseComponentUpgradeable, because BaseComponentUpgradeable is Routed where it should say shouldnt be instead.  In the FortaStaking contract, the sweep function allows to withdraw any token that was mistakenly sent to the contract. However, the documentation suggest that the function sweeps all the tokens at the same time, even though the function takes one at a time.  Consider fixing the documentation so users are aware of the real behavior of the protocol.  Update: Fixed on commit ab3fdc505ea5804d0e4991e28d0f0b143ef56a64 in pull request 63.  Missing Docstrings  Many of the contracts and functions in the Forta Token codebase lack documentation. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Fixed on commit 8d89e975f27328ddcfa98147751e4745b95df877 in pull request 80.  Naming issues  There are many areas in the codebase which we feel better naming could greatly benefit development and reviewers understanding of the code. In particular:  Within Forwarder.sol, there are two functions named getNonce. Consider renaming one or both of them to indicate the difference between the two functions.  Within Dispatch.sol, function agentsFor should be renamed to numAgentsFor since it returns the number of agents for a scanner. Similarly, function scannersFor should be renamed to numScannersFor.  Within Dispatch.sol, function agentsAt should be renamed to agentAt since it returns only a single agent. Similarly, function scannersAt should be renamed to scannerAt.  Within VestingWalletV2.sol, function setHistoricalBalanceBridged should be renamed to setHistoricalBalanceMin to better represent what it does. Similarly, function updateHistoricalBalanceBridged should be renamed to updateHistoricalBalanceMin.  Note also that in a previous round of auditing, the issue was reported that many upgradeable contracts had filenames which did not indicate upgradeability. Consider making the suggested naming changes to better explain the codes purpose and reduce confusion for reviewers and developers.  Update: Partially fixed on commit 97f51b7eaec9310c17e82fc58ccef859d80c58cd in pull request 64 and on commit a1f8eee474259c7b408932a7abc567116859c106 in pull request 74. The Fortas team statement for the issue:  Having 2 getNonce methods with different parameters is a valid example of static polymorphism. The possible confusion will be mitigated by adding NatSpec in [N07].  As we said in the previous review, we signal that a contract is upgradeable when they inherit from BaseContractUpgradeable (or other Upgradeables in Routers case). Adding the suffix to every contract may be very noisy, especially when using long contract names.  Lack of _commits getter  The FrontRunningProtection contract utilizes a mapping, _commits, to track hashes for a commit-reveal scheme.  However, there is no easy way to access the _commits mapping on-chain. Consider adding a getter for the _commits mapping to ease the user and developer experience. Alternatively, if there is a reason for keeping the _commits mapping as private, consider explaining it in a comment.  Update: Fixed on commit ba8f8dcef73c27ec6dcb5bb2c05b7aabacde0d0a in pull request 65. However, now off-chain tracking services will not be able to detect when a commit hash has been submitted by using the events due to the removal of it.  Pragma statement is not consistent  Although most of the contracts in the codebase use a pragma statement of ^0.8.0, the index.sol file uses a >=0.8.4 version instead.  Although this does not represent a security risk per se, it is always recommended to use the same pragma statement for all the codebase.  Consider reviewing and updating the pragma statements of all contracts throughout the code base to ensure they are consistent.  Update: Fixed on commit d638bd6622d1d2776d1a4f5d2bd31a568ad436ba in pull request 66.  Unneeded public visibility  Some functions in the codebase have public visibility, although it is unneeded since they are not called within the contract they exist in. For example:  Both getNonce functions within Forwarder.sol.  The execute function within Forwarder.sol.  The mint function within Forta.sol.  Consider changing the visibility of these functions to external to better indicate their role in the codebase, and to follow Solidity best practices. Alternatively, if the functions are needed to be public, consider documenting this with a comment.  Update: Fixed on commit 0b15e86ba7fe1dacc515884e88b578c806cddb3d in pull request 67.  Inconsistent use of roles  Throughout the codebase, there are several roles in charge of performing unique and sensitive actions. Most of such roles are defined in the Roles.sol file, one of them being the ENS_MANAGER_ROLE role which is in charge of setting the ENS reverse registration.  However, in the FortaCommon contract, this task belongs to the ADMIN_ROLE role instead.  Consider either using the ENS_MANAGER_ROLE role instead of the ADMIN_ROLE role to set such ENS variable or documenting the reason to use the ADMIN_ROLE role to improve the readability of the code and reduce the attack surface.  Update: Fixed on commit e6edd43e02e5b876573ae71e4cccefe0cefd2ef0 in pull request 68.  Multiple contracts per file  The file Forwarder.sol contains two contracts: EIP712WithNonce and Forwarder.  Consider separating the contracts into their own files to make the codebase easier to understand for developers and reviewers.  Update: Fixed on commit ea3e792c7f7d3b660381c9d4c9a029fd66cdcbfe in pull request 69.  Styling issues  Within the codebase, we found a few stylistic issues which, if corrected, would make the codebase easier to review and more understandable, as well as more predictable for future development efforts. Below are our findings:  There is an extra line at ScannerRegistry.sol line 5.  There is an extra line at ScannerNodeVersion.sol line 33.  The _setStakeController private function is placed before public functions in StakeAware.sol.  Within the initialize function of VestingWallet.sol, input parameter names contain a trailing underscore, unlike other initialize functions in the codebase which use two leading underscores for their input parameter names.  Throughout the codebase, there is relatively common usage of the expression ++i in places where i++ would function identically. For example, within a for loop in AgentRegistryCore.sol. This is in contrast to i++ which is also frequently used, for instance in the for loop in BatchRelayer.sol. Consider using only one style whenever possible, and when necessary to use the other style, including an explanatory comment.  In StakingEscrow.sol, there are two deposit functions (one for a full deposit and one for a partial deposit). However, the initiateWithdrawal function and its partner, initiateFullWithdrawal do not match this pattern. Consider overloading the initiateWithdrawal function as well, to match the style of the overloaded deposit function.  Update: Fixed on commit 3efd28b2a4ec84f1569f807bfb636ddfabc92753 in pull request 70.  Typos and erroneous comments  Several typographical errors were found in the codebase which should be corrected. In particular:  Line 26 of FullMath.sol says Remiander instead of Remainder.  Line 29 of FortaStaking.sol says elligible instead of eligible.  Line 401 of ForaStaking.sol says cal instead of can.  Line 49 of StakingEscrow.sol mentions __l1vesting in the error message, instead of __l2manager.  Line 112 of StakingEscrow.sol references the beneficiary, but should instead say manager.  Line 67 of VestingWalletV2.sol says explicitelly instead of explicitly.  Consider correcting the listed typos and errors within comments. Consider utilizing a spell-checker, such as codespell for future changes to the codebase.  Update: Partially fixed on commit 5c273497f71785d1d34f67d083ec494dbfdb99d3 in pull request 71. Some other typos were found and fixed by the Forta team, but the identified instances in FortaStaking.sol and StakingEscrow.sol were not addressed.  Unneeded or unclear frontrunning protection to update an agent  The FrontRunningProtection contract implement the functionality to allow a commit-reveal scheme to run frontrunning-protected actions in the protocol. Between those, are the ones to create and update an agent in the AgentRegistryCore contract.  Although it may be necessary to have such scheme to create a new agent, so no one can own it beforehand, it is not clear why would it be necessary to have the same procedure to update an agent, taking into account that only the owner of such agent is able to perform the update.  In order to improve the readability of the code and the UX of the protocol, consider documenting the reasoning behind the need of the commit-reveal scheme during agent updates.  Update: Fixed on commit ac296e0ce7d5c6c81f772be88cd6fc74fdd2b429 in pull request 72. The unneeded check has been removed.  Vesting schedule is changeable  VestingWallet or  VestingWalletV2 contracts, users should note that their  vestedAmount value is dependent on _historicalBalance output, which may change. If they transfer tokens to the  increase the _historicalBalance output which will result in a changed vesting schedule. Specifically, it will treat the new token amount as vested as well, and it will be released to the user following the vesting schedule. This has the effect of locking up some of the users funds temporarily if they accidentally transfer them to the  This is made more complicated by the fact that the staking system is set up to only allow funds to be transferred back to the VestingWallet contract. So, users must transfer their tokens back to the VestingWallet contract in order to be able to transfer them freely, and at that point they will be re-vested.  Furthermore, any change in the staked value in L2, e.g. funds get slashed, will not be addressed in L1 due to the historicalBalanceMin variable, off-syncing the balances between both chains even if all the remaining staked funds in L2 are bridged back to L1.  Users should also be made aware of the existence of the setHistoricalBalanceBridged function and the updateHistoricalBalanceBridged function, which give the owner role power to instantly affect the vesting schedule, specifically changing its speed.  Consider refactoring the vesting schedule logic to make it more predictable and user-friendly. For example, consider tracking the remaining vesting balance independently from the balance of the contract, so that tokens which are transferred to the VestingWallet contract from L2 are not re-vested. Additionally, consider defining predictable contract logic for calling the setHistoricalBalanceBridged and updateHistoricalBalanceBridged functions so that users can be assured their vesting schedules will not be tampered with maliciously. Finally, consider the legal implications of changing a vesting schedule based on both user and admin actions, as well as the tax implications for a user whose vesting schedule may change without warning.  Update: Acknowledged, will not fix. Forta teams statement for this issue:  There is a limited number of users relying on these contracts, so for those that want to use the staking features we will just need to upgrade the vesting wallets, at which time such users can be thoroughly informed of the functionalities and risks of the upgrade and agree to them. Thanks for the warning!  Conclusions  No critical issues and one high severity issue were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#deviation-from-specifications", "labels": ["OpenZeppelin"]}, {"title": "Reentrancy possibility due to _doSafeTransferAcceptanceCheck", "body": "Reentrancy possibility due to _doSafeTransferAcceptanceCheck", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#reentrancy-possibility-due-to-_dosafetransferacceptancecheck", "labels": ["OpenZeppelin"]}, {"title": "Add bridge exit instructions", "body": "Currently in the codebase, there is no obvious way to release tokens from the Polygon POS bridge. According to their documentation, the exit function will need to be called on Ethereum to release tokens sent from Polygon to Ethereum.  This may not be clear to users who transfer tokens from L2 to L1. The only locations in the code referencing the exit function are within the IRootChainManager interface and within the mock for RootChainManager. Notably, in the mock, the function is not implemented. It appears that the exit functionality may not have been fully implemented as intended.  Consider implementing instructions for users to exit from the Polygon bridge. To make it easier for users, consider calling the function from within contracts they are already interacting with, and ensure that instructions for using these functions are clear. Make sure to test all exit functionality thoroughly. Alternatively, consider writing a guide for users to exit on their own, and include it within the Forta documentation. Tests for such instructions should also be performed.  Update: Not fixed. The Forta team has acknowledged the issue and will fix it in the future. Their response for the issue:  We will add this to the public docs, thanks for the note.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#add-bridge-exit-instructions", "labels": ["OpenZeppelin"]}, {"title": "Suggestion: add hooks which revert on failure", "body": "Currently in the codebase, the Router and Routed contracts allow for adding hooks via the _emitHook function to different contracts throughout the Forta codebase. Notably, different target contracts can be added and changed for each hook at any time, and all hooks will not revert the overall call if they revert.  It appears that this architecture exists for handling an unplanned future architecture. Therefore, consider also adding functionality which allows for hooks which MUST succeed, or revert the outer call if they revert. Note that this suggestion is merely for better future development experience, and does not arise from any security issue.  Update: Fixed on commit 1f19717cc711522afb05299c8c3e05238484de0d in pull request 75. Now, depending on how the routing table is set, a certain signature may require that the external transaction has to be successful in order to proceed.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#suggestion:-add-hooks-which-revert-on-failure", "labels": ["OpenZeppelin"]}, {"title": "Add explicit warning about the Forwarder", "body": "The Forwarder contract allows for users to sign messages, and for them to be executed by other EOAs by presenting a valid signature. It includes nonces for replay protection for such transactions. However, users should be made explicitly aware that failing transactions will NOT consume a nonce. This is because the _verifyAndConsumeNonce function cannot store any data within a reverting transaction. Meaning, any transactions which revert can be broadcast again at any point in the future, by any user, and may succeed at that time.  Although this is briefly mentioned in the linked README, consider adding an explicit inline warning that nonces are not consumed in failing transactions, unlike normal ethereum transactions. Users should be made aware that to remedy this, they should make use of the deadline functionality, or that they will need to successfully broadcast a transaction which succeeds with the same nonce to cancel another. Additionally, consider adding a cancelTransaction function, which simply validates a signature and consumes the nonce.  Update: Not fixed. After discussing potential solutions, the security implications of a fix were deemed non-trivial and would require more time. The Forta team plans to address this in future development efforts.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#add-explicit-warning-about-the-forwarder", "labels": ["OpenZeppelin"]}, {"title": "Gas optimizations", "body": "There are a few spots identified in the code which could be optimized for gas consumption.  On line 372 of FortaStaking.sol, a call to the availableReward function is made. This calls the subjectToActive method. On line 373, another call to the subjectToActive method is made. Making a single call to subjectToActive to utilize in both locations could save gas.  In StakingEscrowFactory.sol, the immutable value template is declared as an instance of the StakingEscrow contract. However, it is only ever used in the codebase when it is casted to an address. Instead of storing it as type StaingEscrow, store it as type address to save gas during the deployment and the runtime execution.  Consider correcting these two instances for more efficient gas usage when interacting with the Forta codebase.  Update: Fixed on commmit f60dec0d8beaf0153af55dabbffd647eb04db0ab in pull request 62.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent format in error messages", "body": "Error messages throughout the code base were found to be following different formats. In particular, some messages are formatted Contract name::function name: error message, whereas others are not.  So as to favor readability and ease debugging, consider always following a consistent format in error messages and, furthermore, consider adapting all revert messages to the \"Contract name::function name: error message\" format.  Update: Fixed on commit 2004980310db61537c0fac7be8f62b0de0aa6fb6 in pull request 79.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#inconsistent-format-in-error-messages", "labels": ["OpenZeppelin"]}, {"title": "Misleading documentation", "body": "Throughout the codebase, there are places of misleading documentation. In particular:  The FortaBridgedPolygon contract implements the functionality to handle the bridge of asset between the 2 networks. When depositing funds in the root chain, the childChainManagerProxy address will call the deposit function to mint the respective tokens in the child chain. The in-line documentation also states that To avoid token locked on the parent chains not being correctly represented on the child chain, this should NEVER revert. Consequently, we might have to temporarily grant WHITELIST_ROLE to the receiver, however the _mint function can revert if the _maxSupply value is reached.  In the Router contract, the in-line documentation states that the contract should be BaseComponentUpgradeable, because BaseComponentUpgradeable is Routed where it should say shouldnt be instead.  In the FortaStaking contract, the sweep function allows to withdraw any token that was mistakenly sent to the contract. However, the documentation suggest that the function sweeps all the tokens at the same time, even though the function takes one at a time.  Consider fixing the documentation so users are aware of the real behavior of the protocol.  Update: Fixed on commit ab3fdc505ea5804d0e4991e28d0f0b143ef56a64 in pull request 63.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Many of the contracts and functions in the Forta Token codebase lack documentation. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Fixed on commit 8d89e975f27328ddcfa98147751e4745b95df877 in pull request 80.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Naming issues", "body": "There are many areas in the codebase which we feel better naming could greatly benefit development and reviewers understanding of the code. In particular:  Within Forwarder.sol, there are two functions named getNonce. Consider renaming one or both of them to indicate the difference between the two functions.  Within Dispatch.sol, function agentsFor should be renamed to numAgentsFor since it returns the number of agents for a scanner. Similarly, function scannersFor should be renamed to numScannersFor.  Within Dispatch.sol, function agentsAt should be renamed to agentAt since it returns only a single agent. Similarly, function scannersAt should be renamed to scannerAt.  Within VestingWalletV2.sol, function setHistoricalBalanceBridged should be renamed to setHistoricalBalanceMin to better represent what it does. Similarly, function updateHistoricalBalanceBridged should be renamed to updateHistoricalBalanceMin.  Note also that in a previous round of auditing, the issue was reported that many upgradeable contracts had filenames which did not indicate upgradeability. Consider making the suggested naming changes to better explain the codes purpose and reduce confusion for reviewers and developers.  Update: Partially fixed on commit 97f51b7eaec9310c17e82fc58ccef859d80c58cd in pull request 64 and on commit a1f8eee474259c7b408932a7abc567116859c106 in pull request 74. The Fortas team statement for the issue:  Having 2 getNonce methods with different parameters is a valid example of static polymorphism. The possible confusion will be mitigated by adding NatSpec in [N07].  As we said in the previous review, we signal that a contract is upgradeable when they inherit from BaseContractUpgradeable (or other Upgradeables in Routers case). Adding the suffix to every contract may be very noisy, especially when using long contract names.  Lack of _commits getter  The FrontRunningProtection contract utilizes a mapping, _commits, to track hashes for a commit-reveal scheme.  However, there is no easy way to access the _commits mapping on-chain. Consider adding a getter for the _commits mapping to ease the user and developer experience. Alternatively, if there is a reason for keeping the _commits mapping as private, consider explaining it in a comment.  Update: Fixed on commit ba8f8dcef73c27ec6dcb5bb2c05b7aabacde0d0a in pull request 65. However, now off-chain tracking services will not be able to detect when a commit hash has been submitted by using the events due to the removal of it.  Pragma statement is not consistent  Although most of the contracts in the codebase use a pragma statement of ^0.8.0, the index.sol file uses a >=0.8.4 version instead.  Although this does not represent a security risk per se, it is always recommended to use the same pragma statement for all the codebase.  Consider reviewing and updating the pragma statements of all contracts throughout the code base to ensure they are consistent.  Update: Fixed on commit d638bd6622d1d2776d1a4f5d2bd31a568ad436ba in pull request 66.  Unneeded public visibility  Some functions in the codebase have public visibility, although it is unneeded since they are not called within the contract they exist in. For example:  Both getNonce functions within Forwarder.sol.  The execute function within Forwarder.sol.  The mint function within Forta.sol.  Consider changing the visibility of these functions to external to better indicate their role in the codebase, and to follow Solidity best practices. Alternatively, if the functions are needed to be public, consider documenting this with a comment.  Update: Fixed on commit 0b15e86ba7fe1dacc515884e88b578c806cddb3d in pull request 67.  Inconsistent use of roles  Throughout the codebase, there are several roles in charge of performing unique and sensitive actions. Most of such roles are defined in the Roles.sol file, one of them being the ENS_MANAGER_ROLE role which is in charge of setting the ENS reverse registration.  However, in the FortaCommon contract, this task belongs to the ADMIN_ROLE role instead.  Consider either using the ENS_MANAGER_ROLE role instead of the ADMIN_ROLE role to set such ENS variable or documenting the reason to use the ADMIN_ROLE role to improve the readability of the code and reduce the attack surface.  Update: Fixed on commit e6edd43e02e5b876573ae71e4cccefe0cefd2ef0 in pull request 68.  Multiple contracts per file  The file Forwarder.sol contains two contracts: EIP712WithNonce and Forwarder.  Consider separating the contracts into their own files to make the codebase easier to understand for developers and reviewers.  Update: Fixed on commit ea3e792c7f7d3b660381c9d4c9a029fd66cdcbfe in pull request 69.  Styling issues  Within the codebase, we found a few stylistic issues which, if corrected, would make the codebase easier to review and more understandable, as well as more predictable for future development efforts. Below are our findings:  There is an extra line at ScannerRegistry.sol line 5.  There is an extra line at ScannerNodeVersion.sol line 33.  The _setStakeController private function is placed before public functions in StakeAware.sol.  Within the initialize function of VestingWallet.sol, input parameter names contain a trailing underscore, unlike other initialize functions in the codebase which use two leading underscores for their input parameter names.  Throughout the codebase, there is relatively common usage of the expression ++i in places where i++ would function identically. For example, within a for loop in AgentRegistryCore.sol. This is in contrast to i++ which is also frequently used, for instance in the for loop in BatchRelayer.sol. Consider using only one style whenever possible, and when necessary to use the other style, including an explanatory comment.  In StakingEscrow.sol, there are two deposit functions (one for a full deposit and one for a partial deposit). However, the initiateWithdrawal function and its partner, initiateFullWithdrawal do not match this pattern. Consider overloading the initiateWithdrawal function as well, to match the style of the overloaded deposit function.  Update: Fixed on commit 3efd28b2a4ec84f1569f807bfb636ddfabc92753 in pull request 70.  Typos and erroneous comments  Several typographical errors were found in the codebase which should be corrected. In particular:  Line 26 of FullMath.sol says Remiander instead of Remainder.  Line 29 of FortaStaking.sol says elligible instead of eligible.  Line 401 of ForaStaking.sol says cal instead of can.  Line 49 of StakingEscrow.sol mentions __l1vesting in the error message, instead of __l2manager.  Line 112 of StakingEscrow.sol references the beneficiary, but should instead say manager.  Line 67 of VestingWalletV2.sol says explicitelly instead of explicitly.  Consider correcting the listed typos and errors within comments. Consider utilizing a spell-checker, such as codespell for future changes to the codebase.  Update: Partially fixed on commit 5c273497f71785d1d34f67d083ec494dbfdb99d3 in pull request 71. Some other typos were found and fixed by the Forta team, but the identified instances in FortaStaking.sol and StakingEscrow.sol were not addressed.  Unneeded or unclear frontrunning protection to update an agent  The FrontRunningProtection contract implement the functionality to allow a commit-reveal scheme to run frontrunning-protected actions in the protocol. Between those, are the ones to create and update an agent in the AgentRegistryCore contract.  Although it may be necessary to have such scheme to create a new agent, so no one can own it beforehand, it is not clear why would it be necessary to have the same procedure to update an agent, taking into account that only the owner of such agent is able to perform the update.  In order to improve the readability of the code and the UX of the protocol, consider documenting the reasoning behind the need of the commit-reveal scheme during agent updates.  Update: Fixed on commit ac296e0ce7d5c6c81f772be88cd6fc74fdd2b429 in pull request 72. The unneeded check has been removed.  Vesting schedule is changeable  VestingWallet or  VestingWalletV2 contracts, users should note that their  vestedAmount value is dependent on _historicalBalance output, which may change. If they transfer tokens to the  increase the _historicalBalance output which will result in a changed vesting schedule. Specifically, it will treat the new token amount as vested as well, and it will be released to the user following the vesting schedule. This has the effect of locking up some of the users funds temporarily if they accidentally transfer them to the  This is made more complicated by the fact that the staking system is set up to only allow funds to be transferred back to the VestingWallet contract. So, users must transfer their tokens back to the VestingWallet contract in order to be able to transfer them freely, and at that point they will be re-vested.  Furthermore, any change in the staked value in L2, e.g. funds get slashed, will not be addressed in L1 due to the historicalBalanceMin variable, off-syncing the balances between both chains even if all the remaining staked funds in L2 are bridged back to L1.  Users should also be made aware of the existence of the setHistoricalBalanceBridged function and the updateHistoricalBalanceBridged function, which give the owner role power to instantly affect the vesting schedule, specifically changing its speed.  Consider refactoring the vesting schedule logic to make it more predictable and user-friendly. For example, consider tracking the remaining vesting balance independently from the balance of the contract, so that tokens which are transferred to the VestingWallet contract from L2 are not re-vested. Additionally, consider defining predictable contract logic for calling the setHistoricalBalanceBridged and updateHistoricalBalanceBridged functions so that users can be assured their vesting schedules will not be tampered with maliciously. Finally, consider the legal implications of changing a vesting schedule based on both user and admin actions, as well as the tax implications for a user whose vesting schedule may change without warning.  Update: Acknowledged, will not fix. Forta teams statement for this issue:  There is a limited number of users relying on these contracts, so for those that want to use the staking features we will just need to upgrade the vesting wallets, at which time such users can be thoroughly informed of the functionalities and risks of the upgrade and agree to them. Thanks for the warning!  Conclusions  No critical issues and one high severity issue were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#naming-issues", "labels": ["OpenZeppelin"]}, {"title": "Lack of _commits getter", "body": "Lack of _commits getter", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#lack-of-_commits-getter", "labels": ["OpenZeppelin"]}, {"title": "Pragma statement is not consistent", "body": "Although most of the contracts in the codebase use a pragma statement of ^0.8.0, the index.sol file uses a >=0.8.4 version instead.  Although this does not represent a security risk per se, it is always recommended to use the same pragma statement for all the codebase.  Consider reviewing and updating the pragma statements of all contracts throughout the code base to ensure they are consistent.  Update: Fixed on commit d638bd6622d1d2776d1a4f5d2bd31a568ad436ba in pull request 66.  Unneeded public visibility  Some functions in the codebase have public visibility, although it is unneeded since they are not called within the contract they exist in. For example:  Both getNonce functions within Forwarder.sol.  The execute function within Forwarder.sol.  The mint function within Forta.sol.  Consider changing the visibility of these functions to external to better indicate their role in the codebase, and to follow Solidity best practices. Alternatively, if the functions are needed to be public, consider documenting this with a comment.  Update: Fixed on commit 0b15e86ba7fe1dacc515884e88b578c806cddb3d in pull request 67.  Inconsistent use of roles  Throughout the codebase, there are several roles in charge of performing unique and sensitive actions. Most of such roles are defined in the Roles.sol file, one of them being the ENS_MANAGER_ROLE role which is in charge of setting the ENS reverse registration.  However, in the FortaCommon contract, this task belongs to the ADMIN_ROLE role instead.  Consider either using the ENS_MANAGER_ROLE role instead of the ADMIN_ROLE role to set such ENS variable or documenting the reason to use the ADMIN_ROLE role to improve the readability of the code and reduce the attack surface.  Update: Fixed on commit e6edd43e02e5b876573ae71e4cccefe0cefd2ef0 in pull request 68.  Multiple contracts per file  The file Forwarder.sol contains two contracts: EIP712WithNonce and Forwarder.  Consider separating the contracts into their own files to make the codebase easier to understand for developers and reviewers.  Update: Fixed on commit ea3e792c7f7d3b660381c9d4c9a029fd66cdcbfe in pull request 69.  Styling issues  Within the codebase, we found a few stylistic issues which, if corrected, would make the codebase easier to review and more understandable, as well as more predictable for future development efforts. Below are our findings:  There is an extra line at ScannerRegistry.sol line 5.  There is an extra line at ScannerNodeVersion.sol line 33.  The _setStakeController private function is placed before public functions in StakeAware.sol.  Within the initialize function of VestingWallet.sol, input parameter names contain a trailing underscore, unlike other initialize functions in the codebase which use two leading underscores for their input parameter names.  Throughout the codebase, there is relatively common usage of the expression ++i in places where i++ would function identically. For example, within a for loop in AgentRegistryCore.sol. This is in contrast to i++ which is also frequently used, for instance in the for loop in BatchRelayer.sol. Consider using only one style whenever possible, and when necessary to use the other style, including an explanatory comment.  In StakingEscrow.sol, there are two deposit functions (one for a full deposit and one for a partial deposit). However, the initiateWithdrawal function and its partner, initiateFullWithdrawal do not match this pattern. Consider overloading the initiateWithdrawal function as well, to match the style of the overloaded deposit function.  Update: Fixed on commit 3efd28b2a4ec84f1569f807bfb636ddfabc92753 in pull request 70.  Typos and erroneous comments  Several typographical errors were found in the codebase which should be corrected. In particular:  Line 26 of FullMath.sol says Remiander instead of Remainder.  Line 29 of FortaStaking.sol says elligible instead of eligible.  Line 401 of ForaStaking.sol says cal instead of can.  Line 49 of StakingEscrow.sol mentions __l1vesting in the error message, instead of __l2manager.  Line 112 of StakingEscrow.sol references the beneficiary, but should instead say manager.  Line 67 of VestingWalletV2.sol says explicitelly instead of explicitly.  Consider correcting the listed typos and errors within comments. Consider utilizing a spell-checker, such as codespell for future changes to the codebase.  Update: Partially fixed on commit 5c273497f71785d1d34f67d083ec494dbfdb99d3 in pull request 71. Some other typos were found and fixed by the Forta team, but the identified instances in FortaStaking.sol and StakingEscrow.sol were not addressed.  Unneeded or unclear frontrunning protection to update an agent  The FrontRunningProtection contract implement the functionality to allow a commit-reveal scheme to run frontrunning-protected actions in the protocol. Between those, are the ones to create and update an agent in the AgentRegistryCore contract.  Although it may be necessary to have such scheme to create a new agent, so no one can own it beforehand, it is not clear why would it be necessary to have the same procedure to update an agent, taking into account that only the owner of such agent is able to perform the update.  In order to improve the readability of the code and the UX of the protocol, consider documenting the reasoning behind the need of the commit-reveal scheme during agent updates.  Update: Fixed on commit ac296e0ce7d5c6c81f772be88cd6fc74fdd2b429 in pull request 72. The unneeded check has been removed.  Vesting schedule is changeable  VestingWallet or  VestingWalletV2 contracts, users should note that their  vestedAmount value is dependent on _historicalBalance output, which may change. If they transfer tokens to the  increase the _historicalBalance output which will result in a changed vesting schedule. Specifically, it will treat the new token amount as vested as well, and it will be released to the user following the vesting schedule. This has the effect of locking up some of the users funds temporarily if they accidentally transfer them to the  This is made more complicated by the fact that the staking system is set up to only allow funds to be transferred back to the VestingWallet contract. So, users must transfer their tokens back to the VestingWallet contract in order to be able to transfer them freely, and at that point they will be re-vested.  Furthermore, any change in the staked value in L2, e.g. funds get slashed, will not be addressed in L1 due to the historicalBalanceMin variable, off-syncing the balances between both chains even if all the remaining staked funds in L2 are bridged back to L1.  Users should also be made aware of the existence of the setHistoricalBalanceBridged function and the updateHistoricalBalanceBridged function, which give the owner role power to instantly affect the vesting schedule, specifically changing its speed.  Consider refactoring the vesting schedule logic to make it more predictable and user-friendly. For example, consider tracking the remaining vesting balance independently from the balance of the contract, so that tokens which are transferred to the VestingWallet contract from L2 are not re-vested. Additionally, consider defining predictable contract logic for calling the setHistoricalBalanceBridged and updateHistoricalBalanceBridged functions so that users can be assured their vesting schedules will not be tampered with maliciously. Finally, consider the legal implications of changing a vesting schedule based on both user and admin actions, as well as the tax implications for a user whose vesting schedule may change without warning.  Update: Acknowledged, will not fix. Forta teams statement for this issue:  There is a limited number of users relying on these contracts, so for those that want to use the staking features we will just need to upgrade the vesting wallets, at which time such users can be thoroughly informed of the functionalities and risks of the upgrade and agree to them. Thanks for the warning!  Conclusions  No critical issues and one high severity issue were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#pragma-statement-is-not-consistent", "labels": ["OpenZeppelin"]}, {"title": "Unneeded public visibility", "body": "Unneeded public visibility", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#unneeded-public-visibility", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent use of roles", "body": "Throughout the codebase, there are several roles in charge of performing unique and sensitive actions. Most of such roles are defined in the Roles.sol file, one of them being the ENS_MANAGER_ROLE role which is in charge of setting the ENS reverse registration.  However, in the FortaCommon contract, this task belongs to the ADMIN_ROLE role instead.  Consider either using the ENS_MANAGER_ROLE role instead of the ADMIN_ROLE role to set such ENS variable or documenting the reason to use the ADMIN_ROLE role to improve the readability of the code and reduce the attack surface.  Update: Fixed on commit e6edd43e02e5b876573ae71e4cccefe0cefd2ef0 in pull request 68.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#inconsistent-use-of-roles", "labels": ["OpenZeppelin"]}, {"title": "Multiple contracts per file", "body": "The file Forwarder.sol contains two contracts: EIP712WithNonce and Forwarder.  Consider separating the contracts into their own files to make the codebase easier to understand for developers and reviewers.  Update: Fixed on commit ea3e792c7f7d3b660381c9d4c9a029fd66cdcbfe in pull request 69.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#multiple-contracts-per-file", "labels": ["OpenZeppelin"]}, {"title": "Styling issues", "body": "Within the codebase, we found a few stylistic issues which, if corrected, would make the codebase easier to review and more understandable, as well as more predictable for future development efforts. Below are our findings:  There is an extra line at ScannerRegistry.sol line 5.  There is an extra line at ScannerNodeVersion.sol line 33.  The _setStakeController private function is placed before public functions in StakeAware.sol.  Within the initialize function of VestingWallet.sol, input parameter names contain a trailing underscore, unlike other initialize functions in the codebase which use two leading underscores for their input parameter names.  Throughout the codebase, there is relatively common usage of the expression ++i in places where i++ would function identically. For example, within a for loop in AgentRegistryCore.sol. This is in contrast to i++ which is also frequently used, for instance in the for loop in BatchRelayer.sol. Consider using only one style whenever possible, and when necessary to use the other style, including an explanatory comment.  In StakingEscrow.sol, there are two deposit functions (one for a full deposit and one for a partial deposit). However, the initiateWithdrawal function and its partner, initiateFullWithdrawal do not match this pattern. Consider overloading the initiateWithdrawal function as well, to match the style of the overloaded deposit function.  Update: Fixed on commit 3efd28b2a4ec84f1569f807bfb636ddfabc92753 in pull request 70.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#styling-issues", "labels": ["OpenZeppelin"]}, {"title": "Typos and erroneous comments", "body": "Several typographical errors were found in the codebase which should be corrected. In particular:  Line 26 of FullMath.sol says Remiander instead of Remainder.  Line 29 of FortaStaking.sol says elligible instead of eligible.  Line 401 of ForaStaking.sol says cal instead of can.  Line 49 of StakingEscrow.sol mentions __l1vesting in the error message, instead of __l2manager.  Line 112 of StakingEscrow.sol references the beneficiary, but should instead say manager.  Line 67 of VestingWalletV2.sol says explicitelly instead of explicitly.  Consider correcting the listed typos and errors within comments. Consider utilizing a spell-checker, such as codespell for future changes to the codebase.  Update: Partially fixed on commit 5c273497f71785d1d34f67d083ec494dbfdb99d3 in pull request 71. Some other typos were found and fixed by the Forta team, but the identified instances in FortaStaking.sol and StakingEscrow.sol were not addressed.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#typos-and-erroneous-comments", "labels": ["OpenZeppelin"]}, {"title": "Unneeded or unclear frontrunning protection to update an agent", "body": "The FrontRunningProtection contract implement the functionality to allow a commit-reveal scheme to run frontrunning-protected actions in the protocol. Between those, are the ones to create and update an agent in the AgentRegistryCore contract.  Although it may be necessary to have such scheme to create a new agent, so no one can own it beforehand, it is not clear why would it be necessary to have the same procedure to update an agent, taking into account that only the owner of such agent is able to perform the update.  In order to improve the readability of the code and the UX of the protocol, consider documenting the reasoning behind the need of the commit-reveal scheme during agent updates.  Update: Fixed on commit ac296e0ce7d5c6c81f772be88cd6fc74fdd2b429 in pull request 72. The unneeded check has been removed.", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#unneeded-or-unclear-frontrunning-protection-to-update-an-agent", "labels": ["OpenZeppelin"]}, {"title": "Vesting schedule is changeable", "body": "VestingWallet or  VestingWalletV2 contracts, users should note that their  vestedAmount value is dependent on _historicalBalance output, which may change. If they transfer tokens to the  increase the _historicalBalance output which will result in a changed vesting schedule. Specifically, it will treat the new token amount as vested as well, and it will be released to the user following the vesting schedule. This has the effect of locking up some of the users funds temporarily if they accidentally transfer them to the  This is made more complicated by the fact that the staking system is set up to only allow funds to be transferred back to the VestingWallet contract. So, users must transfer their tokens back to the VestingWallet contract in order to be able to transfer them freely, and at that point they will be re-vested.  Furthermore, any change in the staked value in L2, e.g. funds get slashed, will not be addressed in L1 due to the historicalBalanceMin variable, off-syncing the balances between both chains even if all the remaining staked funds in L2 are bridged back to L1.  Users should also be made aware of the existence of the setHistoricalBalanceBridged function and the updateHistoricalBalanceBridged function, which give the owner role power to instantly affect the vesting schedule, specifically changing its speed.  Consider refactoring the vesting schedule logic to make it more predictable and user-friendly. For example, consider tracking the remaining vesting balance independently from the balance of the contract, so that tokens which are transferred to the VestingWallet contract from L2 are not re-vested. Additionally, consider defining predictable contract logic for calling the setHistoricalBalanceBridged and updateHistoricalBalanceBridged functions so that users can be assured their vesting schedules will not be tampered with maliciously. Finally, consider the legal implications of changing a vesting schedule based on both user and admin actions, as well as the tax implications for a user whose vesting schedule may change without warning.  Update: Acknowledged, will not fix. Forta teams statement for this issue:  There is a limited number of users relying on these contracts, so for those that want to use the staking features we will just need to upgrade the vesting wallets, at which time such users can be thoroughly informed of the functionalities and risks of the upgrade and agree to them. Thanks for the warning!", "html_url": "https://blog.openzeppelin.com/forta-protocol-audit#vesting-schedule-is-changeable", "labels": ["OpenZeppelin"]}, {"title": "Incorrect or misleading documentation", "body": "Several instances of docstrings or comments in the codebase were found to be erroneous. In particular:  In the SpokePool contract's _fillRelay function, the comment on line 1003 appears unrelated to the if statement on the following line. Consider revising the comment.  The docstring for pauseDeposits in the SpokePool contract says it \"pauses deposit and fill functions\", but pausing fill functions is performed by calling pauseFills, which does not have a docstring.  Consider revising the pauseDeposits docstring and adding a docstring to pauseFills.  Update: Resolved in pull request #251 at commit 21d9ed8.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#incorrect-or-misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission after sensitive action", "body": "The setSuccinctTargetAmb administrative function does not emit a relevant event after changing the succinctTargetAmb address.  Consider always emitting events after sensitive changes take place to facilitate tracking and notify off-chain clients that follow the protocol's contracts' activity.  Update: Resolved in pull request #252 at commit 10c1190. Additionally, new ReceivedMessageFromL1 events were added to the Polygon_SpokePool and Succinct_SpokePool's message handler functions (processMessageFromRoot and handleTelepathy, respectively).", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#lack-of-event-emission-after-sensitive-action", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings. In particular:  AdapterInterface.sol, lines 13-20: The interface functions are undocumented.  Arbitrum_Adapter.sol, lines 9-54: The ArbitrumL1InboxLike and ArbitrumL1ERC20GatewayLike interfaces and their functions are undocumented.  LpTokenFactoryInterface.sol, lines 4-5: The interface and its functions are undocumented.  Optimism_Adapter.sol, lines 15-16: The SynthetixBridgeToOptimism interface and its function are undocumented.  Polygon_Adapter.sol, lines 10-30: The IRootChainManager, IFxStateSender, and DepositManager interfaces and their functions are undocumented.  Polygon_SpokePool.sol, line 11: The processMessageFromRoot function is undocumented.  SpokePool.sol, lines 169-196: The RelayExecution, RelayExecutionInfo, and DepositUpdate structs have undocumented members.  Succinct_SpokePool.sol, line 39: The initialize function has no docstring.  Succinct_SpokePool.sol, line 57: The handleTelepathy function has no docstring.  WETH9Interface.sol, lines 4-11: The interface and its functions are undocumented.  ZkSync_Adapter.sol, lines 13-30: The ZkSyncLike and ZkBridgeLike interfaces and their functions are undocumented.  ZkSync_SpokePool.sol, lines 6-12: The ZkBridgeLike interface and its function are undocumented.  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #253 at commit 5d1090a, pull request #242 at commit 4a8fe1c, and pull request #269 at commit 146f2f2.  The ZkSync_Adapter.sol and ZkSync_SpokePool.sol contracts were not changed. The UMA team stated:  All suggested comments are implemented except for zkSync contracts which were out of this audit's scope and are still in progress and not live.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "updatedRelayerFeePct can be lower than expected", "body": "In the SpokePool contract, the speedUpDeposit function performs the following check on the updatedRelayerFeePct variable:  require  (updatedRelayerFeePct  5e18  \"invalid relayer fee\"  );  equivalent check in the  will be rejected by the  Consider using the SignedMath.abs function to ensure the updatedRelayerFeePct argument provided to speedUpDeposit is within the expected limits.  Update: Resolved in pull request #254 at commit 857e787.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#updatedrelayerfeepct-can-be-lower-than-expected", "labels": ["OpenZeppelin"]}, {"title": "Interface files not in interfaces directory", "body": "The Across Protocol V2 codebase contains the interfaces directory, but the HubPoolInterface.sol and SpokePoolInterface.sol files do not reside in that location. Instead, they are located in the parent directory.  Consider moving all non-external interface files to the interfaces directory, so that interfaces can be more easily located.  Update: Resolved in pull request #255 at commit fa59467.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#interface-files-not-in-interfaces-directory", "labels": ["OpenZeppelin"]}, {"title": "Multiple conditions in a single require statement", "body": "There is a require statement with multiple conditions in the handleTelepathy function of the Succinct_SpokePool contract.  Consider isolating each condition in its own separate require statement with a corresponding error message, to more easily identify the specific condition that failed.  Update: Resolved in pull request #256 at commit c42ea4f.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#multiple-conditions-in-a-single-require-statement", "labels": ["OpenZeppelin"]}, {"title": "Redundant condition in if statement", "body": "In the SpokePool contract, the _updateCountFromFill function is responsible for updating the fillCounter data when a fill takes place. No update is necessary in the following three cases: when the action is either a slow fill or an initial zero-fill, or when a partial fill for that request has already happened.  However, in the case of a zero-fill the execution flow will not reach this function, which makes the condition endingFillAmount == 0 redundant.  Consider removing the redundant condition for increased clarity, readability, and gas savings. For extra safety, consider adding a comment where the function returns if there is a zero-fill, denoting that any updates to this part should take the function _updateCountFromFill into account.  Update: Resolved in pull request #264 at commit ef59e2a. The endingFillAmount == 0 condition has been removed and a comment has been added to clarify that initial zero-fills will not reach this location in the code.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#redundant-condition-in-if-statement", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Consider correcting the following typographical errors:  In BondToken.sol:  Line 11, \"rootBundleProposer()\" should be \"rootBundleProposal()\". Line 21: \"permissiong\" should be \"permissioning\".  In EIP712CrossChainUpgradeable.sol:  Line 83: \"its always\" should be \"it's always\".  In MultiCallerUpgradeable.sol:  Line 5: \"@title MockSpokePool\" should be \"@title MultiCallerUpgradeable\".  In Optimism_Adapter.sol:  Line 23: \"its only\" should be \"it's only\".  In Polygon_SpokePool.sol:  Line 51: the sentence \"See\" is incomplete. Line 139: the sentence is malformed.  In SpokePool.sol:  Line 567: \"speedUpRelay()\" should be \"speedUpDeposit()\". Line 1177: \"its always\" should be \"it's always\".  In Succinct_Adapter.sol:  Line 27: \"destinatipn\" should be \"destination\". Line 27: \"the message..\" should be \"the message.\".  In Succinct_SpokePool.sol:  Line 22: \"callValidated\" should be \"adminCallValidated\". Line 24: \"callValidated\" should be \"adminCallValidated\". Line 35: \"callValidated\" should be \"adminCallValidated\".  Update: Resolved in pull request #258 at commit 43a0ea7.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary modulo operation", "body": "performs a modulo 256 operation on  Consider removing the redundant modulo operation.  Update: Resolved in pull request #259 at commit 04c8488.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#unnecessary-modulo-operation", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "The following imports are unused:  Import AdapterInterface.sol in HubPoolInterface.sol  Import ECDSA.sol in SpokePool.sol  To improve readability and avoid confusion, consider removing any unused imports.  Update: Resolved in pull request #260 at commit 4a94713.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Use of hard-coded values", "body": "The _bridgeTokensToHubPool function in the Ovm_SpokePool contract contains two hard-coded addresses that are not explicitly documented.  Consider creating constants to store these values, and assigning them descriptive variable names.  Update: Resolved in pull request #261 at commit 6f8b6e3.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit#use-of-hard-coded-values", "labels": ["OpenZeppelin"]}, {"title": "[N01] Suggested EIP changes", "body": "[N01] Suggested EIP changes", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n01]-suggested-eip-changes", "labels": ["OpenZeppelin"]}, {"title": "Client reported:\u00a0The Ethereum Foundation made or inspired many of these suggestions during the audit. We include them here for reference.", "body": "Client reported:\u00a0The Ethereum Foundation made or inspired many of these suggestions during the audit. We include them here for reference.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#client-reported:\u00a0the-ethereum-foundation-made-or-inspired-many-of-these-suggestions-during-the-audit.-we-include-them-here-for-reference.", "labels": ["OpenZeppelin"]}, {"title": "Here are some suggestions to improve the precision and clarity of the EIP and associated documentation:", "body": "Here are some suggestions to improve the precision and clarity of the EIP and associated documentation:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#here-are-some-suggestions-to-improve-the-precision-and-clarity-of-the-eip-and-associated-documentation:", "labels": ["OpenZeppelin"]}, {"title": "To prevent cross-chain replay attacks, user operation signatures should depend on the\u00a0chainid. This is handled in the current implementation but not yet included as a requirement in the EIP.", "body": "To prevent cross-chain replay attacks, user operation signatures should depend on the\u00a0chainid. This is handled in the current implementation but not yet included as a requirement in the EIP.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#to-prevent-cross-chain-replay-attacks,-user-operation-signatures-should-depend-on-the\u00a0chainid.-this-is-handled-in-the-current-implementation-but-not-yet-included-as-a-requirement-in-the-eip.", "labels": ["OpenZeppelin"]}, {"title": "After constructing a batch, bundlers should execute\u00a0eth_estimateGas\u00a0with the maximum gas limit. This would mitigate potential\u00a0return bombing\u00a0or other gas manipulation attacks that could cause batches to fail without specifically identifying the offending operation.", "body": "After constructing a batch, bundlers should execute\u00a0eth_estimateGas\u00a0with the maximum gas limit. This would mitigate potential\u00a0return bombing\u00a0or other gas manipulation attacks that could cause batches to fail without specifically identifying the offending operation.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#after-constructing-a-batch,-bundlers-should-execute\u00a0eth_estimategas\u00a0with-the-maximum-gas-limit.-this-would-mitigate-potential\u00a0return-bombing\u00a0or-other-gas-manipulation-attacks-that-could-cause-batches-to-fail-without-specifically-identifying-the-offending-operation.", "labels": ["OpenZeppelin"]}, {"title": "State any restrictions on how bundlers should construct batches, including ensuring all user operations have different senders.", "body": "State any restrictions on how bundlers should construct batches, including ensuring all user operations have different senders.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#state-any-restrictions-on-how-bundlers-should-construct-batches,-including-ensuring-all-user-operations-have-different-senders.", "labels": ["OpenZeppelin"]}, {"title": "State any restrictions on how batches should be arranged or ordered in blocks (e.g. using the access lists) to avoid interference from other transactions.", "body": "State any restrictions on how batches should be arranged or ordered in blocks (e.g. using the access lists) to avoid interference from other transactions.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#state-any-restrictions-on-how-batches-should-be-arranged-or-ordered-in-blocks-(e.g.-using-the-access-lists)-to-avoid-interference-from-other-transactions.", "labels": ["OpenZeppelin"]}, {"title": "Clarify any operations that paymasters can undertake that wallets cannot. Additionally, explain the conditions (e.g. whitelisting) under which a bundler may accept a non-compliant paymaster, such as the\u00a0DepositPaymaster.", "body": "Clarify any operations that paymasters can undertake that wallets cannot. Additionally, explain the conditions (e.g. whitelisting) under which a bundler may accept a non-compliant paymaster, such as the\u00a0DepositPaymaster.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#clarify-any-operations-that-paymasters-can-undertake-that-wallets-cannot.-additionally,-explain-the-conditions-(e.g.-whitelisting)-under-which-a-bundler-may-accept-a-non-compliant-paymaster,-such-as-the\u00a0depositpaymaster.", "labels": ["OpenZeppelin"]}, {"title": "Although implicit in the specification, we believe a complete walkthrough of the lifecycle of a user operation would be instructive.", "body": "Although implicit in the specification, we believe a complete walkthrough of the lifecycle of a user operation would be instructive.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#although-implicit-in-the-specification,-we-believe-a-complete-walkthrough-of-the-lifecycle-of-a-user-operation-would-be-instructive.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#83.", "body": "Update: Fixed in pull request\u00a0#83.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#83.", "labels": ["OpenZeppelin"]}, {"title": "[N02] Imprecise gas limits [core]", "body": "[N02] Imprecise gas limits [core]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n02]-imprecise-gas-limits-[core]", "labels": ["OpenZeppelin"]}, {"title": "combines the various gas parameters into a single variable\u00a0so they can be collectively compared against a hardcoded limit. Although this correctly ensures all values are individually less than the maximum", "body": "combines the various gas parameters into a single variable\u00a0so they can be collectively compared against a hardcoded limit. Although this correctly ensures all values are individually less than the maximum", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#combines-the-various-gas-parameters-into-a-single-variable\u00a0so-they-can-be-collectively-compared-against-a-hardcoded-limit.-although-this-correctly-ensures-all-values-are-individually-less-than-the-maximum", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#86.", "body": "Update: Fixed in pull request\u00a0#86.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#86.", "labels": ["OpenZeppelin"]}, {"title": "[N03] Duplicated naming [core]", "body": "[N03] Duplicated naming [core]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n03]-duplicated-naming-[core]", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0EntryPoint\u00a0contract, the\u00a0paymasterStake\u00a0variable\u00a0has the same name as\u00a0one of the\u00a0PaymentMode\u00a0options.", "body": "In the\u00a0EntryPoint\u00a0contract, the\u00a0paymasterStake\u00a0variable\u00a0has the same name as\u00a0one of the\u00a0PaymentMode\u00a0options.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in-the\u00a0entrypoint\u00a0contract,-the\u00a0paymasterstake\u00a0variable\u00a0has-the-same-name-as\u00a0one-of-the\u00a0paymentmode\u00a0options.", "labels": ["OpenZeppelin"]}, {"title": "Consider using different names to improve code readability and avoid confusion.", "body": "Consider using different names to improve code readability and avoid confusion.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#consider-using-different-names-to-improve-code-readability-and-avoid-confusion.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed. Pull request\u00a0#76\u00a0relocates the\u00a0paymasterStake\u00a0variable from the\u00a0EntryPoint\u00a0contract to the\u00a0StakeManager\u00a0contract, but does not rename it.", "body": "Update: Partially fixed. Pull request\u00a0#76\u00a0relocates the\u00a0paymasterStake\u00a0variable from the\u00a0EntryPoint\u00a0contract to the\u00a0StakeManager\u00a0contract, but does not rename it.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-partially-fixed.-pull-request\u00a0#76\u00a0relocates-the\u00a0paymasterstake\u00a0variable-from-the\u00a0entrypoint\u00a0contract-to-the\u00a0stakemanager\u00a0contract,-but-does-not-rename-it.", "labels": ["OpenZeppelin"]}, {"title": "[N04] ECDSA signature length check allows invalid values [sample]", "body": "[N04] ECDSA signature length check allows invalid values [sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n04]-ecdsa-signature-length-check-allows-invalid-values-[sample]", "labels": ["OpenZeppelin"]}, {"title": "contains a check\u00a0that the ECDSA signature being verified has a length >= 65 bytes. The", "body": "contains a check\u00a0that the ECDSA signature being verified has a length >= 65 bytes. The", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#contains-a-check\u00a0that-the-ecdsa-signature-being-verified-has-a-length->=-65-bytes.-the", "labels": ["OpenZeppelin"]}, {"title": "tryRecover\u00a0function in the OpenZeppelin", "body": "tryRecover\u00a0function in the OpenZeppelin", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#tryrecover\u00a0function-in-the-openzeppelin", "labels": ["OpenZeppelin"]}, {"title": "Consider modifying the check in\u00a0validatePaymasterUserOp\u00a0to only allow ECDSA signature lengths equal to 65.", "body": "Consider modifying the check in\u00a0validatePaymasterUserOp\u00a0to only allow ECDSA signature lengths equal to 65.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#consider-modifying-the-check-in\u00a0validatepaymasteruserop\u00a0to-only-allow-ecdsa-signature-lengths-equal-to-65.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#66. The signature length must now be equal to 64 or 65 to be considered valid. The\u00a0tryRecover\u00a0function supports both length values. Note that this expands the previous functionality to support the 64-byte encoding, so there are now multiple valid signatures for the same operation.", "body": "Update: Fixed in pull request\u00a0#66. The signature length must now be equal to 64 or 65 to be considered valid. The\u00a0tryRecover\u00a0function supports both length values. Note that this expands the previous functionality to support the 64-byte encoding, so there are now multiple valid signatures for the same operation.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#66.-the-signature-length-must-now-be-equal-to-64-or-65-to-be-considered-valid.-the\u00a0tryrecover\u00a0function-supports-both-length-values.-note-that-this-expands-the-previous-functionality-to-support-the-64-byte-encoding,-so-there-are-now-multiple-valid-signatures-for-the-same-operation.", "labels": ["OpenZeppelin"]}, {"title": "[N05] Fixed Oracle [sample]", "body": "[N05] Fixed Oracle [sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n05]-fixed-oracle-[sample]", "labels": ["OpenZeppelin"]}, {"title": "When the owner of the\u00a0DepositPaymaster\u00a0adds a new supported token-oracle pair, it ensures the token\u00a0does not already have an oracle. There is no mechanism to change or remove the oracle. We are simply noting this in case it\u2019s an oversight.", "body": "When the owner of the\u00a0DepositPaymaster\u00a0adds a new supported token-oracle pair, it ensures the token\u00a0does not already have an oracle. There is no mechanism to change or remove the oracle. We are simply noting this in case it\u2019s an oversight.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#when-the-owner-of-the\u00a0depositpaymaster\u00a0adds-a-new-supported-token-oracle-pair,-it-ensures-the-token\u00a0does-not-already-have-an-oracle.-there-is-no-mechanism-to-change-or-remove-the-oracle.-we-are-simply-noting-this-in-case-it\u2019s-an-oversight.", "labels": ["OpenZeppelin"]}, {"title": "Update: Not an issue. This was intentional.", "body": "Update: Not an issue. This was intentional.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-not-an-issue.-this-was-intentional.", "labels": ["OpenZeppelin"]}, {"title": "[N06] Incorrectly set argument [core]", "body": "[N06] Incorrectly set argument [core]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n06]-incorrectly-set-argument-[core]", "labels": ["OpenZeppelin"]}, {"title": "After executing the user operation, the\u00a0internalHandleOp\u00a0function of the\u00a0EntryPoint\u00a0contract\u00a0invokes\u00a0handlePostOp\u00a0with a zero\u00a0opIndex, regardless of the actual position of the operation within the branch. In this particular invocation, the\u00a0opIndex\u00a0parameter is unused, so setting it to zero was chosen as a simplification and gas optimization. Nevertheless, in the interest of code clarity, robustness and to support local reasoning, consider either refactoring the code to avoid the unnecessary parameter, passing in the correct value, or clearly documenting any misleading parameter assignments.", "body": "After executing the user operation, the\u00a0internalHandleOp\u00a0function of the\u00a0EntryPoint\u00a0contract\u00a0invokes\u00a0handlePostOp\u00a0with a zero\u00a0opIndex, regardless of the actual position of the operation within the branch. In this particular invocation, the\u00a0opIndex\u00a0parameter is unused, so setting it to zero was chosen as a simplification and gas optimization. Nevertheless, in the interest of code clarity, robustness and to support local reasoning, consider either refactoring the code to avoid the unnecessary parameter, passing in the correct value, or clearly documenting any misleading parameter assignments.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#after-executing-the-user-operation,-the\u00a0internalhandleop\u00a0function-of-the\u00a0entrypoint\u00a0contract\u00a0invokes\u00a0handlepostop\u00a0with-a-zero\u00a0opindex,-regardless-of-the-actual-position-of-the-operation-within-the-branch.-in-this-particular-invocation,-the\u00a0opindex\u00a0parameter-is-unused,-so-setting-it-to-zero-was-chosen-as-a-simplification-and-gas-optimization.-nevertheless,-in-the-interest-of-code-clarity,-robustness-and-to-support-local-reasoning,-consider-either-refactoring-the-code-to-avoid-the-unnecessary-parameter,-passing-in-the-correct-value,-or-clearly-documenting-any-misleading-parameter-assignments.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#78. A comment was added to explain the zero\u00a0opIndex\u00a0value.", "body": "Update: Fixed in pull request\u00a0#78. A comment was added to explain the zero\u00a0opIndex\u00a0value.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#78.-a-comment-was-added-to-explain-the-zero\u00a0opindex\u00a0value.", "labels": ["OpenZeppelin"]}, {"title": "[N07] Inconsistent naming convention [core]", "body": "[N07] Inconsistent naming convention [core]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n07]-inconsistent-naming-convention-[core]", "labels": ["OpenZeppelin"]}, {"title": "We identified the following examples of inconsistent naming:", "body": "We identified the following examples of inconsistent naming:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#we-identified-the-following-examples-of-inconsistent-naming:", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0EntryPoint.sol:", "body": "line 29 and line 30: simulateOp should be simulateValidation line 178: of should be if line 297: done, by should be done and  In IWallet.sol:  line 10: successfuly. should be successfully.  In StakeManager.sol:  line 12: blocks to should be seconds to wait line 83: time should be duration  In DepositPaymaster.sol:  line 68: on in the same block as withdrawTo() should be in the same block as withdrawTokensTo()  In SimpleWallet.sol:  line 88: (its should be (its  In TokenPaymaster.sol:  line 11: os should be or line 18: method-ids. should be method ids. line 77: paymaster should be entrypoint  In VerifyingPaymaster.sol:  line 57: signing should be to signing  In eip-4337.md:  line 46: for to compensate the bundler for should be to compensate the bundler line 84: worlflow should be workflow line 89: simulateWalletValidation should be simulateValidation line 127: paymaster should be paymaster) line 151: op should be op validation line 165: valiation should be validation and the line should end in a period.  Update: Fixed in pull request #79 and pull request #88.  [N26] Abstract StakeManager contract [core]  The StakeManager contract is intended to provide staking functionality to other contracts, but should not be deployed directly. To better signal this intention, consider declaring the contract as abstract.  Update: Fixed in pull request #76.  [N27] Declare uint as uint256 [core and sample]  To favor explicitness, consider declaring all instance of uint as uint256.  Update: Fixed in pull request #77.  Conclusions  1 critical and 4 high severity issues were found in the code base in addition to the high severity issue that the Ethereum Foundation noted. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix: Architectural Analysis  Overview  Many security features and mitigations to protect nodes and bundlers are executed partially or entirely off-chain; they also involve complex interactions between multiple parties with competing interests. Based on the EIP and our discussions with the Ethereum Foundation, we have captured our understanding of these features to correct any misunderstandings and identify any shortcomings. For clarity, we are referencing the latest design, which includes modifications that were made during or after the audit. This document attempts to describe high level concepts, and then systematically interrogate the details.  Basic Structure  Actors  Wallets  Smart contract wallets are primary accounts. Users construct arbitrary operations and publish them to a new mempool and each operation is associated with a specific smart contract wallet. In practice, each operation is an arbitrary call to the wallet. This allows the wallet to perform an action from its own context. A wallet can be deployed as part of its first operation.  Paymasters  Operations can specify optional paymasters. These are contracts that agree to pay the gas fees associated with the operation. Typically, they would be reimbursed somehow (perhaps with an ERC20 token), but the system does not specify or enforce any particular incentive. They must stake some funds beforehand as an anti-sybil mechanism. They must also prepay for the operations that they will fund.  Bundlers  Bundlers watch the new mempool and aggregate multiple operations into a bundle (i.e. an array of operations). They submit the bundle to miners as an Ethereum transaction. In practice, miners could also be bundlers. They will pay the gas fees associated with the bundle at the transaction gas price. However, users specify their own gas price with each operation and bundlers will be reimbursed at this rate. The difference between the user-specified gas price and the transaction gas price provides the incentive for bundlers to participate.  Miners  Miners treat bundles like normal Ethereum transactions (with a small exception related to transaction ordering, explained below).  Nodes  Nodes are clients that participate in the mempool gossip network without necessarily mining or bundling.  Execution  Bundlers submit their bundle transactions to the global EntryPoint contract. For each operation in the bundle, the EntryPoint validates that the wallet contract accepts it as valid, and that the wallet or paymaster (if specified) is willing and able to pay for it. The paymaster can use this opportunity to validate that the wallet will reimburse them. If any of the validations fail, the whole bundle reverts.  For each (now validated) operation, the EntryPoint creates a new call frame and performs the following steps:  Executes the operation (i.e. invokes the wallet with the operation data) and traps any errors.  Hands control to the paymaster (if it exists) to perform any after-operation functionality, whether or not the operation succeeded. Typically, this would include retrieving reimbursement for the cost of the operation (that the paymaster will pay for).  This call frame wont revert in the first step because errors are caught. If the call frame reverts in the second (after-operation) step, its effects are rolled back, and the paymaster is given another chance to perform any after-revert functionality. If this after-revert step reverts, the whole bundle transaction reverts.  The EntryPoint collects gas costs at the user-specified rate. If the wallet is paying for the transaction, the maximum fee is retrieved before execution, and any unused funds are refunded. If instead the paymaster is paying for the transaction, the funds are deducted from their stake after execution. When all transactions in the bundle have been processed, the EntryPoint sends the funds to a bundler-specified address.  Rationale  Valid operations should be charged  If an operation is validated, someone (either the wallet or the paymaster) has agreed to pay for execution, whether or not the operation itself succeeds. Ideally, the EntryPoint would guarantee that the operation is executed and the bundler will be reimbursed. In practice, the EntryPoint guarantees that either:  All operations in the bundle will be executed and the bundler will be reimbursed, or  The paymaster is misbehaving in an identifiable way, or  The bundle is poorly constructed.  Bundlers are responsible for choosing valid operations  If any of the validations fail on chain, the bundler is at fault. Bundlers should:  Only include valid operations within a bundle.  Use the simulation mechanism (described below) to identify invalidated operations.  If the bundler-specified beneficiary address cannot be paid (for example, if its fallback function reverts), the bundler is at fault. In either case, the transaction reverts and the bundler has to pay the gas costs. Nobody else is affected.  Wallets are responsible for operation execution failures  If an operation fails, the wallet is at fault. Wallets should only accept valid operations. In the event that an operation fails, the wallet or paymaster is still charged for the execution. Paymasters are still provided with the same opportunity to retrieve reimbursement from the wallet.  Wallets are responsible for maintaining paymaster preconditions  If the paymasters after-operation function reverts, the wallet is at fault. Paymasters use their validation step to check preconditions that are assumed to hold after the operation. One example is to use the validation to ensure the wallet has funds, and the after-operation function to retrieve those funds as reimbursement. However, paymasters cannot guarantee that this will succeed because the user operation could invalidate the precondition. For example, the user operation could spend the tokens or revoke the allowance.  Wallets should only choose paymasters with agreeable after-operation functionality, and only approve operations that they know will succeed. If the after-operation function reverts:  The user operation will revert in the same call frame, which means its effects are rolled back.  The paymaster will typically use its after-revert function to retrieve the funds anyway.  The paymaster will pay the gas costs and the bundler will be reimbursed.  The overall effect is that the after-operation function is treated like part of the operation. If it fails, the wallet pays for the execution of a reverted operation.  Paymasters are responsible for guaranteeing payments  As noted above, wallets may cause the paymasters after-operation function to revert. In this scenario, the EntryPoint will invoke the paymasters after-revert function. When considering an individual operation, the paymaster validation step should guarantee the after-revert function will succeed, if it is invoked. Since the user operation has reverted (and its effects are rolled back), the operation cannot undermine this validation. The paymaster will typically use this function to retrieve reimbursement from the wallet; the validation would involve ensuring the wallet has sufficient funds with a corresponding allowance.  If the after-revert function reverts, the paymaster is typically at fault. However, the EntryPoint cannot penalize them directly (by trapping the error and charging them for the gas) because its possible that a valid after-revert function reverts when included in a poorly constructed batch (which would be the bundlers fault). The batch could contain operations that affect the validity of subsequent operations (for example, if multiple operations spend the same funds).  Bundlers are responsible for bundle success  As noted above, when a paymasters after-revert function reverts, the EntryPoint cannot identify if its due to a poorly constructed paymaster or bundle. Therefore, the bundler is responsible for recognizing failing bundles and avoiding operations with misbehaving paymasters. If any after-revert function in the batch reverts, the entire bundle transaction reverts and the bundler has to pay the gas costs. Nobody else, not even the paymaster is directly affected on chain. The bundler will consider the paymaster to be at fault. The off-chain simulation and paymaster reputation system (both explained below) limit the amount of griefing the paymaster can get away with.  Simulation  Overview  Bundlers are responsible for including operations that will pass validation (so the EntryPoint knows they are accepted by wallets and paymasters). They are not responsible for ensuring the operation itself succeeds or the paymaster is reimbursed. Bundlers use off-chain simulation to validate bundles before submitting them. It is worth noting that this process and the associated restrictions are intended as a safety feature for bundlers. It gives them confidence that bundle transactions will succeed and they will be compensated for the gas costs. Bundlers that understand the risks can choose to relax some of these restrictions.  First validation simulation  Clients should call simulateValidation (locally) on each user operation before accepting it into the mempool. This performs the validation for the wallet and paymaster (if it exists) against the current state of the blockchain. In this way, the mempool is only populated with operations that would have been valid at the time they were accepted.  Forbidden opcodes  The EIP lists some opcodes that cannot be used during validation because they contain environmental information about the execution context (not directly related to the state of the blockchain). This implies they can differ between off-chain simulation and on-chain execution. If these opcodes were used, a bundler could be misled into including transactions that would fail on-chain validation. The EntryPoint cannot distinguish this case from one in which the bundler simply included unauthorized transactions; the transaction would revert and the bundler would pay the gas costs. This is intended as a safety feature for bundlers, but it manifests as a restriction on wallets and paymasters.  Second validation simulation  Bundlers should call simulateValidation (locally) on each user operation before including it in a batch. The state of the blockchain can progress while operations are in the mempool, so its possible that previously valid operations become invalid. The second simulation ensures operations are still valid.  Forbidden state accesses  It is acceptable for some operations to become invalid between the first and second simulation. However, if too many operations were invalidated quickly, bundlers would waste time testing and rejecting them all. The EIP design principle is that each invalidated operation should cost an on-chain storage change. Stated more directly, a single on-chain storage change can only invalidate one operation in the mempool. This introduces a natural mitigation against intentionally invalidating multiple operations in the mempool as a denial-of-service attack (since changing on-chain storage costs significantly more than the nuisance caused by invalidating mempool operations).  As with the opcode banning, this is a safety feature for bundlers that manifests as a new restriction on wallets and paymasters. It is more plausible that wallets or paymasters will want to base validation decisions on external storage. Still, most valid use cases are supported. Additionally, bundlers can choose to (internally) whitelist contracts or functions that they know are safe, even if they violate this restriction. Its worth emphasizing that there is no storage restriction during the execution of the operation (which would be very prohibitive).  Bundle execution simulation  The second validation simulation ensures that each operation in a batch individually passes validation. It does not guarantee that the bundle execution will succeed. A bundle of valid operations could fail if:  An operations validation undermines a later validation in the batch.  A paymasters after-revert operation fails. This could occur if multiple transactions in the batch spend the same funds.  The bundle runs out of gas, particularly as a result of return bombing  A paymaster has insufficient funds to cover all operations in a batch. Bundlers should identify this scenario as they are constructing the batch.  Note that if an operations execution undermines a later operations execution, this is not an attack on the bundler. This is analogous to a normal Ethereum transaction in the mempool invalidating another transaction in the mempool. The second operation will fail, but the bundle will still succeed. To detect batch failures, bundlers should run eth_estimateGas on the entire bundle before submitting it. This step is used to obtain the gas required by the bundle. Moreover, if any operation fails, it should be removed from the batch. In this way (when combined with the opcode restrictions), bundlers know that the batch will succeed when executed on the current state of the blockchain.  Bundles have unique wallets  The EIP specifies that each operation in a bundle corresponds to a different wallet. When combined with the forbidden state access rules, this ensures wallet validations cannot interfere with each other. In practice, this is not much of a restriction since wallets will likely use nonces for transaction ordering. This means there should only be one valid operation per wallet at a time. Users can add additional operations with the same nonce to the mempool (e.g. to replace the transaction or increase its gas price), but only one should be included in the batch anyway. Note: There can be repeated paymasters within a bundle. Paymaster interference is handled by the reputation system (explained below). Additionally, our discussion with the Ethereum Foundation suggests that the mempool can only have a limited number operations corresponding to the same wallet.  Execution  Determinism  Bundlers must ensure that the on-chain bundle execution exactly matches the off-chain execution. Otherwise, an unrelated transaction could invalidate the bundle. To this end, bundlers must be a miner or have a relationship with a miner such that:  The bundle is the first transaction in the next block, or  None of the preceding transactions affect the bundle. This could be detected and enforced with access control lists.  Paymaster Reputation System  Paymasters have two opportunities to undermine bundlers:  Since the same paymaster can be used in multiple operations in the mempool, several operations can potentially be invalidated by a single on-chain state change.  Paymasters can have after-revert functions that incorrectly revert.  In both scenarios, the bundler will identify the issue during the bundle execution simulation, and remove the offending operations. Over time, this will result in operations from the same paymaster being added to the mempool (and expiring after 10 blocks) without being included in bundles. As explained in the EIP, paymasters must stake some funds (as an anti-sybil mechanism), and will be throttled or banned if they have too many operations that are not included in bundles. Their stake is not slashed and the rate-limiting calculation is based on the amount of inclusions from the previous day, weighting the more recent hours more heavily. In this way, throttling is naturally reversed over time.  It is worth noting that even though bundlers can construct invalid batches from valid operations (explained above), this is not an attack against paymasters as long as there are some bundlers who include the operations in sensible batches. The possibility of invalid batches from valid operations is why the EntryPoint cannot penalize paymasters directly when their after-revert function fails, but invalid batches themselves do not directly affect the rest of the system because they are never published.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in\u00a0entrypoint.sol:", "labels": ["OpenZeppelin"]}, {"title": "Most internal and private functions are prefixed with an underscore, while\u00a0compensate\u00a0and\u00a0handlePostOp\u00a0are not.", "body": "Most internal and private functions are prefixed with an underscore, while\u00a0compensate\u00a0and\u00a0handlePostOp\u00a0are not.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#most-internal-and-private-functions-are-prefixed-with-an-underscore,-while\u00a0compensate\u00a0and\u00a0handlepostop\u00a0are-not.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0UserOpInfo\u00a0struct has a\u00a0single parameter\u00a0that starts with an underscore.", "body": "The\u00a0UserOpInfo\u00a0struct has a\u00a0single parameter\u00a0that starts with an underscore.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#the\u00a0useropinfo\u00a0struct-has-a\u00a0single-parameter\u00a0that-starts-with-an-underscore.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0_salt\u00a0parameter\u00a0of the\u00a0getSenderAddress\u00a0function starts with an underscore.", "body": "The\u00a0_salt\u00a0parameter\u00a0of the\u00a0getSenderAddress\u00a0function starts with an underscore.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#the\u00a0_salt\u00a0parameter\u00a0of-the\u00a0getsenderaddress\u00a0function-starts-with-an-underscore.", "labels": ["OpenZeppelin"]}, {"title": "Additionally, the prefix \u201cinternal\u201d in function names may cause confusion. It seems redundant for functions declared with the\u00a0internal\u00a0keyword, such as the\u00a0deposit manipulation functions\u00a0and misleading for the\u00a0external\u00a0internalHandleOp\u00a0function. We believe the prefix is intended to be descriptive of the actual function behavior, but nevertheless would recommend a different prefix, perhaps \u201clocal\u201d, to avoid overloading Solidity keywords.", "body": "Additionally, the prefix \u201cinternal\u201d in function names may cause confusion. It seems redundant for functions declared with the\u00a0internal\u00a0keyword, such as the\u00a0deposit manipulation functions\u00a0and misleading for the\u00a0external\u00a0internalHandleOp\u00a0function. We believe the prefix is intended to be descriptive of the actual function behavior, but nevertheless would recommend a different prefix, perhaps \u201clocal\u201d, to avoid overloading Solidity keywords.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#additionally,-the-prefix-\u201cinternal\u201d-in-function-names-may-cause-confusion.-it-seems-redundant-for-functions-declared-with-the\u00a0internal\u00a0keyword,-such-as-the\u00a0deposit-manipulation-functions\u00a0and-misleading-for-the\u00a0external\u00a0internalhandleop\u00a0function.-we-believe-the-prefix-is-intended-to-be-descriptive-of-the-actual-function-behavior,-but-nevertheless-would-recommend-a-different-prefix,-perhaps-\u201clocal\u201d,-to-avoid-overloading-solidity-keywords.", "labels": ["OpenZeppelin"]}, {"title": "For clarity and readability, consider using a consistent naming convention.", "body": "For clarity and readability, consider using a consistent naming convention.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#for-clarity-and-readability,-consider-using-a-consistent-naming-convention.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull requests\u00a0#63\u00a0and\u00a0#67. The function and variable naming was made consistent by adding or removing underscores in the requested locations. The\u00a0internalHandleOp\u00a0function usage has been clarified by renaming it to\u00a0innerHandleOp\u00a0and adding an explanatory docstring. The deposit manipulation functions still retain the redundant \u201cinternal\u201d prefix.", "body": "Update: Fixed in pull requests\u00a0#63\u00a0and\u00a0#67. The function and variable naming was made consistent by adding or removing underscores in the requested locations. The\u00a0internalHandleOp\u00a0function usage has been clarified by renaming it to\u00a0innerHandleOp\u00a0and adding an explanatory docstring. The deposit manipulation functions still retain the redundant \u201cinternal\u201d prefix.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-requests\u00a0#63\u00a0and\u00a0#67.-the-function-and-variable-naming-was-made-consistent-by-adding-or-removing-underscores-in-the-requested-locations.-the\u00a0internalhandleop\u00a0function-usage-has-been-clarified-by-renaming-it-to\u00a0innerhandleop\u00a0and-adding-an-explanatory-docstring.-the-deposit-manipulation-functions-still-retain-the-redundant-\u201cinternal\u201d-prefix.", "labels": ["OpenZeppelin"]}, {"title": "[N08] Explicitly identify and name constants [sample]", "body": "[N08] Explicitly identify and name constants [sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n08]-explicitly-identify-and-name-constants-[sample]", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0TokenPaymaster\u00a0contract, it is recommended to declare the\u00a0COST_OF_POST\u00a0variable as\u00a0constant. This change will eliminate the use of a storage slot for this value.", "body": "In the\u00a0TokenPaymaster\u00a0contract, it is recommended to declare the\u00a0COST_OF_POST\u00a0variable as\u00a0constant. This change will eliminate the use of a storage slot for this value.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in-the\u00a0tokenpaymaster\u00a0contract,-it-is-recommended-to-declare-the\u00a0cost_of_post\u00a0variable-as\u00a0constant.-this-change-will-eliminate-the-use-of-a-storage-slot-for-this-value.", "labels": ["OpenZeppelin"]}, {"title": "For clarity, also consider assigning a named constant to the values\u00a016000\u00a0and\u00a035000\u00a0that appear within the\u00a0validatePaymasterUserOp\u00a0functions.", "body": "For clarity, also consider assigning a named constant to the values\u00a016000\u00a0and\u00a035000\u00a0that appear within the\u00a0validatePaymasterUserOp\u00a0functions.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#for-clarity,-also-consider-assigning-a-named-constant-to-the-values\u00a016000\u00a0and\u00a035000\u00a0that-appear-within-the\u00a0validatepaymasteruserop\u00a0functions.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#68. In the\u00a0TokenPaymaster\u00a0contract the\u00a0constant\u00a0keyword was added to the existing\u00a0COST_OF_POST\u00a0variable and the hard-coded value of 16000 was replaced with\u00a0COST_OF_POST. In the\u00a0DepositPaymaster\u00a0contract a new\u00a0COST_OF_POST\u00a0constant was added and assigned the hard-coded value of 35000. It is also included in the amount charged to the wallet.", "body": "Update: Fixed in pull request\u00a0#68. In the\u00a0TokenPaymaster\u00a0contract the\u00a0constant\u00a0keyword was added to the existing\u00a0COST_OF_POST\u00a0variable and the hard-coded value of 16000 was replaced with\u00a0COST_OF_POST. In the\u00a0DepositPaymaster\u00a0contract a new\u00a0COST_OF_POST\u00a0constant was added and assigned the hard-coded value of 35000. It is also included in the amount charged to the wallet.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#68.-in-the\u00a0tokenpaymaster\u00a0contract-the\u00a0constant\u00a0keyword-was-added-to-the-existing\u00a0cost_of_post\u00a0variable-and-the-hard-coded-value-of-16000-was-replaced-with\u00a0cost_of_post.-in-the\u00a0depositpaymaster\u00a0contract-a-new\u00a0cost_of_post\u00a0constant-was-added-and-assigned-the-hard-coded-value-of-35000.-it-is-also-included-in-the-amount-charged-to-the-wallet.", "labels": ["OpenZeppelin"]}, {"title": "[N09] Failing tests", "body": "[N09] Failing tests", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n09]-failing-tests", "labels": ["OpenZeppelin"]}, {"title": "On a fresh checkout of the project repository and\u00a0npm install\u00a0of the dependencies, the entire test suite fails to run. This has been identified as the result of a mismatch between specific package versions used during development vs. the current versions of those packages.", "body": "On a fresh checkout of the project repository and\u00a0npm install\u00a0of the dependencies, the entire test suite fails to run. This has been identified as the result of a mismatch between specific package versions used during development vs. the current versions of those packages.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#on-a-fresh-checkout-of-the-project-repository-and\u00a0npm-install\u00a0of-the-dependencies,-the-entire-test-suite-fails-to-run.-this-has-been-identified-as-the-result-of-a-mismatch-between-specific-package-versions-used-during-development-vs.-the-current-versions-of-those-packages.", "labels": ["OpenZeppelin"]}, {"title": "On a stable production branch, it is recommended to lock the package versions within the\u00a0package.json\u00a0file to prevent package updates from breaking code that has been previously verified to work correctly.", "body": "On a stable production branch, it is recommended to lock the package versions within the\u00a0package.json\u00a0file to prevent package updates from breaking code that has been previously verified to work correctly.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#on-a-stable-production-branch,-it-is-recommended-to-lock-the-package-versions-within-the\u00a0package.json\u00a0file-to-prevent-package-updates-from-breaking-code-that-has-been-previously-verified-to-work-correctly.", "labels": ["OpenZeppelin"]}, {"title": "Update: Not an issue. Tests can be run successfully if the\u00a0yarn install\u00a0command is used instead of\u00a0npm install. Providing the exact instructions for building and testing the project in a README file would benefit other developers.", "body": "Update: Not an issue. Tests can be run successfully if the\u00a0yarn install\u00a0command is used instead of\u00a0npm install. Providing the exact instructions for building and testing the project in a README file would benefit other developers.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-not-an-issue.-tests-can-be-run-successfully-if-the\u00a0yarn-install\u00a0command-is-used-instead-of\u00a0npm-install.-providing-the-exact-instructions-for-building-and-testing-the-project-in-a-readme-file-would-benefit-other-developers.", "labels": ["OpenZeppelin"]}, {"title": "[N10] Unindexed event addresses [sample]", "body": "[N10] Unindexed event addresses [sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n10]-unindexed-event-addresses-[sample]", "labels": ["OpenZeppelin"]}, {"title": "To support log filtering for the\u00a0EntryPointChanged\u00a0event in the\u00a0SimpleWallet\u00a0contract, consider adding the\u00a0indexed\u00a0keyword to the address parameters in the event.", "body": "To support log filtering for the\u00a0EntryPointChanged\u00a0event in the\u00a0SimpleWallet\u00a0contract, consider adding the\u00a0indexed\u00a0keyword to the address parameters in the event.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#to-support-log-filtering-for-the\u00a0entrypointchanged\u00a0event-in-the\u00a0simplewallet\u00a0contract,-consider-adding-the\u00a0indexed\u00a0keyword-to-the-address-parameters-in-the-event.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#69.", "body": "Update: Fixed in pull request\u00a0#69.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#69.", "labels": ["OpenZeppelin"]}, {"title": "[N11] IWallet doesn\u2019t strongly enforce required functionality [sample]", "body": "[N11] IWallet doesn\u2019t strongly enforce required functionality [sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n11]-iwallet-doesn\u2019t-strongly-enforce-required-functionality-[sample]", "labels": ["OpenZeppelin"]}, {"title": "IWallet\u00a0interface\u00a0specifies a single", "body": "IWallet\u00a0interface\u00a0specifies a single", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#iwallet\u00a0interface\u00a0specifies-a-single", "labels": ["OpenZeppelin"]}, {"title": "all the necessary logic\u00a0in its own", "body": "all the necessary logic\u00a0in its own", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#all-the-necessary-logic\u00a0in-its-own", "labels": ["OpenZeppelin"]}, {"title": "To help developers create secure wallet implementations that follow the\u00a0EIP specification, consider removing the\u00a0IWallet\u00a0interface and replacing it with an abstract \u201cBaseWallet\u201d contract that implements all of the mandated checks, but leaves the custom behavior such as\u00a0validateSignature\u00a0up to derived classes. The existing\u00a0SimpleWallet\u00a0contract would then be derived from BaseWallet.", "body": "To help developers create secure wallet implementations that follow the\u00a0EIP specification, consider removing the\u00a0IWallet\u00a0interface and replacing it with an abstract \u201cBaseWallet\u201d contract that implements all of the mandated checks, but leaves the custom behavior such as\u00a0validateSignature\u00a0up to derived classes. The existing\u00a0SimpleWallet\u00a0contract would then be derived from BaseWallet.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#to-help-developers-create-secure-wallet-implementations-that-follow-the\u00a0eip-specification,-consider-removing-the\u00a0iwallet\u00a0interface-and-replacing-it-with-an-abstract-\u201cbasewallet\u201d-contract-that-implements-all-of-the-mandated-checks,-but-leaves-the-custom-behavior-such-as\u00a0validatesignature\u00a0up-to-derived-classes.-the-existing\u00a0simplewallet\u00a0contract-would-then-be-derived-from-basewallet.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#82. A new\u00a0BaseWallet\u00a0contract has been added that requires wallet implementers to adhere to the\u00a0validateUserOp\u00a0function structure originally laid out in the\u00a0SimpleWallet\u00a0sample contract;\u00a0SimpleWallet\u00a0now inherits from\u00a0BaseWallet.", "body": "Update: Fixed in pull request\u00a0#82. A new\u00a0BaseWallet\u00a0contract has been added that requires wallet implementers to adhere to the\u00a0validateUserOp\u00a0function structure originally laid out in the\u00a0SimpleWallet\u00a0sample contract;\u00a0SimpleWallet\u00a0now inherits from\u00a0BaseWallet.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#82.-a-new\u00a0basewallet\u00a0contract-has-been-added-that-requires-wallet-implementers-to-adhere-to-the\u00a0validateuserop\u00a0function-structure-originally-laid-out-in-the\u00a0simplewallet\u00a0sample-contract;\u00a0simplewallet\u00a0now-inherits-from\u00a0basewallet.", "labels": ["OpenZeppelin"]}, {"title": "[N12] Not all state variables have explicit visibility [sample]", "body": "[N12] Not all state variables have explicit visibility [sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n12]-not-all-state-variables-have-explicit-visibility-[sample]", "labels": ["OpenZeppelin"]}, {"title": "Several contracts in the samples directory don\u2019t explicitly declare the visibility of the state variables and constants:", "body": "Several contracts in the samples directory don\u2019t explicitly declare the visibility of the state variables and constants:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#several-contracts-in-the-samples-directory-don\u2019t-explicitly-declare-the-visibility-of-the-state-variables-and-constants:", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0DepositPaymaster\u00a0contract: \u2013\u00a0nullOracle\u00a0\u2013\u00a0unlockBlock", "body": "In the\u00a0DepositPaymaster\u00a0contract: \u2013\u00a0nullOracle\u00a0\u2013\u00a0unlockBlock", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in-the\u00a0depositpaymaster\u00a0contract:-\u2013\u00a0nulloracle\u00a0\u2013\u00a0unlockblock", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0TokenPaymaster\u00a0contract: \u2013\u00a0knownWallet", "body": "In the\u00a0TokenPaymaster\u00a0contract: \u2013\u00a0knownWallet", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in-the\u00a0tokenpaymaster\u00a0contract:-\u2013\u00a0knownwallet", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0SimpleWallet\u00a0contract: \u2013\u00a0ownerNonce", "body": "In the\u00a0SimpleWallet\u00a0contract: \u2013\u00a0ownerNonce", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in-the\u00a0simplewallet\u00a0contract:-\u2013\u00a0ownernonce", "labels": ["OpenZeppelin"]}, {"title": "For clarity, consider always explicitly declaring the visibility of functions and variables, even when the default visibility type matches the intended type.", "body": "For clarity, consider always explicitly declaring the visibility of functions and variables, even when the default visibility type matches the intended type.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#for-clarity,-consider-always-explicitly-declaring-the-visibility-of-functions-and-variables,-even-when-the-default-visibility-type-matches-the-intended-type.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#70.", "body": "[N15] Inconsistent solidity version [core and sample]  The majority of the code base supports solidity versions ^0.8.7, but the StakeManager contract supports versions ^0.8 and the ECDSA contract supports versions ^0.8.0.  Consider using consistent solidity versions throughout the code base. Additionally, in the interest of predictability, consider locking the contracts to a specific supported version.  Update: Fixed in pull request #71 and commit 4efa5fc296f0034dbf402dcd558a07be45bdd761. All contracts were updated to use Solidity version ^0.8.12.  All of the contract versions remain unpinned.  [N16] Undocumented assembly [core and sample]  There are several contracts where inline assembly code is undocumented. Using inline assembly is risky because it bypasses some of the compilers safety checks, its harder to read and audit, and more likely to contain errors. For these reasons, the recommended best practice is for every line of assembly to have a corresponding explanatory comment.  Consider adding documentation to the following lines of code:  ECDSA.sol lines 188-202  UserOperation.sol line 25  UserOperation.sol lines 64-71  Update: Partially fixed in pull request #72. High-level comments were added to assembly blocks but individual lines remain uncommented.  [N17] Excessive code optimization [core]  getSender function takes a  inline assembly code. This is the only struct member that has its own custom getter function, and even though there are two addresses in the struct (  For safety and clarity, consider removal of the getSender function.  Update: Not fixed. A comment was added in pull request #72 that indicates this function saves 800 gas by using inline assembly.  [N18] Indirect import [sample]  The TokenPaymaster contract imports the obsolete SimpleWalletForTokens contract as an indirect mechanism to import the SimpleWallet contract. Consider replacing the indirect import with a direct one.  Update: Fixed in pull request #73.  [N19] Unused imports [sample]  To improve readability and avoid confusion, consider removing the following unused imports:  In the TokenPaymaster contract, the hardhat console library.  In the SimpleWallet contract, the hardhat console library.  In the TestCounter contract, the UserOperation contract and the IWallet interface.  In the TestOracle contract, the OpenZeppelin ERC20 contract.  In the TestUtil contract, the IWallet interface.  Update: Fixed in pull request #73 and commit 4efa5fc296f0034dbf402dcd558a07be45bdd761.  [N20] Redundant code [core and sample]  Consider making the following changes to eliminate redundant code:  In UserOperation.sol, the requiredGas function calculates mul by evaluating the expression userOp.paymaster != address(0), which is equivalent to hasPaymaster(userOp).  In UserOperation.sol, the pack function has an unnecessary return statement.  In DepositPaymaster.sol, the statement to silence an unused variable warning for mode can be removed. The mode variable is used to determine the payment method.  Update: Fixed in pull request #73.  [N21] Inconsistent clearing of memory [sample]  OpenZeppelins ECDSA library, which replaces the existing  ecrecover2 assembly implementation that does not use the GAS opcode. After  a few more instructions to zero out the first two words of the free memory space, overwriting the  associated comment it can be inferred that memory space is being zeroed out for the benefit of future callers that might assume the memory has been cleared. However, the current implementation is not clearing all of the modified memoryit only zeroes out the  Consider either clearing all of the memory used, or none of it. The Solidity documentation makes it clear that users should not expect the free memory to point to zeroed-out memory, so this final clearing operation is not necessary.  Update: Fixed in pull request #56. The memory clearing instructions were removed.  Following this pull request, the EIP was updated to allow the GAS opcode to be used when simulating validation, provided that it is followed by CALL, DELEGATECALL, CALLCODE, or STATICCALL. Additional statement from the Ethereum Foundation on this issue:  This is no longer an issue, since we removed completely the need for ecrecover2 (we allow the use of GAS opcode if immediately followed by *CALL).  [N22] Unclear use of mixed size values [core]  The StakeManager contract defines the DepositInfo struct with three values of size uint112, uint32 and uint64. While the intention to pack the contents into a single word can be inferred, the reason for the particular sizes are not obvious. Consider documenting the reason for this design pattern and the corresponding (reasonable) assumptions about the maximum sizes of each type.  Update: Fixed in pull request #76.  [N23] Unused parameter in validatePaymasterUserOp methods [sample]  validatePaymasterUserOp function in the  Consider providing a sample paymaster contract that demonstrates the use of the requestId parameter for validation.  Update: Acknowledged.  [N24] Naming suggestions [core and sample]  We believe some functions are variables could benefit from renaming. These are our suggestions:  The IOracle, DepositPaymaster and TokenPaymaster contracts all have a getTokenToEthOutputPrice function, but in all cases, its not a price (because it accounts for the amount bought) and it appears to be described backwards. Something like getTokenValueOfEth would be clearer.  The last parameter of validateUserOp in the IWallet interface should be missingWalletFunds or additionalFundsRequired to match how its used in the EntryPoint contract.  The gasUsedByValidateUserOp variable should be gasUsedByValidateWalletPrepayment  The PaymentMode options should be paymasterDeposit and walletDeposit, because neither uses the stake for gas payments.  The sender parameter in the _call function of the SimpleWallet contract should be target.  The maxPriorityFeePerGas component of the UserOperation struct should be priorityFeePerGas.  In BasePaymaster, the setEntrypoint and _requireFromEntrypoint functions should capitalize the p for consistency with the rest of the code base.  Update: Partially fixed in pull request #80 and commit 074672b6ccfb596fe7ff44e13783881a2e1cfed2. The following naming suggestions were not implemented:  The maxPriorityFeePerGas component of the UserOperation struct should be priorityFeePerGas. Ethereum Foundation comment on this issue:  Note that maxPriorityFeePerGas was left unchanged, since it defines the maximum, not actual fee paid by the user.  [N25] Typographical errors [core and sample]  Consider addressing the following typographical errors:  In EntryPoint.sol:  line 29 and line 30: simulateOp should be simulateValidation line 178: of should be if line 297: done, by should be done and  In IWallet.sol:  line 10: successfuly. should be successfully.  In StakeManager.sol:  line 12: blocks to should be seconds to wait line 83: time should be duration  In DepositPaymaster.sol:  line 68: on in the same block as withdrawTo() should be in the same block as withdrawTokensTo()  In SimpleWallet.sol:  line 88: (its should be (its  In TokenPaymaster.sol:  line 11: os should be or line 18: method-ids. should be method ids. line 77: paymaster should be entrypoint  In VerifyingPaymaster.sol:  line 57: signing should be to signing  In eip-4337.md:  line 46: for to compensate the bundler for should be to compensate the bundler line 84: worlflow should be workflow line 89: simulateWalletValidation should be simulateValidation line 127: paymaster should be paymaster) line 151: op should be op validation line 165: valiation should be validation and the line should end in a period.  Update: Fixed in pull request #79 and pull request #88.  [N26] Abstract StakeManager contract [core]  The StakeManager contract is intended to provide staking functionality to other contracts, but should not be deployed directly. To better signal this intention, consider declaring the contract as abstract.  Update: Fixed in pull request #76.  [N27] Declare uint as uint256 [core and sample]  To favor explicitness, consider declaring all instance of uint as uint256.  Update: Fixed in pull request #77.  Conclusions  1 critical and 4 high severity issues were found in the code base in addition to the high severity issue that the Ethereum Foundation noted. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix: Architectural Analysis  Overview  Many security features and mitigations to protect nodes and bundlers are executed partially or entirely off-chain; they also involve complex interactions between multiple parties with competing interests. Based on the EIP and our discussions with the Ethereum Foundation, we have captured our understanding of these features to correct any misunderstandings and identify any shortcomings. For clarity, we are referencing the latest design, which includes modifications that were made during or after the audit. This document attempts to describe high level concepts, and then systematically interrogate the details.  Basic Structure  Actors  Wallets  Smart contract wallets are primary accounts. Users construct arbitrary operations and publish them to a new mempool and each operation is associated with a specific smart contract wallet. In practice, each operation is an arbitrary call to the wallet. This allows the wallet to perform an action from its own context. A wallet can be deployed as part of its first operation.  Paymasters  Operations can specify optional paymasters. These are contracts that agree to pay the gas fees associated with the operation. Typically, they would be reimbursed somehow (perhaps with an ERC20 token), but the system does not specify or enforce any particular incentive. They must stake some funds beforehand as an anti-sybil mechanism. They must also prepay for the operations that they will fund.  Bundlers  Bundlers watch the new mempool and aggregate multiple operations into a bundle (i.e. an array of operations). They submit the bundle to miners as an Ethereum transaction. In practice, miners could also be bundlers. They will pay the gas fees associated with the bundle at the transaction gas price. However, users specify their own gas price with each operation and bundlers will be reimbursed at this rate. The difference between the user-specified gas price and the transaction gas price provides the incentive for bundlers to participate.  Miners  Miners treat bundles like normal Ethereum transactions (with a small exception related to transaction ordering, explained below).  Nodes  Nodes are clients that participate in the mempool gossip network without necessarily mining or bundling.  Execution  Bundlers submit their bundle transactions to the global EntryPoint contract. For each operation in the bundle, the EntryPoint validates that the wallet contract accepts it as valid, and that the wallet or paymaster (if specified) is willing and able to pay for it. The paymaster can use this opportunity to validate that the wallet will reimburse them. If any of the validations fail, the whole bundle reverts.  For each (now validated) operation, the EntryPoint creates a new call frame and performs the following steps:  Executes the operation (i.e. invokes the wallet with the operation data) and traps any errors.  Hands control to the paymaster (if it exists) to perform any after-operation functionality, whether or not the operation succeeded. Typically, this would include retrieving reimbursement for the cost of the operation (that the paymaster will pay for).  This call frame wont revert in the first step because errors are caught. If the call frame reverts in the second (after-operation) step, its effects are rolled back, and the paymaster is given another chance to perform any after-revert functionality. If this after-revert step reverts, the whole bundle transaction reverts.  The EntryPoint collects gas costs at the user-specified rate. If the wallet is paying for the transaction, the maximum fee is retrieved before execution, and any unused funds are refunded. If instead the paymaster is paying for the transaction, the funds are deducted from their stake after execution. When all transactions in the bundle have been processed, the EntryPoint sends the funds to a bundler-specified address.  Rationale  Valid operations should be charged  If an operation is validated, someone (either the wallet or the paymaster) has agreed to pay for execution, whether or not the operation itself succeeds. Ideally, the EntryPoint would guarantee that the operation is executed and the bundler will be reimbursed. In practice, the EntryPoint guarantees that either:  All operations in the bundle will be executed and the bundler will be reimbursed, or  The paymaster is misbehaving in an identifiable way, or  The bundle is poorly constructed.  Bundlers are responsible for choosing valid operations  If any of the validations fail on chain, the bundler is at fault. Bundlers should:  Only include valid operations within a bundle.  Use the simulation mechanism (described below) to identify invalidated operations.  If the bundler-specified beneficiary address cannot be paid (for example, if its fallback function reverts), the bundler is at fault. In either case, the transaction reverts and the bundler has to pay the gas costs. Nobody else is affected.  Wallets are responsible for operation execution failures  If an operation fails, the wallet is at fault. Wallets should only accept valid operations. In the event that an operation fails, the wallet or paymaster is still charged for the execution. Paymasters are still provided with the same opportunity to retrieve reimbursement from the wallet.  Wallets are responsible for maintaining paymaster preconditions  If the paymasters after-operation function reverts, the wallet is at fault. Paymasters use their validation step to check preconditions that are assumed to hold after the operation. One example is to use the validation to ensure the wallet has funds, and the after-operation function to retrieve those funds as reimbursement. However, paymasters cannot guarantee that this will succeed because the user operation could invalidate the precondition. For example, the user operation could spend the tokens or revoke the allowance.  Wallets should only choose paymasters with agreeable after-operation functionality, and only approve operations that they know will succeed. If the after-operation function reverts:  The user operation will revert in the same call frame, which means its effects are rolled back.  The paymaster will typically use its after-revert function to retrieve the funds anyway.  The paymaster will pay the gas costs and the bundler will be reimbursed.  The overall effect is that the after-operation function is treated like part of the operation. If it fails, the wallet pays for the execution of a reverted operation.  Paymasters are responsible for guaranteeing payments  As noted above, wallets may cause the paymasters after-operation function to revert. In this scenario, the EntryPoint will invoke the paymasters after-revert function. When considering an individual operation, the paymaster validation step should guarantee the after-revert function will succeed, if it is invoked. Since the user operation has reverted (and its effects are rolled back), the operation cannot undermine this validation. The paymaster will typically use this function to retrieve reimbursement from the wallet; the validation would involve ensuring the wallet has sufficient funds with a corresponding allowance.  If the after-revert function reverts, the paymaster is typically at fault. However, the EntryPoint cannot penalize them directly (by trapping the error and charging them for the gas) because its possible that a valid after-revert function reverts when included in a poorly constructed batch (which would be the bundlers fault). The batch could contain operations that affect the validity of subsequent operations (for example, if multiple operations spend the same funds).  Bundlers are responsible for bundle success  As noted above, when a paymasters after-revert function reverts, the EntryPoint cannot identify if its due to a poorly constructed paymaster or bundle. Therefore, the bundler is responsible for recognizing failing bundles and avoiding operations with misbehaving paymasters. If any after-revert function in the batch reverts, the entire bundle transaction reverts and the bundler has to pay the gas costs. Nobody else, not even the paymaster is directly affected on chain. The bundler will consider the paymaster to be at fault. The off-chain simulation and paymaster reputation system (both explained below) limit the amount of griefing the paymaster can get away with.  Simulation  Overview  Bundlers are responsible for including operations that will pass validation (so the EntryPoint knows they are accepted by wallets and paymasters). They are not responsible for ensuring the operation itself succeeds or the paymaster is reimbursed. Bundlers use off-chain simulation to validate bundles before submitting them. It is worth noting that this process and the associated restrictions are intended as a safety feature for bundlers. It gives them confidence that bundle transactions will succeed and they will be compensated for the gas costs. Bundlers that understand the risks can choose to relax some of these restrictions.  First validation simulation  Clients should call simulateValidation (locally) on each user operation before accepting it into the mempool. This performs the validation for the wallet and paymaster (if it exists) against the current state of the blockchain. In this way, the mempool is only populated with operations that would have been valid at the time they were accepted.  Forbidden opcodes  The EIP lists some opcodes that cannot be used during validation because they contain environmental information about the execution context (not directly related to the state of the blockchain). This implies they can differ between off-chain simulation and on-chain execution. If these opcodes were used, a bundler could be misled into including transactions that would fail on-chain validation. The EntryPoint cannot distinguish this case from one in which the bundler simply included unauthorized transactions; the transaction would revert and the bundler would pay the gas costs. This is intended as a safety feature for bundlers, but it manifests as a restriction on wallets and paymasters.  Second validation simulation  Bundlers should call simulateValidation (locally) on each user operation before including it in a batch. The state of the blockchain can progress while operations are in the mempool, so its possible that previously valid operations become invalid. The second simulation ensures operations are still valid.  Forbidden state accesses  It is acceptable for some operations to become invalid between the first and second simulation. However, if too many operations were invalidated quickly, bundlers would waste time testing and rejecting them all. The EIP design principle is that each invalidated operation should cost an on-chain storage change. Stated more directly, a single on-chain storage change can only invalidate one operation in the mempool. This introduces a natural mitigation against intentionally invalidating multiple operations in the mempool as a denial-of-service attack (since changing on-chain storage costs significantly more than the nuisance caused by invalidating mempool operations).  As with the opcode banning, this is a safety feature for bundlers that manifests as a new restriction on wallets and paymasters. It is more plausible that wallets or paymasters will want to base validation decisions on external storage. Still, most valid use cases are supported. Additionally, bundlers can choose to (internally) whitelist contracts or functions tha", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#70.", "labels": ["OpenZeppelin"]}, {"title": "[N13] One oracle per token restriction [sample]", "body": "[N13] One oracle per token restriction [sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n13]-one-oracle-per-token-restriction-[sample]", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0getTokenToEthOutputPrice\u00a0function\u00a0of the\u00a0IOracle\u00a0interface does not specify the particular token to translate. This means that each\u00a0IOracle\u00a0contract can only support one token, which seems like an unnecessary restriction. Consider including a\u00a0tokenAddress\u00a0parameter to the function specification.", "body": "The\u00a0getTokenToEthOutputPrice\u00a0function\u00a0of the\u00a0IOracle\u00a0interface does not specify the particular token to translate. This means that each\u00a0IOracle\u00a0contract can only support one token, which seems like an unnecessary restriction. Consider including a\u00a0tokenAddress\u00a0parameter to the function specification.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#the\u00a0gettokentoethoutputprice\u00a0function\u00a0of-the\u00a0ioracle\u00a0interface-does-not-specify-the-particular-token-to-translate.-this-means-that-each\u00a0ioracle\u00a0contract-can-only-support-one-token,-which-seems-like-an-unnecessary-restriction.-consider-including-a\u00a0tokenaddress\u00a0parameter-to-the-function-specification.", "labels": ["OpenZeppelin"]}, {"title": "Update: Not an issue. An oracle is intended to be an\u00a0IUniswapExchange, which has a single instance per token.", "body": "Update: Not an issue. An oracle is intended to be an\u00a0IUniswapExchange, which has a single instance per token.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-not-an-issue.-an-oracle-is-intended-to-be-an\u00a0iuniswapexchange,-which-has-a-single-instance-per-token.", "labels": ["OpenZeppelin"]}, {"title": "[N14] Unnecessary encapsulation [sample]", "body": "[N14] Unnecessary encapsulation [sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n14]-unnecessary-encapsulation-[sample]", "labels": ["OpenZeppelin"]}, {"title": "OwnerNonce\u00a0struct. Since these variables would still pack into a single storage slot without the struct, encapsulating them together in", "body": "OwnerNonce\u00a0struct. Since these variables would still pack into a single storage slot without the struct, encapsulating them together in", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#ownernonce\u00a0struct.-since-these-variables-would-still-pack-into-a-single-storage-slot-without-the-struct,-encapsulating-them-together-in", "labels": ["OpenZeppelin"]}, {"title": "owner\u00a0and", "body": "owner\u00a0and", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#owner\u00a0and", "labels": ["OpenZeppelin"]}, {"title": "nonce\u00a0getter functions.", "body": "nonce\u00a0getter functions.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#nonce\u00a0getter-functions.", "labels": ["OpenZeppelin"]}, {"title": "Consider removing the\u00a0OwnerNonce\u00a0struct and having standalone\u00a0nonce\u00a0and\u00a0owner\u00a0state variables.", "body": "Consider removing the\u00a0OwnerNonce\u00a0struct and having standalone\u00a0nonce\u00a0and\u00a0owner\u00a0state variables.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#consider-removing-the\u00a0ownernonce\u00a0struct-and-having-standalone\u00a0nonce\u00a0and\u00a0owner\u00a0state-variables.", "labels": ["OpenZeppelin"]}, {"title": "[N15] Inconsistent solidity version [core and sample]", "body": "[N15] Inconsistent solidity version [core and sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n15]-inconsistent-solidity-version-[core-and-sample]", "labels": ["OpenZeppelin"]}, {"title": "The majority of the code base supports solidity versions\u00a0^0.8.7, but the\u00a0StakeManager\u00a0contract\u00a0supports versions\u00a0^0.8\u00a0and the\u00a0ECDSA\u00a0contract\u00a0supports versions\u00a0^0.8.0.", "body": "The majority of the code base supports solidity versions\u00a0^0.8.7, but the\u00a0StakeManager\u00a0contract\u00a0supports versions\u00a0^0.8\u00a0and the\u00a0ECDSA\u00a0contract\u00a0supports versions\u00a0^0.8.0.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#the-majority-of-the-code-base-supports-solidity-versions\u00a0^0.8.7,-but-the\u00a0stakemanager\u00a0contract\u00a0supports-versions\u00a0^0.8\u00a0and-the\u00a0ecdsa\u00a0contract\u00a0supports-versions\u00a0^0.8.0.", "labels": ["OpenZeppelin"]}, {"title": "Consider using consistent solidity versions throughout the code base. Additionally, in the interest of predictability, consider locking the contracts to a specific supported version.", "body": "Consider using consistent solidity versions throughout the code base. Additionally, in the interest of predictability, consider locking the contracts to a specific supported version.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#consider-using-consistent-solidity-versions-throughout-the-code-base.-additionally,-in-the-interest-of-predictability,-consider-locking-the-contracts-to-a-specific-supported-version.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#71\u00a0and commit\u00a04efa5fc296f0034dbf402dcd558a07be45bdd761. All contracts were updated to use Solidity version\u00a0^0.8.12.", "body": "Update: Fixed in pull request\u00a0#71\u00a0and commit\u00a04efa5fc296f0034dbf402dcd558a07be45bdd761. All contracts were updated to use Solidity version\u00a0^0.8.12.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#71\u00a0and-commit\u00a04efa5fc296f0034dbf402dcd558a07be45bdd761.-all-contracts-were-updated-to-use-solidity-version\u00a0^0.8.12.", "labels": ["OpenZeppelin"]}, {"title": "All of the contract versions remain unpinned.", "body": "All of the contract versions remain unpinned.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#all-of-the-contract-versions-remain-unpinned.", "labels": ["OpenZeppelin"]}, {"title": "[N16] Undocumented assembly [core and sample]", "body": "[N16] Undocumented assembly [core and sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n16]-undocumented-assembly-[core-and-sample]", "labels": ["OpenZeppelin"]}, {"title": "There are several contracts where inline assembly code is undocumented. Using inline assembly is risky because it bypasses some of the compiler\u2019s safety checks, it\u2019s harder to read and audit, and more likely to contain errors. For these reasons, the recommended best practice is for every line of assembly to have a corresponding explanatory comment.", "body": "There are several contracts where inline assembly code is undocumented. Using inline assembly is risky because it bypasses some of the compiler\u2019s safety checks, it\u2019s harder to read and audit, and more likely to contain errors. For these reasons, the recommended best practice is for every line of assembly to have a corresponding explanatory comment.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#there-are-several-contracts-where-inline-assembly-code-is-undocumented.-using-inline-assembly-is-risky-because-it-bypasses-some-of-the-compiler\u2019s-safety-checks,-it\u2019s-harder-to-read-and-audit,-and-more-likely-to-contain-errors.-for-these-reasons,-the-recommended-best-practice-is-for-every-line-of-assembly-to-have-a-corresponding-explanatory-comment.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding documentation to the following lines of code:", "body": "Consider adding documentation to the following lines of code:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#consider-adding-documentation-to-the-following-lines-of-code:", "labels": ["OpenZeppelin"]}, {"title": "ECDSA.sol lines 188-202", "body": "ECDSA.sol lines 188-202", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#ecdsa.sol-lines-188-202", "labels": ["OpenZeppelin"]}, {"title": "UserOperation.sol line 25", "body": "UserOperation.sol line 25", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#useroperation.sol-line-25", "labels": ["OpenZeppelin"]}, {"title": "UserOperation.sol lines 64-71", "body": "UserOperation.sol lines 64-71", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#useroperation.sol-lines-64-71", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed in pull request\u00a0#72. High-level comments were added to assembly blocks but individual lines remain uncommented.", "body": "Update: Partially fixed in pull request\u00a0#72. High-level comments were added to assembly blocks but individual lines remain uncommented.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-partially-fixed-in-pull-request\u00a0#72.-high-level-comments-were-added-to-assembly-blocks-but-individual-lines-remain-uncommented.", "labels": ["OpenZeppelin"]}, {"title": "[N17] Excessive code optimization [core]", "body": "[N17] Excessive code optimization [core]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n17]-excessive-code-optimization-[core]", "labels": ["OpenZeppelin"]}, {"title": "getSender\u00a0function takes a", "body": "getSender\u00a0function takes a", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#getsender\u00a0function-takes-a", "labels": ["OpenZeppelin"]}, {"title": "inline assembly code. This is the only struct member that has its own custom getter function, and even though there are two addresses in the struct (", "body": "inline assembly code. This is the only struct member that has its own custom getter function, and even though there are two addresses in the struct (", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#inline-assembly-code.-this-is-the-only-struct-member-that-has-its-own-custom-getter-function,-and-even-though-there-are-two-addresses-in-the-struct-(", "labels": ["OpenZeppelin"]}, {"title": "For safety and clarity, consider removal of the\u00a0getSender\u00a0function.", "body": "For safety and clarity, consider removal of the\u00a0getSender\u00a0function.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#for-safety-and-clarity,-consider-removal-of-the\u00a0getsender\u00a0function.", "labels": ["OpenZeppelin"]}, {"title": "Update: Not fixed. A comment was added in pull request\u00a0#72\u00a0that indicates this function saves 800 gas by using inline assembly.", "body": "Update: Not fixed. A comment was added in pull request\u00a0#72\u00a0that indicates this function saves 800 gas by using inline assembly.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-not-fixed.-a-comment-was-added-in-pull-request\u00a0#72\u00a0that-indicates-this-function-saves-800-gas-by-using-inline-assembly.", "labels": ["OpenZeppelin"]}, {"title": "[N18] Indirect import [sample]", "body": "[N18] Indirect import [sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n18]-indirect-import-[sample]", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0TokenPaymaster\u00a0contract\u00a0imports\u00a0the obsolete\u00a0SimpleWalletForTokens\u00a0contract as an indirect mechanism to\u00a0import the\u00a0SimpleWallet\u00a0contract. Consider replacing the indirect import with a direct one.", "body": "The\u00a0TokenPaymaster\u00a0contract\u00a0imports\u00a0the obsolete\u00a0SimpleWalletForTokens\u00a0contract as an indirect mechanism to\u00a0import the\u00a0SimpleWallet\u00a0contract. Consider replacing the indirect import with a direct one.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#the\u00a0tokenpaymaster\u00a0contract\u00a0imports\u00a0the-obsolete\u00a0simplewalletfortokens\u00a0contract-as-an-indirect-mechanism-to\u00a0import-the\u00a0simplewallet\u00a0contract.-consider-replacing-the-indirect-import-with-a-direct-one.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#73.", "body": "[N21] Inconsistent clearing of memory [sample]  OpenZeppelins ECDSA library, which replaces the existing  ecrecover2 assembly implementation that does not use the GAS opcode. After  a few more instructions to zero out the first two words of the free memory space, overwriting the  associated comment it can be inferred that memory space is being zeroed out for the benefit of future callers that might assume the memory has been cleared. However, the current implementation is not clearing all of the modified memoryit only zeroes out the  Consider either clearing all of the memory used, or none of it. The Solidity documentation makes it clear that users should not expect the free memory to point to zeroed-out memory, so this final clearing operation is not necessary.  Update: Fixed in pull request #56. The memory clearing instructions were removed.  Following this pull request, the EIP was updated to allow the GAS opcode to be used when simulating validation, provided that it is followed by CALL, DELEGATECALL, CALLCODE, or STATICCALL. Additional statement from the Ethereum Foundation on this issue:  This is no longer an issue, since we removed completely the need for ecrecover2 (we allow the use of GAS opcode if immediately followed by *CALL).  [N22] Unclear use of mixed size values [core]  The StakeManager contract defines the DepositInfo struct with three values of size uint112, uint32 and uint64. While the intention to pack the contents into a single word can be inferred, the reason for the particular sizes are not obvious. Consider documenting the reason for this design pattern and the corresponding (reasonable) assumptions about the maximum sizes of each type.  Update: Fixed in pull request #76.  [N23] Unused parameter in validatePaymasterUserOp methods [sample]  validatePaymasterUserOp function in the  Consider providing a sample paymaster contract that demonstrates the use of the requestId parameter for validation.  Update: Acknowledged.  [N24] Naming suggestions [core and sample]  We believe some functions are variables could benefit from renaming. These are our suggestions:  The IOracle, DepositPaymaster and TokenPaymaster contracts all have a getTokenToEthOutputPrice function, but in all cases, its not a price (because it accounts for the amount bought) and it appears to be described backwards. Something like getTokenValueOfEth would be clearer.  The last parameter of validateUserOp in the IWallet interface should be missingWalletFunds or additionalFundsRequired to match how its used in the EntryPoint contract.  The gasUsedByValidateUserOp variable should be gasUsedByValidateWalletPrepayment  The PaymentMode options should be paymasterDeposit and walletDeposit, because neither uses the stake for gas payments.  The sender parameter in the _call function of the SimpleWallet contract should be target.  The maxPriorityFeePerGas component of the UserOperation struct should be priorityFeePerGas.  In BasePaymaster, the setEntrypoint and _requireFromEntrypoint functions should capitalize the p for consistency with the rest of the code base.  Update: Partially fixed in pull request #80 and commit 074672b6ccfb596fe7ff44e13783881a2e1cfed2. The following naming suggestions were not implemented:  The maxPriorityFeePerGas component of the UserOperation struct should be priorityFeePerGas. Ethereum Foundation comment on this issue:  Note that maxPriorityFeePerGas was left unchanged, since it defines the maximum, not actual fee paid by the user.  [N25] Typographical errors [core and sample]  Consider addressing the following typographical errors:  In EntryPoint.sol:  line 29 and line 30: simulateOp should be simulateValidation line 178: of should be if line 297: done, by should be done and  In IWallet.sol:  line 10: successfuly. should be successfully.  In StakeManager.sol:  line 12: blocks to should be seconds to wait line 83: time should be duration  In DepositPaymaster.sol:  line 68: on in the same block as withdrawTo() should be in the same block as withdrawTokensTo()  In SimpleWallet.sol:  line 88: (its should be (its  In TokenPaymaster.sol:  line 11: os should be or line 18: method-ids. should be method ids. line 77: paymaster should be entrypoint  In VerifyingPaymaster.sol:  line 57: signing should be to signing  In eip-4337.md:  line 46: for to compensate the bundler for should be to compensate the bundler line 84: worlflow should be workflow line 89: simulateWalletValidation should be simulateValidation line 127: paymaster should be paymaster) line 151: op should be op validation line 165: valiation should be validation and the line should end in a period.  Update: Fixed in pull request #79 and pull request #88.  [N26] Abstract StakeManager contract [core]  The StakeManager contract is intended to provide staking functionality to other contracts, but should not be deployed directly. To better signal this intention, consider declaring the contract as abstract.  Update: Fixed in pull request #76.  [N27] Declare uint as uint256 [core and sample]  To favor explicitness, consider declaring all instance of uint as uint256.  Update: Fixed in pull request #77.  Conclusions  1 critical and 4 high severity issues were found in the code base in addition to the high severity issue that the Ethereum Foundation noted. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix: Architectural Analysis  Overview  Many security features and mitigations to protect nodes and bundlers are executed partially or entirely off-chain; they also involve complex interactions between multiple parties with competing interests. Based on the EIP and our discussions with the Ethereum Foundation, we have captured our understanding of these features to correct any misunderstandings and identify any shortcomings. For clarity, we are referencing the latest design, which includes modifications that were made during or after the audit. This document attempts to describe high level concepts, and then systematically interrogate the details.  Basic Structure  Actors  Wallets  Smart contract wallets are primary accounts. Users construct arbitrary operations and publish them to a new mempool and each operation is associated with a specific smart contract wallet. In practice, each operation is an arbitrary call to the wallet. This allows the wallet to perform an action from its own context. A wallet can be deployed as part of its first operation.  Paymasters  Operations can specify optional paymasters. These are contracts that agree to pay the gas fees associated with the operation. Typically, they would be reimbursed somehow (perhaps with an ERC20 token), but the system does not specify or enforce any particular incentive. They must stake some funds beforehand as an anti-sybil mechanism. They must also prepay for the operations that they will fund.  Bundlers  Bundlers watch the new mempool and aggregate multiple operations into a bundle (i.e. an array of operations). They submit the bundle to miners as an Ethereum transaction. In practice, miners could also be bundlers. They will pay the gas fees associated with the bundle at the transaction gas price. However, users specify their own gas price with each operation and bundlers will be reimbursed at this rate. The difference between the user-specified gas price and the transaction gas price provides the incentive for bundlers to participate.  Miners  Miners treat bundles like normal Ethereum transactions (with a small exception related to transaction ordering, explained below).  Nodes  Nodes are clients that participate in the mempool gossip network without necessarily mining or bundling.  Execution  Bundlers submit their bundle transactions to the global EntryPoint contract. For each operation in the bundle, the EntryPoint validates that the wallet contract accepts it as valid, and that the wallet or paymaster (if specified) is willing and able to pay for it. The paymaster can use this opportunity to validate that the wallet will reimburse them. If any of the validations fail, the whole bundle reverts.  For each (now validated) operation, the EntryPoint creates a new call frame and performs the following steps:  Executes the operation (i.e. invokes the wallet with the operation data) and traps any errors.  Hands control to the paymaster (if it exists) to perform any after-operation functionality, whether or not the operation succeeded. Typically, this would include retrieving reimbursement for the cost of the operation (that the paymaster will pay for).  This call frame wont revert in the first step because errors are caught. If the call frame reverts in the second (after-operation) step, its effects are rolled back, and the paymaster is given another chance to perform any after-revert functionality. If this after-revert step reverts, the whole bundle transaction reverts.  The EntryPoint collects gas costs at the user-specified rate. If the wallet is paying for the transaction, the maximum fee is retrieved before execution, and any unused funds are refunded. If instead the paymaster is paying for the transaction, the funds are deducted from their stake after execution. When all transactions in the bundle have been processed, the EntryPoint sends the funds to a bundler-specified address.  Rationale  Valid operations should be charged  If an operation is validated, someone (either the wallet or the paymaster) has agreed to pay for execution, whether or not the operation itself succeeds. Ideally, the EntryPoint would guarantee that the operation is executed and the bundler will be reimbursed. In practice, the EntryPoint guarantees that either:  All operations in the bundle will be executed and the bundler will be reimbursed, or  The paymaster is misbehaving in an identifiable way, or  The bundle is poorly constructed.  Bundlers are responsible for choosing valid operations  If any of the validations fail on chain, the bundler is at fault. Bundlers should:  Only include valid operations within a bundle.  Use the simulation mechanism (described below) to identify invalidated operations.  If the bundler-specified beneficiary address cannot be paid (for example, if its fallback function reverts), the bundler is at fault. In either case, the transaction reverts and the bundler has to pay the gas costs. Nobody else is affected.  Wallets are responsible for operation execution failures  If an operation fails, the wallet is at fault. Wallets should only accept valid operations. In the event that an operation fails, the wallet or paymaster is still charged for the execution. Paymasters are still provided with the same opportunity to retrieve reimbursement from the wallet.  Wallets are responsible for maintaining paymaster preconditions  If the paymasters after-operation function reverts, the wallet is at fault. Paymasters use their validation step to check preconditions that are assumed to hold after the operation. One example is to use the validation to ensure the wallet has funds, and the after-operation function to retrieve those funds as reimbursement. However, paymasters cannot guarantee that this will succeed because the user operation could invalidate the precondition. For example, the user operation could spend the tokens or revoke the allowance.  Wallets should only choose paymasters with agreeable after-operation functionality, and only approve operations that they know will succeed. If the after-operation function reverts:  The user operation will revert in the same call frame, which means its effects are rolled back.  The paymaster will typically use its after-revert function to retrieve the funds anyway.  The paymaster will pay the gas costs and the bundler will be reimbursed.  The overall effect is that the after-operation function is treated like part of the operation. If it fails, the wallet pays for the execution of a reverted operation.  Paymasters are responsible for guaranteeing payments  As noted above, wallets may cause the paymasters after-operation function to revert. In this scenario, the EntryPoint will invoke the paymasters after-revert function. When considering an individual operation, the paymaster validation step should guarantee the after-revert function will succeed, if it is invoked. Since the user operation has reverted (and its effects are rolled back), the operation cannot undermine this validation. The paymaster will typically use this function to retrieve reimbursement from the wallet; the validation would involve ensuring the wallet has sufficient funds with a corresponding allowance.  If the after-revert function reverts, the paymaster is typically at fault. However, the EntryPoint cannot penalize them directly (by trapping the error and charging them for the gas) because its possible that a valid after-revert function reverts when included in a poorly constructed batch (which would be the bundlers fault). The batch could contain operations that affect the validity of subsequent operations (for example, if multiple operations spend the same funds).  Bundlers are responsible for bundle success  As noted above, when a paymasters after-revert function reverts, the EntryPoint cannot identify if its due to a poorly constructed paymaster or bundle. Therefore, the bundler is responsible for recognizing failing bundles and avoiding operations with misbehaving paymasters. If any after-revert function in the batch reverts, the entire bundle transaction reverts and the bundler has to pay the gas costs. Nobody else, not even the paymaster is directly affected on chain. The bundler will consider the paymaster to be at fault. The off-chain simulation and paymaster reputation system (both explained below) limit the amount of griefing the paymaster can get away with.  Simulation  Overview  Bundlers are responsible for including operations that will pass validation (so the EntryPoint knows they are accepted by wallets and paymasters). They are not responsible for ensuring the operation itself succeeds or the paymaster is reimbursed. Bundlers use off-chain simulation to validate bundles before submitting them. It is worth noting that this process and the associated restrictions are intended as a safety feature for bundlers. It gives them confidence that bundle transactions will succeed and they will be compensated for the gas costs. Bundlers that understand the risks can choose to relax some of these restrictions.  First validation simulation  Clients should call simulateValidation (locally) on each user operation before accepting it into the mempool. This performs the validation for the wallet and paymaster (if it exists) against the current state of the blockchain. In this way, the mempool is only populated with operations that would have been valid at the time they were accepted.  Forbidden opcodes  The EIP lists some opcodes that cannot be used during validation because they contain environmental information about the execution context (not directly related to the state of the blockchain). This implies they can differ between off-chain simulation and on-chain execution. If these opcodes were used, a bundler could be misled into including transactions that would fail on-chain validation. The EntryPoint cannot distinguish this case from one in which the bundler simply included unauthorized transactions; the transaction would revert and the bundler would pay the gas costs. This is intended as a safety feature for bundlers, but it manifests as a restriction on wallets and paymasters.  Second validation simulation  Bundlers should call simulateValidation (locally) on each user operation before including it in a batch. The state of the blockchain can progress while operations are in the mempool, so its possible that previously valid operations become invalid. The second simulation ensures operations are still valid.  Forbidden state accesses  It is acceptable for some operations to become invalid between the first and second simulation. However, if too many operations were invalidated quickly, bundlers would waste time testing and rejecting them all. The EIP design principle is that each invalidated operation should cost an on-chain storage change. Stated more directly, a single on-chain storage change can only invalidate one operation in the mempool. This introduces a natural mitigation against intentionally invalidating multiple operations in the mempool as a denial-of-service attack (since changing on-chain storage costs significantly more than the nuisance caused by invalidating mempool operations).  As with the opcode banning, this is a safety feature for bundlers that manifests as a new restriction on wallets and paymasters. It is more plausible that wallets or paymasters will want to base validation decisions on external storage. Still, most valid use cases are supported. Additionally, bundlers can choose to (internally) whitelist contracts or functions that they know are safe, even if they violate this restriction. Its worth emphasizing that there is no storage restriction during the execution of the operation (which would be very prohibitive).  Bundle execution simulation  The second validation simulation ensures that each operation in a batch individually passes validation. It does not guarantee that the bundle execution will succeed. A bundle of valid operations could fail if:  An operations validation undermines a later validation in the batch.  A paymasters after-revert operation fails. This could occur if multiple transactions in the batch spend the same funds.  The bundle runs out of gas, particularly as a result of return bombing  A paymaster has insufficient funds to cover all operations in a batch. Bundlers should identify this scenario as they are constructing the batch.  Note that if an operations execution undermines a later operations execution, this is not an attack on the bundler. This is analogous to a normal Ethereum transaction in the mempool invalidating another transaction in the mempool. The second operation will fail, but the bundle will still succeed. To detect batch failures, bundlers should run eth_estimateGas on the entire bundle before submitting it. This step is used to obtain the gas required by the bundle. Moreover, if any operation fails, it should be removed from the batch. In this way (when combined with the opcode restrictions), bundlers know that the batch will succeed when executed on the current state of the blockchain.  Bundles have unique wallets  The EIP specifies that each operation in a bundle corresponds to a different wallet. When combined with the forbidden state access rules, this ensures wallet validations cannot interfere with each other. In practice, this is not much of a restriction since wallets will likely use nonces for transaction ordering. This means there should only be one valid operation per wallet at a time. Users can add additional operations with the same nonce to the mempool (e.g. to replace the transaction or increase its gas price), but only one should be included in the batch anyway. Note: There can be repeated paymasters within a bundle. Paymaster interference is handled by the reputation system (explained below). Additionally, our discussion with the Ethereum Foundation suggests that the mempool can only have a limited number operations corresponding to the same wallet.  Execution  Determinism  Bundlers must ensure that the on-chain bundle execution exactly matches the off-chain execution. Otherwise, an unrelated transaction could invalidate the bundle. To this end, bundlers must be a miner or have a relationship with a miner such that:  The bundle is the first transaction in the next block, or  None of the preceding transactions affect the bundle. This could be detected and enforced with access control lists.  Paymaster Reputation System  Paymasters have two opportunities to undermine bundlers:  Since the same paymaster can be used in multiple operations in the mempool, several ope", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#73.", "labels": ["OpenZeppelin"]}, {"title": "[N19] Unused imports [sample]", "body": "[N19] Unused imports [sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n19]-unused-imports-[sample]", "labels": ["OpenZeppelin"]}, {"title": "To improve readability and avoid confusion, consider removing the following unused imports:", "body": "To improve readability and avoid confusion, consider removing the following unused imports:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#to-improve-readability-and-avoid-confusion,-consider-removing-the-following-unused-imports:", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0TokenPaymaster\u00a0contract, the\u00a0hardhat console\u00a0library.", "body": "In the\u00a0TokenPaymaster\u00a0contract, the\u00a0hardhat console\u00a0library.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in-the\u00a0tokenpaymaster\u00a0contract,-the\u00a0hardhat-console\u00a0library.", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0SimpleWallet\u00a0contract, the\u00a0hardhat console\u00a0library.", "body": "In the\u00a0SimpleWallet\u00a0contract, the\u00a0hardhat console\u00a0library.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in-the\u00a0simplewallet\u00a0contract,-the\u00a0hardhat-console\u00a0library.", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0TestCounter\u00a0contract, the\u00a0UserOperation\u00a0contract and the\u00a0IWallet\u00a0interface.", "body": "In the\u00a0TestCounter\u00a0contract, the\u00a0UserOperation\u00a0contract and the\u00a0IWallet\u00a0interface.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in-the\u00a0testcounter\u00a0contract,-the\u00a0useroperation\u00a0contract-and-the\u00a0iwallet\u00a0interface.", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0TestOracle\u00a0contract, the\u00a0OpenZeppelin ERC20\u00a0contract.", "body": "In the\u00a0TestOracle\u00a0contract, the\u00a0OpenZeppelin ERC20\u00a0contract.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in-the\u00a0testoracle\u00a0contract,-the\u00a0openzeppelin-erc20\u00a0contract.", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0TestUtil\u00a0contract, the\u00a0IWallet\u00a0interface.", "body": "In the\u00a0TestUtil\u00a0contract, the\u00a0IWallet\u00a0interface.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in-the\u00a0testutil\u00a0contract,-the\u00a0iwallet\u00a0interface.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#73\u00a0and commit\u00a04efa5fc296f0034dbf402dcd558a07be45bdd761.", "body": "Update: Fixed in pull request\u00a0#73\u00a0and commit\u00a04efa5fc296f0034dbf402dcd558a07be45bdd761.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#73\u00a0and-commit\u00a04efa5fc296f0034dbf402dcd558a07be45bdd761.", "labels": ["OpenZeppelin"]}, {"title": "[N20] Redundant code [core and sample]", "body": "[N20] Redundant code [core and sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n20]-redundant-code-[core-and-sample]", "labels": ["OpenZeppelin"]}, {"title": "Consider making the following changes to eliminate redundant code:", "body": "Consider making the following changes to eliminate redundant code:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#consider-making-the-following-changes-to-eliminate-redundant-code:", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0UserOperation.sol, the\u00a0requiredGas\u00a0function\u00a0calculates\u00a0mul\u00a0by evaluating the expression\u00a0userOp.paymaster != address(0), which is equivalent to\u00a0hasPaymaster(userOp).", "body": "In\u00a0UserOperation.sol, the\u00a0requiredGas\u00a0function\u00a0calculates\u00a0mul\u00a0by evaluating the expression\u00a0userOp.paymaster != address(0), which is equivalent to\u00a0hasPaymaster(userOp).", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in\u00a0useroperation.sol,-the\u00a0requiredgas\u00a0function\u00a0calculates\u00a0mul\u00a0by-evaluating-the-expression\u00a0userop.paymaster-!=-address(0),-which-is-equivalent-to\u00a0haspaymaster(userop).", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0UserOperation.sol, the\u00a0pack\u00a0function has an\u00a0unnecessary return statement.", "body": "In\u00a0UserOperation.sol, the\u00a0pack\u00a0function has an\u00a0unnecessary return statement.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in\u00a0useroperation.sol,-the\u00a0pack\u00a0function-has-an\u00a0unnecessary-return-statement.", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0DepositPaymaster.sol, the\u00a0statement\u00a0to silence an unused variable warning for\u00a0mode\u00a0can be removed. The\u00a0mode\u00a0variable is\u00a0used to determine the payment method.", "body": "In\u00a0DepositPaymaster.sol, the\u00a0statement\u00a0to silence an unused variable warning for\u00a0mode\u00a0can be removed. The\u00a0mode\u00a0variable is\u00a0used to determine the payment method.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in\u00a0depositpaymaster.sol,-the\u00a0statement\u00a0to-silence-an-unused-variable-warning-for\u00a0mode\u00a0can-be-removed.-the\u00a0mode\u00a0variable-is\u00a0used-to-determine-the-payment-method.", "labels": ["OpenZeppelin"]}, {"title": "[N21] Inconsistent clearing of memory [sample]", "body": "[N21] Inconsistent clearing of memory [sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n21]-inconsistent-clearing-of-memory-[sample]", "labels": ["OpenZeppelin"]}, {"title": "OpenZeppelin\u2019s\u00a0ECDSA\u00a0library, which replaces the existing", "body": "OpenZeppelin\u2019s\u00a0ECDSA\u00a0library, which replaces the existing", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#openzeppelin\u2019s\u00a0ecdsa\u00a0library,-which-replaces-the-existing", "labels": ["OpenZeppelin"]}, {"title": "ecrecover2\u00a0assembly implementation that does not use the GAS opcode. After", "body": "ecrecover2\u00a0assembly implementation that does not use the GAS opcode. After", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#ecrecover2\u00a0assembly-implementation-that-does-not-use-the-gas-opcode.-after", "labels": ["OpenZeppelin"]}, {"title": "a few more instructions\u00a0to zero out the first two words of the free memory space, overwriting the", "body": "a few more instructions\u00a0to zero out the first two words of the free memory space, overwriting the", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#a-few-more-instructions\u00a0to-zero-out-the-first-two-words-of-the-free-memory-space,-overwriting-the", "labels": ["OpenZeppelin"]}, {"title": "associated comment\u00a0it can be inferred that memory space is being zeroed out for the benefit of future callers that might assume the memory has been cleared. However, the current implementation is not clearing all of the modified memory\u2013it only zeroes out the", "body": "associated comment\u00a0it can be inferred that memory space is being zeroed out for the benefit of future callers that might assume the memory has been cleared. However, the current implementation is not clearing all of the modified memory\u2013it only zeroes out the", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#associated-comment\u00a0it-can-be-inferred-that-memory-space-is-being-zeroed-out-for-the-benefit-of-future-callers-that-might-assume-the-memory-has-been-cleared.-however,-the-current-implementation-is-not-clearing-all-of-the-modified-memory\u2013it-only-zeroes-out-the", "labels": ["OpenZeppelin"]}, {"title": "Consider either clearing all of the memory used, or none of it. The\u00a0Solidity documentation\u00a0makes it clear that users should not expect the free memory to point to zeroed-out memory, so this final clearing operation is not necessary.", "body": "Consider either clearing all of the memory used, or none of it. The\u00a0Solidity documentation\u00a0makes it clear that users should not expect the free memory to point to zeroed-out memory, so this final clearing operation is not necessary.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#consider-either-clearing-all-of-the-memory-used,-or-none-of-it.-the\u00a0solidity-documentation\u00a0makes-it-clear-that-users-should-not-expect-the-free-memory-to-point-to-zeroed-out-memory,-so-this-final-clearing-operation-is-not-necessary.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#56. The memory clearing instructions were removed.", "body": "Update: Fixed in pull request\u00a0#56. The memory clearing instructions were removed.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#56.-the-memory-clearing-instructions-were-removed.", "labels": ["OpenZeppelin"]}, {"title": "Following this pull request, the\u00a0EIP\u00a0was updated to allow the\u00a0GAS\u00a0opcode to be used when simulating validation, provided that it is followed by\u00a0CALL,\u00a0DELEGATECALL,\u00a0CALLCODE, or\u00a0STATICCALL. Additional statement from the Ethereum Foundation on this issue:", "body": "Following this pull request, the\u00a0EIP\u00a0was updated to allow the\u00a0GAS\u00a0opcode to be used when simulating validation, provided that it is followed by\u00a0CALL,\u00a0DELEGATECALL,\u00a0CALLCODE, or\u00a0STATICCALL. Additional statement from the Ethereum Foundation on this issue:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#following-this-pull-request,-the\u00a0eip\u00a0was-updated-to-allow-the\u00a0gas\u00a0opcode-to-be-used-when-simulating-validation,-provided-that-it-is-followed-by\u00a0call,\u00a0delegatecall,\u00a0callcode,-or\u00a0staticcall.-additional-statement-from-the-ethereum-foundation-on-this-issue:", "labels": ["OpenZeppelin"]}, {"title": "This is no longer an issue, since we removed completely the need for \u201cecrecover2\u201d (we allow the use of GAS opcode if immediately followed by \u201c*CALL\u201d).", "body": "[N22] Unclear use of mixed size values [core]  The StakeManager contract defines the DepositInfo struct with three values of size uint112, uint32 and uint64. While the intention to pack the contents into a single word can be inferred, the reason for the particular sizes are not obvious. Consider documenting the reason for this design pattern and the corresponding (reasonable) assumptions about the maximum sizes of each type.  Update: Fixed in pull request #76.  [N23] Unused parameter in validatePaymasterUserOp methods [sample]  validatePaymasterUserOp function in the  Consider providing a sample paymaster contract that demonstrates the use of the requestId parameter for validation.  Update: Acknowledged.  [N24] Naming suggestions [core and sample]  We believe some functions are variables could benefit from renaming. These are our suggestions:  The IOracle, DepositPaymaster and TokenPaymaster contracts all have a getTokenToEthOutputPrice function, but in all cases, its not a price (because it accounts for the amount bought) and it appears to be described backwards. Something like getTokenValueOfEth would be clearer.  The last parameter of validateUserOp in the IWallet interface should be missingWalletFunds or additionalFundsRequired to match how its used in the EntryPoint contract.  The gasUsedByValidateUserOp variable should be gasUsedByValidateWalletPrepayment  The PaymentMode options should be paymasterDeposit and walletDeposit, because neither uses the stake for gas payments.  The sender parameter in the _call function of the SimpleWallet contract should be target.  The maxPriorityFeePerGas component of the UserOperation struct should be priorityFeePerGas.  In BasePaymaster, the setEntrypoint and _requireFromEntrypoint functions should capitalize the p for consistency with the rest of the code base.  Update: Partially fixed in pull request #80 and commit 074672b6ccfb596fe7ff44e13783881a2e1cfed2. The following naming suggestions were not implemented:  The maxPriorityFeePerGas component of the UserOperation struct should be priorityFeePerGas. Ethereum Foundation comment on this issue:  Note that maxPriorityFeePerGas was left unchanged, since it defines the maximum, not actual fee paid by the user.  [N25] Typographical errors [core and sample]  Consider addressing the following typographical errors:  In EntryPoint.sol:  line 29 and line 30: simulateOp should be simulateValidation line 178: of should be if line 297: done, by should be done and  In IWallet.sol:  line 10: successfuly. should be successfully.  In StakeManager.sol:  line 12: blocks to should be seconds to wait line 83: time should be duration  In DepositPaymaster.sol:  line 68: on in the same block as withdrawTo() should be in the same block as withdrawTokensTo()  In SimpleWallet.sol:  line 88: (its should be (its  In TokenPaymaster.sol:  line 11: os should be or line 18: method-ids. should be method ids. line 77: paymaster should be entrypoint  In VerifyingPaymaster.sol:  line 57: signing should be to signing  In eip-4337.md:  line 46: for to compensate the bundler for should be to compensate the bundler line 84: worlflow should be workflow line 89: simulateWalletValidation should be simulateValidation line 127: paymaster should be paymaster) line 151: op should be op validation line 165: valiation should be validation and the line should end in a period.  Update: Fixed in pull request #79 and pull request #88.  [N26] Abstract StakeManager contract [core]  The StakeManager contract is intended to provide staking functionality to other contracts, but should not be deployed directly. To better signal this intention, consider declaring the contract as abstract.  Update: Fixed in pull request #76.  [N27] Declare uint as uint256 [core and sample]  To favor explicitness, consider declaring all instance of uint as uint256.  Update: Fixed in pull request #77.  Conclusions  1 critical and 4 high severity issues were found in the code base in addition to the high severity issue that the Ethereum Foundation noted. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix: Architectural Analysis  Overview  Many security features and mitigations to protect nodes and bundlers are executed partially or entirely off-chain; they also involve complex interactions between multiple parties with competing interests. Based on the EIP and our discussions with the Ethereum Foundation, we have captured our understanding of these features to correct any misunderstandings and identify any shortcomings. For clarity, we are referencing the latest design, which includes modifications that were made during or after the audit. This document attempts to describe high level concepts, and then systematically interrogate the details.  Basic Structure  Actors  Wallets  Smart contract wallets are primary accounts. Users construct arbitrary operations and publish them to a new mempool and each operation is associated with a specific smart contract wallet. In practice, each operation is an arbitrary call to the wallet. This allows the wallet to perform an action from its own context. A wallet can be deployed as part of its first operation.  Paymasters  Operations can specify optional paymasters. These are contracts that agree to pay the gas fees associated with the operation. Typically, they would be reimbursed somehow (perhaps with an ERC20 token), but the system does not specify or enforce any particular incentive. They must stake some funds beforehand as an anti-sybil mechanism. They must also prepay for the operations that they will fund.  Bundlers  Bundlers watch the new mempool and aggregate multiple operations into a bundle (i.e. an array of operations). They submit the bundle to miners as an Ethereum transaction. In practice, miners could also be bundlers. They will pay the gas fees associated with the bundle at the transaction gas price. However, users specify their own gas price with each operation and bundlers will be reimbursed at this rate. The difference between the user-specified gas price and the transaction gas price provides the incentive for bundlers to participate.  Miners  Miners treat bundles like normal Ethereum transactions (with a small exception related to transaction ordering, explained below).  Nodes  Nodes are clients that participate in the mempool gossip network without necessarily mining or bundling.  Execution  Bundlers submit their bundle transactions to the global EntryPoint contract. For each operation in the bundle, the EntryPoint validates that the wallet contract accepts it as valid, and that the wallet or paymaster (if specified) is willing and able to pay for it. The paymaster can use this opportunity to validate that the wallet will reimburse them. If any of the validations fail, the whole bundle reverts.  For each (now validated) operation, the EntryPoint creates a new call frame and performs the following steps:  Executes the operation (i.e. invokes the wallet with the operation data) and traps any errors.  Hands control to the paymaster (if it exists) to perform any after-operation functionality, whether or not the operation succeeded. Typically, this would include retrieving reimbursement for the cost of the operation (that the paymaster will pay for).  This call frame wont revert in the first step because errors are caught. If the call frame reverts in the second (after-operation) step, its effects are rolled back, and the paymaster is given another chance to perform any after-revert functionality. If this after-revert step reverts, the whole bundle transaction reverts.  The EntryPoint collects gas costs at the user-specified rate. If the wallet is paying for the transaction, the maximum fee is retrieved before execution, and any unused funds are refunded. If instead the paymaster is paying for the transaction, the funds are deducted from their stake after execution. When all transactions in the bundle have been processed, the EntryPoint sends the funds to a bundler-specified address.  Rationale  Valid operations should be charged  If an operation is validated, someone (either the wallet or the paymaster) has agreed to pay for execution, whether or not the operation itself succeeds. Ideally, the EntryPoint would guarantee that the operation is executed and the bundler will be reimbursed. In practice, the EntryPoint guarantees that either:  All operations in the bundle will be executed and the bundler will be reimbursed, or  The paymaster is misbehaving in an identifiable way, or  The bundle is poorly constructed.  Bundlers are responsible for choosing valid operations  If any of the validations fail on chain, the bundler is at fault. Bundlers should:  Only include valid operations within a bundle.  Use the simulation mechanism (described below) to identify invalidated operations.  If the bundler-specified beneficiary address cannot be paid (for example, if its fallback function reverts), the bundler is at fault. In either case, the transaction reverts and the bundler has to pay the gas costs. Nobody else is affected.  Wallets are responsible for operation execution failures  If an operation fails, the wallet is at fault. Wallets should only accept valid operations. In the event that an operation fails, the wallet or paymaster is still charged for the execution. Paymasters are still provided with the same opportunity to retrieve reimbursement from the wallet.  Wallets are responsible for maintaining paymaster preconditions  If the paymasters after-operation function reverts, the wallet is at fault. Paymasters use their validation step to check preconditions that are assumed to hold after the operation. One example is to use the validation to ensure the wallet has funds, and the after-operation function to retrieve those funds as reimbursement. However, paymasters cannot guarantee that this will succeed because the user operation could invalidate the precondition. For example, the user operation could spend the tokens or revoke the allowance.  Wallets should only choose paymasters with agreeable after-operation functionality, and only approve operations that they know will succeed. If the after-operation function reverts:  The user operation will revert in the same call frame, which means its effects are rolled back.  The paymaster will typically use its after-revert function to retrieve the funds anyway.  The paymaster will pay the gas costs and the bundler will be reimbursed.  The overall effect is that the after-operation function is treated like part of the operation. If it fails, the wallet pays for the execution of a reverted operation.  Paymasters are responsible for guaranteeing payments  As noted above, wallets may cause the paymasters after-operation function to revert. In this scenario, the EntryPoint will invoke the paymasters after-revert function. When considering an individual operation, the paymaster validation step should guarantee the after-revert function will succeed, if it is invoked. Since the user operation has reverted (and its effects are rolled back), the operation cannot undermine this validation. The paymaster will typically use this function to retrieve reimbursement from the wallet; the validation would involve ensuring the wallet has sufficient funds with a corresponding allowance.  If the after-revert function reverts, the paymaster is typically at fault. However, the EntryPoint cannot penalize them directly (by trapping the error and charging them for the gas) because its possible that a valid after-revert function reverts when included in a poorly constructed batch (which would be the bundlers fault). The batch could contain operations that affect the validity of subsequent operations (for example, if multiple operations spend the same funds).  Bundlers are responsible for bundle success  As noted above, when a paymasters after-revert function reverts, the EntryPoint cannot identify if its due to a poorly constructed paymaster or bundle. Therefore, the bundler is responsible for recognizing failing bundles and avoiding operations with misbehaving paymasters. If any after-revert function in the batch reverts, the entire bundle transaction reverts and the bundler has to pay the gas costs. Nobody else, not even the paymaster is directly affected on chain. The bundler will consider the paymaster to be at fault. The off-chain simulation and paymaster reputation system (both explained below) limit the amount of griefing the paymaster can get away with.  Simulation  Overview  Bundlers are responsible for including operations that will pass validation (so the EntryPoint knows they are accepted by wallets and paymasters). They are not responsible for ensuring the operation itself succeeds or the paymaster is reimbursed. Bundlers use off-chain simulation to validate bundles before submitting them. It is worth noting that this process and the associated restrictions are intended as a safety feature for bundlers. It gives them confidence that bundle transactions will succeed and they will be compensated for the gas costs. Bundlers that understand the risks can choose to relax some of these restrictions.  First validation simulation  Clients should call simulateValidation (locally) on each user operation before accepting it into the mempool. This performs the validation for the wallet and paymaster (if it exists) against the current state of the blockchain. In this way, the mempool is only populated with operations that would have been valid at the time they were accepted.  Forbidden opcodes  The EIP lists some opcodes that cannot be used during validation because they contain environmental information about the execution context (not directly related to the state of the blockchain). This implies they can differ between off-chain simulation and on-chain execution. If these opcodes were used, a bundler could be misled into including transactions that would fail on-chain validation. The EntryPoint cannot distinguish this case from one in which the bundler simply included unauthorized transactions; the transaction would revert and the bundler would pay the gas costs. This is intended as a safety feature for bundlers, but it manifests as a restriction on wallets and paymasters.  Second validation simulation  Bundlers should call simulateValidation (locally) on each user operation before including it in a batch. The state of the blockchain can progress while operations are in the mempool, so its possible that previously valid operations become invalid. The second simulation ensures operations are still valid.  Forbidden state accesses  It is acceptable for some operations to become invalid between the first and second simulation. However, if too many operations were invalidated quickly, bundlers would waste time testing and rejecting them all. The EIP design principle is that each invalidated operation should cost an on-chain storage change. Stated more directly, a single on-chain storage change can only invalidate one operation in the mempool. This introduces a natural mitigation against intentionally invalidating multiple operations in the mempool as a denial-of-service attack (since changing on-chain storage costs significantly more than the nuisance caused by invalidating mempool operations).  As with the opcode banning, this is a safety feature for bundlers that manifests as a new restriction on wallets and paymasters. It is more plausible that wallets or paymasters will want to base validation decisions on external storage. Still, most valid use cases are supported. Additionally, bundlers can choose to (internally) whitelist contracts or functions that they know are safe, even if they violate this restriction. Its worth emphasizing that there is no storage restriction during the execution of the operation (which would be very prohibitive).  Bundle execution simulation  The second validation simulation ensures that each operation in a batch individually passes validation. It does not guarantee that the bundle execution will succeed. A bundle of valid operations could fail if:  An operations validation undermines a later validation in the batch.  A paymasters after-revert operation fails. This could occur if multiple transactions in the batch spend the same funds.  The bundle runs out of gas, particularly as a result of return bombing  A paymaster has insufficient funds to cover all operations in a batch. Bundlers should identify this scenario as they are constructing the batch.  Note that if an operations execution undermines a later operations execution, this is not an attack on the bundler. This is analogous to a normal Ethereum transaction in the mempool invalidating another transaction in the mempool. The second operation will fail, but the bundle will still succeed. To detect batch failures, bundlers should run eth_estimateGas on the entire bundle before submitting it. This step is used to obtain the gas required by the bundle. Moreover, if any operation fails, it should be removed from the batch. In this way (when combined with the opcode restrictions), bundlers know that the batch will succeed when executed on the current state of the blockchain.  Bundles have unique wallets  The EIP specifies that each operation in a bundle corresponds to a different wallet. When combined with the forbidden state access rules, this ensures wallet validations cannot interfere with each other. In practice, this is not much of a restriction since wallets will likely use nonces for transaction ordering. This means there should only be one valid operation per wallet at a time. Users can add additional operations with the same nonce to the mempool (e.g. to replace the transaction or increase its gas price), but only one should be included in the batch anyway. Note: There can be repeated paymasters within a bundle. Paymaster interference is handled by the reputation system (explained below). Additionally, our discussion with the Ethereum Foundation suggests that the mempool can only have a limited number operations corresponding to the same wallet.  Execution  Determinism  Bundlers must ensure that the on-chain bundle execution exactly matches the off-chain execution. Otherwise, an unrelated transaction could invalidate the bundle. To this end, bundlers must be a miner or have a relationship with a miner such that:  The bundle is the first transaction in the next block, or  None of the preceding transactions affect the bundle. This could be detected and enforced with access control lists.  Paymaster Reputation System  Paymasters have two opportunities to undermine bundlers:  Since the same paymaster can be used in multiple operations in the mempool, several operations can potentially be invalidated by a single on-chain state change.  Paymasters can have after-revert functions that incorrectly revert.  In both scenarios, the bundler will identify the issue during the bundle execution simulation, and remove the offending operations. Over time, this will result in operations from the same paymaster being added to the mempool (and expiring after 10 blocks) without being included in bundles. As explained in the EIP, paymasters must stake some funds (as an anti-sybil mechanism), and will be throttled or banned if they have too many operations that are not included in bundles. Their stake is not slashed and the rate-limiting calculation is based on the amount of inclusions from the previous day, weighting the more recent hours more heavily. In this way, throttling is naturally reversed over time.  It is worth noting that even though bundlers can construct invalid batches from valid operations (explained above), this is not an attack against paymasters as long as there are some bundlers who include the operations in sensible batches. The possibility of invalid batches from valid operations is why the EntryPoint cannot penalize paymasters directly when their after-revert function fails, but invalid batche", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#this-is-no-longer-an-issue,-since-we-removed-completely-the-need-for-\u201cecrecover2\u201d-(we-allow-the-use-of-gas-opcode-if-immediately-followed-by-\u201c*call\u201d).", "labels": ["OpenZeppelin"]}, {"title": "[N22] Unclear use of mixed size values [core]", "body": "[N22] Unclear use of mixed size values [core]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n22]-unclear-use-of-mixed-size-values-[core]", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0StakeManager\u00a0contract defines the\u00a0DepositInfo\u00a0struct\u00a0with three values of size\u00a0uint112,\u00a0uint32\u00a0and\u00a0uint64. While the intention to pack the contents into a single word can be inferred, the reason for the particular sizes are not obvious. Consider documenting the reason for this design pattern and the corresponding (reasonable) assumptions about the maximum sizes of each type.", "body": "The\u00a0StakeManager\u00a0contract defines the\u00a0DepositInfo\u00a0struct\u00a0with three values of size\u00a0uint112,\u00a0uint32\u00a0and\u00a0uint64. While the intention to pack the contents into a single word can be inferred, the reason for the particular sizes are not obvious. Consider documenting the reason for this design pattern and the corresponding (reasonable) assumptions about the maximum sizes of each type.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#the\u00a0stakemanager\u00a0contract-defines-the\u00a0depositinfo\u00a0struct\u00a0with-three-values-of-size\u00a0uint112,\u00a0uint32\u00a0and\u00a0uint64.-while-the-intention-to-pack-the-contents-into-a-single-word-can-be-inferred,-the-reason-for-the-particular-sizes-are-not-obvious.-consider-documenting-the-reason-for-this-design-pattern-and-the-corresponding-(reasonable)-assumptions-about-the-maximum-sizes-of-each-type.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#76.", "body": "Staking state is no longer affected by the withdrawTo function. Users can now unlock an existing stake using unlockStake without needing to withdraw the funds, and they can then immediately restake by calling the addStakeTo function.  [L09] Wallet may not be deployed [core]  attempt to deploy the wallet if the operation specifies an  the validateUserOp call will unexpectedly revert  In practice, this should be identified by the bundler when constructing the batch. Nevertheless, in the interest of predictability, consider ensuring _createSenderIfNeeded always ends with a wallet deployed at the expected address.  Update: Acknowledged. The Ethereum Foundation decided not to address this because the bundler should identify this during simulation.  [L10] Unchecked math blocks are not narrow in scope [core]  EntryPoint contract, there are several functions (  For safety and clarity, consider restricting the scope of unchecked math blocks to only include the specific lines where it is needed.  Update: Not fixed. According to the Ethereum Foundation  for code clarity, it was added to wrap entire methods, as it makes the code far less readable if we try to wrap only the math expressions.  [L11] Missing docstrings [core and sample]  Many functions in the code base lack documentation. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Partially fixed in pull request #81. New docstrings were added and existing ones were expanded; most functions now have a docstring. However not all input and output parameters are explicitly documented. For example, several functions in the StakeManager contract do not have NatSpec comments.  [L12] Downcasting without bounds checks [core]  The StakeManager contract downcasts the amount when incrementing or decrementing deposits, and when increasing an accounts stake. Although these values are unlikely to overflow, as a matter of good practice, consider adding bounds checks.  Update: Partially fixed in pull request #62. Bounds checks were added to the internalIncrementDeposit and internalDecrementDeposit functions, but the addStake function still downcasts msg.value to a uint112 type without first checking if its size exceeds type(uint112).max.  [L13] Missing validations [core]  The compensate function in EntryPoint takes a beneficiary address as input and sends the amount specified to that address. This happens as the final step of a handleOps or handleOp function call. The code does not check that beneficiary is not 0, which could lead to accidental loss of funds. Consider adding a check to verify that beneficiary is a non-zero value.  In the EntryPoint constructor, there are no checks to ensure the immutable contract variables are set to non-zero values. If _create2factory, _paymasterStake, or _unstakeDelaySec were accidentally set to 0, the contract would need to be redeployed because there is no mechanism to update these values. Consider adding a non-zero check for each of the constructor parameters.  Update: Fixed in pull requests #59 and #63. Checks that reject zero values have been added for beneficiary, _create2factory, _paymasterStake, and unstakeDelaySec.  [L14] DepositPaymaster warning [sample]  The DepositPaymaster contract is non-compliant with the current version of the EIP, because it accesses an external oracle during validation. Consider including a warning at the top of the contract to explain the associated risks and how bundlers should decide whether to support this paymaster.  Update: Fixed in pull request #64.  [L15] Wallet storage in EntryPoint [core]  Client reported: The Ethereum Foundation identified this issue after the audit.  Bundlers ensure that wallets can only access their own mutable storage. However, they need to include an exception for the wallets balance in the EntryPoint contract to allow the wallet to prepay for its operation. The EntryPoint contract should expose a mechanism for bundlers to query the necessary storage locations.  This is addressed in pull request #87 of the public repository.  Notes & Additional Information  [N01] Suggested EIP changes  Client reported: The Ethereum Foundation made or inspired many of these suggestions during the audit. We include them here for reference.  Here are some suggestions to improve the precision and clarity of the EIP and associated documentation:  To prevent cross-chain replay attacks, user operation signatures should depend on the chainid. This is handled in the current implementation but not yet included as a requirement in the EIP.  After constructing a batch, bundlers should execute eth_estimateGas with the maximum gas limit. This would mitigate potential return bombing or other gas manipulation attacks that could cause batches to fail without specifically identifying the offending operation.  State any restrictions on how bundlers should construct batches, including ensuring all user operations have different senders.  State any restrictions on how batches should be arranged or ordered in blocks (e.g. using the access lists) to avoid interference from other transactions.  Clarify any operations that paymasters can undertake that wallets cannot. Additionally, explain the conditions (e.g. whitelisting) under which a bundler may accept a non-compliant paymaster, such as the DepositPaymaster.  Although implicit in the specification, we believe a complete walkthrough of the lifecycle of a user operation would be instructive.  Update: Fixed in pull request #83.  [N02] Imprecise gas limits [core]  combines the various gas parameters into a single variable so they can be collectively compared against a hardcoded limit. Although this correctly ensures all values are individually less than the maximum  Update: Fixed in pull request #86.  [N03] Duplicated naming [core]  In the EntryPoint contract, the paymasterStake variable has the same name as one of the PaymentMode options.  Consider using different names to improve code readability and avoid confusion.  Update: Partially fixed. Pull request #76 relocates the paymasterStake variable from the EntryPoint contract to the StakeManager contract, but does not rename it.  [N04] ECDSA signature length check allows invalid values [sample]  contains a check that the ECDSA signature being verified has a length >= 65 bytes. The  tryRecover function in the OpenZeppelin  Consider modifying the check in validatePaymasterUserOp to only allow ECDSA signature lengths equal to 65.  Update: Fixed in pull request #66. The signature length must now be equal to 64 or 65 to be considered valid. The tryRecover function supports both length values. Note that this expands the previous functionality to support the 64-byte encoding, so there are now multiple valid signatures for the same operation.  [N05] Fixed Oracle [sample]  When the owner of the DepositPaymaster adds a new supported token-oracle pair, it ensures the token does not already have an oracle. There is no mechanism to change or remove the oracle. We are simply noting this in case its an oversight.  Update: Not an issue. This was intentional.  [N06] Incorrectly set argument [core]  After executing the user operation, the internalHandleOp function of the EntryPoint contract invokes handlePostOp with a zero opIndex, regardless of the actual position of the operation within the branch. In this particular invocation, the opIndex parameter is unused, so setting it to zero was chosen as a simplification and gas optimization. Nevertheless, in the interest of code clarity, robustness and to support local reasoning, consider either refactoring the code to avoid the unnecessary parameter, passing in the correct value, or clearly documenting any misleading parameter assignments.  Update: Fixed in pull request #78. A comment was added to explain the zero opIndex value.  [N07] Inconsistent naming convention [core]  We identified the following examples of inconsistent naming:  In EntryPoint.sol:  Most internal and private functions are prefixed with an underscore, while compensate and handlePostOp are not. The UserOpInfo struct has a single parameter that starts with an underscore. The _salt parameter of the getSenderAddress function starts with an underscore.  Additionally, the prefix internal in function names may cause confusion. It seems redundant for functions declared with the internal keyword, such as the deposit manipulation functions and misleading for the external internalHandleOp function. We believe the prefix is intended to be descriptive of the actual function behavior, but nevertheless would recommend a different prefix, perhaps local, to avoid overloading Solidity keywords.  For clarity and readability, consider using a consistent naming convention.  Update: Fixed in pull requests #63 and #67. The function and variable naming was made consistent by adding or removing underscores in the requested locations. The internalHandleOp function usage has been clarified by renaming it to innerHandleOp and adding an explanatory docstring. The deposit manipulation functions still retain the redundant internal prefix.  [N08] Explicitly identify and name constants [sample]  In the TokenPaymaster contract, it is recommended to declare the COST_OF_POST variable as constant. This change will eliminate the use of a storage slot for this value.  For clarity, also consider assigning a named constant to the values 16000 and 35000 that appear within the validatePaymasterUserOp functions.  Update: Fixed in pull request #68. In the TokenPaymaster contract the constant keyword was added to the existing COST_OF_POST variable and the hard-coded value of 16000 was replaced with COST_OF_POST. In the DepositPaymaster contract a new COST_OF_POST constant was added and assigned the hard-coded value of 35000. It is also included in the amount charged to the wallet.  [N09] Failing tests  On a fresh checkout of the project repository and npm install of the dependencies, the entire test suite fails to run. This has been identified as the result of a mismatch between specific package versions used during development vs. the current versions of those packages.  On a stable production branch, it is recommended to lock the package versions within the package.json file to prevent package updates from breaking code that has been previously verified to work correctly.  Update: Not an issue. Tests can be run successfully if the yarn install command is used instead of npm install. Providing the exact instructions for building and testing the project in a README file would benefit other developers.  [N10] Unindexed event addresses [sample]  To support log filtering for the EntryPointChanged event in the SimpleWallet contract, consider adding the indexed keyword to the address parameters in the event.  Update: Fixed in pull request #69.  [N11] IWallet doesnt strongly enforce required functionality [sample]  IWallet interface specifies a single  all the necessary logic in its own  To help developers create secure wallet implementations that follow the EIP specification, consider removing the IWallet interface and replacing it with an abstract BaseWallet contract that implements all of the mandated checks, but leaves the custom behavior such as validateSignature up to derived classes. The existing SimpleWallet contract would then be derived from BaseWallet.  Update: Fixed in pull request #82. A new BaseWallet contract has been added that requires wallet implementers to adhere to the validateUserOp function structure originally laid out in the SimpleWallet sample contract; SimpleWallet now inherits from BaseWallet.  [N12] Not all state variables have explicit visibility [sample]  Several contracts in the samples directory dont explicitly declare the visibility of the state variables and constants:  In the DepositPaymaster contract:  nullOracle  unlockBlock  In the TokenPaymaster contract:  knownWallet  In the SimpleWallet contract:  ownerNonce  For clarity, consider always explicitly declaring the visibility of functions and variables, even when the default visibility type matches the intended type.  Update: Fixed in pull request #70.  [N13] One oracle per token restriction [sample]  The getTokenToEthOutputPrice function of the IOracle interface does not specify the particular token to translate. This means that each IOracle contract can only support one token, which seems like an unnecessary restriction. Consider including a tokenAddress parameter to the function specification.  Update: Not an issue. An oracle is intended to be an IUniswapExchange, which has a single instance per token.  [N14] Unnecessary encapsulation [sample]  OwnerNonce struct. Since these variables would still pack into a single storage slot without the struct, encapsulating them together in  owner and  nonce getter functions.  Consider removing the OwnerNonce struct and having standalone nonce and owner state variables.  Update: Fixed in pull request #70.  [N15] Inconsistent solidity version [core and sample]  The majority of the code base supports solidity versions ^0.8.7, but the StakeManager contract supports versions ^0.8 and the ECDSA contract supports versions ^0.8.0.  Consider using consistent solidity versions throughout the code base. Additionally, in the interest of predictability, consider locking the contracts to a specific supported version.  Update: Fixed in pull request #71 and commit 4efa5fc296f0034dbf402dcd558a07be45bdd761. All contracts were updated to use Solidity version ^0.8.12.  All of the contract versions remain unpinned.  [N16] Undocumented assembly [core and sample]  There are several contracts where inline assembly code is undocumented. Using inline assembly is risky because it bypasses some of the compilers safety checks, its harder to read and audit, and more likely to contain errors. For these reasons, the recommended best practice is for every line of assembly to have a corresponding explanatory comment.  Consider adding documentation to the following lines of code:  ECDSA.sol lines 188-202  UserOperation.sol line 25  UserOperation.sol lines 64-71  Update: Partially fixed in pull request #72. High-level comments were added to assembly blocks but individual lines remain uncommented.  [N17] Excessive code optimization [core]  getSender function takes a  inline assembly code. This is the only struct member that has its own custom getter function, and even though there are two addresses in the struct (  For safety and clarity, consider removal of the getSender function.  Update: Not fixed. A comment was added in pull request #72 that indicates this function saves 800 gas by using inline assembly.  [N18] Indirect import [sample]  The TokenPaymaster contract imports the obsolete SimpleWalletForTokens contract as an indirect mechanism to import the SimpleWallet contract. Consider replacing the indirect import with a direct one.  Update: Fixed in pull request #73.  [N19] Unused imports [sample]  To improve readability and avoid confusion, consider removing the following unused imports:  In the TokenPaymaster contract, the hardhat console library.  In the SimpleWallet contract, the hardhat console library.  In the TestCounter contract, the UserOperation contract and the IWallet interface.  In the TestOracle contract, the OpenZeppelin ERC20 contract.  In the TestUtil contract, the IWallet interface.  Update: Fixed in pull request #73 and commit 4efa5fc296f0034dbf402dcd558a07be45bdd761.  [N20] Redundant code [core and sample]  Consider making the following changes to eliminate redundant code:  In UserOperation.sol, the requiredGas function calculates mul by evaluating the expression userOp.paymaster != address(0), which is equivalent to hasPaymaster(userOp).  In UserOperation.sol, the pack function has an unnecessary return statement.  In DepositPaymaster.sol, the statement to silence an unused variable warning for mode can be removed. The mode variable is used to determine the payment method.  Update: Fixed in pull request #73.  [N21] Inconsistent clearing of memory [sample]  OpenZeppelins ECDSA library, which replaces the existing  ecrecover2 assembly implementation that does not use the GAS opcode. After  a few more instructions to zero out the first two words of the free memory space, overwriting the  associated comment it can be inferred that memory space is being zeroed out for the benefit of future callers that might assume the memory has been cleared. However, the current implementation is not clearing all of the modified memoryit only zeroes out the  Consider either clearing all of the memory used, or none of it. The Solidity documentation makes it clear that users should not expect the free memory to point to zeroed-out memory, so this final clearing operation is not necessary.  Update: Fixed in pull request #56. The memory clearing instructions were removed.  Following this pull request, the EIP was updated to allow the GAS opcode to be used when simulating validation, provided that it is followed by CALL, DELEGATECALL, CALLCODE, or STATICCALL. Additional statement from the Ethereum Foundation on this issue:  This is no longer an issue, since we removed completely the need for ecrecover2 (we allow the use of GAS opcode if immediately followed by *CALL).  [N22] Unclear use of mixed size values [core]  The StakeManager contract defines the DepositInfo struct with three values of size uint112, uint32 and uint64. While the intention to pack the contents into a single word can be inferred, the reason for the particular sizes are not obvious. Consider documenting the reason for this design pattern and the corresponding (reasonable) assumptions about the maximum sizes of each type.    [N23] Unused parameter in validatePaymasterUserOp methods [sample]  validatePaymasterUserOp function in the  Consider providing a sample paymaster contract that demonstrates the use of the requestId parameter for validation.  Update: Acknowledged.  [N24] Naming suggestions [core and sample]  We believe some functions are variables could benefit from renaming. These are our suggestions:  The IOracle, DepositPaymaster and TokenPaymaster contracts all have a getTokenToEthOutputPrice function, but in all cases, its not a price (because it accounts for the amount bought) and it appears to be described backwards. Something like getTokenValueOfEth would be clearer.  The last parameter of validateUserOp in the IWallet interface should be missingWalletFunds or additionalFundsRequired to match how its used in the EntryPoint contract.  The gasUsedByValidateUserOp variable should be gasUsedByValidateWalletPrepayment  The PaymentMode options should be paymasterDeposit and walletDeposit, because neither uses the stake for gas payments.  The sender parameter in the _call function of the SimpleWallet contract should be target.  The maxPriorityFeePerGas component of the UserOperation struct should be priorityFeePerGas.  In BasePaymaster, the setEntrypoint and _requireFromEntrypoint functions should capitalize the p for consistency with the rest of the code base.  Update: Partially fixed in pull request #80 and commit 074672b6ccfb596fe7ff44e13783881a2e1cfed2. The following naming suggestions were not implemented:  The maxPriorityFeePerGas component of the UserOperation struct should be priorityFeePerGas. Ethereum Foundation comment on this issue:  Note", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#76.", "labels": ["OpenZeppelin"]}, {"title": "[N23] Unused parameter in validatePaymasterUserOp methods [sample]", "body": "[N23] Unused parameter in validatePaymasterUserOp methods [sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n23]-unused-parameter-in-validatepaymasteruserop-methods-[sample]", "labels": ["OpenZeppelin"]}, {"title": "validatePaymasterUserOp\u00a0function in the", "body": "validatePaymasterUserOp\u00a0function in the", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#validatepaymasteruserop\u00a0function-in-the", "labels": ["OpenZeppelin"]}, {"title": "Consider providing a sample paymaster contract that demonstrates the use of the\u00a0requestId\u00a0parameter for validation.", "body": "Consider providing a sample paymaster contract that demonstrates the use of the\u00a0requestId\u00a0parameter for validation.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#consider-providing-a-sample-paymaster-contract-that-demonstrates-the-use-of-the\u00a0requestid\u00a0parameter-for-validation.", "labels": ["OpenZeppelin"]}, {"title": "Update: Acknowledged.", "body": "[N24] Naming suggestions [core and sample]  We believe some functions are variables could benefit from renaming. These are our suggestions:  The IOracle, DepositPaymaster and TokenPaymaster contracts all have a getTokenToEthOutputPrice function, but in all cases, its not a price (because it accounts for the amount bought) and it appears to be described backwards. Something like getTokenValueOfEth would be clearer.  The last parameter of validateUserOp in the IWallet interface should be missingWalletFunds or additionalFundsRequired to match how its used in the EntryPoint contract.  The gasUsedByValidateUserOp variable should be gasUsedByValidateWalletPrepayment  The PaymentMode options should be paymasterDeposit and walletDeposit, because neither uses the stake for gas payments.  The sender parameter in the _call function of the SimpleWallet contract should be target.  The maxPriorityFeePerGas component of the UserOperation struct should be priorityFeePerGas.  In BasePaymaster, the setEntrypoint and _requireFromEntrypoint functions should capitalize the p for consistency with the rest of the code base.  Update: Partially fixed in pull request #80 and commit 074672b6ccfb596fe7ff44e13783881a2e1cfed2. The following naming suggestions were not implemented:  The maxPriorityFeePerGas component of the UserOperation struct should be priorityFeePerGas. Ethereum Foundation comment on this issue:  Note that maxPriorityFeePerGas was left unchanged, since it defines the maximum, not actual fee paid by the user.  [N25] Typographical errors [core and sample]  Consider addressing the following typographical errors:  In EntryPoint.sol:  line 29 and line 30: simulateOp should be simulateValidation line 178: of should be if line 297: done, by should be done and  In IWallet.sol:  line 10: successfuly. should be successfully.  In StakeManager.sol:  line 12: blocks to should be seconds to wait line 83: time should be duration  In DepositPaymaster.sol:  line 68: on in the same block as withdrawTo() should be in the same block as withdrawTokensTo()  In SimpleWallet.sol:  line 88: (its should be (its  In TokenPaymaster.sol:  line 11: os should be or line 18: method-ids. should be method ids. line 77: paymaster should be entrypoint  In VerifyingPaymaster.sol:  line 57: signing should be to signing  In eip-4337.md:  line 46: for to compensate the bundler for should be to compensate the bundler line 84: worlflow should be workflow line 89: simulateWalletValidation should be simulateValidation line 127: paymaster should be paymaster) line 151: op should be op validation line 165: valiation should be validation and the line should end in a period.  Update: Fixed in pull request #79 and pull request #88.  [N26] Abstract StakeManager contract [core]  The StakeManager contract is intended to provide staking functionality to other contracts, but should not be deployed directly. To better signal this intention, consider declaring the contract as abstract.  Update: Fixed in pull request #76.  [N27] Declare uint as uint256 [core and sample]  To favor explicitness, consider declaring all instance of uint as uint256.  Update: Fixed in pull request #77.  Conclusions  1 critical and 4 high severity issues were found in the code base in addition to the high severity issue that the Ethereum Foundation noted. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix: Architectural Analysis  Overview  Many security features and mitigations to protect nodes and bundlers are executed partially or entirely off-chain; they also involve complex interactions between multiple parties with competing interests. Based on the EIP and our discussions with the Ethereum Foundation, we have captured our understanding of these features to correct any misunderstandings and identify any shortcomings. For clarity, we are referencing the latest design, which includes modifications that were made during or after the audit. This document attempts to describe high level concepts, and then systematically interrogate the details.  Basic Structure  Actors  Wallets  Smart contract wallets are primary accounts. Users construct arbitrary operations and publish them to a new mempool and each operation is associated with a specific smart contract wallet. In practice, each operation is an arbitrary call to the wallet. This allows the wallet to perform an action from its own context. A wallet can be deployed as part of its first operation.  Paymasters  Operations can specify optional paymasters. These are contracts that agree to pay the gas fees associated with the operation. Typically, they would be reimbursed somehow (perhaps with an ERC20 token), but the system does not specify or enforce any particular incentive. They must stake some funds beforehand as an anti-sybil mechanism. They must also prepay for the operations that they will fund.  Bundlers  Bundlers watch the new mempool and aggregate multiple operations into a bundle (i.e. an array of operations). They submit the bundle to miners as an Ethereum transaction. In practice, miners could also be bundlers. They will pay the gas fees associated with the bundle at the transaction gas price. However, users specify their own gas price with each operation and bundlers will be reimbursed at this rate. The difference between the user-specified gas price and the transaction gas price provides the incentive for bundlers to participate.  Miners  Miners treat bundles like normal Ethereum transactions (with a small exception related to transaction ordering, explained below).  Nodes  Nodes are clients that participate in the mempool gossip network without necessarily mining or bundling.  Execution  Bundlers submit their bundle transactions to the global EntryPoint contract. For each operation in the bundle, the EntryPoint validates that the wallet contract accepts it as valid, and that the wallet or paymaster (if specified) is willing and able to pay for it. The paymaster can use this opportunity to validate that the wallet will reimburse them. If any of the validations fail, the whole bundle reverts.  For each (now validated) operation, the EntryPoint creates a new call frame and performs the following steps:  Executes the operation (i.e. invokes the wallet with the operation data) and traps any errors.  Hands control to the paymaster (if it exists) to perform any after-operation functionality, whether or not the operation succeeded. Typically, this would include retrieving reimbursement for the cost of the operation (that the paymaster will pay for).  This call frame wont revert in the first step because errors are caught. If the call frame reverts in the second (after-operation) step, its effects are rolled back, and the paymaster is given another chance to perform any after-revert functionality. If this after-revert step reverts, the whole bundle transaction reverts.  The EntryPoint collects gas costs at the user-specified rate. If the wallet is paying for the transaction, the maximum fee is retrieved before execution, and any unused funds are refunded. If instead the paymaster is paying for the transaction, the funds are deducted from their stake after execution. When all transactions in the bundle have been processed, the EntryPoint sends the funds to a bundler-specified address.  Rationale  Valid operations should be charged  If an operation is validated, someone (either the wallet or the paymaster) has agreed to pay for execution, whether or not the operation itself succeeds. Ideally, the EntryPoint would guarantee that the operation is executed and the bundler will be reimbursed. In practice, the EntryPoint guarantees that either:  All operations in the bundle will be executed and the bundler will be reimbursed, or  The paymaster is misbehaving in an identifiable way, or  The bundle is poorly constructed.  Bundlers are responsible for choosing valid operations  If any of the validations fail on chain, the bundler is at fault. Bundlers should:  Only include valid operations within a bundle.  Use the simulation mechanism (described below) to identify invalidated operations.  If the bundler-specified beneficiary address cannot be paid (for example, if its fallback function reverts), the bundler is at fault. In either case, the transaction reverts and the bundler has to pay the gas costs. Nobody else is affected.  Wallets are responsible for operation execution failures  If an operation fails, the wallet is at fault. Wallets should only accept valid operations. In the event that an operation fails, the wallet or paymaster is still charged for the execution. Paymasters are still provided with the same opportunity to retrieve reimbursement from the wallet.  Wallets are responsible for maintaining paymaster preconditions  If the paymasters after-operation function reverts, the wallet is at fault. Paymasters use their validation step to check preconditions that are assumed to hold after the operation. One example is to use the validation to ensure the wallet has funds, and the after-operation function to retrieve those funds as reimbursement. However, paymasters cannot guarantee that this will succeed because the user operation could invalidate the precondition. For example, the user operation could spend the tokens or revoke the allowance.  Wallets should only choose paymasters with agreeable after-operation functionality, and only approve operations that they know will succeed. If the after-operation function reverts:  The user operation will revert in the same call frame, which means its effects are rolled back.  The paymaster will typically use its after-revert function to retrieve the funds anyway.  The paymaster will pay the gas costs and the bundler will be reimbursed.  The overall effect is that the after-operation function is treated like part of the operation. If it fails, the wallet pays for the execution of a reverted operation.  Paymasters are responsible for guaranteeing payments  As noted above, wallets may cause the paymasters after-operation function to revert. In this scenario, the EntryPoint will invoke the paymasters after-revert function. When considering an individual operation, the paymaster validation step should guarantee the after-revert function will succeed, if it is invoked. Since the user operation has reverted (and its effects are rolled back), the operation cannot undermine this validation. The paymaster will typically use this function to retrieve reimbursement from the wallet; the validation would involve ensuring the wallet has sufficient funds with a corresponding allowance.  If the after-revert function reverts, the paymaster is typically at fault. However, the EntryPoint cannot penalize them directly (by trapping the error and charging them for the gas) because its possible that a valid after-revert function reverts when included in a poorly constructed batch (which would be the bundlers fault). The batch could contain operations that affect the validity of subsequent operations (for example, if multiple operations spend the same funds).  Bundlers are responsible for bundle success  As noted above, when a paymasters after-revert function reverts, the EntryPoint cannot identify if its due to a poorly constructed paymaster or bundle. Therefore, the bundler is responsible for recognizing failing bundles and avoiding operations with misbehaving paymasters. If any after-revert function in the batch reverts, the entire bundle transaction reverts and the bundler has to pay the gas costs. Nobody else, not even the paymaster is directly affected on chain. The bundler will consider the paymaster to be at fault. The off-chain simulation and paymaster reputation system (both explained below) limit the amount of griefing the paymaster can get away with.  Simulation  Overview  Bundlers are responsible for including operations that will pass validation (so the EntryPoint knows they are accepted by wallets and paymasters). They are not responsible for ensuring the operation itself succeeds or the paymaster is reimbursed. Bundlers use off-chain simulation to validate bundles before submitting them. It is worth noting that this process and the associated restrictions are intended as a safety feature for bundlers. It gives them confidence that bundle transactions will succeed and they will be compensated for the gas costs. Bundlers that understand the risks can choose to relax some of these restrictions.  First validation simulation  Clients should call simulateValidation (locally) on each user operation before accepting it into the mempool. This performs the validation for the wallet and paymaster (if it exists) against the current state of the blockchain. In this way, the mempool is only populated with operations that would have been valid at the time they were accepted.  Forbidden opcodes  The EIP lists some opcodes that cannot be used during validation because they contain environmental information about the execution context (not directly related to the state of the blockchain). This implies they can differ between off-chain simulation and on-chain execution. If these opcodes were used, a bundler could be misled into including transactions that would fail on-chain validation. The EntryPoint cannot distinguish this case from one in which the bundler simply included unauthorized transactions; the transaction would revert and the bundler would pay the gas costs. This is intended as a safety feature for bundlers, but it manifests as a restriction on wallets and paymasters.  Second validation simulation  Bundlers should call simulateValidation (locally) on each user operation before including it in a batch. The state of the blockchain can progress while operations are in the mempool, so its possible that previously valid operations become invalid. The second simulation ensures operations are still valid.  Forbidden state accesses  It is acceptable for some operations to become invalid between the first and second simulation. However, if too many operations were invalidated quickly, bundlers would waste time testing and rejecting them all. The EIP design principle is that each invalidated operation should cost an on-chain storage change. Stated more directly, a single on-chain storage change can only invalidate one operation in the mempool. This introduces a natural mitigation against intentionally invalidating multiple operations in the mempool as a denial-of-service attack (since changing on-chain storage costs significantly more than the nuisance caused by invalidating mempool operations).  As with the opcode banning, this is a safety feature for bundlers that manifests as a new restriction on wallets and paymasters. It is more plausible that wallets or paymasters will want to base validation decisions on external storage. Still, most valid use cases are supported. Additionally, bundlers can choose to (internally) whitelist contracts or functions that they know are safe, even if they violate this restriction. Its worth emphasizing that there is no storage restriction during the execution of the operation (which would be very prohibitive).  Bundle execution simulation  The second validation simulation ensures that each operation in a batch individually passes validation. It does not guarantee that the bundle execution will succeed. A bundle of valid operations could fail if:  An operations validation undermines a later validation in the batch.  A paymasters after-revert operation fails. This could occur if multiple transactions in the batch spend the same funds.  The bundle runs out of gas, particularly as a result of return bombing  A paymaster has insufficient funds to cover all operations in a batch. Bundlers should identify this scenario as they are constructing the batch.  Note that if an operations execution undermines a later operations execution, this is not an attack on the bundler. This is analogous to a normal Ethereum transaction in the mempool invalidating another transaction in the mempool. The second operation will fail, but the bundle will still succeed. To detect batch failures, bundlers should run eth_estimateGas on the entire bundle before submitting it. This step is used to obtain the gas required by the bundle. Moreover, if any operation fails, it should be removed from the batch. In this way (when combined with the opcode restrictions), bundlers know that the batch will succeed when executed on the current state of the blockchain.  Bundles have unique wallets  The EIP specifies that each operation in a bundle corresponds to a different wallet. When combined with the forbidden state access rules, this ensures wallet validations cannot interfere with each other. In practice, this is not much of a restriction since wallets will likely use nonces for transaction ordering. This means there should only be one valid operation per wallet at a time. Users can add additional operations with the same nonce to the mempool (e.g. to replace the transaction or increase its gas price), but only one should be included in the batch anyway. Note: There can be repeated paymasters within a bundle. Paymaster interference is handled by the reputation system (explained below). Additionally, our discussion with the Ethereum Foundation suggests that the mempool can only have a limited number operations corresponding to the same wallet.  Execution  Determinism  Bundlers must ensure that the on-chain bundle execution exactly matches the off-chain execution. Otherwise, an unrelated transaction could invalidate the bundle. To this end, bundlers must be a miner or have a relationship with a miner such that:  The bundle is the first transaction in the next block, or  None of the preceding transactions affect the bundle. This could be detected and enforced with access control lists.  Paymaster Reputation System  Paymasters have two opportunities to undermine bundlers:  Since the same paymaster can be used in multiple operations in the mempool, several operations can potentially be invalidated by a single on-chain state change.  Paymasters can have after-revert functions that incorrectly revert.  In both scenarios, the bundler will identify the issue during the bundle execution simulation, and remove the offending operations. Over time, this will result in operations from the same paymaster being added to the mempool (and expiring after 10 blocks) without being included in bundles. As explained in the EIP, paymasters must stake some funds (as an anti-sybil mechanism), and will be throttled or banned if they have too many operations that are not included in bundles. Their stake is not slashed and the rate-limiting calculation is based on the amount of inclusions from the previous day, weighting the more recent hours more heavily. In this way, throttling is naturally reversed over time.  It is worth noting that even though bundlers can construct invalid batches from valid operations (explained above), this is not an attack against paymasters as long as there are some bundlers who include the operations in sensible batches. The possibility of invalid batches from valid operations is why the EntryPoint cannot penalize paymasters directly when their after-revert function fails, but invalid batches themselves do not directly affect the rest of the system because they are never published.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-acknowledged.", "labels": ["OpenZeppelin"]}, {"title": "[N24] Naming suggestions [core and sample]", "body": "[N24] Naming suggestions [core and sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n24]-naming-suggestions-[core-and-sample]", "labels": ["OpenZeppelin"]}, {"title": "We believe some functions are variables could benefit from renaming. These are our suggestions:", "body": "We believe some functions are variables could benefit from renaming. These are our suggestions:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#we-believe-some-functions-are-variables-could-benefit-from-renaming.-these-are-our-suggestions:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0IOracle,\u00a0DepositPaymaster\u00a0and\u00a0TokenPaymaster\u00a0contracts all have a\u00a0getTokenToEthOutputPrice\u00a0function, but in all cases, it\u2019s not a price (because it accounts for the amount bought) and it appears to be described backwards. Something like\u00a0getTokenValueOfEth\u00a0would be clearer.", "body": "The\u00a0IOracle,\u00a0DepositPaymaster\u00a0and\u00a0TokenPaymaster\u00a0contracts all have a\u00a0getTokenToEthOutputPrice\u00a0function, but in all cases, it\u2019s not a price (because it accounts for the amount bought) and it appears to be described backwards. Something like\u00a0getTokenValueOfEth\u00a0would be clearer.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#the\u00a0ioracle,\u00a0depositpaymaster\u00a0and\u00a0tokenpaymaster\u00a0contracts-all-have-a\u00a0gettokentoethoutputprice\u00a0function,-but-in-all-cases,-it\u2019s-not-a-price-(because-it-accounts-for-the-amount-bought)-and-it-appears-to-be-described-backwards.-something-like\u00a0gettokenvalueofeth\u00a0would-be-clearer.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0last parameter of\u00a0validateUserOp\u00a0in the\u00a0IWallet\u00a0interface should be\u00a0missingWalletFunds\u00a0or\u00a0additionalFundsRequired\u00a0to match how it\u2019s used in the\u00a0EntryPoint\u00a0contract.", "body": "The\u00a0last parameter of\u00a0validateUserOp\u00a0in the\u00a0IWallet\u00a0interface should be\u00a0missingWalletFunds\u00a0or\u00a0additionalFundsRequired\u00a0to match how it\u2019s used in the\u00a0EntryPoint\u00a0contract.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#the\u00a0last-parameter-of\u00a0validateuserop\u00a0in-the\u00a0iwallet\u00a0interface-should-be\u00a0missingwalletfunds\u00a0or\u00a0additionalfundsrequired\u00a0to-match-how-it\u2019s-used-in-the\u00a0entrypoint\u00a0contract.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0gasUsedByValidateUserOp\u00a0variable\u00a0should be\u00a0gasUsedByValidateWalletPrepayment", "body": "The\u00a0gasUsedByValidateUserOp\u00a0variable\u00a0should be\u00a0gasUsedByValidateWalletPrepayment", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#the\u00a0gasusedbyvalidateuserop\u00a0variable\u00a0should-be\u00a0gasusedbyvalidatewalletprepayment", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0PaymentMode\u00a0options\u00a0should be\u00a0paymasterDeposit\u00a0and\u00a0walletDeposit, because neither uses the \u201cstake\u201d for gas payments.", "body": "The\u00a0PaymentMode\u00a0options\u00a0should be\u00a0paymasterDeposit\u00a0and\u00a0walletDeposit, because neither uses the \u201cstake\u201d for gas payments.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#the\u00a0paymentmode\u00a0options\u00a0should-be\u00a0paymasterdeposit\u00a0and\u00a0walletdeposit,-because-neither-uses-the-\u201cstake\u201d-for-gas-payments.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0sender\u00a0parameter in\u00a0the\u00a0_call\u00a0function\u00a0of the\u00a0SimpleWallet\u00a0contract should be\u00a0target.", "body": "The\u00a0sender\u00a0parameter in\u00a0the\u00a0_call\u00a0function\u00a0of the\u00a0SimpleWallet\u00a0contract should be\u00a0target.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#the\u00a0sender\u00a0parameter-in\u00a0the\u00a0_call\u00a0function\u00a0of-the\u00a0simplewallet\u00a0contract-should-be\u00a0target.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0maxPriorityFeePerGas\u00a0component\u00a0of the\u00a0UserOperation\u00a0struct should be\u00a0priorityFeePerGas.", "body": "The\u00a0maxPriorityFeePerGas\u00a0component\u00a0of the\u00a0UserOperation\u00a0struct should be\u00a0priorityFeePerGas.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#the\u00a0maxpriorityfeepergas\u00a0component\u00a0of-the\u00a0useroperation\u00a0struct-should-be\u00a0priorityfeepergas.", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0BasePaymaster, the\u00a0setEntrypoint\u00a0and\u00a0_requireFromEntrypoint\u00a0functions should capitalize the \u201cp\u201d for consistency with the rest of the code base.", "body": "In\u00a0BasePaymaster, the\u00a0setEntrypoint\u00a0and\u00a0_requireFromEntrypoint\u00a0functions should capitalize the \u201cp\u201d for consistency with the rest of the code base.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in\u00a0basepaymaster,-the\u00a0setentrypoint\u00a0and\u00a0_requirefromentrypoint\u00a0functions-should-capitalize-the-\u201cp\u201d-for-consistency-with-the-rest-of-the-code-base.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed in pull request\u00a0#80\u00a0and commit\u00a0074672b6ccfb596fe7ff44e13783881a2e1cfed2. The following naming suggestions were not implemented:", "body": "Update: Partially fixed in pull request\u00a0#80\u00a0and commit\u00a0074672b6ccfb596fe7ff44e13783881a2e1cfed2. The following naming suggestions were not implemented:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-partially-fixed-in-pull-request\u00a0#80\u00a0and-commit\u00a0074672b6ccfb596fe7ff44e13783881a2e1cfed2.-the-following-naming-suggestions-were-not-implemented:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0maxPriorityFeePerGas\u00a0component of the\u00a0UserOperation\u00a0struct should be\u00a0priorityFeePerGas. Ethereum Foundation comment on this issue:", "body": "The\u00a0maxPriorityFeePerGas\u00a0component of the\u00a0UserOperation\u00a0struct should be\u00a0priorityFeePerGas. Ethereum Foundation comment on this issue:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#the\u00a0maxpriorityfeepergas\u00a0component-of-the\u00a0useroperation\u00a0struct-should-be\u00a0priorityfeepergas.-ethereum-foundation-comment-on-this-issue:", "labels": ["OpenZeppelin"]}, {"title": "Note that maxPriorityFeePerGas was left unchanged, since it defines the maximum, not actual fee paid by the user.", "body": "Note that maxPriorityFeePerGas was left unchanged, since it defines the maximum, not actual fee paid by the user.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#note-that-maxpriorityfeepergas-was-left-unchanged,-since-it-defines-the-maximum,-not-actual-fee-paid-by-the-user.", "labels": ["OpenZeppelin"]}, {"title": "[N25] Typographical errors [core and sample]", "body": "[N25] Typographical errors [core and sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n25]-typographical-errors-[core-and-sample]", "labels": ["OpenZeppelin"]}, {"title": "Consider addressing the following typographical errors:", "body": "Consider addressing the following typographical errors:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#consider-addressing-the-following-typographical-errors:", "labels": ["OpenZeppelin"]}, {"title": "line 29\u00a0and\u00a0line 30: \u201csimulateOp\u201d should be \u201csimulateValidation\u201d", "body": "line 29\u00a0and\u00a0line 30: \u201csimulateOp\u201d should be \u201csimulateValidation\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-29\u00a0and\u00a0line-30:-\u201csimulateop\u201d-should-be-\u201csimulatevalidation\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 178: \u201cof\u201d should be \u201cif\u201d", "body": "line 178: \u201cof\u201d should be \u201cif\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-178:-\u201cof\u201d-should-be-\u201cif\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 297: \u201cdone, by\u201d should be \u201cdone and\u201d", "body": "line 297: \u201cdone, by\u201d should be \u201cdone and\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-297:-\u201cdone,-by\u201d-should-be-\u201cdone-and\u201d", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0IWallet.sol:", "body": "In\u00a0IWallet.sol:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in\u00a0iwallet.sol:", "labels": ["OpenZeppelin"]}, {"title": "line 10: \u201csuccessfuly.\u201d should be \u201csuccessfully.\u201d", "body": "line 10: \u201csuccessfuly.\u201d should be \u201csuccessfully.\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-10:-\u201csuccessfuly.\u201d-should-be-\u201csuccessfully.\u201d", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0StakeManager.sol:", "body": "In\u00a0StakeManager.sol:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in\u00a0stakemanager.sol:", "labels": ["OpenZeppelin"]}, {"title": "line 12: \u201cblocks to\u201d should be \u201cseconds to wait\u201d", "body": "line 12: \u201cblocks to\u201d should be \u201cseconds to wait\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-12:-\u201cblocks-to\u201d-should-be-\u201cseconds-to-wait\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 83: \u201ctime\u201d should be \u201cduration\u201d", "body": "line 83: \u201ctime\u201d should be \u201cduration\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-83:-\u201ctime\u201d-should-be-\u201cduration\u201d", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0DepositPaymaster.sol:", "body": "In\u00a0DepositPaymaster.sol:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in\u00a0depositpaymaster.sol:", "labels": ["OpenZeppelin"]}, {"title": "line 68: \u201con in the same block as withdrawTo()\u201d should be \u201cin the same block as withdrawTokensTo()\u201d", "body": "line 68: \u201con in the same block as withdrawTo()\u201d should be \u201cin the same block as withdrawTokensTo()\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-68:-\u201con-in-the-same-block-as-withdrawto()\u201d-should-be-\u201cin-the-same-block-as-withdrawtokensto()\u201d", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0SimpleWallet.sol:", "body": "In\u00a0SimpleWallet.sol:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in\u00a0simplewallet.sol:", "labels": ["OpenZeppelin"]}, {"title": "line 88: \u201c(its\u201d should be \u201c(it\u2019s\u201d", "body": "line 88: \u201c(its\u201d should be \u201c(it\u2019s\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-88:-\u201c(its\u201d-should-be-\u201c(it\u2019s\u201d", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0TokenPaymaster.sol:", "body": "In\u00a0TokenPaymaster.sol:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in\u00a0tokenpaymaster.sol:", "labels": ["OpenZeppelin"]}, {"title": "line 11: \u201cos\u201d should be \u201cor\u201d", "body": "line 11: \u201cos\u201d should be \u201cor\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-11:-\u201cos\u201d-should-be-\u201cor\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 18: \u201cmethod-ids.\u201d should be \u201cmethod ids.\u201d", "body": "line 18: \u201cmethod-ids.\u201d should be \u201cmethod ids.\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-18:-\u201cmethod-ids.\u201d-should-be-\u201cmethod-ids.\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 77: \u201cpaymaster\u201d should be \u201centrypoint\u201d", "body": "line 77: \u201cpaymaster\u201d should be \u201centrypoint\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-77:-\u201cpaymaster\u201d-should-be-\u201centrypoint\u201d", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0VerifyingPaymaster.sol:", "body": "In\u00a0VerifyingPaymaster.sol:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in\u00a0verifyingpaymaster.sol:", "labels": ["OpenZeppelin"]}, {"title": "line 57: \u201csigning\u201d should be \u201cto signing\u201d", "body": "line 57: \u201csigning\u201d should be \u201cto signing\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-57:-\u201csigning\u201d-should-be-\u201cto-signing\u201d", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0eip-4337.md:", "body": "In\u00a0eip-4337.md:", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#in\u00a0eip-4337.md:", "labels": ["OpenZeppelin"]}, {"title": "line 46: \u201cfor to compensate the bundler for\u201d should be \u201cto compensate the bundler\u201d", "body": "line 46: \u201cfor to compensate the bundler for\u201d should be \u201cto compensate the bundler\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-46:-\u201cfor-to-compensate-the-bundler-for\u201d-should-be-\u201cto-compensate-the-bundler\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 84: \u201cworlflow\u201d should be \u201cworkflow\u201d", "body": "line 84: \u201cworlflow\u201d should be \u201cworkflow\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-84:-\u201cworlflow\u201d-should-be-\u201cworkflow\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 89: \u201csimulateWalletValidation\u201d should be \u201csimulateValidation\u201d", "body": "line 89: \u201csimulateWalletValidation\u201d should be \u201csimulateValidation\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-89:-\u201csimulatewalletvalidation\u201d-should-be-\u201csimulatevalidation\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 127: \u201cpaymaster\u201d should be \u201cpaymaster)\u201d", "body": "line 127: \u201cpaymaster\u201d should be \u201cpaymaster)\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-127:-\u201cpaymaster\u201d-should-be-\u201cpaymaster)\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 151: \u201cop\u201d should be \u201cop\u00a0validation\u201d", "body": "line 151: \u201cop\u201d should be \u201cop\u00a0validation\u201d", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-151:-\u201cop\u201d-should-be-\u201cop\u00a0validation\u201d", "labels": ["OpenZeppelin"]}, {"title": "line 165: \u201cvaliation\u201d should be \u201cvalidation\u201d and the line should end in a period.", "body": "line 165: \u201cvaliation\u201d should be \u201cvalidation\u201d and the line should end in a period.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#line-165:-\u201cvaliation\u201d-should-be-\u201cvalidation\u201d-and-the-line-should-end-in-a-period.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#79\u00a0and pull request\u00a0#88.", "body": "Update: Fixed in pull request\u00a0#79\u00a0and pull request\u00a0#88.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#79\u00a0and-pull-request\u00a0#88.", "labels": ["OpenZeppelin"]}, {"title": "[N26] Abstract StakeManager contract [core]", "body": "[N26] Abstract StakeManager contract [core]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n26]-abstract-stakemanager-contract-[core]", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0StakeManager\u00a0contract\u00a0is intended to provide staking functionality to other contracts, but should not be deployed directly. To better signal this intention, consider declaring the contract as\u00a0abstract.", "body": "The\u00a0StakeManager\u00a0contract\u00a0is intended to provide staking functionality to other contracts, but should not be deployed directly. To better signal this intention, consider declaring the contract as\u00a0abstract.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#the\u00a0stakemanager\u00a0contract\u00a0is-intended-to-provide-staking-functionality-to-other-contracts,-but-should-not-be-deployed-directly.-to-better-signal-this-intention,-consider-declaring-the-contract-as\u00a0abstract.", "labels": ["OpenZeppelin"]}, {"title": "[N27] Declare uint as uint256 [core and sample]", "body": "[N27] Declare uint as uint256 [core and sample]", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#[n27]-declare-uint-as-uint256-[core-and-sample]", "labels": ["OpenZeppelin"]}, {"title": "To favor explicitness, consider declaring all instance of\u00a0uint\u00a0as\u00a0uint256.", "body": "To favor explicitness, consider declaring all instance of\u00a0uint\u00a0as\u00a0uint256.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#to-favor-explicitness,-consider-declaring-all-instance-of\u00a0uint\u00a0as\u00a0uint256.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request\u00a0#77.", "body": "Update: Fixed in pull request\u00a0#77.", "html_url": "https://blog.openzeppelin.com/eth-foundation-account-abstraction-audit#update:-fixed-in-pull-request\u00a0#77.", "labels": ["OpenZeppelin"]}, {"title": "Anyone can steal money from other suppliers in TUSD market by creating negative interest rates", "body": "Auditors note:The bug behind this issue was first privately reported by the ChainSecurity team during their audit of the CToken Refactors. The OpenZeppelin team was later provided access to ChainSecuritys private report and took it as an input. After further exploring scenarios, OpenZeppelin not only confirmed Chainsecuritys findings but found that other protocols could be impacted by similar integration issues with TUSD. As a result, OpenZeppelin worked with the TUSD team to fix the issue at the source.  It is important to note that this vulnerability was in code that was out of scope for this audit and would have likely gone unnoticed if not for the excellent work of the ChainSecurity team.  Context  The exchangeRateStoredInternal function from the CToken contract calculates the exchange rate between an underlying token and its cToken as follows:  Where:  exchangeRate: the exchange rate between the underlying and the cToken, e.g., TUSD/cTUSD  totalCash: the total amount of underlying held by the cToken contract (calculated by calling underlying.balanceOf(cToken))  totalBorrows: the total amount of underlying borrowed  totalReserves: the total reserves of the market, managed by the protocol that is not intended to be borrowed  totalSupply: the total supply of the cToken minted to suppliers, otherwise known as liquidity providers (LPs)  The mintFresh function uses this exchange rate to calculate how many cTokens should be minted to a user that supplies underlying tokens to the market.  The CToken contract additionally defines the sweepToken function, that can be called by anyone, which moves tokens accidentally sent to the CToken contract to its admin, i.e., the Timelock. This function cannot be called for the underlying token. So, for instance, if the CDAI contract holds USDT, anyone can call the sweepToken function on the CDAI contract, sending the USDT balance to the Timelock contract. Notably, if anyone calls this function sending the DAI address as the parameter, the call will fail since the underlying cannot be moved to the Timelock  The TUSD market case  The issue lies in the fact that the totalCash, in the numerator of the exchangeRate formula described above, can be moved to 0 by calling the sweepToken function, and given the amount of underlying that is not being used for borrows in the TUSD market (roughly 50% of the TVL), the exchange rate could be moved down by around 50%.  This means that after calling the sweep function, the following would happen:  The exchange rate, which tracks the borrow rate, and should always be an increasing function, will go down by ~50%  Any supplier that adds TUSD to the market will receive ~2x the cTUSD amount they should. (A malicious supplier could discover this bug, call the sweep function, and then immediately add liquidity)  Any supplier that provided liquidity to the market before the sweep and then redeems their liquidity after the sweep will receive roughly 50% less of the underlying asset than they should. This would only be possible if suppliers added liquidity at an inflated exchange rate after the sweep. Until the sweep is reversed, they will not be able to redeem any amount  Even if the Timelock moves the funds back to the CTUSD contract, the relationship between the cTUSD supply and underlying assets can be permanently changed due to overminted cTUSD tokens. The interest rates would then remain negative, ultimately putting the market in a loss state for previous suppliers. The degree of the negative rates would depend on the amount of cTUSD tokens minted after the sweep: The more inflated cTUSD tokens minted after the sweep, the more negative the interest rate would be  The exact amounts can be found in this spreadsheet.  On February 23rd 2022, the TUSD team disallowed forwarded calls from the legacy contract to the current contract by rejecting them from the latter, ultimately fixing the issue.  High Severity  None.  Medium Severity  None.  Low Severity", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#anyone-can-steal-money-from-other-suppliers-in-tusd-market-by-creating-negative-interest-rates", "labels": ["OpenZeppelin"]}, {"title": "cEther might fail when repaying a borrow", "body": "repayBorrow function of the  repayBorrowFresh function of the  line 683 of the  Then in line 696, the doTransferIn function calls back the CEther implementation where it checks again that msg.value == repayAmountFinal.  This implies the following: If an amount of ether equal to type(uint).max is passed (Which is unlikely, since it represents an enormous quantity of ETH), then the repayAmountFinal which is passed in the doTransferIn function will be different from the original msg.value = repayAmount and execution will revert. If an amount greater than the actual borrow is passed in, then an underflow will occur in line 703, and the execution will revert.  So to pay an ETH loan in its entirety, one must pass msg.value with the exact total borrow amount. If the amount is greater, it will revert. If msg.value == uint(type).max, it will also revert but for different reasons.  Consider refactoring the code to avoid checking type(uint).max in the CETH case as this cannot be passed as msg.value. Consider requiring that repayAmount <= accountBorrowsPrev instead.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#cether-might-fail-when-repaying-a-borrow", "labels": ["OpenZeppelin"]}, {"title": "Possible function selector clashing", "body": "The upgradeability system implemented in the codebase does not manage function clashing between the proxy contract and the implementation contract.  Clashing can happen among functions with different names. Every function that is part of a contracts public ABI is identified, at the bytecode level, by a 4-byte identifier. This identifier depends on the name and arity of the function, but since it is only 4 bytes, there is a possibility that two different functions with different names may end up having the same identifier. The Solidity compiler tracks when this happens within the same contract, but not when the collision happens across different ones, such as between a proxy and its logic contract.  Upgradeable contract instances (or proxies) work by delegating all calls to a logic contract. However, the proxies need some functions of their own, such as _setPendingImplementation(address) and _acceptImplementation() to upgrade to a new implementation. This setup means there can be a function in the proxy contract with the same 4-byte identifier as one in the implementation contract. This issue would make it impossible to access the one defined in the implementation contract, as the call will not be handled by the fallback function but by the function with that signature in the proxy contract.  Consider thoroughly testing all functions implemented in each upgradeable contract to ensure no collisions are possible. Alternatively, consider migrating to the EIP-1822: Universal Upgradeable Proxy Standard (UUPS), which, by design, does not have this problem.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#possible-function-selector-clashing", "labels": ["OpenZeppelin"]}, {"title": "Gas inefficiencies", "body": "There are many places throughout the codebase where changes can be made to improve gas consumption. For example:  Arbitrary use of different uint types can lead to unwanted effects  Numerous unsigned integer (uint) values of various sizes are used. Those less than 256-bits (uint256) are used extensively. Non-uint256 sizes are generally chosen to facilitate tight packing inside of structs to save on storage costs. However, projects must carefully weigh the realized gas savings against the additional complexity such a design decision introduces.  Since the Ethereum Virtual Machine operates on 256-bit integers, additional operations must be performed to process non-uint256 values. These additional operations increase the bytecode size of contracts and consume additional gas during execution.  In the Comp contract, for example, it was necessary to include some specific functions to manage these units safely but causing extra gas costs for the additional operations. Other than that, the variables are not properly packed in the slots of the contract, so the choice of picking these units is not justified.  The code in some loops is executed unnecessarily  cancel should verify  Some variables are being unnecessarily initialized to their default value  getPriorVotes function the local variable  transferTokens function the local variable  NO_ERROR.  The loops of some functions are not properly optimized  getHypotheticalAccountLiquidityInternal,  _addMarketInternal,  fixBadAccruals and  claimComp, in  queue,  execute and  cancel in  if it is a storage array, this is an extra sload operation(100 additional extra gas (EIP-2929) for each iteration except for the first),  if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first),  if it is a calldata array, this is an extra calldataload operation (3 additional gas for each iteration except for the first)  These extra costs are avoidable by creating a variable with the array length (caching the array length in stack).  Arguments with read-only parameters are using memory instead of calldata  Some protocol contract functions have parameters in which they use the keyboard memory. This may not be very efficient as it performs unnecessary steps if the argument is read-only. Here some examples:  safe32, safe96, add96 and sub96 in Comp.sol  enterMarkets, updateCompBorrowIndex, distributeBorrowerComp, claimComp, _setCompSpeeds in Comptroller.sol  propose in GovernorBravoDelegate.sol  Consider using calldata instead of memory if the function argument is only read.  Storage slots read multiple times  Operations that load values onto the execution stack can be expensive. On several occasions, some variables are read multiple times and cause gas cost overruns in the execution. Here are some examples:  doTransferIn in the CToken contract reads three times the underlying state variable.  propose in the GovernorBravoDelegate contract reads three times the targets.length memory variable.  state in Governor Bravo Delegate, the local variable proposal is unnecessarily defined with the keyword storage, causing multiple reads from storage.  Line 254 of cToken contract is defining a storage variable when memory can be used instead.  To avoid this, consider only loading the variable onto the stack once and reusing it from the stack itself.  Redundant validations  The exitMarket function performs a redundant check to verify if the sender is not already in the market. The internal function redeemAllowedInternal called by the former performs the same validation.  Consider removing the redundant validation.  Unnecessary extra steps  transferTokens has local variables and validations that are wasting gas without adding any value and reducing readability.  Consider removing intermediate variable definitions to act directly on storage variables and and synthesize the validations.  Redundant usage of the Exp type  Usage of Exp type can be avoided at lines 308-310 in favour of uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#gas-inefficiencies", "labels": ["OpenZeppelin"]}, {"title": "isPriceOracle is not used", "body": "uses a  current implementation, the  UniswapAnchorView contract implementation. However, theres a mismatch between  what the PriceOracle interface should implement and what is  actually implemented.  isPriceOracle getter is not present in the implementation, making the  Moreover, when setting a new oracle, theres no check on whether the new implementation implements isPriceOracle nor assets price is retrieved to check if the oracle is working.  Consider either refactoring the PriceOracle interface or adjusting the current implementation to match its interface. This improves correctness and consistency but will also avoid unexpected call failures.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#ispriceoracle-is-not-used", "labels": ["OpenZeppelin"]}, {"title": "Missing or erroneous docstrings and comments", "body": "Several docstrings and inline comments throughout the codebase were found to be erroneous and should be fixed. Some examples are:  In line 2458 of Unitroller.sol, the concept of ComptrollerCore is mentioned but not used nowhere else in the codebase again  In line 2460 of Unitroller.sol, the comment appears to be either incomplete or the if should be removed from the end of the comment  In line 17 of Exponential.sol says INT but should say UINT  line 237 of Comptroller.sol is incorrect, since minter is actually used.  In line 13 of PriceOracle.sol used by the Comptroller says that zero means price unavailable. But according to how that function works, this is not true in general. The result can be correctly 0 and be a valid price.  In line 795 of CToken.sol should say to avoid re-entrancy check  In line 291 of CToken.sol, should be changed since the function does not return error codes anymore (expect the NO_ERROR code in case of success)  In line 136 of Comptroller.sol, borrower should be supplier or borrower. Note that, in this case, the parameter name should also be changed for consistency and accuracy.  In line 140 of CToken.sol, instead of mentioning that -1 is infinite, it should say that uint256.max is the maximum amount allowed  Additionally, some public and external functions throughout the codebase lack documentation. The lack of documentation hinders a reviewers understanding of the codes intention, an understanding that is essential for correctly assessing both security and correctness. Docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec). Additionally, consider reviewing all existent comments and docstrings to check whether they are complete, descriptive, and accurate, including the examples mentioned above.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#missing-or-erroneous-docstrings-and-comments", "labels": ["OpenZeppelin"]}, {"title": "Commented out or missing verify calls", "body": "The CToken contract includes either commented out or removed lines of code without giving enough context on why those lines have been discarded, thus providing them with little to no value at all. These are:  The transferVerify, mintVerify which have been commented out.  The repayBorrowVerify call which was completely removed from the cToken code.  If any of these function calls will be re-activated in the future by changing their current implementation, this CToken model will need to be updated too.  To avoid compatibility issues and to independently support any Comptroller upgrade, consider adding those function calls back. Alternatively, as the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are present to provide alternate implementation options, consider extracting them to a separate document where a deeper and more thorough explanation could be included.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#commented-out-or-missing-verify-calls", "labels": ["OpenZeppelin"]}, {"title": "Outdated Solidity versions", "body": "The version of Solidity used throughout the codebase is outdated, varies between contracts, and is not pinned.  The choice of Solidity version should always be informed by the features each version introduces and that the codebase could benefit from, as well as the list of known bugs associated with each version. Examples of this are:  Unitroller and Timelock  0.5.8  Compiler Bugs.  Comptroller and COMP Token  0.5.16  Compiler Bugs.  GovernorBravoDelegator and GovernorBravoDelegate  0.5.17  Compiler Bugs.  The new CToken contract uses ^0.8.6  Compiler Bugs.  Consider taking advantage of the latest Solidity version to improve the overall readability and security of the codebase. Regardless of which version of Solidity is used, consider pinning the version consistently throughout the codebase to prevent the introduction of bugs due to incompatible future releases.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#outdated-solidity-versions", "labels": ["OpenZeppelin"]}, {"title": "Unreachable code", "body": "During the cToken refactor, error handling migrated from returning error codes to reverts. However, error codes in the external/public functions have been preserved for compatibility.  In some cases, these error codes are still being checked, but the code after the check is unreachable, increases gas cost, and reduces readability.  In particular, the accrueInterest function always returns NO_ERROR or reverts thus these code blocks are unreachable:  mintInternal  redeemInternal  redeemUnderlyingInternal  borrowInternal  repayBorrowInternal  repayBorrowBehalfInternal  liquidateBorrowInternal (but lines 732-735 should be kept)  _setReserveFactor  _addReservesInternal  _reduceReserves  _setInterestRateModel  totalBorrowsCurrent  borrowBalanceCurrent  exchangeRateCurrent  The following if clauses of the CToken contract will never be true since the accrueInterest function is always called at the beginning of a mint and will update the accrualBlockNumber to be the latest block number.  mintFresh  redeemFresh  borrowFresh  repayBorrowFresh  liquidateBorrowFresh (but lines 761-764 should be kept)  _setReserveFactorFresh  _addReservesFresh  _reduceReservesFresh  _setInterestRateModelFresh  Consider refactoring the code where necessary to improve the overall gas needed to deploy and run operations.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#unreachable-code", "labels": ["OpenZeppelin"]}, {"title": "Unused functions and parameters", "body": "In the up-to-date version of the protocol, the Comptroller contract has many functions and parameters defined which are deprecated and not used anymore. In particular:  mintVerify, redeemVerify, borrowVerify, repayBorrowVerify, liquidateBorrowVerify, seizeVerify and transferVerify do nothing.  isComped, maxAssets, _mintGuardianPaused, _borrowGuardianPaused, compSpeeds, compRate, closeFactorMinMantissa and closeFactorMaxMantissa are not used anymore.  Given the distributed ownership over the Compound protocol, the code base is frequently revisited and maintained by many different community members and contributors. Also, the intrinsic storage layout separation pattern and the upgradeability design have important tradeoff consequences over the general readability and quality of the codebase.  We suggest revisiting the current implementation and starting a community-wide conversation over the long-term codebase development to avoid making the error more confused and less readable.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#unused-functions-and-parameters", "labels": ["OpenZeppelin"]}, {"title": "Unused return value", "body": "Line 940 of the Comptroller contract calls the isCToken getter in the cToken contract when listing a new market, but it does check the return value, making this check completely useless.  If the called address has no isCToken getter and the passed contract is not an EOA, the fallback function will be executed. Moreover, if the answer is false, the market should not be listed.  The unwanted outcome is that Markets can be mistakenly added but cannot be removed according to the latest deployed version.  Consider explicitly checking the return value of such calls and eventually revert with any unwanted behaviours or values returned.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#unused-return-value", "labels": ["OpenZeppelin"]}, {"title": "A compromised underlying asset can drain all funds from the protocol", "body": "If an underlying assets collateral factor in a specific market is greater than zero and the underlying token is upgraded with malicious code, then it might be possible to set an arbitrarily large underlying balance to drain all other markets and drain them using the underlying asset as collateral. There could be other examples where a malicious upgrade of an underlying token can circumvent the entire protocols security, and the protocol would be blind to such events.  In the short-term, consider this risk for a new token listing process and add monitoring for compromised or upgraded underlying assets. In the long-term, consider a system design where a specific underlying token cant affect the protocol as a whole to mitigate this specific risk.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#a-compromised-underlying-asset-can-drain-all-funds-from-the-protocol", "labels": ["OpenZeppelin"]}, {"title": "Block velocity assumption", "body": "The InterestRateStrategy makes an assumption on the number of blocks per year to evaluate interests rate.  This will not work for many current L2 solutions or future Ethereum upgrades. Even if this doesnt pose a security issue today, it might be an issue in the future if Compound is deployed on many different chains.  Consider adding this to the backlog tasks when planning to deploy the protocol to a new chain.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#block-velocity-assumption", "labels": ["OpenZeppelin"]}, {"title": "Code style inconsistencies", "body": "Across the codebase there are several places where code has an inconsistent style. Some examples are:  Inconsistent error handling between line 489 and line 504 in the Comptroller contract.  Mixed docstrings style in the ComptrollerInterface used by the Comptroller.  SNAKE_CASE for constants is missing for quorumVotes and proposalMaxOperations in the GovernorBravoDelegate contract.  Some contracts use a require statement for access control and others an if and a custom function called fail that does not revert but returns a number that refers to a type of error.  Consider reviewing the entire codebase to improve consistency and refactor the code where possible.Take into consideration using the Solidity Style Guide when doing so enforcing a standard coding style with help of linter tools such as Solhint.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#code-style-inconsistencies", "labels": ["OpenZeppelin"]}, {"title": "Declare uint as uint256", "body": "In the audited contracts, there is a general use of unsigned integer variables declared as uint.  To favor explicitness, consider replacing all instances of uint to uint256.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#declare-uint-as-uint256", "labels": ["OpenZeppelin"]}, {"title": "doTransferOut doesn\u2019t ensure success operation", "body": "The doTransferOut function performs an ERC20s transfer operation taking into account that this transfer call may not return anything if the asset is not ERC20 compliant. To manage this, it uses an assembly block that is implemented to check the returndatasize() as follows:  When returndatasize() = 0, it is assumed that the asset does not comply with the ERC20 specification, and set the success variable to true.  When returndatasize() = 32, it is assumed that the returned value was either true or false, and set the success variable as the returned value.  When returndatasize() equals any other value, it is assumed that the asset is an excessively non-compliant ERC20, and the function reverts.  The issue lies in the fact that when returndatasize() is zero, It cannot be ensured that the transfer succeeded, since the transfer may have silently failed. If the transfer call silently fails, the users CTokens will be burned but no tokens are going to be transferred back to them.  Even though this does not pose a security risk in any current Compound market, it may cause problems in markets to be added in the future.  Consider adding an additional check to the doTransferOut function to evaluate whether the final underlying balance of the CToken is different than its initial underlying balance. Additionally, consider exhaustively reviewing the transfer and transferFrom functions of any future market addition proposal to check that they cannot silently fail.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#dotransferout-doesn\u2019t-ensure-success-operation", "labels": ["OpenZeppelin"]}, {"title": "Implementation used as interface", "body": "_become function to call back the  implementation and not an interface. This implementation slightly differs from the  real  CToken contract.  Consider using interfaces instead of contract files to avoid confusion, improve readability, and reduce the codebase size.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#implementation-used-as-interface", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed parameters in events", "body": "Over the code base, theres inconsistent use of indexed parameters for event definitions. Specifically, some event definitions lack completely indexed parameters. Some examples are:  The Failure event of the ComptrollerErrorReporter.  The event definitions of the Unitroller.  Many events of the GovernorBravoDelegator contract.  Many events of the Comptroller contract.  Many events of the CTokenInterfaces contract.  The NewImplementation event of the CDelegatorInterface.  Consider indexing event parameters to avoid hindering the task of off-chain services searching and filtering for specific events.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#lack-of-indexed-parameters-in-events", "labels": ["OpenZeppelin"]}, {"title": "Lack of input validation", "body": "In the codebase, there are several places where theres a lack of input validation. Some examples:  Admin functions of the Comptroller lack of input validation.  The Unitroller doesnt have input validation when setting pending implementation or admin.  When calling _setMarketBorrowCaps an array of cTokens is passed to be configured with a borrow cap. However, there is no check on whether each market isListed before setting a borrow cap.  Consider reviewing the codebase looking for any places where an input validation might be beneficial. This will reduce attack surface, error propagations and improve overall security.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Lack of SPDX License Identifier", "body": "All Compound protocol contracts except those developed for the new CToken contract do not have a license identifier.  To avoid legal issues regarding copyright and follow best practices, consider adding the SPDX license identifier as suggested by the Solidity documentation.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#lack-of-spdx-license-identifier", "labels": ["OpenZeppelin"]}, {"title": "Constants not declared explicitly", "body": "There are several occurrences of literal values with unexplained meaning in the Compound Protocols contracts. Some examples are:  In Comptroller.sol: line 176, line 188, line 738, and line 1088.  line 71,  line 405,  line 521,  line 584,  line 670,  line 752, and  line 833  Literal values in the codebase without an explained meaning make the code harder to read, understand and maintain, thus hindering the experience of developers, auditors, and external contributors alike.  For the examples mentioned above in particular, all 0 constants can be replaced with either Error.NO_ERROR or NO_ERROR constants. But in general, developers should define a constant variable for every magic value used (including booleans), giving it a clear and self-explanatory name. Additionally, for complex values, inline comments explaining how they were calculated or why they were chosen are highly recommended. Following Soliditys style guide, constants should be named in UPPER_CASE_WITH_UNDERSCORES format, and specific public getters should be defined to read each one of them.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#constants-not-declared-explicitly", "labels": ["OpenZeppelin"]}, {"title": "cEth and cErc20 underlying balances can be manipulated", "body": "In the cErc20 contract, the balance of the underlying asset is calculated by calling the balanceOf function from the EIP20Interface interface. As a result, if any underlying tokens are sent directly to a cErc20 contract, bypassing the mint function, the underlying token balance is incremented without minting the corresponding cTokens to the user.  When a market has already a notable amount of liquidity, sending funds directly to these contracts will not be profitable, and will instead mean each cToken holder can claim more tokens for themselves. However in markets where the amount of underlying in the contract is relatively low, this may not be true as sending untracked tokens to the market can cause a large change to a markets exchange rate, ultimetly allowing over-minting of cTokens in extreme conditions.  The same is true of cEth, where an actor can bypass the receive function using self destruct, similarly manipulating the underlying amount.  Consider tracking the total underlying balance in a new variable, and increment/decrement it as appropriate when supplies and borrows happen, to avoid adverse actors from being able to bypass predefined functions and manipulating the markets exchange rate.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#ceth-and-cerc20-underlying-balances-can-be-manipulated", "labels": ["OpenZeppelin"]}, {"title": "Markets can\u2019t be unlisted", "body": "The current implementation does not allow for a Markets isListed flag to be turned off. However, markets can become deprecated but will stay in the allMarkets storage variable.  Moreover, the current implementation often performs for loops around the allMarkets array. This altogether means that markets cant be effectively unlisted nor removed from the array.  If markets are added in the future or if some get deprecated, they will still incur higher gas prices for normal operations since the calculations will run through all the markets array independently.  Consider starting a discussion on how to effectively refactor the code to improve the current design in order to improve general gas cost and optimize storage usage.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#markets-can\u2019t-be-unlisted", "labels": ["OpenZeppelin"]}, {"title": "Improper imports style", "body": "Non-explicit imports are used throughout all protocol contracts. This reduces code readability and could lead to conflicts between names defined locally and the ones imported.  Furthermore, many contracts are defined inside the same Solidity files, making the issue even more significant.  Some examples of multiple contracts and interfaces within the same file are:  GovernorBravoEvents, GovernorBravoDelegatorStorage, GovernorBravoDelegateStorageV1, GovernorBravoDelegateStorageV2, TimelockInterface, CompInterface, GovernorAlpha are in GovernorBravoInterfaces.sol  CTokenStorage, CTokenInterface, CErc20Storage, CErc20Interface, CDelegationStorage, CDelegatorInterface, CDelegateInterface are in CTokenInterfaces.sol  On the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported and avoid having multiple implementations in the same file.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#improper-imports-style", "labels": ["OpenZeppelin"]}, {"title": "Typos", "body": "Accross the codebase there are different typos. Some examples are:  contructor should be constructor.  arity should be parity.  tather should be rather.  Consider correcting these typos and review the codebase to check for more to improve code readability.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#typos", "labels": ["OpenZeppelin"]}, {"title": "Unclear and inconsistent naming", "body": "There are some places in the codebase that might benefit from some naming changes:  The UnitrollerAdminStorage.sol not only holds the admin storage variables but also the implementation variables (comptrollerImplementation, pendingComptrollerImplementation), so naming it UnitrollerStorage would be more general and consistent.  In general, there is no clear and consistent naming system for functions. Some contracts follow the convention that internal ones are prefixed with _, but in other cases this prefix is used for admin functions that can be public, external or, internal. Some examples are:  In the Comp token contract the prefix is used for internal functions although not consistently as safe32, safe96, add96, sub96 and getChainId are internal and do not carry the prefix.  In the Comptroller, CToken and GovernorBravo contracts, the convention is that the prefix is used for admin functions.  Consider being consistent to improve code readability, clarity, and quality. An inconsistent naming system can confuse users and is prone to error. Moreover, consider reviewing the entire codebase for potential other occurrences.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#unclear-and-inconsistent-naming", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary assembly code", "body": "Functions getChainId and getChainIdInternal use assembly code to query for the identifier of the blockchain in which the contract is deployed.  For future implementations, consider using the global variable block.chainid to improve readability, reduce execution gas and optimize bytecode size.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#unnecessary-assembly-code", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary checks", "body": "Throughout the codebase, there are some unnecessary checks that can be avoided to save gas and improve readability. For example:  The _acceptAdmin function and the _acceptImplementation function in Unitroller.sol validate that the msg.sender is not the zero address (that is, the new admin who calls the function is not the zero address and the address of the new Comptroller implementation is not the zero address), which is an unfeasible scenario, and is anyway validated in both if clauses in the first evaluated condition  The borrowAllowed function in Comptroller.sol redundantly checks whether the borrower is part of the accountMembership mapping, since this flag is properly set in the addToMarketInternal function, and if that fails, it will return beforehand.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#unnecessary-checks", "labels": ["OpenZeppelin"]}, {"title": "Wrong or missing visibility in functions and variables", "body": "The following functions are defined as public but are never locally used:  inComp.sol: delegate, delegateBySig and getPriorVotes.  in Comptroller.sol: enterMarkets, getAccountLiquidity, getHypotheticalAccountLiquidity, _setPriceOracle, _setPauseGuardian, _setMintPaused, _setBorrowPaused, _setTransferPaused, _setSeizePaused, _become, _grantComp, _setCompSpeeds, _setContributorCompSpeed, getAllMarkets  in CToken.sol: _setInterestRateModel  in GovernorBravoDelegate.sol: propose  all functions in Unitroller contract.  Moreover, in the ExponentialNoError contract, all the constants are implicitly using the default visibility.  To clarify intent and favor readability, consider explicitly declaring the visibility of all constants and state variables. Also, consider changing the visibility of the aforementioned functions to external to reduce gas costs.", "html_url": "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit#wrong-or-missing-visibility-in-functions-and-variables", "labels": ["OpenZeppelin"]}, {"title": "[N01] addStorageRoot can add duplicate url\u2018s", "body": "[N01] addStorageRoot can add duplicate url\u2018s", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#[n01]-addstorageroot-can-add-duplicate-url\u2018s", "labels": ["OpenZeppelin"]}, {"title": "PR #8360, the", "body": "PR #8360, the", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#pr-#8360,-the", "labels": ["OpenZeppelin"]}, {"title": "addStorageRoot function of the", "body": "addStorageRoot function of the", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#addstorageroot-function-of-the", "labels": ["OpenZeppelin"]}, {"title": "This function does not check whether the url already exists in the array so there can be duplicate entries added.", "body": "This function does not check whether the url already exists in the array so there can be duplicate entries added.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#this-function-does-not-check-whether-the-url-already-exists-in-the-array-so-there-can-be-duplicate-entries-added.", "labels": ["OpenZeppelin"]}, {"title": "This does not pose a security risk. However, it can result in unnecessary gas expenditure. Furthermore the resulting redundant data returned by the getOffchainStorageRoots function can confuse offchain clients and add computational complexity to the processing of this data.", "body": "This does not pose a security risk. However, it can result in unnecessary gas expenditure. Furthermore the resulting redundant data returned by the getOffchainStorageRoots function can confuse offchain clients and add computational complexity to the processing of this data.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#this-does-not-pose-a-security-risk.-however,-it-can-result-in-unnecessary-gas-expenditure.-furthermore-the-resulting-redundant-data-returned-by-the-getoffchainstorageroots-function-can-confuse-offchain-clients-and-add-computational-complexity-to-the-processing-of-this-data.", "labels": ["OpenZeppelin"]}, {"title": "Consider using OpenZeppelin\u2019s EnumerableMap as a more practical solution than an array.", "body": "Consider using OpenZeppelin\u2019s EnumerableMap as a more practical solution than an array.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#consider-using-openzeppelin\u2019s-enumerablemap-as-a-more-practical-solution-than-an-array.", "labels": ["OpenZeppelin"]}, {"title": "Update: Acknowledged, and will not fix. cLab\u2019s statement for this issue:", "body": "Update: Acknowledged, and will not fix. cLab\u2019s statement for this issue:", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#update:-acknowledged,-and-will-not-fix.-clab\u2019s-statement-for-this-issue:", "labels": ["OpenZeppelin"]}, {"title": "These duplicates can be checked for on the client side easily, both as a check before adding a duplicate or as a filter on the returned storage roots. To avoid complicating and inflating the cost of the storage root logic, we will not make a change to address this at this time.", "body": "These duplicates can be checked for on the client side easily, both as a check before adding a duplicate or as a filter on the returned storage roots. To avoid complicating and inflating the cost of the storage root logic, we will not make a change to address this at this time.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#these-duplicates-can-be-checked-for-on-the-client-side-easily,-both-as-a-check-before-adding-a-duplicate-or-as-a-filter-on-the-returned-storage-roots.-to-avoid-complicating-and-inflating-the-cost-of-the-storage-root-logic,-we-will-not-make-a-change-to-address-this-at-this-time.", "labels": ["OpenZeppelin"]}, {"title": "[N02] ExchangeBRL.sol lacks Solidity version pragma", "body": "[N02] ExchangeBRL.sol lacks Solidity version pragma", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#[n02]-exchangebrl.sol-lacks-solidity-version-pragma", "labels": ["OpenZeppelin"]}, {"title": "In PR #8831, the ExchangeBRL.sol file does not define a Solidity version pragma.", "body": "In PR #8831, the ExchangeBRL.sol file does not define a Solidity version pragma.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#in-pr-#8831,-the-exchangebrl.sol-file-does-not-define-a-solidity-version-pragma.", "labels": ["OpenZeppelin"]}, {"title": "In this case, it does not pose a security threat since the ExchangeBRL contract has trivial logic and its base contract does have its Solidity version pragma set. But it is considered good practice to always define the Solidity version pragma, since it can be a security concern when the contract contains non-trivial operations which can have different effects across Solidity versions.", "body": "In this case, it does not pose a security threat since the ExchangeBRL contract has trivial logic and its base contract does have its Solidity version pragma set. But it is considered good practice to always define the Solidity version pragma, since it can be a security concern when the contract contains non-trivial operations which can have different effects across Solidity versions.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#in-this-case,-it-does-not-pose-a-security-threat-since-the-exchangebrl-contract-has-trivial-logic-and-its-base-contract-does-have-its-solidity-version-pragma-set.-but-it-is-considered-good-practice-to-always-define-the-solidity-version-pragma,-since-it-can-be-a-security-concern-when-the-contract-contains-non-trivial-operations-which-can-have-different-effects-across-solidity-versions.", "labels": ["OpenZeppelin"]}, {"title": "Consider defining Solidity version pragmas for all Solidity source files in this project.", "body": "Consider defining Solidity version pragmas for all Solidity source files in this project.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#consider-defining-solidity-version-pragmas-for-all-solidity-source-files-in-this-project.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed as of commit 8e0caecc0554d5a3f6fb25b6d024f29ff7562029.", "body": "Update: Fixed as of commit 8e0caecc0554d5a3f6fb25b6d024f29ff7562029.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#update:-fixed-as-of-commit-8e0caecc0554d5a3f6fb25b6d024f29ff7562029.", "labels": ["OpenZeppelin"]}, {"title": "[N03] Not using SafeMath", "body": "[N03] Not using SafeMath", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#[n03]-not-using-safemath", "labels": ["OpenZeppelin"]}, {"title": "PR #8360 contains a getOffchainStorageRoots function which concatenates the url bytes of an account using the help of a local totalLength variable. The totalLength is the aggregated length of all the offchainStorageRoots elements for a specified account.", "body": "PR #8360 contains a getOffchainStorageRoots function which concatenates the url bytes of an account using the help of a local totalLength variable. The totalLength is the aggregated length of all the offchainStorageRoots elements for a specified account.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#pr-#8360-contains-a-getoffchainstorageroots-function-which-concatenates-the-url-bytes-of-an-account-using-the-help-of-a-local-totallength-variable.-the-totallength-is-the-aggregated-length-of-all-the-offchainstorageroots-elements-for-a-specified-account.", "labels": ["OpenZeppelin"]}, {"title": "Consider using OpenZeppelin\u2019s SafeMath to perform the addition to totalLength to prevent overflow and maintain consistency with the method in batchGetMetadataURL.", "body": "Consider using OpenZeppelin\u2019s SafeMath to perform the addition to totalLength to prevent overflow and maintain consistency with the method in batchGetMetadataURL.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#consider-using-openzeppelin\u2019s-safemath-to-perform-the-addition-to-totallength-to-prevent-overflow-and-maintain-consistency-with-the-method-in-batchgetmetadataurl.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in PR9026 as of commit 6af9bf0371550f723731080929f9d8946d78d524.", "body": "Update: Fixed in PR9026 as of commit 6af9bf0371550f723731080929f9d8946d78d524.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#update:-fixed-in-pr9026-as-of-commit-6af9bf0371550f723731080929f9d8946d78d524.", "labels": ["OpenZeppelin"]}, {"title": "[N04] Incorrect token initialization data", "body": "[N04] Incorrect token initialization data", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#[n04]-incorrect-token-initialization-data", "labels": ["OpenZeppelin"]}, {"title": "In PR #8831, the migrationsConfig.js file is updated to include initialization data for the deployment of the StableTokenBRL.", "body": "In PR #8831, the migrationsConfig.js file is updated to include initialization data for the deployment of the StableTokenBRL.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#in-pr-#8831,-the-migrationsconfig.js-file-is-updated-to-include-initialization-data-for-the-deployment-of-the-stabletokenbrl.", "labels": ["OpenZeppelin"]}, {"title": "incorrectly set to be a copy of the", "body": "incorrectly set to be a copy of the", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#incorrectly-set-to-be-a-copy-of-the", "labels": ["OpenZeppelin"]}, {"title": "This incorrect token initialization will not affect the inner logic and accounting of the token itself. However, this mislabelling can cause errors in indexing this token in exchanges, and will likely confuse users which can greatly affect its utility and adoption.", "body": "This incorrect token initialization will not affect the inner logic and accounting of the token itself. However, this mislabelling can cause errors in indexing this token in exchanges, and will likely confuse users which can greatly affect its utility and adoption.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#this-incorrect-token-initialization-will-not-affect-the-inner-logic-and-accounting-of-the-token-itself.-however,-this-mislabelling-can-cause-errors-in-indexing-this-token-in-exchanges,-and-will-likely-confuse-users-which-can-greatly-affect-its-utility-and-adoption.", "labels": ["OpenZeppelin"]}, {"title": "Consider updating the migrationsConfig.js to have appropriate tokenName and tokenSymbol set specific to the StableTokenBRL.", "body": "Consider updating the migrationsConfig.js to have appropriate tokenName and tokenSymbol set specific to the StableTokenBRL.", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#consider-updating-the-migrationsconfig.js-to-have-appropriate-tokenname-and-tokensymbol-set-specific-to-the-stabletokenbrl.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed as of commit 92441e39e3b5cbb29bb8af6ed914b90a874d9afe. cLabs comments on the issue:", "body": "Update: Fixed as of commit 92441e39e3b5cbb29bb8af6ed914b90a874d9afe. cLabs comments on the issue:", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#update:-fixed-as-of-commit-92441e39e3b5cbb29bb8af6ed914b90a874d9afe.-clabs-comments-on-the-issue:", "labels": ["OpenZeppelin"]}, {"title": "As a clarification, wanted to point out that file is only used for testing proposals and not for mainnet (not even testnets).", "body": "As a clarification, wanted to point out that file is only used for testing proposals and not for mainnet (not even testnets).", "html_url": "https://blog.openzeppelin.com/celo-contracts-audit-release-6#as-a-clarification,-wanted-to-point-out-that-file-is-only-used-for-testing-proposals-and-not-for-mainnet-(not-even-testnets).", "labels": ["OpenZeppelin"]}, {"title": "[N01] Deprecated project dependencies", "body": "[N01] Deprecated project dependencies", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#[n01]-deprecated-project-dependencies", "labels": ["OpenZeppelin"]}, {"title": "During the installation of the project\u2019s dependencies, NPM warns that one of the packages installed, Highlight, \u201cwill no longer be supported or receive security updates in the future\u201d.", "body": "During the installation of the project\u2019s dependencies, NPM warns that one of the packages installed, Highlight, \u201cwill no longer be supported or receive security updates in the future\u201d.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#during-the-installation-of-the-project\u2019s-dependencies,-npm-warns-that-one-of-the-packages-installed,-highlight,-\u201cwill-no-longer-be-supported-or-receive-security-updates-in-the-future\u201d.", "labels": ["OpenZeppelin"]}, {"title": "Even though it is unlikely that this package could cause a security risk, consider upgrading the dependency that uses this package to a maintained version.", "body": "Even though it is unlikely that this package could cause a security risk, consider upgrading the dependency that uses this package to a maintained version.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#even-though-it-is-unlikely-that-this-package-could-cause-a-security-risk,-consider-upgrading-the-dependency-that-uses-this-package-to-a-maintained-version.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 0a2b55d. However, the installation now requires the usage of the -force flag on current LTS versions of node in order to succeed.", "body": "Update: Fixed in commit 0a2b55d. However, the installation now requires the usage of the -force flag on current LTS versions of node in order to succeed.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#update:-fixed-in-commit-0a2b55d.-however,-the-installation-now-requires-the-usage-of-the--force-flag-on-current-lts-versions-of-node-in-order-to-succeed.", "labels": ["OpenZeppelin"]}, {"title": "[N02] Pool fees may incentivize imbalanced deposits", "body": "[N02] Pool fees may incentivize imbalanced deposits", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#[n02]-pool-fees-may-incentivize-imbalanced-deposits", "labels": ["OpenZeppelin"]}, {"title": "When depositing into the FixedRateSwap contract, the _getVirtualAmountsForDeposit function calculates the virtual value of the deposit. Virtual amounts are the original amounts scaled, after charging the fee according to the pool\u2019s current asset ratio.", "body": "When depositing into the FixedRateSwap contract, the _getVirtualAmountsForDeposit function calculates the virtual value of the deposit. Virtual amounts are the original amounts scaled, after charging the fee according to the pool\u2019s current asset ratio.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#when-depositing-into-the-fixedrateswap-contract,-the-_getvirtualamountsfordeposit-function-calculates-the-virtual-value-of-the-deposit.-virtual-amounts-are-the-original-amounts-scaled,-after-charging-the-fee-according-to-the-pool\u2019s-current-asset-ratio.", "labels": ["OpenZeppelin"]}, {"title": "If a user deposits funds at the current ratio of assets within the pool then they are not charged fees. Otherwise, they are charged fees based on the difference between their deposit ratio and the pool\u2019s current asset ratio.", "body": "If a user deposits funds at the current ratio of assets within the pool then they are not charged fees. Otherwise, they are charged fees based on the difference between their deposit ratio and the pool\u2019s current asset ratio.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#if-a-user-deposits-funds-at-the-current-ratio-of-assets-within-the-pool-then-they-are-not-charged-fees.-otherwise,-they-are-charged-fees-based-on-the-difference-between-their-deposit-ratio-and-the-pool\u2019s-current-asset-ratio.", "labels": ["OpenZeppelin"]}, {"title": "This design implies that when the ratio of assets within the pool is imbalanced, users would be incentivized to deposit at the same imbalanced ratio, rather than deposit at a ratio which would make the pool more balanced.", "body": "This design implies that when the ratio of assets within the pool is imbalanced, users would be incentivized to deposit at the same imbalanced ratio, rather than deposit at a ratio which would make the pool more balanced.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#this-design-implies-that-when-the-ratio-of-assets-within-the-pool-is-imbalanced,-users-would-be-incentivized-to-deposit-at-the-same-imbalanced-ratio,-rather-than-deposit-at-a-ratio-which-would-make-the-pool-more-balanced.", "labels": ["OpenZeppelin"]}, {"title": "To encourage a more balanced pool, consider incentivizing deposits that balance the pool rather than penalizing them. Alternatively, if this is not feasible, consider explaining why within the project\u2019s documentation.", "body": "To encourage a more balanced pool, consider incentivizing deposits that balance the pool rather than penalizing them. Alternatively, if this is not feasible, consider explaining why within the project\u2019s documentation.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#to-encourage-a-more-balanced-pool,-consider-incentivizing-deposits-that-balance-the-pool-rather-than-penalizing-them.-alternatively,-if-this-is-not-feasible,-consider-explaining-why-within-the-project\u2019s-documentation.", "labels": ["OpenZeppelin"]}, {"title": "Update: Acknowledged, and will not fix.", "body": "[L06] No accessible coverage report  Although the README file points to a coverage report, it is inaccessible.  Additionally, there are no instructions for running the test coverage scripts.  Consider making the coverage report accessible and explicitly documenting how to run the test coverage scripts.  Update: Partially fixed. The coverage report is now accessible, however the README file still does not explain how to run the scripts.  [L07] Potentially unsafe unchecked math  Throughout the FixedRateSwap contract, there are many uses of unchecked math. The main reason for using unchecked math is to remove overflow/underflow checks in cases that either rely on such behavior or are known not to underflow/overflow. This has the benefit of saving gas, but, if used incorrectly, can lead to unexpected results and potential vulnerabilities.  Instances of unchecked arithmetic that can potentially underflow/overflow were identified. For example:  The _getReturn function can overflow in multiple places, potentially returning a highly diminished outputAmount.  The _checkVirtualAmountsFormula function can overflow.  The _powerHelper function can overflow, but it is only used by the private _getReturn function.  The necessary values required to overflow these calculations, paired with reasonable validations throughout the codebase, often prevent these overflows from being achievable in practice, but they are still theoretically possible. Consider not using unchecked math except whenever the possibility of overflows can be completely ruled out, in order to prevent unexpected results and reduce the overall attack surface of the protocol.    [L08] Unsafe explicit casting of integers  Swap event takes an  swap0To1,  swap1To0,  swap0To1For, and  swap1To0For functions.  During emission, however, the integer values being passed to the event are explicitly cast from uint256 to int256 values.  Although unlikely to be problematic in practice today, ecosystems developments such as unbounded flash loans of stablecoin assets could cause this design to exhibit undesirable behaviors in the future. On a given large enough uint256 value, explicitly casting into an int256 type would truncate its value. As a result, off-chain systems, dependent on the accuracy of the event emission, could be misled.  Consider redefining the Swap event to deal directly with uint256 values so that the functions that emit the event can forego the explicit casts.  Update: Fixed in commit 8436c6c. 1inch team imported the OpenZeppelins SafeCast library to safely cast the mentioned cases.  [L09] Withdrawal process could result in flooring  When a share holder uses either the withdraw or the withdrawFor functions, the contract calculates the amount of assets that they are entitled to given an amount of shares. Those assets are then transferred to the specified recipient.  However, since if statements are being used rather than require statements to validate whether any asset should be sent to the recipient, if the pool is unbalanced and the amount of shares is small, the contract could floor the value to be sent for either one or both of the assets.  Given that the values involved would necessarily be quite small, and in consideration of the fact that the protocol cannot completely restrict withdrawals where one token output may in fact be zero, consider documenting this potential rounding behavior so that users are aware of it when withdrawing.    Notes & Additional Information  [N01] Deprecated project dependencies  During the installation of the projects dependencies, NPM warns that one of the packages installed, Highlight, will no longer be supported or receive security updates in the future.  Even though it is unlikely that this package could cause a security risk, consider upgrading the dependency that uses this package to a maintained version.  Update: Fixed in commit 0a2b55d. However, the installation now requires the usage of the -force flag on current LTS versions of node in order to succeed.  [N02] Pool fees may incentivize imbalanced deposits  When depositing into the FixedRateSwap contract, the _getVirtualAmountsForDeposit function calculates the virtual value of the deposit. Virtual amounts are the original amounts scaled, after charging the fee according to the pools current asset ratio.  If a user deposits funds at the current ratio of assets within the pool then they are not charged fees. Otherwise, they are charged fees based on the difference between their deposit ratio and the pools current asset ratio.  This design implies that when the ratio of assets within the pool is imbalanced, users would be incentivized to deposit at the same imbalanced ratio, rather than deposit at a ratio which would make the pool more balanced.  To encourage a more balanced pool, consider incentivizing deposits that balance the pool rather than penalizing them. Alternatively, if this is not feasible, consider explaining why within the projects documentation.    [N03] Undocumented implicit approval requirements  The FixedRateSwap contract implicitly assumes that it has been granted an appropriate allowance before executing swaps and deposits which necessarily transfer tokens.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.    [N04] Confusing implicit validation of outputAmount  getReturn function is provided three parameters, namely, a token to swap from (  calculated and returned.  Before the calculation, the function requires that the inputAmount value is less than or equal to the pools token balance of the tokenTo asset. However, the outputAmount value, arguably the more intuitive value to check against the tokenTo asset balance, is never explicitly checked for the same condition.  In fact, the math used to calculate outputAmount value ensures that it will be strictly less than or equal to the inputAmount value.  However, the intentionality of this behavior is unclear, i.e. it is not obvious whether this design is just meant to fail more quickly during execution to reduce the gas cost or not. Consider explicitly documenting the reasoning for the exact check used. Additionally, consider validating if the balance of the to asset is greater than the outputAmount value as opposed to the inputAmount value.  Update: Fixed in commit 10f4d9c.  [N05] Naming inconsistency  FixedRateSwap contract sets an explicit  pair of tokens that the swap, withdrawal, and deposit operations are meant to operate with. Throughout the codebase, these tokens are labeled with an index of either  swap0To1 function.  withdrawForWithRatio function, the parameter that defines the proportion to receive of  firstTokenShare which could introduce confusion that it is in reference to the  To improve overall readability and reduce potential confusion, consider keeping naming conventions consistent throughout the entire codebase.  Update: Fixed in commit 57ad4cd.  [N06] Revert messages are inconsistently formatted  The require statements in the constructor of the FixedRateSwap contract are formatted differently than all of the other require statements in the contract.  As inconsistently formatted revert messages can introduce unnecessary confusion, consider ensuring that all require statements have revert messages that are consistently formatted, accurate, informative, and user-friendly.  Update: Fixed in commit 0aa4e9d.  [N07] Inconsistent use of named return variables  There is an inconsistent use of named return variables in the FixedRateSwap contract.  Specifically, while most functions return named variables, the decimals, _getVirtualAmountsForDepositImpl, _getRealAmountsForWithdrawImpl, and _checkVirtualAmountsFormula functions return explicit values.  Consider adopting a consistent approach to return values throughout the codebase by removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This would improve both the explicitness and readability of the code, and it may also help reduce regressions during future code refactors.    [N08] Gas optimizations  Within the FixedRateSwap contract, there are opportunities for a few simple gas consumption reductions. For instance:  The _getVirtualAmountsForDeposit private function is only ever called from one place in the codebase, and that is the depositFor function. Within the depositFor function there are calls to token0.balanceOf(address(this)) and token1.balanceOf(address(this)). However, those exact same calls are made at the top of the _getVirtualAmountsForDeposit function. The latter function could simply be passed the required values, instead of reading the balances twice per depositFor call.  Within the _getRealAmountsForWithdrawImpl private function, the secondTokenShare variable is defined as _ONE - firstTokenShare. On the very next line, the exact same subtraction is performed again when it could simply use the secondTokenShare variable.  To reduce gas costs and further simplify the codebase, consider addressing the instances raised above.  Update: Fixed in commit 34974ee.  [N09] Incorrect function visibility  The withdrawWithRatio function is not called internally by any of the functions in the FixedRateSwap contract. Consider setting the visibility to external instead of public.  Update: Fixed in commit cb852f5.  [N10] Reliance on matching decimals may be problematic  The protocol implicitly requires that both tokens inside of a pool support the decimals method for pool construction to be successful. In reality, this method is almost ubiquitous, but it is, technically, an optional component of the ERC20 specification wherein it is explicitly stated that contracts MUST NOT expect these values to be present. Currently, any tokens that do not support the optional decimals method will not be usable within the protocol.  Perhaps more problematically, as part of these calls to token decimals, the protocol further requires that both tokens return identical values.  However, the stable coin token space is not homogeneous in this regard. It is comprised of many tokens that return a variety of different values for decimals. For instance, while USDT and USDC report 6 decimals, DAI reports 18 decimals.  If these are intentional limitations of the protocol, consider touching on them explicitly and providing short justifications via the inline documentation. Also consider providing better error messages at construction time for tokens that do not support the decimals method. Alternatively, consider making the protocol more robust, so that it can handle tokens that do not support the decimals method or pairs reporting disparate decimals within the same pool.  Update: Fixed in commit b49d808. Inline documentation was added.  [N11] Typographical error  We identified the following typographical error in the codebase:  The revert message on line 92 of FixedRateSwap.sol starts without a capital letter, making it inconsistent with the rest of the code.  To improve the overall consistency and readability of the codebase, consider correcting this and any other typographical errors throughout the codebase.  Update: Fixed in commit a92d16a.  [N12] Unnecessarily virtual function  The FixedRateSwap contract inherits from OpenZeppelins ERC20 contract but it overrides its ERC20.decimals function. This is required because the FixedRateSwaps liquidity pool token, being dependent on the decimals of the assets that comprise the pool, is necessarily dynamic.  However, even though this overriding implementation of the function should be final, it is defined with the virtual keyword, signaling that it is not necessarily a final implementation and allowing for it to be overridden again.  To avoid confusion and clarify intent, consider removing the virtual keyword or documenting the reasons for keeping it.  Update: Fixed in commit 8bce5ec.  Conclusions  No high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#update:-acknowledged,-and-will-not-fix.", "labels": ["OpenZeppelin"]}, {"title": "[N03] Undocumented implicit approval requirements", "body": "[N03] Undocumented implicit approval requirements", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#[n03]-undocumented-implicit-approval-requirements", "labels": ["OpenZeppelin"]}, {"title": "The FixedRateSwap contract implicitly assumes that it has been granted an appropriate allowance before executing swaps and deposits which necessarily transfer tokens.", "body": "The FixedRateSwap contract implicitly assumes that it has been granted an appropriate allowance before executing swaps and deposits which necessarily transfer tokens.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#the-fixedrateswap-contract-implicitly-assumes-that-it-has-been-granted-an-appropriate-allowance-before-executing-swaps-and-deposits-which-necessarily-transfer-tokens.", "labels": ["OpenZeppelin"]}, {"title": "In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions\u2019 inline documentation.", "body": "In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions\u2019 inline documentation.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#in-favor-of-explicitness-and-to-improve-the-overall-clarity-of-the-codebase,-consider-documenting-all-approval-requirements-in-the-relevant-functions\u2019-inline-documentation.", "labels": ["OpenZeppelin"]}, {"title": "[N04] Confusing implicit validation of outputAmount", "body": "[N04] Confusing implicit validation of outputAmount", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#[n04]-confusing-implicit-validation-of-outputamount", "labels": ["OpenZeppelin"]}, {"title": "getReturn function is provided three parameters, namely, a token to swap from (", "body": "getReturn function is provided three parameters, namely, a token to swap from (", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#getreturn-function-is-provided-three-parameters,-namely,-a-token-to-swap-from-(", "labels": ["OpenZeppelin"]}, {"title": "calculated and returned.", "body": "calculated and returned.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#calculated-and-returned.", "labels": ["OpenZeppelin"]}, {"title": "Before the calculation, the function requires that the inputAmount value is less than or equal to the pool\u2019s token balance of the tokenTo asset. However, the outputAmount value, arguably the more intuitive value to check against the tokenTo asset balance, is never explicitly checked for the same condition.", "body": "Before the calculation, the function requires that the inputAmount value is less than or equal to the pool\u2019s token balance of the tokenTo asset. However, the outputAmount value, arguably the more intuitive value to check against the tokenTo asset balance, is never explicitly checked for the same condition.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#before-the-calculation,-the-function-requires-that-the-inputamount-value-is-less-than-or-equal-to-the-pool\u2019s-token-balance-of-the-tokento-asset.-however,-the-outputamount-value,-arguably-the-more-intuitive-value-to-check-against-the-tokento-asset-balance,-is-never-explicitly-checked-for-the-same-condition.", "labels": ["OpenZeppelin"]}, {"title": "In fact, the math used to calculate outputAmount value ensures that it will be strictly less than or equal to the inputAmount value.", "body": "In fact, the math used to calculate outputAmount value ensures that it will be strictly less than or equal to the inputAmount value.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#in-fact,-the-math-used-to-calculate-outputamount-value-ensures-that-it-will-be-strictly-less-than-or-equal-to-the-inputamount-value.", "labels": ["OpenZeppelin"]}, {"title": "However, the intentionality of this behavior is unclear, i.e. it is not obvious whether this design is just meant to fail more quickly during execution to reduce the gas cost or not. Consider explicitly documenting the reasoning for the exact check used. Additionally, consider validating if the balance of the to asset is greater than the outputAmount value as opposed to the inputAmount value.", "body": "However, the intentionality of this behavior is unclear, i.e. it is not obvious whether this design is just meant to fail more quickly during execution to reduce the gas cost or not. Consider explicitly documenting the reasoning for the exact check used. Additionally, consider validating if the balance of the to asset is greater than the outputAmount value as opposed to the inputAmount value.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#however,-the-intentionality-of-this-behavior-is-unclear,-i.e.-it-is-not-obvious-whether-this-design-is-just-meant-to-fail-more-quickly-during-execution-to-reduce-the-gas-cost-or-not.-consider-explicitly-documenting-the-reasoning-for-the-exact-check-used.-additionally,-consider-validating-if-the-balance-of-the-to-asset-is-greater-than-the-outputamount-value-as-opposed-to-the-inputamount-value.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 10f4d9c.", "body": "Update: Fixed in commit 10f4d9c.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#update:-fixed-in-commit-10f4d9c.", "labels": ["OpenZeppelin"]}, {"title": "[N05] Naming inconsistency", "body": "[N05] Naming inconsistency", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#[n05]-naming-inconsistency", "labels": ["OpenZeppelin"]}, {"title": "FixedRateSwap contract sets an explicit", "body": "FixedRateSwap contract sets an explicit", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#fixedrateswap-contract-sets-an-explicit", "labels": ["OpenZeppelin"]}, {"title": "pair of tokens that the swap, withdrawal, and deposit operations are meant to operate with. Throughout the codebase, these tokens are labeled with an index of either", "body": "pair of tokens that the swap, withdrawal, and deposit operations are meant to operate with. Throughout the codebase, these tokens are labeled with an index of either", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#pair-of-tokens-that-the-swap,-withdrawal,-and-deposit-operations-are-meant-to-operate-with.-throughout-the-codebase,-these-tokens-are-labeled-with-an-index-of-either", "labels": ["OpenZeppelin"]}, {"title": "swap0To1 function.", "body": "swap0To1 function.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#swap0to1-function.", "labels": ["OpenZeppelin"]}, {"title": "withdrawForWithRatio function, the parameter that defines the proportion to receive of", "body": "withdrawForWithRatio function, the parameter that defines the proportion to receive of", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#withdrawforwithratio-function,-the-parameter-that-defines-the-proportion-to-receive-of", "labels": ["OpenZeppelin"]}, {"title": "firstTokenShare which could introduce confusion that it is in reference to the", "body": "firstTokenShare which could introduce confusion that it is in reference to the", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#firsttokenshare-which-could-introduce-confusion-that-it-is-in-reference-to-the", "labels": ["OpenZeppelin"]}, {"title": "To improve overall readability and reduce potential confusion, consider keeping naming conventions consistent throughout the entire codebase.", "body": "To improve overall readability and reduce potential confusion, consider keeping naming conventions consistent throughout the entire codebase.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#to-improve-overall-readability-and-reduce-potential-confusion,-consider-keeping-naming-conventions-consistent-throughout-the-entire-codebase.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 57ad4cd.", "body": "Update: Fixed in commit 57ad4cd.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#update:-fixed-in-commit-57ad4cd.", "labels": ["OpenZeppelin"]}, {"title": "[N06] Revert messages are inconsistently formatted", "body": "[N06] Revert messages are inconsistently formatted", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#[n06]-revert-messages-are-inconsistently-formatted", "labels": ["OpenZeppelin"]}, {"title": "The require statements in the constructor of the FixedRateSwap contract are formatted differently than all of the other require statements in the contract.", "body": "The require statements in the constructor of the FixedRateSwap contract are formatted differently than all of the other require statements in the contract.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#the-require-statements-in-the-constructor-of-the-fixedrateswap-contract-are-formatted-differently-than-all-of-the-other-require-statements-in-the-contract.", "labels": ["OpenZeppelin"]}, {"title": "As inconsistently formatted revert messages can introduce unnecessary confusion, consider ensuring that all require statements have revert messages that are consistently formatted, accurate, informative, and user-friendly.", "body": "As inconsistently formatted revert messages can introduce unnecessary confusion, consider ensuring that all require statements have revert messages that are consistently formatted, accurate, informative, and user-friendly.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#as-inconsistently-formatted-revert-messages-can-introduce-unnecessary-confusion,-consider-ensuring-that-all-require-statements-have-revert-messages-that-are-consistently-formatted,-accurate,-informative,-and-user-friendly.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 0aa4e9d.", "body": "Update: Fixed in commit 0aa4e9d.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#update:-fixed-in-commit-0aa4e9d.", "labels": ["OpenZeppelin"]}, {"title": "[N07] Inconsistent use of named return variables", "body": "[N07] Inconsistent use of named return variables", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#[n07]-inconsistent-use-of-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "There is an inconsistent use of named return variables in the FixedRateSwap contract.", "body": "There is an inconsistent use of named return variables in the FixedRateSwap contract.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#there-is-an-inconsistent-use-of-named-return-variables-in-the-fixedrateswap-contract.", "labels": ["OpenZeppelin"]}, {"title": "Specifically, while most functions return named variables, the decimals, _getVirtualAmountsForDepositImpl, _getRealAmountsForWithdrawImpl, and _checkVirtualAmountsFormula functions return explicit values.", "body": "Specifically, while most functions return named variables, the decimals, _getVirtualAmountsForDepositImpl, _getRealAmountsForWithdrawImpl, and _checkVirtualAmountsFormula functions return explicit values.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#specifically,-while-most-functions-return-named-variables,-the-decimals,-_getvirtualamountsfordepositimpl,-_getrealamountsforwithdrawimpl,-and-_checkvirtualamountsformula-functions-return-explicit-values.", "labels": ["OpenZeppelin"]}, {"title": "Consider adopting a consistent approach to return values throughout the codebase by removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This would improve both the explicitness and readability of the code, and it may also help reduce regressions during future code refactors.", "body": "Consider adopting a consistent approach to return values throughout the codebase by removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This would improve both the explicitness and readability of the code, and it may also help reduce regressions during future code refactors.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#consider-adopting-a-consistent-approach-to-return-values-throughout-the-codebase-by-removing-all-named-return-variables,-explicitly-declaring-them-as-local-variables,-and-adding-the-necessary-return-statements-where-appropriate.-this-would-improve-both-the-explicitness-and-readability-of-the-code,-and-it-may-also-help-reduce-regressions-during-future-code-refactors.", "labels": ["OpenZeppelin"]}, {"title": "[N08] Gas optimizations", "body": "[N08] Gas optimizations", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#[n08]-gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Within the FixedRateSwap contract, there are opportunities for a few simple gas consumption reductions. For instance:", "body": "Within the FixedRateSwap contract, there are opportunities for a few simple gas consumption reductions. For instance:", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#within-the-fixedrateswap-contract,-there-are-opportunities-for-a-few-simple-gas-consumption-reductions.-for-instance:", "labels": ["OpenZeppelin"]}, {"title": "The _getVirtualAmountsForDeposit private function is only ever called from one place in the codebase, and that is the depositFor function. Within the depositFor function there are calls to token0.balanceOf(address(this)) and token1.balanceOf(address(this)). However, those exact same calls are made at the top of the _getVirtualAmountsForDeposit function. The latter function could simply be passed the required values, instead of reading the balances twice per depositFor call.", "body": "The _getVirtualAmountsForDeposit private function is only ever called from one place in the codebase, and that is the depositFor function. Within the depositFor function there are calls to token0.balanceOf(address(this)) and token1.balanceOf(address(this)). However, those exact same calls are made at the top of the _getVirtualAmountsForDeposit function. The latter function could simply be passed the required values, instead of reading the balances twice per depositFor call.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#the-_getvirtualamountsfordeposit-private-function-is-only-ever-called-from-one-place-in-the-codebase,-and-that-is-the-depositfor-function.-within-the-depositfor-function-there-are-calls-to-token0.balanceof(address(this))-and-token1.balanceof(address(this)).-however,-those-exact-same-calls-are-made-at-the-top-of-the-_getvirtualamountsfordeposit-function.-the-latter-function-could-simply-be-passed-the-required-values,-instead-of-reading-the-balances-twice-per-depositfor-call.", "labels": ["OpenZeppelin"]}, {"title": "Within the _getRealAmountsForWithdrawImpl private function, the secondTokenShare variable is defined as _ONE - firstTokenShare. On the very next line, the exact same subtraction is performed again when it could simply use the secondTokenShare variable.", "body": "Within the _getRealAmountsForWithdrawImpl private function, the secondTokenShare variable is defined as _ONE - firstTokenShare. On the very next line, the exact same subtraction is performed again when it could simply use the secondTokenShare variable.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#within-the-_getrealamountsforwithdrawimpl-private-function,-the-secondtokenshare-variable-is-defined-as-_one---firsttokenshare.-on-the-very-next-line,-the-exact-same-subtraction-is-performed-again-when-it-could-simply-use-the-secondtokenshare-variable.", "labels": ["OpenZeppelin"]}, {"title": "To reduce gas costs and further simplify the codebase, consider addressing the instances raised above.", "body": "To reduce gas costs and further simplify the codebase, consider addressing the instances raised above.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#to-reduce-gas-costs-and-further-simplify-the-codebase,-consider-addressing-the-instances-raised-above.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 34974ee.", "body": "Update: Fixed in commit 34974ee.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#update:-fixed-in-commit-34974ee.", "labels": ["OpenZeppelin"]}, {"title": "[N09] Incorrect function visibility", "body": "[N09] Incorrect function visibility", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#[n09]-incorrect-function-visibility", "labels": ["OpenZeppelin"]}, {"title": "The withdrawWithRatio function is not called internally by any of the functions in the FixedRateSwap contract. Consider setting the visibility to external instead of public.", "body": "The withdrawWithRatio function is not called internally by any of the functions in the FixedRateSwap contract. Consider setting the visibility to external instead of public.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#the-withdrawwithratio-function-is-not-called-internally-by-any-of-the-functions-in-the-fixedrateswap-contract.-consider-setting-the-visibility-to-external-instead-of-public.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit cb852f5.", "body": "Update: Fixed in commit cb852f5.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#update:-fixed-in-commit-cb852f5.", "labels": ["OpenZeppelin"]}, {"title": "[N10] Reliance on matching decimals may be problematic", "body": "[N10] Reliance on matching decimals may be problematic", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#[n10]-reliance-on-matching-decimals-may-be-problematic", "labels": ["OpenZeppelin"]}, {"title": "The protocol implicitly requires that both tokens inside of a pool support the decimals method for pool construction to be successful. In reality, this method is almost ubiquitous, but it is, technically, an optional component of the ERC20 specification wherein it is explicitly stated that contracts \u201cMUST NOT expect these values to be present\u201d. Currently, any tokens that do not support the optional decimals method will not be usable within the protocol.", "body": "The protocol implicitly requires that both tokens inside of a pool support the decimals method for pool construction to be successful. In reality, this method is almost ubiquitous, but it is, technically, an optional component of the ERC20 specification wherein it is explicitly stated that contracts \u201cMUST NOT expect these values to be present\u201d. Currently, any tokens that do not support the optional decimals method will not be usable within the protocol.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#the-protocol-implicitly-requires-that-both-tokens-inside-of-a-pool-support-the-decimals-method-for-pool-construction-to-be-successful.-in-reality,-this-method-is-almost-ubiquitous,-but-it-is,-technically,-an-optional-component-of-the-erc20-specification-wherein-it-is-explicitly-stated-that-contracts-\u201cmust-not-expect-these-values-to-be-present\u201d.-currently,-any-tokens-that-do-not-support-the-optional-decimals-method-will-not-be-usable-within-the-protocol.", "labels": ["OpenZeppelin"]}, {"title": "Perhaps more problematically, as part of these calls to token decimals, the protocol further requires that both tokens return identical values.", "body": "Perhaps more problematically, as part of these calls to token decimals, the protocol further requires that both tokens return identical values.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#perhaps-more-problematically,-as-part-of-these-calls-to-token-decimals,-the-protocol-further-requires-that-both-tokens-return-identical-values.", "labels": ["OpenZeppelin"]}, {"title": "However, the stable coin token space is not homogeneous in this regard. It is comprised of many tokens that return a variety of different values for decimals. For instance, while USDT and USDC report 6 decimals, DAI reports 18 decimals.", "body": "However, the stable coin token space is not homogeneous in this regard. It is comprised of many tokens that return a variety of different values for decimals. For instance, while USDT and USDC report 6 decimals, DAI reports 18 decimals.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#however,-the-stable-coin-token-space-is-not-homogeneous-in-this-regard.-it-is-comprised-of-many-tokens-that-return-a-variety-of-different-values-for-decimals.-for-instance,-while-usdt-and-usdc-report-6-decimals,-dai-reports-18-decimals.", "labels": ["OpenZeppelin"]}, {"title": "If these are intentional limitations of the protocol, consider touching on them explicitly and providing short justifications via the inline documentation. Also consider providing better error messages at construction time for tokens that do not support the decimals method. Alternatively, consider making the protocol more robust, so that it can handle tokens that do not support the decimals method or pairs reporting disparate decimals within the same pool.", "body": "If these are intentional limitations of the protocol, consider touching on them explicitly and providing short justifications via the inline documentation. Also consider providing better error messages at construction time for tokens that do not support the decimals method. Alternatively, consider making the protocol more robust, so that it can handle tokens that do not support the decimals method or pairs reporting disparate decimals within the same pool.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#if-these-are-intentional-limitations-of-the-protocol,-consider-touching-on-them-explicitly-and-providing-short-justifications-via-the-inline-documentation.-also-consider-providing-better-error-messages-at-construction-time-for-tokens-that-do-not-support-the-decimals-method.-alternatively,-consider-making-the-protocol-more-robust,-so-that-it-can-handle-tokens-that-do-not-support-the-decimals-method-or-pairs-reporting-disparate-decimals-within-the-same-pool.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit b49d808. Inline documentation was added.", "body": "Update: Fixed in commit b49d808. Inline documentation was added.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#update:-fixed-in-commit-b49d808.-inline-documentation-was-added.", "labels": ["OpenZeppelin"]}, {"title": "[N11] Typographical error", "body": "[N11] Typographical error", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#[n11]-typographical-error", "labels": ["OpenZeppelin"]}, {"title": "We identified the following typographical error in the codebase:", "body": "We identified the following typographical error in the codebase:", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#we-identified-the-following-typographical-error-in-the-codebase:", "labels": ["OpenZeppelin"]}, {"title": "The revert message on line 92 of FixedRateSwap.sol starts without a capital letter, making it inconsistent with the rest of the code.", "body": "The revert message on line 92 of FixedRateSwap.sol starts without a capital letter, making it inconsistent with the rest of the code.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#the-revert-message-on-line-92-of-fixedrateswap.sol-starts-without-a-capital-letter,-making-it-inconsistent-with-the-rest-of-the-code.", "labels": ["OpenZeppelin"]}, {"title": "To improve the overall consistency and readability of the codebase, consider correcting this and any other typographical errors throughout the codebase.", "body": "To improve the overall consistency and readability of the codebase, consider correcting this and any other typographical errors throughout the codebase.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#to-improve-the-overall-consistency-and-readability-of-the-codebase,-consider-correcting-this-and-any-other-typographical-errors-throughout-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit a92d16a.", "body": "Update: Fixed in commit a92d16a.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#update:-fixed-in-commit-a92d16a.", "labels": ["OpenZeppelin"]}, {"title": "[N12] Unnecessarily virtual function", "body": "[N12] Unnecessarily virtual function", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#[n12]-unnecessarily-virtual-function", "labels": ["OpenZeppelin"]}, {"title": "The FixedRateSwap contract inherits from OpenZeppelin\u2019s ERC20 contract but it overrides its ERC20.decimals function. This is required because the FixedRateSwap\u2018s liquidity pool token, being dependent on the decimals of the assets that comprise the pool, is necessarily dynamic.", "body": "The FixedRateSwap contract inherits from OpenZeppelin\u2019s ERC20 contract but it overrides its ERC20.decimals function. This is required because the FixedRateSwap\u2018s liquidity pool token, being dependent on the decimals of the assets that comprise the pool, is necessarily dynamic.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#the-fixedrateswap-contract-inherits-from-openzeppelin\u2019s-erc20-contract-but-it-overrides-its-erc20.decimals-function.-this-is-required-because-the-fixedrateswap\u2018s-liquidity-pool-token,-being-dependent-on-the-decimals-of-the-assets-that-comprise-the-pool,-is-necessarily-dynamic.", "labels": ["OpenZeppelin"]}, {"title": "However, even though this overriding implementation of the function should be final, it is defined with the virtual keyword, signaling that it is not necessarily a final implementation and allowing for it to be overridden again.", "body": "However, even though this overriding implementation of the function should be final, it is defined with the virtual keyword, signaling that it is not necessarily a final implementation and allowing for it to be overridden again.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#however,-even-though-this-overriding-implementation-of-the-function-should-be-final,-it-is-defined-with-the-virtual-keyword,-signaling-that-it-is-not-necessarily-a-final-implementation-and-allowing-for-it-to-be-overridden-again.", "labels": ["OpenZeppelin"]}, {"title": "To avoid confusion and clarify intent, consider removing the virtual keyword or documenting the reasons for keeping it.", "body": "To avoid confusion and clarify intent, consider removing the virtual keyword or documenting the reasons for keeping it.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#to-avoid-confusion-and-clarify-intent,-consider-removing-the-virtual-keyword-or-documenting-the-reasons-for-keeping-it.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in commit 8bce5ec.", "body": "Update: Fixed in commit 8bce5ec.", "html_url": "https://blog.openzeppelin.com/1inch-fixed-rate-swap-audit#update:-fixed-in-commit-8bce5ec.", "labels": ["OpenZeppelin"]}, {"title": "[N01] Change bond token", "body": "[N01] Change bond token", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#[n01]-change-bond-token", "labels": ["OpenZeppelin"]}, {"title": "The Proposer contract includes a mechanism for the owner to change the size of the proposal bond. Consider whether they should also be able to change the bond token. Note that this would require a mechanism to identify the correct bond currency when existing proposals are resolved.", "body": "The Proposer contract includes a mechanism for the owner to change the size of the proposal bond. Consider whether they should also be able to change the bond token. Note that this would require a mechanism to identify the correct bond currency when existing proposals are resolved.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#the-proposer-contract-includes-a-mechanism-for-the-owner-to-change-the-size-of-the-proposal-bond.-consider-whether-they-should-also-be-able-to-change-the-bond-token.-note-that-this-would-require-a-mechanism-to-identify-the-correct-bond-currency-when-existing-proposals-are-resolved.", "labels": ["OpenZeppelin"]}, {"title": "Update: Not an issue. UMA\u2019s statement for this issue:", "body": "Update: Not an issue. UMA\u2019s statement for this issue:", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#update:-not-an-issue.-uma\u2019s-statement-for-this-issue:", "labels": ["OpenZeppelin"]}, {"title": "N01 recommends enabling the proposer contract to change the bond token to something other than UMA. We have no intention of supporting any token other than $UMA for this function and so have chosen to not make any changes for this issue. Moreover, a single token per contract keeps this logic as simple as possible. Lastly, If a change was needed (in the case of a token migration, for instance), we could just deploy a new proposer contract with the other token and initiate a proposal to migrate the system to use that one.", "body": "N01 recommends enabling the proposer contract to change the bond token to something other than UMA. We have no intention of supporting any token other than $UMA for this function and so have chosen to not make any changes for this issue. Moreover, a single token per contract keeps this logic as simple as possible. Lastly, If a change was needed (in the case of a token migration, for instance), we could just deploy a new proposer contract with the other token and initiate a proposal to migrate the system to use that one.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#n01-recommends-enabling-the-proposer-contract-to-change-the-bond-token-to-something-other-than-uma.-we-have-no-intention-of-supporting-any-token-other-than-$uma-for-this-function-and-so-have-chosen-to-not-make-any-changes-for-this-issue.-moreover,-a-single-token-per-contract-keeps-this-logic-as-simple-as-possible.-lastly,-if-a-change-was-needed-(in-the-case-of-a-token-migration,-for-instance),-we-could-just-deploy-a-new-proposer-contract-with-the-other-token-and-initiate-a-proposal-to-migrate-the-system-to-use-that-one.", "labels": ["OpenZeppelin"]}, {"title": "[N02] Incomplete interface", "body": "[N02] Incomplete interface", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#[n02]-incomplete-interface", "labels": ["OpenZeppelin"]}, {"title": "The ChildMessengerInterface does not specify a processMessageFromCrossChainParent function, even though it is assumed to exist by parent messengers. Consider including it for completeness.", "body": "The ChildMessengerInterface does not specify a processMessageFromCrossChainParent function, even though it is assumed to exist by parent messengers. Consider including it for completeness.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#the-childmessengerinterface-does-not-specify-a-processmessagefromcrosschainparent-function,-even-though-it-is-assumed-to-exist-by-parent-messengers.-consider-including-it-for-completeness.", "labels": ["OpenZeppelin"]}, {"title": "Update: Not fixed. UMA\u2019s statement for this issue:", "body": "Update: Not fixed. UMA\u2019s statement for this issue:", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#update:-not-fixed.-uma\u2019s-statement-for-this-issue:", "labels": ["OpenZeppelin"]}, {"title": "We intentionally chose to leave this interface inconsistent as implementing this within the ChildMessengerInterface breaks compatibility with the Polygon_ChildMessenger as Polygon\u2019s method for processing messages from other chains requires somewhat custom logic wherein an internal method is called called _processMessageFromRoot.", "body": "We intentionally chose to leave this interface inconsistent as implementing this within the ChildMessengerInterface breaks compatibility with the Polygon_ChildMessenger as Polygon\u2019s method for processing messages from other chains requires somewhat custom logic wherein an internal method is called called _processMessageFromRoot.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#we-intentionally-chose-to-leave-this-interface-inconsistent-as-implementing-this-within-the-childmessengerinterface-breaks-compatibility-with-the-polygon_childmessenger-as-polygon\u2019s-method-for-processing-messages-from-other-chains-requires-somewhat-custom-logic-wherein-an-internal-method-is-called-called-_processmessagefromroot.", "labels": ["OpenZeppelin"]}, {"title": "[N03] Incorrect interface", "body": "[N03] Incorrect interface", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#[n03]-incorrect-interface", "labels": ["OpenZeppelin"]}, {"title": "The GovernorSpoke contract incorrectly uses the ChildMessengerConsumerInterface type to describe its messenger variable. Consider using the ChildMessengerInterface instead.", "body": "The GovernorSpoke contract incorrectly uses the ChildMessengerConsumerInterface type to describe its messenger variable. Consider using the ChildMessengerInterface instead.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#the-governorspoke-contract-incorrectly-uses-the-childmessengerconsumerinterface-type-to-describe-its-messenger-variable.-consider-using-the-childmessengerinterface-instead.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed as of commit f31a527 in PR3680.", "body": "Update: Fixed as of commit f31a527 in PR3680.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#update:-fixed-as-of-commit-f31a527-in-pr3680.", "labels": ["OpenZeppelin"]}, {"title": "[N04] Pull tokens to Store", "body": "[N04] Pull tokens to Store", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#[n04]-pull-tokens-to-store", "labels": ["OpenZeppelin"]}, {"title": "previous audit we questioned the purpose of the", "body": "previous audit we questioned the purpose of the", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#previous-audit-we-questioned-the-purpose-of-the", "labels": ["OpenZeppelin"]}, {"title": "payOracleFeesErc20 function (in issue L19). The UMA team", "body": "payOracleFeesErc20 function (in issue L19). The UMA team", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#payoraclefeeserc20-function-(in-issue-l19).-the-uma-team", "labels": ["OpenZeppelin"]}, {"title": "opted to keep the function to standardized the interface for potential future modifications. Since the purpose of the function is not fully specified, it is unclear whether it should be triggered when the", "body": "opted to keep the function to standardized the interface for potential future modifications. Since the purpose of the function is not fully specified, it is unclear whether it should be triggered when the", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#opted-to-keep-the-function-to-standardized-the-interface-for-potential-future-modifications.-since-the-purpose-of-the-function-is-not-fully-specified,-it-is-unclear-whether-it-should-be-triggered-when-the", "labels": ["OpenZeppelin"]}, {"title": "confiscates a bond. It likely should be used when the", "body": "confiscates a bond. It likely should be used when the", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#confiscates-a-bond.-it-likely-should-be-used-when-the", "labels": ["OpenZeppelin"]}, {"title": "pays for a price request. Consider whether the function should be used in either scenario.", "body": "pays for a price request. Consider whether the function should be used in either scenario.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#pays-for-a-price-request.-consider-whether-the-function-should-be-used-in-either-scenario.", "labels": ["OpenZeppelin"]}, {"title": "Update: Acknowledged. UMA\u2019s statement for this issue:", "body": "Update: Acknowledged. UMA\u2019s statement for this issue:", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#update:-acknowledged.-uma\u2019s-statement-for-this-issue:", "labels": ["OpenZeppelin"]}, {"title": "N04 recommends using the Store\u2019s payOracleFeeErc20 method for paying fees in both the Proposer and OracleHub contracts to be consistent with the Store usage. We\u2019ve opted to not use this function as it would mean needing to import an additional interface (for the store) and require casting of the bond amount to a FixedPoint (which would also require an additional import. To keep the code simple and clean we\u2019ve opted to not do this. The OZ feedback on payOracleFeeErc20 in audit phase 1 in April 2020 was valid that this method is not really useful, making this kind of integration harder to reason about.", "body": "N04 recommends using the Store\u2019s payOracleFeeErc20 method for paying fees in both the Proposer and OracleHub contracts to be consistent with the Store usage. We\u2019ve opted to not use this function as it would mean needing to import an additional interface (for the store) and require casting of the bond amount to a FixedPoint (which would also require an additional import. To keep the code simple and clean we\u2019ve opted to not do this. The OZ feedback on payOracleFeeErc20 in audit phase 1 in April 2020 was valid that this method is not really useful, making this kind of integration harder to reason about.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#n04-recommends-using-the-store\u2019s-payoraclefeeerc20-method-for-paying-fees-in-both-the-proposer-and-oraclehub-contracts-to-be-consistent-with-the-store-usage.-we\u2019ve-opted-to-not-use-this-function-as-it-would-mean-needing-to-import-an-additional-interface-(for-the-store)-and-require-casting-of-the-bond-amount-to-a-fixedpoint-(which-would-also-require-an-additional-import.-to-keep-the-code-simple-and-clean-we\u2019ve-opted-to-not-do-this.-the-oz-feedback-on-payoraclefeeerc20-in-audit-phase-1-in-april-2020-was-valid-that-this-method-is-not-really-useful,-making-this-kind-of-integration-harder-to-reason-about.", "labels": ["OpenZeppelin"]}, {"title": "[N05] TODOs in code", "body": "[N05] TODOs in code", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#[n05]-todos-in-code", "labels": ["OpenZeppelin"]}, {"title": "There are \u201cTODO\u201d comments in the code base that should be tracked in the project\u2019s issues backlog. For example:", "body": "There are \u201cTODO\u201d comments in the code base that should be tracked in the project\u2019s issues backlog. For example:", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#there-are-\u201ctodo\u201d-comments-in-the-code-base-that-should-be-tracked-in-the-project\u2019s-issues-backlog.-for-example:", "labels": ["OpenZeppelin"]}, {"title": "Line 37 of Arbitrum_ParentMessenger contract", "body": "Line 37 of Arbitrum_ParentMessenger contract", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#line-37-of-arbitrum_parentmessenger-contract", "labels": ["OpenZeppelin"]}, {"title": "Line 25 of Optimism_ChildMessenger contract", "body": "Line 25 of Optimism_ChildMessenger contract", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#line-25-of-optimism_childmessenger-contract", "labels": ["OpenZeppelin"]}, {"title": "Lines 83 and 146 of OracleHub contract.", "body": "Lines 83 and 146 of OracleHub contract.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#lines-83-and-146-of-oraclehub-contract.", "labels": ["OpenZeppelin"]}, {"title": "During development, having well described \u201cTODO\u201d comments will make the process of tracking and solving them easier. Without that information, these comments might tend to rot and important information for the security of the system might be forgotten by the time it is released to production.", "body": "During development, having well described \u201cTODO\u201d comments will make the process of tracking and solving them easier. Without that information, these comments might tend to rot and important information for the security of the system might be forgotten by the time it is released to production.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#during-development,-having-well-described-\u201ctodo\u201d-comments-will-make-the-process-of-tracking-and-solving-them-easier.-without-that-information,-these-comments-might-tend-to-rot-and-important-information-for-the-security-of-the-system-might-be-forgotten-by-the-time-it-is-released-to-production.", "labels": ["OpenZeppelin"]}, {"title": "These TODO comments should have a brief description of the task pending to do, and a link to the corresponding issue in the project repository.", "body": "These TODO comments should have a brief description of the task pending to do, and a link to the corresponding issue in the project repository.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#these-todo-comments-should-have-a-brief-description-of-the-task-pending-to-do,-and-a-link-to-the-corresponding-issue-in-the-project-repository.", "labels": ["OpenZeppelin"]}, {"title": "Consider updating the TODO comments to add this information. For completeness and traceability, a signature and a timestamp can be added. For example:", "body": "Consider updating the TODO comments to add this information. For completeness and traceability, a signature and a timestamp can be added. For example:", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#consider-updating-the-todo-comments-to-add-this-information.-for-completeness-and-traceability,-a-signature-and-a-timestamp-can-be-added.-for-example:", "labels": ["OpenZeppelin"]}, {"title": "// TODO: point this at an interface instead.", "body": "// TODO: point this at an interface instead.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#//-todo:-point-this-at-an-interface-instead.", "labels": ["OpenZeppelin"]}, {"title": "// https://github.com/UMAprotocol/protocol/issues/XXXX", "body": "// https://github.com/UMAprotocol/protocol/issues/XXXX", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#//-https://github.com/umaprotocol/protocol/issues/xxxx", "labels": ["OpenZeppelin"]}, {"title": "// --mrice32 - 20211209", "body": "// --mrice32 - 20211209", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#//---mrice32---20211209", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed as of commit 5d57b5b in PR3684.", "body": "Update: Fixed as of commit 5d57b5b in PR3684.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#update:-fixed-as-of-commit-5d57b5b-in-pr3684.", "labels": ["OpenZeppelin"]}, {"title": "[N06] Typographical errors", "body": "[N06] Typographical errors", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#[n06]-typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "The codebase contains the following typographical errors:", "body": "The codebase contains the following typographical errors:", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#the-codebase-contains-the-following-typographical-errors:", "labels": ["OpenZeppelin"]}, {"title": "In the Admin_ChildMessenger contract, impleenting should be implementing", "body": "In the Admin_ChildMessenger contract, impleenting should be implementing", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#in-the-admin_childmessenger-contract,-impleenting-should-be-implementing", "labels": ["OpenZeppelin"]}, {"title": "In the OptimisticRewarderBase contract, timestap should be timestamp.", "body": "In the OptimisticRewarderBase contract, timestap should be timestamp.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#in-the-optimisticrewarderbase-contract,-timestap-should-be-timestamp.", "labels": ["OpenZeppelin"]}, {"title": "In the OptimisticRewarderBase contract, liveness liveness should be liveness.", "body": "In the OptimisticRewarderBase contract, liveness liveness should be liveness.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#in-the-optimisticrewarderbase-contract,-liveness-liveness-should-be-liveness.", "labels": ["OpenZeppelin"]}, {"title": "In the GovernorSpoke contract, only called should be only be called.", "body": "In the GovernorSpoke contract, only called should be only be called.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#in-the-governorspoke-contract,-only-called-should-be-only-be-called.", "labels": ["OpenZeppelin"]}, {"title": "In the Optimism_ChildMessenger contract:", "body": "In the Optimism_ChildMessenger contract:", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#in-the-optimism_childmessenger-contract:", "labels": ["OpenZeppelin"]}, {"title": "onlyCrossDomainAccount should be onlyFromCrossDomainAccount.", "body": "onlyCrossDomainAccount should be onlyFromCrossDomainAccount.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#onlycrossdomainaccount-should-be-onlyfromcrossdomainaccount.", "labels": ["OpenZeppelin"]}, {"title": "addresses on the L1 should be addresses on the L2", "body": "addresses on the L1 should be addresses on the L2", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#addresses-on-the-l1-should-be-addresses-on-the-l2", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed as of commit 9b92b0b in PR3681.", "body": "Update: Fixed as of commit 9b92b0b in PR3681.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#update:-fixed-as-of-commit-9b92b0b-in-pr3681.", "labels": ["OpenZeppelin"]}, {"title": "[N07] Unused imports", "body": "[N07] Unused imports", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#[n07]-unused-imports", "labels": ["OpenZeppelin"]}, {"title": "To improve readability of the code, consider removing the following unused imports:", "body": "To improve readability of the code, consider removing the following unused imports:", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#to-improve-readability-of-the-code,-consider-removing-the-following-unused-imports:", "labels": ["OpenZeppelin"]}, {"title": "The OptimisticRewarderToken contract imports unused OptimisticRewarder contract", "body": "The OptimisticRewarderToken contract imports unused OptimisticRewarder contract", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#the-optimisticrewardertoken-contract-imports-unused-optimisticrewarder-contract", "labels": ["OpenZeppelin"]}, {"title": "The OptimisticRewarderCreator contract imports unused ERC721 and Testable contracts", "body": "The OptimisticRewarderCreator contract imports unused ERC721 and Testable contracts", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#the-optimisticrewardercreator-contract-imports-unused-erc721-and-testable-contracts", "labels": ["OpenZeppelin"]}, {"title": "the OptimisticStaker contract imports usused OptimisticRewarder and OptimisticRewarderToken contracts", "body": "the OptimisticStaker contract imports usused OptimisticRewarder and OptimisticRewarderToken contracts", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#the-optimisticstaker-contract-imports-usused-optimisticrewarder-and-optimisticrewardertoken-contracts", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed as of commit 40b7221 in PR3682.", "body": "Update: Fixed as of commit 40b7221 in PR3682.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#update:-fixed-as-of-commit-40b7221-in-pr3682.", "labels": ["OpenZeppelin"]}, {"title": "[N08] L2 transaction ordering", "body": "[N08] L2 transaction ordering", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#[n08]-l2-transaction-ordering", "labels": ["OpenZeppelin"]}, {"title": "The Governor ensures transactions within a proposal are executed in order. However, when those transactions involve cross-chain transactions, this merely guarantees that they arrive at the L1 bridge contract in the correct order. In the Arbitrum case, they may be reordered before they are finalized on L2. Therefore, governance proposals should be constructed to permit the possibility of reordered L2 transactions.", "body": "The Governor ensures transactions within a proposal are executed in order. However, when those transactions involve cross-chain transactions, this merely guarantees that they arrive at the L1 bridge contract in the correct order. In the Arbitrum case, they may be reordered before they are finalized on L2. Therefore, governance proposals should be constructed to permit the possibility of reordered L2 transactions.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#the-governor-ensures-transactions-within-a-proposal-are-executed-in-order.-however,-when-those-transactions-involve-cross-chain-transactions,-this-merely-guarantees-that-they-arrive-at-the-l1-bridge-contract-in-the-correct-order.-in-the-arbitrum-case,-they-may-be-reordered-before-they-are-finalized-on-l2.-therefore,-governance-proposals-should-be-constructed-to-permit-the-possibility-of-reordered-l2-transactions.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed as of commit 0fb2e7b in PR3703. The GovernorHub can now relay an array of L2 transactions.", "body": "Update: Fixed as of commit 0fb2e7b in PR3703. The GovernorHub can now relay an array of L2 transactions.", "html_url": "https://blog.openzeppelin.com/uma-audit-phase-6#update:-fixed-as-of-commit-0fb2e7b-in-pr3703.-the-governorhub-can-now-relay-an-array-of-l2-transactions.", "labels": ["OpenZeppelin"]}, {"title": "[N01] Not importing interfaces", "body": "[N01] Not importing interfaces", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n01]-not-importing-interfaces", "labels": ["OpenZeppelin"]}, {"title": "The AggregatorInterface interface appears to be a subset of code copied from ChainLink\u2018s public code repository. The full interface is included in ChainLink\u2018s contract npm package.", "body": "The AggregatorInterface interface appears to be a subset of code copied from ChainLink\u2018s public code repository. The full interface is included in ChainLink\u2018s contract npm package.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#the-aggregatorinterface-interface-appears-to-be-a-subset-of-code-copied-from-chainlink\u2018s-public-code-repository.-the-full-interface-is-included-in-chainlink\u2018s-contract-npm-package.", "labels": ["OpenZeppelin"]}, {"title": "When possible, to lessen the potential for interface mismatches and resultant issues, rather than re-defining and/or rewriting another project\u2019s interfaces, consider using interfaces installed via their official npm packages instead.", "body": "When possible, to lessen the potential for interface mismatches and resultant issues, rather than re-defining and/or rewriting another project\u2019s interfaces, consider using interfaces installed via their official npm packages instead.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#when-possible,-to-lessen-the-potential-for-interface-mismatches-and-resultant-issues,-rather-than-re-defining-and/or-rewriting-another-project\u2019s-interfaces,-consider-using-interfaces-installed-via-their-official-npm-packages-instead.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #66.", "body": "Update: Fixed in pull request #66.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#update:-fixed-in-pull-request-#66.", "labels": ["OpenZeppelin"]}, {"title": "[N02] Deprecated project dependencies", "body": "[N02] Deprecated project dependencies", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n02]-deprecated-project-dependencies", "labels": ["OpenZeppelin"]}, {"title": "During the installation of the project\u2019s dependencies, NPM warns that one of the packages installed, Highlight, \u201cwill no longer be supported or receive security updates in the future\u201d.", "body": "During the installation of the project\u2019s dependencies, NPM warns that one of the packages installed, Highlight, \u201cwill no longer be supported or receive security updates in the future\u201d.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#during-the-installation-of-the-project\u2019s-dependencies,-npm-warns-that-one-of-the-packages-installed,-highlight,-\u201cwill-no-longer-be-supported-or-receive-security-updates-in-the-future\u201d.", "labels": ["OpenZeppelin"]}, {"title": "Even though it is unlikely that this package could cause a security risk, consider upgrading the dependency that uses this package to a maintained version.", "body": "Even though it is unlikely that this package could cause a security risk, consider upgrading the dependency that uses this package to a maintained version.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#even-though-it-is-unlikely-that-this-package-could-cause-a-security-risk,-consider-upgrading-the-dependency-that-uses-this-package-to-a-maintained-version.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #64.", "body": "Update: Fixed in pull request #64.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#update:-fixed-in-pull-request-#64.", "labels": ["OpenZeppelin"]}, {"title": "[N03] External calls to view methods are not staticcalls", "body": "[N03] External calls to view methods are not staticcalls", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n03]-external-calls-to-view-methods-are-not-staticcalls", "labels": ["OpenZeppelin"]}, {"title": "ChainlinkCalculator contract, despite the intention of making external calls only to", "body": "ChainlinkCalculator contract, despite the intention of making external calls only to", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#chainlinkcalculator-contract,-despite-the-intention-of-making-external-calls-only-to", "labels": ["OpenZeppelin"]}, {"title": "singlePrice and", "body": "doublePrice functions are not made via explicit  While we did not identify any immediate security concerns stemming from this, to reduce the attack surface, improve consistency, and clarify intent, consider using explicit staticcalls, for all external calls to view functions in the ChainlinkCalculator contract.  Update: Not fixed. The 1inch team states:  We think that syntax complication nullifies improvements in consistency.  [N04] Not failing early with invalid orders  In the OrderMixin contract, the fillOrderTo function handles the special condition when an order has not been previously submitted (remainingMakerAmount == 0), but it does not explicitly handle the condition when the order is no longer valid (remainingMakerAmount == 1).  In the latter scenario, the function will eventually revert, but only after burning non-trivial amounts of gas. To clarify intent, increase readability, and reduce gas usage, consider explicitly handling the invalid-order scenario towards the beginning of the function.  Update: Fixed in pull request #68.  [N05] Helper contracts not marked as abstract  In Solidity, the keyword abstract is used for contracts that are either not functional contracts in their own right, or are not meant to be used as such. Instead, abstract contracts are inherited by other contracts in the system to create stand-alone functional contracts.  Throughout the codebase, there are examples of helper contracts that are not marked as abstract, despite the fact that they are not meant to be deployed on their own. For instance, the AmountCalculator, ChainlinkCalculator, ImmutableOwner, NonceManager, and PredicateHelper contracts are all comprised of a base set of functions which are intended to be used by inheriting contracts.  Consider marking helper contracts as abstract to clearly signify that they are designed solely to add functionality to contracts that inherit them.  Update: Not fixed. The 1inch team states:  Those helpers can be deployed separately. They are inherited only for gas savings.  [N06] Inconsistent function ordering  recommended order in the Solidity Style Guide, which is:  However, in the the OrderMixin contract, the public checkPredicate function deviates from the style guide, bisecting the external functions.  To improve the projects overall legibility, consider standardizing function ordering throughout the codebase, as recommended by the Solidity Style Guide.  Update: Fixed in pull request #69.  [N07] Inconsistent order fill flow  The OrderMixin and RFQOrderMixin contracts both handle the filling of signed orders, but the general order flow between the two contracts is inconsistent.  OrderMixins fillOrderTo function follows this general flow (pseudo-code):  Whereas RFQOrderMixins analogous fillOrderRFQTo function follows this flow (pseudo-code):  To clarify intent and increase the overall readability of the code, consider either standardizing the general order flow across these two contracts, or explicitly documenting why the differences exist.  Update: Not fixed. The 1inch team states:  This is due to custom pricing functions in limit orders. Since getMakerAmount can potentially substantially differ from getTakerAmount, we thought that it is better not to make default option for the taker as itll probably confuse them in cases when those getters will be different.  [N08] Error messages are inconsistently formatted or misleading  Throughout the codebase, the require and revert error messages, which are meant to notify users of the particular conditions causing a transaction to fail, were found to be inconsistently formatted.  For instance, each one of the error messages on lines 85 of OrderMixin.sol, 16 of ERC721ProxySafe.sol, and 26 of Permitable.sol employ a different style.  Additionally, some error messages are misleading:  LOP: one of amounts should be 0 should be at least one of the amounts should be 0, since either or both amounts can be zero.  LOP: only one amount should be 0 should be LOP: one, and only one, amount should be 0.  Error messages are intended to notify users about failing conditions, so they should provide enough information so that appropriate corrections can be made to interact with the system. Uninformative error messages greatly damage the overall user experience, thus lowering the systems quality. Moreover, inconsistently formatted error messages can introduce unnecessary confusion. Therefore, consider reviewing the entire codebase to make sure every require and revert statement has an error message that is consistently formatted, accurate, informative, and user-friendly.  Update: Partially fixed in pull request #81.  [N09] Inconsistent use of named return variables  There is an inconsistent use of named return variables in the OrderMixin contract. Some functions return named variables, others return explicit values, and others declare a named return variable but override it with an explicit return statement.  Consider adopting a consistent approach to return values throughout the codebase by removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This would improve both the explicitness and readability of the code, and it may also help reduce regressions during future code refactors.  Update: Fixed in pull request #73.  [N10] Orders hash calculation is not open to the API  The external functions remaining, remainingRaw and remainingsRaw all expect an order hash for successful operation.  However, the helper function _hash, which returns the hash of an order, has private visibility. This means that users will have to pack parts of the orders and domain strings manually in order to obtain the hash of an order.  To avoid the potential for mistakes when calculating order hashes and to provide users with a method for generating an orders respective hash, consider extending the visibility of the _hash function to public and refactoring the name to hash to be consistent with the rest of the code.  Update: Fixed in pull request #74.  [N11] Semantic overloading of mapping  The _remaining mapping in the OrderMixin contract is semantically overloaded to track the status of orders and the remaining amount of assets available for those orders.  The three states that it can take on are:  0: The order hash has not been seen yet.  1: The order has been either canceled or completely filled.  Any uint larger than 1: The remaining makerAmount available to be filled on the order plus 1.  This semantic overloading requires wrapping and unwrapping of this value during lookup, cancellation, initialization, and storage.  Semantic overloading and the necessary logic to enable it can be prone to error and can make the codebase harder to understand and reason about, it may also open the door for regressions in future updates to the code.  To improve the codes readability, consider tracking the completion state of orders in a separate mapping.  Update: Not fixed. The 1inch team cited that a fix would increase gas costs for the fillOrder function.  [N12] Orders with permit allow calls to arbitrary contracts  The OrderMixin contract inherits the Permitable contract to allow for single-transaction order filling with assets that accept such permit calls to modify allowances.  However, the calls to the Permitable contract do not validate whether the target is a permitable asset nor if it is even an asset, which could allow a malicious user to pass the address of an arbitrary contract which could execute another call before the order fill completes.  Although the contract is protected against reentrancy, reducing the attack surface and preventing the calling of external contracts during execution is always recommended. Consider either restricting the asset involved in the permit to the assets involved in the order or to an assets whitelist for the protocol.  Update: Not fixed. The 1inch team states:  OrderMixin does not actually have info about actual tokens as makerAsset and takerAsset sometimes are proxies or other intermediate contracts and info about actual tokens is stored in some arbitrary bytes. So there is no viable way to restrict which asset permit is called on.  [N13] solhint is never re-enabled  Throughout the codebase, there are a couple of solhint-disable statements, specifically those on line 23 and on line 41 of RevertReasonParser.sol, that are not terminated with solhint-enable.  In favor of explicitness and to be as restrictive as possible when disabling solhint, consider using solhint-disable-line or solhint-disable-next-line instead, similar to line 16 of the same file.  Update: Fixed in pull request #72.  [N14] Typos  The codebase contains the following typos:  On line 18 of OrderMixin.sol and line 11 of OrderRFQMixin.sol, v1 should be v2.  On lines 147, 165, and 188 of OrderMixin.sol, it's should be if it's.  Additionally the projects README (out of scope for this audit) contains the following typos:  Ket should be Key.  stategies should be strategies.  cancelation should be cancellation.  Consider correcting these typos to improve code readability.  Update: Fixed in pull request #71 and pull request #77.  [N15] Use of uint instead of uint256  98 and  119 of  OrderMixin.sol and lines  16 and  30 of  PredicateHelper.sol.  Update: Fixed in pull request #70.  Conclusions  3 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#singleprice-and", "labels": ["OpenZeppelin"]}, {"title": "doublePrice functions are not made via explicit", "body": "doublePrice functions are not made via explicit", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#doubleprice-functions-are-not-made-via-explicit", "labels": ["OpenZeppelin"]}, {"title": "While we did not identify any immediate security concerns stemming from this, to reduce the attack surface, improve consistency, and clarify intent, consider using explicit staticcalls, for all external calls to view functions in the ChainlinkCalculator contract.", "body": "While we did not identify any immediate security concerns stemming from this, to reduce the attack surface, improve consistency, and clarify intent, consider using explicit staticcalls, for all external calls to view functions in the ChainlinkCalculator contract.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#while-we-did-not-identify-any-immediate-security-concerns-stemming-from-this,-to-reduce-the-attack-surface,-improve-consistency,-and-clarify-intent,-consider-using-explicit-staticcalls,-for-all-external-calls-to-view-functions-in-the-chainlinkcalculator-contract.", "labels": ["OpenZeppelin"]}, {"title": "Update: Not fixed. The 1inch team states:", "body": "We handle that on our backend and well think about the ways to notify possible takers about the issue.  [L12] Rounding can be unfavorable for taker  In the OrderMixin and OrderRFQMixin contracts, when an order is being filled and the taker provides only a makingAmount or takingAmount amount, the protocol attempts to calculate the counterpart amount of the swap.  There are two issues with these calculations, the first being that there is no documentation or logic limiting the number of decimals that the amount parameters should use, which we addressed in the Undocumented decimal assumptions issue.The second issue is that, in the course of these calculations, the protocol rounds in the favor of the maker. The rounding issue can be greatly exacerbated when the implicit decimal assumptions are broken, but even when everything is in the expected terms, rounding will occur with small, odd amounts.  Consider allowing the taker to specify a minimum amount of makerAsset asset that they are willing to receive together with a maximum amount of takerAsset asset they are willing to swap, so that the acceptance of any rounding is more explicit.    Threshold amount should be enough for takers protection.  [L13] Contradictory order handling when lacking parameters  OrderMixin contract, the  fillOrderTo function makes internal calls to the  _callGetMakerAmount and  _callGetTakerAmount functions whenever a fill is attempted and either the  makingAmount or the  takingAmount parameters are zero, respectively, or if the  makingAmount value is larger than the remainingMakerAmount value.  The _callGetMakerAmount and _callGetTakerAmount calls will lead to reversions if the order was not created with the getMakerAmount or getTakerAmount parameters, respectively, and a partial fill is being executed.  An inline comment alongside _callGetMakerAmount and an inline comment alongside _callGetTakerAmount claim that only whole fills are allowed if the order was not created with getMakerAmount or getTakerAmount parameters.  However, there are code paths for which this does not apply, because those paths do not check the lengths of both getMakerAmount and getTakerAmount parameters.  Specifically, when a taker specifies a takerAmount value for an order which only has a getMakerAmount, unless that call to getMakerAmount returns an amount larger than remainingMakerAmount, a partial fill can be executed in contradiction to the inline documentation.  This leaves the intentionality of those code paths unclear. If this is the expected behavior, consider modifying the inline documentation so that it is more explicit. If this is unintentional behavior, consider always checking the lengths of both the getMakerAmount and the getTakerAmount parameters simultaneously so that the implementation reinforces the behavior described by the inline documentation.  Update: Fixed in pull request #79.  [L14] Using deprecated Chainlink calls  The ChainlinkCalculator contract is intended to be used to query Chainlink oracles. It does so via making calls to their latestTimestamp and latestAnswer methods, both of which have been deprecated. In fact, the methods are no longer present in the API of Chainlink aggregators as of version three.  To avoid potential future incompatibilities with Chainlink oracles, consider using the latestRoundData method instead.  Update: Fixed in pull request #67.  Notes & Additional Information  [N01] Not importing interfaces  The AggregatorInterface interface appears to be a subset of code copied from ChainLinks public code repository. The full interface is included in ChainLinks contract npm package.  When possible, to lessen the potential for interface mismatches and resultant issues, rather than re-defining and/or rewriting another projects interfaces, consider using interfaces installed via their official npm packages instead.  Update: Fixed in pull request #66.  [N02] Deprecated project dependencies  During the installation of the projects dependencies, NPM warns that one of the packages installed, Highlight, will no longer be supported or receive security updates in the future.  Even though it is unlikely that this package could cause a security risk, consider upgrading the dependency that uses this package to a maintained version.  Update: Fixed in pull request #64.  [N03] External calls to view methods are not staticcalls  ChainlinkCalculator contract, despite the intention of making external calls only to  singlePrice and  doublePrice functions are not made via explicit  While we did not identify any immediate security concerns stemming from this, to reduce the attack surface, improve consistency, and clarify intent, consider using explicit staticcalls, for all external calls to view functions in the ChainlinkCalculator contract.    We think that syntax complication nullifies improvements in consistency.  [N04] Not failing early with invalid orders  In the OrderMixin contract, the fillOrderTo function handles the special condition when an order has not been previously submitted (remainingMakerAmount == 0), but it does not explicitly handle the condition when the order is no longer valid (remainingMakerAmount == 1).  In the latter scenario, the function will eventually revert, but only after burning non-trivial amounts of gas. To clarify intent, increase readability, and reduce gas usage, consider explicitly handling the invalid-order scenario towards the beginning of the function.  Update: Fixed in pull request #68.  [N05] Helper contracts not marked as abstract  In Solidity, the keyword abstract is used for contracts that are either not functional contracts in their own right, or are not meant to be used as such. Instead, abstract contracts are inherited by other contracts in the system to create stand-alone functional contracts.  Throughout the codebase, there are examples of helper contracts that are not marked as abstract, despite the fact that they are not meant to be deployed on their own. For instance, the AmountCalculator, ChainlinkCalculator, ImmutableOwner, NonceManager, and PredicateHelper contracts are all comprised of a base set of functions which are intended to be used by inheriting contracts.  Consider marking helper contracts as abstract to clearly signify that they are designed solely to add functionality to contracts that inherit them.    Those helpers can be deployed separately. They are inherited only for gas savings.  [N06] Inconsistent function ordering  recommended order in the Solidity Style Guide, which is:  However, in the the OrderMixin contract, the public checkPredicate function deviates from the style guide, bisecting the external functions.  To improve the projects overall legibility, consider standardizing function ordering throughout the codebase, as recommended by the Solidity Style Guide.  Update: Fixed in pull request #69.  [N07] Inconsistent order fill flow  The OrderMixin and RFQOrderMixin contracts both handle the filling of signed orders, but the general order flow between the two contracts is inconsistent.  OrderMixins fillOrderTo function follows this general flow (pseudo-code):  Whereas RFQOrderMixins analogous fillOrderRFQTo function follows this flow (pseudo-code):  To clarify intent and increase the overall readability of the code, consider either standardizing the general order flow across these two contracts, or explicitly documenting why the differences exist.    This is due to custom pricing functions in limit orders. Since getMakerAmount can potentially substantially differ from getTakerAmount, we thought that it is better not to make default option for the taker as itll probably confuse them in cases when those getters will be different.  [N08] Error messages are inconsistently formatted or misleading  Throughout the codebase, the require and revert error messages, which are meant to notify users of the particular conditions causing a transaction to fail, were found to be inconsistently formatted.  For instance, each one of the error messages on lines 85 of OrderMixin.sol, 16 of ERC721ProxySafe.sol, and 26 of Permitable.sol employ a different style.  Additionally, some error messages are misleading:  LOP: one of amounts should be 0 should be at least one of the amounts should be 0, since either or both amounts can be zero.  LOP: only one amount should be 0 should be LOP: one, and only one, amount should be 0.  Error messages are intended to notify users about failing conditions, so they should provide enough information so that appropriate corrections can be made to interact with the system. Uninformative error messages greatly damage the overall user experience, thus lowering the systems quality. Moreover, inconsistently formatted error messages can introduce unnecessary confusion. Therefore, consider reviewing the entire codebase to make sure every require and revert statement has an error message that is consistently formatted, accurate, informative, and user-friendly.  Update: Partially fixed in pull request #81.  [N09] Inconsistent use of named return variables  There is an inconsistent use of named return variables in the OrderMixin contract. Some functions return named variables, others return explicit values, and others declare a named return variable but override it with an explicit return statement.  Consider adopting a consistent approach to return values throughout the codebase by removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This would improve both the explicitness and readability of the code, and it may also help reduce regressions during future code refactors.  Update: Fixed in pull request #73.  [N10] Orders hash calculation is not open to the API  The external functions remaining, remainingRaw and remainingsRaw all expect an order hash for successful operation.  However, the helper function _hash, which returns the hash of an order, has private visibility. This means that users will have to pack parts of the orders and domain strings manually in order to obtain the hash of an order.  To avoid the potential for mistakes when calculating order hashes and to provide users with a method for generating an orders respective hash, consider extending the visibility of the _hash function to public and refactoring the name to hash to be consistent with the rest of the code.  Update: Fixed in pull request #74.  [N11] Semantic overloading of mapping  The _remaining mapping in the OrderMixin contract is semantically overloaded to track the status of orders and the remaining amount of assets available for those orders.  The three states that it can take on are:  0: The order hash has not been seen yet.  1: The order has been either canceled or completely filled.  Any uint larger than 1: The remaining makerAmount available to be filled on the order plus 1.  This semantic overloading requires wrapping and unwrapping of this value during lookup, cancellation, initialization, and storage.  Semantic overloading and the necessary logic to enable it can be prone to error and can make the codebase harder to understand and reason about, it may also open the door for regressions in future updates to the code.  To improve the codes readability, consider tracking the completion state of orders in a separate mapping.  Update: Not fixed. The 1inch team cited that a fix would increase gas costs for the fillOrder function.  [N12] Orders with permit allow calls to arbitrary contracts  The OrderMixin contract inherits the Permitable contract to allow for single-transaction order filling with assets that accept such permit calls to modify allowances.  However, the calls to the Permitable contract do not validate whether the target is a permitable asset nor if it is even an asset, which could allow a malicious user to pass the address of an arbitrary contract which could execute another call before the order fill completes.  Although the contract is protected against reentrancy, reducing the attack surface and preventing the calling of external contracts during execution is always recommended. Consider either restricting the asset involved in the permit to the assets involved in the order or to an assets whitelist for the protocol.    OrderMixin does not actually have info about actual tokens as makerAsset and takerAsset sometimes are proxies or other intermediate contracts and info about actual tokens is stored in some arbitrary bytes. So there is no viable way to restrict which asset permit is called on.  [N13] solhint is never re-enabled  Throughout the codebase, there are a couple of solhint-disable statements, specifically those on line 23 and on line 41 of RevertReasonParser.sol, that are not terminated with solhint-enable.  In favor of explicitness and to be as restrictive as possible when disabling solhint, consider using solhint-disable-line or solhint-disable-next-line instead, similar to line 16 of the same file.  Update: Fixed in pull request #72.  [N14] Typos  The codebase contains the following typos:  On line 18 of OrderMixin.sol and line 11 of OrderRFQMixin.sol, v1 should be v2.  On lines 147, 165, and 188 of OrderMixin.sol, it's should be if it's.  Additionally the projects README (out of scope for this audit) contains the following typos:  Ket should be Key.  stategies should be strategies.  cancelation should be cancellation.  Consider correcting these typos to improve code readability.  Update: Fixed in pull request #71 and pull request #77.  [N15] Use of uint instead of uint256  98 and  119 of  OrderMixin.sol and lines  16 and  30 of  PredicateHelper.sol.  Update: Fixed in pull request #70.  Conclusions  3 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#update:-not-fixed.-the-1inch-team-states:", "labels": ["OpenZeppelin"]}, {"title": "We think that syntax complication nullifies improvements in consistency.", "body": "We think that syntax complication nullifies improvements in consistency.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#we-think-that-syntax-complication-nullifies-improvements-in-consistency.", "labels": ["OpenZeppelin"]}, {"title": "[N04] Not failing early with invalid orders", "body": "[N04] Not failing early with invalid orders", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n04]-not-failing-early-with-invalid-orders", "labels": ["OpenZeppelin"]}, {"title": "In the OrderMixin contract, the fillOrderTo function handles the special condition when an order has not been previously submitted (remainingMakerAmount == 0), but it does not explicitly handle the condition when the order is no longer valid (remainingMakerAmount == 1).", "body": "In the OrderMixin contract, the fillOrderTo function handles the special condition when an order has not been previously submitted (remainingMakerAmount == 0), but it does not explicitly handle the condition when the order is no longer valid (remainingMakerAmount == 1).", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#in-the-ordermixin-contract,-the-fillorderto-function-handles-the-special-condition-when-an-order-has-not-been-previously-submitted-(remainingmakeramount-==-0),-but-it-does-not-explicitly-handle-the-condition-when-the-order-is-no-longer-valid-(remainingmakeramount-==-1).", "labels": ["OpenZeppelin"]}, {"title": "In the latter scenario, the function will eventually revert, but only after burning non-trivial amounts of gas. To clarify intent, increase readability, and reduce gas usage, consider explicitly handling the invalid-order scenario towards the beginning of the function.", "body": "In the latter scenario, the function will eventually revert, but only after burning non-trivial amounts of gas. To clarify intent, increase readability, and reduce gas usage, consider explicitly handling the invalid-order scenario towards the beginning of the function.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#in-the-latter-scenario,-the-function-will-eventually-revert,-but-only-after-burning-non-trivial-amounts-of-gas.-to-clarify-intent,-increase-readability,-and-reduce-gas-usage,-consider-explicitly-handling-the-invalid-order-scenario-towards-the-beginning-of-the-function.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #68.", "body": "Update: Fixed in pull request #68.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#update:-fixed-in-pull-request-#68.", "labels": ["OpenZeppelin"]}, {"title": "[N05] Helper contracts not marked as abstract", "body": "[N05] Helper contracts not marked as abstract", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n05]-helper-contracts-not-marked-as-abstract", "labels": ["OpenZeppelin"]}, {"title": "In Solidity, the keyword abstract is used for contracts that are either not functional contracts in their own right, or are not meant to be used as such. Instead, abstract contracts are inherited by other contracts in the system to create stand-alone functional contracts.", "body": "In Solidity, the keyword abstract is used for contracts that are either not functional contracts in their own right, or are not meant to be used as such. Instead, abstract contracts are inherited by other contracts in the system to create stand-alone functional contracts.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#in-solidity,-the-keyword-abstract-is-used-for-contracts-that-are-either-not-functional-contracts-in-their-own-right,-or-are-not-meant-to-be-used-as-such.-instead,-abstract-contracts-are-inherited-by-other-contracts-in-the-system-to-create-stand-alone-functional-contracts.", "labels": ["OpenZeppelin"]}, {"title": "Throughout the codebase, there are examples of helper contracts that are not marked as abstract, despite the fact that they are not meant to be deployed on their own. For instance, the AmountCalculator, ChainlinkCalculator, ImmutableOwner, NonceManager, and PredicateHelper contracts are all comprised of a base set of functions which are intended to be used by inheriting contracts.", "body": "Throughout the codebase, there are examples of helper contracts that are not marked as abstract, despite the fact that they are not meant to be deployed on their own. For instance, the AmountCalculator, ChainlinkCalculator, ImmutableOwner, NonceManager, and PredicateHelper contracts are all comprised of a base set of functions which are intended to be used by inheriting contracts.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#throughout-the-codebase,-there-are-examples-of-helper-contracts-that-are-not-marked-as-abstract,-despite-the-fact-that-they-are-not-meant-to-be-deployed-on-their-own.-for-instance,-the-amountcalculator,-chainlinkcalculator,-immutableowner,-noncemanager,-and-predicatehelper-contracts-are-all-comprised-of-a-base-set-of-functions-which-are-intended-to-be-used-by-inheriting-contracts.", "labels": ["OpenZeppelin"]}, {"title": "Consider marking helper contracts as abstract to clearly signify that they are designed solely to add functionality to contracts that inherit them.", "body": "Consider marking helper contracts as abstract to clearly signify that they are designed solely to add functionality to contracts that inherit them.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#consider-marking-helper-contracts-as-abstract-to-clearly-signify-that-they-are-designed-solely-to-add-functionality-to-contracts-that-inherit-them.", "labels": ["OpenZeppelin"]}, {"title": "Those helpers can be deployed separately. They are inherited only for gas savings.", "body": "Those helpers can be deployed separately. They are inherited only for gas savings.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#those-helpers-can-be-deployed-separately.-they-are-inherited-only-for-gas-savings.", "labels": ["OpenZeppelin"]}, {"title": "[N06] Inconsistent function ordering", "body": "[N06] Inconsistent function ordering", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n06]-inconsistent-function-ordering", "labels": ["OpenZeppelin"]}, {"title": "recommended order in the Solidity Style Guide, which is:", "body": "recommended order in the Solidity Style Guide, which is:", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#recommended-order-in-the-solidity-style-guide,-which-is:", "labels": ["OpenZeppelin"]}, {"title": "However, in the the OrderMixin contract, the public checkPredicate function deviates from the style guide, bisecting the external functions.", "body": "However, in the the OrderMixin contract, the public checkPredicate function deviates from the style guide, bisecting the external functions.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#however,-in-the-the-ordermixin-contract,-the-public-checkpredicate-function-deviates-from-the-style-guide,-bisecting-the-external-functions.", "labels": ["OpenZeppelin"]}, {"title": "To improve the project\u2019s overall legibility, consider standardizing function ordering throughout the codebase, as recommended by the Solidity Style Guide.", "body": "To improve the project\u2019s overall legibility, consider standardizing function ordering throughout the codebase, as recommended by the Solidity Style Guide.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#to-improve-the-project\u2019s-overall-legibility,-consider-standardizing-function-ordering-throughout-the-codebase,-as-recommended-by-the-solidity-style-guide.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #69.", "body": "Update: Fixed in pull request #69.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#update:-fixed-in-pull-request-#69.", "labels": ["OpenZeppelin"]}, {"title": "[N07] Inconsistent order fill flow", "body": "[N07] Inconsistent order fill flow", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n07]-inconsistent-order-fill-flow", "labels": ["OpenZeppelin"]}, {"title": "The OrderMixin and RFQOrderMixin contracts both handle the filling of signed orders, but the general order flow between the two contracts is inconsistent.", "body": "The OrderMixin and RFQOrderMixin contracts both handle the filling of signed orders, but the general order flow between the two contracts is inconsistent.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#the-ordermixin-and-rfqordermixin-contracts-both-handle-the-filling-of-signed-orders,-but-the-general-order-flow-between-the-two-contracts-is-inconsistent.", "labels": ["OpenZeppelin"]}, {"title": "OrderMixin\u2018s fillOrderTo function follows this general flow (pseudo-code):", "body": "OrderMixin\u2018s fillOrderTo function follows this general flow (pseudo-code):", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#ordermixin\u2018s-fillorderto-function-follows-this-general-flow-(pseudo-code):", "labels": ["OpenZeppelin"]}, {"title": "Whereas RFQOrderMixin\u2018s analogous fillOrderRFQTo function follows this flow (pseudo-code):", "body": "Whereas RFQOrderMixin\u2018s analogous fillOrderRFQTo function follows this flow (pseudo-code):", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#whereas-rfqordermixin\u2018s-analogous-fillorderrfqto-function-follows-this-flow-(pseudo-code):", "labels": ["OpenZeppelin"]}, {"title": "To clarify intent and increase the overall readability of the code, consider either standardizing the general order flow across these two contracts, or explicitly documenting why the differences exist.", "body": "To clarify intent and increase the overall readability of the code, consider either standardizing the general order flow across these two contracts, or explicitly documenting why the differences exist.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#to-clarify-intent-and-increase-the-overall-readability-of-the-code,-consider-either-standardizing-the-general-order-flow-across-these-two-contracts,-or-explicitly-documenting-why-the-differences-exist.", "labels": ["OpenZeppelin"]}, {"title": "This is due to custom pricing functions in limit orders. Since getMakerAmount can potentially substantially differ from getTakerAmount, we thought that it is better not to make default option for the taker as it\u2019ll probably confuse them in cases when those getters will be different.", "body": "This is due to custom pricing functions in limit orders. Since getMakerAmount can potentially substantially differ from getTakerAmount, we thought that it is better not to make default option for the taker as it\u2019ll probably confuse them in cases when those getters will be different.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#this-is-due-to-custom-pricing-functions-in-limit-orders.-since-getmakeramount-can-potentially-substantially-differ-from-gettakeramount,-we-thought-that-it-is-better-not-to-make-default-option-for-the-taker-as-it\u2019ll-probably-confuse-them-in-cases-when-those-getters-will-be-different.", "labels": ["OpenZeppelin"]}, {"title": "[N08] Error messages are inconsistently formatted or misleading", "body": "[N08] Error messages are inconsistently formatted or misleading", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n08]-error-messages-are-inconsistently-formatted-or-misleading", "labels": ["OpenZeppelin"]}, {"title": "Throughout the codebase, the require and revert error messages, which are meant to notify users of the particular conditions causing a transaction to fail, were found to be inconsistently formatted.", "body": "Throughout the codebase, the require and revert error messages, which are meant to notify users of the particular conditions causing a transaction to fail, were found to be inconsistently formatted.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#throughout-the-codebase,-the-require-and-revert-error-messages,-which-are-meant-to-notify-users-of-the-particular-conditions-causing-a-transaction-to-fail,-were-found-to-be-inconsistently-formatted.", "labels": ["OpenZeppelin"]}, {"title": "For instance, each one of the error messages on lines 85 of OrderMixin.sol, 16 of ERC721ProxySafe.sol, and 26 of Permitable.sol employ a different style.", "body": "For instance, each one of the error messages on lines 85 of OrderMixin.sol, 16 of ERC721ProxySafe.sol, and 26 of Permitable.sol employ a different style.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#for-instance,-each-one-of-the-error-messages-on-lines-85-of-ordermixin.sol,-16-of-erc721proxysafe.sol,-and-26-of-permitable.sol-employ-a-different-style.", "labels": ["OpenZeppelin"]}, {"title": "Additionally, some error messages are misleading:", "body": "Additionally, some error messages are misleading:", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#additionally,-some-error-messages-are-misleading:", "labels": ["OpenZeppelin"]}, {"title": "LOP: one of amounts should be 0 should be at least one of the amounts should be 0, since either or both amounts can be zero.", "body": "LOP: one of amounts should be 0 should be at least one of the amounts should be 0, since either or both amounts can be zero.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#lop:-one-of-amounts-should-be-0-should-be-at-least-one-of-the-amounts-should-be-0,-since-either-or-both-amounts-can-be-zero.", "labels": ["OpenZeppelin"]}, {"title": "LOP: only one amount should be 0 should be LOP: one, and only one, amount should be 0.", "body": "LOP: only one amount should be 0 should be LOP: one, and only one, amount should be 0.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#lop:-only-one-amount-should-be-0-should-be-lop:-one,-and-only-one,-amount-should-be-0.", "labels": ["OpenZeppelin"]}, {"title": "Error messages are intended to notify users about failing conditions, so they should provide enough information so that appropriate corrections can be made to interact with the system. Uninformative error messages greatly damage the overall user experience, thus lowering the system\u2019s quality. Moreover, inconsistently formatted error messages can introduce unnecessary confusion. Therefore, consider reviewing the entire codebase to make sure every require and revert statement has an error message that is consistently formatted, accurate, informative, and user-friendly.", "body": "Error messages are intended to notify users about failing conditions, so they should provide enough information so that appropriate corrections can be made to interact with the system. Uninformative error messages greatly damage the overall user experience, thus lowering the system\u2019s quality. Moreover, inconsistently formatted error messages can introduce unnecessary confusion. Therefore, consider reviewing the entire codebase to make sure every require and revert statement has an error message that is consistently formatted, accurate, informative, and user-friendly.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#error-messages-are-intended-to-notify-users-about-failing-conditions,-so-they-should-provide-enough-information-so-that-appropriate-corrections-can-be-made-to-interact-with-the-system.-uninformative-error-messages-greatly-damage-the-overall-user-experience,-thus-lowering-the-system\u2019s-quality.-moreover,-inconsistently-formatted-error-messages-can-introduce-unnecessary-confusion.-therefore,-consider-reviewing-the-entire-codebase-to-make-sure-every-require-and-revert-statement-has-an-error-message-that-is-consistently-formatted,-accurate,-informative,-and-user-friendly.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed in pull request #81.", "body": "Update: Partially fixed in pull request #81.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#update:-partially-fixed-in-pull-request-#81.", "labels": ["OpenZeppelin"]}, {"title": "[N09] Inconsistent use of named return variables", "body": "[N09] Inconsistent use of named return variables", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n09]-inconsistent-use-of-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "There is an inconsistent use of named return variables in the OrderMixin contract. Some functions return named variables, others return explicit values, and others declare a named return variable but override it with an explicit return statement.", "body": "There is an inconsistent use of named return variables in the OrderMixin contract. Some functions return named variables, others return explicit values, and others declare a named return variable but override it with an explicit return statement.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#there-is-an-inconsistent-use-of-named-return-variables-in-the-ordermixin-contract.-some-functions-return-named-variables,-others-return-explicit-values,-and-others-declare-a-named-return-variable-but-override-it-with-an-explicit-return-statement.", "labels": ["OpenZeppelin"]}, {"title": "Consider adopting a consistent approach to return values throughout the codebase by removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This would improve both the explicitness and readability of the code, and it may also help reduce regressions during future code refactors.", "body": "Consider adopting a consistent approach to return values throughout the codebase by removing all named return variables, explicitly declaring them as local variables, and adding the necessary return statements where appropriate. This would improve both the explicitness and readability of the code, and it may also help reduce regressions during future code refactors.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#consider-adopting-a-consistent-approach-to-return-values-throughout-the-codebase-by-removing-all-named-return-variables,-explicitly-declaring-them-as-local-variables,-and-adding-the-necessary-return-statements-where-appropriate.-this-would-improve-both-the-explicitness-and-readability-of-the-code,-and-it-may-also-help-reduce-regressions-during-future-code-refactors.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #73.", "body": "Update: Fixed in pull request #73.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#update:-fixed-in-pull-request-#73.", "labels": ["OpenZeppelin"]}, {"title": "[N10] Order\u2019s hash calculation is not open to the API", "body": "[N10] Order\u2019s hash calculation is not open to the API", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n10]-order\u2019s-hash-calculation-is-not-open-to-the-api", "labels": ["OpenZeppelin"]}, {"title": "The external functions remaining, remainingRaw and remainingsRaw all expect an order hash for successful operation.", "body": "The external functions remaining, remainingRaw and remainingsRaw all expect an order hash for successful operation.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#the-external-functions-remaining,-remainingraw-and-remainingsraw-all-expect-an-order-hash-for-successful-operation.", "labels": ["OpenZeppelin"]}, {"title": "However, the helper function _hash, which returns the hash of an order, has private visibility. This means that users will have to pack parts of the orders and domain strings manually in order to obtain the hash of an order.", "body": "However, the helper function _hash, which returns the hash of an order, has private visibility. This means that users will have to pack parts of the orders and domain strings manually in order to obtain the hash of an order.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#however,-the-helper-function-_hash,-which-returns-the-hash-of-an-order,-has-private-visibility.-this-means-that-users-will-have-to-pack-parts-of-the-orders-and-domain-strings-manually-in-order-to-obtain-the-hash-of-an-order.", "labels": ["OpenZeppelin"]}, {"title": "To avoid the potential for mistakes when calculating order hashes and to provide users with a method for generating an order\u2019s respective hash, consider extending the visibility of the _hash function to public and refactoring the name to hash to be consistent with the rest of the code.", "body": "To avoid the potential for mistakes when calculating order hashes and to provide users with a method for generating an order\u2019s respective hash, consider extending the visibility of the _hash function to public and refactoring the name to hash to be consistent with the rest of the code.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#to-avoid-the-potential-for-mistakes-when-calculating-order-hashes-and-to-provide-users-with-a-method-for-generating-an-order\u2019s-respective-hash,-consider-extending-the-visibility-of-the-_hash-function-to-public-and-refactoring-the-name-to-hash-to-be-consistent-with-the-rest-of-the-code.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #74.", "body": "Update: Fixed in pull request #74.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#update:-fixed-in-pull-request-#74.", "labels": ["OpenZeppelin"]}, {"title": "[N11] Semantic overloading of mapping", "body": "[N11] Semantic overloading of mapping", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n11]-semantic-overloading-of-mapping", "labels": ["OpenZeppelin"]}, {"title": "The _remaining mapping in the OrderMixin contract is semantically overloaded to track the status of orders and the remaining amount of assets available for those orders.", "body": "The _remaining mapping in the OrderMixin contract is semantically overloaded to track the status of orders and the remaining amount of assets available for those orders.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#the-_remaining-mapping-in-the-ordermixin-contract-is-semantically-overloaded-to-track-the-status-of-orders-and-the-remaining-amount-of-assets-available-for-those-orders.", "labels": ["OpenZeppelin"]}, {"title": "The three states that it can take on are:", "body": "The three states that it can take on are:", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#the-three-states-that-it-can-take-on-are:", "labels": ["OpenZeppelin"]}, {"title": "0: The order hash has not been seen yet.", "body": "0: The order hash has not been seen yet.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#0:-the-order-hash-has-not-been-seen-yet.", "labels": ["OpenZeppelin"]}, {"title": "1: The order has been either canceled or completely filled.", "body": "1: The order has been either canceled or completely filled.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#1:-the-order-has-been-either-canceled-or-completely-filled.", "labels": ["OpenZeppelin"]}, {"title": "Any uint larger than 1: The remaining makerAmount available to be filled on the order plus 1.", "body": "Any uint larger than 1: The remaining makerAmount available to be filled on the order plus 1.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#any-uint-larger-than-1:-the-remaining-makeramount-available-to-be-filled-on-the-order-plus-1.", "labels": ["OpenZeppelin"]}, {"title": "This semantic overloading requires wrapping and unwrapping of this value during lookup, cancellation, initialization, and storage.", "body": "This semantic overloading requires wrapping and unwrapping of this value during lookup, cancellation, initialization, and storage.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#this-semantic-overloading-requires-wrapping-and-unwrapping-of-this-value-during-lookup,-cancellation,-initialization,-and-storage.", "labels": ["OpenZeppelin"]}, {"title": "Semantic overloading and the necessary logic to enable it can be prone to error and can make the codebase harder to understand and reason about, it may also open the door for regressions in future updates to the code.", "body": "Semantic overloading and the necessary logic to enable it can be prone to error and can make the codebase harder to understand and reason about, it may also open the door for regressions in future updates to the code.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#semantic-overloading-and-the-necessary-logic-to-enable-it-can-be-prone-to-error-and-can-make-the-codebase-harder-to-understand-and-reason-about,-it-may-also-open-the-door-for-regressions-in-future-updates-to-the-code.", "labels": ["OpenZeppelin"]}, {"title": "To improve the code\u2019s readability, consider tracking the completion state of orders in a separate mapping.", "body": "To improve the code\u2019s readability, consider tracking the completion state of orders in a separate mapping.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#to-improve-the-code\u2019s-readability,-consider-tracking-the-completion-state-of-orders-in-a-separate-mapping.", "labels": ["OpenZeppelin"]}, {"title": "Update: Not fixed. The 1inch team cited that a fix would increase gas costs for the fillOrder function.", "body": "Update: Not fixed. The 1inch team cited that a fix would increase gas costs for the fillOrder function.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#update:-not-fixed.-the-1inch-team-cited-that-a-fix-would-increase-gas-costs-for-the-fillorder-function.", "labels": ["OpenZeppelin"]}, {"title": "[N12] Orders with permit allow calls to arbitrary contracts", "body": "[N12] Orders with permit allow calls to arbitrary contracts", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n12]-orders-with-permit-allow-calls-to-arbitrary-contracts", "labels": ["OpenZeppelin"]}, {"title": "The OrderMixin contract inherits the Permitable contract to allow for single-transaction order filling with assets that accept such permit calls to modify allowances.", "body": "The OrderMixin contract inherits the Permitable contract to allow for single-transaction order filling with assets that accept such permit calls to modify allowances.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#the-ordermixin-contract-inherits-the-permitable-contract-to-allow-for-single-transaction-order-filling-with-assets-that-accept-such-permit-calls-to-modify-allowances.", "labels": ["OpenZeppelin"]}, {"title": "However, the calls to the Permitable contract do not validate whether the target is a permitable asset nor if it is even an asset, which could allow a malicious user to pass the address of an arbitrary contract which could execute another call before the order fill completes.", "body": "However, the calls to the Permitable contract do not validate whether the target is a permitable asset nor if it is even an asset, which could allow a malicious user to pass the address of an arbitrary contract which could execute another call before the order fill completes.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#however,-the-calls-to-the-permitable-contract-do-not-validate-whether-the-target-is-a-permitable-asset-nor-if-it-is-even-an-asset,-which-could-allow-a-malicious-user-to-pass-the-address-of-an-arbitrary-contract-which-could-execute-another-call-before-the-order-fill-completes.", "labels": ["OpenZeppelin"]}, {"title": "Although the contract is protected against reentrancy, reducing the attack surface and preventing the calling of external contracts during execution is always recommended. Consider either restricting the asset involved in the permit to the assets involved in the order or to an assets whitelist for the protocol.", "body": "Although the contract is protected against reentrancy, reducing the attack surface and preventing the calling of external contracts during execution is always recommended. Consider either restricting the asset involved in the permit to the assets involved in the order or to an assets whitelist for the protocol.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#although-the-contract-is-protected-against-reentrancy,-reducing-the-attack-surface-and-preventing-the-calling-of-external-contracts-during-execution-is-always-recommended.-consider-either-restricting-the-asset-involved-in-the-permit-to-the-assets-involved-in-the-order-or-to-an-assets-whitelist-for-the-protocol.", "labels": ["OpenZeppelin"]}, {"title": "OrderMixin does not actually have info about actual tokens as makerAsset and takerAsset sometimes are proxies or other intermediate contracts and info about actual tokens is stored in some arbitrary bytes. So there is no viable way to restrict which asset permit is called on.", "body": "OrderMixin does not actually have info about actual tokens as makerAsset and takerAsset sometimes are proxies or other intermediate contracts and info about actual tokens is stored in some arbitrary bytes. So there is no viable way to restrict which asset permit is called on.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#ordermixin-does-not-actually-have-info-about-actual-tokens-as-makerasset-and-takerasset-sometimes-are-proxies-or-other-intermediate-contracts-and-info-about-actual-tokens-is-stored-in-some-arbitrary-bytes.-so-there-is-no-viable-way-to-restrict-which-asset-permit-is-called-on.", "labels": ["OpenZeppelin"]}, {"title": "[N13] solhint is never re-enabled", "body": "[N13] solhint is never re-enabled", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n13]-solhint-is-never-re-enabled", "labels": ["OpenZeppelin"]}, {"title": "Throughout the codebase, there are a couple of solhint-disable statements, specifically those on line 23 and on line 41 of RevertReasonParser.sol, that are not terminated with solhint-enable.", "body": "Throughout the codebase, there are a couple of solhint-disable statements, specifically those on line 23 and on line 41 of RevertReasonParser.sol, that are not terminated with solhint-enable.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#throughout-the-codebase,-there-are-a-couple-of-solhint-disable-statements,-specifically-those-on-line-23-and-on-line-41-of-revertreasonparser.sol,-that-are-not-terminated-with-solhint-enable.", "labels": ["OpenZeppelin"]}, {"title": "In favor of explicitness and to be as restrictive as possible when disabling solhint, consider using solhint-disable-line or solhint-disable-next-line instead, similar to line 16 of the same file.", "body": "In favor of explicitness and to be as restrictive as possible when disabling solhint, consider using solhint-disable-line or solhint-disable-next-line instead, similar to line 16 of the same file.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#in-favor-of-explicitness-and-to-be-as-restrictive-as-possible-when-disabling-solhint,-consider-using-solhint-disable-line-or-solhint-disable-next-line-instead,-similar-to-line-16-of-the-same-file.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #72.", "body": "Update: Fixed in pull request #72.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#update:-fixed-in-pull-request-#72.", "labels": ["OpenZeppelin"]}, {"title": "[N14] Typos", "body": "[N14] Typos", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n14]-typos", "labels": ["OpenZeppelin"]}, {"title": "The codebase contains the following typos:", "body": "The codebase contains the following typos:", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#the-codebase-contains-the-following-typos:", "labels": ["OpenZeppelin"]}, {"title": "On line 18 of OrderMixin.sol and line 11 of OrderRFQMixin.sol, v1 should be v2.", "body": "On line 18 of OrderMixin.sol and line 11 of OrderRFQMixin.sol, v1 should be v2.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#on-line-18-of-ordermixin.sol-and-line-11-of-orderrfqmixin.sol,-v1-should-be-v2.", "labels": ["OpenZeppelin"]}, {"title": "On lines 147, 165, and 188 of OrderMixin.sol, it's should be if it's.", "body": "On lines 147, 165, and 188 of OrderMixin.sol, it's should be if it's.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#on-lines-147,-165,-and-188-of-ordermixin.sol,-it's-should-be-if-it's.", "labels": ["OpenZeppelin"]}, {"title": "Additionally the project\u2019s README (out of scope for this audit) contains the following typos:", "body": "Additionally the project\u2019s README (out of scope for this audit) contains the following typos:", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#additionally-the-project\u2019s-readme-(out-of-scope-for-this-audit)-contains-the-following-typos:", "labels": ["OpenZeppelin"]}, {"title": "Ket should be Key.", "body": "Ket should be Key.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#ket-should-be-key.", "labels": ["OpenZeppelin"]}, {"title": "stategies should be strategies.", "body": "stategies should be strategies.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#stategies-should-be-strategies.", "labels": ["OpenZeppelin"]}, {"title": "cancelation should be cancellation.", "body": "cancelation should be cancellation.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#cancelation-should-be-cancellation.", "labels": ["OpenZeppelin"]}, {"title": "Consider correcting these typos to improve code readability.", "body": "Consider correcting these typos to improve code readability.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#consider-correcting-these-typos-to-improve-code-readability.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #71 and pull request #77.", "body": "Update: Fixed in pull request #71 and pull request #77.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#update:-fixed-in-pull-request-#71-and-pull-request-#77.", "labels": ["OpenZeppelin"]}, {"title": "[N15] Use of uint instead of uint256", "body": "[N15] Use of uint instead of uint256", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#[n15]-use-of-uint-instead-of-uint256", "labels": ["OpenZeppelin"]}, {"title": "98 and", "body": "98 and", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#98-and", "labels": ["OpenZeppelin"]}, {"title": "119 of", "body": "119 of", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#119-of", "labels": ["OpenZeppelin"]}, {"title": "OrderMixin.sol and lines", "body": "OrderMixin.sol and lines", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#ordermixin.sol-and-lines", "labels": ["OpenZeppelin"]}, {"title": "16 and", "body": "16 and", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#16-and", "labels": ["OpenZeppelin"]}, {"title": "30 of", "body": "30 of", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#30-of", "labels": ["OpenZeppelin"]}, {"title": "PredicateHelper.sol.", "body": "PredicateHelper.sol.", "html_url": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit#predicatehelper.sol.", "labels": ["OpenZeppelin"]}]