[{"title": "Unused Imports", "body": "There are imports that are unused:  Lines 5-7 of IGovernance.sol  Line 6 of Governance.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.", "html_url": "https://blog.openzeppelin.com/zksync-upgrade-system-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Magic Numbers", "body": "The bootloader no longer uses the L1_TX_TYPE function and instead hardcodes the priority and upgrade transaction types when validating transaction structures and processing transactions. To improve readability, consider using a named function for both L1 transaction types.", "html_url": "https://blog.openzeppelin.com/zksync-upgrade-system-audit#magic-numbers", "labels": ["OpenZeppelin"]}, {"title": "Misleading Error Message", "body": "The forceDeployOnAddresses access control error message is now incorrect, since it can be called by the ComplexUpgrader contract. Consider updating the error message accordingly.", "html_url": "https://blog.openzeppelin.com/zksync-upgrade-system-audit#misleading-error-message", "labels": ["OpenZeppelin"]}, {"title": "Missing Interface", "body": "In the interest of readability and consistency, consider updating the ComplexUpgrader contract to inherit from its interface.", "html_url": "https://blog.openzeppelin.com/zksync-upgrade-system-audit#missing-interface", "labels": ["OpenZeppelin"]}, {"title": "Missing Validation", "body": "The _commitBlockWithSystemContractsUpgrade function assumes there is at least one new block, but this is not enforced. Consider validating this property so it can fail with a descriptive error message.", "html_url": "https://blog.openzeppelin.com/zksync-upgrade-system-audit#missing-validation", "labels": ["OpenZeppelin"]}, {"title": "Previously Reported Issues", "body": "Previously Reported Issues", "html_url": "https://blog.openzeppelin.com/zksync-upgrade-system-audit#previously-reported-issues", "labels": ["OpenZeppelin"]}, {"title": "Recommendations", "body": "Monitoring   Conclusions  Summary  Rollup  From 2023-06-26  To 2023-06-30  Solidity  20 (0\u202fresolved)  0 (0\u202fresolved)  1 (0\u202fresolved)  4 (0\u202fresolved)  6 (0\u202fresolved)  9 (0\u202fresolved)  0 (0\u202fresolved)  Scope  We audited:  Pull request #272 of the matter-labs/system-contracts repository up to the 548a958e02f71a350e288c70e5523fbfb4ae0832 commit.  Pull request #143 of the matter-labs/zksync-2-contracts repository up to the 0ea939847569a02ae9c3b2d096aef5cb6238eb9d commit.  In scope were changes to the following contracts:  System Overview  The code under review introduces a new L2 transaction type to support upgrade transactions initiated on L1. These are equivalent to the existing L1 (ie. priority) transactions with two important differences.  Firstly, the L2 transaction must be included as soon as the upgrade is processed on L1, and it must be the first transaction in the block. There are some technicalities around handling block reversions but conceptually, it should be viewed as an immediate, forcing transaction.  Secondly, the mechanism that can be used to include an upgrade transaction in L2 is less restrictive than the Mailbox (which is used to include priority transactions). In particular, there is no restriction on the sender address or amount of ETH to mint, so it can be used to make arbitrary changes to the L2 contract code. Naturally, this should only be used for breaking changes to the system.  Security Model and Trust Assumptions  Privileged Roles  The main change to the security architecture is that the governor can no longer directly set the bootloader and default bytecode hashes, the allowlist address and the verifier configuration. Instead, these changes are mediated through the DefaultUpgrade contract, which enforces a time delay. This is part of the Matterlab team's progressive decentralization policy.  However, the upgrade also includes the ability to execute an arbitrary L2 transaction from any address, and this can be used to replace the code of any contract including system contracts. Although this is not meaningfully different than the existing administrator privileges (after all, replacing the bootloader is as powerful), it is worth noting the difference between making irregular transactions within the L2 and making changes to the L2 state transition function itself.  Testing Coverage   Several concerns regarding the testing of the current system were identified during the audit. While one of the findings contains a description of these concerns for the specific contracts within the scope of this audit, it is important to note the overall systematic risks here.  Insufficient testing, while not a specific vulnerability, implies the high probability of additional unfound vulnerabilities and bugs. It also exacerbates multiple interrelated risk factors in a complex codebase with novel functionality. This includes a lack of full implicit specification of the functionality and the expected behaviors that tests normally provide, which increases the chances that issues will be missed. It also requires more effort to establish basic correctness and reduces the effort spent exploring edge cases, thereby increasing the chances of missing complex issues.  Moreover, the lack of repeated automated testing of the full specification increases the chances of introducing breaking changes and new vulnerabilities. This applies to both previously audited code and future changes to currently audited code. This is particularly true in this project due to the pace, extent, and complexity of ongoing and planned changes across all parts of the stack (L1, L2, bootloader and system contracts, compiler and VM). Underspecified interfaces and assumptions increase the risk of subtle integration issues, which testing could reduce by enforcing an exhaustive specification.  To address these issues, we recommend implementing a comprehensive multi-level test suite before the next expected audits. Such a test suite should be comprised of contract-level tests with 95%-100% coverage, per-layer deployment and integration tests that test the deployment scripts as well as the system as a whole, per-layer fork tests for planned upgrades, and cross-chain full integration tests of the entire system. Crucially, the test suite should be documented in a way that a reviewer can set up and run all these test layers independently of the development team. Some existing examples of such setups can be used as references in a follow-up conversation. Implementing such a test suite should be a very high priority to ensure the system's robustness and reduce the risk of vulnerabilities and bugs.  High Severity  Not Setting L2 Upgrade Block Number Prevents Future Upgrades  The L2 block at which the L2 update occurs is not properly recorded in l2SystemContractsUpgradeBlockNumber. Consequently, when it is validated during subsequent upgrades, it fails, causing the upgrade to revert. Moreover, this code section, intended to handle blocks that have been", "html_url": "https://blog.openzeppelin.com/zksync-upgrade-system-audit#recommendations", "labels": ["OpenZeppelin"]}, {"title": "Monitoring Recommendations", "body": "While audits help in identifying code-level issues in the current implementation and potentially the code deployed in production, the Matter Labs team is encouraged to consider incorporating monitoring activities in the production environment. Ongoing monitoring of deployed contracts helps in identifying potential threats and issues affecting the production environment. Here are new recommendations to augment the ones provided in previous audits.  Governance  Critical: Some administrator privileges have been moved from the GovernanceFacet to the DefaultUpgrade contract. Consider updating any monitoring of these powers accordingly.  Critical: The upgrade function includes the ability to execute an arbitrary transaction on L2 from any sender address, including minting additional ETH. Consider monitoring all upgrade proposals to ensure the changes are expected. In addition, consider monitoring the execution of the L2 upgrade transaction to ensure it succeeds and has the desired effect.  Technical  High: The new L2 upgrade transaction is intended to occur simultaneously with the L1 updates at a predictable timestamp. Since there are several interacting components, consider monitoring the transaction through its lifecycle to identify any unexpected inconsistencies. In particular, we recommend reviewing:  Any difference between the L1 and L2 timestamps when the upgrade occurs.  Any reverted blocks that occur between the L1 upgrade and the finalization of the L2 upgrade transaction, particularly any reverted block that contains the upgrade transaction.", "html_url": "https://blog.openzeppelin.com/zksync-upgrade-system-audit#monitoring-recommendations", "labels": ["OpenZeppelin"]}, {"title": "Unexpected Refund Recipient", "body": "is able to invoke a transaction on behalf of the  authorized by enough owners and the relayer accepts the corresponding  gas refund parameters. However, if no  will receive the refund.  This makes sense on the EVM but on the zkEVM there is an important subtlety. If the initiator is an EOA (the default account), then it is set as the tx.origin value, so it will correctly receive the refund. However, if the initiator is another smart contract account, the bootloader will be set as tx.origin and it will incorrectly receive the refund.  To avoid loss of funds, consider enforcing that the refundRecipient is specified whenever tx.origin is the bootloader address.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We agree that this complicates the usage of custom accounts with multisig wallet. However, the cost of supporting different codebases is also very high and the issue affects only custom zkSync functionality.  Low Severity", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#unexpected-refund-recipient", "labels": ["OpenZeppelin"]}, {"title": "Discouraged Solidity Version", "body": "The zkSync Era documentation strongly recommends using the latest 0.8.x version of Solidity. However, the code under review allows all versions from 0.7.0 and the project is configured to use version 0.7.6. To comply with best practices, consider compiling with the latest Solidity version.  Update: Acknowledged, not resolved. The Matter Labs team stated:  While it is always better to use the latest version of the compiler, there are no known issues that affect the codebase.", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#discouraged-solidity-version", "labels": ["OpenZeppelin"]}, {"title": "Misleading Documentation", "body": "Here are some suggestions for improving the clarity and accuracy of the documentation:  The claim that creationCode is not supported should instead say that it translates to the bytecode hash.  As a matter of good practice, the example .send or .transfer replacement should check the success flag after the call.  The claim that zkSync Era does not support EIP-1559 transactions is contradicted by the listed transaction types.  The SystemContractsCaller explanation contains a broken link to the contract implementation.  Consider updating the documentation accordingly.  Update: Partially resolved in pull request #591 at commits 6d77af8 and d446f94, with second suggestion not being addressed.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Hardcoded Gas Constants", "body": "The existing codebase uses hardcoded constants to determine the transaction execution overhead and the token transfer overhead, which contradicts the recommended best practice. Consider whether these constants are still valid under the zkSync Era fee model, and whether it would be appropriate to remove the constants altogether.  Update: Acknowledged, not resolved. The Matter Labs team acknolwedged this issue.", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#hardcoded-gas-constants", "labels": ["OpenZeppelin"]}, {"title": "Unexpected Backrun Incentive", "body": "During the audit we incidentally identified a minor undesirable incentive. As noted in the documentation, only state diffs are stored on Ethereum mainnet. The transaction cost for a storage change is only charged once to the first user in the block that made the change. This creates an incentive for users to backrun other transactions that modify the same storage slots, since subsequent changes will not be charged.  The incentive is capped at the cost of all storage changes in the transaction, and is partially mitigated by the fact that currently all transactions are sent directly to the sequencer. Consider whether it's worth socializing the cost to every user interacting with the same storage slot.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We will take this into account with updating the fee model mechanism.", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#unexpected-backrun-incentive", "labels": ["OpenZeppelin"]}, {"title": "Unused Variable", "body": "When refunding the gas costs, the returned data variable is unused.  Consider leaving it undeclared.  Update: Resolved. The Matter Labs team stated:  Fixed with using original GnosisSafe/GnosisSafeL2 contract codes.", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#unused-variable", "labels": ["OpenZeppelin"]}, {"title": "Recommendations", "body": "Recommended Changes to Safe Functionality  Although not required for zkSync compatibility, we identified several recommendations to improve the original Gnosis functionality.", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#recommendations", "labels": ["OpenZeppelin"]}, {"title": "System Contract Is Used as Placeholder Value", "body": "The code uses a hardcoded sentinel address of 0x1 to define the owner linked list and the module linked list. This is intended to be a placeholder address, but it corresponds to the Ecrecover system contract on the zkEVM (and the ecrecover precompile on the EVM).  This introduces the possibility that the Ecrecover system contract could incorrectly invoke the approveHash function. This will not be an issue in practice, but in the interest of predictability, consider choosing a pseudorandom address that is not being used by a system contract.", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#system-contract-is-used-as-placeholder-value", "labels": ["OpenZeppelin"]}, {"title": "Code Style Inconsistencies", "body": "The GnosisSafeZk contract uses different styles of docstrings simultaneously. For example, compare the docstrings of the approveHash function with the requiredTxGas function. Consider unifying the style.", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#code-style-inconsistencies", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Pagination", "body": "start parameter of the  immediately after the start module. This means that neither the  returned next module are contained in the page. If the whole list is enumerated by passing the  Consider updating the code to return the start module as the first element on the page.", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#inconsistent-pagination", "labels": ["OpenZeppelin"]}, {"title": "Event Discrepancies", "body": "The GnosisSafeL2Zk contract emits SafeMultiSigTransaction and SafeModuleTransaction events whether or not the actual operation succeeds, so they need to be correlated with the success or failure events for accurate tracking. Consider including the transaction result in the event message.  Moreover, these events (as well as several events in the GnosisSafeZk contract) do not index their parameters. Our recommendation is to consider indexing event parameters to improve the ability of off-chain services to search and filter for specific events.", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#event-discrepancies", "labels": ["OpenZeppelin"]}, {"title": "Missing or Incorrect Docstrings", "body": "Some parts of the codebase do not have docstrings. For instance:  Line 195 in GnosisSafeZk.sol  Line 351 in GnosisSafeZk.sol  Some parts of the code have misleading docstrings. For instance:  Line 181 in GnosisSafeZk.sol says funds are being sent to the tx.origin, while that's not necessarily true.  Line 25 in GuardManager.sol incorrectly describes the FallbackManager contract.  Consider adding docstrings where needed and fixing incorrect ones to improve the overall readability of the codebase. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#missing-or-incorrect-docstrings", "labels": ["OpenZeppelin"]}, {"title": "require Statement With Multiple Conditions", "body": "Within GnosisSafeZk.sol there is a require statement on line 303 that requires multiple conditions to be satisfied.  To simplify the codebase and raise the most helpful error messages for failing require statements, consider having a single require statement per condition.", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#require-statement-with-multiple-conditions", "labels": ["OpenZeppelin"]}, {"title": "Singleton Contract Should Be First in the Inheritance Chain", "body": "The comment on the Singleton contract explicitly states that it should be positioned in the inheritance chain to align the singleton variable. However, it is positioned as second instead. In this case, the singleton variable is still positioned correctly, but this cannot be ascertained by local reasoning. To increase robustness, consider moving it to the top of the inheritance list.", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#singleton-contract-should-be-first-in-the-inheritance-chain", "labels": ["OpenZeppelin"]}, {"title": "Outdated EIP-1271 Interface", "body": "The GnosisSafeZk contract uses 0x20c13b0b as the EIP-1271 magic constant, corresponding to the old isValidSignature function interface. However, the latest version of the EIP uses a new interface and a corresponding new constant. Consider complying with the latest definition of the EIP.", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#outdated-eip-1271-interface", "labels": ["OpenZeppelin"]}, {"title": "Unused signedMessages Mapping", "body": "The signedMessages mapping and SignMsg event are not used in the deployed code. They are referenced in the SignMessageLib contract (which redefines the event) and appear to offer similar functionality to the approvedHashes mapping.  Consider whether it should be updated in the approveHash function (to update the number of people who accept the transaction), or in execTransaction after it's been executed, or if it should be removed entirely.", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#unused-signedmessages-mapping", "labels": ["OpenZeppelin"]}, {"title": "Gas Inefficiency", "body": "The add(result, 0x20) operation in the getStorageAt function of StorageAccessible contract can be moved outside the loop. This would also be an opportunity to introduce a comment explaining why the 0x20 offset is used (to account for the length field), which would improve the readability of the code.", "html_url": "https://blog.openzeppelin.com/zksync-gnosissafezk-assessment-1#gas-inefficiency", "labels": ["OpenZeppelin"]}, {"title": "Fragile Deposit Limit", "body": "The L1ERC20Bridge contract prevents deposits over a configurable limit for some tokens. This is achieved by recording deposits for deposit-limited tokens, rewinding the update if the deposit failed, and ignoring tokens that are not limited. This introduces an edge case that could lead to loss of funds:  A user initiates a deposit that will fail to execute on L2 using a token with no deposit limit. Therefore, the deposit is not recorded.  A deposit limit is introduced for the token.  The user will be unable to claim the failed deposit, because the attempt to rewind the (non-existent) deposit update will fail.  Consider simply clearing the deposit record if the amount to claim exceeds the recorded value. Alternatively, consider recording deposits for all tokens, whether or not they have a deposit limit.  Update: Acknowledged, not resolved. The Matter Labs team stated:  The deposit limiting feature is currently turned off in the network. We will revisit this issue if we decide to turn on the feature.  Low Severity", "html_url": "https://blog.openzeppelin.com/zksync-bridge-and-.transfer-.send-diff-audit#fragile-deposit-limit", "labels": ["OpenZeppelin"]}, {"title": "Unsafe ABI Encoding", "body": "It is not an uncommon practice to use abi.encodeWithSignature or abi.encodeWithSelector to generate calldata for a low-level call. However, the first option is not typo-safe and the second option is not type-safe. The result is that both of these methods are error-prone and should be considered unsafe.  On line 151 of L2ERC20Bridge.sol an unsafe ABI encoding is used.  Consider replacing this occurrence with abi.encodeCall, which checks whether the supplied values actually match the types expected by the called function and also avoids errors caused by typos. Note that this will require a version greater than Solidity 0.8.11. However, it is recommended to use Solidity 0.8.13 or above since there was a bug detected regarding fixed-length bytes literals. While this bug does not currently affect the codebase, using an updated version will remove the possibility of future errors.  Update: Resolved in pull request #132 at commit fb2ab16.", "html_url": "https://blog.openzeppelin.com/zksync-bridge-and-.transfer-.send-diff-audit#unsafe-abi-encoding", "labels": ["OpenZeppelin"]}, {"title": "Missing Error Messages in require Statements", "body": "Throughout the codebase there are require statements that lack error messages:  The require statement on line 46 of L1Messenger.sol  The require statement on line 168 of SystemContractHelper.sol  Consider including specific, informative error messages in require statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied.  Update: Resolved in pull request #265 at commit 589d582.", "html_url": "https://blog.openzeppelin.com/zksync-bridge-and-.transfer-.send-diff-audit#missing-error-messages-in-require-statements", "labels": ["OpenZeppelin"]}, {"title": "Unreplenishable Deposit Limit", "body": "When users transfer ERC-20 tokens over the bridge, they consume part of their deposit limit, which is never replaced. This introduces the possibility that an address can reach the limit and be unable to use the bridge until the limit is increased or removed for everybody. It is likely that the limits will be configured to exceed most legitimate use cases.  Nevertheless, in the interest of flexibility, consider introducing a mechanism for the administrator to reset or replenish a user's allowance.  Update: Acknowledged, not resolved. The Matter Labs team stated:  The deposit limiting feature is currently turned off in the network. We will revisit this issue if we decide to turn on the feature.", "html_url": "https://blog.openzeppelin.com/zksync-bridge-and-.transfer-.send-diff-audit#unreplenishable-deposit-limit", "labels": ["OpenZeppelin"]}, {"title": "Bridge Cannot Recover Funds", "body": "The BridgeInitializationHelper contract sets the message sender as the refund recipient for its cross-domain messages. This pattern assumes that the message sender will independently recover the funds if necessary. However, in this case, the message sender is the L1ERC20Bridge contract, which has no mechanism to initiate the withdrawal. Therefore, if either the implementation or proxy deployment transaction fails, the deployment fee will be trapped on Layer 2.  Consider using the governor address as the refund recipient instead.  Update: Resolved in pull request #136 at commit 0437f63.", "html_url": "https://blog.openzeppelin.com/zksync-bridge-and-.transfer-.send-diff-audit#bridge-cannot-recover-funds", "labels": ["OpenZeppelin"]}, {"title": "Missing and Misleading Documentation", "body": "The following parts of the codebase are lacking documentation:  In the BridgeInitializationHelper contract:  The requestDeployTransaction function is missing the @param statement for the _zkSync parameter.  In the L1ERC20Bridge contract:  The initialize function is missing the @param statements for the fee parameters.  In the Mailbox contract:  The l2TransactionBaseCost function is missing all @param statements. The _deriveL2GasPrice function is missing the @return statement. The _getOverheadForTransaction function is missing the @param statements for two parameters.  In the L2ContractHelper.sol file:  The library functions, interfaces, and struct are missing documentation.  The following documentation is misleading:  In the L2Weth contract:  The initialize function's documentation claims it stores the L1 address of the bridge, but it does not. The bridgeMint function's documentation references the StandardToken interface instead of the IL2StandardToken interface. It should also indicate that the function always reverts. The first bridgeMint function parameter is annotated with \"_to\" but the parameter is named _account. The bridgeBurn function claims to burn tokens from \"_from\" WETH contract instead of the \"_from\" address.  In the L1ERC20Bridge contract:  The l2TokenBeacon variable is described as a factory, but it is actually a beacon.  Consider including thorough and correct docstrings and inline explanations with references to relevant source files or documentation, allowing readers or maintainers to verify the implementations and their correct usage.  Update: Resolved in pull request #135 at commit c415ce5.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/zksync-bridge-and-.transfer-.send-diff-audit#missing-and-misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "State Variable Visibility Not Explicitly Declared", "body": "Throughout the codebase there are state variables that lack an explicitly declared visibility:  The state variable allowList in L1ERC20Bridge.sol  The state variable zkSync in L1ERC20Bridge.sol  The state variable l2TokenProxyBytecodeHash in L2ERC20Bridge.sol  For clarity, consider always explicitly declaring the visibility of variables, even when the default visibility matches the intended visibility.  Update: Resolved in pull request #140 at commit 459918a.", "html_url": "https://blog.openzeppelin.com/zksync-bridge-and-.transfer-.send-diff-audit#state-variable-visibility-not-explicitly-declared", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "Throughout the codebase there are imports that are unused and could be removed:  Import MAX_MSG_VALUE of MsgValueSimulator.sol  Import MSG_VALUE_SYSTEM_CONTRACT of SystemContractHelper.sol  Import Utils of SystemContractHelper.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #269 at commit b868f4a.", "html_url": "https://blog.openzeppelin.com/zksync-bridge-and-.transfer-.send-diff-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Multiple Declarations per File", "body": "Within SystemContractHelper.sol, both the SystemContractHelper library and the abstract contract ISystemContract are declared.  Consider separating the contracts into their own files to make the codebase easier to understand for developers and reviewers.  Update: Resolved in pull request #270 at commit 5a48644.", "html_url": "https://blog.openzeppelin.com/zksync-bridge-and-.transfer-.send-diff-audit#multiple-declarations-per-file", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "Throughout the codebase we identified the following typographical errors:  zkSync v2.0 \u2192 zkSync Era in L1ERC20Bridge.sol  do \u2192 does in L1ERC20Bridge.sol  finalisation \u2192 finalization in L1ERC20Bridge.sol and in Mailbox.sol for consistency  can not \u2192 cannot in L2Weth.sol  Consider correcting these typographical errors.  Update: Resolved in pull request #138 at commit 4f984e6.", "html_url": "https://blog.openzeppelin.com/zksync-bridge-and-.transfer-.send-diff-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "To favor explicitness and readability, there are two locations in the contracts that may benefit from better naming:  The function requestDeployTransaction is internal and thus could be prepended with an underscore. Consider renaming the function to _requestDeployTransaction.  The variable unspendGas could be renamed to unspentGas.  Consider renaming these variables to be more consistent.  Update: Resolved in pull request #267 at commit 2382fa2. The Matter Labs team stated:  Our convention is not to prefix internal methods with an underscore in libraries, so we will not change the naming of requestDeployTransaction.", "html_url": "https://blog.openzeppelin.com/zksync-bridge-and-.transfer-.send-diff-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Use assert for Inviolable Conditions", "body": "When finalizing deposits on Layer 2, the L2ERC20Bridge contract checks one of two consistency conditions. Since these should never fail for any user input, consider using assert statements instead of require statements. This indicates that the conditions should be inviolable, and is better suited for analysis tools that attempt to prove this claim or identify counterexamples.  Update: Acknowledged, not resolved. The Matter Labs team stated:  Although assert might logically seem like a better option, require is easier to debug. We will leave the require statement in place for now.", "html_url": "https://blog.openzeppelin.com/zksync-bridge-and-.transfer-.send-diff-audit#use-assert-for-inviolable-conditions", "labels": ["OpenZeppelin"]}, {"title": "Unexpected Address Aliasing", "body": "When constructing Layer 1 (L1) to Layer 2 (L2) messages, the Mailbox contract aliases the refund recipient if it corresponds to a deployed L1 smart contract. This makes sense when the address is known to be associated with that smart contract, such as when it is initialized to the message sender. However, if it is chosen by the user to be an L2 address, applying the alias could bypass the user's intention.  In particular, users will be unable to choose an L2 refund recipient that has the same address as an existing L1 smart contract. If a user inputs this address as the refund recipient, it will be aliased and the intended L2 contract will be unable to control the funds. Instead, the funds would be controlled by the L1 smart contract, which the user may not even control.  In the current deployment, this scenario should be impossible because L1 and L2 addresses are derived differently, but this decision is not settled. In the interest of predictability, consider leaving the refund recipient unaliased if it is explicitly chosen by the user to be an L2 address.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We will take this into account when and if we change the address derivation rule.", "html_url": "https://blog.openzeppelin.com/zksync-bridge-and-.transfer-.send-diff-audit#unexpected-address-aliasing", "labels": ["OpenZeppelin"]}, {"title": "ETH Can Be Locked Through Address Aliasing", "body": "Whenever interacting with L2 from L1, either through the Mailbox.requestL2Transaction or the L1WethBridge.deposit function, the user can specify a refund recipient address. This address receives a refund (on L2) of any excessive ETH provided, up to a full refund in the case of a reverting transaction.  [1]  [2],  L1WethBridge contract, and  _requestL2Transaction function. The outcome of the used refund recipient is condensed into the following table:  Is Zero  Is L1 Contract  Is L1 EOA  Is L1 Contract  aliased msg.sender (*)  aliased _refundRecipient (*)  _refundRecipient  Is L1 EOA  msg.sender  aliased _refundRecipient (*)  _refundRecipient  Firstly, the cases (*) where the refund will be sent to an aliased address on L2 are confusing and error-prone, especially since the docstring states that the _refundRecipient is \"The address on L2 that will receive the refund for the transaction\". Secondly, it is possible that the caller has no control over that address, thereby locking the ETH. An exception to this occurs if the L1 contract is able to initiate arbitrary L2 transaction requests, such that the caller can act as the aliased address through the Mailbox to transfer or withdraw the ETH.  It is noted that in a previous report, this issue was presented and a fix was attempted at commit 201c99c. While OpenZeppelin's previous review had deemed this fixed, upon further review, it has now been identified that this issue persists.  As of March 30th, 2023, the Mailbox contract on mainnet appears to be affected by this issue. Thus, under the conditions above, users are currently at risk of having their ETH locked in a L2 address that they do not control. While the developer documentation provides warnings regarding aliasing, it is still possible for users (particularly those less familiar with the inner workings of the system) to have their ETH locked.  The reasoning for the address aliasing of the refund recipient is unclear at the moment. It is understood that applying address aliasing to the msg.sender can help prevent cross-chain attacks. However, consider removing address aliasing for the refund recipient. In addition, consider requiring that a refund recipient is always provided.  Update: Acknowledged, not resolved. The Matter Labs team stated:  Users can specify the needed refund receiver to eliminate the risk of a smart contract refund recipient that is not able to get the funds back. That being said, we agree that mandatory parameter is a cleaner option, but whether it is the better foolproof approach is debatable. As an example, one of our partners that are building a bridge asked us to implement this. Also, users seem to be used to this approach on Arbitrum, and since it is battle-tested, the risk is rather small. Lastly, the ERC-20 bridge was deployed on production and it is highly undesirable to change its behavior without an important reason. Thank you for highlighting the issue, we will keep eye on it.  Low Severity", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#eth-can-be-locked-through-address-aliasing", "labels": ["OpenZeppelin"]}, {"title": "Entanglement of Initialization and ReentrancyGuard", "body": "The L1WethBridge is the implementation contract that is intended to be used with a proxy. As such, it is a good practice to restrict how it can be invoked directly. The reentrancyGuardInitializer modifier is used for the constructor and initialize functions as a means to prevent an attacker from (re-)initialization of the implementation and proxy contracts. This is realized by updating the value of the pseudo-random storage location LOCK_FLAG_ADDRESS.  Two functions in L1WethBridge, deposit and finalizeWithdrawal, use the nonReentrant modifier for protection against reentrancy. This modifier works by also updating the value at the same LOCK_FLAG_ADDRESS storage location. While there is currently no identifiable vulnerability with this methodology, using one storage slot to serve these two purposes entangles the two attack surfaces and goes against the general programming principles of modularization. By separating these two concerns, the codebase can be easier to comprehend, especially when adding future functionality and complexity.  Update: Acknowledged, will resolve. The Matter Labs team stated:  This is planned for the refactoring. The proposed approach seems much cleaner, but we will not implement it in the current upgrade due to the complexity of the migration and its associated risk.", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#entanglement-of-initialization-and-reentrancyguard", "labels": ["OpenZeppelin"]}, {"title": "Funds Can Get Lost in WETH Bridge", "body": "The WETH bridging involves multiple steps of handling and transferring funds. One of these steps is swapping the WETH token to ETH that is sent from the WETH contract to the L1 or L2 bridge. Hence, the L1WethBridge and L2WethBridge contracts have a receive function that logs the ETH that is received. If a user or a contract sends ETH directly to either the L1 or the L2 bridge, it will be irrecoverable.  Since the bridge contracts are only expected to receive ETH from the WETH contracts, consider adding a check that restricts any other addresses from sending ETH to the bridge.  Update: Resolved in pull request #113 at commit 5dc8067.", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#funds-can-get-lost-in-weth-bridge", "labels": ["OpenZeppelin"]}, {"title": "Interface Mismatch", "body": "withdrawWithMessage function, which was renamed from  withdraw function with the respective parameters.  Consider updating the interface to match the latest implementation and guarantee the functionality of the bridge.  Update: Resolved in pull request #114 at commit 664a2df.", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#interface-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings:  ethereum/contracts/bridge/interfaces/IL2Bridge.sol  ethereum/contracts/bridge/interfaces/IL2WethBridge.sol  zksync/contracts/bridge/interfaces/IL2Bridge.sol  Line 46 in L2WethBridge.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Partially resolved in pull request #115 at commit dd9533b. The Matter Labs team stated:  We don't usually write documentation for interfaces, since it ends up with duplicated doc-comments.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "Throughout the codebase, the following imports are unused and could be removed:  Import IL2ContractDeployer of L1WethBridge.sol  Import TransparentUpgradeableProxy of L2WethBridge.sol  Import IL1Bridge of L2WethBridge.sol  Import L2Weth of L2WethBridge.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #116 at commit e577cae.", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Non-Explicit Imports Are Used", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code. This is particularly relevant when multiple constructs exist within the same Solidity file. For instance, the following two imports provide constants to the contract, but this is not obvious from just reading the import statements of L2ContractAddresses and L2ContractHelper:  L2ContractAddresses in L1WethBridge.sol  L2ContractHelper in L2WethBridge.sol  Consider applying an explicit import format to specify which constants are imported.  Update: Resolved in pull request #117 at commit 802fd24.", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Misleading Documentation", "body": "The following documentation is misleading:  The comment on the refundRecipient address says \"Please note, if the recipient is a contract (the only exception is a contracting contract, but it is shooting in the leg)\", which does not make sense.  The comment on the claimFailedDeposit function says \"Refund is performed by sending an equivalent amount of ETH to the refund recipient address on L2.\" However, the refund is actually obtained by directly calling the withdraw or withdrawWithMessage methods in L2EthToken.  This revert message says that \"ETH refund is handled by the zkSync contract.\" It should be more explicit and state that the ETH refund is handled by the L2EthToken contract.  This comment should say additionalData instead of additonalData.  Consider rephrasing misleading comments to match the intention of the code.  Update: Resolved in pull request #118 at commit fbc9c01. The Matter Labs team stated:  Regarding the claimFailedDeposit comments, it is correct. If the deposit transaction fails, the associated ETH will be sent to the deposit refund recipient's address.", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Keyword payable Is Missing in Interface", "body": "The IL2Bridge interface within the ethereum folder structure is primarily used for encoding calldata that is sent to L2. One of these functions is finalizeDeposit, which must be payable. Whenever a non-payable function is overridden with a payable function, a compiler error is thrown. Because this interface is not being inherited and overridden, this is currently not a problem.  However, consider adding the payable keyword in the interface to ensure correctness and alignment in the future.  Update: Resolved in pull request #119 at commit b4c8e1b.", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#keyword-payable-is-missing-in-interface", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "To favor explicitness and readability, there are two locations in the contracts that may benefit from better naming:  The l2ProxyWethAddress name is inconsistent with l2WethAddress. Consider renaming both variables to l2WethProxyAddress for consistency with each other and with the naming convention of the ERC20 Bridges.  The L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR name is inconsistent with L2_ETH_ADDRESS and ETH_TOKEN_SYSTEM_CONTRACT.  Consider renaming these variables to be more consistent.  Update: Partially resolved in pull request #120 and commit d549055. Regarding the first bullet point, the Matter Labs team applied consistency by renaming l2ProxyWethAddress to l2WethAddress in the L1WethBridge contract. Regarding the second bullet point they stated:  The second comment requires changing the naming across the repos and careful refactoring, so we will postpone it.", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Monitoring Recommendations", "body": "While audits help in identifying potential security risks, the Matter Labs team is encouraged to also incorporate automated monitoring of on-chain contract activity into their operations. Ongoing monitoring of deployed contracts helps in identifying potential threats and issues affecting the production environment. Note that the following recommendations are partly similar to the ones of the prior ERC20Bridge audit.", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#monitoring-recommendations", "labels": ["OpenZeppelin"]}, {"title": "Governance", "body": "Governance", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#governance", "labels": ["OpenZeppelin"]}, {"title": "Technical", "body": "High: Monitor that the WETH amount deposited on L1 equals the minted amount on L2. Also, monitor that the burnt amount on L2 matches the withdrawn amount on L1. Any mismatch could mean a loss for the user or an attack on the protocol. Note that this will happen with a time delay, but these events can be seen in context through the recipient parameter.  High: Monitor that the Diamond Proxy (Mailbox) ETH balance is roughly equal to L2EthToken.totalSupply + L2Weth.totalSupply, with some tolerance (for example, within a 5% difference) to account for the time delay of bridge transfers.", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#technical", "labels": ["OpenZeppelin"]}, {"title": "Financial", "body": "Medium: Consider monitoring the size and cadence of WETH bridge transfers during normal operations to establish a baseline of healthy properties. Any large deviation, such as an unexpectedly large L1 withdrawal or L2 mint, may indicate unusual behavior of the contracts or an ongoing attack.", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#financial", "labels": ["OpenZeppelin"]}, {"title": "Suspicious Activity", "body": "Low: Withdrawals on L1 are not triggered automatically, and must instead be initiated by L1 users. Any withdrawal that takes too long to finalize may indicate a problem with the withdrawal proof. Consider monitoring for withdrawals that remain in transit for significantly longer than the median withdrawal duration.", "html_url": "https://blog.openzeppelin.com/zksync-weth-bridge-audit#suspicious-activity", "labels": ["OpenZeppelin"]}, {"title": "Configuration update retroactively impacts users rewards", "body": "Updating the configuration of a staking pool using the configureStakingToken function in the AcceleratingDistributor contract will immediately affect the rewards received by all users who have staked in the pool. If the maxMultiplier or secondsToMaxMultiplier parameters are modified, users who have previously staked in the pool will see a change in their outstanding rewards. Specifically:  Increasing/decreasing the maxMultiplier parameter causes an immediate increase/decrease in outstanding rewards, respectively.  Increasing/decreasing the secondsToMaxMultiplier parameter causes an immediate decrease/increase in outstanding rewards, respectively.  getUserRewardMultiplier function where the  getOutstandingRewards function returns a value called  baseRewardPerToken function,  _updateReward function is called by the  Consider implementing a mechanism to checkpoint user rewards such that parameter changes do not retroactively impact outstanding rewards.  Update: Acknowledged, not resolved. Documentation was added to the configureStakingToken function in pull request #55 with commit 2110ce2. The documentation clarifies the consequences of updating the maxMultiplier and secondsToMaxMultiplier parameters, however no changes were made to contract to prevent parameter changes from impacting outstanding user rewards. The UMA team stated:  We decided not to implement this fix and instead are willing to live with the fact that the admin has full control over the contract's rewards and should set the stakingToken configuration reasonably so as not to cause unexpected reward drops for users. (Unexpected reward increases are ok). The admin already has full ability to drain all rewards (not principal!) from the contract so doing so by changing stakingToken configs doesn't strike us as a different risk profile.  Low Severity", "html_url": "https://blog.openzeppelin.com/uma-accelerating-distributor-incremental-audit#configuration-update-retroactively-impacts-users-rewards", "labels": ["OpenZeppelin"]}, {"title": "Dangerous maximum values for reward calculations", "body": "AcceleratingDistributor contract contains  hard-coded upper limits that ensure  According to the Across documentation for rewards locking, the value of maxMultiplier should never exceed 3e18 for the initial reward locking program; 1e36 is many orders of magnitude larger.  The rewards locking documentation also states that the initial token supply for rewards is 75,000,000 ACX tokens. This equates to 7.5e25 wei, but the upper limit of 1e27 on baseEmissionRate allows a token emission rate per second that is two orders of magnitude higher than the total supply to be emitted.  Through an accidental or malicious administrative action, maxMultiplier and/or baseEmissionRate could be set to values that rapidly deplete the rewards pool, allowing some users to claim excessively large reward payouts until the error is discovered and corrected.  Consider setting the upper limits for maxMultiplier and baseEmissionRate much closer to the expected maximum operating values. For example, setting upper limits no more than 1 order of magnitude above the maximum expected values reduces risk while still allowing some flexibility to change the terms of the rewards program in the future.  Update: Partially resolved in pull request #4319 with commit 2e9794a. The maxMultiplier upper limit was reduced from 1e36 to 1e24, which allows for multiples of up to 1000000x the base reward rate, and the baseEmissionRate upper limit was reduced from 1e27 to 1e24, which allows for up to 1 million tokens/second to be emitted. These limits are substantially lower than the previous values, but are still high enough that security is being traded for flexibility.", "html_url": "https://blog.openzeppelin.com/uma-accelerating-distributor-incremental-audit#dangerous-maximum-values-for-reward-calculations", "labels": ["OpenZeppelin"]}, {"title": "Lack of input validation", "body": "The AcceleratingDistributor contract includes some functions that do not properly validate their input parameters. Specifically:  The stakeFor function does not check that the beneficiary address is not the zero address.  The unstake and _stake functions do not verify that the input amount is greater than zero.  Even though these issues do not pose a security risk, the lack of validation on user-controlled parameters may result in erroneous transactions. Consider implementing appropriate validation on the input arguments for the cases listed above.  Update: Resolved in pull request #47 with commit d38d4cd.", "html_url": "https://blog.openzeppelin.com/uma-accelerating-distributor-incremental-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Missing or incomplete docstrings", "body": "Several functions and structs in AcceleratingDistributor contract lack complete documentation:  The members of the UserDeposit and StakingToken structs are undocumented.  The constructor is undocumented.  The getCurrentTime function is undocumented.  The getAverageDepositTimePostDeposit function is missing a docstring for the amount parameter.  The _stake function is undocumented.  Incomplete documentation hinders reviewers' understanding of the code's intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions and their parameters. When writing docstrings, especially for publicly-exposed functions, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #53 with commit 95ae7ff.", "html_url": "https://blog.openzeppelin.com/uma-accelerating-distributor-incremental-audit#missing-or-incomplete-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Potential underflow error", "body": "AcceleratingDistributor contract, there is no lower bound on the  return statement of the  getUserRewardMultiplier function will fail due to underflow when evaluating  Consider refactoring the return statement of the getUserRewardMultiplier function such that it cannot fail due to underflow.  Update: Resolved in pull request #48 with commit 7bd053a. A lower limit of 1e18 has been placed on the maxMultiplier value.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/uma-accelerating-distributor-incremental-audit#potential-underflow-error", "labels": ["OpenZeppelin"]}, {"title": "Event parameter will always be zero", "body": "When the RewardsWithdrawn event is emitted from the withdrawReward function, the userRewardsOutstanding event parameter will always be zero. Since this is the only location in the codebase where the RewardsWithdrawn event is emitted, consider removing the redundant event parameter.  Update: Resolved in pull request #49 with commit f50c6ec.", "html_url": "https://blog.openzeppelin.com/uma-accelerating-distributor-incremental-audit#event-parameter-will-always-be-zero", "labels": ["OpenZeppelin"]}, {"title": "Misleading documentation", "body": "In the AcceleratingDistributor contract, the following instances of misleading documentation were found:  Lines 165-166: The comment says \"if the token is not enabled for staking then we simply send back the full amount of tokens that the contract has\", but it is the lastUpdateTime value that is checked, not the enabled value. Consider changing \"if the token is not enabled\" to \"if the token has not been initialized\".  Within the across-token/test directory, the constants.ts file uses a maxMultipler value of 5 for testing. The associated comment says \"At maximum recipient can earn 5x the base rate\". However, the Across documentation for reward locking states that 3 is the maximum multiplier value. To avoid confusion, consider updating the test to match the official documentation.  Update: Resolved in pull request #50 with commit fe338bc. Regarding the suggested change to the constants.ts test file, the UMA team stated:  This is currently not implemented, because the current maxMultiplier of 3 represents current Across LP staking policy, rather than the technical constraints of the underlying contract.", "html_url": "https://blog.openzeppelin.com/uma-accelerating-distributor-incremental-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent ordering", "body": "In the AcceleratingDistributor contract, ordering generally follows the recommended order in the Solidity Style Guide, which is: type declarations, state variables, events, errors, modifiers, functions. However, within the contract, the event definitions deviate from the style guide, bisecting the functions. Additionally, the struct definitions occur after the rewardToken state variable is defined.  Furthermore, the ordering of functions is generally well structured with the exception of the public view getCurrentTime function, which is defined outside of the view functions section.  To improve the project's overall legibility, consider standardizing ordering throughout the codebase, as recommended by the Solidity Style Guide.  Update: Resolved in pull request #52 with commit be635c4. However, in restructuring the layout of the contract, the docstrings for the getCurrentTimestamp and the constructor were removed.", "html_url": "https://blog.openzeppelin.com/uma-accelerating-distributor-incremental-audit#inconsistent-ordering", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Consider correcting the following typographical errors in AcceleratingDistributor.sol:  Line 122: \"dont\" should be \"don't\".  Line 123: \"loose\" should be \"lose\".  Line 158: \"have. i.e\" should be \"have, i.e.\".  Line 159: \"cant\" should be \"can't\".  Line 165: \"if the token\" should be \"If the token\".  Line 214: \"if underflow\" should be \"on underflow\" or \"if underflow occurs\".  Line 214: \"cant\" should be \"can't\".  Line 312: \"any internal logic...\" line is a copy-paste error from line 294.  Line 331: \"users staking duration\" should be \"user's staking duration\" .  Line 349: \"last users average deposit time\" should be \"user's last average deposit time\".  Line 352: Add a space before @return.  Line 352: \"users average deposit time\" should be \"user's average deposit time\".  Line 359: \"users new average deposit time\" should be \"user's new average deposit time\".  Update: Partially resolved in pull request #51 with commit 5254dec. The following typographical errors are still present:  Line 188: \"i.e\" should be \"i.e.\".  Line 396: \"last user's\" should be \"user's\".", "html_url": "https://blog.openzeppelin.com/uma-accelerating-distributor-incremental-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "HubPool Might Stop Executing Bundles if Deposit Limits Are Enabled for ZkSync", "body": "If zkSync enables deposit limit and the HubPool contract hits the limit then the Across protocol will partially stop working because the root bundle could not be executed. The Across protocol assumes that the limit can be bypassed by splitting a deposit into multiple chunks.  However, this is not the case as the limit specifies the total amount of tokens bridged but not the per-deposit amount. Thus if the limit is hit it will not be possible to bypass it by splitting the deposit into smaller chunks. Furthermore, the attacker can trigger this scenario by increasing the total amount deposited from Across to zkSync by choosing zkSync as the repayment chain.  Consider changing how the limit hit is handled by the Across protocol.  Update: Resolved in pull request #328 at commit fd6c17b.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/across-v2-incremental-audit#hubpool-might-stop-executing-bundles-if-deposit-limits-are-enabled-for-zksync", "labels": ["OpenZeppelin"]}, {"title": "Constants Not Using UPPER_CASE Format", "body": "In ZkSync_Adapter.sol there are constants not using UPPER_CASE format. For instance:  The l2GasLimit constant declared on line 75  The l1GasToL2GasPerPubDataLimit constant declared on line 80  The l2RefundAddress constant declared on line 85  The zkSync constant declared on line 91  The zkErc20Bridge constant declared on line 93  According to the Solidity Style Guide, constants should be named with all capital letters with underscores separating words. For better readability, consider following this convention.  Update: Partially resolved in pull request #322 at commit ce6e2e1. The names of the constants that are actually interfaces were not changed because the camel case better reflects their purpose.", "html_url": "https://blog.openzeppelin.com/across-v2-incremental-audit#constants-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "Incomplete Event Emissions", "body": "The SetZkBridge event should emit both the old bridge address and the new bridge address.  When making modifications to state variables, it is essential to enhance the functionality of off-chain services in searching for and filtering specific events. To achieve this, consider consistently emitting the old and new values during state variable changes. By doing so, off-chain services can have better visibility and track the evolution of these variables over time.  Furthermore, it is recommended to adopt this pattern in the scope of this audit and other contracts beyond its scope. This approach promotes consistency and standardization throughout the codebase.  Update: Resolved in pull request #327 at commit fa3b55b.", "html_url": "https://blog.openzeppelin.com/across-v2-incremental-audit#incomplete-event-emissions", "labels": ["OpenZeppelin"]}, {"title": "Lack of Documentation", "body": "The l2RefundAddress address is used to receive refunds from L2 transactions. However, it is not clear what its role is and how it is managed.  Consider documenting the address's purpose and how it is managed.  Update: Resolved in pull request #326 at commit ea0a27f.", "html_url": "https://blog.openzeppelin.com/across-v2-incremental-audit#lack-of-documentation", "labels": ["OpenZeppelin"]}, {"title": "Misleading Comments", "body": "The comment in the ZkSync_SpokePool contract states that ETH on zkSync is an ERC-20. However, that is not completely true. While ETH on zkSync has balanceOf, decimals, and some other ERC-20 functions it does not provide functions such as transfer, approve, and transferFrom.  Consider adjusting the comment.  Update: Resolved in pull request #323 at commit d6c610e.", "html_url": "https://blog.openzeppelin.com/across-v2-incremental-audit#misleading-comments", "labels": ["OpenZeppelin"]}, {"title": "Style Inconsistencies", "body": "Throughout the codebase, events are emitted at the end of functions. However, the ZkSyncTokensBridged event does not follow this pattern and is emitted at the beginning of the function.  Consider emitting it at the end of the functions to improve the codebase's consistency.  Update: Resolved in pull request #324 at commit 7cce6fb.", "html_url": "https://blog.openzeppelin.com/across-v2-incremental-audit#style-inconsistencies", "labels": ["OpenZeppelin"]}, {"title": "TODO Comments", "body": "The following instances of TODO comments were found in the codebase.  These comments should be tracked in the project's issue backlog and resolved before the system is deployed:  The TODO comment on line 15 in ZkSync_SpokePool.sol  The TODO comment on line 95 in ZkSync_Adapter.sol  During development, having well-described TODO comments will make the process of tracking and solving them easier. Without this information, these comments might age and important information for the security of the system might be forgotten by the time it is released to production.  Consider removing all instances of TODO comments and instead tracking them in the issues backlog. Alternatively, consider linking each inline TODO to the corresponding issues backlog entry.  Update: Resolved in pull request #325 at commit b2abd5d.", "html_url": "https://blog.openzeppelin.com/across-v2-incremental-audit#todo-comments", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Neither IScrollMessenger.sol nor ScrollBridgeReceiver.sol have docstrings.  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #822.", "html_url": "https://blog.openzeppelin.com/scroll-alpha-comet-deployment-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Function Is Updating the State Without an Event Emission", "body": "The ScrollBridgeReceiver contract sets the l2Messenger variable during construction. However, it does so without firing the relevant event for such an update.  Consider emitting the NewL2Messenger event during ScrollBridgeReceiver construction.  Update: Resolved in pull request #822.", "html_url": "https://blog.openzeppelin.com/scroll-alpha-comet-deployment-audit#function-is-updating-the-state-without-an-event-emission", "labels": ["OpenZeppelin"]}, {"title": "Unused Variable", "body": "In the Comet contract's absorb function, the gasUsed variable is instantiated but never used.  In order to maintain cohesive, easily understood code, consider removing the unused variable entirely.  Update: Acknowledged, not resolved. The Scroll team stated:  Leaving gasUsed in the code to minimize code changes from the original Comet contracts  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/scroll-alpha-comet-deployment-audit#unused-variable", "labels": ["OpenZeppelin"]}, {"title": "Lack of Security Contact", "body": "Providing a specific security contact (such as an email or ENS name) within a smart contract significantly simplifies the process for individuals to communicate if they identify a vulnerability in the code. This practice is beneficial as it permits the code owners to dictate the communication channel for vulnerability disclosure, eliminating the risk of miscommunication or failure to report due to a lack of knowledge on how to do so. In addition, if the contract incorporates third-party libraries and a bug surfaces in those, it becomes easier for their maintainers to contact the appropriate person about the problem and provide mitigation instructions. However, neither IScrollMessenger.sol nor ScrollBridgeReceiver.sol contain such a contact.  Consider adding a NatSpec comment containing a security contact above the contract definitions. Using the @custom:security-contact convention is recommended as it has been adopted by the OpenZeppelin Wizard and the ethereum-lists.  Update: Acknowledged, not resolved. The Scroll team stated:  Leaving as is to follow conventions of the Comet repo", "html_url": "https://blog.openzeppelin.com/scroll-alpha-comet-deployment-audit#lack-of-security-contact", "labels": ["OpenZeppelin"]}, {"title": "Non-Explicit Imports Are Used", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code, and may create naming conflicts between local and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  In ScrollBridgeReceiver.sol, global imports are being used:  The import \"../SweepableBridgeReceiver.sol\"; import in ScrollBridgeReceiver.sol  The import \"./IScrollMessenger.sol\"; import in ScrollBridgeReceiver.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged, not resolved. The Scroll team stated:  Leaving non-explicit imports to comply with existing conventions in the Comet repo", "html_url": "https://blog.openzeppelin.com/scroll-alpha-comet-deployment-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "No Access Control on ReserveFeed Contract", "body": "The ReserveFeed contract tracks exchange rates for each collateral type. The setExchangeRate function does not contain any access control or input validation. This would allow anyone to set any price for any collateral type.  Consider implementing access control on the setExchangeRate function to ensure that only trusted users can update the tracked rates.  Update: Resolved in pull request #20.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#no-access-control-on-reservefeed-contract", "labels": ["OpenZeppelin"]}, {"title": "Repaying Debt With IonZapper Will Lock WETH in Contract", "body": "zapRepay function in the  wraps the ETH sent into WETH and then is supposed to  use this to repay debt on behalf of the msg.sender.  payer argument to the  original caller's address within the  Update: Resolved in pull request #21.  High Severity", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#repaying-debt-with-ionzapper-will-lock-weth-in-contract", "labels": ["OpenZeppelin"]}, {"title": "repayAndWithdraw Will Frequently Fail for Full Repayments", "body": "Within the repayWithdraw function of the IonHandlerBase contract, the amount to repay is specified in units of WETH. As a result of inaccuracies in converting this to normalizedDebt units, when attempting to repay an account's full borrow, this function is likely to fail. Inaccuracies may arise from rounding incorrectly, or from the transaction being mined at a different time than the user anticipates and interest accrual being unexpected.  computed normalizedDebtToRepay is too high or too low, the call may revert. In case  addition of the negated normalizedDebtToRepay will revert since the value  should be less than 0. In case that  vault is likely to be dusty, causing a revert.  Consider refactoring the repayAndWithdraw function to include a \"max repayment\" logical branch. Consider using the value repayAmount == uint.max to indicate a full repayment, for example. Note that this will require changes to the transfer of WETH since the amount of WETH will need to be computed on-the-fly, and will require an accurate rate to do so. Alternatively, consider making a separate function for full repayment, and informing users, at multiple places, of the risk of failure when using the regular repayAndWithdraw function for full or near-full repayments.  Update: Resolved in pull request #22.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#repayandwithdraw-will-frequently-fail-for-full-repayments", "labels": ["OpenZeppelin"]}, {"title": "Lack of ERC-20 Approvals Prevents IonZapper Contract From Functioning as Intended", "body": "zapDepositWstEth function in the  However, there are two places within this function where the IonZapper contract needs to approve external contracts to spend ERC-20 tokens where the approvals do not exist:  When wrapping the stETH token into wstETH, the stETH held by the IonZapper contract is transferred into the wstETH contract when the wrap function is called. In order for the wstETH contract to make this transfer, the IonZapper contract must approve the wstETH contract to spend stETH tokens on its behalf.  When calling the join function on the GemJoin contract, the wstETH held by the IonZapper contract is transferred into the GemJoin contract. In order for the GemJoin contract to make this transfer, the IonZapper contract must approve the GemJoin contract to spend wstETH tokens on its behalf.  Consider setting the appropriate token approvals for the appropriate amounts within the zapDepositWstEth function to allow it to operate as intended.  Update: Resolved in pull request #21.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#lack-of-erc-20-approvals-prevents-ionzapper-contract-from-functioning-as-intended", "labels": ["OpenZeppelin"]}, {"title": "Ineffective Bound of Exchange Rate Change in Reserve Oracle", "body": "ReserveOracle contract, a  The reserve oracle is used within the Liquidation contract to determine the value of collateral when determining if a vault is liquidatable. Since the reserve oracle computes the exchange rate as the minimum of the protocol exchange rate and an averaged price from external price feeds, if an attacker were to have sufficient control over any of the price feeds, or was able to manipulate the protocol exchange rate, they would be able to move the price enough within a single transaction to liquidate users by undervauling their collateral.  Consider either using a time or block-based maximum change percentage to limit large price changes to longer periods of time and prevent single transaction attack scenarios.  Update: Resolved in pull request #32.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#ineffective-bound-of-exchange-rate-change-in-reserve-oracle", "labels": ["OpenZeppelin"]}, {"title": "Observation Cardinality Insufficient for Uniswap SwETH Oracle", "body": "The SwEthSpotOracle contract uses a Uniswap v3 TWAP oracle to get the price of the swETH token. The intended pool (ETH/swETH 0.05% fee pool) does not currently have a large enough observation cardinality to support the TWAP window (2 hours) intended to be used. The observation cardinality of the pool should be at least as large as the number of blocks in the TWAP window (600 blocks) otherwise the TWAP calculation may fail as the Uniswap pool would not contain any data from the beginning of the TWAP window.  This would prevent users from modifying their positions. As a result, vaults could be liquidated if there was a sufficient change in the exchange rate and users would be unable to repay their debt, or deposit collateral into their vault to prevent liquidation.  Consider increasing the observation cardinality for the pool by calling the increaseObservationCardinalityNext function on the pool contract with an input amount that is at least as large as the number of blocks within the TWAP window. Further, the TWAP should not be used until the Uniswap pool observation cardinality has increased to the target amount. The constructor for the SwEthSpotOracle contract should validate that the observation cardinality is sufficiently large when deploying the contract.  Update: Acknowledged, will resolve. Ion Protocol team stated:  This is a known issue. The team is aware that the observation cardinality of the swETH Uniswap AMM needs to be increased for the TWAP to function properly. We will not be launching with Swell's stETH until the observation cardinality is increased.  Medium Severity", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#observation-cardinality-insufficient-for-uniswap-sweth-oracle", "labels": ["OpenZeppelin"]}, {"title": "Liquidations Use Inaccurate rate Values", "body": "The liquidate function of the Liquidation contract does not accrue interest prior to liquidating a vault. Instead, interest is accrued within the call to confiscateVault function which determines the amount sent to the liquidator. Therefore, the rate at which the amount of collateral and debt to repay for a vault is calculated will be lower than what is sent to the liquidator. This would result in the health ratio of a vault being less than the TARGET_HEALTH value after liquidation when it is expected to be no less than this value. Furthermore, the liquidator will receive the collateral at a lower discount than if interest had been accrued prior to liquidation.  Moreover, the liquidate function could determine that a vault will be dusty after being liquidated and pay off all debt when in fact the vault would not have dust after liquidation if using an accurate value for the rate. As a result, all of the debt within a vault would be paid off when not required.  Consider accruing interest within the liquidate function to ensure that all computations are done with an accurate rate.  Update: Resolved in pull request #30.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#liquidations-use-inaccurate-rate-values", "labels": ["OpenZeppelin"]}, {"title": "Missing Deadline Check for Functions Which Call Uniswap v3 FlashSwap", "body": "There is no option to set a deadline for the flashswapLeverage, flashswapDeleverage, flashLeverageWethAndSwap and flashDeleverageWethAndSwap functions. The transaction can still be stuck in the mempool and be executed a long time after the transaction is initially called. During this time, the price in the Uniswap pool can change. In this case, the slippage parameters can become outdated and the swap will become vulnerable to sandwich attacks.  Consider adding a deadline check to the flashswapLeverage, flashswapDeleverage, flashLeverageWethAndSwap and flashDeleverageWethAndSwap functions.  Update: Resolved in pull request #25.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#missing-deadline-check-for-functions-which-call-uniswap-v3-flashswap", "labels": ["OpenZeppelin"]}, {"title": "Whitelist Modifiers Check msg.sender Rather Than User", "body": "The onlyWhitelistedLender and onlyWhitelistedBorrowers modifiers check if msg.sender is a whitelisted lender or borrower. However, for many functions, the user input parameter specifies the account that has their position adjusted rather than msg.sender. As a result, a whitelisted lender or borrower can create vaults for accounts which are not whitelisted.  another whitelist modifier as the  Consider checking the user rather than msg.sender for the whitelist. Additionally, consider removing the custom modifiers existing in IonZapper.sol and IonHandlerBase.sol in favor of relying on whitelist checks within IonPool.sol.  Update: Resolved in pull request #23. Note that the protocol whitelist is only intended to contain Ion Protocol contracts and thus should not create positions for unauthorized accounts.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#whitelist-modifiers-check-msg.sender-rather-than-user", "labels": ["OpenZeppelin"]}, {"title": "Use of Deprecated Function From Chainlink API", "body": "The getPrice function of the EthXSpotOracle contract pulls the ETHx to USD price from a Redstone oracle using the Chainlink interface using the deprecated latestAnswer function.  Consider using the non-deprecated latestRoundData function from the Chainlink interface.  Update: Resolved in pull request #32.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#use-of-deprecated-function-from-chainlink-api", "labels": ["OpenZeppelin"]}, {"title": "Collateral Rate Can Be Overwritten", "body": "rate stored for a collateral type can be overwritten using the  overwrite the rates within the first 256 indices in the  Overwriting the rate for one of the collateral types would immediately decrease the outstanding debt for all debt positions against the collateral type as the rate tracks the accumulated interest on debt. As a result, the contract would be in an inconsistent state where the outstanding debt for the collateral type would be less than what lenders are owed.  Consider explicitly validating that the length of the ilks array is 256 or less after pushing the new ilk data within the initializeIlk function.  Update: Resolved in pull request #26.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#collateral-rate-can-be-overwritten", "labels": ["OpenZeppelin"]}, {"title": "Pausing Does Not Accrue Interest as Intended", "body": "The pauseSafeActions function of the IonPool contract is intended to accrue interest when the contract is paused. Within this function, the internal _pause function is called first followed by the _accrueInterest function. As a result, interest will not be accrued since the _accrueInterest function does not accrue interest when the contract is in a safe paused state.  Consider switching the order of the internal function calls within pauseSafeActions.  Update: Resolved in pull request #27.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#pausing-does-not-accrue-interest-as-intended", "labels": ["OpenZeppelin"]}, {"title": "Timestamp Discrepancy in Spot Oracle Price Feeds May Cause Inaccurate Price", "body": "The getPrice function of the EthXSpotOracle contract computes the price of ETHx in ETH. Two oracles are used to determine the price: a Redstone oracle returns the price of ETHx in USD, and a Chainlink oracle returns the price of ETH in USD. These prices are combined to return the price of ETHx in ETH.  The corresponding timestamps for the prices for the oracles are never validated to ensure they are from similar times. If there is a significant discrepancy between the timestamps for the price feeds, this could result in an inaccurate ETHx in ETH price. Specifically, the two prices might have significant misalignment during volatile periods and may be large enough to cause a significant impact on the health of users' vaults. This situation could lead to the following:  A user could take on less additional debt if the oracle underprices their collateral.  A user could take on more debt than intended when collateral is over-priced, although this overpricing will never exceed the reserve exchange rate.  Consider validating that the two price feeds are returning prices from similar timestamps.  Update: Acknowledged, not resolved. Ion Protocol team stated:  The concern around the delayed oracle misrepresenting user health vaults is not an issue that will lead to a loss of user-locked funds as no liquidation can be triggered by the spot oracle price. The spot oracle can malfunction by either 'under' valuing or 'over' valuing the market price. This misrepresented spot oracle in the core protocol is used to value the collateral when issuing debt, such that the user debt-to-collateral ratio will adhere to the LTV. It is important to note that the value reported by the spot oracle is not used for liquidations.  If the spot oracle under reports a value, this will temporarily reduce the amount of debt that the borrowers can take out from the Ion Pool. However, it will neither lead to a liquidation nor an increase in borrow rate payments and therefore will not result in a loss for the borrower. It will only restrict the amount of debt possible to be issued. There is also no loss for the lenders aside from the borrowers creating fewer loans than what would theoretically have been possible.  If the spot oracle over represents the value, this will allow the user to borrow more funds compared to using the fair value. However, the maximum this value will reach is the exchange rate reported by the reserve oracle as the spot oracle is maximum-bounded by the exchange rate. This means that even in times of overvalued spot prices, the maximum divergence it can have is capped by the exchange rate. This means that the lenders will never be issuing loans at a valuation any higher than the native redemption value of the staked collateral which is the exchange rate.  The spot oracle is upper-bounded by the exchange rate value reported by the reserve oracle. Thus, the maximum price a spot oracle can report is the exchange rate. If the 'true' value of the market price of the asset falls in a drastic de-peg event, and the spot oracle is manipulated to report a value much larger than this 'true' value, then the risk exists that the attacker can borrow more than they theoretically should have at the true value. In the case of this oracle manipulation, the protocol would redeem the collateral into the beacon chain instead of selling it to make lenders whole. This is possible since the manipulated spot price will again be capped by the exchange rate.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#timestamp-discrepancy-in-spot-oracle-price-feeds-may-cause-inaccurate-price", "labels": ["OpenZeppelin"]}, {"title": "Oracle Data Lacks Validation", "body": "Throughout the codebase, there are several functions that use on-chain oracles to retrieve price data. These oracles consistently lack validation of the returned data. In particular:  The WstEthSpotOracle contract uses a Chainlink oracle to get the price of stETH in ETH within the getPrice function.  The EthXSpotOracle contract uses a Redstone oracle to get the price of ETHx in USD and a Chainlink oracle to get the price of ETH in USD within the getPrice function.  Consider adding checks which validate the returned data to ensure a non-zero price is returned and that the price is recent.  Update: Acknowledged, not resolved. Ion Protocol team stated:  Please refer to the M-07 response stating that underreported and overreported spot oracle values do not cause user loss of funds.  The suggested validation above is to check the returned value against a zero value. However, even if the oracle returns a zero value, the zero value will simply not allow any issuance of debt and therefore is not a risk for the protocol. Therefore validating the zero value or not validating the zero value does not introduce a meaningful difference to user safety.  As stated in M-07, similar malfunctioning of oracle behavior will be monitored offchain to trigger pauses when necessary.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#oracle-data-lacks-validation", "labels": ["OpenZeppelin"]}, {"title": "Inconsistencies When Adding a New Collateral Type", "body": "The initializeIlk function of the IonPool contract allows for adding a new collateral type. This function only includes features to partially support the addition of a new collateral type and calls to additional functions are expected to occur before the new collateral type is fully supported. Specifically:  The spot oracle must be initialized using the updateIlkSpot function.  The debt ceiling must be initialized using the updateIlkDebtCeiling function.  The dust limit must be initialized using the updateIlkDust function.  The interest rate module must be updated with an instance that supports the new collateral type using the updateInterestRateModule function.  The whitelist must be updated with an instance that supports the new collateral type using the updateWhitelist function. The current implementation of the Whitelist contract would default to allowing anyone to borrow against the new collateral type.  To minimize the attack surface and ensure adding new collateral types is less error-prone, consider consolidating all of the initialization logic into a single function, or making the initialization procedure otherwise atomic.  Update: Acknowledged, will resolve. Ion Protocol team stated:  Initialization procedure for adding new collateral types will be done atomically through Gnosis Multisend.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#inconsistencies-when-adding-a-new-collateral-type", "labels": ["OpenZeppelin"]}, {"title": "Inconsistency When Accruing Interest for a Single ILK vs. All ILKs", "body": "The IonPool contract contains two internal functions for accruing interest: the _accrueInterestForIlk function for accruing interest for a single collateral type, and the _accrueInterest function for accruing interest for all collateral types. Both of these functions update the supplyFactor which is used for tracking interest accrued on the underlying token.  As a result, accruing interest for a single collateral type, followed by accruing interest for another collateral type in the future is not equivalent to accruing interest for all collateral types each time interest is accrued. This will result in an inaccurate interest rate being applied to users' debt positions.  Consider accruing interest for all collateral types each time there is an action made on any of the collateral types that should result in interest accrual.  Update: Resolved in pull request #27.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#inconsistency-when-accruing-interest-for-a-single-ilk-vs.-all-ilks", "labels": ["OpenZeppelin"]}, {"title": "Lack of Input Validation", "body": "Throughout the codebase, functions lack validation of input arguments:  Within the ReserveOracle contract:  The constructor does not validate that the _feeds.length is exactly MAX_FEED_COUNT. If _feeds.length < MAX_FEED_COUNT, the constructor will revert when assigning the FEED0, FEED1, and FEED2 variables. The constructor does not validate that the _maxChange argument is non-zero and less than 1e27 (1 RAY). The _bound function does not validate that the min value is strictly less than the max value and may lead to inaccurate output if this does not hold.  Within the SwEthSpotOracle contract:  The constructor does not validate that the _secondsAgo argument is non-zero.  Within the YieldOracle contract:  The constructor does not validate that none of the _historicalExchangeRates values are non-zero. A zero value would result in a division by zero on line 127. The _getExchangeRate function does not validate that the ilkIndex value is within the expected range and will return 0 for an invalid input.  Within the InterestRate contract:  The constructor does not validate that the minimumKinkRate values are at least as large as the minimumBaseRate values. If this condition does not hold, the calculateInterestRate function will revert. The constructor does not validate that the ilkDataList argument has a maximum length of 8. If an array with a length greater than 8 is passed, it is possible that the distributionFactorSum will be 1e4 when the data stored within the contract will not sum to 1e4. The constructor does not validate that the optimalUtilizationRate values are non-zero. A zero optimalUtilizationRate will cause the calculateInterestRate function to revert. The constructor does not validate that the reserveFactor values are less than 1 RAY (1e27). A reserveFactor value larger than 1e27 would cause the _calculateRewardAndDebtDistribution function in the IonPool contract to revert.  Within the IonPool contract:  The mintAndBurnGem, collateral, normalizedDebt, vault, and gem functions do not validate that their ilkIndex arguments are within the supported range. The initialize function does not validate that the value of _underlying token is the WETH token which is assumed loan contracts, specifically the IonHandlerBase contract will assume it has a \"WETH\" interface.  Within the Liquidation contract:  The constructor does not validate that the length of the _maxDiscount array is 3. The constructor does not validate that the _liquidationThresholds values should be non-zero. This is instead checked within the liquidate function. Passing in a zero value for the _liquidationThresholds would result in a contract that will deploy but will not be able to perform liquidations as the liquidate function will always revert. The constructor does not validate that _targetHealth is at least 1 RAY (1e27). A value less than 1e27 would cause the liquidate function to always revert due to an underflow in subtraction in the _getRepayAmt function. The constructor does not validate that the _maxDiscount values are less than 1 RAY (1e27). If a value greater than 1e27 is passed, the contract will deploy correctly but liquidations will always revert due to an underflow within the liquidate function. The constructor does not validate that for each collateral index (i), _targetHealth >= _liquidationThresholds[i] / (RAY - _maxDiscount[i]). This invariant must hold otherwise all liquidations will revert when discount == configs.maxDiscount within the _getRepayAmt function. The _getConfigs function does not validate that the ilkIndex argument is within the expected range.  Within the UniswapFlashswapHandler contract:  The constructor _poolFee argument is not validated to match the fee of the input _pool. This argument can be removed and the fee can be read directly from the UniswapV3Pool contract. The constructor _wethIsToken0 argument should be validated explicitly against the pool or assigned directly from the _pool. The flashswapLeverage function does not validate that resultingAdditionalCollateral >= initialDeposit. The flashswapLeverage function does not validate that sqrtPriceLimitX96 is either 0 or between the current price and MIN_SQRT_RATIO or MAX_SQRT_RATIO (depending on token ordering in the pool). The flashswapDeleverage function does not validate that sqrtPriceLimitX96 is either 0 or between the current price and MIN_SQRT_RATIO or MAX_SQRT_RATIO (depending on token ordering in the pool).  Consider validating the input to all constructors to ensure the contracts cannot be deployed with invalid arguments. A misconfigured contract may cause problems when later attempting to interact with the contract (e.g., liquidate a vault) and could delay performing critical actions. Additionally, ensure input arguments to all functions are properly validated with a preference to fail early and loudly.  Update: Partially resolved in pull request #33. Note that the _getConfigs function of the Liquidation contract still does not validate that the", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Protocol Liquidations Are Not Pausable", "body": "liquidate function is called during a safe pause, the function reverts during the call to the  repayBadDebt function in the  protocol liquidation, this call does not happen as the function  returns early and therefore liquidations will be successful. Allowing liquidations to occur when the  Consider disallowing protocol liquidations when the IonPool is in a safe pause state to prevent unfairly liquidating vaults.  Update: Resolved in pull request #36. A single pause has been implemented which now pauses all liquidations.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#protocol-liquidations-are-not-pausable", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Interest Accrual When No Debt", "body": "return 0 for the timestampIncrease value and the  accruing interest before their debt position is recorded internally, the user will have interest applied on their debt from before their position was opened the next time interest is accrued.  Consider always incrementing the lastRateUpdate timestamp for each ilk when interest is accrued regardless of whether there is debt against the collateral type except when the protocol is in a safe pause state.  Update: Resolved in pull request #21.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#incorrect-interest-accrual-when-no-debt", "labels": ["OpenZeppelin"]}, {"title": "Users May Be Able to Borrow swEth at an Outdated Price", "body": "The getPrice function of SwEthSpotOracle uses a TWAP oracle which means that a sudden change in price would not immediately affect the return value. This value is used in the getSpot function which calculates the spot price as the minimum of the result of getPrice (the TWAP price) and the exchange rate from the ReserveOracle. Using the minimum is a safety mechanism which ensures that the user can only borrow the more pessimistic of the two oracle values.  However, both the reserve oracle and the TWAP oracle have the property that there is a time delay before the price is updated. The reserve oracle is only updated when the updateExchangeRate function is called. If the price of the swEth token decreases as a step function, due to a smart contract failure or large slashing event, both the TWAP oracle and reserve oracle will not update immediately.  Thus, a user could borrow against the swEth token in the IonPool contract using an out-of-date exchange rate. If the price discrepancy is large enough, it would be profitable for an attacker to deposit a large amount of swEth and borrow the maximum allowed amount of WETH which would exceed the value of the collateral after the price has been updated. Since this deposit and borrow can be executed in a single transaction, the protocol is vulnerable to being drained during a depegging event even if the TWAP window is relatively short.  Consider using a price oracle that better reflects price jumps for the swEth token. Alternatively, consider monitoring for sharp price drops and quickly pausing the ability to borrow in this case.  Update: Acknowledged, not resolved. Ion Protocol team stated:  The TWAP range will be chosen carefully to avoid potentially feeding outdated prices while being resilient against short term price manipulations. We will be monitoring the oracle closely for any necessary pauses.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#users-may-be-able-to-borrow-sweth-at-an-outdated-price", "labels": ["OpenZeppelin"]}, {"title": "Locked ETH in Contract", "body": "Throughout the codebase, there are several contracts that include functions that can receive ETH but with no corresponding function for withdrawing ETH. As a result, any ETH sent to these contracts could be permanently lost. In particular:  The constructor of the TransparentUpgradeableProxy contract  The flashLeverageWeth function in the BalancerFlashloanDirectMintHandler contract  The zapDepositWstEth function in the IonZapper contract  Consider removing the payable attribute or adding a withdrawal feature.  Update: Resolved in pull request #23.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#locked-eth-in-contract", "labels": ["OpenZeppelin"]}, {"title": "No Incentive to Perform Protocol Liquidation", "body": "The liquidate function of the Liquidation contract performs a \"protocol\" liquidation when there is insufficient collateral to bring the health ratio of a vault up to the TARGET_HEALTH ratio. In this type of liquidation, the PROTOCOL address receives the collateral from the underwater vault and is responsible for repaying the bad debt. During a liquidation in which the vault does have enough collateral to bring its health ratio back to TARGET_HEALTH, the caller pays off the debt of the vault by transferring WETH to the contract, and the keeper (specified by the caller) receives the vault's collateral at a discount such that liquidating the vault is profitable to the caller. Since a protocol liquidation does not transfer discounted collateral to the caller, there is no incentive for anyone to perform a protocol liquidation.  Consider providing an incentive to users to perform protocol liquidations to ensure they are done in a timely manner.  Update: Acknowledged, not resolved. Ion Protocol team stated:  This is known and by design. We would not consider this a vulnerability. The option for protocol liquidation exists as a fallback path where the liquidator pays the gas fees for transferring the vault's bad debt to the protocol balance sheet. Vaults that are already in bad debt do not need to be liquidated by searchers and therefore doesn't require incentives.  In more detail:  Protocol liquidations are liquidations where there is not enough collateral to be sold at the discounted price to reach the target health ratio. If theres bad debt in the position (debt that cant be paid off with collateral), there is also no profitable path for the liquidator, and we do not expect a searcher to call an unprofitable trade.  The protocol liquidation logical path only exists such that if for some reason a searcher tries to liquidate a position that is in bad debt, it will simply automatically transfer this bad debt to the badDebt variable in IonPool such that the unprofitable searcher pays for the gas cost of transferring badDebt instead of governance having to manually call the transaction.  The alternative option is to simply not do anything about this when bad debt forms, but we decided to add this fallback to automatically transfer bad debt to the balance sheet without paying for gas.  We see this as extra utility for the governance and therefore not a vulnerability.  Low Severity", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#no-incentive-to-perform-protocol-liquidation", "labels": ["OpenZeppelin"]}, {"title": "Lack of Validation of Treasury Address Could Halt Contract", "body": "updateTreasury function of the  _mintNormalized function in the  _accrueInterest and  _accrueInterestForIlk functions in the  Consider validating that the treasury address is not the zero address in both the _initialize and updateTreasury functions in the RewardModule contract.  Update: Resolved in pull request #29.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#lack-of-validation-of-treasury-address-could-halt-contract", "labels": ["OpenZeppelin"]}, {"title": "Interest Not Accrued Prior to Withdrawing or Depositing Collateral", "body": "Within the IonPool contract, the depositCollateral and withdrawCollateral functions allow users to deposit or withdraw collateral from a vault. These functions do not accrue interest prior to modifying the collateral balance within the vault. This would allow a user to withdraw collateral from a vault that would have been unhealthy had interest been accrued prior to the withdrawal. Additionally, it would prevent a user from depositing collateral into their vault if their debt position is dusty but would no longer be dusty after accruing interest.  Consider accruing interest prior to all operations that affect the collateral and debt in vaults.  Update: Resolved in pull request #27.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#interest-not-accrued-prior-to-withdrawing-or-depositing-collateral", "labels": ["OpenZeppelin"]}, {"title": "Floating Pragma", "body": "Pragma directives should be fixed to clearly identify the Solidity version with which the contracts will be compiled.  Throughout the codebase, there are multiple floating pragma directives:  The file ProxyAdmin.sol has the solidity ^0.8.20 floating pragma directive.  The file TransparentUpgradeableProxy.sol has the solidity ^0.8.20 floating pragma directive.  The file WadRayMath.sol has the solidity ^0.8.0 floating pragma directive.  Consider using a fixed Solidity version throughout the codebase.  Update: Acknowledged, not resolved. Ion Protocol team stated:  This is intended. Will not fix.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#floating-pragma", "labels": ["OpenZeppelin"]}, {"title": "Liquidations May Use Outdated Reserve Oracle Exchange Rate", "body": "The liquidate function of the Liquidation contract does not update the reserve oracle exchange rate prior to liquidating a vault. This could result in a vault being falsely liquidated that should not be liquidatable based on the current exchange rate from the reserve oracle had the rate been updated. Furthermore, it could lead to a keeper attempting to liquidate a vault and the liquidation failing due to the vault not being liquidatable based on the out-of-date exchange rate.  Consider updating the reserve oracle exchange rate within the liquidate function prior to liquidation calculations.  Update: Acknowledged, not resolved. Ion Protocol team stated:  This is intended. We want a delay between the exchange rate used by the protocol and the true exchange rate. The delay allows the protocol to bound the reported exchange rate and respond with emergency measures in the case of serious malfunction from the liquid staking provider's exchange rate oracle.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#liquidations-may-use-outdated-reserve-oracle-exchange-rate", "labels": ["OpenZeppelin"]}, {"title": "Missing or Incomplete Docstrings", "body": "Throughout the codebase, many of the contracts have missing or incomplete docstrings. There are also several docstrings that either do not document all arguments, do not document any arguments, or do not document the return values.  There are no docstrings in the public interface of the IonZapper contract, the IonRegistry contract, or the ReserveFeed contract.  The RewardModule contract is missing @notice and @return docstrings for most functions  The InterestRate contract is missing @notice and @return docstrings for the function calculateInterestRate  The IonPool contract is missing @notice docstrings for many public interface functions.  The YieldOracle contract is missing @notice docstrings for the updateAll function.  The IonHandlerBase contract is missing @notice docstrings for the repayAndWithdraw function.  The UniswapFlashloanBalancerSwapHandler contract is missing @notice docstrings for the flashDeleverageWethAndSwap function.  The LidoLibrary, StaderLibrary, and SwellLibrary contracts, as well as accompanying EthXHandler, SwEthHandler and WstEthHandler contracts, while containing internal functions, have almost no documentation whatsoever.  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Acknowledged, will resolve. Ion Protocol team stated:  The documentation will be reviewed and edited post-audit to include all up-to-date information.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#missing-or-incomplete-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Infinite Loop Prevents Interest Accrual", "body": "_accrueInterest function of the  for-loop on lines 384-405 will never terminate preventing interest accrual. This would additionally prevent the contract from being safe paused with the  Consider either explicitly preventing the contract from having 256 or more collateral types in the initializeIlk function, or using a larger type for the loop index variable.  Update: Resolved in pull request #26.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#infinite-loop-prevents-interest-accrual", "labels": ["OpenZeppelin"]}, {"title": "Users Cannot Deposit Collateral into a Dusty Vault", "body": "Within the IonPool contract, users are unable to deposit collateral into their vault if their vault is dusty. This would prevent users from adding collateral to their vault which could allow them to increase their borrow amount above the dusty threshold.  Since adding collateral is a \"safe\" action, consider allowing users to deposit collateral into their vault regardless of whether their vault is dusty.  Update: Acknowledged, not resolved. Ion Protocol team stated:  If the protocol raises the dust value over a position's current borrow amount, then the user can close their position first and reopen the position again. Not fixed as it is an unlikely scenario and no users are at risk.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#users-cannot-deposit-collateral-into-a-dusty-vault", "labels": ["OpenZeppelin"]}, {"title": "Functions Return Inaccurate Values Without Interest Accrual", "body": "Several view functions in the IonPool and RewardModule contracts return inaccurate values as they do not accrue interest prior to being called.  The balanceOf function  The totalSupply function  The supplyFactor function  The rate function  The debt function  The getCurrentBorrowRate function  The normalizedTotalSupply function  This can lead to difficulties for users who are interacting with the protocol. In particular, if a user wants to withdraw their entire underlying balance, they would expect that calling withdraw(msg.sender, balanceOf(msg.sender)) would withdraw their entire balance but it would not.  In addition, if a user wants to borrow a fixed amount of WETH (amountOfWETH), they would expect that calling borrow(ilkIndex, msg.sender, msg.sender, amountOfWETH / rate(), proof) would result in borrowing exactly amountOfWETH WETH but due to an out-of-date rate value they would receive less WETH than expected.  Moreover, if a user wants to repay their debt and only wants to approve the exact amount of WETH to be transferred from their wallet, the approved amount would be less than what would be required after accruing interest.  Consider implementing functions that will return the correct up-to-date state of the contract for the aforementioned view functions such that their resulting output will be accurate. These functions may be called something like getAccrued... in order to allow the previous functions to remain useful for internal integrations without breaking functionality. We also suggest carefully checking all calls to each of these functions to determine if they should be swapped out for an up-to-date version.  Update: Resolved in pull request #30.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#functions-return-inaccurate-values-without-interest-accrual", "labels": ["OpenZeppelin"]}, {"title": "The YieldOracle Contract Returns Stale Data After Price Decrease", "body": "assumes that the exchange rates are monotonically increasing. Thus, if there is ever a decrease in the exchange rate of one of the tokens (e.g., due to slashing), the  Consider implementing a mechanism to return appropriate exchange rates and apys immediately after a price decrease and enable the YieldOracle to begin returning accurate data once the 1-week look-back window has passed.  Update: Resolved in pull request #31.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#the-yieldoracle-contract-returns-stale-data-after-price-decrease", "labels": ["OpenZeppelin"]}, {"title": "ERC-20 Transfer Should Occur Before Updating Internal State", "body": "join function of the  updates the internal totalGem balance, and mints gem to the user account in the IonPool contract prior to transferring the  Though this problem does not exist for the currently planned collateral types, consider moving the token transfer before updating any internal accounting to better implement defensive coding practices and prevent exploits in the future when more collaterals are added, or current collaterals are upgraded.  Update: Acknowledged, not resolved. Ion Protocol team stated:  The protocol should not be supporting hook tokens. Will not fix.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#erc-20-transfer-should-occur-before-updating-internal-state", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Check in BalancerFlashloanDirectMintHandler", "body": "In the receiveFlashLoan function of the BalancerFlashLoanDirectMindHandler contract, there is a check comparing the LST amount minted to the maximum WETH-denominated debt.  This check is incorrect as it compares two different tokens' amounts. It happens to work for the current collaterals as they have 18 decimals and are more valuable than WETH, so a certain value of LST will generally be less than the corresponding value of WETH. However, in the case that the LST loses value, or a new LST is onboarded with more LST corresponding to a certain amount of WETH, this check may fail, causing the flashLeverageWeth function to be uncallable.  In addition, note that the intention of this check is redundant with the check on line 129, where both variables being compared are denominated in WETH, and prevents the maxResultingDebt from being exceeded.  Consider removing the identified check to avoid failure in the described cases and to improve the readability and maintainability of the code.  Update: Resolved in pull request #24.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#incorrect-check-in-balancerflashloandirectminthandler", "labels": ["OpenZeppelin"]}, {"title": "Whitelist Can Be Bypassed for New Collateral Type", "body": "The Whitelist contract validates borrowers against a whitelist for each collateral type using the isWhitelistedBorrower function. This function never validates that the input ilkIndex is within the expected range of indices and will default to returning true for an invalid index. If a new collateral type were added to the IonPool contract before updating the whitelist to support it, this would allow anyone to borrow against the new collateral type, bypassing the whitelist.  Consider validating that the input ilkIndex to the isWhitelistedBorrower function is within the expected range for the deployed instance of the Whitelist contract.  Update: Acknowledged, not resolved. Ion Protocol team stated:  Not fixed as the code works as intended. A new collateral type by default should not have a whitelist. A whitelist should only apply to a new collateral type if explicitly set by the protocol. The fix would alter this behavior to apply whitelist to all new collateral types which is not the intention.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#whitelist-can-be-bypassed-for-new-collateral-type", "labels": ["OpenZeppelin"]}, {"title": "Functions and variables should be private", "body": "Throughout the codebase, there are internal functions and state variables that could use private visibility as they either use complex storage patterns, or are only ever called from the base contract they are implemented in. In particular:  The ILKCONFIG variables in the InterestRate contract as the data stored in these variables should only ever be read using the _unpackCollateralConfig function.  The _packCollateralConfig function in the InterestRate contract as this function is only ever called by the constructor and writes to immutable variables.  Consider reducing the visibility of these functions and variables to ensure they are only used in the correct context.  Update: Resolved in pull request #35.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#functions-and-variables-should-be-private", "labels": ["OpenZeppelin"]}, {"title": "Unreachable Code", "body": "Within the _modifyPosition function in the IonPool contract, the check for an uninitialized ilk will never cause execution to revert since passing an invalid ilkIndex will revert when accessing the rate.  Consider removing this unreachable code.  Update: Acknowledged, not resolved. Ion Protocol team stated:  Acknowledged, but not fixed in this audit.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#unreachable-code", "labels": ["OpenZeppelin"]}, {"title": "\"Magic\" Values are Used", "body": "Throughout the codebase, magic numbers are used. In particular:  On lines 203, and 492 of IonPool.sol.  On lines 29, 192, 232, and 259 of UniswapFlashloanBalancerSwapHandler.sol.  On line 12 of BalancerFlashloanDirectMintHandler.sol.  Following Solidity's style guide, consider defining constant variables to represent these numbers to help developers and auditors understand the intention of the code. These variables will also make future modifications to the code easier by localizing needed changes to a single spot.  Update: Partially resolved in pull request #34. Only the first three instances from the second bullet point have been fixed.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#\"magic\"-values-are-used", "labels": ["OpenZeppelin"]}, {"title": "Missing Arguments for Events", "body": "Throughout the codebase, there are several events that would benefit from including additional arguments. In particular:  Several events in the IonPool contract should include the ilkIndex as an argument as the events are emitted when only a specific ilk is updated.  The Liquidate event in the Liquidation contract should include the msg.sender.  Consider adding these additional arguments to these events to make it clear under what context the events are emitted.  Update: Partially resolved in pull request #35. Ion Protocol team stated:  This was partially fixed, only Liquidate event was altered. Fixes for IonPool events will come after the audit since they are housed in pull request #17.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#missing-arguments-for-events", "labels": ["OpenZeppelin"]}, {"title": "Redundant Argument for Error", "body": "The invalidWhitelist argument for the InvalidWhitelist error is unnecessary as it will always be the zero-address.  Consider removing this redundant argument.  Update: Resolved in pull request #35.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#redundant-argument-for-error", "labels": ["OpenZeppelin"]}, {"title": "Constants Not Using UPPER_CASE Format", "body": "Throughout the codebase, there are constants not using UPPER_CASE format. For instance:  The IonPausableStorageLocation constant in the IonPausableUpgradeable contract  The IonPoolStorageLocation constant in the IonPool contract  The RewardModuleStorageLocation constant in the RewardModule contract  According to the Solidity Style Guide, constants should be named with all capital letters with underscores separating words. For better readability, consider following this convention.  Update: Acknowledged, not resolved. Ion Protocol team stated:  Will not fix. This is intended.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#constants-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "Throughout the codebase, there are multiple imports that are unused and could be removed. For instance:  The SafeCast import in ReserveOracle.sol  The WadRayMath import in EthXReserveOracle.sol  The WadRayMath import in StaderLibrary.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #35.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Todo Comments in the Code", "body": "During development, having well described TODO/Fixme comments will make the process of tracking and solving them easier. Without this information these comments might age and important information for the security of the system might be forgotten by the time it is released to production. These comments should be tracked in the project's issue backlog and resolved before the system deploy.  The following instance of TODO/Fixme comments were found:  TODO comment on line 122 in UniswapFlashswapHandler.sol.  Consider removing all instances of TODO/Fixme comments and instead tracking them in the issues backlog. Alternatively, consider linking each inline TODO/Fixme to the corresponding issues backlog entry.  Update: Resolved in pull request #33.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#todo-comments-in-the-code", "labels": ["OpenZeppelin"]}, {"title": "Multiple Instances of Missing Named Parameters in Mappings", "body": "Since Solidity 0.8.18, developers can utilize named parameters in mappings. This means mappings can take the form of mapping(KeyType KeyName? => ValueType ValueName?). This updated syntax provides a more transparent representation of the mapping's purpose.  Throughout the codebase, there are multiple mappings without named parameters. For instance:  The protocolWhitelist mapping in the Whitelist contract.  The borrowersRoot mapping in the Whitelist contract.  The unbackedDebt mapping in the IonPool contract.  The isOperator mapping in the IonPool contract.  The _normalizedBalances mapping in the RewardModule contract.  Consider adding named parameters to the mappings to improve readability and maintainability of the code.  Update: Resolved in pull request #35.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#multiple-instances-of-missing-named-parameters-in-mappings", "labels": ["OpenZeppelin"]}, {"title": "Unused Errors", "body": "Throughout the codebase, there are unused errors. For instance:  The TotalDebtsLength error in InterestRate.sol  The SpotUpdaterNotAuthorized error in IonPool.sol  The ExternalUniswapFlashloanNotAllowed error in UniswapFlashloanBalancerSwapHandler.sol  The ExternalFlashswapNotAllowed error in UniswapFlashswapHandler.sol  The InsufficientBalance error in UniswapFlashswapHandler.sol  The InvalidConstructorArguments error in Whitelist.sol  The InvalidWhitelistMerkleProof error in Whitelist.sol  To improve the overall clarity, intentionality, and readability of the codebase, consider either using or removing any currently unused errors.  Update: Resolved in pull request #35.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#unused-errors", "labels": ["OpenZeppelin"]}, {"title": "Functions Are Updating the State Without Event Emissions", "body": "Throughout the codebase, instances of functions that are updating the state without an event emission were found. For instance:  The constructor function in the Whitelist contract.  The updateBorrowersRoot function in the Whitelist contract.  The updateLendersRoot function in the Whitelist contract.  The approveProtocolWhitelist function in the Whitelist contract.  The revokeProtocolWhitelist function in the Whitelist contract.  The _initializeExchangeRate function in the ReserveOracle contract.  The updateIonPool function in the YieldOracle contract.  The _setSupplyFactor function in the RewardModule contract.  The flashLeverageCollateral function in the BalancerFlashloanDirectMintHandler contract.  The flashLeverageWeth function in the BalancerFlashloanDirectMintHandler contract.  The join function in the GemJoin contract.  The exit function in the GemJoin contract.  The setGemJoin function in the IonRegistry contract.  The setDepositContract function in the IonRegistry contract.  The setExchangeRate function in the ReserveFeed contract.  Consider emitting events whenever there are state changes to make the codebase less error prone and improve its readability.  Update: Partially resolved in pull request #35. Ion Protocol team stated:  Partially fixed, the event was only added in the _initializeExchangeRate function of the ReserveOracle contract).", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#functions-are-updating-the-state-without-event-emissions", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Use Named Returns", "body": "There are multiple contracts throughout the codebase that have inconsistent usage of named returns in their functions. For instance:  The InterestRate contract  The IonPool contract  The ReserveOracle contract  Consider consistently using either named or unnamed returns for all functions in each contract.  Update: Acknowledged, not resolved. Ion Protocol team stated:  Acknowledged, but not changed in this audit.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#inconsistent-use-named-returns", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Variable Casts", "body": "Throughout the codebase, there are multiple functions that have variables that are unnecessarily cast. For instance:  The FEED0 variable in the _aggregate function in the ReserveOracle contract.  The FEED0 variable in the _aggregate function in the ReserveOracle contract.  The FEED1 variable in the _aggregate function in the ReserveOracle contract.  The FEED0 variable in the _aggregate function in the ReserveOracle contract.  The FEED1 variable in the _aggregate function in the ReserveOracle contract.  The FEED2 variable in the _aggregate function in the ReserveOracle contract.  The RESERVE_ORACLE variable in the getSpot function in the SpotOracle contract.  The assetIn variable in the _simulateGivenOutBalancerSwap function in the UniswapFlashloanBalancerSwapHandler contract.  The assetOut variable in the _simulateGivenOutBalancerSwap function in the UniswapFlashloanBalancerSwapHandler contract.  The ethPerStEth variable in the getPrice function in the WstEthSpotOracle contract.  The wstEth variable in the getLstAmountOutForEthAmountIn function in the LidoLibrary library.  The result of ReserveOracle(configs.reserveOracle).currentExchangeRate() in the liquidate function in the Liquidation contract.  To improve the overall clarity, intent, and readability of the codebase, consider removing unnecessary casts.  Update: Resolved in pull request #35.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#unnecessary-variable-casts", "labels": ["OpenZeppelin"]}, {"title": "Unused Variables", "body": "Throughout the codebase, there are multiple unused variables. For instance:  The FACTORY state variable in the UniswapFlashswapHandler contract.  The POOL_FEE state variable in the UniswapFlashswapHandler contract.  The ethXDecimals free variable in EthXReserveOracle.sol.  The PROVIDER_PRECISION free variable in YieldOracle.sol.  The reserveOracle variable in the _getConfigs function in the Liquidation contract.  To improve the overall clarity, intentionality, and readability of the codebase, consider removing any unused variables.  Update: Partially resolved in pull request #35. All identified instances have been removed except for PROVIDER_PRECISION.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#unused-variables", "labels": ["OpenZeppelin"]}, {"title": "State Variable Visibility Not Explicitly Declared", "body": "Throughout the codebase, there are state variables that lack an explicitly declared visibility. For instance:  The STADER_DEPOSIT state variable in EthXHandler.sol  The REDSTONE_ETHX_PRICE_FEED state variable in EthXSpotOracle.sol  The USD_PER_ETH_CHAINLINK state variable in EthXSpotOracle.sol  The WETH state variable in IonHandlerBase.sol  The ILK_INDEX state variable in IonHandlerBase.sol  The POOL state variable in IonHandlerBase.sol  The JOIN state variable in IonHandlerBase.sol  The LST_TOKEN state variable in IonHandlerBase.sol  The WHITELIST state variable in IonHandlerBase.sol  The POOL state variable in SwEthSpotOracle.sol  The SECONDS_AGO state variable in SwEthSpotOracle.sol  The WETH_IS_TOKEN0_ON_UNISWAP state variable in UniswapFlashloanBalancerSwapHandler.sol  The FACTORY state variable in UniswapFlashswapHandler.sol  The UNISWAP_POOL state variable in UniswapFlashswapHandler.sol  The WETH_IS_TOKEN0 state variable in UniswapFlashswapHandler.sol  The POOL_FEE state variable in UniswapFlashswapHandler.sol  The ST_ETH_TO_ETH_CHAINLINK state variable in WstEthSpotOracle.sol  The WST_ETH state variable in WstEthSpotOracle.sol  For clarity, consider always explicitly declaring the visibility of variables, even when the default visibility matches the intended visibility.  Update: Resolved in pull request #35.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#state-variable-visibility-not-explicitly-declared", "labels": ["OpenZeppelin"]}, {"title": "Lack of Security Contact", "body": "Providing a specific security contact (such as an email or ENS name) within a smart contract significantly simplifies the process for individuals to communicate if they identify a vulnerability in the code. This practice proves beneficial as it permits the code owners to dictate the communication channel for vulnerability disclosure, eliminating the risk of miscommunication or failure to report due to lack of knowledge on how to do so. Additionally, if the contract incorporates third-party libraries and a bug surfaces in these, it becomes easier for the maintainers of those libraries to make contact with the appropriate person about the problem and provide mitigation instructions.  Security contact information is omitted throughout the codebase.  Consider adding a NatSpec comment containing a security contact on top of the contracts definition. Using the @custom:security-contact convention is recommended as it has been adopted by the OpenZeppelin Wizard and the ethereum-lists.  Update: Acknowledged, will resolve. Ion Protocol team stated:  Acknowledged, security contract will be added post-audit.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#lack-of-security-contact", "labels": ["OpenZeppelin"]}, {"title": "Unused Named Return Variables", "body": "Named return variables are a way to declare variables that are meant to be used within a function body for the purpose of being returned as the function's output. They are an alternative to explicit in-line return statements.  Throughout the codebase, there are multiple instances of unused named return variables. For instance:  The newTotalDebt return variable in the accrueInterest function in IonPool.sol.  The supplyFactorIncrease return variable in the calculateRewardAndDebtDistribution function in IonPool.sol.  The treasuryMintAmount return variable in the calculateRewardAndDebtDistribution function in IonPool.sol.  The newRateIncrease return variable in the calculateRewardAndDebtDistribution function in IonPool.sol.  The newDebtIncrease return variable in the calculateRewardAndDebtDistribution function in IonPool.sol.  The newTimestampIncrease return variable in the calculateRewardAndDebtDistribution function in IonPool.sol.  The priceX96 return variable in the _getPriceX96FromSqrtPriceX96 function in SwEthSpotOracle.sol.  Consider either using or removing any unused named return variables.  Update: Partially resolved in pull request #35. The identified instances in IonPool.sol have not been fixed.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#unused-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Unsafe and Safe Pauses and Unpauses Should Occur Simultaneously", "body": "The IonPausableUpgradeable contract defines two separate pause states and is used by the IonPool contract. The states are:  Safe pause where safe actions are disabled including depositing collateral, moving collateral into a vault, repaying debt, and accruing interest.  Unsafe pause where unsafe actions are disabled including withdrawing collateral from a vault, transferring collateral between vaults, borrowing, and withdrawing collateral.  The IonPool contract currently allows for any combination of these pause states. If the contract were to be in a state where safe actions were paused, and unsafe actions were not paused, users would be able to take on additional debt, and transfer collateral out of their vault, both of which would put their vault into a less healthy position but there would be no way for users to make their vault more healthy.  Consider only allowing safe actions to be paused when unsafe actions are also paused.  Update: Acknowledged, will resolve. Ion Protocol team stated:  Unsafe and Safe pauses were combined to form a single protocol-wide pause.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#unsafe-and-safe-pauses-and-unpauses-should-occur-simultaneously", "labels": ["OpenZeppelin"]}, {"title": "Missing EIP-7201 Annotation", "body": "EIP-7201 defines a namespaced storage layout to prevent storage collisions for modular contracts. The EIP defines the @custom:storage-location NatSpec annotation that should annotate the storage struct in a contract. Several contracts throughout the codebase that implement EIP-7201 lack this annotation. In particular:  The IonPausableStorage struct in the IonPausableUpgradeable contract  The RewardModuleStorage struct in the RewardModule contract  The IonPoolStorage struct in the IonPool contract  Consider annotating the storage structs in these contracts with @custom:storage-location.  Update: Resolved in pull request #35.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#missing-eip-7201-annotation", "labels": ["OpenZeppelin"]}, {"title": "Coding Style Deviates from Solidity Style Guide", "body": "There are several files throughout the codebase that deviate from the recommended Solidity Style Guide. In particular:  Within the ReserveOracle contract there are functions defined before the constructor.  Within the Liquidation contract the Configs and the LiquidationArgs structs are defined between functions.  Within the UniswapFlashswapHandler contract, the FlashswapData struct is defined after the constructor.  Within the UniswapFlashloanBalancerSwapHandler contract, the FlashCallbackData struct is defined between functions.  To favor readability, consider always following a consistent style throughout the codebase.  Update: Partially resolved in pull request #35. Ion Protocol team stated:  Partially fixed, functions were moved below constructor but structs in between functions will not be moved.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#coding-style-deviates-from-solidity-style-guide", "labels": ["OpenZeppelin"]}, {"title": "No Method To Determine Last Update to Reserve Oracles", "body": "The reserve oracle contracts track the latest exchange rate between a LST and ETH and each instance inherits from the abstract ReserveOracle contract. The updateExchangeRate function is used to update the currentExchangeRate state variable to reflect the latest exchange rate however there is no variable that tracks the last timestamp that the exchange rate was updated at.  Consider tracking the last timestamp that exchange rate was last updated at to allow users to easily query whether the exchange rate is up-to-date.  Update: Resolved in pull request #32.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#no-method-to-determine-last-update-to-reserve-oracles", "labels": ["OpenZeppelin"]}, {"title": "Abstract Contracts Allow Direct Modification of State Variables", "body": "The currentExchangeRate state variable in the abstract ReserveOracle tracks the most recent exchangeRate between an LST and ETH. Since this variable uses public visibility within an abstract contract, a child contract would be able to directly modify this value.  Consider using private visibility for all non-constant and non-immutable state variables in abstract contracts. If child contracts should be able to update values for the state variables, consider creating internal functions for updating these variables which emit appropriate events and verify that desirable conditions are met.  Update: Acknowledged, not resolved. Ion Protocol team stated:  Acknowledged but not fixed in this audit.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#abstract-contracts-allow-direct-modification-of-state-variables", "labels": ["OpenZeppelin"]}, {"title": "public Functions That Should Have external Visibility", "body": "The following public functions should be external:  The updateExchangeRate function in the ReserveOracle contract.  The ilkCount function in the IonPool contract.  The getIlkIndex function in the IonPool contract.  The getIlkAddress function in the IonPool contract.  The addressContains function in the IonPool contract.  The addressesLength function in the IonPool contract.  The getCurrentBorrowRate function in the IonPool contract.  Consider changing the visibility of these functions to external in order to clarify that these functions will only be called by external contracts.  Update: Resolved in pull request #35.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#public-functions-that-should-have-external-visibility", "labels": ["OpenZeppelin"]}, {"title": "Variables could be immutable", "body": "Throughout the codebase, there are several variables that could be immutable. For instance:  The protocolFeed variable in the EthXReserveOracle contract.  The protocolFeed variable in the SwEthReserveOracle contract.  To better convey the intended use of variables and to potentially save gas, consider adding the immutable keyword to variables that are only set in the constructor.  Update: Partially resolved in pull request #35. Only the instance in SwEthReserveOracle has been fixed.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#variables-could-be-immutable", "labels": ["OpenZeppelin"]}, {"title": "Naming Issues Hinder Code Understanding and Readability", "body": "Throughout the codebase, there are several functions and variables that could be renamed to better reflect their purpose, in particular:  The _getPriceX96FromSqrtPriceX96 function in the SwEthSpotOracle contract with named return priceX96 implies that it returns an \"X96\" (base 2**96) price when it returns a \"WAD\" price (base 10**18).  The ADDRESS0, ADDRESS1, and ADDRESS2 public state variables in the YieldOracle contract.  The from and to arguments of the AddOperator and RemoveOperator events are unclear which argument corresponds to the user and which is the operator.  The sender argument for the InsufficientBalance error is the account with an insufficient balance and is not necessarily the account making the call.  The amountIn argument of the _simulateGivenOutBalancerSwap function in the UniswapFlashloanBalancerSwapHandler contract should be named amountOut, since it represents an amount \"out\" from the Balancer swap.  Consider addressing these naming issues to improve the readability of the codebase.  Update: Partially resolved in pull request #35. All instances except those in YieldOracle have been fixed.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#naming-issues-hinder-code-understanding-and-readability", "labels": ["OpenZeppelin"]}, {"title": "Interfaces should be used for type definitions", "body": "Throughout the codebase, contract types are used for external contracts that could be upgraded or changed. If the contracts will be verified on a block explorer, and any of these external contracts are later updated, the verified code would be misleading.  In particular:  The Whitelist contract within the IonPool contract  The InterestRate contract within the IonPool contract  The SpotOracle contract within the IonPool contract  Consider defining implementation-agnostic interfaces that define the expected functionality these contracts will implement and using these for the types. This will prevent old contract code from being treated as current on block explorers after these contracts have been upgraded.  Update: Acknowledged, not resolved. Ion Protocol team stated:  Acknowledged, but was not fixed in this audit as we do not foresee these contract interfaces changing in the future.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#interfaces-should-be-used-for-type-definitions", "labels": ["OpenZeppelin"]}, {"title": "Redundant Functions", "body": "The ilkCount and addressesLength functions in the IonPool contract are redundant as they will always return the same value. Consider removing one of these redundant functions.  Update: Resolved in pull request #35. Note that the addressesLength function has been removed.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#redundant-functions", "labels": ["OpenZeppelin"]}, {"title": "Inefficiency in _depositAndBorrow", "body": "Within the clause for if(amountToBorrow != 0), there is only the borrow call. Since the computations for normalized borrow amount will not be used if amountToBorrow == 0, consider moving them inside this clause.  Update: Resolved in pull request #35.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#inefficiency-in-_depositandborrow", "labels": ["OpenZeppelin"]}, {"title": "Inefficiency in flashLeverageCollateral", "body": "In the flashLeverageCollateral function, the case where amounts[0] == 0 signifies that there is no leverage needed.  Since amounts[0] == amountToLeverage, consider moving this check up to right after amountToLeverage is determined.  Update: Resolved in pull request #35.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#inefficiency-in-flashleveragecollateral", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "Consider correcting the following typographical errors to improve the readability of the codebase:  On line 15 of IonPausableUpgradeable.sol, \"Depnding\" should be \"Depending\".  On line 25 of SwEthReserveOracle.sol, \"Swel\" should be \"Swell\".  On line 114 of UniswapFlashswapHandler.sol, \"sandwhich\" should be \"sandwich\".  On line 136 of IonPool.sol, \"Total unbacked Dai\" should be \"Total unbacked WETH\".  Update: Partially resolved in pull request #35. All instances except the last bullet have been fixed.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Misleading and Inaccurate Documentation", "body": "Throughout the codebase, misleading and inaccurate documentation was identified. In particular:  The docstring for the IonPausableUpgradeable contract states that there are three pause states when the contract only contains two.  The docstring for the _aggregate function in the ReserveOracle contract states that it calculates the minimum of the exchange rates returned from the reserve feeds when the function returns the average.  The docstring for the _aggregate function in the ReserveOracle contract states that it will revert if the quorum isn't met when the function will only revert if calling getExchangeRate on one of the reserve feeds reverts.  The docstring for the getPrice function in the EthXSpotOracle contract states that the Redstone oracle returns 6 decimal places when it returns 8.  The comments on lines 45 and 46 in EthXSpotOracle.sol state that these are for the price of stETH in ETH when it is the price of ETH in USD.  The docstrings for the updateExchangeRate and getExchangeRate functions in the IReserveFeed interface state that the functions update and get the total reserve when they update and get the exchange rate of the asset against ETH.  The inline documentation for the IlkData struct in InterestRate.sol document how the values are packed into the ILKCONFIG variables but does not align with how the values are packed in memory within the struct. Specifically, the reserveFactor value would be part of the first word for the packed struct.  The documentation for the kpr argument to the liquidate function in the Liquidation contract states that it is the payer of the debt when the payer of debt is msg.sender.  The comment on line 167 of Liquidation.sol states that the exchange rate is returned as a uint72 type when it is a uint256 type.  The comments on lines 73, 74, 92, and 123 of UniswapFlashswapHandler.sol state that the token is \"swEth\" when it is used for both swEth and wstEth.  Consider clarifying all in-line documentation to ensure developers and auditors understand the intended purpose of the code.  Update: Acknowledged, will resolve. Ion Protocol team stated:  The documentation will be reviewed and edited post-audit to include all up-to-date information.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#misleading-and-inaccurate-documentation", "labels": ["OpenZeppelin"]}, {"title": "Interfaces With the Same Name", "body": "Throughout the codebase, there are instances of more than one interface with the same name. For instance:  The IWstEth interface in ProviderInterfaces.sol  The IWstEth interface in WstEthSpotOracle.sol  Consider renaming the interfaces to avoid unexpected behavior and improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #35.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#interfaces-with-the-same-name", "labels": ["OpenZeppelin"]}, {"title": "Gas Optimization By Directly Querying External Variable", "body": "using the getExchangeRate function. The  Consider directly querying the exchangeRate variable from the StaderOracle instead of calling the getExchangeRate function.  Update: Acknowledged, not resolved. Ion Protocol team stated:  The EthxReserveOracle contract's public exchange rate variable stores the exchange rate that is delayed and bounded for oracle security. The library queries real time exchange rate through the getter as it should operate on the up to date exchange rate and not the bounded exchange rate. Will not fix.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#gas-optimization-by-directly-querying-external-variable", "labels": ["OpenZeppelin"]}, {"title": "Over-Constrained Check in UniswapFlashswapHandler", "body": "Within the UniswapFlashswapHandler contract, the two functions flashswapLeverage and flashswapDeleverage are designed to change a user's leverage by a specified amount.  Within both of these functions, there is a check which reverts only if the amount received is not the expected output and the sqrtPriceLimitX96 is unspecified (equal to 0). Since it is intended that amountOutReceived be exactly equal to amountOut in all cases, this check can remove the conditional regarding sqrtPriceLimitX96.  sqrtPriceLimitX96 check is applied within Uniswap. Also consider moving the check before the  _depositAndBorrow or  _repayAndWithdraw function calls, to follow the fail-early-and-loudly principle and help users understand when their transactions fail. Though these calls should fail if the desired amount out is not obtained (due to failures within  _depositAndBorrow or  _repayAndWithdraw), they may not fail if there are already tokens in the  Update: Resolved in pull request #28.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#over-constrained-check-in-uniswapflashswaphandler", "labels": ["OpenZeppelin"]}, {"title": "Client-Reported", "body": "Client-Reported", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#client-reported", "labels": ["OpenZeppelin"]}, {"title": "Borrow Actions Continue to Accrue Interest During Pause", "body": "When the IonPool contract is in a safe pause state, interest is not intended to be accrued for vaults as the functionality for repaying debt is disabled. The _accrueInterest function prevents interest accrual during a safe pause by returning early. However, the _accrueInterestForIlk function does not implement the same logic and will allow for interest accrual during a safe pause state. As a result, when a user borrows against their collateral, interest will be accrued for all vaults for the corresponding collateral type.  Consider disallowing interest accrual within the _accrueInterestForIlk function during a safe pause as is done in the _accrueInterest function.  Update: Resolved in pull request #27.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#borrow-actions-continue-to-accrue-interest-during-pause", "labels": ["OpenZeppelin"]}, {"title": "Missing Return Value Check for ERC-20 Transfer", "body": "Throughout the codebase, there are missing return value checks for ERC-20 transfers:  At line 189 of BalancerFlashloanDirectMintHandler.sol  At line 132 of IonHandlerBase.sol  At line 212 or UniswapFlashloanBalancerSwapHandler.sol  At line 242 of UniswapFlashloanBalancerSwapHandler.sol.  Consider validating the return value from these ERC-20 transfers or using the SafeERC20 library to ensure that transfers have been successful.  Update: Resolved in pull request #22.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#missing-return-value-check-for-erc-20-transfer", "labels": ["OpenZeppelin"]}, {"title": "Flash Leverage Contracts Lack Whitelist Checks", "body": "The UniswapFlashloanBalancerSwapHandler, BalancerFlashloanDirectMintHandler and UniswapFlashswapHandler contracts do not contain the onlyWhitelistedBorrowers and onlyWhitelistedLenders modifiers. As a result, even users who are not whitelisted can create positions in the vault.  Consider adding the onlyWhitelistedBorrowers modifier to the functions in the flash leverage contracts. Changing the whitelisting modifiers in the IonPool contract to check user rather than msg.sender would also prevent non-whitelisted users from opening positions.  Update: Resolved in pull request #25.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#flash-leverage-contracts-lack-whitelist-checks", "labels": ["OpenZeppelin"]}, {"title": "Recommendations", "body": "Recommendations", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#recommendations", "labels": ["OpenZeppelin"]}, {"title": "Testing", "body": "Given the complexity of the system, we recommend building a comprehensive test suite covering the entire system using realistic parameter values. An extensive and well-designed test suite is critical for minimizing the risk of unintentionally introducing issues during future development and may aid in identifying unintended features of the existing codebase.  We recommend:  Increasing test coverage to 100%   the IonPool contract with realistic parameter values   the impact of various parameter changes (increasing dust, decreasing debt ceiling, etc.)   accruing interest (incrementing the block timestamp) within the IonPool contract unit tests to ensure that the invariants hold  A comprehensive review of the test suite was not performed and the above list only includes some specific areas noted during the audit.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#testing", "labels": ["OpenZeppelin"]}, {"title": "Monitoring", "body": "Several key areas where continuous monitoring would benefit the health of the protocol were identified:  Monitor the swETH pool in Uniswap for suspicious activity affecting the TWAP price, including swaps and large increases or decreases in liquidity.  Monitor the Chainlink wstETH oracle to ensure it is returning accurate and up-to-date information.  Monitor the Redstone and Chainlink oracles associated with pricing ETHx. Ensure that they are returning accurate and up-to-date information. Furthermore, ensure that combining their rates results in an accurate price of ETHx.  Monitor the upgrades to the LST token contracts. These upgrades may change or break functionality that Ion integrates with. Monitor for changes to the internal exchange rates within the LST contracts.  Ensure liquidations occur in a timely manner (to avoid requiring a protocol liquidation and creating bad debt)  Monitor bad debt  Monitor all external price feeds for anomalous data.  Monitor for changes to the fees charged for Balancer flash loans. Note that BalancerFlashloanDirectMintHandler assumes balancer flash loans are feeless.  Monitor for slashing events to relevant validators.  Monitor for vault operations which seem suspicious, such as frequent calls to the same functions from the same addresses, or calls which result in a user's holdings increasing in value.  Monitor for suspicious calls to integrated LSTs, such as large amounts of tokens being minted, burned, or moved, or mints and burns which do not match the internal exchange rate of the LST.  Monitor the liquidity of all flash loan and flash swap sources. Monitor for suspicious behavior like large liquidity deposits/withdrawals or large swaps.  Monitor for sandwiching attacks or frontrunning attacks by checking the transactions near protocol interactions for profitable swaps with protocol collaterals.  Monitor all protocol actions to ensure compliance with invariants. For example, ensure that no user can borrow more than they owe, and that vaults are liquidatable when their health factors are below the threshold.  Monitor for protocol access and vault manipulation for users who are not whitelisted in order to detect faulty enforcement of the whitelist.  The above monitoring recommendations are a non-comprehensive list. It is recommended that Ion Protocol team build an extensive monitoring suite to ensure the proper functionality of the system.", "html_url": "https://blog.openzeppelin.com/ion-protocol-audit#monitoring", "labels": ["OpenZeppelin"]}, {"title": "Attacker Can Downscale All Protocol Shares by 18 Decimals", "body": "deposit function of the  mints protocol token shares for the user, maintaining a 1:1 ratio between the underlying deposited token and the underlying token balance of the protocol token. The shares minted for the user are calculated in the  balanceToShares function of the  mint function of the  fixed value of 1e18, and  either 1e18 or the ratio between the total underlying token deposited in the controller and the total amount of protocol token shares minted, defined  here as:  The issue arises because the first depositor can manipulate both the underlying token balance held by the protocol (by either the controller or the staker contracts) and the protocol token's total share amount to downscale all future users' shares and the total shares stored in the contract by 18 decimals.  Example:  Alice (malicious) deposits 1 underlying token into the protocol through the deposit function. As the protocol token's total shares are initially 0, the _shareValue function will return 1e18, as will the _sharesPrecision function, and Alice will be minted 1 share.  Alice then transfers any amount with 18 decimals of precision (e.g., 10e18) of the underlying token to either the Controller or any of the Stakers. At this point, total_shares = 1, alice_shares = 1, and total_underlying = 10e18 + 1. Now Alice owns the protocol's only share without decimal precision, which is unexpected, representing the total underlying token balance held by the protocol (with 18 decimals of precision), as well as all future user shares. This leads to several undesired scenarios.  Loss of Funds  Any deposit amount lower than the underlying balance held by Alice that occurs after the sequence mentioned above will be owned by Alice.  Let's say Bob (an honest actor) deposits 10e18 underlying tokens into the protocol. Since the protocol token's total shares are now 1 (not 0), the _shareValue function will return a value with 36 decimals based on this formula:  The shares minted for Bob are calculated as:  Bob deposits 10e18 underlying tokens but receives 0 shares in exchange, meaning the underlying tokens he deposited will belong to Alice.  Rounding Errors  In certain scenarios, due to rounding issues arising from the loss of 18 decimals of precision, depositors will lose part of their deposit shares. Following the aforementioned example where Alice deposits 1 token and then transfers 10e18 tokens to the Controller, if Bob subsequently deposits, for example, 15e18 tokens into the protocol, his shares will be calculated as follows:  Bob's deposit will represent 50% of the pool, instead of 60% (15e18 in a total of 25e18).  A step-by-step proof-of-concept can be found in this secret gist.  Consider tracking the balance of the underlying token in Staker contracts and the controller locally, and using these amounts instead of relying on the balanceOf function in the getTotalUnderlying function.  Update: Mitigated in pull request #28 at commit 3b7214d. In pull request 28, the team introduced a sacrifice position, deposited by the Controller contract itself during initialization, which is then permanently locked. This strategy makes it highly impractical to return to a scenario where the underlying amount is much larger than the number of shares, and it will lead to a substantial loss for the attacker.  It is also important to notice that a small downscale due to a rounding issue and a side transfer might occur. In such a scenario, a depositor could end up withdrawing less underlying than what was originally deposited. Nevertheless, the error produced is insignificant and cannot be mitigated in this type of setting.  Initially, the RestakeFi team added pull request #15 at commit 0b350a1, which included a minimum deposit requirement that took into account the decimal precision of the underlying asset. This is to prevent users from minting an excessively small number of shares. However, this minimum deposit amount, as well as the minimum share quantity for initial depositors, could be manipulated, potentially reverting to the problematic scenario initially identified. The attack would consist of the following:  The first depositor deposits the lowest permissible amount, say 1e13, receiving an equivalent number of shares (1e13). In the same transaction, a malicious user could request a withdrawal of (1e13 - 1) of the underlying asset. They would then execute their withdrawal using the processWithdrawals function and subsequently redeem their underlying asset. At this point, the attack is back to the initial issue: the first depositor is left with just 1 share, and the value of the underlying asset in the Controller contract is reduced to 1.  Moreover, another attack could be made by directly calling either of the burn or burnShares functions (the latter one introduced in the same pull request as the fix for M02), which would allow the user to burn all but one shares directly without altering the underlying asset balance and return to the same attack scenario.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#attacker-can-downscale-all-protocol-shares-by-18-decimals", "labels": ["OpenZeppelin"]}, {"title": "Shares Not Burned After Redemption of Underlying Assets", "body": "The asset withdrawal process from the protocol is a two-step procedure. Initially, depositors must request a withdrawal using the requestWithdraw function, requesting the amount in underlying units. This amount is then converted into shares and, if all balance checks pass, transferred back to the Controller contract. The request is subsequently added to the pending list, awaiting processing by the StrategyManager. Each request is assigned an ID and includes multiple parameters, such as the request owner and the amount of shares associated with that request.  redeemUnderlying function, inputting the request ID. The function converts the shares tied to the request into underlying units using the  sharesToBalance function, and then this amount of underlying is transferred to the user. The request is  removed from the list of withdrawal requests and the function attempts to burn the shares associated with the request using the  controlledBurnSharesFrom function, specifying the  However, as this request is removed from the list once the underlying assets are transferred to the user, the value of req.shares will be zero. Due to this, shares will never be burned and will remain stuck in the Controller contract.  Moreover, as all calculations for converting balances to shares (and vice versa) depend on the total supply of shares, the underlying balances will not properly reflect the conversion due to an always-increasing totalShares value.  A step-by-step proof-of-concept can be found in this secret gist.  Consider either burning the shares before removing the request from the list of withdrawal requests, or using a temporary variable to store the value that will later be burned.  Update: Resolved in pull request #14 at commit 376f4e4.  High Severity", "html_url": "https://blog.openzeppelin.com/restakefi-audit#shares-not-burned-after-redemption-of-underlying-assets", "labels": ["OpenZeppelin"]}, {"title": "Attacker Can DoS Withdrawals", "body": "For users who want to re-stake their tokens in EigenLayer using the protocol, the following steps should be followed:  The user deposits an asset through the deposit function of the Controller contract. In return, the Controller mints protocol token shares for the user, maintaining a 1:1 ratio between the deposited underlying and the underlying token balance of the protocol token.  After some time, the user might want to withdraw their funds (plus potential earnings) from the protocol. To do this, they first have to request a withdrawal through the requestWithdraw function in the Controller. This request gets queued in a double-linked list, where the user address, the nonce of the request, and the share amount are saved. These funds cannot be redeemed until the StrategyManager processes this user's withdrawal request.  The StrategyManager processes this and potentially other withdrawal requests by calling the processWithdrawals function. Withdrawal requests are processed in order, as a FIFO (First In, First Out), which means that to process the user's withdrawal request, the StrategyManager has to process any remaining requests done previously by other users in order. An iterator is updated each time a withdrawal request is processed, so they don't get processed again. Before processing withdrawals, the StrategyManager must ensure enough funds in the Controller contract to pay for the selected batch of consecutive withdrawal requests.  Finally, the user can call the redeemUnderlying function, where their protocol tokens get burned, and the protocol transfers the underlying shares to the user.  The issue lies in the fact that there are no restrictions on users making multiple withdrawal requests, which opens up griefing attack scenarios:  An attacker could deposit a relatively low amount of underlying assets (e.g., 1,000 tokens) and use multicall to call requestWithdrawal 1,000 times, each time with 1 unit as a parameter (in different batches if necessary, in case they run out of gas). In this scenario, the StrategyManager would have to process 1,000 withdrawal requests before being able to address legitimate users' requests.  Once the StrategyManager decides to fulfill all these requests, the attacker can then create another 1,000 withdrawal requests. In an extreme case, the attacker could continuously prevent the StrategyManager from catching up, forcing them to process thousands of malicious requests again before being able to fulfill the next batch of legitimate requests.  In an extreme scenario, the attacker could initially create an even higher number of malicious withdrawal requests, compelling the protocol team to upgrade the protocol with a new design and pause withdrawal requests. This would prevent legitimate users from transferring their protocol tokens to the Controller contract, thereby virtually \"losing\" their positions.  These scenarios will make the protocol unusable for users since they will not be able to redeem their assets, or will have to wait until the StrategyManager processes malicious requests. and will incur financial expenses for the StrategyManager to be able to fulfill the malicious withdrawal requests, as well as fill the double-linked list with trash requests, hindering the task of off-chain services searching and filtering for specific requests.  Consider limiting the number of withdrawal requests that a user can make. Otherwise, consider adding a larger minimum amount that could be withdrawn by a user, for instance, 50% of their shares. Note that even with these mitigations, an attacker could still perform this attack using different accounts. We recommend designing a new withdrawal system where these scenarios are not possible.  Update: Not resolved in pull request #27 at commit d3ce3e7. The RestakeFi team stated:  We changed the logic to add up all the withdrawals from the same user in the same existing position until a strategy manager engages with the withdrawal logic. This change together with the fact that creating withdrawal requests is almost three times more expensive than processing them (iterating over them), and the minimum deposit amount, should solve this issue.  The same attack is still possible, just with an extra step. The attacker now has to use multiple addresses to deposit and call requestWithdrawal 1,000 times to block future withdrawals. This also creates a new issue. An attacker can force users who have withdrawals that would be processed in the next batch to be delayed. This is possible due to an attacker who is front-running the processWithdrawal function, increasing their withdrawing amount and leaving the honest users' withdrawals unprocessed and delayed.  Moreover, the RestakeFi team stated:  The high-severity issue is also theoretical in a sense because it pivots on the existence of an irrational attacker willing to waste large amounts of funds to do a DDoS attack and grief withdrawals. It\u201a\u00c4\u00f4s a similar issue that can be brought up for almost any", "html_url": "https://blog.openzeppelin.com/restakefi-audit#attacker-can-dos-withdrawals", "labels": ["OpenZeppelin"]}, {"title": "DoS in Controller's depositWithPermit Function", "body": "The depositWithPermit function in the Controller allows users to deposit a certain amount of underlying tokens without prior token approval, bypassing methods like approve() or increaseAllowance(). It does this by leveraging the permit functionality of the ERC20Permit contract.  However, the depositWithPermit function can be front-run by a malicious actor. This actor can observe the transaction in the mempool, replicate the parameters being sent, and directly invoke the ERC20Permit#permit function of the underlying token. As a result, the original user's call will fail.  Consider implementing a try/catch block within the depositWithPermit function. In this block, if the call to permit fails, the contract should execute the deposit anyway if the allowance is sufficient.  Update: Resolved in pull request #16 at commit b80abef.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#dos-in-controller's-depositwithpermit-function", "labels": ["OpenZeppelin"]}, {"title": "Funds Can Get Stuck Due to Incorrect Initialization", "body": "The BaseERC20 contract implements the functionality to set the available features in the Protocol Token based on the input passed by the admin, and it can only be done once.  However, if the allowControlled flag is set to false, then all the operations after the tokens have been deposited will not work and the underlying asset stored in the protocol will be stuck. It is worth mentioning that the false value is the default value and it could be passed by mistake, realizing this only when the withdrawals of funds are happening.  deposit function from the  controlledTransferFrom,  controlledBurnFrom, and  controlledBurnSharesFrom functions. That means that after depositing funds, users will not be able to take back the underlying assets.  Moreover, as the flag is only set during the initialization, the admin will not be able to change it without a protocol upgrade. Furthermore, since it is always expected for the Controller contract to be in control of those functionalities (controlledTransferFrom and controlledBurnSharesFrom functions), the flag should always be up.  Consider removing this flag or always setting it to true to prevent funds from becoming stuck in the protocol. Moreover, consider checking that the passed roles.controller address is indeed a Controller type of contract with an ERC-165 or other introspection standard.  Update: Resolved in pull request #17 at commit 80958e7. The flag no longer exists. However, the controlledBurnSharesFrom function has been renamed burnShares and its access control has been eliminated. This function resembles the burn function inherited by the ERC20BurnableUpgradeable contract, although in this case its value is not converted from underlying into shares by going through the _update function. It is worth noting that with both external functions, users can lose their positions as it does not process the underlying withdrawal after the shares are removed from their account, so users should not be allowed to call them.  Low Severity", "html_url": "https://blog.openzeppelin.com/restakefi-audit#funds-can-get-stuck-due-to-incorrect-initialization", "labels": ["OpenZeppelin"]}, {"title": "Protocol Token Cannot Be Unpaused", "body": "The BaseERC20 contract implements the basic role management for the other contracts inheriting it.  In particular, it handles the PAUSER_ROLE role.  Although the PAUSER_ROLE is the one able to pause the token, another role (UNPAUSER_ROLE role) is the one in charge of unpausing it after it has been paused.  However, all other roles are granted in the __BaseERC20_init_unchained function, except for the UNPAUSER_ROLE, meaning that nobody will have the ability to call the unpause function.  Although the admin, currently a multisig controlled by the team, can later grant the role to a new address, it would be wise to prevent the situation of delaying the resuming of the protocol's activity due to the extra task of granting the role beforehand. Moreover, to reduce the attack surface and improve the readability of the code, it is suggested that all roles should have the same granting process.  Consider granting the UNPAUSER_ROLE role along with the rest of the roles in the __BaseERC20_init_unchained function.  Update: Resolved in pull request #18 at commit d094552.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#protocol-token-cannot-be-unpaused", "labels": ["OpenZeppelin"]}, {"title": "Protocol Token Initialization Might Not Be Properly Configured", "body": "The BaseERC20 contract uses flags to define certain characteristics and the roles available for the token.  However, there are situations where the inputs are not entirely being handled by the implementation, meaning that it may cause problems later on if the input was mistakenly crafted. For example, if a token is not meant to be paused, the pauser address should be zero so it is not skipped silently.  As a safety check, consider validating that addresses for their respective flags are zero for features that will not be used, and reverting the initialization in the alternate scenario.  Update: Acknowledged, not resolved. The RestakeFi team stated:  For our specific case, this is acceptable. We are setting all the flags we need.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#protocol-token-initialization-might-not-be-properly-configured", "labels": ["OpenZeppelin"]}, {"title": "Floating Pragma", "body": "Pragma directives should be fixed to clearly identify the Solidity version with which the contracts will be compiled.  Throughout the codebase, there are multiple floating pragma directives:  The file BaseERC20.sol  The file Controller.sol  The file ERC20Snapshot.sol  The file ERC20SnapshotRebase.sol  The file EigenSharePricer.sol  The file IController.sol  The file IDelegationManager.sol  The file IERC20SnapshotRebase.sol  The file ISignatureUtils.sol  The file IStaker.sol  The file IStrategy.sol  The file StakerM1.sol  The file StorageBaseERC20.sol  The file StorageController.sol  The file StorageERC20Snapshot.sol  The file StorageERC20SnapshotRebase.sol  The file StorageStaker.sol  Consider using a fixed pragma version on all files.  Update: Resolved in pull request #19 at commit 70437a5.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#floating-pragma", "labels": ["OpenZeppelin"]}, {"title": "Improper Namespace NatSpec Tag for ERC-7201", "body": "StorageController does not follow the NatSpec tag specification that should be annotated to the contract's struct for ERC-7201. The  ControllerStorage namespace tag is  formula  ERC-7201:  A namespace in a contract should be implemented as a struct type. These structs should be annotated with the NatSpec tag @custom:storage-location <FORMULA_ID>:<NAMESPACE_ID>, where <FORMULA_ID> identifies a formula used to compute the storage location where the namespace is rooted, based on the namespace id.  Consider changing the namespace tag to @custom:storage-location erc7201:ControllerStorage to properly follow the ERC-7201 specification.  Update: Resolved in pull request #20 at commit c03320c.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#improper-namespace-natspec-tag-for-erc-7201", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings:  Line 15 in BaseERC20.sol  Line 26 in BaseERC20.sol  Line 27 in BaseERC20.sol  Line 28 in BaseERC20.sol  Line 29 in BaseERC20.sol  Line 30 in BaseERC20.sol  Line 48 in BaseERC20.sol  Line 114 in BaseERC20.sol  Line 164 in BaseERC20.sol  Line 180 in BaseERC20.sol  Line 195 in BaseERC20.sol  Line 199 in BaseERC20.sol  Line 203 in BaseERC20.sol  Line 19 in Controller.sol  Line 29 in Controller.sol  Line 30 in Controller.sol  Line 32 in Controller.sol  Line 33 in Controller.sol  Line 40 in Controller.sol  Line 82 in Controller.sol  Line 281 in Controller.sol  Line 11 in ERC20Snapshot.sol  Line 19 in ERC20Snapshot.sol  Line 39 in ERC20Snapshot.sol  Line 50 in ERC20Snapshot.sol  Line 15 in ERC20SnapshotRebase.sol  Line 21 in ERC20SnapshotRebase.sol  Line 22 in ERC20SnapshotRebase.sol  Line 24 in ERC20SnapshotRebase.sol  Line 33 in ERC20SnapshotRebase.sol  Line 42 in ERC20SnapshotRebase.sol  Line 67 in ERC20SnapshotRebase.sol  Line 86 in ERC20SnapshotRebase.sol  Line 108 in ERC20SnapshotRebase.sol  Line 117 in ERC20SnapshotRebase.sol  Line 123 in ERC20SnapshotRebase.sol  Line 130 in ERC20SnapshotRebase.sol  Line 135 in ERC20SnapshotRebase.sol  Line 159 in ERC20SnapshotRebase.sol  Line 166 in ERC20SnapshotRebase.sol  Line 172 in ERC20SnapshotRebase.sol  Line 179 in ERC20SnapshotRebase.sol  Line 185 in ERC20SnapshotRebase.sol  Line 195 in ERC20SnapshotRebase.sol  Line 8 in EigenSharePricer.sol  Line 9 in EigenSharePricer.sol  Line 11 in EigenSharePricer.sol  Line 12 in EigenSharePricer.sol  Line 19 in EigenSharePricer.sol  Line 31 in EigenSharePricer.sol  Line 8 in IController.sol  Line 50 in IController.sol  Line 51 in IController.sol  Line 57 in IController.sol  Line 62 in IController.sol  Line 67 in IController.sol  Line 68 in IController.sol  Line 69 in IController.sol  Line 70 in IController.sol  Line 71 in IController.sol  Line 73 in IController.sol  Line 6 in IERC20SnapshotRebase.sol  Line 17 in IERC20SnapshotRebase.sol  Line 19 in IERC20SnapshotRebase.sol  Line 21 in IERC20SnapshotRebase.sol  Line 23 in IERC20SnapshotRebase.sol  Line 25 in IERC20SnapshotRebase.sol  Line 30 in IERC20SnapshotRebase.sol  Line 32 in IERC20SnapshotRebase.sol  Line 34 in IERC20SnapshotRebase.sol  Line 9 in IStaker.sol  Line 39 in IStaker.sol  Line 40 in IStaker.sol  Line 41 in IStaker.sol  Line 42 in IStaker.sol  Line 43 in IStaker.sol  Line 44 in IStaker.sol  Line 66 in IStaker.sol  Line 68 in IStaker.sol  Line 70 in IStaker.sol  Line 72 in IStaker.sol  Line 74 in IStaker.sol  Line 76 in IStaker.sol  Line 103 in IStrategy.sol  Line 32 in StakerM1.sol  Line 39 in StakerM1.sol  Line 160 in StakerM1.sol  Line 192 in StakerM1.sol  Line 256 in StakerM1.sol  Line 262 in StakerM1.sol  Line 268 in StakerM1.sol  Line 272 in StakerM1.sol  Line 4 in StorageBaseERC20.sol  Line 8 in StorageController.sol  Line 39 in StorageController.sol  Line 43 in StorageController.sol  Line 47 in StorageController.sol  Line 51 in StorageController.sol  Line 55 in StorageController.sol  Line 61 in StorageController.sol  Line 65 in StorageController.sol  Line 76 in StorageController.sol  Line 82 in StorageController.sol  Line 86 in StorageController.sol  Line 105 in StorageController.sol  Line 4 in StorageERC20Snapshot.sol  Line 4 in StorageERC20SnapshotRebase.sol  Line 6 in StorageStaker.sol  Line 28 in StorageStaker.sol  Line 32 in StorageStaker.sol  Line 36 in StorageStaker.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Acknowledged, not resolved. The RestakeFi team stated:  Acknowledged. Not an issue for us.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Confusing Usage of Staker Index", "body": "staker_deposit,  staker_pullUnderlying,  staker_delegateTo,  staker_undelegate,  staker_queueWithdrawal, and  staker_completeWithdrawal functions require both the  However, in the removeStaker function, if a staker is removed and is not the last in the array, the last element of the array replaces the removed Staker's position, and then the last element is removed. This process changes the position of the last staker in the array. As this change is not recorded in an event, it becomes challenging to track the new index of the relocated staker.  Consider emitting an additional event if a Staker is moved to a different position in the array. This will prevent any hindrance caused by a lack of visibility into the current indices of the Stakers.  Update: Acknowledged, not resolved. The RestakeFi team stated:  The index is used just for double-checking that it is the actual staker that the admin wants to remove. It is not used for anything else. Not an issue.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#confusing-usage-of-staker-index", "labels": ["OpenZeppelin"]}, {"title": "Use of Boolean Literal as Conditional", "body": "Boolean literals in code have limited legitimate uses. Other uses (in complex expressions, as conditionals) indicate either an error or, most likely, the persistence of faulty code.  The boolean literal False within the BaseERC20 contract in BaseERC20.sol is a misuse.  To avoid misusing Boolean literals, consider changing the style to maintain consistency within if clauses.  Update: Resolved in pull request #21 at commit 7bb1659.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#use-of-boolean-literal-as-conditional", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Value Emitted in Event", "body": "updateShares is called to update the balance of shares of the account from which the shares are being burned, and to adjust the total supply of shares, as this is a burning operation. However, an issue arises with an  event that emits the amount of balance being burned, calculated using the  mintShares function).  It is important to note that in this protocol, controlledBurnSharesFrom is invoked in the Controller immediately following a transfer. As such, this will not pose an issue and the value emitted will be correct.  Consider documenting and explicitly stating this behavior, as other parts of the code that integrate this function could encounter future problems.  Update: Partially resolved in pull request #22 at commit 58de4f7. As we mentioned, the issue pertained to the controlledBurnSharesFrom function. However, due to the manner in which the Controller interacted with it, no adverse effects occurred. With the function now corrected, it must be utilized properly in conjunction with the Controller. Specifically, in the redeemUnderlying function, it is crucial to conduct the transfer() after executing burnShares(). If not, the balances become inconsistent. This inconsistency arises because shareToBalance() is invoked before the burn, resulting in a certain value. Following this, the transfer() occurs, altering the total underlying in the protocol. Subsequently, when the burn function is executed, shareToBalance is recalculated, leading to a different value. Ensure that the transfer is executed post-burn.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/restakefi-audit#incorrect-value-emitted-in-event", "labels": ["OpenZeppelin"]}, {"title": "Constants Not Using UPPER_CASE Format", "body": "Throughout the codebase there are constants not using UPPER_CASE format. For instance:  The BaseERC20StorageLocation constant declared on line 14 in StorageBaseERC20.sol  The ControllerStorageLocation constant declared on line 26 in StorageController.sol  The ERC20SnapshotStorageLocation constant declared on line 17 in StorageERC20Snapshot.sol  The ERC20SnapshotRebaseStorageLocation constant declared on line 11 in StorageERC20SnapshotRebase.sol  The StakerStorageLocation constant declared on line 15 in StorageStaker.sol  According to the Solidity Style Guide, constants should be named with all capital letters with underscores separating words. For better readability, consider following this convention.  Update: Acknowledged, not resolved. The RestakeFi team stated:  We followed the OpenZeppelin upgradable contracts library syntax. Not an issue.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#constants-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "Todo Comments", "body": "During development, having well-described TODO/Fixme comments will make the process of tracking and solving them easier. Without this information, these comments might age and important information for the security of the system might be forgotten by the time it is released to production. These comments should be tracked in the project's issue backlog and resolved before the system's deployment.  Multiple instances of TODO/Fixme comments were found in the codebase. For instance:  The TODO comment on line 321 in Controller.sol.  The TODO comment on line 229 in StakerM1.sol.  Consider removing all instances of TODO/Fixme comments and instead tracking them in the issues backlog. Alternatively, consider linking each inline TODO/Fixme to the corresponding issues backlog entry.  Update: Acknowledged, not resolved. The RestakeFi team stated:  These TODO comments are for future upgraders to be aware of. Not an issue.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#todo-comments", "labels": ["OpenZeppelin"]}, {"title": "Lack of Indexed Event Parameters", "body": "Throughout the codebase, several events do not have their parameters indexed. For instance:  The nonce of the WithdrawalQueued event of IStaker.sol  The root hash of the WithdrawalCompleted event of IStaker.sol  Consider indexing event parameters to improve the ability of off-chain services to search for and filter for specific events.  Update: Acknowledged, not resolved. The RestakeFi team stated:  For our needs, this is fine and more gas efficient.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Non-Explicit Imports Are Used", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code, and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are being used. For instance:  The StorageController.sol import in IController.sol  The IDelegationTerms.sol import in IDelegationManager.sol  The IERC20.sol import in IStrategy.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged, not resolved. The RestakeFi team stated:  Not an issue.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Unused Errors", "body": "Throughout the codebase there are unused errors. For instance:  The MustHaveAdminRole error in BaseERC20.sol  The ERC20SnapshotInvalidOperation error in ERC20Snapshot.sol  The Controller_MustPullUnderlying error in IController.sol  To improve the overall clarity, intentionality, and readability of the codebase, consider either using or removing any currently unused errors.  Update: Resolved in pull request #23 at commit 0cadceb.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#unused-errors", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "Throughout the codebase, there are multiple imports that are unused and could be removed. For instance:  Import StorageController.sol in IController.sol  Import IDelegationManager.sol has an unused alias IDelegationManager in StakerM1.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Acknowledged, not resolved. The RestakeFi team stated:  Not an issue.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused Named Return Variables", "body": "Named return variables are a way to declare variables that are meant to be used within a function body for the purpose of being returned as the function's output. They are an alternative to explicit in-line return statements.  Throughout the codebase, there are multiple instances of unused named return variables. For instance:  The headId return variable in the getWithdrawalRequestQueue_Info function of StorageController.sol.  The tailId return variable in the getWithdrawalRequestQueue_Info function of StorageController.sol.  The count return variable in the getWithdrawalRequestQueue_Info function of StorageController.sol.  Consider either using or removing any unused named return variables.  Update: Resolved in pull request #24 at commit 7f22405.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#unused-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Unused Structs", "body": "Throughout the codebase, there are unused structs. For instance:  The WithdrawalRequest struct in IController.sol  The SignatureWithExpiry struct in ISignatureUtils.sol  To improve the overall clarity, intentionality, and readability of the codebase, consider either using or removing any currently unused structs.  Update: Partially resolved in pull request #25 at commit 346f20d. The RestakeFi team stated:  Fixed one. ISignatureUtils is external and we do not want to modify it.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#unused-structs", "labels": ["OpenZeppelin"]}, {"title": "New maxStakers Value Not Being Checked", "body": "The setMaxStakers function allows the StrategyManager to modify the maximum number of Stakers. However, it lacks checks to ensure that the new maximum amount specified as a parameter is equal to or greater than the current number of Stakers.  While this does not inherently pose a security risk, it could lead to confusion. Consider incorporating a check ensuring that the new maximum Staker amount is not set lower than the existing number of Stakers.  Update: Acknowledged, not resolved. The RestakeFi team stated:  Prefer not to modify. Not an issue for us.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#new-maxstakers-value-not-being-checked", "labels": ["OpenZeppelin"]}, {"title": "Lack of Security Contact", "body": "Providing a specific security contact (such as an email or ENS name) within a smart contract significantly simplifies the process for individuals to communicate if they identify a vulnerability in the code. This practice proves beneficial as it permits the code owners to dictate the communication channel for vulnerability disclosure, eliminating the risk of miscommunication or failure to report due to a lack of knowledge on how to do so. Additionally, if the contract incorporates third-party libraries and a bug surfaces in these, it becomes easier for the maintainers of those libraries to make contact with the appropriate person about the problem and provide mitigation instructions.  Throughout the codebase, there are contracts that do not have a security contact:  The BaseERC20 contract  The Controller contract  The ERC20Snapshot contract  The ERC20SnapshotRebase contract  The EigenSharePricer contract  The IController contract  The IDelegationManager contract  The IERC20SnapshotRebase contract  The ISignatureUtils contract  The IStaker contract  The IStrategy contract  The StakerM1 contract  The StorageBaseERC20 contract  The StorageController contract  The StorageERC20Snapshot contract  The StorageERC20SnapshotRebase contract  The StorageStaker contract  Consider adding a NatSpec comment containing a security contact on top of the contracts' definition. Using the @custom:security-contact convention is recommended as it has been adopted by the OpenZeppelin Wizard and the ethereum-lists.  Update: Acknowledged, not resolved.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#lack-of-security-contact", "labels": ["OpenZeppelin"]}, {"title": "Inaccurate Revert Messages", "body": "The processWithdrawals, staker_pullUnderlying and staker_completeWithdrawal functions in the Controller contract will revert either when the current operation being triggered is paused, or when the caller does not possess the STRATEGY_MANAGER_ROLE, among other reasons.  However, if a caller lacking the STRATEGY_MANAGER_ROLE attempts to invoke these functions, they will erroneously revert with a pause-related error message, instead of the more appropriate Controller_Unauthorized message. To improve clarity and visibility, consider splitting these if statements into two separate checks so that the functions can revert with the correct error message when a user without authorization attempts to call them.  Update: Acknowledged, not resolved. The RestakeFi team stated:  The pause flags allow those functions to be paused only for the user. The strategy manager is still able to call them. When not paused, anyone can call those functions. So, we consider the error to be fit for the use case.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#inaccurate-revert-messages", "labels": ["OpenZeppelin"]}, {"title": "Refactor Opportunities", "body": "Throughout the codebase, there are instances where the code can be refactored. In particular:  Within the BaseERC20 contract, these getters could be reused instead of recreating the same logic in the controlledTransferFrom, controlledBurnFrom, mint, and pause functions.  In the EigenSharePricer contract, an external call to query the totalShares value is unnecessary as the same value is stored in the totalShares local variable.  Consider applying these refactoring opportunities in the codebase to reduce its size and improve readability.  Update: Partially resolved in pull request #26 at commit b184d96. The RestakeFi team stated:  The second bullet point is resolved. The first bullet point is not an issue for us.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#refactor-opportunities", "labels": ["OpenZeppelin"]}, {"title": "Incomplete Parameters in Emitted Event", "body": "The MaxStakersSet event should emit both the old maximum value as well as the new one. In general, when modifying a state variable in the system, consider emitting both its old and new value to notify off-chain clients monitoring the contracts\u201a\u00c4\u00f4 activity.  Update: Acknowledged, not resolved. The RestakeFi team stated:  Not an issue for us.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#incomplete-parameters-in-emitted-event", "labels": ["OpenZeppelin"]}, {"title": "Error In Function Name", "body": "Consider changing the requestWithdraw function's name to requestWithdrawal.  Update: Acknowledged, not resolved. The RestakeFi team stated:  Not an issue for us.", "html_url": "https://blog.openzeppelin.com/restakefi-audit#error-in-function-name", "labels": ["OpenZeppelin"]}, {"title": "Incorrect or misleading documentation", "body": "Several instances of docstrings or comments in the codebase were found to be erroneous. In particular:  In the SpokePool contract's _fillRelay function, the comment on line 1003 appears unrelated to the if statement on the following line. Consider revising the comment.  The docstring for pauseDeposits in the SpokePool contract says it \"pauses deposit and fill functions\", but pausing fill functions is performed by calling pauseFills, which does not have a docstring.  Consider revising the pauseDeposits docstring and adding a docstring to pauseFills.  Update: Resolved in pull request #251 at commit 21d9ed8.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit-2023#incorrect-or-misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission after sensitive action", "body": "The setSuccinctTargetAmb administrative function does not emit a relevant event after changing the succinctTargetAmb address.  Consider always emitting events after sensitive changes take place to facilitate tracking and notify off-chain clients that follow the protocol's contracts' activity.  Update: Resolved in pull request #252 at commit 10c1190. Additionally, new ReceivedMessageFromL1 events were added to the Polygon_SpokePool and Succinct_SpokePool's message handler functions (processMessageFromRoot and handleTelepathy, respectively).", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit-2023#lack-of-event-emission-after-sensitive-action", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings. In particular:  AdapterInterface.sol, lines 13-20: The interface functions are undocumented.  Arbitrum_Adapter.sol, lines 9-54: The ArbitrumL1InboxLike and ArbitrumL1ERC20GatewayLike interfaces and their functions are undocumented.  LpTokenFactoryInterface.sol, lines 4-5: The interface and its functions are undocumented.  Optimism_Adapter.sol, lines 15-16: The SynthetixBridgeToOptimism interface and its function are undocumented.  Polygon_Adapter.sol, lines 10-30: The IRootChainManager, IFxStateSender, and DepositManager interfaces and their functions are undocumented.  Polygon_SpokePool.sol, line 11: The processMessageFromRoot function is undocumented.  SpokePool.sol, lines 169-196: The RelayExecution, RelayExecutionInfo, and DepositUpdate structs have undocumented members.  Succinct_SpokePool.sol, line 39: The initialize function has no docstring.  Succinct_SpokePool.sol, line 57: The handleTelepathy function has no docstring.  WETH9Interface.sol, lines 4-11: The interface and its functions are undocumented.  ZkSync_Adapter.sol, lines 13-30: The ZkSyncLike and ZkBridgeLike interfaces and their functions are undocumented.  ZkSync_SpokePool.sol, lines 6-12: The ZkBridgeLike interface and its function are undocumented.  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #253 at commit 5d1090a, pull request #242 at commit 4a8fe1c, and pull request #269 at commit 146f2f2.  The ZkSync_Adapter.sol and ZkSync_SpokePool.sol contracts were not changed. The UMA team stated:  All suggested comments are implemented except for zkSync contracts which were out of this audit's scope and are still in progress and not live.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit-2023#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "updatedRelayerFeePct can be lower than expected", "body": "In the SpokePool contract, the speedUpDeposit function performs the following check on the updatedRelayerFeePct variable:  require  (updatedRelayerFeePct  5e18  \"invalid relayer fee\"  );  equivalent check in the  will be rejected by the  Consider using the SignedMath.abs function to ensure the updatedRelayerFeePct argument provided to speedUpDeposit is within the expected limits.  Update: Resolved in pull request #254 at commit 857e787.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit-2023#updatedrelayerfeepct-can-be-lower-than-expected", "labels": ["OpenZeppelin"]}, {"title": "Interface files not in interfaces directory", "body": "The Across Protocol V2 codebase contains the interfaces directory, but the HubPoolInterface.sol and SpokePoolInterface.sol files do not reside in that location. Instead, they are located in the parent directory.  Consider moving all non-external interface files to the interfaces directory, so that interfaces can be more easily located.  Update: Resolved in pull request #255 at commit fa59467.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit-2023#interface-files-not-in-interfaces-directory", "labels": ["OpenZeppelin"]}, {"title": "Multiple conditions in a single require statement", "body": "There is a require statement with multiple conditions in the handleTelepathy function of the Succinct_SpokePool contract.  Consider isolating each condition in its own separate require statement with a corresponding error message, to more easily identify the specific condition that failed.  Update: Resolved in pull request #256 at commit c42ea4f.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit-2023#multiple-conditions-in-a-single-require-statement", "labels": ["OpenZeppelin"]}, {"title": "Redundant condition in if statement", "body": "In the SpokePool contract, the _updateCountFromFill function is responsible for updating the fillCounter data when a fill takes place. No update is necessary in the following three cases: when the action is either a slow fill or an initial zero-fill, or when a partial fill for that request has already happened.  However, in the case of a zero-fill the execution flow will not reach this function, which makes the condition endingFillAmount == 0 redundant.  Consider removing the redundant condition for increased clarity, readability, and gas savings. For extra safety, consider adding a comment where the function returns if there is a zero-fill, denoting that any updates to this part should take the function _updateCountFromFill into account.  Update: Resolved in pull request #264 at commit ef59e2a. The endingFillAmount == 0 condition has been removed and a comment has been added to clarify that initial zero-fills will not reach this location in the code.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit-2023#redundant-condition-in-if-statement", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Consider correcting the following typographical errors:  In BondToken.sol:  Line 11, \"rootBundleProposer()\" should be \"rootBundleProposal()\". Line 21: \"permissiong\" should be \"permissioning\".  In EIP712CrossChainUpgradeable.sol:  Line 83: \"its always\" should be \"it's always\".  In MultiCallerUpgradeable.sol:  Line 5: \"@title MockSpokePool\" should be \"@title MultiCallerUpgradeable\".  In Optimism_Adapter.sol:  Line 23: \"its only\" should be \"it's only\".  In Polygon_SpokePool.sol:  Line 51: the sentence \"See\" is incomplete. Line 139: the sentence is malformed.  In SpokePool.sol:  Line 567: \"speedUpRelay()\" should be \"speedUpDeposit()\". Line 1177: \"its always\" should be \"it's always\".  In Succinct_Adapter.sol:  Line 27: \"destinatipn\" should be \"destination\". Line 27: \"the message..\" should be \"the message.\".  In Succinct_SpokePool.sol:  Line 22: \"callValidated\" should be \"adminCallValidated\". Line 24: \"callValidated\" should be \"adminCallValidated\". Line 35: \"callValidated\" should be \"adminCallValidated\".  Update: Resolved in pull request #258 at commit 43a0ea7.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit-2023#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary modulo operation", "body": "performs a modulo 256 operation on  Consider removing the redundant modulo operation.  Update: Resolved in pull request #259 at commit 04c8488.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit-2023#unnecessary-modulo-operation", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "The following imports are unused:  Import AdapterInterface.sol in HubPoolInterface.sol  Import ECDSA.sol in SpokePool.sol  To improve readability and avoid confusion, consider removing any unused imports.  Update: Resolved in pull request #260 at commit 4a94713.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit-2023#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Use of hard-coded values", "body": "The _bridgeTokensToHubPool function in the Ovm_SpokePool contract contains two hard-coded addresses that are not explicitly documented.  Consider creating constants to store these values, and assigning them descriptive variable names.  Update: Resolved in pull request #261 at commit 6f8b6e3.", "html_url": "https://blog.openzeppelin.com/uma-across-v2-audit-2023#use-of-hard-coded-values", "labels": ["OpenZeppelin"]}, {"title": "Paused Token Contract Does Not Pause Allowance Changes", "body": "The AukiToken contract can be paused and unpaused by an address that has been granted the PAUSER_ROLE. Through the use of the whenNotPaused modifier on the _beforeTokenTransfer function, when the AukiToken contract is paused, no tokens can be transferred, minted, or burned. However, this does not prevent approvals, permits, and/or any other allowance changes from taking place while the contract is paused.  According to the Auki Labs team, \"the expected behavior when [Auki] token is paused is to pause all operations.\". As such, consider adding the whenNotPaused modifier to all corresponding allowance change functions to prevent this from occurring while the contract is paused.  Update: Resolved in pull request #48 at commit 5c27964.", "html_url": "https://blog.openzeppelin.com/auki-labs-audit#paused-token-contract-does-not-pause-allowance-changes", "labels": ["OpenZeppelin"]}, {"title": "Unsafe Use of DEFAULT_ADMIN_ROLE", "body": "According to the comments in OpenZeppelin's AccessControl.sol file as well as the official documentation, the recommendation is to use AccessControl in conjunction with AccessControlDefaultAdminRules. This contract implements the following risk mitigations on top of AccessControl:  Only one account holds the DEFAULT_ADMIN_ROLE role since deployment until it is potentially renounced.  Enforces a two-step process to transfer the DEFAULT_ADMIN_ROLE role to another account.  Enforces a configurable delay between the two steps, with the ability to cancel before the transfer is accepted. The delay can be changed by scheduling.  It is not possible to use another role to manage the DEFAULT_ADMIN_ROLE role.  Consider adding AccessControlDefaultAdminRules on top of the existing AccessControl in order to safely manage the DEFAULT_ADMIN_ROLE role.  Update: Resolved in pull request #48 at commit ce493df.  Low Severity  Remove Test Code isProxied From Constructors  There are instances of test code across several upgradeable contract constructors:  Line 31 of AukiToken.sol  Line 36 of BurnContract.sol  Line 45 of StakingContract.sol  parameter is used by the development team in order to use the  Blacksmith tool. Blacksmith currently does not support interacting with a contract that uses a proxy upgrade pattern. However, deploying these contracts without the use of a proxy in production can create the risk of an attacker front-running the  function. This would lead to a redeployment of the contracts and wastage of gas.  Consider removing the isProxied parameter from the constructors in a production-ready codebase.  Update: Resolved in pull request #48 at commit 3597610.  Missing Event Emissions  Throughout the codebase, the constructors and initializers do not emit events after initializing sensitive variables in the system. Although in some cases, when those variables are updated using setter functions, an event is emitted:  In the initialize function of BurnContract, both storage variables token and recipient are set without emitting any events.  In the constructor of RewardLiquidityPoolContract, the storage variable token is set without emitting an event.  In the initialize function of StakingContract, the storage variable stakingToken is set without emitting an event. Furthermore, the storage variables thawingPeriod and stakeAmount are set without emitting the UpdatedThawingPeriod and UpdatedStakeAmount events, respectively.  Consider emitting events when updating state variables to more easily enable off-chain monitoring for the protocol.  Update: Resolved in pull request #48 at commit edd27f0.  Notes & Additional Information  Multiple Instances of Missing Named Parameters in Mappings  Since Solidity 0.8.18, developers can utilize named parameters in mappings. This means mappings can take the form of mapping(KeyType KeyName? => ValueType ValueName?). This updated syntax provides a more transparent representation of a mapping's purpose.  Throughout the codebase, there are multiple mappings without named parameters:  The stakes state variable in the StakingContract contract  The _rewards state variable in the RewardLiquidityPoolContract contract  Consider adding named parameters to the mappings in order to improve the readability and maintainability of the codebase.  Update: Resolved in pull request #48 at commit 25f7718.  Variable Cast is Unnecessary  In StakingContract, there are multiple variables that are unnecessarily casted:  The stakingToken variable in the slash function  The _stakingToken variable in the initialize function  To improve the overall clarity, intent, and readability of the codebase, consider removing these unnecessary casts.  Update: Resolved in pull request #48 at commit 437191d.  Use of Foundry-Specific Imports  Throughout the codebase, the current format for importing other Solidity files is from the lib folder of the repository. For example, the OpenZeppelin contract imports take the form of import {SomeContract} from \"lib/openzeppelin-contracts/*\". While this is suitable for developers working only in Foundry, other developers who are using this contract (particularly those who are not using Foundry as their smart contract development framework) may run into compilation errors when trying to integrate.  as described in the  OpenZeppelin documentation. This pattern can similarly be applied for other imports outside the OpenZeppelin library. In conjunction with this, a  file can be added in the home directory to map imports to their Foundry specific paths.  Consider changing the import format as suggested above and adding a remappings.txt. This will help improve the developer experience for developers working in different development frameworks.  Update: Resolved in pull request #48 at commit 496066f.  Gas Optimizations  Potential gas cost improvements were found throughout the codebase:  Extraneous require statement on token transfers. The AukiToken contract inherits from the OpenZeppelin libr", "html_url": "https://blog.openzeppelin.com/auki-labs-audit#unsafe-use-of-default_admin_role", "labels": ["OpenZeppelin"]}, {"title": "Remove Test Code isProxied From Constructors", "body": "Remove Test Code isProxied From Constructors", "html_url": "https://blog.openzeppelin.com/auki-labs-audit#remove-test-code-isproxied-from-constructors", "labels": ["OpenZeppelin"]}, {"title": "Missing Event Emissions", "body": "Throughout the codebase, the constructors and initializers do not emit events after initializing sensitive variables in the system. Although in some cases, when those variables are updated using setter functions, an event is emitted:  In the initialize function of BurnContract, both storage variables token and recipient are set without emitting any events.  In the constructor of RewardLiquidityPoolContract, the storage variable token is set without emitting an event.  In the initialize function of StakingContract, the storage variable stakingToken is set without emitting an event. Furthermore, the storage variables thawingPeriod and stakeAmount are set without emitting the UpdatedThawingPeriod and UpdatedStakeAmount events, respectively.  Consider emitting events when updating state variables to more easily enable off-chain monitoring for the protocol.  Update: Resolved in pull request #48 at commit edd27f0.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/auki-labs-audit#missing-event-emissions", "labels": ["OpenZeppelin"]}, {"title": "Multiple Instances of Missing Named Parameters in Mappings", "body": "Since Solidity 0.8.18, developers can utilize named parameters in mappings. This means mappings can take the form of mapping(KeyType KeyName? => ValueType ValueName?). This updated syntax provides a more transparent representation of a mapping's purpose.  Throughout the codebase, there are multiple mappings without named parameters:  The stakes state variable in the StakingContract contract  The _rewards state variable in the RewardLiquidityPoolContract contract  Consider adding named parameters to the mappings in order to improve the readability and maintainability of the codebase.  Update: Resolved in pull request #48 at commit 25f7718.", "html_url": "https://blog.openzeppelin.com/auki-labs-audit#multiple-instances-of-missing-named-parameters-in-mappings", "labels": ["OpenZeppelin"]}, {"title": "Variable Cast is Unnecessary", "body": "In StakingContract, there are multiple variables that are unnecessarily casted:  The stakingToken variable in the slash function  The _stakingToken variable in the initialize function  To improve the overall clarity, intent, and readability of the codebase, consider removing these unnecessary casts.  Update: Resolved in pull request #48 at commit 437191d.", "html_url": "https://blog.openzeppelin.com/auki-labs-audit#variable-cast-is-unnecessary", "labels": ["OpenZeppelin"]}, {"title": "Use of Foundry-Specific Imports", "body": "Throughout the codebase, the current format for importing other Solidity files is from the lib folder of the repository. For example, the OpenZeppelin contract imports take the form of import {SomeContract} from \"lib/openzeppelin-contracts/*\". While this is suitable for developers working only in Foundry, other developers who are using this contract (particularly those who are not using Foundry as their smart contract development framework) may run into compilation errors when trying to integrate.  as described in the  OpenZeppelin documentation. This pattern can similarly be applied for other imports outside the OpenZeppelin library. In conjunction with this, a  file can be added in the home directory to map imports to their Foundry specific paths.  Consider changing the import format as suggested above and adding a remappings.txt. This will help improve the developer experience for developers working in different development frameworks.  Update: Resolved in pull request #48 at commit 496066f.", "html_url": "https://blog.openzeppelin.com/auki-labs-audit#use-of-foundry-specific-imports", "labels": ["OpenZeppelin"]}, {"title": "Gas Optimizations", "body": "Potential gas cost improvements were found throughout the codebase:  Extraneous require statement on token transfers. The AukiToken contract inherits from the OpenZeppelin libraries which already revert with an error message if a transfer fails.  In RewardLiquidityPoolContract.sol at line 33 and line 44 In StakingContract.sol at line 210  for loops that are using i++ can be optimized by upgrading to Solidity version 0.8.22 where the compiler will automatically generate an unchecked block to save gas.  In RewardLiquidityPoolContract.sol at line 54 and line 72  Variables of the Stake struct are being individually updated across several functions in StakingContract.sol. The struct can be saved into a local storage variable that can then be used and updated as needed. This applies to the following functions:  slash _stake _withdraw  A temporary local variable can be used to store the array length used in the for loops and require statements in RewardLiquidityPoolContract.sol. Specifically, the recipients.length in the following functions could be stored in a temporary variable:  increaseFixedAmount increaseDynamicAmount  The calldata keyword can be used instead of memory for dynamic array function parameters when the function is being called externally and the parameter is not manipulated within the function itself. This leaves the data inside of the calldata, rather than copying it to memory, which saves gas. The following examples were found in the codebase:  increaseFixedAmount increaseDynamicAmount  Consider applying these gas optimizations.  Update: Partially resolved in pull request #48 at commit 265a519. The local variables were added, the calldata keyword was used in the appropriate locations, and all the extraneous require statements were removed. The for loops were left unoptimized. The Auki Labs team stated:  We are constrained to use 0.8.19.", "html_url": "https://blog.openzeppelin.com/auki-labs-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestion", "body": "balance  function does not refer to the token balance of the contract, but rather is the token balance with the  subtracted from it. Consider updating the name of this function to  for clarity and to prevent name-clashing with the commonly used name  Consider applying the above naming suggestion to improve the consistency and readability of the codebase.  Update: Resolved in pull request #48 at commit e42401c.  RewardLiquidityPoolContract Is Not Upgradeable  RewardLiquidityPoolContract  is a non-upgradeable contract. Therefore, in the event that there is a need to update its code, the storage variables will not persist once a new version is deployed (i.e., the  _rewards mapping  will be reset). To preserve the values of the storage variables even after an upgrade, consider making  upgradeable.  Update: Resolved in pull request #48 at commit ce493df.  Superfluous virtual Keyword  _stake  and  _withdraw  functions have the  keyword. This indicates to a reader that these functions are intended to be overridden. However, the Auki Labs team has stated that they \"  Consider removing the virtual keyword to show clear intent to other developers and end users who are reading the code.  Update: Resolved in pull request #48 at commit 768c7eb.  Lack of immutable Keyword for Unchanging Variables  BurnContract,  RewardLiquidityPoolContract, and  StakingContract, the variable representing the  is a state variable. However, it cannot be changed by any function in the contract.  Consider adding the immutable keyword to this variable along with moving the variable initialization into the constructor. This will help save gas as well as improve code readability.  Update: Resolved in pull request #48 at commit d4c88ad.  .env Does Not Follow Best Practice  .env file  that has been pushed to Github contains a  used for Anvil testing. Although there are no real funds on this network, it is best to have sensitive information stored offline and only an example stored in an  file. Doing this will help prevent accidentally pushing a mainnet private key to Github, potentially resulting in the theft of funds.  file on Github and only leaving an example in an  file.  Update: Acknowledged, not resolved. The Auki Labs team stated:  The leaked private key is the one provided by the Anvil tool. It is already a leaked key and is used by everyone using Anvil from the Foundry toolchain. As such, we may keep it to ease the developer workflow.  Conclusion  Auki Labs aim to utilize blockchain technology to incentivize developers and operators through the AukiToken. The token is burned for posemesh credits, staked for reputation, and can be slashed for malicious behavior, with the rewards being distributed from a liquidity pool contract.  This was the first audit that the OpenZeppelin team has performed for Auki Labs. In the report, we uncovered a couple of medium-severity issues related to the integration of the OpenZeppelin libraries. We would like to thank the Auki Labs team for their quick and thorough responses which greatly helped our process.  The codebase was well-tested with nearly 100% coverage. While we understand that this project is still in its infancy and therefore in a centralized state, we hope that over time, it will slowly decentralize into a protocol with less trust assumptions and privileged roles.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/auki-labs-audit#naming-suggestion", "labels": ["OpenZeppelin"]}, {"title": "RewardLiquidityPoolContract Is Not Upgradeable", "body": "RewardLiquidityPoolContract Is Not Upgradeable", "html_url": "https://blog.openzeppelin.com/auki-labs-audit#rewardliquiditypoolcontract-is-not-upgradeable", "labels": ["OpenZeppelin"]}, {"title": "Superfluous virtual Keyword", "body": "Superfluous virtual Keyword", "html_url": "https://blog.openzeppelin.com/auki-labs-audit#superfluous-virtual-keyword", "labels": ["OpenZeppelin"]}, {"title": "Lack of immutable Keyword for Unchanging Variables", "body": "Lack of immutable Keyword for Unchanging Variables", "html_url": "https://blog.openzeppelin.com/auki-labs-audit#lack-of-immutable-keyword-for-unchanging-variables", "labels": ["OpenZeppelin"]}, {"title": ".env Does Not Follow Best Practice", "body": ".env Does Not Follow Best Practice", "html_url": "https://blog.openzeppelin.com/auki-labs-audit#.env-does-not-follow-best-practice", "labels": ["OpenZeppelin"]}, {"title": "External Call to Permit2 Allows Stealing Users' Tokens", "body": "During an order execution, it is possible to make arbitrary external calls to any stepTarget except the token manager. A vulnerability arises when setting stepTarget equal to the Permit2 address, which allows an attacker to make a call from the router to Permit2 using a valid order/signature pair from another benign user.  This results in the transfer of all tokens from the benign user to the router during the attacker's order execution, enabling them to steal all the tokens from the order.  Consider disallowing any external calls to Permit2 in both steps and relaying executions.  Update: Resolved in pull request #6 at commit 6ba7a7e. External calls to the Permit2 contract have been prohibited.  High Severity", "html_url": "https://blog.openzeppelin.com/beefy-zap-audit-1#external-call-to-permit2-allows-stealing-users'-tokens", "labels": ["OpenZeppelin"]}, {"title": "Denial-of-Service of Router Functionality", "body": "The _approveToken function of the BeefyZapRouter contract is responsible for approving each stepTarget to spend an unlimited amount of tokens. The function checks if the allowance is lower than the requested amount, and in that case it sets the approval to the maximum value.  However, when approving non-zero amounts, safeApprove (which is used in this function) requires the current allowance to be equal to zero.  This requirement can be manipulated by making use of external calls in stages or relays. These calls can directly communicate with one of the accepted tokens, setting a low allowance for the exchange. Consequently, this causes future attempts to utilize the token on the targeted exchange to revert.  Consider replacing the usage of safeApprove with the newer forceApprove function from the OpenZeppelin library.  Update: Resolved in pull request #7 at commit 76fd619. The usage of safeApprove in _approveToken has been replaced with the new forceApprove function.  Low Severity", "html_url": "https://blog.openzeppelin.com/beefy-zap-audit-1#denial-of-service-of-router-functionality", "labels": ["OpenZeppelin"]}, {"title": "Floating Pragma", "body": "Throughout the codebase, the version of Solidity used is ^0.8.0. This version indicates that any compiler version after 0.8.0 can be used to compile the source code. However, the code will not compile when using version 0.8.3 or earlier since there are functions that use custom errors that were introduced in Solidity 0.8.4.  Consider upgrading all contracts to Solidity version 0.8.4 at a minimum, but ideally to the latest version. This precautionary measure also helps prevent the accidental deployment of contracts with outdated compiler versions that could potentially introduce vulnerabilities.  Update: Resolved in pull request #8 at commit 71c3eee. The Solidity version has been locked to 0.8.19.", "html_url": "https://blog.openzeppelin.com/beefy-zap-audit-1#floating-pragma", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings. For instance:  Line 8 of BeefyTokenManager.sol  Line 5 of ZapErrors.sol  When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #9 at commit 132902c. The docstrings have been added to all contracts and interfaces.", "html_url": "https://blog.openzeppelin.com/beefy-zap-audit-1#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Witness Type String Does Not Follow EIP-712", "body": "witness string used by the  Uniswap's guidance on integrating with Permit2 and results in an incorrect EIP-712 type string being created.  This string is missing the declaration of Order order inside PermitBatchWitnessTransferFrom after the deadline parameter. In addition, there is no definition of the TokenPermissions object.  Consider updating the ORDER_STRING value to include the Order order parameter and the TokenPermissions object.  Update: Resolved in pull request #10 at commit e2aad12.", "html_url": "https://blog.openzeppelin.com/beefy-zap-audit-1#witness-type-string-does-not-follow-eip-712", "labels": ["OpenZeppelin"]}, {"title": "Missing Order Typehash Prefix for Witness Parameter", "body": "The witness parameter used by BeefyZapRouter does not follow Uniswap's guidance on integrating with Permit2 and is calculated only out of Order data, instead of prefixing the data with the Order typehash.  Consider prefixing Order data with the typehash before executing the keccak256 function.  Update: Resolved in pull request #11 at commit 0bcdf0c. The Order typehash has been added to the witness parameter.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/beefy-zap-audit-1#missing-order-typehash-prefix-for-witness-parameter", "labels": ["OpenZeppelin"]}, {"title": "Styling Suggestions", "body": "In the IBeefyZapRouter.sol contract, external files are imported before declaring the Solidity compiler version.  Consider declaring the Solidity version first to comply with the Solidity style guide.  Update: Resolved in pull request #12 at commit 0a5fc06. The order of the layout has been changed by declaring the Solidity version first and then importing external files.", "html_url": "https://blog.openzeppelin.com/beefy-zap-audit-1#styling-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Missing Custom Errors", "body": "The BeefyTokenManager contract is using a require statement to validate the caller of the pullTokens function. Since solidity version 0.8.4, custom errors provide a cleaner and more cost-efficient way to explain to users why an operation failed.  To improve the clarity of the codebase and save gas, consider replacing the error string with a custom error.  Update: Resolved in pull request #13 at commit 059af74. The require statement in the pullTokens function has been replaced with the custom error CallerNotZap.", "html_url": "https://blog.openzeppelin.com/beefy-zap-audit-1#missing-custom-errors", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "Throughout the codebase, the following typographical errors have been identified:  Line 16: \"TokenManger\" should be \"TokenManager\".  Line 147: \"appoved\" should be \"approved\".  Consider fixing these typographical errors to improve the readability of the codebase.  Update: Resolved in pull request #14 at commit 233fb84.", "html_url": "https://blog.openzeppelin.com/beefy-zap-audit-1#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unused Import", "body": "In IBeefyZapRouter.sol, the import IBeefyTokenManager is unused and could be removed.  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #15 at commit 606ea46. The unused IBeefyTokenManager import has been moved from the IBeefyZapRouter interface to the BeefyZapRouter contract.", "html_url": "https://blog.openzeppelin.com/beefy-zap-audit-1#unused-import", "labels": ["OpenZeppelin"]}, {"title": "Non-Explicit Imports Are Used", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code, and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are being used. For instance:  Line 5 of IBeefyTokenManager.sol  Line 3 of IBeefyZapRouter.sol  Line 4 of IBeefyZapRouter.sol  Line 5 of BeefyTokenManager.sol  Line 6 of BeefyTokenManager.sol  Line 5 of BeefyZapRouter.sol  Line 6 of BeefyZapRouter.sol  Line 7 of BeefyZapRouter.sol  Line 8 of BeefyZapRouter.sol  Line 10 of BeefyZapRouter.sol  Line 11 of BeefyZapRouter.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare the imported contracts.  Update: Resolved in pull request #16 at commit 151dd3d.", "html_url": "https://blog.openzeppelin.com/beefy-zap-audit-1#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Interface Mismatch", "body": "Consider matching the BeefyZapRouter contract implementation by correctly marking the following functions as view in the IBeefyZapRouter interface:  permit2  tokenManager  Update: Resolved in pull request #17 at commit c5ddf8c.", "html_url": "https://blog.openzeppelin.com/beefy-zap-audit-1#interface-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Fees Do Not Follow a Predictable Calculation", "body": "When sending a message with the TeleporterMessenger contract, there is no check to ensure that the fee deposited for the relayer who will submit the message on the destination subnet will be sufficient to cover the gas cost incurred by executing the message. This could cause users to spend more than what is required to execute their message, or less, in which case the message may not be relayed as it would not be profitable for a relayer.  Some message bridging protocols remedy this by predicting the gas cost based on the size of the message and the expected gas limit on the other subnet, which is translated into feeAsset units. Moreover, such protocols provide a view-only function to predict this value off-chain before submitting the message.  Consider adding functionality to estimate the necessary fee and assert it against the transferred fee assets.  Update: Acknowledged, not resolved. AVA Labs stated the following about the issue:  The fee asset and amount \"accepted\" by a given relayer is defined by that individual relayer themselves, so it makes sense for those fee estimates to be published off-chain, out of the scope of the Teleporter contract. For instance, some dApps/subnets may run a relayer that relays messages for free to attract more users. In other cases, one relayer may only accept fees paid in AVAX, while another accepts fees paid in USDC or other arbitrary ERC20 tokens. The fee amount of a given asset expected for a given relayer may also depend on the current gas price at the destination chain for a given message, the current price of the native gas token being spent by the relayer, and the current price of the asset being used to pay the relayer's fee. This information isn't necessarily available on-chain, and even if it were, different relayers may use different sources for this information. For these reasons, we think it's best to leave fee estimation and publishing to be handled on a case-by-case basis off-chain.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#fees-do-not-follow-a-predictable-calculation", "labels": ["OpenZeppelin"]}, {"title": "Nick's Method for Deployments Is Error-Prone", "body": "The TeleporterMessenger contract will be deployed at the same address on any subnet that wishes to allow cross-chain messaging using the Teleporter protocol. It is intended to use Nick's method to ensure that the contract is deployed at the same address on each subnet. Since Nick's method uses a signed transaction from a one-time address, a few concerns arise that could prevent deployment as intended. In particular:  If the deployment fails, the signed transaction will not be able to be retried as the signed nonce in the transaction for the one-time address will be used. This could occur if the call to WARP_MESSENGER.getBlockchainID() fails.  If a subnet defines non-standard costs for opcodes, the gasLimit in the signed transaction may not be large enough for the deployment transaction to be executed.  The gasPrice must also be set within the signed transaction. The gasPrice can vary widely between subnets due to the popularity of the chain as well as the liquid supply of native tokens used for paying for gas. If a subnet has a low total supply of the native token relative to other chains, the specified gasPrice may not be large enough to get the deployment transaction included in a block. Conversely, if a subnet has a relatively large liquid supply of native tokens, the gasPrice may require spending a large quantity of native tokens. This could result in an expensive deployment transaction when measured in fiat currency.  Consider using an alternative to Nick's method such as CREATE2. Alternatively, consider ensuring that there is a fallback approach to deploying the TeleporterMessenger contract at the intended address and that its procedure is well documented. This is so that the actors involved in the deployment of a new subnet can mitigate this problem without any friction.  Update: Partially resolved in pull request 64 at commit 5f8b039. blockchainID assignment has been moved from the constructor function into the receiveCrossChainMessage function. However, it would preferable to use a one-time only dedicated method to initialize the variable to reduce the attack surface and the gas cost when receiving messages from other subnets. Moreover, the deployment documentation does not include the additional information to deploy the contract under problematic situations. AVA Labs stated the following regarding the issue:  We have updated the TeleporterMessenger contract such that it has an empty/default constructor in order to minimize the potential for the deployment transaction to fail. Using CREATE2 is not really a viable alternative to Nick's method. It requires that a factory contract is deployed at the same address on each chain prior to creating the TeleporterMessenger instance using the factory. In order to deploy the factory contract to the same address on each chain (without having a shared account key used by every chain, as required in this case), Nick's method would still need to be used in the same manner, with the same possible error cases for that transaction to fail. The fallback approach in mind for a scenario where the normal TeleporterMessenger deployment transaction using Nick's method fails for a subnet is for that subnet to specify the contract in their genesis for new subnets, or add the code in a state upgrade as part of a required network update for existing subnets. While more cumbersome than sending a pre-defined transaction, each allows a surefire fallback approach for getting the contract code the necessary address on a given chain.  Low Severity", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#nick's-method-for-deployments-is-error-prone", "labels": ["OpenZeppelin"]}, {"title": "Abstract Contracts Allow Direct Modification of State Variables", "body": "In order to prevent re-entrant calls, the _sendEntered and _receiveEntered state variables in the abstract ReentrancyGuards contract track whether a call has been made to a \"sender\" or \"receiver\" function. Since these variables use internal visibility within an abstract contract, a child contract would be able to directly modify these values which could unintentionally allow a re-entrant call.  Consider using private visibility for all non-constant and non-immutable state variables in abstract contracts as OpenZeppelin's ReentrancyGuard contract does. If child contracts should be able to update values for the state variables, consider creating internal functions for updating these variables which emit appropriate events and verify that the desired conditions are met.  Update: Resolved in pull request #106 at commit 43d4c728.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#abstract-contracts-allow-direct-modification-of-state-variables", "labels": ["OpenZeppelin"]}, {"title": "Missing and Incomplete Docstrings", "body": "Throughout the codebase, there are several parts with missing or incomplete docstrings. In particular, function arguments and return values are consistently undocumented which limits users' ability to determine appropriate input values and expected outputs. Further, the following parts are missing docstrings:  Line 27 in TeleporterMessenger.sol  Line 32 in TeleporterMessenger.sol  Line 8 in ITeleporterMessenger.sol  Line 13 in ITeleporterMessenger.sol  Line 32 in ITeleporterMessenger.sol  Line 15 in ReceiptQueue.sol  Line 16 in ReceiptQueue.sol  Line 17 in ReceiptQueue.sol  Line 18 in ReceiptQueue.sol  Line 8 inIWarpMessenger.sol  Line 16 in IWarpMessenger.sol  Line 27 in SafeERC20TransferFrom.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Partially resolved pull request #106 at commit 43d4c728. The following instances still remain undocumented:  Line 37 in TeleporterMessenger.sol  Line 8 in IWarpMessenger.sol  Line 14 in IWarpMessenger.sol", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#missing-and-incomplete-docstrings", "labels": ["OpenZeppelin"]}, {"title": "External Call Is a Return Bomb Vector", "body": "When a relayer executes a message, an external call is made to the destinationAddress specified by the message sender where the amount of gas the call can use is specified in the message by the requiredGasLimit value. The return data from this call is not used and only the success of the call is recorded. Although a gas limit is set for the call, the external contract can force the transaction to use gas in excess of the specified limit due to an open issue with the Solidity compiler. This is possible because the TeleporterMessenger contract pays for memory expansion to accommodate the return data, but the external contract controls the size of that return data.  Consider using assembly to explicitly prevent any memory from being allocated for the return data from the external call.  Update: Resolved in pull request #119 at commit 1de7667. However, no test case for such an exploit has been added to the test suite. Consider including a test for this kind of attack.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#external-call-is-a-return-bomb-vector", "labels": ["OpenZeppelin"]}, {"title": "Multiple Mechanisms to Relay Receipts", "body": "When a message is received on a destination chain, a receipt must be sent back to the origin chain so that the relayer is able to claim its fee token for executing the message. Within the TeleporterMessenger contract, there are two different paths for a receipt to return to the origin chain. One is by the regular inclusion of the receipt in a message going back to the origin, which goes through the queue/dequeue process of the ReceiptQueue contract. The other is by a relayer calling the retryReceipts function and relaying only the specified receipt. The latter approach bypasses the ReceiptQueue contract, leaving in the queue receipts which have already been relayed. The different approaches are not only more difficult to follow and debug in case of exploits but also increase the attack surface and the overall gas consumption.  Consider unifying the receipt mechanism to reduce the attack surface and the complexity involved while still maintaining the possibility of moving stuck receipts forward.  Update: Acknowledged, not resolved. The Ava Labs team stated:  The secondary mechanism to allow for relaying specific receipts (now called \"sendSpecifiedReceipts\") was added per the recommendation of a previous audit, which had called out that the relayers may not be able to efficiently receive rewards in the case that messages flow predominantly in a single direction between two Teleporter instances, such that the receipt queue grows in the length over time. Using \"sendSpecifiedReceipts\", relayers are always able to redeem their reward themselves by sending a single empty message back to the destination. This would only be needed in the case that the receipt queue for the given chain has grown large and the relayer is not willing to wait for it to empty out in order to be able to redeem their rewards.  Making such that receipts sent via \"sendSpecifiedReceipts\" are removed from the receipt queue (if they are still in the queue) would require additional indices on the queue to be able to look up specific receipts at arbitrary positions, and remove items from arbitrary positions in the queue. This would significantly increase the complexity of the queue implementation and the gas cost of the common path enqueue/dequeue calls for receipt operations. Given that a receipt being sent multiple times is not a correctness issue, it is preferred to keep the complexity and gas cost of expected cases minimized.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#multiple-mechanisms-to-relay-receipts", "labels": ["OpenZeppelin"]}, {"title": "Lack of Validation That Contract Receiving Messages Supports ITeleporterReceiver Interface", "body": "must implement the receiveTeleporterMessage function from the  message is being executed. If a contract does not implement the  stored for a future execution.  However, if the receiving contract does not implement this function and instead implements a fallback, the call could be successful. This opens up the possibility whereby even though the message is being forwarded to the contract, the destination contract does not handle it but there is no reversion of the transaction. Moreover, implementing the receiveTeleporterMessage function cannot be used to assert that the destination address will be able to handle the message, leaving open the possibility of setting a destination address by mistake that will call its fallback function.  In favor of restricting the possibility of a message being delivered into a non-compatible contract on the destination subnet, consider using an EIP meant for introspection, such as EIP-1820, instead of assuming that contracts that do not possess a receiveTeleporterMessage hook cannot be called.  Update: Acknowledged, not resolved. AVA Labs stated the following regarding the issue:  We think that trying to determine if a given contract address implements a specific interface would introduce more complexities than the benefits it provides. Even if the contract implements the required interface properly, it still may be unable to handle messages properly due to other implementation issues, as noted in the report, so even the best of guard rails doesn't ensure the correctness of applications built to use Teleporter. It is the responsibility of applications using Teleporter to ensure that they are able to send and receive their specific messages properly.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#lack-of-validation-that-contract-receiving-messages-supports-iteleporterreceiver-interface", "labels": ["OpenZeppelin"]}, {"title": "Message Fee Can Be Increased by Any Account", "body": "The TeleporterMessenger contract allows users to add additional fees to a submitted message on the origin chain. However, there is no restriction on who can add the fees to a certain message. This results in two possible problems:  If the original sender wants to add additional fees to their own message, they may mistakenly send the fees to a different message as there is no validation to ensure that the msg.sender is the same one as the one that originally sent the message.  Malicious users might prevent a message from being relayed by adding stolen or OFAC-sanctioned funds into a particular message. Relayers may not want to risk receiving tainted funds even if the original fees deposited came from an honest source. As a result, relayers may not relay such messages.  In order to prevent unauthorized deposits into a particular message and to reduce the possibility of mistakenly depositing fees into a different message, consider restricting the deposit to the one that originally sent the message. Alternatively, consider using an allow list of addresses that can add more funds, similar to how authorized relayers are handled on the destination chain.  Update: Acknowledged, not resolved. The Ava Labs team stated:  It is not practical to limit the ability to add fees for a message to the sender of the message given that in most cases the sender of the message will be smart contract accounts. Thus, in order to add fee amounts from the same account, the smart contract would need to implement further logic to allow it to call the TeleporterMessenger.addFeeAmount function on behalf of users, increasing complexity, gas cost, and the likelihood of error that leads to it being impossible for anyone to add fee amounts for a given message.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#message-fee-can-be-increased-by-any-account", "labels": ["OpenZeppelin"]}, {"title": "Using Custom Ownership Logic", "body": "The enqueue and dequeue functions in the ReceiptQueue contract implement custom logic to ensure that only the owner of the contract (i.e., the TeleporterMessenger contract) is able to update the queue. Custom access control implementations are not recommended as they could introduce a larger attack surface if not implemented properly. Consider using OpenZeppelin's Ownable library instead.  Update: Resolved in pull request 32. The ReceiptQueue contract has been adapted to be a library and no longer needs access control from those methods.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#using-custom-ownership-logic", "labels": ["OpenZeppelin"]}, {"title": "Semantic Overload", "body": "Throughout the codebase, there are multiple instances where variables are used for multiple different purposes (Semantic-overloading. For instance:  The outstandingReceiptForDestination variable keeps track of the ReceiptQueue contract instance for a specific destination chain ID. However, it is also used to check if such a contract was deployed earlier in a previous operation.  The relayerRewardAddress address is meant to indicate the fee payment receiver after the message was sent. However, it is also used to flag whether a message has been delivered or not, even though fees might not be involved during the operation.  The getVerifiedWarpMessage function from the IWarpMessenger interface will return the message when the valid flag is true, but nothing when it is false. Meaning that the actual message output has the same behavior as the flag instead of returning the possibility of a false outcome while returning the message. The same applies to the getVerifiedWarpBlockHash function.  This can lead to the codebase not only being harder to understand but also harder to reason about from a security point of view.  Consider using separate flags to store different states instead of reusing variables. This will help increase the readability and understandability of the codebase.  Update: Partially resolved in pull requests 32 and 106. The outstandingReceipts mapping has been removed in favor of using the ReceiptQueue as a library. However, the relayerRewardAddresses is still being used to track if the message was received or not. AVA Labs stated the following regarding the issue:  outstandingReceiptForDestination no longer exists given that the receipt queues are now implemented in a library. In the case of relayerRewardAddress, using it to track whether a message has been delivered results in less state used by the contract, and fewer places in state that need to be properly updated for each message received, reducing the overall code complexity and gas costs. We created an internal messageReceived helper function to help increase code clarity.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#semantic-overload", "labels": ["OpenZeppelin"]}, {"title": "Incentive Misalignment When Sending a Message", "body": "The TeleporterMessenger contract implements functionality to allow certain actors (called relayers) to relay messages for users in exchange for a fee. Once the relayer has fulfilled its part and delivered the message on the destination chain, a receipt is created on the destination chain to be used as verification. It signifies that the work was done and allows the relayer to collect their fee on the origin chain.  However, the procedure to send these possible third-party receipts back to the origin involves attaching them to a message going in the opposite direction. Even though there is a limit on the maximum number of receipts attached to a message (currently 5), users will have to pay for gas expenditures unrelated to their message.  Moreover, when a user is acting as a relayer by both sending and relaying their own message, the associated fee for the message can be zero, as they would simply be paying themselves. However, the user is still required to attach receipts from the origin chain and process them on the destination chain without any additional reward.  Even though there is a mechanism for relayers to relay specific receipts without an associated message using the retryReceipts function, users cannot opt out of attaching receipts using the sendCrossChainMessage function if there are receipts to be forwarded.  Consider adjusting the incentive design around the receipts mechanism and allowing users to define the number of receipts they want to attach to their message.  Update: Acknowledged, not resolved. AVA Labs stated the following regarding the issue:  Acknowledged. Allowing users to define the number of receipts they want to attach to their message would result in messages not containing any receipts except for those beneficial to the sender themselves. In this case, relayers would always have to manually send messages back to the origin chain themselves for their receipts to be returned, multiplying the message overhead and also increasing the total relayer cost to redeem rewards.  While possibly suboptimal, we disagree that incentives are misaligned. Relayers must account for needing to provide gas for up to a maximum of 5 receipts being marked in state per message, and can do so by calculating that cost in order to determine if they are properly incentivized if charging per message. Message senders must account for this relayer cost in the fee to incentivize a relayer. Message senders relaying their own message (i.e., with no message fee), do have the additional gas cost of marking unrelated receipts, but this is considered a small cost overhead of using the Teleporter protocol.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#incentive-misalignment-when-sending-a-message", "labels": ["OpenZeppelin"]}, {"title": "Relayer Rewards Might Get Stuck", "body": "must pass a relayerRewardAddress address that can be different from the address that makes that call (  marks that fee as able to be withdrawn for the relayerRewardAddress address. The  redeem the balance accumulated to it by calling the  However, if there is a contract deployed at the relayerRewardAddress address that does not implement functionality to call the redeemRelayerRewards function (for instance, if it is meant to be used as a cold storage wallet), the rewards will be stuck as there is no way to redeem rewards on behalf of another address.  Consider allowing anyone to call the redeemRelayerRewards function on behalf of an input relayerRewardAddress address. This will help prevent funds from becoming stuck for addresses that lack the functionality to call the redeemRelayerRewards function.  Update: Acknowledged, not resolved. AVA Labs stated the following regarding the issue:  Allowing anyone to call redeemRelayerRewards on behalf of an input relayerRewardAddress has possible unintended side effects. For instance, there may be tax implications around when rewards are redeemed, or certain relayer operators may not be allowed to redeem specific rewards due to regulatory considerations. Any relayer can set arbitrary reward addresses owned by others when delivering a message, so it may be undesirable to also allow anyone to redeem those rewards on their behalf.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#relayer-rewards-might-get-stuck", "labels": ["OpenZeppelin"]}, {"title": "Relaying Message Without a Fee Requires Reward Address", "body": "When a message is submitted to the TeleporterMessenger contract, a fee is generally included that will be redeemable on the source chain by the relayer who executes the message on the destination chain. If a user wishes to relay their own message, the fee amount can be set to zero as they do not need to incentivize an external relayer to execute the message. When a user relays their message on the destination chain by calling the receiveCrossChainMessage function, they are expected to pass a non-zero relayerRewardAddress address regardless of whether there was a fee associated with the message. This could be counter-intuitive for the user as they may omit the relayerRewardAddress parameter or pass the zero address as there is no relayer to pay a reward to.  In order to improve the readability of the codebase and prevent debugging possible reverted transactions, consider using a flag to mark that such state has been reached. Alternatively, consider using an enum containing all the possible states of the message.  Update: Acknowledged, not resolved. AVA Labs stated the following regarding the issue:  This requirement is documented in the code, and if a given message has no fee or the deliverer otherwise does not want to redeem the reward for it, they can provide a non-zero \"black hole\" address such as 0x00...01. While using separate variables to track the state of message delivery may help code readability, it comes at the trade-off of complexity and gas cost.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#relaying-message-without-a-fee-requires-reward-address", "labels": ["OpenZeppelin"]}, {"title": "Lack of Security Contact", "body": "Providing a specific security contact (such as an email or ENS name) within a smart contract significantly simplifies the process for individuals to communicate if they identify a vulnerability in the code. This practice proves beneficial as it permits the project owners to dictate the communication channel for vulnerability disclosure, eliminating the risk of miscommunication or failure to report due to a lack of knowledge on how to do so. In addition, if the contract incorporates third-party libraries and a bug surfaces in these, it becomes easier for the maintainers of those libraries to contact the appropriate person about the problem and provide mitigation instructions.  Throughout the codebase, there are contracts that do not have a security contact. For instance:  The ITeleporterMessenger interface  The ReentrancyGuards contract  The ITeleporterReceiver interface  The TeleporterMessenger contract  The SafeERC20TransferFrom contract  The ReceiptQueue contract  The IWarpMessenger interface  Consider adding a NatSpec comment containing a security contact on top of the contract definitions. Using the @custom:security-contact convention is recommended as it has been adopted by the OpenZeppelin Wizard and the ethereum-lists.  Update: Partially resolved in pull request #106 at commit 43d4c728. The IWarpMessenger interface has not been updated to include a security contact.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#lack-of-security-contact", "labels": ["OpenZeppelin"]}, {"title": "Unused State Variables", "body": "Within the TeleporterMessenger contract, there are multiple unused state variables. For instance:  The REQUIRED_ORIGIN_CHAIN_ID_START_INDEX state variable  The MINIMUM_REQUIRED_CALL_DATA_LENGTH state variable  To improve the overall clarity, intentionality, and readability of the codebase, consider removing any unused state variables.  Update: Resolved in pull request #106 at commit 43d4c728.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#unused-state-variables", "labels": ["OpenZeppelin"]}, {"title": "Constant Not Using UPPER_CASE Format", "body": "In TeleporterMessenger.sol, the blockchainID constant is not declared using UPPER_CASE format.  According to the Solidity Style Guide, constants should be named with all capital letters with underscores separating words. For better readability, consider following this convention.  Update: Resolved in pull request #64 at commit 5f394a11. The blockchainID state variable is no longer defined as immutable and is assigned outside of the constructor.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#constant-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "Multiple Instances of Missing Named Parameters in Mappings", "body": "Since Solidity 0.8.18, developers can utilize named parameters in mappings. This means mappings can take the form of mapping(KeyType KeyName? => ValueType ValueName?). This updated syntax provides a more transparent representation of the mapping's purpose.  Throughout the codebase, there are multiple mappings without named parameters. For instance:  The queue state variable in the ReceiptQueue contract  The latestMessageIDs state variable in the TeleporterMessenger contract  The outstandingReceipts state variable in the TeleporterMessenger contract  The sentMessageInfo state variable in the TeleporterMessenger contract  The relayerRewardAddresses state variable in the TeleporterMessenger contract  The receivedFailedMessageHashes state variable in the TeleporterMessenger contract  The relayerRewardAmounts state variable in the TeleporterMessenger contract  Consider adding named parameters to the mappings to improve the readability and maintainability of the codebase.  Update: Resolved at commit c2f43256.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#multiple-instances-of-missing-named-parameters-in-mappings", "labels": ["OpenZeppelin"]}, {"title": "Unused Named Return Variables", "body": "Named return variables are a way to declare variables that are meant to be used within a function's body for the purpose of being returned as the function's output. They are an alternative to explicit in-line return statements.  In TeleporterMessenger.sol, there are multiple instances of unused named return variables. For instance:  The messageID return variable in the sendCrossChainMessage function  The messageHash return variable in the getMessageHash function  The delivered return variable in the messageReceived function  The relayerRewardAddress return variable in the getRelayerRewardAddress function  The feeAsset return variable in the getFeeInfo function  The feeAmount return variable in the getFeeInfo function  The messageID return variable in the getNextMessageID function  The messageID return variable in the _getNextMessageID function  Consider either using or removing any unused named return variables, while keeping the same convention in all cases for consistency.  Update: Resolved in pull request #106 at commit 43d4c728.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#unused-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Non-Explicit Imports Are Used", "body": "The use of non-explicit imports in the codebase can decrease the code clarity and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are being used. For instance:  Line 8 of ReceiptQueue.sol  Lines 8-9 of SafeERC20TransferFrom.sol  Lines 8-15 of TeleporterMessenger.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Resolved in pull request #106 at commit 43d4c728.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Lack of Event Emission", "body": "Within the TeleporterMessenger contract, the redeemRelayerRewards function allows a relayer to redeem rewards they are owed for relaying messages. This function does not emit an event besides the Transfer event that ERC-20 tokens should emit.  Consider emitting an event to ensure accurate off-chain monitoring of reward withdrawals without relying on external ERC-20 token event emissions.  Update: Resolved in pull request 53 at commit 874d6d3.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#lack-of-event-emission", "labels": ["OpenZeppelin"]}, {"title": "Misleading Error Name", "body": "will revert when there is no message for the input messageID and destinationChainID. This occurs when the message hash for the corresponding message in the  Consider renaming this error message to ensure it is clear under what scenarios it may cause execution to revert.  Update: Resolved in pull request 59.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#misleading-error-name", "labels": ["OpenZeppelin"]}, {"title": "Redundant Getter Functions", "body": "In the TeleporterMessenger contract, there are external getter methods that are redundant given the public state variables. In particular:  The getRelayerRewardAddress function is redundant given the relayerRewardAddresses mapping.  The checkRelayerRewardAmount function is redundant given the relayerRewardAmounts mapping.  Consider either removing the aforementioned functions or reducing the visibility of the relayerRewardAddresses and relayerRewardAmounts state variables to internal or private.  Update: Resolved in pull request #106 at commit 43d4c728. The visibility of the relayerRewardAddresses and relayerRewardAmounts mappings have been changed to internal.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#redundant-getter-functions", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "Consider correcting the following typographical errors to improve the readability of the codebase:  On line 102 of ITeleporterMessenger.sol, \"it's\" should be \"its\".  On line 142 of TeleporterMessenger.sol, \"mush\" should be \"must\".  On line 350 of TeleporterMessenger.sol, \"subsquent\" should be \"subsequent\".  On line 386 of TeleporterMessenger.sol, \"preivously\" should be \"previously\".  On line 413 of TeleporterMessenger.sol, \"exeuction\" should be \"execution\".  On line 648 of TeleporterMessenger.sol, \"adress\" should be \"address\".  Update: Resolved in pull request #106 at commit 43d4c728.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Interface Does Not Fully Represent the Implementation", "body": "In the ITeleporterMessenger interface, there are several getters and functions from the TeleporterMessenger contract, which implements ITeleporterMessenger interface, that are not declared in the interface.  In order to improve the readability and facilitate such methods for third-party developers using the protocol, consider adding those to the interface.  Update: Partially resolved in pull request #106 at commit 43d4c728. Several getters remain that are not declared in the interface.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#interface-does-not-fully-represent-the-implementation", "labels": ["OpenZeppelin"]}, {"title": "Misleading Documentation", "body": "In the SafeERC20TransferFrom library, the docstring for the library states that it \"checks the balance of the recipient\". Since the recipient is hardcoded as address(this), consider updating the docstring to make it clear that the recipient is always the contract using the library.  Update: Resolved in pull request 106.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Solidity Programming Best Practices and Recommendations", "body": "Throughout the codebase, several areas were identified where the code style could be improved. In particular:  The checkIsAllowedRelayer function in the TeleporterMessenger contract could use either internal or private visibility. The function performs a simple computation that would likely be done off-chain by relayers and given that it is a pure function, it has no dependence on the contract state. Moreover, the allowed relayer could simply pass the respective index at which their address is in the allow list instead of looping through all of it. Therefore, if it is not allowed, the transaction will revert as none of the possible provided indexes could pass the check.  The events for the TeleporterMessenger contract are defined in the ITeleporterMessenger interface while the errors are defined within the TeleporterMessenger contract. Consider defining both the errors and events within the interface.  Lines 782-787 of TeleporterMessenger.sol could be simplified by using a min function such as the one from the OpenZeppelin Math library.  The TeleporterMessageInput struct is only used as an input to the sendCrossChainMessage function. Consider removing this redundant struct.  The outstandingReceiptForDestination variable name does not align with its purpose which is to hold the ReceiptQueue contract for a given chain ID. Consider using a variable name that clearly indicates the purpose of the variable.  Consider addressing these areas to improve the readability of the codebase.  Update: Partially resolved in pull request 106. Function visibility has been reduced and OpenZeppelin's Math library has been imported. AVA Labs stated the following regarding the issue:  Still loop through allowed relayers where necessary to avoid extra parameters needing to be provided by the relayer, and considering an expected case is that the array is empty so that any relayer is allowed.  Custom errors have been removed in favor of explicit require statements with custom string messages to allow for a more user-friendly error display in explorers.  TeleporterMessageInput is now also used for sendCrossChainMessage, and is unfortunately necessary to reduce stack depth within the functions where it's used.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#solidity-programming-best-practices-and-recommendations", "labels": ["OpenZeppelin"]}, {"title": "Redundant Function Argument", "body": "feeContractAddress argument for the  sentMessageInfo mapping.  Consider removing this argument to reduce redundant code.  Update: Acknowledged, not resolved. The Ava Labs team stated:  The redundancy feeContractAddress argument will be kept as a safeguard if callers specify the wrong message ID accidentally which could result in an unexpected asset being transferred out of their account. This case would be especially bad for assets with different \"decimal\" values where the amounts could be extremely high.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#redundant-function-argument", "labels": ["OpenZeppelin"]}, {"title": "Gas Optimizations", "body": "Gas Optimizations", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Recommendations", "body": "Monitoring   Conclusion  Summary  This audit was performed prior to production usage of Teleporter. Any identified issues did not affect a production instance of Teleporter.  DeFi  From 2023-10-02  To 2023-10-31  Solidity  28 (13\u202fresolved, 7\u202fpartially\u202fresolved)  0 (0\u202fresolved)  0 (0\u202fresolved)  2 (0\u202fresolved, 1\u202fpartially\u202fresolved)  11 (3\u202fresolved, 2\u202fpartially\u202fresolved)  15 (10\u202fresolved, 4\u202fpartially\u202fresolved)  Scope  We audited the ava-labs/teleporter repository at commit 253b833 and the ava-labs/subnet-evm repository at commit c354ad6.  In scope were the following files:  The example cross-chain applications (CCAs) included in the repository under the contracts/src/CrossChainApplications directory were reviewed and used as a reference for how the TeleporterMessenger contract is intended to be used. These examples were not explicitly audited and this report does not include any issues found while reviewing these examples.  Tests, dependencies, and other parts of the protocol have been left out of the audit. Knowledge of how the main Avalanche network works has been used to explore possible attack vectors but was not considered part of the scope.  System Overview  The Teleporter messenger creates a user-friendly layer to send arbitrary messages between subnets using the Warp messaging system. The Warp Messenger operates at the virtual machine (VM) layer and offers the most flexibility for moving a payload between subnets. The Teleporter messenger, however, makes use of this flexibility and adds limitations to prevent incorrect use, such as replayability or Sybil attacks on other subnets. As such, it is meant to be used as an intermediate contract between CCAs and the Warp Messenger and is not meant to be used with non-contract recipients.  When a user wants to send a message from the origin subnet through the CCAs' endpoint, the message is wrapped, given a message ID, stored, and sent to the Warp Messenger precompile. Next, a relayer bundles them together in a certain arbitrary order, gets a signature for each message, and then aggregates a BLS signature for the unsigned messages. The relayer then submits a transaction on the destination chain where the messages and signature are submitted in the Access List of the transaction, encoded as a precompile. Each message on the destination chain will contain a destination address and subnet as specified when sending the message. Due to their design, the TeleporterMessenger contracts in all subnets will be deployed under the same address using Nick's deployment method. Meaning, the destination address for the Warp message will be the same address as the TeleporterMessenger contract at the origin subnet.  Relayers are incentivized to process messages through an ERC-20 token fee that is paid for by the message sender. The message sender is able to specify which ERC-20 token they wish to pay for their message with and how much of that token to spend. A relayer is only able to redeem this fee after they have executed the message on the destination chain and a receipt has been received on the origin chain.  Due to the flexibility of the fee mechanism, it is expected that relayers will only relay messages that will be profitable for them to execute and for ERC-20 tokens that they have vetted. The message sender must decide what ERC-20 token to use and an appropriate amount to incentivize relayers with. The fee amount for a message can be increased after initial submission to further incentivize relayers if the message is not being relayed. The relayer asks for validation and when enough validators' signatures (weighted in stake) reach the threshold, the message can be delivered to the recipient on the destination subnet.  While the message is being submitted, the relayer calls the hook on the TeleporterMessenger contract in the same transaction to receive the message and tries to execute it. If, for some reason external to the relayer, the message cannot be executed, it is stored to be executed again in the future. However, as the relayer's task is done, a receipt is created to then be attached to a message going in the opposite direction. Thus, when it is delivered, the relayer can collect the fee stored in the origin TeleporterMessenger contract for its work.  The protocol also includes mechanisms to speed up the receipt movement (in case no messages are going in the opposite direction), retry methods for failed executions, and add more fees to a sent message, among other things.  Security Model and Trust Assumptions  Subnets are special chains in the Avalanche project that allow for the modification of how the chain works at the VM level. This means that users must be aware of the fact that gas costs, opcodes, behaviors, and other characteristics might vary from one subnet to another. This not only impacts the operational workflow but could also cause issues if CCAs are not completely tackling these changes on each chain.  Moreover, the Warp protocol is meant to be as l", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#recommendations", "labels": ["OpenZeppelin"]}, {"title": "Monitoring Recommendations", "body": "While audits help in identifying code-level issues in the current implementation and potentially the code deployed in production, the AVA Labs team is encouraged to consider incorporating monitoring activities in the production environment. Continuous monitoring of deployed contracts helps identify potential threats and issues affecting production environments. With the goal of providing a complete security assessment, this section recommends several actions addressing trust assumptions and out-of-scope components that can benefit from on-chain monitoring.  Suspicious Activity  OFAC-sanctioned addresses interact with your smart contract.  Destination contracts on the destination subnet do not belong to any familiar protocol or project.  Failed messages that are stored at the destination chain due to trying to be executed at addresses without any code (ticking bomb).  Higher-than-average payload size.  Validators' downtime for signing bundle messages.  Calls that have the TeleporterMessenger contract as the recipient.  Financial  Front-run scenarios on an ongoing message delivery.  Users make use of a custom token to pay the fees.  Receipts pile up in a particular chain and do not return to their origin chain.  TeleporterMessenger contracts' fee balances.  Technical  ReceiptQueue contract reaches a stuck scenario where it cannot retrieve the size output.", "html_url": "https://blog.openzeppelin.com/ava-teleporter-audit#monitoring-recommendations", "labels": ["OpenZeppelin"]}, {"title": "PSP22 Capped Amount Is Not Enforced Upon Minting", "body": "The PSP22Capped extension provides various functions to initialize a cap value, check the cap amount, and verify if a given amount exceeds the cap for PSP22-compliant contracts to limit the number of tokens that can be created.  However, it currently lacks enforcement to ensure that the cap amount is not exceeded during a mint operation. This omission can lead to confusion and potential errors. Users might assume that merely implementing PSP22Capped in their contracts will automatically incorporate this feature, similar to other extensions such as Burnable or Mintable, since the contracts will compile and be deployable because the _before_token_transfer function in the PSP22 contract is defined as an empty function.  Additionally, note that the absence of enforcement for this behavior can potentially create issues when using other extensions. For instance, if the cap is not adequately enforced and the user's PSP22 implementation also incorporates the FlashLender extension, it could lead to situations where flash borrowers exceed the cap during flash loans.  To address this, consider overriding the _before_token_transfer function defined in the PSP22 implementation within the PSP22Capped implementation. By doing so, when the mint function is called, the hook will be triggered, and it will guarantee that the current supply plus the minted amount does not surpass the cap.  Update: Resolved in pull request #141 at commit 4e6e93d.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#psp22-capped-amount-is-not-enforced-upon-minting", "labels": ["OpenZeppelin"]}, {"title": "PSP22 Is Vulnerable to Double-Spending", "body": "The PSP22 contract defines the approve function, which permits a user to specify the number of tokens that another user can expend on their behalf.  However, this function is susceptible to the well-known double-spending attack, functioning as follows:  Alice grants Bob the authority to expend 1000 tokens on her behalf.  After some time, Alice decides to decrease the allowance from 1000 tokens to 500 tokens through the approve function, using Bob's AccountId and the new allowance as parameters.  Bob anticipates this action and spends 1000 tokens on Alice's behalf, diminishing the allowance from 1000 tokens to 0.  Alice's action is executed, establishing the new allowance amount as 500 tokens.  Bob spends 500 tokens on Alice's behalf, resulting in a total of 1500 tokens spent.  Since the PSP22 implementation introduced the increaseAllowance and decreaseAllowance functions to modify token allowances for user expenditure, and considering the discussions with the OpenBrush team about potentially redefining the PSP22 or proposing a new fungible token contract standard, consider removing the approve function from the PSP22 implementation.  Update: Acknowledged, not resolved. The Brushfam team stated:  It is not worth to break the standard to incorporate this change.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#psp22-is-vulnerable-to-double-spending", "labels": ["OpenZeppelin"]}, {"title": "Zero Address Management Inconsistencies", "body": "In the Substrate ecosystem, public addresses adopt the SS58 encoding. The Base-58 alphabet omits characters prone to confusion when printed, such as the number 0.  Given this, referring to the \"zero address\" from EVM blockchains can be confusing. In this context, what could potentially use zeros is the public key, which is seldom referenced by regular users. The very idea of a \"zero address\" does not seamlessly translate from EVM chains to Substrate chains.  Additionally, the address derived from a hex public key composed entirely of zeros varies across different Substrate chains.  Throughout the codebase, the term \"zero address\" appears numerous times. However, in many instances, it actually refers to Options without an associated AccountId (\"None\") which can lead to potentially harmful misunderstandings.  When using AccountId without an associated address, it might be preferable to use \"None\". It is also recommended to rename or refactor any \"zero address\" references throughout the codebase for clarity. For instance, consider changing PSP22TokenTimelockError::BeneficiaryZeroAddress to PSP22TokenTimelockError::BeneficiaryIsNotSet.  Update: Resolved in pull request #136 at commit 36e2a49.  Medium Severity", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#zero-address-management-inconsistencies", "labels": ["OpenZeppelin"]}, {"title": "Native Ink! Transfers Are Not Traceable in PaymentSplitter Contract", "body": "The PaymentSplitter contract implements a receive function used to add funds to the contract. When calling this function, an event is emitted to keep track of all funds received in the contract and the sender's identity.  However, there is no way to keep track of deposits made through the ink! transfer function. Consequently, other contracts will need to be aware of the PaymentSplitter's implementation and its functions, as they must know about the aforementioned receive function. In general, transfers between protocols should occur in a standardized manner (for instance, using the transfer function mentioned above), which enhances interoperability between systems.  For instance, if one of the beneficiaries of the PaymentSplitter contract is another PaymentSplitter contract when releasing funds to this beneficiary, the funds sent will not be tracked since the contract is using the aforementioned transfer function instead of the receive function.  Currently, there appears to be no direct solution for initiating an action within a contract when funds are sent to it. This limitation stems from ink!, not OpenBrush. Consider encouraging the ink! team to incorporate a standard receive function, which could then be triggered upon someone executing a native transfer to a contract.  Update: Acknowledged, not resolved. The Brushfam team stated:  We will communicate with ink! team to fix the issue, for now will just update the documentation about this issue.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#native-ink!-transfers-are-not-traceable-in-paymentsplitter-contract", "labels": ["OpenZeppelin"]}, {"title": "PSP22Wrapper's deposit_for/withdraw_to Implementations Might Lead to Stuck Tokens", "body": "deposit_for function of  the _recover function, which enables anyone to sweep  The WToken-to-Token ratio will return to 1:1.  Consequently, those tokens will be stuck in the wrapper token forever.  Note that a similar behavior can occur when calling the withdraw_to function sending the wrapper contract address as the account parameter.  Consider adding a check in the deposit_for and withdraw_to functions to ensure that the account parameter is not the wrapper contract's address, preventing such tokens from getting trapped in the wrapper token indefinitely.  Update: Resolved in pull request #140 at commit 57d90f8.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#psp22wrapper's-deposit_for/withdraw_to-implementations-might-lead-to-stuck-tokens", "labels": ["OpenZeppelin"]}, {"title": "Incorrect max_flashloan Amount When Using FlashLender and PSP22Capped Together", "body": "The max_flashloan function in FlashLenderImpl calculates the total amount of tokens to be flash-minted as the total maximum balance minus the current total supply of the PSP22.  However, when using both the FlashLender and PSP22Capped extensions, the max_flashloan function does not take into account the cap. This means that when users call the function, an incorrect amount will be returned. If users then consider this amount as valid and attempt to perform a flash-borrow operation, the transaction can revert.  Consider adding a function that checks the cap (by calling the _cap function) and calling it within max_flashloan to obtain the correct flash loan amount.  Update: Resolved in pull request #142 at commit c1c1fe1.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#incorrect-max_flashloan-amount-when-using-flashlender-and-psp22capped-together", "labels": ["OpenZeppelin"]}, {"title": "Lack of Standard Interface Detection Mechanism Implemented in Contracts", "body": "In the Openbrush contracts, there is no standard way to check whether a contract supports specific interfaces or features. In the Ethereum ecosystem, this can be accomplished if a contract is compliant with EIP-165. An interface is a collection of functions that define a set of behaviors. By implementing a standard, contracts can expose a method to query whether they support specific interfaces, making it easier for other contracts to understand their capabilities.  Some advantages of having standardized interface detection are:  Interoperability: It ensures that contracts can communicate and interact efficiently by checking for compatible interfaces. This is crucial in the decentralized ecosystem, where smart contracts interact with each other without relying on a central authority.  Efficient Function Calls: Provide a computationally efficient and standardized method to check for function signature support, which reduces the risk of unexpected errors and makes function calls more reliable.  Security: Prevents erroneous interactions between contracts by allowing them to check whether an interface is implemented before invoking specific functions. This can help prevent costly mistakes and potential security vulnerabilities.  Upgradeability: Since in the ink! programming language smart contracts can be upgraded, and new functionality can be added to existing contracts, this standardization would allow new versions of contracts to indicate support for the same interfaces as the previous versions, ensuring backward compatibility and smooth upgrades.  Consider defining and implementing a standard interface detection mechanism in the OpenBrush smart contracts to improve their overall usability, safety, and efficiency by providing a consistent way for contracts to query and identify the features they support.  Update: Resolved in pull request #112 at commit d145cfd. The Brushfam team stated:  PSP61 was already added in the latest versions of OpenBrush but was not in the scope of audit.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#lack-of-standard-interface-detection-mechanism-implemented-in-contracts", "labels": ["OpenZeppelin"]}, {"title": "Wrong Event Emitted In PaymentSplitter::receive Function", "body": "The receive function in the PaymentSplitter contract is responsible for receiving funds from accounts. However, instead of emitting the _emit_payment_received_event, it is emitting the _emit_payee_added_event. Although this appears to be intentional based on the comment in the payment splitter trait, this could lead to confusion since added payees will get mixed with accounts that contribute to the total balance of the contract, potentially hindering off-chain services' task of searching and filtering for added payees and funds within the system.  Consider emitting the _emit_payment_received_event in the receive function event instead.  Update: Resolved in pull request #139 at commit 7482cfd.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#wrong-event-emitted-in-paymentsplitter::receive-function", "labels": ["OpenZeppelin"]}, {"title": "Lack of Test Coverage Tracking", "body": "Test coverage provides an essential metric in software development, reflecting the proportion of the codebase verified by tests. Without a system to monitor this, there is a heightened risk of undetected bugs and a decline in code quality.  To ensure software reliability, consider integrating a test coverage tracking tool into the development process. This tool highlights untested areas, promoting more thorough testing and a stronger end library.  Update: Acknowledged, will resolve. The Brushfam team expressed that they will resolve the issue.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#lack-of-test-coverage-tracking", "labels": ["OpenZeppelin"]}, {"title": "Wrong Argument Validation in Modifier Generation", "body": "In the generate function of the modifier_definition macro, modifier arguments are matched against certain expected types. When checking that the second argument is not self, the if let block erroneously tries to match against the first argument again. This may allow flawed methods to be accepted as valid modifiers.  Additionally, when matching on additional arguments, the error message implies a necessary check that the argument is passed by value and implements the Clone trait. However, the check only ensures that the argument is not a reference.  Consider correcting the argument validation in the generate function to correspond to the intended behavior.  Update: Partially resolved in pull request #144 at commit b48968d. The client did not take any action on the inaccurate error message. They expressed that checking if Clone trait is implemented, it is not realistic to do in Rust. Nonetheless, they should modify the error message to more accurately reflect what the code is actually checking.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#wrong-argument-validation-in-modifier-generation", "labels": ["OpenZeppelin"]}, {"title": "Macro Implementations Missing Adequate Docstrings", "body": "In the codegen folder, the files that hold the implementations for each macro are missing proper docstrings. Given the complexity and length of the code, adding detailed docstrings is strongly recommended. This will make it easier for readers and developers to understand the inner workings of the codebase.  Update: Acknowledged, will resolve. The Brushfam team expressed that they will resolve the issue. Progress can be tracked on issue #155 in the repository's issue tracker.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#macro-implementations-missing-adequate-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Error-Prone and Unnecessary Push-Payment Mechanism in PaymentSplitter Contract", "body": "The PaymentSplitter contract implements a push-payment mechanism through the internal _release_all function. This function iterates through all the payees added to the contract and transfers the corresponding amount to each of them.  However, this function presents the following problems:  If one of the beneficiaries has already claimed their part and their releasable amount is 0, then even if other beneficiaries have yet to receive their part, the whole transaction will revert.  If the number of beneficiaries is too big, the function call might revert due to the defined block limit size in Polkadot.  Even though this function is not public and therefore not accessible by default, library users might want to call this function from custom public functions, potentially triggering the aforementioned errors.  Consider removing the _release_all function, documenting why there is no push-payment implementation provided by the library, and encouraging the use of the release function's pull-payment mechanism instead.  Update: Resolved in pull request #145 at commit e5de183.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#error-prone-and-unnecessary-push-payment-mechanism-in-paymentsplitter-contract", "labels": ["OpenZeppelin"]}, {"title": "No Access Control on Setters Produced by accessors Macro", "body": "The accessors macro implements getters and setters for struct fields, which can be called externally in a smart contract context since they are annotated with #[ink(message)]. It is vital to ensure that any sensitive or critical state variables cannot be trivially accessible or modifiable using these generated functions, as it could expose vulnerabilities in the contract.  Currently, modifiers cannot be attached to these setters, and there is inadequate documentation cautioning users about this macro's use.  Consider modifying the macro setter attribute to incorporate access control capabilities. Furthermore, it would be ideal for the setters to come with access control mechanisms enabled by default and only allow them to be disabled if users intentionally choose to do so.  Update: Acknowledged, will resolve. The Brushfam team stated that they will resolve the issue:  The macro is going to be reworked soon, the suggestion will be implemented there, progress can be tracked here: https://github.com/Brushfam/openbrush-contracts/issues/135.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#no-access-control-on-setters-produced-by-accessors-macro", "labels": ["OpenZeppelin"]}, {"title": "Fetching Code Directly From Repository", "body": "The openbrush-contracts repository makes its public crates available only through direct fetching from the repository. This introduces potential risks of instability and security breaches. Using a crates registry, where each crate undergoes a review and verification process, mitigates these concerns and ensures more reliable code access.  Consider using a crates registry for all the public crates within the codebase. Crates.io, for example, offers these benefits while also providing continuous access to crates, protecting against the pitfalls of repository deletions.  Update: Acknowledged, will resolve. The Brushfam expressed that they will resolve the issue:  We will be uploaded to registry in a new release, could not be uploaded before because OpenBrush was using pallet-assets-chain-extension, which is a git dependency. In new versions we are planning to move psp22_pallet in another repo and publish OpenBrush. Issue: https://github.com/Brushfam/openbrush-contracts/issues/154.  Low Severity", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#fetching-code-directly-from-repository", "labels": ["OpenZeppelin"]}, {"title": "Flash Fee Burned Instead of Sent to a Beneficiary", "body": "The flashloan function within the FlashLenderImpl trait is responsible for sending the flash-minted tokens to the flash receiver and calculating the fee that the borrower must pay. However, despite the fee being used for calculations, the FlashLender implementation never sends it to a flash fee receiver. Instead, it burns the fee without an apparent reason.  Consider defining a flash_fee_receiver function that returns the AccountId of the fee beneficiary, and subsequently sends the fee amount to that account. Alternatively, consider documenting the rationale behind burning the fees if there is a specific reason for this approach.  Update: Resolved in pull request #157 at commit dcf5843.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#flash-fee-burned-instead-of-sent-to-a-beneficiary", "labels": ["OpenZeppelin"]}, {"title": "PaymentSplitter Beneficiary Amounts to Release Are Not Retrievable", "body": "The PaymentSplitter implementation lacks a public function for beneficiaries to perform a read-only query of the current amount of funds they can release. As a result, they may be uncertain about whether the transaction cost will exceed the amount to be released, particularly when the releasable amount is low. Additionally, if there are no funds available for release, the transaction will revert, causing users to incur costs unnecessarily.  Consider adding a releasable function, similar to the one implemented in older versions of the OpenZeppelin contracts library. This function would allow beneficiaries to check how much money they can release, even when they have no funds available for release.  Update: Resolved in pull request #146 at commit 4e81921.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#paymentsplitter-beneficiary-amounts-to-release-are-not-retrievable", "labels": ["OpenZeppelin"]}, {"title": "Missing Documentation for End-to-End Tests", "body": "Simulating on-chain interactions is an essential part of the testing process during development for blockchain applications. In ink!, E2E tests are used for this purpose. The OpenBrush examples use the E2E tests frequently, where functions are annotated with the #[ink_e2e::test] attribute. Due to ongoing issues with cargo-contract and substrate-contracts-node, particular versions of toolchain components are currently required to run these types of tests, which may fail when using the latest versions. Consider adding documentation for the recommended setup to run these tests.  Update: Resolved in pull request #148 at commit de87bf6.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#missing-documentation-for-end-to-end-tests", "labels": ["OpenZeppelin"]}, {"title": "Ownership Can Be Transferred to \"None\"", "body": "This comment on the Ownable trait states that the transfer_ownership function should produce a NewOwnerIsZero error if the new owner is \"None\".  However, the implementation of transfer_ownership never produces this error, allowing any address to be used as the transfer recipient. Consider modifying the ownership transfer logic to produce this error if the provided new_owner argument is \"None\".  Update: Partially resolved in pull request #137 at commit 5088162. The inline comment in the ownable trait still references the NewOwnerIsZero error.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#ownership-can-be-transferred-to-\"none\"", "labels": ["OpenZeppelin"]}, {"title": "Checking for Unused Attribute in Contract Macro", "body": "consume_traits function of the  checked for the  generated. Hence,  the code block is never entered. Consider refactoring the contract macro by removing unused code to improve efficiency and readability.  Update: Acknowledged, not resolved. The Brushfam team stated:  The consume_traits function is desired to work if some trait_definition is described inside contract module, so it is better to leave it there.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#checking-for-unused-attribute-in-contract-macro", "labels": ["OpenZeppelin"]}, {"title": "All Traits Loaded Into End-User Projects", "body": "The OpenBrush library uses Rust features to allow users to selectively integrate contracts and modules into their codebases, thereby only importing the contracts they need. However, the system operates differently for traits. Traits are not governed by features and are loaded automatically. This means that regardless of the features chosen by the end user, all traits get loaded. This leads to unnecessary overhead at compilation time, especially for trait-related macros (trait_definition and wrapper). Moreover, metadata files are produced for all traits, even for contracts that are not utilized in the user's project.  Consider reorganizing the traits folder so that the traits within also use Rust features. This ensures that only relevant traits, those corresponding to the contracts users have integrated from the library, are loaded into user codebases.  Update: Acknowledged, will resolve. The Brushfam team expressed that they will resolve the issue:  _ We will think about appropriate way for resolving this issue._", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#all-traits-loaded-into-end-user-projects", "labels": ["OpenZeppelin"]}, {"title": "Code Repetition", "body": "Throughout the codebase, there are instances of similar or identical code being used that could be consolidated. For example:  In the PSP22PalletMetadataImpl Trait  The token_name, token_symbol, and token_decimals functions access the pallet assets in the following manner:  fn  self  >  Option  String  let  self_  self  data  ();  let  name  self_  pallet_assets  get_or_default  ()  ..  ..  This code is repeated in each function. Consider centralizing this logic by creating metadata_symbol, metadata_name, and metadata_decimals functions and calling them in each corresponding function.  In accessors.rs  The generate_struct is nearly identical to the one used in storage_item. Consider reusing it as much as possible.  The only difference between the extract_get_fields and extract_set_fields functions is the parameter passed to is_ident (\"get\" for the former and \"set\" for the latter). Consider consolidating both functions in one single function and adding one parameter to distinguish between \"set\" and \"get\".  In implementation.rs / contract.rs  Both implementation and contract macros check that the module is not an out-of-line module declaration, which will be passed twice during code generation. Consider doing this check a single time.  Update: Partially resolved in pull request #150 at commit dc91955. The client resolved code repetition in PSP22PalletMetadataImpl and part of accessors.rs but did not take any action on implementation.rs / contract.rs. The Brushfam team stated:  Out of module declaration is more extracting values, not a check. Generating structs differs for working with fields, so we left them as they are for now.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#code-repetition", "labels": ["OpenZeppelin"]}, {"title": "Using the Full License in Each File Adds Unnecessary Bulk", "body": "Throughout the OpenBrush repository, most files use the complete license, which can be redundant and potentially distracting for users reviewing the code.  Consider adopting an SPDX license identifier as an alternative to embedding the entire license in every file.  Update: Partially resolved in pull request #147 at commit a0f48bc. The license text has been replaced with SPDX license identifiers in the files within the contracts folder. However, files in the lang and tests folders still contain the full license.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#using-the-full-license-in-each-file-adds-unnecessary-bulk", "labels": ["OpenZeppelin"]}, {"title": "Lack of License Identifier", "body": "Some files within the lang folder do not have a license identifier. For example:  accessors.rs  implementations.rs  To avoid legal issues regarding copyright and follow best practices, consider adding the license identifier at the beginning of each file.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#lack-of-license-identifier", "labels": ["OpenZeppelin"]}, {"title": "Undocumented Metadata Usage", "body": "When compiling a project that employs the Openbrush library, a directory named __openbrush_metadata_folder is produced, housing metadata files for each trait in the library.  These metadata files lack extensions and essentially provide an unformatted copy of the corresponding trait. The intent or utility of these metadata files remains unclear, and their current format does not align with conventional expectations for metadata - which is data describing other data.  It would be beneficial to introduce documentation clarifying the intention of these metadata files. Additionally, if feasible, it is recommended to revise their format to better match users' typical semantic expectations for metadata files.  Update: Acknowledged, will resolve. The Brushfam team expressed that they will resolve the issue. Progress can be tracked on issue #159 in the repository's issue tracker.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#undocumented-metadata-usage", "labels": ["OpenZeppelin"]}, {"title": "TODO Comments", "body": "There are \"TODO\" comments in the codebase that should be tracked in the project's issues backlog. See for example line 41 of the PaymentSplitter trait.  During development, having well-described \"TODO\" comments will make the process of tracking and solving them easier. They should include a brief description of the pending task, and a link to the corresponding issue in the project's repository. For completeness and traceability, a signature and a timestamp can be added. Consider updating the \"TODO\" comments in the code with this information.  Update: Acknowledged, will resolve. The Brushfam team expressed that they will resolve the issue:  _ We will add a PSP22 Payment Splitter contract soon and remove the TODO._", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#todo-comments", "labels": ["OpenZeppelin"]}, {"title": "non_reentrant Flag Should Be Boolean", "body": "status variable, which is defined as a  updates it to 1. Subsequently, if the function is re-entered, the modifier checks whether the  reverts if it is 1.  To improve readability, expressiveness, and memory alignment, consider changing the variable type of the status, NOT_ENTERED, and ENTERED constants to boolean.  _Update: Resolved in pull request #143 at commit 6f94147.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#non_reentrant-flag-should-be-boolean", "labels": ["OpenZeppelin"]}, {"title": "Outdated Or Wrong Website References", "body": "On the OpenBrush hompage, the \"How to Use\" section allows users to download an example crate using either psp22, psp37, or psp34 features from the OpenBrush library. In the generated Cargo.toml file, the OpenBrush dependency is included with a \"v\" prefix in the tag name, which is not being used in the OpenBrush repository. Consider updating the tool to prevent users from encountering errors when building contracts.  Within the section on the OpenBrush website that pertains to upgradeability, broken links are present which direct to the ink! Solidity repository. Consider checking that all links on the website direct to existing and functional resources by conducting a thorough review.  Update: Resolved in pull request #66 of the openbrush-website repository at commit 873d0ad and pull request #12 of the learn-page repository at commit c27d26f.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#outdated-or-wrong-website-references", "labels": ["OpenZeppelin"]}, {"title": "Outdated Copyright", "body": "Throughout the codebase, the copyright dates currently cover the period from 2012 to 2022. They should be updated to include the current year.  Update: Partially resolved in pull request #147 at commit a0f48bc. The copyright is still outdated in the files within the lang and tests folders.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#outdated-copyright", "labels": ["OpenZeppelin"]}, {"title": "Inaccurate Directory Name", "body": "The Diamond contracts reside in the upgradeability directory, even though the diamond proxy might not be inherently upgradeable. Consider moving these contracts to a different directory with a more precise name, bearing in mind that renaming the upgradeability directory to proxy might not be entirely accurate, as one of the upgradeability approaches employs set_code_hash instead of a proxy pattern.  Update: Resolved in pull request #156 at commit fbff63e2.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#inaccurate-directory-name", "labels": ["OpenZeppelin"]}, {"title": "Typographical Error", "body": "In line 52 in the PSP34 Burnable example: \"burn_wokrs\" should be \"burn_works\".  Consider addressing this typographical error and thoroughly examining the codebase to rectify any additional ones.  Update: Resolved in pull request #151 at commit 36b4c5c.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#typographical-error", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Adoption of Underscore Prefix", "body": "In the Rust community, the underscore prefix is commonly used to signify intentionally unused variables. This prevents the compiler from issuing warnings for such variables.  While some functions in the codebase adhere to this convention, others do not. Some examples include the _attrs parameter in the generate function of the contract macro and the parameters in the generate function of the modifiers macro. Despite bearing the underscore prefix, these parameters are actively used.  For clarity, consider refactoring these examples and any other instances in the code to adhere to the established convention consistently.  Update: Resolved in pull request #152 at commit 7128b63.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#inconsistent-adoption-of-underscore-prefix", "labels": ["OpenZeppelin"]}, {"title": "Use of Non-Explicit Imports", "body": "Macros such as implementation and contract utilize the * symbol to import modules from certain crates. This approach might result in warnings for unused imports and potential ambiguities. For clarity and precision, consider importing only the necessary components explicitly and avoid using the * symbol.  Update: Acknowledged, will resolve. The Brushfam team expressed that they will resolve the issue:  _ We will think about appropriate way to resolve, especially whether it is really needed, since some imports are generated by macros and it is hard to keep track on all of them. Also, it could be hard to read the code with lots of imports._", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#use-of-non-explicit-imports", "labels": ["OpenZeppelin"]}, {"title": "Redundant Bindings in the Codebase", "body": "Throughout the codebase, there are variable bindings that seem unnecessary. Instead of creating new variables, the original variables can be used directly. For example:  The ink_module variable within the implementation macro can be directly used, eliminating the need for the additional binding input.  In contract.rs, the _attrs and ink_module parameters are moved to attrs and input, respectively.  The result variable at the end of the accessors method is an unnecessary binding. Consider using the quote! macro directly.  Consider removing any redundant bindings within the codebase to improve its overall clarity.  Update: Resolved in pull request #153 at commit f73a53e.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#redundant-bindings-in-the-codebase", "labels": ["OpenZeppelin"]}, {"title": "Misleading Error Message", "body": "In the generate function of implementation.rs, the panic in the code block that extracts the attributes to a Vec<String> says \"Expected names of OpenBrush traits to implement in the contract!\", while in reality, the only thing that is being validated is that the attribute argument is a single path or a MetaList struct instance (or more precisely, something that matches NestedMeta::Path). Consider modifying the error message to more accurately describe the cause of panic.  Update: Resolved in pull request #158 at commit 64b5647.", "html_url": "https://blog.openzeppelin.com/openbrush-contracts-library-security-review#misleading-error-message", "labels": ["OpenZeppelin"]}, {"title": "Token Bridge Reentrancy Can Corrupt Token Accounting", "body": "The TokenBridge contract gets deployed on both L1 and L2, allowing users to bridge tokens between the layers by calling the bridgeToken function. To compute the number of tokens that are being sent, the bridgeToken function first retrieves its current balance, transfers the tokens from msg.sender to itself, and then computes the difference between its new balance and the original one. This is done to handle tokens with unusual logic, such as those having a fee on transfers.  However, this function is vulnerable to reentrancy attacks through token callbacks, for example with ERC-777 tokens. This would allow an attacker to be credited with more tokens than they initially bridged. For example, in the case of an ERC-777-compliant token called \"myToken\", an attacker could:  Register an attacker-owned contract as an ERC777TokensSender to the ERC-1820 registry.  Call bridgeToken with 500 tokens. The balanceBefore is 0 and safeTransferFrom is called, triggering the ERC-777 callback to the sender.  In the ERC-777 tokensToSend callback, call bridgeToken again with 500 additional tokens. In this subcall, balanceBefore is still 0, safeTransferFrom is called successfully and balanceAfter is 500.  The main call will end with a balanceAfter of 1000.  Having sent 1000 tokens in total, the attacker would be credited with 1500 tokens on L2. Assuming other users have bridged this token to L2, the attacker could withdraw the 1500 tokens, effectively stealing 500 tokens from other users. Note that some ERC-777 tokens currently have enough liquidity to motivate such an attack, such as Skale, AMP or VRA.  Consider adding reentrancy protection to the bridgeToken function, such as OpenZeppelin's ReentrancyGuard.  Update: Resolved at commit bb3691b.  High Severity", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#token-bridge-reentrancy-can-corrupt-token-accounting", "labels": ["OpenZeppelin"]}, {"title": "Rate Limiters Can Lead to a Denial-of-Service Attack", "body": "The protocol uses rate limiters to limit its exposure in case of financial loss. These limit the amount of ETH that can be bridged from L2, as well as the amount of ETH that can be claimed on L1.  However, such protocol-wide rate limits can be used to DOS the protocol. For example, a well-funded attacker could deposit and withdraw the rate limit in ETH on each rate limit period. If this were to occur, users' ETH would be stuck on L2 as the rate limit would block withdrawals. Users would also be prevented from adding a postman fee, forcing them to be their own postman to get their transactions included on L1.  Consider removing the rate limiter or introducing more sophisticated limits. If it is kept, consider composing an action plan and incorporating monitoring for potential cases of abuse. Any change, such as more sophisticated rate limits, would have to be end-to-end tested.  Update: Acknowledged, will resolve. The Linea team stated:  This will be a future enhancement. Current withdrawal limits are placed on the bridge to minimize the impact of any potential malicious actors and will be removed at a later date.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#rate-limiters-can-lead-to-a-denial-of-service-attack", "labels": ["OpenZeppelin"]}, {"title": "Tokens Sharing an Address on L1 and L2 Can Be Set Up to Steal User Funds", "body": "is fetched and then sent via the  Beacon Proxy pointing to the  BridgedToken implementation is then deployed with  create2.  Other than custom deployments by the Linea team, this pattern is standard for every token, where one layer should host the native token and the other layer should have an associated BridgedToken deployed.  Exploiting the asynchronous nature of the bridge, it is possible to circumvent this standard pattern and have two native tokens both deployed and linked on separate layers. With this configuration, it is possible for the controller of the contracts to siphon money from the bridge.  The pattern to deploy two linked native tokens in this invalid state is as follows:  Attacker bridges the token with _recipient := address(0). On the origin chain, the nativeToBridgedToken mapping will be set to NATIVE_STATUS. The message cannot be executed on the destination chain as minting to a _recipient of zero will revert.  Attacker bridges the token deployed to the same address as the origin chain on the destination chain. Similarly, the nativeToBridgedToken mapping will be set to NATIVE_STATUS.  When users attempt bridging of this token, the bridge will treat the tokens as native, attempting to safeTransfer tokens to users on the destination chain. Since the attacker controls the entire supply on the destination layer, the bridge will not have any funds to compensate the user with.  Now the attacker is able to mint tokens on the destination layer and bridge back, extracting all of the origin tokens sitting on the token bridge.  completeBridging not being called before step 2 to avoid the token being deployed as a  Consider only updating mappings in completeBridging to ensure atomicity, as well as passing both the local and remote addresses as arguments when bridging to introduce additional checks. Such changes should be end-to-end tested, notably under scenarios where bridging transactions are asynchronous and interleaved.  Update: Resolved at commit bb3691b.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#tokens-sharing-an-address-on-l1-and-l2-can-be-set-up-to-steal-user-funds", "labels": ["OpenZeppelin"]}, {"title": "ERC-721 Tokens Can Be Locked on the Token Bridge", "body": "The TokenBridge contract allows tokens to be bridged across layers with the bridgeToken function. When a native token is bridged, the token bridge will call safeTransferFrom to move the token from the caller to itself. This safeTransferFrom function is defined in OpenZeppelin's SafeERC20Upgradeable contract.  While this definition of safeTransferFrom is intended to be used solely with ERC-20 tokens, it is possible to move ERC-721 tokens with it. Inside the function call, the low-level transferFrom function is actually used to transfer the token. The ERC-721 standard contains this function signature and uses it to transfer tokens.  If a user attempts to bridge an ERC-721 token with the token bridge, the first half of the bridging, where the tokens are collected onto the bridge, will succeed. However, the bridge uses safeTransfer when bridging native tokens out, which uses the low-level transfer function. Unfortunately, transfer is not supported by the ERC-721 standard, resulting in the ERC-721 being locked on the token bridge, with an upgrade being the only way to recover it.  Consider blocking the bridging of ERC-721 tokens, for example by removing the default decimal fallback during metadata collection. By reverting when a contract does not properly support the decimals function selector, all standard ERC-721 contracts would revert before sending any tokens to the contract.  Update: Acknowledged, will resolve. The Linea team stated:  This will be a future addition.  Medium Severity", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#erc-721-tokens-can-be-locked-on-the-token-bridge", "labels": ["OpenZeppelin"]}, {"title": "Tokens Sharing an Address Across L1 and L2 Can Prevent Users From Bridging", "body": "Users can call the bridgeToken function on the origin layer to start the bridging process. The completeBridging function can then be called on the destination layer to complete it. Bridges track tokens internally using their native address, defined as the address of the token on the chain from which it was first bridged. A token can thus only be native on either L1 or L2. If a token with the same address on L1 and L2 is encountered, a choice is made as to which token is the \"real\" native one by picking the first one that is bridged. It then becomes impossible to bridge a token with the same address in the other direction.  However, this mechanism can be exploited as a DOS attack to prevent users from bridging. This can be done as follows:  An attacker deploys a token on L2 with the same address as a token on L1 which has not been bridged yet.  The attacker calls bridgeToken on L2, followed by completeBridging on L1.  The token is now considered native to L2, and users can no longer bridge this token in the L1 to L2 direction.  A token can be deployed to the same address on L1 and L2 by using create2. At a high level, the issue above arises because of the assumption in the bridge logic that a token cannot be native on both chains. A solution would ideally result in two bridgedToken instances being deployed, one on each chain, each associated with its own native token.  Consider using a different prevention method that allows native tokens to exist on both chains at the same address. Such changes would have to be end-to-end tested.  Update: Resolved at commit bb3691b.  Low Severity", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#tokens-sharing-an-address-across-l1-and-l2-can-prevent-users-from-bridging", "labels": ["OpenZeppelin"]}, {"title": "Error-Prone and Inconsistent Definition of Gap Variables", "body": "The L2MessageService contract defines gap variables to support the future addition of state variables when upgrading.  However, while most gaps in the codebase are defined after the other storage variables, the L2MessageService contract defines this gap before. This makes it inconsistent with the rest of the codebase in addition to being error-prone for future updates. New variables cannot be added to the end of the existing storage variables without resulting in a storage collision.  Consider defining the gap variable after other storage definitions in the L2MessageService contract to be consistent with the rest of the codebase. If this is impossible, consider documenting this issue thoroughly to ensure storage variables are added to the front of the storage definitions in this file to avoid storage collisions.  Update: Resolved in pull request #9 at commit 2a3c0b0.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#error-prone-and-inconsistent-definition-of-gap-variables", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Parent Initializer in BridgedToken", "body": "calls __EIP712_init instead of calling its parent initializer  Update: Resolved at commit bb3691b.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#incorrect-parent-initializer-in-bridgedtoken", "labels": ["OpenZeppelin"]}, {"title": "Pragma Compiler Version Default Can Generate Incompatible Opcodes", "body": "Valid compiler versions for the codebase are set via the pragma solidity tag at the top of Solidity files. The codebase uses pragma solidity ^0.8.19, requiring the compiler version to be at least 0.8.19 and lower than 0.9.0.  However, Linea currently only supports EVM versions up to London. This notably means that Linea does not support the push0 opcode which was introduced in Shanghai. Additionally, Shanghai is the default EVM version starting from Solidity compiler version 0.8.20. This means that contracts compiled with 0.8.20 by default might not be supported on Linea.  Consider fixing the pragma version to 0.8.19 in the codebase to limit the likelihood of this occurring, as well as documenting the supported EVM versions.  Update: Resolved in pull request #6 and commit bb3691b.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#pragma-compiler-version-default-can-generate-incompatible-opcodes", "labels": ["OpenZeppelin"]}, {"title": "Pointer Arithmetic Error in RLP Library", "body": "During finalization, L1 to L2 transactions that have been transmitted to L2 by the coordinator are marked as received back on L1. To do so, the transactions relaying the message hashes to the L2 message service are RLP-decoded to extract the hashes marked as received during finalization.  However, the RLP library used for decoding includes a pointer arithmetic error when computing the bounds of the RLP-encoded transactions. When decoding long lists, the endPtr is computed as _self.item.memPtr + 1 + lenX while it should be computed as _self.item.memPtr + 1 + byteLen + lenX.  Given the current usage of the library, this arithmetic error will not result in adverse effects. This is because byteLen will never exceed 5 bytes in practice, while the abi encoding of the hashes will always be over 64 bytes in length. Still, for correctness and to avoid potential future issues, consider fixing the end pointer calculation.  Update: Acknowledged, will resolve. The Linea team stated:  Will resolve, using extensive sample testing for generic use.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#pointer-arithmetic-error-in-rlp-library", "labels": ["OpenZeppelin"]}, {"title": "Validators Can Steal Refunds of EOA Users When Claiming Messages", "body": "When a message with empty calldata and an EOA as a recipient is claimed on L1, part of the fees is reimbursed to the destination address. This refund is computed as _feeInWei - deliveryFee where deliveryFee = min(_feeInWei, (startingGas + REFUND_OVERHEAD_IN_GAS - gasleft()) * tx.gasprice).  However, this way of computing the refund is vulnerable to validators claiming messages and inflating tx.gasprice by setting a high transaction tip. A validator could inflate the tip to where the deliveryFee is equal to the maximum fee set on the message. A user setting a high fee to ensure their transaction is picked up by a postman would effectively get their refund stolen.  Consider documenting this behavior. Generally, users should not be encouraged to rely on the refund mechanism as it is susceptible to leaks from MEV.  Update: Acknowledged, not resolved. The Linea team stated:  This will be a potential future enhancement. Documentation will be updated as per the recommendation.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#validators-can-steal-refunds-of-eoa-users-when-claiming-messages", "labels": ["OpenZeppelin"]}, {"title": "Functions Lack Pausability", "body": "The TokenBridge contract can be paused to prevent some functions from being called for a period of time. This functionality is intended as a contingency plan to prevent loss of funds in case something unexpected happens.  However, several functions can still be called while the contract is paused, notably the completeBridging and confirmDeployment functions.  Consider making these functions pausable.  Update: Partially resolved at commit bb3691b. The completeBridging function is now pausable. The Linea team stated:  confirmDeployment is a Linea function with no impact on funds.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#functions-lack-pausability", "labels": ["OpenZeppelin"]}, {"title": "Funds Can Be Locked in the Bridge", "body": "In order to bridge funds, users can call the bridgeToken function on the origin chain. Later, on the destination chain, the completeBridging function can be called to transfer the bridged tokens to the _recipient. It is possible to have funds effectively stuck on one side of the bridge if completeBridging is unable to successfully execute.  mint and  burn tokens directly from a user's account instead of using  proper permissions to  mint and  burn from the  zero address is specifically protected in the mint function, resulting in a revert when attempting to  Even though sending funds to the zero address should only be done when attempting to lock up tokens, in this scenario funds would be locked on the TokenBridge and not on the zero address itself.  Consider reverting in the bridgeToken function when the _recipient is specified to be the zero address.  Update: Resolved at commit bb3691b.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#funds-can-be-locked-in-the-bridge", "labels": ["OpenZeppelin"]}, {"title": "Denial-of-Service Protection Not Initialized", "body": "The L2MessageService contract defines a state variable called minimumFeeInWei as a minimum fee to pay to transfer L2-to-L1 messages. Such a fee is intended as a way to \"address DOS protection\".  However, this fee is not set in the initializer, meaning that its value is initially 0 until setMinimumFee is called.  If minimumFeeInWei is required to address a DOS risk that could be present from the launch of the protocol, consider initializing it in the initializer.  Update: Acknowledged, will resolve. The Linea team stated:  This will be a future enhancement for testnet deployments. Mainnet has the fee set, so it includes Denial-of-Service protection.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#denial-of-service-protection-not-initialized", "labels": ["OpenZeppelin"]}, {"title": "Bridge Tokens Default to 18 Decimals", "body": "BridgedToken can be deployed on the destination layer. To collect this metadata,  static calls are made to the  Hermez's bridge, default values are assumed in case the metadata could not be fetched/decoded.  However, assuming default values for decimals may surprise users. For instance, in the case of a token with 0 decimals being defaulted to 18 on L2, a user bridging 100 tokens may not expect to receive only 100 * 10^-18 tokens on the target chain.  While it is possible to deploy a contract with the same metadata as the original on the destination chain and ask the Linea team to call the setCustomContract function to link the two contracts through the bridge, this option becomes unavailable once the token has been initially bridged.  Consider removing default values for metadata and reverting on unsupported tokens. These tokens would then have to be bridged following the second method underlined above. Whether or not this suggestion is implemented, any potential consequences for users should be properly documented.  Update: Acknowledged, not resolved. The Linea team stated:  This will be a potential future enhancement. Documentation will be updated as per the recommendation.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#bridge-tokens-default-to-18-decimals", "labels": ["OpenZeppelin"]}, {"title": "Bridging Completion May Be Blocked by Reserve Status", "body": "After initiating a bridging transaction of a token for the first time, a postman can call completeBridging on the destination bridge. Once they do, a new instance of BridgedToken is deployed behind a beacon proxy.  mint call to address(0x111) (  This situation could happen if an administrator mistakenly calls setReserved for a token on a chain it is not native on.  To limit the likelihood of such a scenario happening, consider adding an additional warning in the NatSpec of the setReserved function that _token should be a native token on the chain.  Update: Resolved in pull request #8 at commit 952bf56.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#bridging-completion-may-be-blocked-by-reserve-status", "labels": ["OpenZeppelin"]}, {"title": "Custom Error Redefinition", "body": "The abstract contract MessageServiceBase defines the ZeroAddressNotAllowed error, which is also defined in the IGenericError interface.  Consider reusing IGenericError in MessageServiceBase to avoid defining it twice.  Update: Resolved in pull request #13 at commit d6c4399.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#custom-error-redefinition", "labels": ["OpenZeppelin"]}, {"title": "Custom Errors Recommendations", "body": "Some unused errors and potential improvements were detected:  Some errors ([1] [2] [3] [4] [5]) are defined but never used. Consider removing them.  In the IL1MessageManager interface, the MessageDoesNotExistOrHasAlreadyBeenClaimed error could return the messageHash as an argument to be consistent with the other errors and make debugging easier for users.  In the ZkEvmV2 contract, the BlockTimestampError error could include the blockInfo.l2BlockTimestamp and block.timestamp.  In the TransactionDecoder library, the UnknownTransactionType error could include the version byte.  Consider updating these errors to improve the clarity of the codebase.  Update: Resolved in pull request #13.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#custom-errors-recommendations", "labels": ["OpenZeppelin"]}, {"title": "Hardcoded Values Are Error-Prone", "body": "When a new message is claimed, L1/2MessageService exposes a _messageSender state variable that can be queried to get the cross-domain address. _messageSender's default value is hard-coded to address(123456789).  Consider using a constant instead of a hard-coded value to be clearer and less error-prone. For the same reasons, consider setting the constant permit function selector to IERC20PermitUpgradeable.permit.selector instead of computing the keccak256 hash of a string.  Update: Resolved in pull request #14 at commit 985ee5f.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#hardcoded-values-are-error-prone", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Licenses", "body": "Some files have an Apache-2.0 license while others have an AGPL-3.0 license.  Consider standardizing the license across the codebase.  Update: Acknowledged, not resolved. The Linea team stated:  Licenses are decided on a per-contract level and were purposely set.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#inconsistent-licenses", "labels": ["OpenZeppelin"]}, {"title": "Multi-Line Comments Do Not Consistently Follow NatSpec Format", "body": "Some multi-line NatSpec comments end with a **/ instead of the recommended */.  Similarly, there is an instance of a multi-line comment starting with /* rather than the recommended /**.  Consider fixing these instances to be consistent in case external services depend on a strict NatSpec format.  Update: Resolved in pull request #9 at commit 4f6e4ea.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#multi-line-comments-do-not-consistently-follow-natspec-format", "labels": ["OpenZeppelin"]}, {"title": "Incorrect or Misleading Documentation", "body": "Throughout the codebase, a few instances of incorrect or misleading documentation were identified:  In the IMessageService interface, a comment has been duplicated for two different events.  In the IL1MessageManager interface, the NatSpec for the MessageDoesNotExistOrHasAlreadyBeenClaimed error could mention the possibility that the message does not exist.  In the L1MessageManager contract, there is a comment indicating that \"There is a uint216 worth of storage layout here\". However, this comment is incorrect as the variables above are constant and do not occupy storage space. Consider removing it. This also occurs in the L2MessageManager.  In the TokenBridge contract, the default returned value for token names is \"UNKNOWN\" and not \"NOT_VALID_ENCODING\".  In the IRateLimiter interface, the NatSpec around the resetRateLimitAmount function describes the _amount parameter as being \"New message hashes\". Consider editing this comment to better describe that it sets the maximum amount of ETH that can be withdrawn over a period.  In the TokenBridge, the NatSpec for the _safeName function incorrectly documents two arguments when there should only be one.  In the IZkEvmV2 interface, the NatSpec for the finalizeBlocks should be replaced by this one.  Clean and accurate documentation helps users and developers understand the codebase. Consider updating the identified instances of incorrect or misleading documentation.  Update: Resolved in pull request #12 and commit bb3691b.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#incorrect-or-misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Lack of Indexed Event Parameters", "body": "Throughout the codebase, several events do not have their parameters indexed. For instance:  In the IPauseManager interface, the Paused and UnPaused events could have the pauseType parameter indexed.  In the ITokenBridge interface, most events could have their parameters indexed.  Consider indexing event parameters to improve the ability of off-chain services to search and filter for specific events.  Update: Resolved in pull request #15 at commits c921621 and bb3691b.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Missing Event Parameter", "body": "We have identified a few instances of events which would benefit from additional event parameters:  The NewTokenDeployed event is emitted to signal that a new bridged token has been deployed by the TokenBridge. Consider adding the address of the native token to the emitted parameters of the event.  The VerifierAddressChanged event only emits the address of the new verifier and could benefit from also emitting the old address.  The BlockFinalized event could emit a flag indicating whether the block was finalized using a proof.  Consider adding the suggested parameters to their respective events to improve the clarity and transparency of the records.  Update: Partially resolved in pull request #15. The BlockFinalized event remains unchanged.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#missing-event-parameter", "labels": ["OpenZeppelin"]}, {"title": "Only One Permit Standard Supported", "body": "The TokenBridge supports permit-style approvals via the _permit function, invoked when calling the external bridgeTokenWithPermit function. This function supports ERC-2612, a permit standard now widely used among ERC-20 and ERC-712 tokens.  However, there are permit standards other than ERC-2612. Most notably, Dai from MakerDAO uses a different signature for their permit function.  In order to support permit functionality on more tokens, consider adding other permit methods to the permit function of the TokenBridge.  Update: Acknowledged, will resolve. The Linea team stated:  This will be a future addition.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#only-one-permit-standard-supported", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "We identified the following typographical errors in the codebase:  \"checked,\" [1] [2] should be \"checked.\"  \"store\" should be \"stored\".  \"claim\" should be \"claims\".  \"reserved\" [1] [2] [3] [4] should be \"reserve\".  \"are\" [1] [2] should be \"have\".  \"subject to a by a time lock\" should be \"subject to a delay by a time lock\".  \"updated\" should be \"updates\".  \"achoring\" should be \"anchoring\".  \"EIP29230\" should be \"EIP2930\".  \"neccesary\" should be \"necessary\".  To improve the overall consistency and readability of the codebase, consider updating the identified errors and applying an automated spelling/grammar checker to the codebase to identify further instances.  Update: Partially resolved in pull request #9.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "L2 Timestamp Not Initialized in ZkEvm Contract", "body": "The ZkEvmV2 contract exposes a currentTimestamp state variable which is used to store the last L2 block timestamp.  However, this variable is not initialized alongside the currentL2BlockNumber and stateRootHashes variables. This means that on initialization, the block number might not match the timestamp as the timestamp is set to 0. In the case of a migration, this could break the assumption that the rollup timestamps are strictly increasing.  Consider adding an argument to the initialize function to initialize the currentTimestamp variable.  Update: Acknowledged, will resolve. The Linea team stated:  This will be a future enhancement for testnet deployments. Mainnet has the timestamp set.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#l2-timestamp-not-initialized-in-zkevm-contract", "labels": ["OpenZeppelin"]}, {"title": "Unused Import", "body": "In L2MessageService.sol, the import of CodecV2 is unused and could be removed.  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #9.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#unused-import", "labels": ["OpenZeppelin"]}, {"title": "Codec Function Is Not Memory Safe", "body": "The _extractXDomainAddHashes function is used to extract the message hashes from the calldata of transactions calling addL1L2MessageHashes on L2.  However, this function modifies its input bytes array _calldataWithSelector argument in-place by changing its length and making it invalid. This is not an issue with the way the code is currently used as the function is called on a local memory copy which is not used for anything else.  Consider documenting the fact that the input of this function is modified and should not be reused.  Update: Resolved in pull request #9 at commit 2c71574.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#codec-function-is-not-memory-safe", "labels": ["OpenZeppelin"]}, {"title": "Lack of Documentation in bridgeTokenWithPermit Function", "body": "The TokenBridge contract exposes a bridgeTokenWithPermit function to allow users to approve and bridge in a single transaction. This function calls an internal _permit function which calls the ERC-2612 permit function on the token address.  However, the _permit function passing does not mean that the allowance has been updated or that the user has been authenticated. For example, calling _permit with the address of WETH on layer 1 would pass without being supported because of its silent fallback method.  While there is currently no issue with the way the function is being used, consider documenting a warning not to rely on this function for authentication.  Update: Resolved in pull request #8.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#lack-of-documentation-in-bridgetokenwithpermit-function", "labels": ["OpenZeppelin"]}, {"title": "Variable Naming", "body": "The array hashOfRootHashes in the ZkEvmV2 contract could be renamed to blockRootHashes, as it does not contain the hash of root hashes, but the individual root hashes.  Consider renaming the variable to improve the clarity of the codebase.  Update: Resolved in pull request #9 at commit ac6185e.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#variable-naming", "labels": ["OpenZeppelin"]}, {"title": "Gas Optimizations", "body": "In the TokenBridge contract, the nativeToken variable is set on each loop but remains unused.  There are multiple instances of array lengths being evaluated on each loop ([1] [2] [3] [4] [5] [6] [7]). These could be written to memory to save gas.  In the RLPReader library, the constant LIST_SHORT_START_MAX is unused and could be removed.  Consider updating these to save gas during the operation/deployment of the protocol.  Update: Acknowledged, not resolved. The Linea team stated:  There will be very few items on TokenBridge and the gas savings are negligible or null. In the zkEvmV2 contract, the high volume of data, in practice, is more costly due to exponential memory costs.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Lack of Security Contact", "body": "Providing a specific security contact (such as an email or ENS) within a smart contract significantly simplifies the process for individuals to communicate should a vulnerability be identified in the code. Additionally, if the contract incorporates third-party libraries and a bug surfaces in these, it becomes easier for the creators of those libraries to make contact, inform the code owners about the problem, and provide mitigation instructions.  Consider adding a NatSpec comment on top of contract definitions with a security contact. Using the @custom:security-contact tag is recommended as it has been adopted by the Openzeppelin Wizard and the ethereum-lists.  Update: Resolved in pull request #11 at commit 001bf37.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#lack-of-security-contact", "labels": ["OpenZeppelin"]}, {"title": "BlockData Struct Lacks Documentation", "body": "The BlockData struct is an important part of the proving system but is not documented. Consider adding documentation describing the meaning of its different components to improve the clarity of the codebase.  Update: Resolved in pull request #10.", "html_url": "https://blog.openzeppelin.com/linea-bridge-audit-1#blockdata-struct-lacks-documentation", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Randomness Computation Allows Proof Forgery", "body": "The PlonkVerifier contract is called by the rollup to verify the validity proofs associated with blocks of transactions. The Verify function can be called with the proof and the public inputs, and outputs a boolean indicating that the proof is valid for the received public inputs. To do so, the verifier notably samples a random value u and does a batch evaluation to verify that all the openings match their respective commitments.  The malicious prover P extracts A = [W\u03b6]1 + u*[W\u03b6\u03c9]1 and B = z*[W\u03b6]1 + u\u03b6\u03c9*[W\u03b6\u03c9]1 + [F]1 - [E]1 obtained when any valid proof is submitted. A and B are by construction points on the elliptic curve for which e(-A, [x]2) * e(B, [1]2) == 1.  P sets the public input (or any proof commitment) to an arbitrary value. Any value beside t(\u03b6), [W\u03b6]1 and [W\u03b6\u03c9]1 can be changed.  P computes T = [ r(\u03b6) + PI(\u03b6) \u2212 ((a(\u03b6) + \u03b2s\u03c31(\u03b6) + \u03b3)(b(\u03b6) + \u03b2s\u03c32(\u03b6) + \u03b3)(c(\u03b6) + \u03b3)z\u03c9(\u03b6))\u03b1 \u2212 L1(\u03b6)\u03b1^2 ] / ZH(\u03b6) following step 8 of the PLONK verifier algorithm. The prover sets t(\u03b6) = T in the forged proof. This step is required to pass this check in the code.  P computes u, \u03b6 and \u03c9 as done by the code.  P solves the equations X + u*Y = A and \u03b6*X + \u03b6\u03c9u*Y = C + B obtained by denoting X = [W\u03b6]1 and Y = [W\u03b6\u03c9]1 taken from step 12 of the verifier algorithm. This system has for solutions [W\u03b6]1 = X = (-u)*Y + A and [W\u03b6\u03c9]1 = Y = 1/(\u03b6u(\u03c9 - 1)) * (C + B -\u03b6A).  P submits the proof to the verifier, replacing t(\u03b6) by T, and [W\u03b6]1, [W\u03b6\u03c9]1 by the values computed in step 5.  The verifier computes e(-A, [x]2) * e(B, [1]2) == 1 and accepts the proof.  The core of the attack is the ability of the prover to change [W\u03b6]1 and [W\u03b6\u03c9]1 after u has been sampled. This attack allows the prover to arbitrarily change the public inputs or any polynomial commitments and still submit a valid proof. In the case of Linea, this could be used by the prover to modify the state root and steal all the assets on the rollup.  Consider computing u as the hash of the transcript following the PLONK paper.  Update: Resolved in pull request #30.  Medium Severity", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#incorrect-randomness-computation-allows-proof-forgery", "labels": ["OpenZeppelin"]}, {"title": "Missing Commitment in Challenge Computation", "body": "When following the non-interactive version of PLONK using Fiat-Shamir, the challenges are assumed to be derived from the transcript, defined as \"the concatenation of the common preprocessed input, and public input, and the proof elements written by the prover up to a certain point in time\". In the code, the following parameters are used to compute the \u03b3 and \u03b2 challenges:  The public inputs  The commitments to the wire polynomials ([a]1, [b]1, [c]1, [Pi]1)  The commitments to the selector polynomials ([S\u03c31]1, [S\u03c32]1, [S\u03c33]1, [Ql]1, [Qr]1, [Qm]1, [Qo]1, [Qk]1)  included in the derivation of the  Since they are hardcoded anyway, they cannot be used as a free parameter in frozen-heart-style attacks. Nevertheless, this means the system is out of compliance with the security analysis, which undermines the security guarantees.  Consider including all relevant parameters when deriving these challenges. In particular, consider adding the [Qci]1 commitments, the group parameters (generators, at least [1]1, [x]1 and [1]2, modulus and domain size), as well as the number of public inputs and the circuit size. Similarly, the Fiat-Shamir done inside of the circuit should also include all relevant parameters.  Update: Resolved in pull request #25. The Linea team stated:  The modifications are that now gamma depends on the Qcp (instead of the commitments to the wires associated with it). Beta is unchanged, and alpha depends on the commitments to the wires associated with the custom gate (it is at this point that the verifier should have sent alpha if the protocol were interactive).", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#missing-commitment-in-challenge-computation", "labels": ["OpenZeppelin"]}, {"title": "Deviations From So-Far-Digest Model", "body": "We are aware of only two provably secure transformations of a constant round argument of knowledge from its interactive to its non-interactive version. Those transformations are, in the terms used in this article, the so-far-transcript (i.e., the Fiat-Shamir transformation in its classical form) and the so-far-digest transformations.  The PLONK specification chooses pseudorandom challenges using the so-far-transcript method, where each challenge is generated from the content of the entire transcript so far. The Linea verifier uses the newly introduced so-far-digest method, where each challenge is generated only from the previous challenge and subsequent messages. However, there are several deviations:  compute_gamma_kzg, corresponding to v in the PLONK specification, should strictly follow the so-far-digest transformation. In particular, it should depend on \u03b6 and all the PLONK prover messages that are output in round 4 (i.e., the respective opening evaluations). Currently, it has several redundant dependencies but does not depend on z(\u03b6\u03c9).  The random variable used in the KZG opening, corresponding to u in the PLONK specification, should also be computed as any challenge defined by the so-far-digest model. In particular, it should depend on challenge v (not \u03b1) and on the two KZG commitments that are output by the PLONK prover in round 5. Moreover, the use of keccak256 for computing this challenge should be substituted by the same hash-to-field function as in the rest of the so-far-digest model.  Note that the definition of a challenge in the so-far-transcript and so-far-digest models is that of randomness computed by a non-interactive prover/verifier in lieu of the public coin randomness computed by an interactive verifier, so u in the PLONK specification is also a challenge.  \u03b6 depends on the non-reduced version of \u03b1, but in accordance with the so-far-digest transformation we recommend making the dependency directly on \u03b1. The same holds for almost all other challenges.  In summary, in order to fall under the security guarantees of one of the two existing interactive to non-interactive secure transformations for argument systems, once started, it is strongly recommended to strictly follow the so-far-digest transformation without interleaving it with any other possible transformation. Avoiding compliance may lead to transformations without currently explored security proofs and may put the codebase at risk of attacks on the system's soundness.  Finally, note that we are in contact with the authors of this paper with comments and feedback regarding the security proof of the so-far-digest transformation.  Update: Partially resolved in pull request #30, except for \u03b6 which still depends on the non-reduced version of \u03b1. The issue regarding the computation of random in the second point was spun off as a separate issue during the fix review as the vulnerability was found to be more serious than initially thought.", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#deviations-from-so-far-digest-model", "labels": ["OpenZeppelin"]}, {"title": "Missing Validations", "body": "The Verify function performs sanity checks on the inputs, but there are still some validations missing. In particular, it does not confirm the number of public inputs, or whether the commitments correspond to valid elliptic curve points.  In the interest of reducing the attack surface, consider including these validations. Note that checking that the commitments are valid elliptic curve points is a requirement of the PLONK specification in order to inherit the security proof.  Update: Partially resolved in pull request #26. A check to explicitly restrict the number of public inputs was added. Regarding the elliptic curve checks, the Linea team stated:  It is implicitly tested when the EC precompiles are called - if a point is not on the curve, the precompile will revert. This avoids doing checks each time we verify a proof (there are a lot of points to verify), and the proofs that are received are likely to be correctly formatted so we believe the trade-off is better as it is now.  Low Severity", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#missing-validations", "labels": ["OpenZeppelin"]}, {"title": "Incomplete Specialization of Custom Gate Support", "body": "The codebase is designed to support an arbitrary number of selector gates that are nevertheless fixed at compile time.  However, the sum_pi_commit function is specialized for the current configuration of one selector gate, which is inconsistent with the rest of the codebase. Moreover, the specialization is incomplete. In particular:  It only hashes the first commitment and ignores any subsequent commitments.  It unnecessarily adds the result to an unspecified value.  It unnecessarily increases a pointer that is never reused.  It is still named sum even though it does not return a summation.  Similarly, the compute_gamma_kzg function assumes there is only one custom gate, but then allows for multiple corresponding openings.  Consider generalizing the functions to support multiple selector gates. Alternatively, consider explicitly enforcing the single gate requirement and simplifying the functions accordingly.  Update: Resolved in pull request #27.", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#incomplete-specialization-of-custom-gate-support", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Error Handling", "body": "The pow, compute_gamma_kzg and batch_verify_multi_points functions all use the eq instruction to check the error flag. To be consistent with the rest of the codebase, consider using the iszero instruction instead.  In addition, the final KZG check combines protocol logic and error handling. In particular, it validates the previously saved (quotient polynomial evaluation) status, the success of the precompile call, and the result of the pairing. To be consistent with the rest of the codebase, consider checking the precompile success flag independently and immediately after the call is made.  Update: Partially resolved in pull request #17. The check_pairing_kzg function still checks the precompile call success flag in the returned boolean instead of raising an error.", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#inconsistent-error-handling", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Memory Management", "body": "The codebase adopts a convention where the memory at the free memory pointer is reserved for a shared state, and the subsequent block of memory is considered free. When a function wants to reserve additional memory, it explicitly passes a new free memory pointer (e.g., here) to the called function.  However, this violates Solidity's memory model, where reserved memory is \"allocated\" by updating the free memory pointer. Moreover, the fold_state function directly uses a buffer that was constructed in the compute_gamma_kzg function, even though it appears to be in \"free\" memory under both conventions.  To improve readability and limit potential inconsistencies, consider allocating memory whenever it is reserved. Additionally, consider explicitly documenting that the code is not memory-safe.  Update: Resolved in pull request #20.", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#inconsistent-memory-management", "labels": ["OpenZeppelin"]}, {"title": "Misleading Documentation", "body": "There are several instances where the codebase's documentation could be improved:  This comment references the Lagrange polynomial at index 1 instead of index 0.  The explanation for the \"beta\" and \"alpha\" string offsets incorrectly references \"gamma\". Note that the \"beta\" comment also has the wrong offset.  The polynomial openings are described as \"wire values at zeta\". It would be more accurate to describe them as \"evaluations of wire polynomials at zeta\".  The b0 and b0 ^ b1 comments incorrectly describe them as occupying 64 bytes.  The comment describing the fold_h function uses m instead of n as the group size.  The verify_quotient_poly_eval_at_zeta function contains a commented-out instruction that does not match the rest of the code.  This comment uses \"mPtr[32:]\" instead of \"mPtr[:32]\".  This comment is unclear and incorrectly suggests that \"b2\" is 16 bytes.  Some comments could use additional context. For example, this comment could indicate which step in the paper it corresponds to (step 8) and what it is computing (the t(z) expression).  Consider updating these comments to improve the clarity of the codebase.  Update: Resolved in pull request #16.", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "The code under review contains several functions with minimal or missing docstrings, which limits readability. This is compounded by the fact that many functions intermingle protocol logic with low-level memory manipulation in assembly.  Consider thoroughly documenting all functions (and their parameters). When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #18.", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Implementation Deviates From Paper", "body": "Some operations are done differently in the code compared to what is described in the paper:  The permutation polynomial is defined using the Lagrange polynomial at index 0, which means the interpolation starts at the previous position when compared to the specification.  Some signs have been inverted, for example when evaluating the quotient polynomial.  Some computations are done differently, such as when computing the partial opening commitment [D]1, where the multiplication by v and the addition of u[z]1 are done later.  The components of the quotient polynomial are scaled by \u03b6^{n+2} instead of \u03b6^{n}.  Consider closely following the paper's implementation to reduce the likelihood of mistakes and improve the clarity of the codebase. When this is not feasible, consider clearly documenting the differences between the paper and the codebase.  Update: Acknowledged, not resolved. The first point was found to stem from the code implementing an older version of PLONK than the audit team was looking at, which in itself is not a security concern. The Linea team expressed that the other points were not resolved as, while the code differs from the specifications, it is consistent.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#implementation-deviates-from-paper", "labels": ["OpenZeppelin"]}, {"title": "Complicated Bit Manipulations", "body": "The penultimate step of the hash_fr function is to retrieve the most significant 16 bytes of the 32-byte word b2. This is achieved by zeroing out the previous 16 bytes one at a time, and then reading 32 bytes across the natural word boundary. Instead, the same effect can be achieved directly through right-shifting b2 by 128-bit positions. Consider implementing this simplification.  Update: Resolved in pull request #29.", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#complicated-bit-manipulations", "labels": ["OpenZeppelin"]}, {"title": "Constants Not Using UPPER_CASE Format", "body": "Throughout the codebase, constants are not using the UPPER_CASE format. Consider following this convention as recommended by the Solidity Style Guide.  Update: Resolved in pull request #24.", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#constants-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "Magic Numbers", "body": "The batch_verify_multi_points function hardcodes the group 1 generator with no explanation. To improve readability, consider introducing named constants to describe this value.  Similarly, consider replacing the hardcoded proof size offset with the positional constant that it represents.  Lastly, the size of the ecPairing buffer is assumed to be 0x180, which is not apparent through contextual analysis, because the buffer is constructed in the calling function. Consider passing the length to the check_pairing_kzg function.  Update: Partially resolved in pull request #23. Constants for the group 1 generator were introduced, but the proof size offset and the size of the elliptic curve pairing buffer are still hardcoded.", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#magic-numbers", "labels": ["OpenZeppelin"]}, {"title": "Naming Suggestions", "body": "The following variables and constants could benefit from more descriptive names:  The n parameter of the batch_compute_lagranges_at_z function is the number of public inputs, which conflicts with the domain size.  The h commitments should include com or commitment in their name to be consistent with the other constants.  There are several variables that could remove the \"api\" decorator, which is a reference to how they were constructed rather than what they represent.  Consider renaming these values accordingly.  Update: Resolved in pull request #22.", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#naming-suggestions", "labels": ["OpenZeppelin"]}, {"title": "Outdated Specification", "body": "The verifier implements an outdated version of the PLONK specification. If possible, consider implementing the latest version, which requires a smaller proof.  Update: Acknowledged, not resolved. The Linea team stated:  There is a release of Linea coming soon, we will potentially update our PLONK prover and verifier afterwards.", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#outdated-specification", "labels": ["OpenZeppelin"]}, {"title": "Potentially Unnecessary Computation", "body": "There are multiple places where the verifier continues processing once the outcome is known:  Several functions are called after the verify_quotient_poly_eval_at_zeta function saves its result, regardless of the outcome, even though a failure will always eventually revert.  The check_inputs_size and check_proof_openings_size functions construct a combined error flag for each input, even though any failure ultimately results in a revert.  In the interest of code simplicity and limiting unnecessary computation, consider reverting as soon as a failure is detected.  Update: Partially resolved in pull request #28. An early revert was added when validating the inputs and opening. The Linea team stated:  For verify_quotient_poly_eval_at_zeta, we left the old version so that the verifier executes fully and returns either true or false according to the success.", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#potentially-unnecessary-computation", "labels": ["OpenZeppelin"]}, {"title": "Reuse Cached Value", "body": "Several functions in the fold_state function recompute the pointer to free memory, such as here. Consider reusing the mPtrOffset variable.  Update: Resolved in pull request #20.", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#reuse-cached-value", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "The following typographical errors were identified in the codebase:  \"comming\" should be \"coming\".  \"32byes\" should be \"32 bytes\".  \"in\" should be \"is\".  \"too\" should be \"to\".  Consider resolving these typographical errors, as well as running an automated spelling/grammar checker on the codebase and correcting any identified errors.  Update: Resolved in pull request #21.", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Recommendations", "body": "Supplementary Materials  We recommend reading the following supplementary materials related to some theoretical  security considerations in PLONK.  SRS and Transcript in Practice  As part of the Fiat-Shamir (FS) transformation from the interactive to the non-interactive version  of a protocol, the full transcript should include all public parameters. In a S(N)ARK, the set of  public parameters includes the structured reference string (i.e., the SRS).  In the following, we explain why it is necessary and sufficient to include just a small part of the  SRS in the full transcript for the FS transformation.  Let O(n) be the size of the SNARK witness.  On the one hand, it is not feasible to include the full SRS as part of the full transcript to be later  hashed as this would constitute a computational cost of up to O(n) for both the non-interactive  prover as well as the non-interactive verifier. Indeed, O(n) largely outweighs the upper bound of  O(log n) as the desired computational cost for a non-interactive SNARK verifier.  On the other hand, one certainly needs to add at least some SRS points as part of the full  transcript. We recommend adding [1]1, [x]1 and [1]2. Given these three elements, there exists a  deterministic procedure that verifies the well-formedness of any other SRS element due to the  bilinearity of the pairing. Moreover, this verification is valid only if the SRS elements match [1]1, [x]1  and [1]2. For short, the SRS elements are uniquely determined by fixing only 3 elements: [1]1, [x]1 and [1]2. The mathematical motivation is included below.  Step 1: Given [1]  Step 2 and onwards: given [1]  Pairing-Based Cryptography), this holds if and only if y= [x]  Observation 2: Analogously to Observation 1, one can use the non-degeneracy of the pairing  to motivate the reasoning in Step 2 and onwards.  Batching KZG Proofs for Two Evaluation Points  These sections address the missing security proof on page 13 of the PLONK paper, and how to  implement the required randomness in practice.  Section 1: Security Proof  Lemma 1: Let a, a', b, b' \u2208 F be some given, fixed scalars, where F\u2282 O(2\u03bb) is a finite field and  \u03bb is the security parameter. Let r' \u2208 F be a scalar chosen uniformly at random in F and, thus,  independently chosen from a, a', b, b'.  Then, it holds that a = a' and b= b' if and only if, up to a negligible probability in \u03bb, a+ r'\u00b7b = a'+  r'\u00b7b'.  Proof:  \u2022\"<=\": For the implication from right to left, assume a+ r'\u00b7b = a'+ r'\u00b7b' holds. Then,equivalently, (a - a')+ r'\u00b7(b' - b) = 0. For a, a', b, b' \u2208 F fixed and r' chosen uniformly atrandom in F, by applying the Schwartz-Zippel Lemma, this implies, with overwhelmingprobability in \u03bb that a = a' and b = b'. This concludes the proof.  \"=>\": The implication from left to right holds trivially and with a probability of 1.  \"<=\": For the implication from right to left, assume a+ r'\u00b7b = a'+ r'\u00b7b' holds. Then,  equivalently, (a - a')+ r'\u00b7(b' - b) = 0. For a, a', b, b' \u2208 F fixed and r' chosen uniformly at  random in F, by applying the Schwartz-Zippel Lemma, this implies, with overwhelming  probability in \u03bb that a = a' and b = b'. This concludes the proof.  Instantiation 1: Next, we apply Lemma 1 for the special case of the scheme describing  batching KZG proofs for two evaluation points (page 13 in PLONK). In order to do that, we  instantiate:  a = e(F + zW, [1]1), where F = \u2211i=1t1 \u03b3i-1\u00b7cmi - [ \u2211i=1t1 \u03b3i-1\u00b7si]1 and using the PLONK paper (pages 11-13) notation for \u03b3, cmi, si, t1.  b = e(W, [x]2).  a' = e(F' + z'W', [1]1), where F' = \u2211i=1t2 \u03b3'i-1\u00b7 cmi' - [ \u2211i=1t2 \u03b3'i-1\u00b7 s'i]1.  b' = e(W', [x]2).  Hence, we can conclude that given the security proof for the KZG scheme for one evaluation  point (i.e., the KZG scheme described in Section 3.1, pages 11-12 of PLONK), and using  Instantiation 1, the security of the KZG scheme described on page 13 of PLONK holds.  Note that in order to conclude the above security proof, we made explicit use of the Schwartz-  Zippel Lemma used in the proof of Lemma 1. If not all pre-conditions are met, such as if either the degree of the polynomial considered is not negligible over the size of the field F, or if any of  the coefficients of the polynomial for which we apply the Schwartz-Zippel Lemma are chosen  after r' is chosen, then the security proof may no longer hold.  Section 2: Concrete Implementation Details  To protect itself from a malicious KZG prover, a KZG verifier has two options.  In an ideal world, the verifier would choose r' uniformly at random from F. However, thatis not efficient to implement in practice.  In practice and in support of an efficient implementation, the KZG verifier simply needsto compute the value r' as the hash of the entire transcript and all the public values usedin the KZG scheme up to that point. This is equivalent to the Fiat-Shamir transformationfor a multi-round protocol, with the last round in this case being the computation by theverifier of some publicly used randomness and the final", "html_url": "https://blog.openzeppelin.com/linea-verifier-audit-1#recommendations", "labels": ["OpenZeppelin"]}, {"title": "Unrestricted Minting of esEXA Tokens", "body": "EscrowedEXA contract does not verify the origin or the asset of the Sablier stream expected to be canceled. Cancellation can happen through  cancel function or directly through the Sablier protocol. Depending on what was set as  onStreamCanceled hook will be called by Sablier's smart contracts. This leads to a scenario where an attacker can create a vesting stream directly through the Sablier protocol and then force its processing via the  There are two exploitation scenarios that start with the attacker deploying a bogus ERC-20 token.  In the first scenario, a malicious stream is created with the attacker set as the sender and the EscrowedEXA contract set as the recipient. Upon the attacker canceling the stream directly through Sablier, the onStreamCanceled function is invoked, allowing the attacker to mint esEXA tokens. This scenario is also possible if the roles are reversed, with the attacker set as the recipient and the EscrowedEXA contract set as the sender.  The second scenario involves creating a stream with the EscrowedEXA contract set as the sender and the attacker as the recipient. Calling the cancel function of the EscrowedEXA contract results in the minting of esEXA tokens.  Consider adding a mapping that identifies streams created by the EscrowedEXA contract. Upon cancellation, verify the streamId in the cancel function and the onStreamCanceled hook, ensuring that only the streams created by the EscrowedEXA contract are processed successfully.  Update: Resolved in pull request #672 at commit 0182437.  Low Severity", "html_url": "https://blog.openzeppelin.com/exactly-escrowedexa-audit#unrestricted-minting-of-esexa-tokens", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Within EscrowedEXA.sol, there are several parts that do not have docstrings. For instance:  Line 189: the clock function.  Line 194: the CLOCK_MODE function.  Lines 211 to 225: the entire ISablierV2LockupLinear interface.  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #676 at commit 9a29592.", "html_url": "https://blog.openzeppelin.com/exactly-escrowedexa-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "User May Commit To Vesting Terms They Did Not Anticipate", "body": "EscrowedEXA contract enables users to initiate the vesting process through the  vest function, allowing them to retrieve  reserveRatio and  vestingPeriod parameters can be modified by an administrative account at any time.  The issue arises from the uncertainty faced by users when initiating the vesting process, as they cannot be certain of whether the reserveRatio or vestingPeriod will remain the same when their transaction is included in a block. If the administrator modifies the reserveRatio or vestingPeriod parameters and their transaction is executed before the user's vesting, the user may inadvertently commit to vesting parameters that they did not anticipate.  Consider adding expectedReserveRatio and expectedVestingPeriod parameters to the vest function. If the values of these parameters differ from the actual reserveRatio and vestingPeriod, the transaction should revert, ensuring that users are not bound to vesting parameters they did not expect.  Update: Resolved in pull request #673 at commit ef251d3.", "html_url": "https://blog.openzeppelin.com/exactly-escrowedexa-audit#user-may-commit-to-vesting-terms-they-did-not-anticipate", "labels": ["OpenZeppelin"]}, {"title": "Lack of Input Validation", "body": "The EscrowedEXA contract implements two administrative functions that miss input validation:  The setVestingPeriod function updates the vesting period. Consider adding a check to restrict it to reasonable values.  The setReserveRatio function updates reserveRatio. Consider restricting it, as a value that is too high would require considerable reserves to be deposited in order to start vesting.  Update: Acknowledged, not resolved. The Exactly team stated:  We believe it is difficult to see what is a valid range for it beforehand which will not leave us too limited in the future. At the same time, the check could also bring a false sentiment of safety.", "html_url": "https://blog.openzeppelin.com/exactly-escrowedexa-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Initialization of ERC20Permit", "body": "In the OpenZeppelin Upgradeable contracts, unchained functions are used to mitigate potential double initialization problems. However, because of the simple inheritance structure in the EscrowedEXA contract, double initialization is not a concern in the current implementation.  Using __ERC20Permit_init_unchained instead of __ERC20Permit_init is not necessary, and leaves the EIP712Upgradeable contract's name and version uninitialized. This is not consistent with the EIP-712 domain separator specification, and will lead to issues when integrating with signatures that fully comply with EIP-712.  Consider using the __ERC20Permit_init function in order to correctly initialize the EIP-712 domain separator.  Update: Resolved in pull request #674 at commit 1725765.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/exactly-escrowedexa-audit#incorrect-initialization-of-erc20permit", "labels": ["OpenZeppelin"]}, {"title": "Missing Named Parameters in Mapping", "body": "Since Solidity 0.8.18, developers can utilize named parameters in mappings. This means mappings can take the form of mapping(KeyType KeyName? => ValueType ValueName?). This updated syntax provides a more transparent representation of the mapping's purpose.  Consider adding named parameters to the reserves mapping in the EscrowedEXA.sol contract to improve the readability and maintainability of the codebase.  Update: Acknowledged, will resolve. The Exactly team stated:  The team will work on this soon, but for now, we need to keep using the same Solidity version that we are using in the rest of the contracts.", "html_url": "https://blog.openzeppelin.com/exactly-escrowedexa-audit#missing-named-parameters-in-mapping", "labels": ["OpenZeppelin"]}, {"title": "Lack of Security Contact", "body": "Providing a specific security contact, such as an email or ENS, within a smart contract significantly simplifies the process for individuals to communicate if they identify a vulnerability in the code. This practice proves beneficial as it permits the code owners to dictate the communication channel for vulnerability disclosure, eliminating the risk of miscommunication or failure to report due to a lack of knowledge on how to do so. Additionally, if the contract incorporates third-party libraries and a bug surfaces in these, it becomes easier for the creators of those libraries to make contact, inform the code owners about the problem, and provide mitigation instructions.  The EscrowedEXA contract does not have a security contact.  Consider adding a NatSpec comment with a security contact, on top of the contract definition. Using the @custom:security-contact convention is recommended as it has been adopted by the Openzeppelin Wizard and the ethereum-lists.  Update: Acknowledged, not resolved. The Exactly team stated:  We believe our channels and bug bounty programs are public enough if someone wants to reach us.", "html_url": "https://blog.openzeppelin.com/exactly-escrowedexa-audit#lack-of-security-contact", "labels": ["OpenZeppelin"]}, {"title": "Unused Named Return Variable", "body": "Named return variables are a way to declare variables that are meant to be used within a function's body for the purpose of being returned as the function's output. They are an alternative to explicit in-line return statements.  In EscrowedEXA contract, the streamId return variable for the vest function is unused.  Consider either using or removing any unused named return variables.  Update: Acknowledged, not resolved. The Exactly team stated:  This is a style choice that we believe makes the function more readable.", "html_url": "https://blog.openzeppelin.com/exactly-escrowedexa-audit#unused-named-return-variable", "labels": ["OpenZeppelin"]}, {"title": "Typographical Error", "body": "Consider addressing the following typographical error:  Line 130 should say recipient instead of recepient.  Update: Resolved in pull request #675 at commit 61efaf9. The Exactly team stated:  We removed the internal function where the NatSpec had a typographical error.", "html_url": "https://blog.openzeppelin.com/exactly-escrowedexa-audit#typographical-error", "labels": ["OpenZeppelin"]}, {"title": "Improper Use of assert", "body": "EscrowedEXA contract, there are several instances where  68,  78,  88,  134,  149 and  170.  Generally, assert is used to test system invariants, while require is used to check return values or validate inputs. Moreover, if a transaction reverts because of assert, no leftover gas is returned to the caller, potentially resulting in a negative user experience.  Consider replacing the above occurrences of assert with require.  Update: Acknowledged, not resolved. The Exactly team stated:  This is not true, after solidity 0.8. assert no longer consumes all caller gas. It is also a style choice, and we are being consistent with the rest of the contracts in the protocol.", "html_url": "https://blog.openzeppelin.com/exactly-escrowedexa-audit#improper-use-of-assert", "labels": ["OpenZeppelin"]}, {"title": "Code Is Not Fully Consistent With Solidity Style Guide", "body": "There are several occurrences where the Solidity style guide is not followed, which makes the code more error-prone and difficult to read:  The withdrawMax function is internal and its name should start with an underscore _.  The order of functions within the contract should start with the constructor, followed by external, public, internal, and private functions at the end.  Consider adjusting the layout of the EscrowedEXA.sol file by declaring the ISablierV2LockupLinear interface and defining top-level structs before the EscrowedEXA contract implementation.  To increase the overall readability of the codebase, consider following the Solidity style guide.  Update: Acknowledged, not resolved. The Exactly team stated:  This is a style choice, we are being consistent with the rest of the contracts in the protocol.", "html_url": "https://blog.openzeppelin.com/exactly-escrowedexa-audit#code-is-not-fully-consistent-with-solidity-style-guide", "labels": ["OpenZeppelin"]}, {"title": "Fee-On-Transfer Tokens Lead to Improper Tracking", "body": "updateAssetsState function. If the asset is configured to be transferred directly to the destination (i.e., the  RiskFundV2 vault), the  poolAssetsFunds in  will be updated using the  updatePoolState call. However, if this asset is a fee-on-transfer token, the balance will not be properly tracked as the amount of funds sent from the  poolAssetsFunds. Consider tracking the actual amount of funds received by  Update: Resolved at commit 4025db0.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#fee-on-transfer-tokens-lead-to-improper-tracking", "labels": ["OpenZeppelin"]}, {"title": "ERC-777 Tokens Lead to Improper Tracking", "body": "RiskFundConverter and  XVSVaultConverter are offering the income generated by the Venus protocol to external agents for either  convertExactTokens function which transfers  By subtracting the token balance before the transfer by the token balance after the transfer, the converter contract knows how many tokens were sent out in order to update the internal state in the  postConversionHook function.  If the token is an ERC-777 and the external agent has registered a receive hook, it will be able to execute arbitrary code during the transfer. During this arbitrary code execution, the agent is able to influence the token balance by either transferring out tokens or acquiring additional tokens (e.g., by interacting with a DEX or lending protocol). By performing this action, the agent is able to inflate or deflate the calculation of the amount of funds which were sent out of the converter contract.  As this value is used to keep track of the number of assets held by the converter, the agent is able to create a discrepancy between the amount of tokens that the converter is tracking and the one it is actually holding. In case the converter is tracking fewer tokens than it actually holds, the balances can easily be synced using the updateAssetsState function. However, in case the converter is tracking more tokens than it actually holds, honest external agents' swaps will result in a revert as the converter does not hold enough tokens to perform a swap.  Consider tracking the amount of tokens which were sent out of the converter by subtracting the token balance of the converter instead of the token balance of the external agent.  Update: Resolved at commit 939da0a.  Low Severity", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#erc-777-tokens-lead-to-improper-tracking", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Convention for Checking Access Allowance", "body": "here and  here), but it is called using a  different convention in  revert.  Update: Resolved at commit b467b46.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#inconsistent-convention-for-checking-access-allowance", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Zero-Address Checks", "body": "In the RiskFundConverter contract, there are some inconsistencies in how zero addresses are checked. For example:  Three addresses are passed to the constructor but only the first is checked with ensureNonzeroAddress. vBNB and NATIVE_WRAPPED are never checked throughout the contract. Consider checking that all arguments are non-zero.  Throughout the contract, zero addresses are checked using a mix of ensureNonzeroAddress and != address(0). Consider adopting a consistent convention.  In updateAssetsState, poolRegistry is checked to be non-zero, but this seems unnecessary. It is not an argument to the function and is always checked when set. Consider removing the check in updateAssetsState, but adding it in the initializer.  Update: Resolved at commit 0f58716.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#inconsistent-zero-address-checks", "labels": ["OpenZeppelin"]}, {"title": "Owner Can Only Sweep Tracked Assets From Risk Fund", "body": "The risk fund's sweep function only allows the owner to transfer funds that have been deposited by the risk fund converter and tracked in the internal state. There is no functionality to sweep tokens that have been mistakenly sent to the contract, as exists in the token converter.  Consider adding arbitrary token sweeps to the risk fund to prevent donated tokens from becoming irrecoverable.  Update: Resolved at commit a842667.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#owner-can-only-sweep-tracked-assets-from-risk-fund", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings. For instance:  Line 57 in IAbstractTokenConverter.sol  Line 23 in RiskFundStorage.sol  Line 274 in RiskFundConverter.sol  Line 34 in RiskFundStorage.sol  Line 36 in XVSVaultConverter.sol  Line 84 in XVSVaultTreasury.sol  Line 24 in IAbstractTokenConverter.sol  Line 72 in XVSVaultTreasury.sol  Line 18 in IAbstractTokenConverter.sol  Line 22 in IAbstractTokenConverter.sol  Line 48 in IAbstractTokenConverter.sol  Line 32 in IAbstractTokenConverter.sol  Line 56 in IAbstractTokenConverter.sol  Line 40 in IAbstractTokenConverter.sol  Line 20 in IAbstractTokenConverter.sol  Line 55 in RiskFundConverter.sol  Line 52 in RiskFundConverter.sol  Line 58 in RiskFundConverter.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved at commit a555053.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Missing Event Emissions", "body": "RiskFundConverter emits the AssetsReservesUpdated event upon updating the poolsAssetsReserves mapping in updateAssetsState. poolsAssetsReserves is updated in updatePoolAssetsReserve as well, but no event is emitted here.  When tokens are sent from the RiskFundConverter to the RiskFundV2 in updateAssetsState, the AssetTransferredToDestination event is emitted. Similarly, _actualAmounts in AbstractTokenConverter sends funds to RiskFundV2, but no event is emitted here.  Consider adding event emissions in the previously described cases to ensure that off-chain monitoring can properly track these occurrences.  Update: Resolved at commit 35dc0a1.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#missing-event-emissions", "labels": ["OpenZeppelin"]}, {"title": "Missing Check of XVS Store Address", "body": "In the XVSVaultTreasury contract, the xvsStore address is obtained from the xvsVault before tokens are transferred to the xvsStore. However, there is no check that the address is non-zero.  Consider verifying the xvsStore address before sending tokens to it.  Update: Resolved at commit e558b15.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#missing-check-of-xvs-store-address", "labels": ["OpenZeppelin"]}, {"title": "Sweeping Tokens in Risk Fund Should Be Protected by Access Control Manager", "body": "According to the onlyOwner vs. AccessControlManager (ACM) rule, more critical changes (i.e., relationships between contracts) should be protected with onlyOwner as this is protected by the normal timelock (24 hours of voting + 48 hours of delay). The ACM should be used for actions which should potentially bypass voting, enabling them to take the fast-track or critical route, or even to be executed directly through a multisig by guardians.  The sweepToken function in RiskFundV2 sweeps tokens from the RiskFund vault to the owner. As this functionality is not a critical change in the protocol but only moves assets, it could benefit from the shorter fast-track or critical VIPs in certain cases. For example, if bad debt needs to be covered quickly in case of heavy market fluctuations.  Consider restricting access to the ACM instead of the onlyOwner modifier in this case.  Update: Acknowledged, not resolved. The Venus team stated:  After a discussion with the team, we came to the conclusion of using OnlyOwner for the sweepToken.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#sweeping-tokens-in-risk-fund-should-be-protected-by-access-control-manager", "labels": ["OpenZeppelin"]}, {"title": "Lack of Storage Gap", "body": "The upgradeable XVSVaultConverter contract does not have a storage gap configured. Storage gaps are a convention for reserving storage slots in a base contract, allowing future versions of that contract to use up those slots without affecting the storage layout of the child contract.  Consider adding a storage gap variable to avoid future storage clashes in upgradeable contracts.  Update: Resolved at commit 2be108d.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#lack-of-storage-gap", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Comments", "body": "Throughout the codebase, there are instances of misleading comments or comments with typographical errors. For example:  In AbstractTokenConverter.sol:  line 240: \"fater\" should be \"after\"  line 344: says public function, but has the onlyOwner modifier  line 474: \"liquity\" should be \"liquidity\"  line 143 and line 624: these functions set the destination address, not the oracle  In RiskFundConverter.sol:  line 224: \"poolAssetsResreves\" should be \"poolAssetsReserves\"  line 180: \"transfromation\" should be \"transformation\"  Consider correcting these comments to improve the overall clarity of the codebase.  Update: Resolved at commit 5d0f03b.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#incorrect-comments", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Storage Usage in Conversion Configuration", "body": "convertConfigurations mapping stores  ConversionConfig structs for each  setConversionConfig, this would be the only function that would require refactoring after making this change.  Update: Resolved at commit 91eb7a6.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#unnecessary-storage-usage-in-conversion-configuration", "labels": ["OpenZeppelin"]}, {"title": "postSweepToken Should Revert Early on Insufficient Balance", "body": "postSweepToken in the  transferred out. If the  Consider reverting early in postSweepToken to handle these cases and ensure more clearly defined error handling and gas efficiency.  Update: Resolved at commit 1e367e1.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#postsweeptoken-should-revert-early-on-insufficient-balance", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Error in getAmountIn", "body": "function reverts with an InsufficientInputAmount error, while semantically it should be an  Consider correcting the error to accurately describe the situation.  Update: Resolved at commit 8d6389c.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#incorrect-error-in-getamountin", "labels": ["OpenZeppelin"]}, {"title": "Unused State Variables", "body": "Throughout the codebase, there are multiple unused state variables:  The maxLoopsLimit state variable in the MaxLoopsLimitHelpersStorage contract.  The pancakeSwapRouter state variable in the RiskFundV1Storage contract.  The minAmountToConvert state variable in the RiskFundV1Storage contract.  The BLOCKS_PER_YEAR state variable.  To improve the overall clarity, intentionality, and readability of the codebase, consider removing any unused state variables. In case the unused state variable is necessary to prevent storage collisions between different versions of a contract (e.g., maxLoopsLimit, pancakeSwapRouter and minAmountToConvert), consider changing the name of the variable to clarify that the variable is deprecated.  Update: Resolved. The Venus team stated:  The state variables maxLoopsLimit, pancakeSwapRouter, and minAmountToConvert already have explanations in their Natspec that they are deprecated. Regarding the BLOCKS_PER_YEAR state variable, it might have utility in the future. Importantly, it hasn't been imported in any file, ensuring that it does not impact the bytecode as of now.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#unused-state-variables", "labels": ["OpenZeppelin"]}, {"title": "Unused Named Return Variables", "body": "Named return variables are a way to declare variables that are meant to be used within a function's body for the purpose of being returned as the function's output. They are an alternative to explicit in-line return statements.  There is an instance of an unused named return variable, which is the tokenBalance return variable in the balanceOf function in RiskFundConverter.sol.  Consider either using or removing any unused named return variables.  Update: Resolved at commit 8227f4b.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#unused-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Lack of Security Contact", "body": "Providing a specific security contact (such as an email or ENS name) within a smart contract significantly simplifies the process for individuals to communicate if they identify a vulnerability in the code. This practice proves beneficial as it permits the code owners to dictate the communication channel for vulnerability disclosures, eliminating the risk of miscommunication or failure to report due to a lack of knowledge on how to do so. Additionally, if the contract incorporates third-party libraries and a bug surfaces in these, it becomes easier for the maintainers of those libraries to make contact with the appropriate person about the problem and provide mitigation instructions.  Throughout the codebase, there are contracts that do not have a security contact:  The IAbstractTokenConverter contract  The ReserveHelpersStorage contract  The RiskFundConverter contract  The RiskFundV1Storage contract  The AbstractTokenConverter contract  The MaxLoopsLimitHelpersStorage contract  The XVSVaultConverter contract  The XVSVaultTreasury contract  The RiskFundV2Storage contract  The RiskFundV2 contract  Consider adding a NatSpec comment containing a security contact on top of the contracts' definition. Using the @custom:security-contact convention is recommended as it has been adopted by the OpenZeppelin Wizard and the ethereum-lists.  Update: Resolved at commit 08bacb3.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#lack-of-security-contact", "labels": ["OpenZeppelin"]}, {"title": "Constants Not Using UPPER_CASE Format", "body": "Throughout the codebase there are constants not using UPPER_CASE format. For instance:  The xvsAddress constant declared on line 16 in XVSVaultTreasury.sol  The corePoolComptroller constant declared on line 20 in RiskFundConverter.sol  The vBNB constant declared on line 24 in RiskFundConverter.sol  According to the Solidity Style Guide, constants should be named with all capital letters with underscores separating words. For better readability, consider following this convention.  Update: Resolved at commit bda9bea.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#constants-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "The Function _disableinitializers() Is Not Being Called in the Constructors of Multiple Initializable Contracts", "body": "An implementation contract in a proxy pattern allows anyone to call its initialize function. While not a direct security concern, preventing the implementation contract from being initialized is important, as this could allow an attacker to take over the contract. This would not affect the proxy contract's functionality, as only the implementation contract's storage would be affected.  Throughout the codebase, there are multiple initializable contracts where _disableInitializers() is not called in the constructor. For instance:  The initializable contract RiskFundConverter within the RiskFundConverter.sol file.  The initializable contract XVSVaultConverter within the XVSVaultConverter.sol file.  Consider calling _disableInitializers() in initializable contract constructors to prevent malicious users from tampering with implementation storage.  Update: Resolved at commit 78150be.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#the-function-_disableinitializers()-is-not-being-called-in-the-constructors-of-multiple-initializable-contracts", "labels": ["OpenZeppelin"]}, {"title": "Lack of Indexed Event Parameters", "body": "Within AbstractTokenConverter.sol, several events do not have their parameters indexed. For instance:  line 51  line 54  line 69  line 72  Consider indexing event parameters to improve the ability of off-chain services to search for and filter for specific events.  Update: Resolved at commit 3876d3b.", "html_url": "https://blog.openzeppelin.com/venus-token-converter-audit#lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Unexpected Entry Point Leads to User Impersonation", "body": "Consider adding a require statement to enforce that initiator == address(this).  Update: Resolved in pull request #35 at commit f6aa4b7.", "html_url": "https://blog.openzeppelin.com/wido-comet-collateral-swap-contracts#unexpected-entry-point-leads-to-user-impersonation", "labels": ["OpenZeppelin"]}, {"title": "Unrestricted Execution with _swap Function", "body": "The _swap function is designed to allow users to exchange collateral removed from a Comet market, ensuring there are enough assets to repay the flash loan. However, the swap process, executed on line 85 of LibCollateralSwap.sol, heavily relies on user inputs. This dependence creates a vulnerability, where an attacker might inject malicious inputs into the contract, thereby potentially initiating unrestricted calls to any other smart contract within the blockchain. Combined with other issues found (see C01, H01, M02, and L03) this leads to scenarios where calling users can have all of their Comet positions stolen.  Below is an illustration of this attack, demonstrating how an attacker can exploit the signatures provided by any user, along with the contract's manager-level access over the user's Comet funds, to steal the user's collateral:  Alice holds a debt position in Comet and she wishes to exchange a portion of her collateral for a new one  An attacker sees Alice's public transaction and her signatures, and makes a new transaction. They keep Alice's signatures and pass in a malicious contract's address as the Comet address to gain control whenever Comet is called from the protocol  The attacker front-runs Alice's transaction  The attacker takes a flash loan for the contract, triggering executeOperation  The attacker gains control on line 121 of LibCollateralSwap.sol, where the contract has manager access over the user's Comet funds  Attacker re-enters the collateral swap function, this time aiming for line 85 of LibCollateralSwap.sol providing malicious inputs to steal all of Alice's unlocked funds. They specify an official Comet address as swap.router and transferAssetFrom(address,address,address,uint256) as swap.callData to steal the user's unlocked collateral.  As a side note, the attacker can go further and unlock all of the user's Comet collateral with a flash loan before the whole process, to effectively steal all of their collateral, close the debt position and come out with a profit since the position is over-collateralized.  Consider sanitizing the swap input to ensure users are calling the correct swap contract. Also, you can utilize OpenZeppelin's reenterancy guard to ensure the flow is executed once at a time.  Update: Resolved in pull request #38 at commit e093542.  High Severity", "html_url": "https://blog.openzeppelin.com/wido-comet-collateral-swap-contracts#unrestricted-execution-with-_swap-function", "labels": ["OpenZeppelin"]}, {"title": "Comet Address Is Not Confirmed", "body": "performCollateralSwap allows a user to specify an address that will be used as a Comet implementation. The address, however, is not confirmed to be an official Comet market, allowing a user to run any arbitrary contract in its place. An attacker could input a malicious contract address or lead others to do so and gain control over the transaction at critical points of the execution to steal from users. See line 121 of the LibCollateralSwap.sol for an example of where execution control would be transferred.  Consider storing valid Comet addresses within the contract or confirming Comet addresses by calling the Comet Configurator's getConfiguration method.  Update: Partially resolved in pull request #36 at commit e933cdc. While storage space for a comet market address has been added, consider verifying the input address during construction via Comet's Configurator.  Medium Severity", "html_url": "https://blog.openzeppelin.com/wido-comet-collateral-swap-contracts#comet-address-is-not-confirmed", "labels": ["OpenZeppelin"]}, {"title": "Lack of swap sanitization could lead to user's collateral being stolen", "body": "During the collateral swap process, the swap function is supposed to exchange user's collateral to make up enough funds and repay the flash loan. However, the function never checks that the swap's output token is the same as the flash loan borrowed asset, and the contract only re-invests the surplus amount of the borrowed asset back into the user's Comet. In case users make the mistake of calling swapCollateral by swapping into the the wrong asset (other than the flash loan or deposit asset), the tokens can be stuck in the contract and malicious users can steal the tokens.  For example:  Alice sends a transaction that takes flash loan in USDC, but by mistake swaps the removed collateral into USDT. This should cause the transaction to fail, since there is not enough funds to repay the flash loan.  An attacker sees the transaction, and sends enough USDC to the protocol just before Alice's transaction to make her transaction pass.  After Alice's transaction passes, there are some amount of USDT left in the protocol from Alice's swap  The attacker now creates a vacuous transaction, specifying USDT as their flash loan asset. Since line 65 of LibCollateralSwap.sol simply transfers all of the borrowed asset in the contract to the caller, the attacker will get all of the USDT that Alice wanted to swap for (less the value of the loan required to swap).  Consider checking the swap destination token type is the same as the flash loan token type during the swap process to mitigate this attack vector.  Update: Partially resolved in pull request #37 at commit d66b097. While the code checks if the swap has utilized the flash loan asset, the larger Wido swap contracts were out of scope and so the same attack vector may remain should the swap attempt to swap for multiple tokens.", "html_url": "https://blog.openzeppelin.com/wido-comet-collateral-swap-contracts#lack-of-swap-sanitization-could-lead-to-user's-collateral-being-stolen", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary fee structuring", "body": "During the collateral swap the flash loan fee is first subtracted from the flash loan amount which is then deposited into Comet. This is to ensure that the protocol has enough to pay the flash loan fee. But the swap process itself also relies on the user to pick a large enough amount to withdraw so as to cover the flash loan amount with a token swap. Since the contract checks for the required amount to be repaid, removing the fee first only adds to the complexity of the calculation with which the user has to decide the withdrawal amount. This could be a difficult task given the process involves unpredictable market exchange rate and slippage caused by available liquidity between the two swapping collaterals.  Consider removing the fee deduction to use the full flash loan for the Comet collateral deposit. Further consider offering helper functions to assist with the calculation of the appropriate final collateral amount.  Update: Acknowledged, not resolved. The Wido team stated:  We have an off-chain SDK to assist with the calculation.  Low Severity", "html_url": "https://blog.openzeppelin.com/wido-comet-collateral-swap-contracts#unnecessary-fee-structuring", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings. For example:  Line 14 of WidoCollateralSwap_Aave.sol  Line 12 of WidoCollateralSwap_ERC3156.sol  Line 9 of LibCollateralSwap.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well (even copied interfaces). When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #34 at commit 9a24c01.", "html_url": "https://blog.openzeppelin.com/wido-comet-collateral-swap-contracts#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Exposed signatures can be lead to unanticipated permissions", "body": "To call swapCollateral, a user must provide signatures for allowing the contract permission to move the user's funds on Comet. Exposing this signature means that a front-runner can call Comet's allowBySig with the signature ahead of the swapCollateral transaction. The swap transaction will fail because of a bad nonce and the swap contract will have complete permission for the users' account. This could be entirely unexpected and lead to a user unaware of permissions for their own account.  Consider requiring users to call Comet's allow function for the swap contract prior to interacting with it.  Update: Acknowledged, not resolved. The Wido team stated:  To make the UX simpler for the user, we are keeping the signatures.", "html_url": "https://blog.openzeppelin.com/wido-comet-collateral-swap-contracts#exposed-signatures-can-be-lead-to-unanticipated-permissions", "labels": ["OpenZeppelin"]}, {"title": "Failing Tests and Public env Variables", "body": "Multiple test cases are failing in the provided repo. Tests are an essential part of the development and security cycle. Consider fixing test cases and ensuring that all tests pass and that the coverage is high.  There is also a .env file included in the repo which contains information that might be sensitive, such as API keys. Consider removing these from the public repository and providing a .env.example as the template instead.  Update: Partially resolved in pull request #33 at commit 371963b. The testing suite was updated but we were unable to run them successfully.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/wido-comet-collateral-swap-contracts#failing-tests-and-public-env-variables", "labels": ["OpenZeppelin"]}, {"title": "Aave Pool Address is Immutable", "body": "The WidoCollateralSwap_Aave contract utilizes a POOL variable to call Aave flash loans. This variable is marked as immutable, meaning that when the Aave pool address changes, this entire contract will need to be redeployed. Consider making this variable mutable so it can be updated in the future.  Update: Acknowledged, not resolved. The Wido team stated:  We are okay with deploying a new contract when the Aave Pool address changes.", "html_url": "https://blog.openzeppelin.com/wido-comet-collateral-swap-contracts#aave-pool-address-is-immutable", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "Throughout the codebase, there are imports that are unused and could be removed. For instance:  Import IComet of WidoCollateralSwap_Aave.sol  Import IComet of WidoCollateralSwap_ERC3156.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #32 at commit f34c83b.", "html_url": "https://blog.openzeppelin.com/wido-comet-collateral-swap-contracts#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Using int/uint instead of int256/uint256", "body": "Within IComet.sol, there are multiple instances where int/uint is used as opposed to int256/uint256. For instance:  On line 6 of IComet.sol  On line 8 of IComet.sol  In favor of explicitness, consider replacing all instances of int/uint with int256/uint256.  Update: Resolved in pull request #32 at commit f34c83b.", "html_url": "https://blog.openzeppelin.com/wido-comet-collateral-swap-contracts#using-int/uint-instead-of-int256/uint256", "labels": ["OpenZeppelin"]}, {"title": "Eligibility Manipulation Leads to Stolen Rewards", "body": "Users can leverage their position by calling the loop function within the Leverager contract. This function will loop through multiple cycles of depositing and borrowing of the same asset in order to achieve the desired leveraged position.  During this process, ChefIncentivesController's setEligibilityExempt function is called to temporarily activate an exemption for the user. This skips the check on their eligibility after every iteration in order to save gas. Once the position is fully leveraged, this exemption is set back to false on the last loop iteration.  loopCount of 0 iterations is allowed, so an attacker may pass  loopETH and  loopETHFromBorrow, but in those functions, the eligibility exemption is toggled back to  handleActionAfter hook to prevent eligibility updates for  transfers,  mint,  burn) and  mint,  burn) contracts it opens up different attack vectors such as:  Reusing the same deposit across multiple accounts in order to emit additional rewards by transferring the rTokens between multiple accounts and requalifying every account for rewards via requalifyFor.  Inflating the user's pool balance by depositing a flash-loaned asset, requalifying the position for rewards eligibility via requalify and finally withdrawing the deposit to pay back the flash loan amount. At this point, the total deposited collateral is zero but the user is still emitting rewards for the entire amount previously deposited.  The only requirement in both scenarios is to have the minimum required LP locked from the attack setup until the closest maturity date. After that, since deposited collateral will be zero, the required amount of LP tokens locked to maintain eligibility will also be zero.  Consider refactoring the loop function to ensure that the eligibility exempt is always set back to false before returning and enforcing loopCount to be strictly larger than 0.  Update: Resolved in pull request #170 at commit 5f64342. A new InvalidLoopCount custom error has been introduced. It is used to revert the loop, loopETH, and loopETHFromBorrow functions when they are called with a loopCount value equal to zero.  High Severity", "html_url": "https://blog.openzeppelin.com/radiant#eligibility-manipulation-leads-to-stolen-rewards", "labels": ["OpenZeppelin"]}, {"title": "Vested RDNT Tokens Can Be Withdrawn Early With No Penalties", "body": "individualEarlyExit function within the  ieeWithdrawableBalances. Once a  record is matched, its index is assigned and returned along with the penalty and burn amounts. The  contains a check that presumes that an out-of-bounds  halting execution as intended, it will continue and  remove the first userEarnings item from the list, while not correctly decreasing the user's  earned balance accordingly. This transaction will not revert and will end up transferring 0 RDNT tokens to the user and the DAO treasury.  exit function to determine the withdrawable balance by looping through the  The end result is that any user can withdraw their full amount of RDNT rewards at any time, bypassing any penalties for exiting early.  To ensure users cannot withdraw earnings that are not fully vested without penalties, consider reverting when the specified unlockTime is not found.  Update: Resolved in pull request #242 at commit 0752677. If the specified unlockTime is not found, the transaction will revert with the custom error UnlockTimeNotFound.", "html_url": "https://blog.openzeppelin.com/radiant#vested-rdnt-tokens-can-be-withdrawn-early-with-no-penalties", "labels": ["OpenZeppelin"]}, {"title": "RDNT Token Bridge Fee Can Be Bypassed", "body": "The RDNT token is implemented as a LayerZero Omnichain Fungible Token (OFT), which allows it to be sent to any blockchain that has a LayerZero endpoint. The tokens can be transferred cross-chain by using the OFT sendFrom function, which internally calls the overridden _send function in the RadiantOFT contract. The purpose of this override is to allow the Radiant team to collect an extra fee called the bridge fee, which is expressed in the chain's native currency and dependent on the amount of RDNT being transferred.  This fee can potentially be bypassed by instead using the OFT sendAndCall function, which is similar to sendFrom but allows executing a specific payload after executing the token transfer. If crafted correctly, this will execute the inherited _sendAndCall function, which has not been overridden to also collect the bridge fee.  Consider overriding the internal _sendAndCall function in order to also collect the extra fee and avoid the potential loss of protocol revenue.  Update: Resolved in pull request #176 at commits 01b2bde and eddbf1c.", "html_url": "https://blog.openzeppelin.com/radiant#rdnt-token-bridge-fee-can-be-bypassed", "labels": ["OpenZeppelin"]}, {"title": "Initial Liquidity Can Be Lost by Front-Running Pool Initialization", "body": "Both the UniswapPoolHelper and BalancerPoolHelper contracts implement an initializePool function that is responsible for creating a new liquidity pool for the RDNT token paired with a base token. In the currently deployed contracts, RDNT is paired with WETH on Arbitrum and WBNB on Binance Smart Chain. In the case of Uniswap, this initialization will revert if a pair has already been created.  UniswapPoolHelper and  BalancerPoolHelper as a manual set of transactions, instead of being executed atomically. After depositing liquidity into a pool, the respective  here and  here).  However, access to these initializePool functions is unrestricted, which allows any user to perform the pool initialization step. This leads to the front-running scenario where an attacker monitors the mempool and waits for the protocol owners to send RDNT and WETH tokens to the contract, and then front-runs the initializePool transaction, or alternatively (on Layer 2 chains that do not feature public mempools), the attacker can back-run the second token transfer to accomplish the same goal. The existing RDNT and WETH or WBNB contract balances will then be used to provide liquidity and send the minted LP tokens to the attacker.  Consider adding the onlyOwner modifier to the initializePool functions of UniswapPoolHelper and BalancerPoolHelper to ensure they can only be executed by the protocol owners, and/or implementing an atomic flow of contract deployment, transfer of funds, and pool initialization.  Update: Resolved in pull request #177 at commit 7ce4838. The onlyOwner modifier was added to both initializePool functions.", "html_url": "https://blog.openzeppelin.com/radiant#initial-liquidity-can-be-lost-by-front-running-pool-initialization", "labels": ["OpenZeppelin"]}, {"title": "Bounty Hunters Can Incur a Denial-of-Service", "body": "Successful bounty hunters are expected to claim a large number of bounties per day. The larger the protocol grows, the more situations will arise for hunters to get a reward for ensuring the protocol works as expected.  These bounties are paid out in RDNT tokens, but not directly to the hunter's wallet. Instead, these tokens go into a 90-day vesting period. In order to track penalties for each individual amount in vesting, every bounty needs to be separately added to the hunter's earnings array.  A successful bounty hunter can potentially claim a very large amount of bounties within the same 90-day period (before vesting ends for his first bounty), causing the userEarnings array to be so large that any interaction with it on a transaction will fail due to running out of gas because it has reached the block gas limit. When this happens, hunters will not be able to withdraw their earnings or perform static calls to the earnedBalances function, essentially bricking protocol interactions for that specific user.  The same effect can be achieved by a malicious actor performing a grieving attack on any account by claiming numerous times on behalf of a victim's address since there is no minimum amount claimable and there is no access control enforced when claiming rewards.  In order to avoid a denial of service on regular users, consider increasing the minimum amount claimable to a reasonable threshold. Additionally, consider enforcing access control on the claiming functionality if necessary.  Regarding bounty hunters, in order to prevent them from incurring a denial-of-service, consider implementing an alternate solution to how bounties are added to the userEarnings array. For example, the same array item could be used to combine multiple bounty amounts claimed within the same day.  Update: Resolved in pull request #201 at commits 42c6772, bec761e, 5b43456, 82d6503, d4c1489 and 814adc6. Claims of 0 RDNT are disallowed and a 1-day epoch system has been implemented so that both RDNT claims and LP locks of the same type happening on the same day are merged within 1 entry. LP locks aggregation only takes place if the current lock will unlock on the exact same day as the last lock from the user list. This strategy makes the protocol more gas efficient and protects both users and bounty hunters from denial-of-service attacks by limiting the number of entries in both arrays.", "html_url": "https://blog.openzeppelin.com/radiant#bounty-hunters-can-incur-a-denial-of-service", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Accounting of earned and unlocked Tokens on exit May Brick the Protocol", "body": "The exit function within the MultiFeeDistribution contract is responsible for withdrawing RDNT tokens (earnings) that are already unlocked and still in vesting. It is using withdrawableBalance to calculate the balance that can be withdrawn, and then it releases the tokens to the user via _withdrawTokens.  While the function is correctly deleting userEarnings, it is not updating the unlocked and earned balances to 0, which is where the withdrawableBalance function gets the data from.  A regular call to exit will break that user's internal accounting for earnings and lockings, leading to reverts for crucial functionalities of the system and thus, causing unexpected results and potentially bricking most of the MultiFeeDistribution contract alongside other parts of the protocol.  The following features will be impacted by the incorrect value of earned or unlocked tokens:  The exit function will be reverting when updating the value of total.  The withdrawableBalance function will be returning an incorrect value.  The withdraw function will be reverting when updating value of total.  The earnedBalances function will be returning anincorrect value.  In order to maintain a correct internal accounting of user balances, it is recommended to reset both the unlocked and earned balances to 0 in the exit function.  Update: Resolved in pull request #66 at commit 1830760. Both unlocked and earned values are now reset to 0 within the exit function.  Medium Severity", "html_url": "https://blog.openzeppelin.com/radiant#incorrect-accounting-of-earned-and-unlocked-tokens-on-exit-may-brick-the-protocol", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Calculation of Tokens to Burn on withdraw", "body": "The withdraw function of the MultiFeeDistribution contract implements the logic for withdrawing earned and unlocked tokens from the protocol. It loops through all earnings to sum the amount of earned tokens, penalties for the early withdrawal, and the burn amounts.  The problem is that burnAmount is incorrectly calculated by using the total penaltyAmount instead of the individual penalty for the current loop iteration, which leads to an inflated value of burnAmount.  It is recommended to correct the calculation of burnAmount by replacing penaltyAmount with the individual penalty associated with the current loop iteration.  Update: Resolved in pull request #208 at commit 65220b8.", "html_url": "https://blog.openzeppelin.com/radiant#incorrect-calculation-of-tokens-to-burn-on-withdraw", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Earnings Accounting When ChefIncentivesController Reserve Is Empty", "body": "claim function. The rewards are then sent to the  _mint, which uses the  _sendRadiant function to perform the actual transfer. Following the transfer, the claimed rewards are vested by calling  mint function.  reserve of RDNT tokens is empty, the contract is paused but the  _amount that the user would have received is still returned and used for  vesting. This behavior is incorrect since  To ensure adequate funds are present in the reserve, consider reverting when there are insufficient funds for any rewards claim. In addition, consider using OpenZeppelin Defender to detect this event and subsequently pause the contract or fill the reserve.  Update: Resolved in pull request #174 at commits 4c7d287 and 482c14f. The ChefIncentivesController contract will revert with an OutOfRewards custom error if there are not enough reserve funds to pay out a claim. Additionally, the contract is no longer paused when this situation is encountered.", "html_url": "https://blog.openzeppelin.com/radiant#incorrect-earnings-accounting-when-chefincentivescontroller-reserve-is-empty", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Usage of Uniswap V2 Oracle", "body": "example code for a Uniswap V2 oracle and  follows the example implementation to retrieve oracle price data. However, Uniswap's implementation actually relies on the unchecked arithmetic in Solidity  UniV2TwapOracle contains default checks to prevent overflow from occurring. Since the Uniswap implementation  expects overflows as part of normal operation, the use of modern Solidity  Consider adding unchecked to the parts of the UniV2TwapOracle code that are expected to overflow.  Update: Resolved in pull request #204 at commit 6e67d1c. All parts that are expected to overflow have been wrapped in unchecked blocks.", "html_url": "https://blog.openzeppelin.com/radiant#incorrect-usage-of-uniswap-v2-oracle", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Leveraged Borrow Calculation", "body": "The Leverager contract provides the ability to leverage a user's position by \"looping\" the deposit and borrow actions, i.e. funds that are borrowed are then deposited, increasing the collateral to borrow against in the next loop iteration. This functionality has been implemented by functions loop, loopETH, and loopETHFromBorrow, which cover various use cases.  percentage fee on every deposit during the leveraging process but the fee is not correctly deducted from the  reduced by the fee but  increased amount of borrowed tokens beyond what the user expected. The issue is present in  loop,  loopETH,  loopETHFromBorrow, and the view function  wethToZapEstimation.  Consider updating the value of the amount by deducting fee from it before using it for the deposit.  Update: Resolved in pull request #206 at commits 1483fb5, c95a251 and bb54b79.", "html_url": "https://blog.openzeppelin.com/radiant#incorrect-leveraged-borrow-calculation", "labels": ["OpenZeppelin"]}, {"title": "Leveraged Positions May Receive Reduced Reward Emissions", "body": "loopETH and  loopETHFromBorrow functions set a user as exempt from eligibility for the duration of the loop, which  disables any updates to  zapWETHWithBorrow is called to lock more LP tokens when necessary, in order to ensure that the user maintains reward emission eligibility. When the  stake function, updated  reflected within  However, when users are still eligible even after reaching the desired leverage, the function wethToZap will return 0 and thus, zapWETHWithBorrow will not lock any more liquidity. This will cause users to miss rewards generated by the newly deposited amount since ChefIncentivesController has not been notified about the new balance. Reward emission will continue the next time liquidity is locked on behalf of this specific user.  Consider redesigning both loopETH and loopETHFromBorrow functions in order to ensure that ChefIncentivesController is always notified about final rToken balances after the position is leveraged.  Update: Resolved in pull request #219 at commit 5a7a905. Both loopETH and loopETHFromBorrow have been refactored to behave like the loop function, where the exemption from eligibility is lifted right before performing the last loop iteration. This change ensures that ChefIncentivesController will receive accurate balance notifications after the position is fully leveraged.", "html_url": "https://blog.openzeppelin.com/radiant#leveraged-positions-may-receive-reduced-reward-emissions", "labels": ["OpenZeppelin"]}, {"title": "Slippage Tolerances May Be Too Large", "body": "When performing a selfCompound operation or when a hunter claims an auto-compound bounty, a series of swap operations take place so that an account's rewards can be converted into a combination of the base token (WETH or WBNB) and RDNT.  The first set of swap operations takes place when converting all aToken rewards into the base token. Each of those swaps has a maximum slippage ratio between 0% and 20%.  Once all rewards have been converted into the base token, the necessary amount of RDNT tokens charged as a fee when an auto-compound bounty is being claimed is swapped out from the base token balance. This swap is also subject to a 0%-20% maximum slippage.  Finally, the necessary percentage of the base token balance is swapped again into RDNT in order to be able to provide liquidity in the right ratio. This last swap operation is subject to the ACCEPTABLE_RATIO parameter, which can range from 0% to 100%.  All these slippage amounts can be compounded and an attacker may be able to extract up to the maximum slippage tolerance at all times.  Since Radiant users may have different amounts of capital invested in the protocol, different slippage settings should be enforced for each situation. Apart from enforcing sensible general parameters for these tolerances, consider giving users the ability to choose their own slippage settings so that smaller positions can get away with much tighter ratios.  Update: Resolved in pull request #225 at commits 59d7f1d, 6cb87f9, 937a6b9, 843555b, af0b342 and f466ecc. Users are now able to specify their own custom slippage value for swaps. When auto-compounding is enabled, the MultiFeeDistribution contract stores the user's desired slippage tolerance for compounding. Users are prevented from using a slippage tolerance greater than 5%. If a user has not set a slippage limit for compounding, the maximum slippage tolerance configured for the system will be used, which is currently set at 5%.", "html_url": "https://blog.openzeppelin.com/radiant#slippage-tolerances-may-be-too-large", "labels": ["OpenZeppelin"]}, {"title": "Missing whenNotPaused Modifier", "body": "LockZap contract implements pause functionality that prevents users from locking additional funds in case of emergency. While the functions  zapAlternateAsset is missing that modifier. As a result, even when the contract is paused, it will still be possible to use the  Consider adding the whenNotPaused modifier to the zapAlternateAsset function so that it cannot be executed while the contract is paused.  Update: Resolved in pull request #234 at commit 6e5faf7.", "html_url": "https://blog.openzeppelin.com/radiant#missing-whennotpaused-modifier", "labels": ["OpenZeppelin"]}, {"title": "Loss of RDNT Rewards When Compounding", "body": "claimCompound allows compounding accrued rewards into locked liquidity. The full  list of available rewards is configured within  claimFromConverter, this list is looped through and any available reward is transferred into the  However, the Radiant team confirmed that the RDNT token is added to the list of reward tokens within MultiFeeDistribution because in the future they might want to distribute them as rewards. If that happens, these tokens will get stuck on the Compounder contract because only rTokens are being handled, skipping the iteration when the token is RDNT.  Consider adding specific logic to handle RDNT rewards within the claimCompound function in order to avoid the potential loss of user rewards in the future.  Update: Resolved in pull request #213 at commits 8bad016, e43df4e, 2e579cc, 77ca628, 02db1ea, 776bda9 and 26bea56. RDNT rewards are no longer forwarded to the Compounder contract. Additionally, a safety check has been added so that no reward token can be added if it implements the UNDERLYING_ASSET_ADDRESS function but is not part of the rToken suite.", "html_url": "https://blog.openzeppelin.com/radiant#loss-of-rdnt-rewards-when-compounding", "labels": ["OpenZeppelin"]}, {"title": "Missing PriceProvider Oracle Updates", "body": "The PriceProvider contract is responsible for providing pricing data to multiple contracts of the protocol. It uses either pool data or one of the following oracles: ChainlinkV3Adapter, UniV3TwapOracle, UniV2TwapOracle.  In the case where UniV2TwapOracle is used, the update function must be frequently triggered to correctly track TWAP data, otherwise the returned price will be stale. This is done in the LockZap contract and in multiple functions of the MultiFeeDistribution contract.  The following contracts are using PriceProvider but are missing oracle updates:  RadiantOFT  Compounder  EligibilityDataProvider  It is recommended to always trigger the update function before using PriceProvider to query price data.  Update: Resolved in pull request #235 at commits 6d1516f, c654e43 and 4467c8d.", "html_url": "https://blog.openzeppelin.com/radiant#missing-priceprovider-oracle-updates", "labels": ["OpenZeppelin"]}, {"title": "Use of Deprecated Chainlink Function", "body": "The contracts BaseOracle and PriceProvider are using Chainlinks deprecated latestAnswer function to retrieve the price of ETH. Although latestAnswer returns the price of the asset, it is not possible to check if the data is fresh.  The following instances of using latestAnswer were identified:  latestAnswer in BaseOracle.sol  getTokenPriceUsd and getLpTokenPriceUsd in PriceProvider.sol  Consider replacing calls to latestAnswer with Chainlink's latestRoundData function, and adding checks on the returned data to ensure the price value is positive, is not stale, and that the round is complete.  Update: Resolved in pull request #220 at commit 1612d75. Calls to the deprecated latestAnswer function have been replaced with calls to latestRoundData. Additionally, transactions will be reverted if reported prices are older than a day, non-positive, or if the round is not complete.", "html_url": "https://blog.openzeppelin.com/radiant#use-of-deprecated-chainlink-function", "labels": ["OpenZeppelin"]}, {"title": "Incomplete Validation of Chainlink Price Data", "body": "ChainlinkV3Adapter and  WSTETHOracle contracts are using Chainlinks  latestRoundData function, but are not fully validating the returned data. The returned price value (  The following instances of missing security checks were identified:  latestAnswerof ChainlinkV3Adapter contract.  latestAnswerInEth of ChainlinkV3Adapter contract.  latestAnswer of WSTETHOracle contract.  In each case, consider adding security checks on the returned data with proper revert messages if the price is stale or if the round is incomplete.  Update: Resolved in pull request #221 at commits 0f5c958, 7ebf11a, a6c51b7, 0dc3ddf and cff685f. Prices retrieved from ChainlinkV3Adapter will revert if they are non-positive, older than a day, or from an incomplete round.", "html_url": "https://blog.openzeppelin.com/radiant#incomplete-validation-of-chainlink-price-data", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Reward Updates for Scheduled Emissions", "body": "rewardsPerSecond or change the  emission schedule. Usage of emission schedules requires a frequent check on the current rewards per second value against the schedule to determine when emissions should be adjusted. This logic has been implemented in the  setScheduledRewardsPerSecond function that is triggered by  _updateEmissions.  addPool and  claim, but not in  _handleActionAfterForToken or  afterLockUpdate. The latter two functions both call the  Consider calling _updateEmissions whenever rewards need to be recalculated, to ensure that the rewardsPerSecond value tracks the current scheduled emission rate as closely as possible.  Update: Acknowledged, not resolved. The Radiant team stated:  Calling _updateEmissions on every rToken / dToken transfer would be very gas intensive and would render the product unusable on certain chains. In our opinion, the resulting reward inaccuracy is worth the gas savings on this heavily used function.", "html_url": "https://blog.openzeppelin.com/radiant#incorrect-reward-updates-for-scheduled-emissions", "labels": ["OpenZeppelin"]}, {"title": "Possible Denial-of-Service for Compounding", "body": "claimCompound function allows compounding accrued rewards from the  claiming them,  converting them to the base token, and finally zapping them into locked LP tokens via  LockZap. The logic for swapping rewards to the base token has been implemented in  _claimAndSwapToBase by approving  uniRouter to spend an amount of tokens and then executing  swapExactTokensForTokens on Uniswap's router.  try-catch block, it is possible that the swap reverts but the transaction succeeds, so long as the total received base token meets the slippage requirement. This leads to a scenario where the token has been correctly approved to be spent via  safeApprove requires either the new allowance to be reset to  uniRouter if any of the swaps revert since there will be an unspent allowance. This will lead to a denial-of-service situation for the  Consider using the SafeERC20 forceApprove function instead of safeApprove.  Update: Resolved in pull request #184 at commit d72012f.", "html_url": "https://blog.openzeppelin.com/radiant#possible-denial-of-service-for-compounding", "labels": ["OpenZeppelin"]}, {"title": "Lack of Event Emission", "body": "The following functions do not emit relevant events after executing sensitive actions:  setMinStakeAmount, setBounties and addAddressToWL in BountyManager.sol  setBountyManager, addRewardConverter, setLockTypeInfo, setAddresses, setLPToken and addReward in MultiFeeDistribution.sol  setOracle, setPoolHelper, setAggregator and setUsePool in PriceProvider.sol  setFallback and enableFallback in BaseOracle.sol  setPeriod, setConsultLeniency and setAllowStaleConsults in UniV2TwapOracle.sol  increaseObservationCardinality, setTWAPLookbackSec and toggleTokenForPricing in UniV3TwapOracle.sol  setAdmin and addReward in MiddleFeeDistribution.sol  setBountyManager, setCompoundFee and setSlippageLimit in Compounder.sol  setOnwardIncentives, setBountyManager, setEligibilityEnabled, batchUpdateAllocPoint, setLeverager, setEndingTimeUpdateCadance and registerRewardDeposit in ChefIncentivesController.sol  setPriceProvider, setMfd and setPoolHelper in LockZap.sol  setLiquidityZap and setLockZap in UniswapPoolHelper.sol  Consider emitting events after sensitive changes take place to facilitate tracking and to notify off-chain clients following the contracts' activity.  Update: Resolved in pull request #227 at commits 53348f6 and ed9cabf.", "html_url": "https://blog.openzeppelin.com/radiant#lack-of-event-emission", "labels": ["OpenZeppelin"]}, {"title": "Uniswap Pool Initialization Fails if Pool Exists", "body": "UniswapPoolHelper and  BalancerPoolHelper contracts both implement an  initializePool function that is responsible for creating a trading pair via  IUniswapV2PairFactory or  IWeightedPoolFactory, respectively. However, in the former case, Uniswap's  createPair function will revert if a pair has already been created for the given tokens.  During the deployment process on a new chain, an attacker may create a Uniswap trading pair that matches the same pair Radiant intends to create before this initializePool function is called. This will cause the function to always revert from that point onward. This would require Radiant to upgrade the UniswapPoolHelper contract to resolve this issue.  Consider always checking if the desired Uniswap pool already exists before attempting to create it.  Update: Acknowledged, not resolved. The Radiant team stated:  As this issue only affects deployments on new chains, we will tackle this minor upgrade once (and if) it does actually end up occurring.  Low Severity", "html_url": "https://blog.openzeppelin.com/radiant#uniswap-pool-initialization-fails-if-pool-exists", "labels": ["OpenZeppelin"]}, {"title": "Lack of gap Variable in Base Contract", "body": "The BaseOracle contract is inherited by several other contracts, but does not declare its own __gap variable. Gap variables provide a standard approach to reserve storage slots in base contracts, so that new variables can be safely added while avoiding collisions with the storage used by child contracts.  Consider adding storage gaps to inherited contracts by using gap variables to avoid future storage clashes.  Update: Resolved in pull request #246 at commit 45833b7.", "html_url": "https://blog.openzeppelin.com/radiant#lack-of-gap-variable-in-base-contract", "labels": ["OpenZeppelin"]}, {"title": "Duplicated Code", "body": "There are instances of duplicated code within the codebase, which can lead to issues later on in the development lifecycle. Errors can inadvertently be introduced when functionality changes are not replicated across all instances of code that should be identical. Some examples are:  Functions allowing the owner to recover stray ERC-20 tokens (recoverERC20) can be found with different implementations within the MiddleFeeDistribution, MultiFeeDistribution and ChefIncentivesController, and BountyManager contracts. All implementations are similar but only the first two emit a Recovered event.  Internal functions to safely transfer ETH into a certain address (_safeTransferETH) are replicated on both the Leverager and StargateBorrow contracts.  The loop and loopETH functions in the Leverager contract implement identical logic for updating a token's approved allowance for the lendingPool and treasury.  When withdrawing unvested RDNT tokens, return values from _penaltyInfo are ignored and then amounts after the penalty are recalculated. Consider using the amount, penaltyAmount and burnAmount return values directly to determine if the earned amount from this lock is enough to cover the withdrawal instead of recalculating the values. Duplicating code like this may become error-prone as seen on issue M-01  The wethToZap and wethToZapEstimation functions in the Leverager contract use an identical code block for computing wethAmount.  In the ChefIncentivesController contract, there are multiple instances where accrued rewards since the last update are being calculated. Consider extracting these calculations into a separate function so it can be reused across the contract instead of replicating the same logic.  In the Compounder contract, the selfEligibleCompound function implements a special case of the userEligibleForCompound function where _user = msg.sender. Consider unifying the logic in an internal function that can be called by both public functions instead.  The slippageLimit validation within the Compounder contract is duplicated in the constructor and in setSlippageLimit.  When adding liquidity within LiquidityZap, it performs the optimal token amount calculation directly instead of leveraging the existing public quote function.  Consider leveraging the DustRefunder contract within LiquidityZap to avoid duplicating logic to refund token leftovers after providing liquidity.  When calculating the LP token price via getLpPrice in UniswapPoolHelper, consider leveraging the existing getReserves function in order to retrieve the pool reserves and total supply instead of duplicating its logic.  When calling ltv, the asset configuration is queried directly from the lending pool. Consider making the existing getConfiguration function public so that it can be reused for this query.  Instead of duplicating code, consider extracting it into a shared function or a helper library when applicable.  Update: Resolved in pull request #230 at commits 6c94f65, f946b0c, 57c2ee1 and 22cd008.", "html_url": "https://blog.openzeppelin.com/radiant#duplicated-code", "labels": ["OpenZeppelin"]}, {"title": "Missing Error Message in require Statement", "body": "The require statement on line 1172 of MultiFeeDistribution.sol lacks an error message.  Consider including specific, informative error messages in require statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied.  Update: Resolved in pull request #224 at commits d14d322 and e869cd9.", "html_url": "https://blog.openzeppelin.com/radiant#missing-error-message-in-require-statement", "labels": ["OpenZeppelin"]}, {"title": "Missing or Incorrect Docstrings", "body": "There are several instances in the codebase where NatSpec comments are either absent or incorrect:  In EligibilityDataProvider.sol:  The internal _lockedUsdValue function retrieves the USD value for the LP token but the docstring states that the reported value is in ETH.  In wstethOracle.sol:  The function latestAnswer returns the price for wstETH/USD instead of wstETH/ETH as the comments suggest.  In MultiFeeDistribution.sol:  Line 143 is a stray comment that is not associated with any code.  The initialize function only has @param tags for 4 out of 10 input parameters and has a @dev comment that refers to it as being a constructor instead of an initializer.  The docstring for setLockTypeInfo says the function adds a new reward token, but the function actually sets the lock periods and corresponding multipliers. The @notice documentation for setLockTypeInfo is a copy from the addReward function's docstring.  There is a section divider named \"View functions\", but non-view setter functions are mixed with getter functions in this section.  Documentation associated with the totalBalance function states that it returns the total balance of an account, including earned tokens. This is not the case when the staking token is the LP token instead of the RDNT token.  The earnedBalances @dev comment states that earned balances can be immediately withdrawn for a 50% penalty. This is not the case since the penalty factor is implemented as a function of time, starting at 90% and finishing at 25% right before vesting is complete.  The _notifyUnseenReward function's documentation states that it is meant for rewards other than the staking token, which in this case is the LP token. However, the function only checks if the token argument is the RDNT token.  All references to burn and burnAmount are not valid. Rather than being burnt, the \"burnt\" share of early-exit penalty tokens is sent to the starfleetTreasury contract.  The docstring for ieeWithdrawableBalances states that the function \"returns withdrawable balances at exact unlock time\", but only a single balance will ever be returned from this function because it stops iterating once it finds a matching unlockTime. Consider renaming the function to ieeWithdrawableBalance and updating the corresponding documentation.  In MiddleFeeDistribution.sol:  Missing @param _operationExpenses and @param _operationExpenseRatio for the setOperationExpenses function  Missing @param _configurator for the setAdmin function  Missing @param _rewardsToken for the addReward function  Missing @param _rewardTokens for the forwardReward function  Missing @return for the getRdntTokenAddress function  Missing @return for the getMultiFeeDistributionAddress function  Missing @param asset and @param lpReward for the emitNewTransferAdded function  Missing @param tokenAddress and @param tokenAmount for the recoverERC20 function  Incorrect @notice comment for the recoverERC20 function  The forwardReward function docstring is a copy of the recoverERC20 function docstring, which is misleading because it does forward tokens to the MultiFeeDistribution contract, but not LP rewards such as BAL as indicated.  In ChefIncentivesController.sol:  The @title docstring is a copy of the @title from the UniV3TwapOracle contract.  The docstring for the internal _mint function states that it \"can be called by owner or leverager contract\". This appears to be copied from the setEligibilityExempt function docstring.  The emissionSchedule array documentation states that block number will be used to determine which schedule is the current one, but in reality it uses block.timestamp instead, so offsets refer to seconds not blocks.  In RadiantOFT.sol:  The @notice comment for the _send function incorrectly describes the return value.  In Leverager.sol:  Missing @param _cic for the constructor function  Missing @return for the wethToZapEstimation function  Missing @return for the wethToZap function  Missing @return for the requiredLocked function  In StargateBorrow.sol:  Incorrect docstring for the borrow function.  Missing @return for the getXChainBorrowFeeAmount function.  Missing all @param documentation and @return for the quoteLayerZeroSwapFee function  In LockerList.sol:  Missing @return for the lockersCount function  Missing all @param documentation @return for the getUsers function  Missing @param user for the addToList function  Missing @param user for the removeFromList function  In BountyManager.sol:  Missing @param _eligibilityDataProvider and @param _compounder for the initialize function.  Incomplete @return documentation for the getMfdBounty function. It describes totalBounty but not issueBaseBounty.  Incomplete @return documentation for the getChefBounty function. It describes totalBounty but not issueBaseBounty.  The docstring for getAutoCompoundBounty states that MFDPlus.claimCompound is called and that MFDPlus is the incentivizer; in both cases MFDPlus should be Compounder.  Missing @return issueBaseBounty", "html_url": "https://blog.openzeppelin.com/radiant#missing-or-incorrect-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Use of Assert", "body": "Some instances were found across the codebase where an assert statement is used:  Line 63 in LockerList.sol  Line 256 in EligibilityDataProvider.sol  Line 218 in LiquidityZap.sol  A failed assertion will revert with a Panic exception in the EVM. According to the Solidity documentation, the assert statement should only be used to test for internal errors where an invariant is violated (i.e., it should be reserved to test for \"this should never happen\" states). Well-designed Solidity contracts should never generate a Panic, even when an input parameter is invalid.  Consider replacing all assert statements with an equivalent require or revert statement.  Update: Resolved in pull request #223 at commits 41ae45a and 7154ae9.", "html_url": "https://blog.openzeppelin.com/radiant#incorrect-use-of-assert", "labels": ["OpenZeppelin"]}, {"title": "Missing Slippage Protection for Direct Zapping", "body": "The LiquidityZap contract implements the zapETH and addLiquidityETHOnly functions which allow adding liquidity by directly providing ETH. The received ETH is wrapped into WETH tokens and then half of it is swapped for RDNT.  However, there is no slippage protection when swapping WETH for RDNT, making users of these functions vulnerable to sandwich attacks. An attacker may monitor the mempool and front-run zapETH and addLiquidityETHOnly transactions by buying a significant amount of RDNT tokens prior to a user's transaction and then selling them immediately afterward, profiting at the cost of the user.  Note that this contract is only used in the BSC deployment, so all references to ETH and WETH are technically BNB and WBNB. ETH terms have been used for convenience since both functions contain references to it in their names.  Consider adding slippage protection to zapETH and addLiquidityETHOnly functions to protect against sandwich attacks. The addLiquidityWETHOnly function is safe since it can only be executed by poolHelper.  Update: Resolved in pull request #264 at commit 523d4ab.", "html_url": "https://blog.openzeppelin.com/radiant#missing-slippage-protection-for-direct-zapping", "labels": ["OpenZeppelin"]}, {"title": "Invalid Reward Tokens Can Brick Reward Claiming", "body": "addReward function, or alternatively, the  addReward function.  These tokens are always assumed to be AToken instances or the RDNT token itself. However, if by mistake a different token was added, there is no validation to prevent it as long as it is not the zero address.  Adding an erroneous token will cause multiple parts of the protocol to revert, since this token will not conform to the IAToken interface and there will not be a proper response from the AaveOracle when trying to figure out its price. Furthermore, there is no way to remove a reward token from the list, forcing the team to issue an emergency upgrade in order to address the problem if it occurs.  Consider implementing logic to remove reward tokens from the list when they are no longer supported or when they are added by mistake.  Update: Resolved in pull request #248 at commits 6573a30, 16503ae, fe562e4 and 855cfa6. The Radiant team added a function that allows the removal of existing reward tokens if necessary.", "html_url": "https://blog.openzeppelin.com/radiant#invalid-reward-tokens-can-brick-reward-claiming", "labels": ["OpenZeppelin"]}, {"title": "Unchecked ERC-20 Return Value", "body": "ERC-20 token standard, many function calls return a  In the LockZap contract, the function zapAlternateAsset does not check the return value of the transferFrom call.  Consider adding a check on the return value of transferFrom in this instance. Alternatively, consider using the safeTransferFrom function from the OpenZeppelin library SafeERC20, which is already being imported by the LockZap contract. This library safely handles ERC-20 tokens that behave in different ways, and ensures that all calls revert on failure, regardless of whether the underlying token does.  Update: Resolved in pull request #244 at commit d30d1ab. The unchecked transferFrom function call was replaced with a call to safeTransferFrom.", "html_url": "https://blog.openzeppelin.com/radiant#unchecked-erc-20-return-value", "labels": ["OpenZeppelin"]}, {"title": "Assets With More Than 18 Decimals Not Supported for Zapping", "body": "The LockZap contract allows zapping any ERC-20 asset into staking via the zapAlternateAsset function by converting it to the base token (WETH or WBNB depending on the chain), adding liquidity, and then staking those LP tokens within the MultiFeeDistribution contract. In order to handle slippage, the expected amount of base token is calculated by assuming that the asset's decimals will be equal to or smaller than 18, which may not always be correct. Attempting to zap assets with more than 18 decimals will result in an underflow that will make the transaction revert.  In order to avoid unexpected reverts and be compatible with more asset types, consider refactoring the expectedEthAmount calculation in zapAlternateAsset to also support assets with more than 18 decimals.  Update: Resolved in pull request #191 at commit 95400d3.", "html_url": "https://blog.openzeppelin.com/radiant#assets-with-more-than-18-decimals-not-supported-for-zapping", "labels": ["OpenZeppelin"]}, {"title": "Users Can Burn Their Tokens Without Incentives", "body": "The RDNT token features an unrestricted burn function which allows anyone to voluntarily burn any token holdings without incentive.  While burning tokens is a necessary action for specific protocol flows, consider restricting who can call this function, in order to avoid accidental loss of user funds in the event that the function is called by mistake.  Update: Acknowledged, not resolved. The Radiant team stated:  We prefer to maintain a degree of flexibility here that will allow for potential future utility that is yet unforeseen.", "html_url": "https://blog.openzeppelin.com/radiant#users-can-burn-their-tokens-without-incentives", "labels": ["OpenZeppelin"]}, {"title": "Shadowed initialized Variable", "body": "The LiquidityZap contract implements the upgrade proxy pattern and uses the initialize function to set up storage variables. Additional initialization steps are done in the initLiquidityZap function which is responsible for setting up pool configuration. The contract uses a boolean variable named initialized in order to ensure that initLiquidityZap can be executed only once.  However, LiquidityZap's variable declaration of initialized shadows the initialized variable from the parent contract Initializable.  Although the code works as expected, this practice is error-prone and should be avoided. Consider renaming the LiquidityZap storage variable initialized to something different such asinitializedLiquidity, to ensure it does not shadow the other initialized variable from the Initializable contract.  Update: Resolved in pull request #172 at commits b0cd872 and b416eff.", "html_url": "https://blog.openzeppelin.com/radiant#shadowed-initialized-variable", "labels": ["OpenZeppelin"]}, {"title": "Duplicate Emission Schedules Are Allowed", "body": "When appending a new set of emission schedules, their starting offsets should be in ascending order to make sure they are activated correctly as time goes by.  However, when enforcing this ascending order, it is possible to schedule different emission rates with the same starting time offset. This will cause only the latest one in the list to be enforced when its starting timestamp is reached, ignoring all the other schedule items.  In order to avoid potential misconfiguration and unexpected results, consider reverting when attempting to set an emission schedule that contains duplicated start time offsets.  Update: Resolved in pull request #171 at commit 95fe10c. Before a new emission schedule can be added, it is required that its starting offset is unique and does not match any starting offset in the existing list of emission schedules.", "html_url": "https://blog.openzeppelin.com/radiant#duplicate-emission-schedules-are-allowed", "labels": ["OpenZeppelin"]}, {"title": "Locked ETH in Contracts", "body": "There are several instances in the codebase where ETH can be locked:  The receive function of LockZap.sol  The receive function of UniswapPoolHelper.sol  The receive function of StargateBorrow.sol  In order to avoid accidentally locking ETH on this contract, consider removing the first two instances, and restricting the third one in Stargateborrow so that only the WETH contract can send ETH.  Update: Resolved in pull request #214 at commit 750dcbf. ETH withdrawal functions were added to LockZap and StargateBorrow, protected by the onlyOwner modifier. In UniswapPoolHelper the receive function was removed since the Radiant team deemed it unnecessary.", "html_url": "https://blog.openzeppelin.com/radiant#locked-eth-in-contracts", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Truncation of Balancer LP Total Supply", "body": "The getReserves function in the BalancerPoolHelper contract returns the amounts of RDNT and WETH in the Balancer pool and the corresponding amount of LP tokens.  However, the lpTokenSupply value is divided by 1e18 before being returned, effectively removing all decimals from the value. This calculation is not done in the getReserves function of the UniswapPoolHelper contract.  Even though this lpTokenSupply value is never used within the codebase, consider removing the division by 1e18 in order to return the total supply of Balancer LP tokens with no precision loss.  Update: Resolved in pull request #215 at commit 23fbf42. The unused lpTokenSupply return value was removed from the getReserves function.", "html_url": "https://blog.openzeppelin.com/radiant#unnecessary-truncation-of-balancer-lp-total-supply", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary access control and incorrect mutability", "body": "The BalancerPoolHelper contract limits access to its getSwapFeePercentage function with the onlyOwner modifier. However, there is no reason to limit access to value, since it can be read directly from the pool contract. Additionally, this function does not change the contract's state, but is missing view function state mutability.  Consider removing the onlyOwner modifier from the getSwapFeePercentage function, and also adding view mutability to correctly reflect its behavior.  Update: Resolved in pull request #198 at commit d790662.", "html_url": "https://blog.openzeppelin.com/radiant#unnecessary-access-control-and-incorrect-mutability", "labels": ["OpenZeppelin"]}, {"title": "Commented-Out Code", "body": "Several contracts within the codebase include commented-out lines of code without giving developers enough context on why those lines have been discarded, thus providing them with little to no value at all. For instance:  Line 579 in ChefIncentivesController.sol  Lines 48, 147 and 796 in MultiFeeDistribution.sol  As the purpose of these lines is unclear and may confuse future developers and external contributors, consider removing them from the codebase. If they are to provide alternate implementation options, consider extracting them to a separate document where a deeper and more thorough explanation could be included.  Update: Resolved in pull request #245 at commit 100d94e. All instances of commented-out code were removed except one, where the Radiant team added an inline comment that explains the rationale for leaving that instance in place.", "html_url": "https://blog.openzeppelin.com/radiant#commented-out-code", "labels": ["OpenZeppelin"]}, {"title": "Unsafe ABI Encoding", "body": "It is common practice to use abi.encodeWithSignature or abi.encodeWithSelector to generate calldata for a low-level call. However, the first option is not typo-safe, and the second option is not type-safe. The result is that both of these methods are error-prone and should be considered unsafe.  Line 140 of BountyManager uses the unsafe encodeWithSignature ABI encoding.  Consider replacing all the occurrences of unsafe ABI encodings with abi.encodeCall, which checks whether the supplied values actually match the types expected by the called function, and also avoids errors caused by typos.  Update: Resolved in pull request #216 at commit ce21edd.", "html_url": "https://blog.openzeppelin.com/radiant#unsafe-abi-encoding", "labels": ["OpenZeppelin"]}, {"title": "Tokens May Get Stuck in Compounder Contract", "body": "claimCompound function allows compounding accrued rewards from the  claiming them,  converting them to the base token, and finally zapping them into locked LP tokens via  LockZap. The logic for swapping rewards to the base token has been implemented in  _claimAndSwapToBase by approving  uniRouter to spend amount of tokens and then executing  swapExactTokensForTokens on Uniswap's router.  Because the swap is inside a try-catch block, it is possible that the swap fails but the transaction succeeds (as long as the slippage requirement is satisfied), which leads to a scenario where tokens will get stuck in the Compounder contract without any withdrawal mechanism.  In order to avoid this scenario, consider allowing the swap transaction to revert by removing the try-catch block.  Update: Resolved in pull request #183 at commit 150782f. Rather than removing the try-catch block, the team decided to revert on the catch block with a custom SwapFailed error that reports the underlying asset address and the intended swap amount.", "html_url": "https://blog.openzeppelin.com/radiant#tokens-may-get-stuck-in-compounder-contract", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Use of Named Return Values", "body": "Throughout the codebase, most functions that return values use named return variables. However, there are several instances where functions use unnamed return values, such as:  The getBridgeFee function within the RadiantOFT contract  The first return value from the lockedBalances function within the MultiFeeDistribution contract  The lockersCount and getUsers functions within the LockerList library  For consistency, consider always using named return values.  Update: Resolved in pull request #196 at commit e6a9cde.", "html_url": "https://blog.openzeppelin.com/radiant#inconsistent-use-of-named-return-values", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Input Validation", "body": "The EligibilityDataProvider and Compounder contracts incorrectly validate input parameters used to set the values of storage variables priceToleranceRatio and slippageLimit:  EligibilityDataProvider's setPriceToleranceRatio function incorrectly implements validation of the _priceToleranceRatio parameter, which makes it possible to pass any value as a price tolerance ratio without triggering a revert.  Compounder's initialize and setSlippageLimit functions incorrectly implement validation of the _slippageLimit parameter, which makes it possible to pass any value as a slippage limit without triggering a revert.  In both cases, the intended behavior is to accept values between 8000 (80%) and 10000 (100%).  Consider updating the input validation logic to ensure that only values within the intended range are permitted.  Update: Resolved in pull request #195 at commit 82e419d and pull request #230 at commit 22cd008.", "html_url": "https://blog.openzeppelin.com/radiant#incorrect-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Amount Calculation When Providing Liquidity", "body": "When users zap their RDNT tokens from vesting, the optimal amount of base token necessary to provide liquidity is calculated via the pool helper quoteFromToken function, and then an extra 3% safety margin is added on top.  This is inconsistent with the _zap function's call to the same quoteFromToken function, where no extra safety margin is added.  Consider applying this extra safety margin consistently when calculating the amount of base tokens required to supply liquidity.  Update: Resolved in pull request #247 at commit 503383f. The Radiant team decided not to use an extra safety margin by using the already existing pool helper's quoteFromToken function directly.", "html_url": "https://blog.openzeppelin.com/radiant#inconsistent-amount-calculation-when-providing-liquidity", "labels": ["OpenZeppelin"]}, {"title": "RDNT Bridge Fee Is Being Overcharged", "body": "The new Radiant OFT v2 token allows cross-chain transfers via LayerZero. Such a transfer involves two types of fees: the native LayerZero fee and a bridging fee charged by the Radiant protocol.  certain number of decimals configured as token decimals minus a shared decimals value. In this specific case,  shared decimals are configured to be 8 and RDNT features  However, the getBridgeFee calculation does not truncate input amounts so in the extreme scenario where the minimum value of 1e10 is transferred, the final fee charged will be almost double what it would have been if the amount was truncated first. This effect becomes much less noticeable for larger transfer amounts.  Consider truncating the transfer _amount before calculating the bridge fee in order to not overcharge users.  Update: Resolved in pull request #217 at commit d59c6a1.", "html_url": "https://blog.openzeppelin.com/radiant#rdnt-bridge-fee-is-being-overcharged", "labels": ["OpenZeppelin"]}, {"title": "Use of Low Liquidity Source When Compounding on Arbitrum", "body": "User rewards can be compounded into locked LP tokens via the Compounder contract. They can do so themselves, or a hunter can claim a bounty for doing so on their behalf. When claiming an auto-compounding bounty, several swaps are made:  Each reward token is withdrawn for the underlying token and then swapped for the base token (WETH on Arbitrum and WBNB on BSC).  A percentage of the total base token is swapped for RDNT as a fee that will be split between the hunter and the bounty reserve.  Half of the remaining base token will be swapped for RDNT so that liquidity can be provided in the right proportion via zapOnBehalf.  In the case of Arbitrum, liquidity is provided on a Balancer pool. This means that the highest liquidity available for WETH and RDNT will be found on that Balancer pool. However, the second swap is performed in a Sushiswap pair, which has far lower liquidity since there is no incentive for users to provide liquidity there.  Consider enforcing consistency to always get the best liquidity possible by performing all swaps between the base token and RDNT on the pool where users lock their LP tokens.  Update: Acknowledged, not resolved. The Radiant team stated:  Seeing as we will be deploying on multiple chains, with varying configurations and combinations of locks, zaps and DEXes, we will not be making a change to the codebase at this time.", "html_url": "https://blog.openzeppelin.com/radiant#use-of-low-liquidity-source-when-compounding-on-arbitrum", "labels": ["OpenZeppelin"]}, {"title": "Use of Hard-Coded Values", "body": "The swapToWeth function in the BalancerPoolHelper contract contains multiple hard-coded addresses and pool ids that are too tightly coupled with the specific Arbitrum deployment.  Functions borrow and borrowETH are using fixed slippage set to 1%. Consider adding functionality to adjust slippage based on liquidity and market conditions.  The wethToZap function is using a fixed value of 6% as a margin for wrapping WETH.  Consider creating constants to store these values or assigning them dynamically upon deployment in order to avoid deployment issues on new chains.  Update: Resolved in pull request #231 at commits 74f00dc and c91894b.", "html_url": "https://blog.openzeppelin.com/radiant#use-of-hard-coded-values", "labels": ["OpenZeppelin"]}, {"title": "Uniswap V2 Oracle Does Not Scale Price", "body": "UniV2TwapOracle contract implements the  consult function, which determines the current RDNT price by calculating how many base tokens would be received when swapping one unit of RDNT. When  latestAnswerInEth of the parent contract  always be scaled to 18 decimals. Based on this expectation,  10 ** 10, which should result in the output having 8 decimals. If the quote token does not use 18 decimals, this will result in an incorrect price value, because the return value of  UniV3TwapOracle where the amount of received tokens is scaled to 18 decimals.  Consider scaling the price returned by the consult function to 18 decimals.  Update: Acknowledged, not resolved. The Radiant team stated:  We don't ever intend to utilize any token outside of RDNT in this context (and we don't intend to utilize any version of the RDNT token that doesn't have 18 decimal places).", "html_url": "https://blog.openzeppelin.com/radiant#uniswap-v2-oracle-does-not-scale-price", "labels": ["OpenZeppelin"]}, {"title": "Misleading Naming for Variables and Functions", "body": "Across the codebase, multiple instances of misleading variable and function names were identified. For example:  In the MultiFeeDistribution contract, the mint function does not mint RDNT tokens. The mint function assumes that the rewards being added have already been minted and are available to be distributed by the MFD, which may not be true.  The internal _withdrawExpiredLocksFor function features a boolean isRelockAction parameter which is described as an indicator to determine whether the current staking operation is a relock. However, it will not relock those tokens if it is set to true. Additionally, the alternative withdrawExpiredLocksWithOptions function describes the same parameter as _ignoreRelock, which is the opposite meaning for the same value.  The setFee function within the RadiantOFT contract accepts an input parameter called _fee which will be used to update the state variable feeRatio. If this _fee value is larger than a certain threshold, it reverts with an error message specifying \"Invalid ratio\" and if it does not, it successfully emits the FeeUpdated event. Consider renaming setFee to setFeeRatio, _fee to _feeRatio, and FeeUpdated to FeeRatioUpdated.  The getBestBounty function in the BountyManager contract is responsible for finding and calculating the bounty that can be received for the specified user. It can be executed either by passing an _actionTypeIndex value that corresponds to one of the bounty types (MFD, CIC or Compounder) or by passing the value of 0 which should iterate over all bounty types and find the best available bounty for the user. The logic of the function does not implement that behavior. It iterates over the MFD, CIC and Compounder bounties, until finding one that offers any bounty, not until finding the best one. Consider changing the function name to getAvailableBounty.  In the MultiFeeDistribution contract, the earnedBalances function returns total and unlocked earnings balances. The total variable name is confusing since it seems to account for both vested and already unlocked amounts. However, total in reality means the total amount in vesting (before applying penalties), excluding any already unlocked amounts.  The claimFromConverter function within the MultiFeeDistribution contract is called by the Compounder, but the docstrings indicate that rewards are claimed by and transferred to the \"converter\", not the \"compounder\". Consider renaming this function to claimByCompounder and updating the associated documentation.  Consider providing explicit and consistent naming for both variables and functions all across the project in order to avoid confusion and improve readability.  Update: Resolved in pull request #232 at commits 666d900, dcaa6cd and dc0934b.", "html_url": "https://blog.openzeppelin.com/radiant#misleading-naming-for-variables-and-functions", "labels": ["OpenZeppelin"]}, {"title": "LockZap Does Not Correctly Enforce Maximum Borrowing Power", "body": "When zapping assets into locked LP tokens, users need to provide both RDNT and the base token (WBNB or WETH) in equal value in order to provide liquidity. Among other options, users can provide the base token themselves by approving the LockZap contract to spend them, or they can borrow it from the lending pool against their deposited collateral.  When users decide to borrow against their collateral, there is a check in place to prevent users from borrowing amounts larger than their maximum borrowing power, in order to ensure they maintain an overcollateralized position. This check asks the lending pool how much ETH this user can borrow and compares it with the requested amount, scaled down to 8 decimals.  The original getUserAccountData function from Aave V2 documentation states that the returned value availableBorrowsETH specifies an ETH amount with 18 decimals. However, the modified Radiant version of the lending pool returns all values as USD-denominated amounts with 8 decimals. This comparison is flawed since it is comparing USD amounts with ETH amounts. The end result is that at current prices, this condition is always satisfied since ETH amounts are usually lower than the maximum borrowing power expressed in USD amounts, even when trying to borrow beyond your limit.  Consider converting the amount in ETH to USD by querying the ethOracle in order to correctly enforce that borrow amounts are lower than the actual borrowing power. Even if the lending pool is expected to revert when a user tries to borrow beyond their limit, external code should not be relied on to prevent actions that may lead to insolvency.  Update: Resolved in pull request #192 at commit db69559. The ethOracle Chainlink ETH/USD price feed is now queried to get the requested borrow amount in USD. However, the deprecated latestAnswer function is used to perform the query.", "html_url": "https://blog.openzeppelin.com/radiant#lockzap-does-not-correctly-enforce-maximum-borrowing-power", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Value Used for Slippage Calculations", "body": "The LockZap contract implements functionality to zap assets into liquidity and then stake the received LP tokens in the MultiFeeDistribution contract. In order to handle slippage and prevent sandwich attacks, LockZap calculates the equivalent value of the provided tokens in the base token (WETH or WBNB) and then does the same for the received LP tokens in _calcSlippage. After that it makes sure the required ACCEPTABLE_RATIO is satisfied.  However, it assumes that the entire token amounts passed to zapTokens have been used to add liquidity, which is not always true. This may lead to unexpected reverts due to acceptable slippage not being met when the value of the passed asset is higher than the actual value used when providing liquidity.  Consider calculating the exact amount that was used for adding liquidity by retrieving the token balances before and after adding liquidity through the zapTokens function.  Update: Resolved in pull request #178 at commits 39ff88b, 7d447a4 and af19454. In both the _zap and zapAlternateAsset functions, the difference in the WETH or WBNB amount held by the LockZap contract before and after zapping is now used as the input to the _calcSlippage function.", "html_url": "https://blog.openzeppelin.com/radiant#incorrect-value-used-for-slippage-calculations", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Fee Returned in Case Compounding Is Not Being Executed", "body": "claimCompound of the  _execute set to  selfCompound function always sets  However, when claimCompound is called directly by a user on behalf of themselves with _execute set to false, it always returns the auto-compound fee instead of returning 0 for this self-compound operation.  It is recommended to always return a fee value of 0 for self-compounding in claimCompound. In addition, consider removing the fee returned by the selfCompound function to make it clear that there is no fee charged when performing it.  Update: Resolved in pull request #218 at commit e409b80.", "html_url": "https://blog.openzeppelin.com/radiant#incorrect-fee-returned-in-case-compounding-is-not-being-executed", "labels": ["OpenZeppelin"]}, {"title": "Flawed lastEligibleTime Function", "body": "The lastEligibleTime function should return a value pointing to a future date, since it represents the point in time at which a user's eligibility status might change, always assuming users are currently eligible.  However, if a given user is not currently eligible, this function will still loop through their locks and incorrectly return the nearest unlock time, even when the amount locked does not cover the minimum requirement for eligibility.  Consider handling the scenario where a given user is not eligible differently or, alternatively, provide some more documentation on why this behavior is expected.  Update: Resolved in pull request #226 at commit 80324eb.", "html_url": "https://blog.openzeppelin.com/radiant#flawed-lasteligibletime-function", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Bounty Returned When BountyManager Reserve Is Low", "body": "executeBounty function of the  bounty to the hunter that claims it. At the end of its execution,  _sendBounty function to transfer the  when the reserve does not hold enough funds. In that case, the logic of  returns that value from the function. Regardless of the actual amount paid to the hunter,  Consider modifying executeBounty to return the exact amount paid to the hunter, even when the reserve is not large enough. To ensure an adequate balance at all times in the BountyManager reserve, consider implementing logic that reverts the executeBounty transaction when there are insufficient funds to pay a bounty. Additionally, consider using OpenZeppelin Defender to detect this event and subsequently pause the contract or fill the reserve.  Update: Resolved in pull request #222 at commit 1a05a30. The executeBounty function no longer assumes that the reserve balance was sufficient to pay the entire bounty, and now returns the actual bounty amount transferred.", "html_url": "https://blog.openzeppelin.com/radiant#incorrect-bounty-returned-when-bountymanager-reserve-is-low", "labels": ["OpenZeppelin"]}, {"title": "Logic Contracts Initialization Is Allowed", "body": "The Radiant protocol implements multiple upgradeable contracts, each having an initializer function meant to be called by their respective proxy. However, nothing prevents users from directly calling the initialize function on any of the implementation contracts. In this case, the state of the given implementation would be initialized to some meaningful value.  Leaving an implementation contract uninitialized is generally an insecure pattern to follow.  For each initializable contract, consider adding a constructor that calls the _disableInitializers function to ensure that the implementation contracts cannot be initialized by a third party.  Update: Resolved in pull request #233 at commit b00066b.", "html_url": "https://blog.openzeppelin.com/radiant#logic-contracts-initialization-is-allowed", "labels": ["OpenZeppelin"]}, {"title": "Lack of Input Validation", "body": "Throughout the codebase, there are several functions that lack input validation. In particular:  The owner of the MultiFeeDistribution contract can arbitrarily update the value for the rewardsLookback variable, while it is enforced to be non-zero during initialization.  The owner of the Leverager contract can call setFeePercent to update the value of feePercent to 10000 (100%). Consider adding a check that will enforce setting the feePercent to a reasonable value.  Consider enforcing that borrowRatio is larger than 0 apart from being lower than 100% in order to avoid dividing by zero. Note that the functions loopETH and loopETHFromBorrow should also follow the same recommendation.  The setXChainBorrowFeePercent function in the StargateBorrow contract allows owner to update the value of xChainBorrowFeePercent to 10000 (100%). Consider adding a check that will enforce setting the xChainBorrowFeePercent to a reasonable value.  The value of ACCEPTABLE_RATIO in the LockZap contract that is responsible for handling slippage can be set to any value between 0 and 10000 via setAcceptableRatio. Consider adding a check that will enforce setting the ACCEPTABLE_RATIO to a reasonable minimum value as it happens in other parts of the codebase. Additionally, the initialize function does not enforce any checks on this value.  The value of _ethLPRatio accepted by the LockZap contract initializer function can be 10000 (100%). Consider modifying the check so that a value of 10000 is rejected as invalid.  All functions that handle adding liquidity into the pool within the LiquidityZap contract enforce that LP tokens cannot be accidentally burnt by checking that the recipient to is not the zero address, except the standardAdd function. Additionally, this function is the only one that does not check if either of the input amounts is zero. Consider enforcing consistency on input validations including the standardAdd function to prevent accidental user loss of funds.  The setFee function in the RadiantOFT contract allows setting the bridge fee equal to 10000 (100%). Consider adding a reasonable limit on the maximum bridge fee.  The setTWAPLookbackSec and initialize functions in the UniV3TwapOracle both set the value of lookbackSecs that is used as a TWAP lookback period. Consider adding a check to these functions that will enforce a minimal value of lookback seconds.  Consider adding a check that _actionTypeIndex is less than or equal to bountyCount in order to avoid an out of bounds error when calling the getBestBounty function.  Consider implementing the suggested validations in order to prevent unexpected behaviour that may lead to potential attacks on the protocol.  Update: Resolved in pull request #207 at commits a2de2ee, 400b1b1, bb4b163, ca7ce42, 3eac7d6, 20c279c, 4e23cff and 2ce50e6.", "html_url": "https://blog.openzeppelin.com/radiant#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Event Emission", "body": "add a  userlist, it will not be re-added since there is a  check that the address is not already inserted. However, the  emitted regardless of whether the user is already on the list.  To avoid hindering the task of off-chain services by emitting misleading information, consider only emitting the LockerAdded event when adding an address that is not already inserted in the user list.  Update: Resolved in pull request #202 at commit 2d7307a.", "html_url": "https://blog.openzeppelin.com/radiant#incorrect-event-emission", "labels": ["OpenZeppelin"]}, {"title": "Incorrect or Inconsistent Error Types", "body": "Throughout the codebase, some instances were found where the custom error used to reflect the reason behind a revert was incorrect or inconsistent with the rest of the codebase. Some examples include:  The addReward function in the MultiFeeDistribution contract is used to add reward tokens other than RDNT to the system. It contains a check that ensures the _rewardToken input address is not zero, but instead of reverting with the AddressZero error it uses the InvalidBurn error.  The _stake function in the MultiFeeDistribution contract reverts with InvalidAmount if the provided typeIndex is beyond the size of the lock types array. Consider using the more appropriate InvalidType error.  The setLPToken function in the MultiFeeDistribution contract correctly reverts with AddressZero when trying to set the staking token value to the zero address. However, if this value was already set, it is also reverting with AddressZero. Consider leveraging the AlreadyAdded error or creating a more specific one such as AlreadySet in order to be more informative.  The withdraw function in the MultiFeeDistribution contract reverts with InvalidAmount when trying to withdraw a zero amount. Consider using the more explicit AmountZero error type instead.  When initializing the BountyManager contract, if _hunterShare is larger than 10000 it will revert with an InvalidNumber custom error. However, when using the setHunterShare function to update the hunterShare variable, it reverts with Override under the same conditions.  Consider updating the aforementioned instances in order to make reported errors more accurate and explicit.  Update: Resolved in pull request #209 at commit b61bfe1.", "html_url": "https://blog.openzeppelin.com/radiant#incorrect-or-inconsistent-error-types", "labels": ["OpenZeppelin"]}, {"title": "Configuration Changes May Negatively Impact Users", "body": "Within the codebase there are several instances of configuration update actions that may have a negative impact on a user's transaction if the configuration change happens just before the user's transaction:  The setLockTypeInfo function in the MultiFeeDistribution contract can be used by the owner to set or update the lock periods and their multipliers. Any user who wants to stake or set their default relock type is required to specify an index for the lock period and its multiplier. In the case where the owner's transaction updating lock periods and multipliers is included before the user's call to stake or setDefaultRelockTypeIndex is confirmed, this user will end up potentially committing to an unknown locking period and reward multiplier, different from their expected values.  The Leverager contract charges a fee to users that want to leverage their positions. The feePercent can be set at any time by the owner using the setFeePercent function. That leads to a scenario where the owner's transaction to update this fee may be confirmed before the user's looping transaction, resulting in the user being charged a different fee than expected.  The Compounder contract charges a fee to users that want to compound their rewards into locked liquidity. The compoundFee can be set at any time by the owner using the setCompoundFee function. If the owner's update transaction gets confirmed before the user's compound transaction, they will be charged a different fee than expected.  The setXChainBorrowFeePercent function of the StargateBorrow contract allows updating the cross-chain fee that will be charged when users want to receive funds on another chain. If the owner's transaction to update this fee is included before the user's borrow transaction, they will end up being charged a different fee than expected.  In these cases, consider allowing users to specify the expected values of the relevant configuration state as additional function parameters so that their transaction will revert when the configuration does not match the expected state.  Update: Acknowledged, not resolved. The Radiant team stated:  During the period of a protocol variable change, the front end can be frozen until the new values are active and displayed. In our opinion, the proposed changes are not worth the likely UX decline.", "html_url": "https://blog.openzeppelin.com/radiant#configuration-changes-may-negatively-impact-users", "labels": ["OpenZeppelin"]}, {"title": "Rewards Can Be Emitted to the MiddleFeeDistribution And MultiFeeDistribution Contracts", "body": "handleActionAfter function that is used by  _transfer,  mint and  burn functions) and  mint and  burn functions) in order to track any changes in user balances after performing those actions. It does not  track the balances of  requalifyFor,  stake,  withdrawExpiredLocksFor, or  withdrawExpiredLocksForWithOptions functions are called with the address of either the  Consider enforcing consistency and preventing any action intended only for protocol users from being performed on behalf of the MiddleFeeDistribution and MultiFeeDistribution contracts.  Update: Acknowledged, not resolved. The Radiant team stated:  It is intended that these functions can be executed on behalf of any valid EVM addresses. We have reviewed the exclusion of the MFD and MiddleFeeDistribution contracts from the rewards and believe that functionality is sound.", "html_url": "https://blog.openzeppelin.com/radiant#rewards-can-be-emitted-to-the-middlefeedistribution-and-multifeedistribution-contracts", "labels": ["OpenZeppelin"]}, {"title": "Missing Zero Address Checks", "body": "Multiple contracts are missing zero address checks for setting storage variables. Accidentally setting an address variable to address zero might result in an incorrect configuration of the protocol. For instance, the following parameters are not checked:  _multiFeeDistribution in the initialize function of the MiddleFeeDistribution contract.  _lpToken in the setLPToken function of the EligibilityDataProvider contract.  _rdntAddr, _wethAddr, _routerAddr and _liquidityZap in the initialize function of the UniswapPoolHelper contract.  _poolFactory in the initialize function of the BalancerPoolHelper contract.  _stETHUSDOracle and _stEthPerWstETHOracle in the initialize function of the WSTETHOracle contract.  Consider adding zero address checks to the listed parameters in order to avoid accidental misconfigurations.  Update: Resolved in pull request #203 at commit 37ea95a.", "html_url": "https://blog.openzeppelin.com/radiant#missing-zero-address-checks", "labels": ["OpenZeppelin"]}, {"title": "Lack of Access Control on Pool Helper swapToWeth Functions", "body": "UniswapPoolHelper and  BalancerPoolHelper implement a  LockZap contract and unlike the related pool helper functions  zapWETH and  zapToken, it can be called by anyone.  An attacker may steal any token balance held by the UniswapPoolHelper or BalancerPoolHelper contracts by calling swapToWeth, which will swap the specified _inToken to the base token.  Consider adding a check to the swapToWeth function of UniswapPoolHelper and BalancerPoolHelper to make sure they can only be called from the LockZap contract.  Update: Resolved in pull request #173 at commits 4ba1fa9 and 6f5fd15.", "html_url": "https://blog.openzeppelin.com/radiant#lack-of-access-control-on-pool-helper-swaptoweth-functions", "labels": ["OpenZeppelin"]}, {"title": "Lack of Access Control for LiquidityZap Contract Initialization", "body": "LiquidityZap contract allows any user to initialize its configuration through the  initLiquidityZap function. During protocol deployment, an attacker can execute  initializePool function. As a result, this would require the Radiant team to deploy a new instance of  Consider limiting access to initLiquidityZap by ensuring only the pool helper can call it, or by adding the onlyOwner modifier and calling it externally rather than from the pool helper's initializePool function.  Update: Resolved in pull request #200 at commit 6ea6553. Access to the initLiquidityZap function is now restricted to the contract's owner, and the function is no longer invoked from initializePool.", "html_url": "https://blog.openzeppelin.com/radiant#lack-of-access-control-for-liquidityzap-contract-initialization", "labels": ["OpenZeppelin"]}, {"title": "Usage of Insecure Approval Functions", "body": "Throughout the codebase there are multiple instances of insecure approvals that may lead to security issues:  Function swapToWeth is used to convert a variety of source assets into the base token (WBNB in this case) and then provide both RDNT and the base token as liquidity to the pool. This functionality is expected to process tokens such as USDC, DAI, USDT or WBTC. It uses SafeERC20s safeIncreaseAllowance function which cannot handle non-standard ERC-20 token implementations such as USDT on Ethereum Mainnet, because USDT requires the allowance to be reset to zero before setting it to any positive value. If the allowance is not already zero when attempting to change the existing approval to a non-zero value, the USDT approve function will revert.  Compounder.sol in lines 154, 172 and 274 uses the deprecated safeApprove function.  Leverager.sol in lines 191, 194, 233, 236, 282, 285 and 386 uses the deprecated safeApprove function.  StargateBorrow.sol in lines 204-205 uses the deprecated safeApprove function.  LockZap.sol in lines 244, 320 and 333 uses the deprecated safeApprove function.  BalancerPoolHelper.sol in lines 113-114 uses the deprecated safeApprove function.  UniswapPoolHelper.sol in lines 60-61 uses the deprecated safeApprove function.  Consider using the SafeERC20 contract's new forceApprove function instead in order to avoid running into issues when dealing with non-standard ERC-20 implementations.  Update: Resolved in pull request #228 at commits 299d6d5, 25a9377 and 06f49a7.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/radiant#usage-of-insecure-approval-functions", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent SPDX License Identifiers", "body": "Throughout the codebase, the MIT SPDX license identifier is used, except for these instances:  wstethOracle.sol does not contain an SPDX license identifier.  PriceProvider.sol uses the agpl-3.0 license instead of MIT.  LiquidityZap.sol uses the MIT license, but the file contains documentation that indicates the original code was licensed under GPL.  Consider working with a legal team with knowledge about software licensing to resolve these inconsistencies to avoid potential legal issues regarding copyright.  Update: Resolved in pull request #261 at commit df9c768.", "html_url": "https://blog.openzeppelin.com/radiant#inconsistent-spdx-license-identifiers", "labels": ["OpenZeppelin"]}, {"title": "Using uint Instead of uint256", "body": "Within MultiFeeDistribution.sol, uint is used instead of uint256.  In favor of explicitness, consider replacing all instances of uint with uint256.  Update: Resolved in pull request #239 at commit 9488446.", "html_url": "https://blog.openzeppelin.com/radiant#using-uint-instead-of-uint256", "labels": ["OpenZeppelin"]}, {"title": "TODO Comments in the Code", "body": "The following instances of TODO comments were found in the codebase:  The TODO comment on line 847 in ChefIncentivesController.sol  The TODO comment on line 1070 in MultiFeeDistribution.sol  During development, having well-described TODO comments will make the process of tracking and resolving them easier. Without this information, these comments might age and important information for the security of the system might be forgotten by the time it is released to production.  Consider removing all instances of TODO comments and instead tracking them in the issues backlog. Alternatively, consider linking each inline TODO to a corresponding backlog issue.  Update: Resolved in pull request #263 at commit a5e28ad.", "html_url": "https://blog.openzeppelin.com/radiant#todo-comments-in-the-code", "labels": ["OpenZeppelin"]}, {"title": "Variables Could Be Marked immutable", "body": "Variables that are only assigned a value from within the constructor of a contract can be declared as immutable.  Within the codebase, there are several variables that could be marked immutable. For instance:  The lendingPool, eligibilityDataProvider, lockZap, cic, weth and aaveOracle variables in the Leverager contract  The tokenV1 and tokenV2 variables in the Migration contract  To better convey the intended use of variables and to potentially save gas, consider adding the immutable keyword to variables that are only set in the constructor.  Update: Resolved in pull request #236 at commit ee519f4.", "html_url": "https://blog.openzeppelin.com/radiant#variables-could-be-marked-immutable", "labels": ["OpenZeppelin"]}, {"title": "Functions With public Visibility Could Be external", "body": "Throughout the codebase, instances of externally-called functions with public visibility were found.  Some examples include:  initialize, pause, unpause, autocompoundThreshold isEligibleForCompound, userEligibleForCompound and selfEligibleCompound functions in Compounder.sol  getVDebtToken and ltv functions in Leverager.sol  initialize function in StargateBorrow.sol  isMarketDisqualified function in EligibilityDataProvider.sol  setFallback and enableFallback functions in BaseOracle.sol  setLookback function in MultiFeeDistribution.sol  getSwapFeePercentage and setSwapFeePercentage functions in BalancerPoolHelper.sol  batchUpdateAllocPoint function in ChefIncentivesController.sol  getPoolHelper and getVDebtToken functions in LockZap.sol  To better convey the intended use of functions and to potentially realize some additional gas savings, consider changing a function's visibility from public to external if it is never used internally.  Update: Resolved in pull request #237 at commit 026ec8a.", "html_url": "https://blog.openzeppelin.com/radiant#functions-with-public-visibility-could-be-external", "labels": ["OpenZeppelin"]}, {"title": "Unused Named Return Variables", "body": "Named return variables are a way to declare variables that are meant to be used within a function body for the purpose of being returned as the function's output. They are an alternative to explicit inline return statements.  Throughout the codebase, there are multiple instances of unused named return variables. Some examples are:  In ChainlinkAdapter.sol:  The price return variable in the consult function  The roundId, answer, startedAt, updatedAt and answeredInRound return variables in the getRoundData function  The roundId, answer, startedAt, updatedAt and answeredInRound return variables in the latestRoundData function  In ChefIncentivesController.sol:  The issueBaseBounty return variable in the checkAndProcessEligibility function  The amount return variable in the availableRewards function  In UniswapPoolHelper.sol:  The optimalWETHAmount return variable in the quoteFromToken function  Consider using the existing named return variables or alternatively removing them.  Update: Resolved in pull request #251 at commit e9984e9.", "html_url": "https://blog.openzeppelin.com/radiant#unused-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Use Custom Errors", "body": "Since Solidity version 0.8.4, custom errors provide a cleaner and more cost-efficient way to explain to users why an operation failed versus using require and revert statements with custom error strings.  There are instances of require statements found in these files:  Leverager.sol  StargateBorrow.sol  BountyManager.sol  BaseOracle.sol  ChainlinkV3Adapter.sol  PriceProvider.sol  UniV2TwapOracle.sol  UniV3TwapOracle.sol  RadiantOFT.sol  There are instances of revert statements found in this file:  Leverager.sol  To improve conciseness, consistency, and gas savings, consider replacing hard-coded require and revert messages with custom errors.  Update: Resolved in pull request #252 at commits 6e081bc, 6451a5d, and 362c4a4.", "html_url": "https://blog.openzeppelin.com/radiant#use-custom-errors", "labels": ["OpenZeppelin"]}, {"title": "Use of Non-Explicit Imports", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Several instances where global imports are being used in the codebase were identified:  Lines 4-8 and 10-20 of Compounder.sol  Line 4 and Lines 6-10 of ChainlinkV3Adapter.sol  Lines 2-5 of wstethOracle.sol  Line 10 of RadiantOFT.sol  Line 8 of DustRefunder.sol  Lines 5-13 and Lines 15-21 of UniswapPoolHelper.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Resolved in pull request #253 at commit c05064a.", "html_url": "https://blog.openzeppelin.com/radiant#use-of-non-explicit-imports", "labels": ["OpenZeppelin"]}, {"title": "Redundant Use of SafeMath Library", "body": "The OpenZeppelin SafeMath library provides arithmetic functions with overflow/underflow protection, but Solidity 0.8.0 has added built-in overflow and underflow checking, supplanting the functionality provided by the library.  Throughout the codebase, the SafeMath library is being used in contracts with a Solidity version greater than 0.8.0, resulting in the addition of redundant overflow/underflow checks.  The following contracts import the SafeMath library:  Leverager.sol  StargateBorrow.sol  BountyManager.sol  EligibilityDataProvider.sol  BaseOracle.sol  ChainlinkV3Adapter.sol  PriceProvider.sol  UniV3TwapOracle.sol  ChefIncentivesController.sol  MiddleFeeDistribution.sol  MultiFeeDistribution.sol  Migration.sol  RadiantOFT.sol  LockZap.sol  BalancerPoolHelper.sol  LiquidityZap.sol  UniswapPoolHelper.sol  Consider removing the SafeMath import and its associated function calls from the codebase.  Update: Resolved in pull request #254 at commits 18a98c1 and 3c3dd90.", "html_url": "https://blog.openzeppelin.com/radiant#redundant-use-of-safemath-library", "labels": ["OpenZeppelin"]}, {"title": "Implicitly Abstract Contract", "body": "The consult virtual function of BaseOracle.sol is declared but not implemented. As a result, BaseOracle can never be instantiated directly.  To better signal this intention, consider explicitly marking the BaseOracle contract as abstract.  Update: Resolved in pull request #255 at commit 1e74c37.", "html_url": "https://blog.openzeppelin.com/radiant#implicitly-abstract-contract", "labels": ["OpenZeppelin"]}, {"title": "Follow Solidity Style Guide", "body": "There are several occurrences in the codebase where the Solidity style guide is not followed which makes code more difficult to read and prone to errors.  In DustRefunder.sol:  Function refundDust is internal and its name should start with the underscore _.  In LiquidityZap.sol:  The function getPairReserves is internal and its name should start with an underscore (_).  Public storage variables _token and _tokenWETHPair should start with a lowercase letter, not with an underscore (_).  The else block within _addLiquidity does not have curly braces. The subsequent if block where RDNT token proceeds are refunded also does not have curly braces.  In MultiFeeDistribution.sol:  The style guide's recommended layout of functions is not followed. Consider grouping view functions together.  The getBalances function uses an underscore on its input parameter address _user. This is inconsistent with the other nearby functions that also accept an address user input parameter, such as withdrawableBalance.  All initializer arguments have a leading underscore, except for priceProvider. At the same time, all state variables do not have leading underscores, even private mappings, except for _priceProvider.  In MiddleFeeDistribution.sol:  The emitNewTransferAdded function is internal and its name should start with an underscore (_).  The aaveOracle parameter of the initializer is the only one without a leading underscore (_).  In LockerList.sol:  The userlist state variable should be renamed userList to follow the same naming convention as the rest of the codebase.  In Leverager.sol:  The internal function name requiredLocked should start with an underscore (_).  In StargateBorrow.sol:  The function borrowETH is internal and its name should start with an underscore (_).  In BountyManager.sol:  Functions getBestBounty, getMfdBounty, getChefBounty and getAutoCompoundBounty are internal and their names should start with an underscore (_).  In LockZap.sol:  The ACCEPTABLE_RATIO storage variable name consists of all capital letters which suggests it is a constant variable, but it can be changed via the setAcceptableRatio function.  In UniswapPoolHelper.sol:  Consider making the value 100000000 more readable by changing it to 100_000_000.  In BalancerPoolHelper.sol:  The computeFairReserves function is internal and its name should start with an underscore (_).  The joinPool function is internal and its name should start with an underscore (_).  The sortTokens function is internal and its name should start with an underscore (_).  To improve the readability of the codebase, consider following the Solidity style guide.  Update: Resolved in pull request #256 at commits 66b6ecd, 8a8abf6 and 8a8abf6.", "html_url": "https://blog.openzeppelin.com/radiant#follow-solidity-style-guide", "labels": ["OpenZeppelin"]}, {"title": "Non-library Contract in libraries Directory", "body": "The LockerList.sol contract is located in the libraries directory, but it is not defined using the library keyword.  To avoid confusion, consider relocating this contract to the staking directory.  Update: Resolved in pull request #257 at commits 859dacd and a5fbb2f.", "html_url": "https://blog.openzeppelin.com/radiant#non-library-contract-in-libraries-directory", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "Throughout the codebase there are imports that are unused and could be removed.  For instance:  Imports IAToken, IMultiFeeDistribution, ILendingPoolAddressesProvider, ILendingPool, and ILockZap of BountyManager.sol  Imports SafeMath, Initializable, and IChainlinkAggregator of ChainlinkV3Adapter.sol  Imports IChainlinkAggregator and IBaseOracle of wstethOracle.sol  Import IERC20Metadata of ChefIncentivesController.sol  Import LockedBalance of MiddleFeeDistribution.sol  Imports IMultiFeeDistribution, ILendingPool, IPoolHelper, and IERC20DetailedBytes of UniswapPoolHelper.sol  Consider removing unused imports to improve the overall clarity and readability of the codebase.  Update: Resolved in pull request #258 at commit f6dfecb.", "html_url": "https://blog.openzeppelin.com/radiant#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Gas Optimizations in for Loops", "body": "Inconsistent Gas Optimizations in for Loops", "html_url": "https://blog.openzeppelin.com/radiant#inconsistent-gas-optimizations-in-for-loops", "labels": ["OpenZeppelin"]}, {"title": "Gas Optimizations", "body": "Floating Pragma Redundant Code Inconsistent Use of IERC20 Interfaces Use of Magic Numbers Typographical Errors  Conclusion  Appendix  Monitoring Recommendations  Summary  DeFi  From 2023-04-24  To 2023-06-09  Solidity  82 (75\u202fresolved)  1 (1\u202fresolved)  5 (5\u202fresolved)  15 (13\u202fresolved)  41 (36\u202fresolved)  20 (20\u202fresolved)  Scope  We audited the radiant-capital/v2-core repository at the e8f21f103e17736907b62809d1ad902febc53714 commit.  In scope were the following contracts:  System Overview  Radiant V2 is a decentralized lending platform where users can provide a variety of assets as collateral and borrow against it while keeping a healthy collateralization ratio. It features cross-chain borrowing by leveraging LayerZero's novel interoperability protocol between different blockchains.  Protocol revenue is shared with depositors and additionally, RDNT token rewards are distributed to eligible stakers. Stakers can become eligible by providing liquidity in the form of RDNT and the wrapped native token of each specific blockchain, and then locking it for a given period of time. The longer the lock time, the larger the reward multiplier. This incentivizes protocol participants to provide deep liquidity for the governance token.  The audited codebase is comprised of a few different packages that manage staking, incentives, eligibility, price oracles, a bounty system, looping (leveraging positions in a single transaction), zapping assets into locked LP tokens, cross-chain borrowing and the new Radiant OFT V2 token.  The system is currently deployed on Arbitrum and Binance Smart Chain (BSC). Locked liquidity is provided in a Balancer weighted pool (80% RDNT and 20% WETH) in Arbitrum, while a PancakeSwap V2 pool is used on BSC with 50% RDNT and 50% WBNB.  Staking, Reward Emissions and Eligibility  Staking on Radiant V2 means providing liquidity and locking the LP tokens for a certain period of time. In order to become eligible for reward emissions, users must always maintain a certain amount of locked LP tokens, respective to their total deposited collateral value in USD terms. These tokens can be locked for different periods of time, ranging from 1 month up to 12 months at the moment of writing. The longer the period, the larger the multiplier applied to accrued rewards.  By default, auto-relocking is enabled, which means that after a certain lock expires, it will get locked again automatically for the preferred lock period in order to not lose eligibility for rewards. Alternatively, the LP tokens can be withdrawn on lock expiration.  RDNT reward emissions can be claimed into vesting, which imposes a 90-day period before users can withdraw their full earnings. If a user decides to withdraw their rewards before vesting is complete, they will incur a linear penalty over that time ranging from 90% down to 25%. The penalty fee is distributed as follows: 90% goes to the Radiant DAO reserve, and the remaining 10% is sent to the Radiant Starfleet Treasury.  Eligible depositors and borrowers are entitled to receive RDNT emissions within the money market. Emissions can follow either a linear pattern with a fixed number of tokens distributed per second, or be linked to a predefined schedule that continuously updates the distribution at specific times.  The aforementioned vesting period can be bypassed and rewards instantly claimed for their total amount under the condition that they are zapped into locked LP tokens by pairing all claimed RDNT with the wrapped native token of the specific chain.  Compounding  Eligible depositors will generate rewards in rTokens such as rUSDC or rWBTC, which are the deposited, yield-generating equivalent of their underlying asset. These rewards can be claimed directly as rTokens into the user's wallet or, alternatively, they can be compounded into locked LP tokens in order to generate even more rewards.  This can be achieved via the Compounder contract, in a single transaction. Users can self-compound their rewards at any time or, they can opt-in for auto-compounding and rely on bounty hunters (see below) to do so on their behalf once a day in exchange for a small fee taken out of their claimed rewards.  Bounty System  In order to keep the protocol both decentralized and working as expected, a system of bounties has been set up so that third parties (called hunters) are incentivized to perform specific actions on behalf of the protocol. There are three different actions that hunters can perform in order to receive a bounty for their efforts:  Withdrawing expired locks for users: Expired locks should not keep generating rewards, so hunters are paid a fixed amount (the base bounty) in order to timely withdraw any user's expired locks. Depending on user settings, this lock will be withdrawn as LP tokens directly into their wallet or relocked into the protocol for their preferred amount of time.  Stopping emissions for ineligible users: Due to natural market fluctuations, user locks might change in U", "html_url": "https://blog.openzeppelin.com/radiant#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Floating Pragma", "body": "Contract wstethOracle uses the floating pragma ^0.8.0. It is recommended to set the pragma to 0.8.12 to align with the protocol's practice of locking the pragma for all contracts. This precautionary measure helps prevent the accidental deployment of contracts with outdated compiler versions that could potentially introduce vulnerabilities.  Update: Resolved in pull request #249 at commit f4e029e.", "html_url": "https://blog.openzeppelin.com/radiant#floating-pragma", "labels": ["OpenZeppelin"]}, {"title": "Redundant Code", "body": "Several instances of redundant or unnecessary code were found throughout the codebase:  The override keyword is often used in cases where there is no base function body being overridden. Consider eliminating the unnecessary use of override to avoid confusion.  The pragma abicoder v2 statement is redundant on the current Solidity version used to compile the project, 0.8.12. Consider whether it should stay for explicitness or alternatively, remove it from all occurrences since it is now enabled by default.  In MiddleFeeDistribution.sol:  On line 145 the forwardReward function unnecessarily re-computes the value of total. Consider removing this line.  In MultiFeeDistribution.sol:  When all user locks are withdrawable, the function _cleanWithdrawableLocks overrides the values of lockAmount and lockAmountWithMultiplier, and deletes userLocks[user], all of which is unnecessary since it was already computed.  The individualEarlyExit function contains a line of unreachable code. The ieeWithdrawableBalances function returns an index value that will be between 0 and userEarnings[onBehalfOf].length - 1, so the if statement on line 903 can never be true. Additionally, even if this could happen, the correct behavior in this case would be to revert rather than return.  In ChefIncentivesController.sol:  The initialize function performs an unnecessary address() cast on _poolConfigurator, which is already an address.  The _emitReserveLow internal function is only called by claim. Consider eliminating this function by moving its code into the location where it is called.  The endRewardTime function's calculation for unclaimedRewards duplicates the existing availableRewards function.  The _isEligible boolean parameter passed to stopEmissionsFor is unnecessary since that execution point cannot be reached if _isEligible is true.  In LockerList.sol:  The empty constructor is unnecessary since it will be called (and the parent Ownable constructor) implicitly.  In Compounder.sol:  The contract uses a <= 0 check for input validation of _compoundFee, both in the initializer and the setCompoundFee function. This is an unsigned value, so the value can never be less than zero.  The _claimAndSwapToBase function triggers a call to swapExactTokensForTokens within Uniswap's router, using a deadline value of block.timestamp + 600. This additional 600-second value is not needed; passing block.timestamp is sufficient.  The _wethToRdnt function triggers a call to swapExactTokensForTokens within Uniswap's router, using the deadline value of block.timestamp + 600. This additional 600-second value is not needed; passing block.timestamp is sufficient.  In StargateBorrow.sol:  The constant POOL_ID_ETH is not used and should be removed.  In EligibilityDataProvider.sol:  The storage variables eligibleDeposits and userDeposits are declared but never used.  The isMarketDisqualified function should be removed since it is not used anywhere and it is not coherent with the current protocol's behavior.  In BountyManager.sol:  The storage variable bountyBooster does not appear to be used anywhere after being set and can be removed along with the associated setBountyBooster function and BountyBoosterUpdated event.  The storage variable slippageLimit does not appear to be used anywhere after being set and can be removed along with the associated setSlippageLimit function and SlippageLimitUpdated event.  The check for positive _amount in _sendBounty is redundant since it has to be positive at this point due to this previous condition.  In LockZap.sol:  The setPriceProvider, setMfd, and setPoolHelper functions perform unnecessary address() casts on their input variables, which are already addresses.  In UniswapPoolHelper.sol:  The zapTokens function reassigns the value of liquidity.  The zapWETH reassigns the value of liquidity.  In BalancerPoolHelper.sol:  The internal function swap is not used and should be removed.  The swap function call to IVault(vaultAddr).swap uses a deadline value of block.timestamp + 3 minutes. The addition of 3 minutes is not needed; passing block.timestamp is sufficient.  In ChainlinkV3Adapter.sol:  The update function logic which updates ethLatestTimestamp and tokenLatestTimestamp is not used since canUpdate returns false. Consider removing the update function and the associated storage variables ethLatestTimestamp and tokenLatestTimestamp.  In PriceProvider.sol:  The storage variable eligibilityProvider is not used and should be removed.  Update: Resolved in pull request #259 at commits 7fe0064, 74f889a, 855c142, e86d67c, ea37c2b and 724e290. The isMarketDisqualified function was removed in pull request #226 at commit 7f4a0bc.", "html_url": "https://blog.openzeppelin.com/radiant#redundant-code", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Use of IERC20 Interfaces", "body": "Throughout the protocol, the IERC20 and IERC20Metadata interfaces are frequently used to interact with ERC-20 tokens, with the latter interface only being used to access the decimals function of tokens.  IERC20DetailedBytes interface is used instead of  return value types for the  Consider enforcing consistency by replacing the IERC20DetailedBytes interface with IERC20Metadata within the Compounder contract.  Update: Resolved in pull request #262 at commit 659430e.", "html_url": "https://blog.openzeppelin.com/radiant#inconsistent-use-of-ierc20-interfaces", "labels": ["OpenZeppelin"]}, {"title": "Use of Magic Numbers", "body": "Throughout the codebase, there are several literal values with unexplained meanings.  In Leverager.sol:  Consider leveraging the existing RATIO_DIVISOR constant on both the constructor and setFeePercent function when validating _feePercent instead of the hard-coded 1e4 value.  Consider assigning the value 2 ** 16 within the ltv function to a constant variable or alternatively, leveraging the existing getLtv calculation which is more self-explanatory and gas efficient.  Consider adding a constant value for calculating margin in wethToZapEstimation.  Consider using a constant when adding a safety margin to wethToZap.  Consider using a constant when choosing the desired interest rate mode instead of the hard-coded value 2 in zapWETHWithBorrow.  In Compounder.sol:  Consider adding a MAX_COMPOUND_FEE = 2000 constant to handle validation in the initialize and setCompoundFee functions.  Consider adding a MIN_SLIPPAGE_LIMIT = 8000 constant to handle validation in the initialize and setSlippageLimit.  Consider dividing by PERCENT_DIVISOR and not by 10000 in _wethToRdnt.  Consider adding a MIN_DELAY = 1 days constant to handle the check in isEligibleForAutoCompound.  In StargateBorrow.sol:  Consider using the FEE_PERCENT_DIVISOR constant to validate _xChainBorrowFeePercent parameter in the initialize and setXChainBorrowFeePercent functions.  Consider using a constant variable to hold the referral code used (0) when interacting with the lending pool in the borrow and borrowETH functions.  In EligibilityDataProvider.sol:  Consider adding a INITIAL_REQUIRED_DEPOSIT_RATIO = 500 constant to set requiredDepositRatio during initialization.  Consider adding a INITIAL_PRICE_TOLERANCE_RATIO = 9000 constant to set priceToleranceRatio during initialization.  Consider adding a MIN_PRICE_TOLERANCE_RATIO = 8000 constant to validate the value of _priceToleranceRatio in setPriceToleranceRatio.  In BountyManager.sol:  Consider adding a RATIO_DIVISOR = 10000 constant and use it for validating _hunterShare in the initialize, setHunterShare, and executeBounty functions.  In UniV2TwapOracle.sol:  Consider adding a PERIOD_MIN = 10 constant for validating _period in the initializer and setPeriod functions.  In RadiantOFT.sol:  Consider using a SHARED_DECIMALS = 8 constant for OFTV2 constructor initialization.  Consider using FEE_DIVISOR for validating the _fee parameter in the setFee function.  In BalancerPoolHelper.sol:  Consider adding RDNT_WEIGHT = 800000000000000000 and WETH_WEIGHT = 200000000000000000 constants for setting pool weights.  Consider adding INITIAL_SWAP_FEE_PERCENTAGE = 1000000000000000 constant for setting swapFeePercentage.  Consider dividing by the pool weights ratio instead of using the hard-coded value of 4 within quoteFromToken.  In LockZap.sol:  Consider using RATIO_DIVISOR to validate _ethLPRatio.  Consider adding constant variables for the values 100 and 97 in the quoteFromToken calculation.  Consider assigning the interest rate value 2 to a constant when borrowing from the lending pool to explicitly represent it as a variable interest rate.  To improve the codes readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. For complex values, consider adding an inline comment explaining how they were calculated or why they were chosen.  Update: Resolved in pull request #240 at commits 46a113f, cf2bc80, and f98d6b2.", "html_url": "https://blog.openzeppelin.com/radiant#use-of-magic-numbers", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "Consider addressing the following typographical errors:  In Leverager.sol:  Line 394: \"underlyig\" should be \"underlying\".  In BountyManager.sol:  Line 52: \"whiteliested\" should be \"whitelisted\".  Line 310: \"dont\" should be \"don't\".  In EligibilityDataProvider.sol:  Line 55: \"Elgible\" should be \"Eligible\".  In PriceProvider.sol:  Line 123: \"heler\" should be \"helper\".  In UniV3TwapOracle.sol:  Line 33: \"loopback\" should be \"lookback\".  Line 77: \"loopback\" should be \"lookback\".  Line 78: \"Loopback\" should be \"Lookback\".  In ChefIncentivesController.sol:  Line 136: \"poitns\" should be \"points\".  Line 518: \"eligbility\" should be \"eligibility\".  In MultiFeeDistribution.sol:  Lines 120, 301, and 1100: \"startfleet\" should be \"starfleet\".  Line 259: \"convert\" should be \"converter\".  Line 473: \"Earnings which is locked yet\" is an incomplete sentence.  Line 628: \"transfered\" should be \"transferred\".  Line 689: \"users\" should be \"user's\".  Line 1046: \"loopback\" should be \"lookback\".  In BalancerPoolHelper.sol:  Line 290: \"ad\" should be \"and\".  In DustRefunder.sol:  Line 11: \"remained\" should be \"remaining\".  In LiquidityZap.sol:  Line 186: \"transfered\" should be \"transferred\".  Line 200: \"transfered\" should be \"transferred\".  In LockZap.sol:  Line 29: \"RAITO\" should be \"RATIO\".  Line 82: \"paramter\" should be \"parameter\".  Update: Resolved in pull request #238 at commit d042343.", "html_url": "https://blog.openzeppelin.com/radiant#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Lack of Refunds", "body": ".  Trust Assumptions  During the course of the audit, several assumptions about the Scroll protocol were considered to be inherently trusted. These assumptions and the context surrounding them include:  EVM node and relayer implementation: It is assumed that the EVM node implementation will work as described in the Scroll documentation, particularly the opcodes and their expected behavior. The relayer implementation is trusted to act in the best interest of the users.  Censoring: The protocol is centralized as is, as the sequencer and prover have the ability to censor L2 messages and transactions. L1 to L2 messages are appended into a message queue that is checked against when finalizing, but the sequencer can currently choose to skip any message from this queue during finalization. This allows the chain to finalize even if a message is not provable. Therefore, it is worth noting that L1 to L2 messages from the L1ScrollMessenger or EnforcedTxGateway can be ignored and skipped. There are plans to remove this message-skipping mechanism post-mainnet launch once the prover is more capable.  No escape hatch: The Scroll protocol does not feature an escape hatch mechanism. This, combined with the potential for transaction censorship by the relayer, introduces a trust assumption in the protocol. In the event of the network going offline, users would not be able to recover their funds.  Whitelist ownership: The whitelist contract has an owner who can update the whitelist status of different addresses. This implies trust in the owner of the whitelist to manage this list correctly and in the best interest of the system and its users.  Privileged Roles  Certain privileged roles within the Scroll protocol were identified during the audit. These roles possess special permissions that could potentially impact the system's operation:  Proxy Admins: Most of the contracts are upgradeable. Hence, most of the logic can be changed by the proxy admin. The following contracts are upgradeable:  The gateway contracts L1MessageQueue L1ScrollMessenger L2GasPriceOracle ScrollChain L2ScrollMessenger  Implementation Owners: Most contracts are also ownable. The following actions describe what the owner can do in each contract.  L1ScrollMessenger: Pause relaying of L2 to L1 messages and L1 to L2 message requests. EnforcedTxGateway: Pause L1 to L2 transaction requests and change the fee vault. L1{CustomERC20|ERC721|ERC1155}Gateway: Change the token mapping of which L1 token is bridged to which L2 token. L1GatewayRouter: Set the respective gateway for ETH, custom ERC-20s and default ERC-20s. L1MessageQueue: Update the maximum allowed gas limit for L2 transactions, the gas price oracle to calculate the L2 fee and the EnforcedTxGateway address that may append unaliased messages into the queue. L2GasPriceOracle: Set the whitelist contract address that defines who may change gas-related settings. ScrollChain: Revert previously committed batches that haven't been finalized yet, set addresses as sequencers, change the verifier, and update the maximum amount of L2 transactions that are allowed in a chunk (bundle of blocks). FeeVault: Change the messenger address that is used to withdraw the funds from L2 to L1, the recipient address of the collected fees, and update the minimum amount of funds to withdraw. ScrollMessengerBase: Change the fee vault address which collects fees for message relaying. ScrollStandardERC20Factory: Use the factory to deploy another instance of a standard ERC-20 token on L2. L2ScrollMessenger: Pause relaying of L1 to L2 messages and L2 to L1 message requests. L2{CustomERC20|ERC721|ERC1155}Gateway: Change the token mapping of which L2 token is bridged to which L1 token. L2GatewayRouter: Set the respective gateway for ETH, custom ERC-20s and default ERC-20s. L2MessageQueue: Update the address of the messenger. L2TxFeeVault: Change the messenger address that is used to withdraw the funds from L1 to L2, the recipient address of the collected fees, and update the minimum amount of funds to withdraw. L1BlockContainer: Initialize the starting block hash, block height, block timestamp, block base fee, and state root. L1GasPriceOracle: Update the gas price and whitelist. Fallback: Withdraw ERC20 tokens and ETH as well as execute arbitrary messages. Whitelist: Accounts can be whitelisted to change the L2 base fee on L1 as well as the intrinsic gas parameters. GasSwap: Withdraw stuck ERC20 tokens and ETH, update the fees, and set the approved targets to call MultipleVersionRollupVerifier: Set the new verifier and their starting batch index  Sequencer: The sequencer role can interact with the ScrollChain contract to commit to new batches that bundle multiple L2 blocks in chunks that can then be finalized along with a proof.  Prover: The prover role can interact with the ScrollChain contract to prove batches that have already been committed by the sequencer, thus finalizing them.  Each of these roles presents a unique set of permission", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#lack-of-refunds", "labels": ["OpenZeppelin"]}, {"title": "Potentially Stuck USDC From Pausing", "body": "Currently the L2USDCGateway has pausing functionality that its L1 counterpart does not have. This is a feature that will be used by the protocol to do supply locking in the future.  An issue arises when the L2USDCGateway is paused while the L1USDCGateway remains unpaused and usable. Users may still use the gateway to submit messages from L1 to L2, and while the transaction could succeed on L1, it will fail during finalization on L2 via the paused deposit check in the finalizeDepositERC20 function. Therefore, the users who deposited L1 USDC will have their tokens locked in the gateway and unable to replay their transaction. Assuming that the transaction was not skipped, dropMessage cannot be called to obtain a refund.  As USDC is one of the most widely used tokens, this issue could cause a high volume of users to have locked funds. Consider adding the same pausing functionality to the L1USDCGateway and updating the pausing state on both sides at the same time. Furthermore, consider implementing a refund mechanism to unlock user funds when their message from L1 to L2 fails.  Update: Acknowledged, not resolved. The Scroll team stated:  We will ensure that in L1 pauseDeposit will be called first and in the meantime, in L2, pauseWithdraw will be called. After this, the pending L1=>L2 or L2=>L1 messages are relayed. The pausing withdraw in L1 and pausing deposit in L2 will enable (actually not needed but just in case). We will help relay pending L2=>L1 message if users forget to withdraw the USDC. We will also help replay L1=>L2 messages if they fail in L2 due to running out of gas. Skipped messages are not possible in the USDC gateway, since we disabled deposit/withdraw with data.  Medium Severity", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#potentially-stuck-usdc-from-pausing", "labels": ["OpenZeppelin"]}, {"title": "Lack of Expiration for Retrying Transactions", "body": "The L1ScrollMessenger contract provides a mechanism to retry failed transactions from L1 to L2 at any time. Therefore, if a user creates an L1 to L2 transaction and it fails, it can be retried indefinitely at a later time. A scenario could occur where a user erroneously sends an L1 to L2 transaction, which fails at the L2 level. The user may be inclined to send another transaction, which would succeed at the L2 level. However, a malicious recipient could later retry the user's first transaction against their will, which could succeed.  More generally, if a transaction is sent from L1 to L2 and fails, it can be retried indefinitely at a later time. Consider adding an expiration time to replay failed transactions, limiting the timeframe during which a failed transaction can be retried.  Update: Partially resolved in pull request #840 at commit 0d7d73f. The L1ScrollMessenger and L2ScrollMessenger contracts were updated to store the timestamp of when the message was sent. However, checking for expiration was not implemented. The Scroll team stated:  Only the timestamp is added for each message, the expiration check will be added together with the refund feature.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#lack-of-expiration-for-retrying-transactions", "labels": ["OpenZeppelin"]}, {"title": "Potentially Stuck ETH in L1ScrollMessenger", "body": "function dropMessage in  _value of the message is returned to the sender using the  Consider allowing the _value to be returned to the sender even if the sender does not implement the onDropMessage function.  Update: Acknowledged, will resolve. The Scroll team stated that they will resolve the issue:  This will be resolved if we implement the refund feature.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#potentially-stuck-eth-in-l1scrollmessenger", "labels": ["OpenZeppelin"]}, {"title": "Potentially Stuck ETH from Incorrect Data Parameter", "body": "_executeMessage will be called. On  line 198 of this function, the  The replaying of this message will not help, as the _message field cannot be changed for a replay, and assuming that the transaction was not skipped, dropMessage cannot be called to get a refund.  To avoid funds being lost when bridging, consider adding a way for users to be refunded when the bridging transaction cannot be completed (for example when the transaction reverts or is skipped), and when the gas limit exceeds the gas effectively consumed.  Update: Acknowledged, will resolve. The Scroll team stated that they will resolve the issue:  This will be resolved if we implement the refund feature.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#potentially-stuck-eth-from-incorrect-data-parameter", "labels": ["OpenZeppelin"]}, {"title": "Use of Non-Production-Ready Trusted Forwarder", "body": "that is set in the constructor. The trusted forwarder that it depends on is the  located in the External contract. However, the  mainly meant for testing.  By using the MinimalForwarder, ETH could potentially be lost. In addition, the MinimalForwader's signed requests do not expire and lack batching, which is useful when dealing with a large volume of requests to be forwarded.  Consider using OpenZeppelin's ERC2771Forwarder instead. While this contract is not available until v5.0 is released, the source code can be obtained from the master branch and inserted into the codebase.  Update: Partially resolved in pull request #843 at commit 709101a. The Scroll team replaced the MinimalForwarder with the ERC2771Forwarder contract but did not remove the MinimalForwarder import from the External.sol file", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#use-of-non-production-ready-trusted-forwarder", "labels": ["OpenZeppelin"]}, {"title": "replayMessage and dropMessage Can Be Front-Run", "body": "The L1ScrollMessenger contract is used to send messages from L1 to L2. Failed messages can be replayed using the replayMessage function. In addition, skipped messages can be dropped using the dropMessage function. A scenario could occur where a user sends an L1-to-L2 transaction that gets skipped. The user can now choose to either replay or drop the message.  However, an adversary could void the user's intention by front-running the user's intended action if they have an incentive to do so. If a user wants to replay their message, the adversary could front-run the user and call dropMessage. Similarly, if a user wants to drop their message, the adversary could front-run the user and call replayMessage.  Consider only allowing the sender of the original message to replay or drop their message to prevent front-running attacks.  Update: Acknowledged, not resolved. The Scroll team stated:  Firstly, we do not think the fact that the transaction can be front-run is a big problem. Secondly, it is not easy to figure out which user is the original sender of the message. Thirdly, in some situations, we want to replay or drop message for some users, so we do not plan on fixing the issue.  Low Severity", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#replaymessage-and-dropmessage-can-be-front-run", "labels": ["OpenZeppelin"]}, {"title": "Error-Prone Call Encoding", "body": "On line 126 of ScrollMessengerBase.sol a call is encoded with abi.encodeWithSignature, which is prone to typographical errors. Instead, consider using the abi.encodeCall function that protects against mistakes. When making this change, ensure that at least Solidity version 0.8.13 or above is used, due to a bug encoding literals.  Update: Acknowledged, not resolved. The Scroll team stated:  This is the only encodeWithSignature left in the contracts. The reason why we do not fix it is because the relayMessage is only used in L2ScrollMessenger. If we use abi.encodeCall, some L2 only interface will be introduced to the base contract, which is not good in our opinion.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#error-prone-call-encoding", "labels": ["OpenZeppelin"]}, {"title": "Anyone Can Steal ERC-20 Tokens From GasSwap", "body": "The GasSwap contract implements the withdraw function  to allow the owner to withdraw ETH or ERC-20 tokens that are stuck within the contract. This contract also contains a swap function, which allows users to swap any ERC-20 token for a specified amount of ETH. This function performs the swap followed by a refund of the unswapped tokens to the user.  However, the amount refunded to the user is the total balance of the GasSwap contract of that ERC-20 token, which includes the amount of that ERC-20 token that has been stuck in the contract. Therefore, if there is any ERC-20 token that is stuck in GasSwap, any user can execute a swap of 0 tokens of that particular ERC-20 token and obtain these stuck tokens for themselves as the refund.  When swapping, consider taking into account the user's balance of the swapped token before and after the swap, before refunding the user.  Update: Resolved in pull request #844 at commit 7a26dbc.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#anyone-can-steal-erc-20-tokens-from-gasswap", "labels": ["OpenZeppelin"]}, {"title": "Inconsistency of Allowing a Trusted Forwarder", "body": "msg.sender. Therefore, all functions with  This inconsistency is confusing and error-prone. Consider using _msgSender() everywhere in GasSwap and OwnableBase, which will automatically default to msg.sender if it is not sent from the trustedForwarder address.  Update: Resolved in pull request #846 at commit 60de22b.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#inconsistency-of-allowing-a-trusted-forwarder", "labels": ["OpenZeppelin"]}, {"title": "Inconsistency of Reentrancy Guard", "body": "The ScrollMessengerBase and ScrollGatewayBase contracts implement a nonReentrant modifier. Instead, consider utilizing the ReentrancyGuardUpgradeable contract of the OpenZeppelin library which is a dependency in use. The reimplementation of such safety mechanisms is generally discouraged. In addition, this is inconsistent with other contracts such as EnforcedTxGateway, which does, in fact, use OpenZeppelin's reentrancy guard. In both cases, make sure to initialize the contracts properly if they are used for upgradeable contracts.  Update: Resolved in pull request #698 at commit a798e4d.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#inconsistency-of-reentrancy-guard", "labels": ["OpenZeppelin"]}, {"title": "Potentially Stuck ETH in GasSwap", "body": "GasSwap contract, the  swap function allows a user to swap ERC-20 tokens for ETH. The swap is  executed by calling an approved target, which in return transfers ETH to the  receive function. The user is then  reimbursed the output amount of ETH after deducting the fee.  However, any user can accidentally transfer ETH to the GasSwap contract without calling the swap function. Any ETH transferred outside of a swap will be locked in the contract and is only redeemable through the owner.  Consider only allowing ETH transfers to the GasSwap contract from approved targets to minimize the probability of having ETH accidentally locked in this contract. Alternatively, consider only allowing ETH transfers to the contract during a swap.  Update: Acknowledged, not resolved. The Scroll team stated:  Our owner can rescue the stuck ETH as long as the user provides the transfer transaction.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#potentially-stuck-eth-in-gasswap", "labels": ["OpenZeppelin"]}, {"title": "Possible Misleading revert Message When Swapping Non-ERC20Permit Tokens", "body": "_permit.token can be arbitrarily chosen by the user, there is no guarantee that the address of the token is an  safeTransferFrom, emitting an insufficient allowance message.  Consider using the safePermit function from the imported SafeERC20 library to fail with a more reasonable message.  Update: Resolved in pull request #847 at commit 8daae8f.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#possible-misleading-revert-message-when-swapping-non-erc20permit-tokens", "labels": ["OpenZeppelin"]}, {"title": "Potentially Misleading Verifier Event", "body": "The MultipleVersionRollupVerifier contract maps the batch index to the address of the verifier that was used. The owner of this contract can call the updateVerifier function in order to update the verifier. For this update to succeed, it requires that the provided startBatchIndex is greater than or equal to the previous verifier's startBatchIndex.  However, it does not check if that batch number has already been verified by the current verifier, which could be confusing. For example, if the current verifier's start index is 100, and it has verified batches up to batch 105, the new verifier could be set with a start index of 102. The event emitted would contain the index of 102, which would be confusing because it would appear to a user monitoring the events as though the new verifier was used to verify the batches 102-105 when in reality it was not. This could even be used maliciously by the owner to hide information relating to a faulty verifier.  Consider enforcing that the start index must be greater than the lastFinalizedBatchIndex.  Update: Resolved in pull request #849 at commit 6527331.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#potentially-misleading-verifier-event", "labels": ["OpenZeppelin"]}, {"title": "Redundancy of Replaying Messages in L2ScrollMessenger", "body": "The logic to retry messages sent from L1 to L2 lives solely in the replayMessage function in L1ScrollMessenger. In addition, the maximum number of times that a message can be replayed as well as the replayStates are also located in L1ScrollMessenger.  maxFailedExecutionTimes state variable and a  l1MessageFailedTimes mapping, which are tracking the same values as on the L1 side. When executing a message in  transaction will succeed. However, given that the maximum number of failed execution times  can be updated to be a different value than that on the L1 side, this could cause confusion for a user who replays a transaction from L1. This duplication of function can also result in future issues when refactoring code, which could lead to future vulnerabilities.  Consider removing all code related to replaying messages in L2ScrollMessenger to reduce code duplication as well as the potential surface of future errors.  Update: Resolved in pull request #850 at commit 51a74dd.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#redundancy-of-replaying-messages-in-l2scrollmessenger", "labels": ["OpenZeppelin"]}, {"title": "Misleading and Incorrect Comments", "body": "Throughout the code, we found several comments that were either misleading or incorrect. Some examples are:  This comment in ScrollMessengerBase suggests moving the declaration of _lock_status to ScrollMessengerBase in the next big refactor, which has already been done.  The comments on lines 36 and 172 in L1ERC721Gateway should say _l2Token instead of _l1Token.  The comment on line 134 in L2USDCGateway.sol should say L2GatewayRouter instead of L1GatewayRouter.  Consider resolving these instances of incorrect documentation to improve the clarity and readability of the codebase.  Update: Resolved in pull request #851 at commit b933adb.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#misleading-and-incorrect-comments", "labels": ["OpenZeppelin"]}, {"title": "maxReplayTimes is Not Initialized in L1ScrollMessenger", "body": "initialize function of  deployment script for  updateMaxReplayTimes to set  replayMessage due to the  max reply check reverting. Therefore, this will happen until  Consider setting maxReplayTimes to an appropriate value during the initialization of the L1ScrollMessenger contract.  Update: Resolved in pull request #852 at commit 020d272.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#maxreplaytimes-is-not-initialized-in-l1scrollmessenger", "labels": ["OpenZeppelin"]}, {"title": "Tokens With Permit Functionality Can Be Front-Run", "body": "has  WrappedEther contract will also have  The result would be that when this L1 to L2 message is executed on L2, it would fail since it would attempt to execute the same permit function with the same nonce. This griefing attack could confuse the user, who may believe that the permit did not succeed on L2, and cause them to re-send the message, costing the user more gas.  Consider discouraging calling the permit function from L1 to L2 or documenting the possibility of front-running griefing attacks more thoroughly. Alternatively, consider removing the permit functionality from frequently used tokens in L2.  Update: Acknowledged, not resolved. The Scroll team stated:  It seems not a big problem, we think it is not necessary to fix.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#tokens-with-permit-functionality-can-be-front-run", "labels": ["OpenZeppelin"]}, {"title": "Extraneous Use of safeApprove", "body": "In the swap function of GasSwap, the function safeApprove is used to approve an amount of 0 and once again to approve the desired value. While this will mitigate the attack against double increments, it is gas-inefficient and not the best practice. Furthermore, safeApprove will not be supported in future OpenZeppelin contracts.  Consider avoiding this anti-pattern with the use of safeIncreaseAllowance and safeDecreaseAllowance instead.  Update: Acknowledged, not resolved. The Scroll team stated:  We want make sure only at most amount is used by the target contract, so safeApprove is our best choice.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#extraneous-use-of-safeapprove", "labels": ["OpenZeppelin"]}, {"title": "Variables Missing immutable Keyword", "body": "Throughout the codebase, there are variables that remain unchanged after initialization and can be optimized by declaring them as immutable variables and setting them in the constructor. This could increase code clarity as well as reduce gas costs. For instance:  The variables rollup and messageQueue in L1ScrollMessenger  The variable counterpart in ScrollMessengerBase  The variables messenger and scrollChain in L1MessageQueue  The variable messageQueue in ScrollChain  Consider declaring these variables as immutable if they are not meant to be updateable later.  Update: Acknowledged, not resolved. The Scroll team stated:  Some of the addresses are not known until deploy, so current way works well for us.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#variables-missing-immutable-keyword", "labels": ["OpenZeppelin"]}, {"title": "Inconsistency Between maxReplayTimes and ReplayState.times", "body": "The state variable maxReplayTimes is of type uint256, while the struct field ReplayState.times is of type uint128 (for the purpose of packing the struct into one storage slot).  If maxReplayTimes is set to be greater than type(uint128).max, a user would be allowed to replay their message more than type(uint128).max times. Due to the use of unchecked block, the value of _replayState.times could overflow, causing unexpected behavior.  Consider changing maxReplayTimes from uint256 to uint128 to prevent this potential overflow.  Update: Acknowledged, not resolved. The Scroll team stated:  The overflow is not likely to happen. If someone replays the message 1 time per second, it well need 10790283070806014188970529154990 years.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#inconsistency-between-maxreplaytimes-and-replaystate.times", "labels": ["OpenZeppelin"]}, {"title": "Lack of Indexed Event Parameters", "body": "Throughout the codebase, several events do not have their parameters indexed. For instance:  The UpdateMaxReplayTimes event  The DequeueTransaction event  The DropTransaction event  The UpdateVerifier event  The UpdateMaxNumL2TxInChunk event  The UpdateMaxFailedExecutionTimes event  The UpdateTokenMapping events 1 2  The UpdateWhitelist event  The UpdateFeeRatio event  The UpdateApprovedTarget event  Consider indexing event parameters to improve the ability of off-chain services to search and filter for specific events.  Update: Partially resolved in pull request #673 at commit b7a02fb. The client added in indexed parameters for a few events, but kept the following events unindexed:  The UpdateMaxReplayTimes event  The DequeueTransaction event  The DropTransaction event  The UpdateVerifier event  The UpdateMaxNumL2TxInChunk event  The UpdateMaxFailedExecutionTimes event  The UpdateWhitelist event  The UpdateFeeRatio event  The UpdateApprovedTarget event", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#lack-of-indexed-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Coding Style", "body": "Line 19 in  Line 7 in  Consider removing the solhint-disable no-empty-blocks statements listed above to improve the clarity of the codebase.  Update: Resolved in pull request #874 at commit ba98a1a.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#inconsistent-coding-style", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Function Visibility", "body": "The depositETH function is not called internally by any of the functions in the L1ETHGateway contract. Consider setting the visibility to external instead of public.  Update: Resolved in pull request #875 at commit f5e5de1.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#incorrect-function-visibility", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Order of Event Emissions", "body": "Throughout the codebase, events are emitted after the corresponding storage has changed. However, in revertBatch in ScrollChain, the RevertBatch event is being emitted before resetting the batch value.  To improve the readability and consistency of the codebase, consider always following the same order of operations when emitting an event in response to a change in the state of the contract.  Update: Resolved in pull request #876 at commit 4b8d9ce.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#inconsistent-order-of-event-emissions", "labels": ["OpenZeppelin"]}, {"title": "Missing and Inconsistent Event Emissions", "body": "Throughout the codebase, several constructors and initializers do not emit events after initializing sensitive variables in the system, although when those variables are updated using setter functions, an event is emitted. For instance:  In the constructor of FeeVault, both the storage variables minWithdrawAmount and recipient are changed without emitting the events UpdateMinWithdrawAmount and UpdateRecipient respectively.  When initializing ScrollMessengerBase, the storage variable feeVault is changed without emitting the respective UpdateFeeVault event.  In the constructor of GasSwap, setting the storage variable owner does not emit the OwnershipTransferred event.  In the constructor of MultipleVersionRollupVerifier, the storage variable latestVerifier is changed without emitting the respective UpdateVerifier event.  When initializing EnforcedTxGateway, the storage variable feeVault is changed without emitting the respective UpdateFeeVault event.  dropMessage and  replayMessage do not emit an event when a message is dropped or replayed. Also, the functions  pauseDeposit and  pauseWithdraw in  Consider emitting events when changing state variables. Moreover, consider replacing the manual variable declarations in constructors and initializers with the corresponding setter function to update those variables.  Update: Acknowledged, will resolve. The Scroll team stated that they will resolve the issue:  It will be fixed later on when we have more time.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#missing-and-inconsistent-event-emissions", "labels": ["OpenZeppelin"]}, {"title": "Code Duplication", "body": "There are instances of duplicated code within the codebase. Duplicating code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors. Such errors can inadvertently be introduced when functionality changes are not replicated across all instances of code that should be identical. For instance:  In the L1MessageQueue contract the value while declaring _queueIndex can be replaced by calling nextCrossDomainMessageIndex. Consider marking nextCrossDomainMessageIndex as public.  In the L1CustomERC20Gateway contract multiple instances, for example on lines 102 and 122, obtain the value of the L2 token address by accessing the mapping directly. Consider using the designated getL2ERC20Address function.  In the L1ERC20Gateway contract, if msg.sender != router, the amount requested is calculated in the else-block. However, the calculation can be replaced by calling the designated requestERC20 function.  In the L1ERC721Gateway contract, lines 196 to 197 and 227 to 228 obtain the corresponding L2 address of the token being deposited and check if the address exists. Consider replacing these lines with a corresponding internal function.  All instances of the OwnableBase contract can be replaced by OpenZeppelin's Ownable contract.  During the initialization of the L1GatewayRouter contract, the declaration of the variables defaultERC20Gateway and ethGateway can be replaced by the setDefaultERC20Gateway and setETHGateway functions respectively.  During the initialization of the L2GatewayRouter contract, the declaration of the variables defaultERC20Gateway and ethGateway can be replaced by the setDefaultERC20Gateway and setETHGateway functions respectively.  Consider removing the listed code duplications to improve the readability and consistency of the codebase.  Update: Acknowledged, will resolve. The Scroll team stated that they will resolve the issue:  It will be fixed later on when we have more time.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#code-duplication", "labels": ["OpenZeppelin"]}, {"title": "Follow the Checks-Effects-Interactions Pattern", "body": "In the relayMessageWithProof function in L1ScrollMessenger, there is an external call which is made before a state update, thereby breaking the Checks-Effects-Interactions pattern. While currently there may not be a reentrancy risk, it is still considered best practice to follow this pattern to mitigate future issues that may occur when refactoring code.  Consider rewriting this function to follow the Checks-Effects-Interactions pattern.  Update: Acknowledged, not resolved. The Scroll team stated:  It is hard to do so, that's why we add a reentrancy guard here.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#follow-the-checks-effects-interactions-pattern", "labels": ["OpenZeppelin"]}, {"title": "Unused Function Parameter", "body": "The _receiver parameter is never used in any implementations of the _beforeDropMessage function.  Consider removing the unused function parameter to avoid confusion.  Update: Resolved. This is not an issue. The Scroll team stated:  Yeah, it is not used in our gateways. But we keep it, just in case if thirdparty gateways need it.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#unused-function-parameter", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary Usage of Upgradeable Interfaces", "body": "SafeERC20Upgradeable and  IERC20Upgradeable in  SafeERC20Upgradeable and  IERC20Upgradeable in  SafeERC20Upgradeable and  IERC20Upgradeable in  Consider using upgradeable patterns only for the code contract logic and implementing non-upgradeable interfaces and libraries for better code compatibility and consistency.  Update: Acknowledged, not resolved. The Scroll team stated:  All the contracts mentioned are upgradeable, I think it is ok to use the upgradeable version of IERC20 and SafeERC20.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#unnecessary-usage-of-upgradeable-interfaces", "labels": ["OpenZeppelin"]}, {"title": "Duplicate Imports", "body": "There are duplicate imports throughout the codebase. For instance:  The duplicate import ScrollGatewayBase in L1ERC20Gateway.sol  The duplicate import IERC20 in GasSwap.sol  Consider removing duplicate imports to improve the readability of the codebase.  Update: Resolved in pull request #877 at commit b73f7a9.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#duplicate-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "Unused Imports", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Recommendations", "body": "Conclusion  Summary  zkEVM-based zkRollup, Bridge & Rollup  From 2023-07-24  To 2023-08-11  Solidity  32 (13\u202fresolved, 4\u202fpartially\u202fresolved)  0 (0\u202fresolved)  2 (0\u202fresolved)  5 (0\u202fresolved, 2\u202fpartially\u202fresolved)  10 (8\u202fresolved)  15 (5\u202fresolved, 2\u202fpartially\u202fresolved)  0 (0\u202fresolved)  Scope  We audited the scroll-tech/scroll repository at the 2eb458c commit.  We also performed a diff audit of the scroll-tech/scroll repository at the 2eb458c commit against 3bc8a3f commit.  System Overview  Scroll is an EVM-equivalent zk-Rollup designed to be a scaling solution for Ethereum. It achieves this by interpreting EVM bytecode directly at the bytecode level, following a similar path to projects like Polygon zkEVM and ConsenSys' Linea.  Scroll's architecture and code structure draw inspiration from other Layer 2 solutions like Arbitrum and Optimism, particularly in the design of their gateways, predeploys, and messaging contracts. Notably, a lot of code structures from Arbitrum's gateways and the AddressAliasHelper.sol contract are reused with minor modifications.  There were several major changes since the last audit. The first major change was to add a refund for skipped messages only and to remove the message retry logic from the L2 side. There was also an addition of the MultipleVersionRollupVerifier contract which allows for different verifiers to be used for different batches. A GasSwap contract was also added to help users swap tokens for L2 ETH. Aside from these major changes, this audit focused on diff audits across almost all contracts across this protocol. In this audit, we aimed to verify the correctness and security of the contracts, focusing on block finalization, message passing, and the process of depositing and withdrawing into/from the rollup.  This report presents our findings and recommendations for the Scroll zk-Rollup protocol. In the following sections, we will discuss these aspects in detail. We urge the Scroll team to consider these findings in their ongoing efforts to provide a secure and efficient Layer 2 solution for Ethereum.  Architecture  The system's architecture is split into three main components:  Scroll Node: This constructs Layer 2 (L2) blocks from user transactions, commits these transactions to the Ethereum base layer and handles message passing between L1 and L2.  Roller Network: This component is responsible for generating the zkEVM validity proofs, which are used to prove that transactions are executed correctly.  Rollup and Bridge contracts: These contracts provide data availability for Scroll transactions, verify zkEVM validity proofs, and allow users to move assets between Ethereum and Scroll. Users can pass arbitrary messages between L1 and L2 and can bridge assets in either direction thanks to the Gateway contracts.  Rollup and Bridging  The Scroll system connects to Ethereum primarily through its Rollup and Messenger contracts. The Rollup contract is responsible for receiving L2 state roots and blocks from the Sequencer, and finalizing blocks on Scroll once their validity is established.  The Messenger contracts enable users to pass arbitrary messages between L1 and L2, as well as bridge assets in both directions. The gateway contracts make use of the messages to operate on the appropriate layer.  The standard ERC-20 token bridge automatically deploys tokens on L2, using a standardized token implementation. There is also a custom token bridge which enables users to deploy their L1 token on L2 for more sophisticated cases. In such scenarios, the Scroll team would need to manually set the mapping for these tokens. This could potentially lead to double-minting on L2 (two tokens being created, one through each method). To prevent such a scenario, it is recommended to use the GatewayRouter, which will route the token to the correct gateway. These custom gateways are also required for ERC-721 and ERC-1155 tokens, which currently do not have a standard gateway provided. However, the GatewayRouter does not currently support ERC-721 or ERC-1155 custom gateways.  State of Refunds  When communicating/bridging from L1 to L2, values are handled in two ways on the L1 side:  If a token is bridged, the token will be held by the gateway contract. If ETH is transferred, the value is kept in the L1 messenger contract. In the case of WETH, the assets will be first unwrapped to ETH and forwarded to be held by the L1 messenger contract.  The user has to specify a gas limit that will be used for the L2 transaction. The relayer accounts for this gas limit through a fee that is deducted on the L1 call.  In the audited version of the protocol, there is a refund mechanism for (1) only if the L1 initialized message is not provable and hence not executed and skipped from the L1 message queue. If an L1 message is not executed, reverted, or otherwise in a situation where it has succeeded on L1 but failed on L2 and yet is proven back onto L1, there are no refunds available. This means assets can potenti", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#recommendations", "labels": ["OpenZeppelin"]}, {"title": "ERC-20 Factory Design", "body": "Tokens can be bridged in a custom and standard way. For the latter, the ScrollStandardERC20 is the default implementation that will represent the L1 token on L2. This is realized with the Clones library and the EIP-1167 standard. It works by deploying a minimal proxy that delegates its calls into the token implementation and is initialized as the token instance.  These standard tokens are not upgradeable, which comes with a trade-off. On the one hand, it is more secure since the logic cannot be changed. On the other hand, it is less future-proof meaning that standards like ERC-677 - which is not a finalized EIP - might at some point be overruled by a new standard that finds mass adoption.  An alternative factory design that is future-proof would be the Beacon proxy pattern. In a similar approach the BeaconProxy will be the token instance, but then fetches the implementation contract to delegate to from a single UpgradeableBeacon contract. This allows upgrading all tokens in one transaction.  Regarding the security implications of upgradeable contracts, it is crucial to have the UpgradeableBeacon secured through a timelock, multisig, and cold wallets.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#erc-20-factory-design", "labels": ["OpenZeppelin"]}, {"title": "ERC-165 Support", "body": "While most of the codebase is comprised of custom contracts which do not implement a specific standard, the ScrollStandardERC20 contract is implementing the ERC-20 and ERC-677 standards. As such, it makes sense to also add ERC-165 support to enable other parties to identify its interface and the standard it implements.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#erc-165-support", "labels": ["OpenZeppelin"]}, {"title": "Testing Coverage", "body": "Due to the complex nature of the system, we believe this audit would have benefitted from more complete testing coverage.  While insufficient testing is not necessarily a vulnerability, it implies a high probability of additional hidden vulnerabilities and bugs. Given the complexity of this codebase and the numerous interrelated risk factors, this probability is further increased. Testing provides a full implicit specification along with the expected behaviors of the codebase, which is especially important when adding novel functionalities. A lack thereof increases the chances that correctness issues will be missed. It also results in more effort to establish basic correctness and reduces the effort spent exploring edge cases, thereby increasing the chances of missing complex issues.  Moreover, the lack of repeated automated testing of the full specification increases the chances of introducing breaking changes and new vulnerabilities. This applies to both previously audited code and future changes to current code. This is particularly true in this project due to the pace, extent, and complexity of ongoing and planned changes across all parts of the stack (L1, L2, relayer, and zkEVM). Underspecified interfaces and assumptions increase the risk of subtle integration issues, which testing could reduce by enforcing an exhaustive specification.  We recommend implementing a comprehensive multi-level test suite consisting of contract-level tests with >90% coverage, per-layer deployment and integration tests that test the deployment scripts as well as the system as a whole, per-layer fork tests for planned upgrades and cross-chain full integration tests of the entire system. Crucially, the test suite should be documented in a way so that a reviewer can set up and run all these test layers independently of the development team. Some existing examples of such setups can be suggested for use as reference in a follow-up conversation. Implementing such a test suite should be a very high priority to ensure the system's robustness and reduce the risk of vulnerabilities and bugs.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#testing-coverage", "labels": ["OpenZeppelin"]}, {"title": "Custom Gateway Contracts", "body": "Developers who need to use custom gateway contracts should ensure that their contracts are designed to allow for the burning of tokens and the creation of the same tokens with the same ID. This is particularly relevant for non-fungible tokens (NFTs) and other unique asset types that rely on the token ID for maintaining uniqueness.  The burning of tokens on one layer (L1 or L2) and the subsequent creation of the same tokens on the other layer is a crucial feature for token bridging in layer 2 solutions like Scroll. However, most NFT contracts are designed to create new tokens with a sequential counter, which makes them incompatible with this requirement.  Ensure providing adequate documentation, and if possible code examples, so that developers in the Scroll ecosystem can properly implement these requirements.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#custom-gateway-contracts", "labels": ["OpenZeppelin"]}, {"title": "Monitoring Recommendations", "body": "While audits help in identifying code-level issues in the current implementation and potentially the code deployed in production, the Scroll team is encouraged to consider incorporating monitoring activities in the production environment. Ongoing monitoring of deployed contracts helps identify potential threats and issues affecting production environments. With the goal of providing a complete security assessment, the monitoring recommendations section raises several actions addressing trust assumptions and out-of-scope components that can benefit from on-chain monitoring.  Governance  Critical: There are several important contracts that use the Proxy Pattern and can be arbitrarily upgraded by the proxy owner. Consider monitoring for upgrade events on at least the following contracts:  ScrollChain  L1ScrollMessenger  L2ScrollMessenger  Gateway contracts  Access Control  Technical  High: The rollup contract contains sensitive functions that should only be called by the owner. Consider monitoring if any of the following events are emitted.  UpdateSequencer  UpdateProver  UpdateVerifier  Medium: The L1ScrollMessenger, L2ScrollMessenger, and L2USDCGateway contracts include a mechanism for pausing in case of an incident. Consider monitoring for Paused since an unexpected pause may cause a disruption in the system.  Financial  Medium: Consider monitoring the size, cadence and token type of bridge transfers during normal operations to establish a baseline of healthy properties. Any large deviation, such as an unexpectedly large withdrawal, may indicate unusual behavior of the contracts or an ongoing attack.", "html_url": "https://blog.openzeppelin.com/scroll-gasswap-multiple-verifier-wrapped-ether-and-diff-audit#monitoring-recommendations", "labels": ["OpenZeppelin"]}, {"title": "Abuse of Rate Limiter Mechanism to Perform DOS Attack", "body": "The Rate Limiting mechanism is an excellent safety mechanism to add to a bridge. However, in its current implementation, it can be abused by a malicious attacker to perform a denial-of-service on the system.  The rate limiter contracts ETHRateLimiter and TokenRateLimiter keep track of the amount of ETH or tokens that have been deposited in a certain time period. Every time a user makes an asset deposit or withdrawal, the total amount of their transaction is added to the total amount of the current time period. If the total amount of the current time period exceeds the maximum amount allowed, the transaction is reverted.  A malicious user can make a large deposit, withdraw, and repeat the process multiple times until the rate limiter reaches its total amount limit. This will prevent other users from making deposits or withdrawals from the protocol. The only cost for the malicious user would be the gas fees incurred. Once the amount limit is reached, it can only be updated by admins with the updateTotalLimit functions. Based on the responses to our inquiries with the Scroll team, it was communicated that the rate limiter updateTotalLimit functions will have a full-day delay before being executable. This would allow a malicious user to perform a DOS attack for 24 hours before the rate limiter can be updated and even then, the malicious user could keep repeating the DOS attack.  Consider adding an emergency 0-day execution of the rate limiter's updateTotalLimit function. This would allow the Scroll team to update the rate limiter in case there is a DOS attempt. We also recommend using short time periods for the rate limiter and adding the capability to turn on withdrawal fees that can be enabled during an attack to discourage malicious deposit-withdrawal cycling.  Update: Resolved, the Scroll team removed the delay for updating the limit total amount in pull request #838 at commit fd5dcda.  Low Severity", "html_url": "https://blog.openzeppelin.com/scrollowner-and-rate-limiter-audit#abuse-of-rate-limiter-mechanism-to-perform-dos-attack", "labels": ["OpenZeppelin"]}, {"title": "Missing Docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings. For instance:  Line 10 in ScrollOwner.sol  Line 13 in ETHRateLimiter.sol  Line 5 in IETHRateLimiter.sol  Line 5 in ITokenRateLimiter.sol  Line 13 in TokenRateLimiter.sol  Line 96 in TokenRateLimiter.sol  Line 13 in ITokenRateLimiter.sol  Consider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Acknowledged, will resolve. The Scroll team stated:  It will be fixed later on when we have more time.", "html_url": "https://blog.openzeppelin.com/scrollowner-and-rate-limiter-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Utilizing Deprecated Function From Library", "body": "The TokenRateLimiter contract is setting up its default admin role in the constructor using the _setupRole function. However, this function has been deprecated.  To avoid potential future incompatibilities with OpenZeppelin's contracts library, consider using the _grantRole method instead.  Update: Resolved in pull request #902 at commit daae8c4.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/scrollowner-and-rate-limiter-audit#utilizing-deprecated-function-from-library", "labels": ["OpenZeppelin"]}, {"title": "Variable Cast is Unnecessary", "body": "Within the ScrollOwner contract, the _target variable in the _execute function was unnecessarily cast.  To improve the overall clarity, intent, and readability of the codebase, consider removing this unnecessary cast.  Update: Resolved in pull request #903 at commit 9a69617.", "html_url": "https://blog.openzeppelin.com/scrollowner-and-rate-limiter-audit#variable-cast-is-unnecessary", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Function Visibility", "body": "In the ScrollOwner contract, the execute function is marked as public, while the _execute function has internal visibility.  The execute function should be marked as external because it is not called internally by any of the functions in the ScrollOwner contract.  The _execute function should be marked as private because it is implemented in the top-level ScrollOwner contract and is not intended to be called by the derived contracts.  To improve the overall clarity, intent, and readability of the codebase, consider fixing the visibility for these functions.  Update: Resolved in pull request #904 at commit 72d484c.", "html_url": "https://blog.openzeppelin.com/scrollowner-and-rate-limiter-audit#incorrect-function-visibility", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Usage of msg.sender", "body": "The ScrollOwner contract inherits from OpenZeppelin's AccessControl contract through its inheritance chain. This contract uses the _msgSender function.  Likewise, the ETHRateLimiter contract inherits from OpenZeppelin's Ownable contract. This contract also uses the _msgSender function.  The _msgSender function from OpenZeppelin's Context contract is used to allow the usage of metadata execution.  [1],  [2] instead of the  Consider standardizing the usage of the _msgSender function throughout the codebase to increase clarity and consistency.  Update: Resolved in pull request #906 at commit d0780e9.", "html_url": "https://blog.openzeppelin.com/scrollowner-and-rate-limiter-audit#inconsistent-usage-of-msg.sender", "labels": ["OpenZeppelin"]}, {"title": "Implicit Type Casting", "body": "ETHRateLimiter contract, the variables  compared. However,  _currentPeriod.lastUpdateTs's type is  _currentPeriodStart's type is  Consider explicitly type-casting variables of different types when they are compared or used in the same calculation. This ensures consistency in computations and reduces the risk of errors resulting from data loss.  Update: Resolved in pull request #907 at commit d0780e9.", "html_url": "https://blog.openzeppelin.com/scrollowner-and-rate-limiter-audit#implicit-type-casting", "labels": ["OpenZeppelin"]}, {"title": "Lack of Logs on Sensitive Actions", "body": "In the ScrollOwner contract, the updateAccess function can modify a role's access to calling specific function selectors on a target contract. Although this function will not interfere with users' actions, it is recommended to emit events to allow users to track changes to their permissions and monitor for any anomalies.  In the constructor of the ETHRateLimiter contract, the storage variable currentPeriod.limit is set without emitting the respective UpdateTotalLimit event.  Consider emitting events when changing state variables. Moreover, consider replacing the manual variable declarations in constructors with the corresponding function to update those variables.  Update: Resolved in pull request #908 at commit 0bb41be.", "html_url": "https://blog.openzeppelin.com/scrollowner-and-rate-limiter-audit#lack-of-logs-on-sensitive-actions", "labels": ["OpenZeppelin"]}, {"title": "Unpinned Compiler Version", "body": "ScrollOwner.sol, IETHRateLimiter.sol and ITokenRateLimiter.sol use an unpinned Solidity version.  Consider pinning the version of the Solidity compiler to match the pinned version in the other contracts. This should help prevent the introduction of unexpected bugs due to incompatible future releases.  Update: Partially resolved in pull request #909 at commit 0c5fbb7. IETHRateLimiter.sol and ITokenRateLimiter.sol still use an unpinned Solidity version.", "html_url": "https://blog.openzeppelin.com/scrollowner-and-rate-limiter-audit#unpinned-compiler-version", "labels": ["OpenZeppelin"]}, {"title": "Naming Issue", "body": "Naming Issue", "html_url": "https://blog.openzeppelin.com/scrollowner-and-rate-limiter-audit#naming-issue", "labels": ["OpenZeppelin"]}]