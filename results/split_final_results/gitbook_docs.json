[{"title": "First Swap #", "html_url": "https://uniswapv3book.com/docs/milestone_1/introduction/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Introduction   First Swap First Swap  # In this milestone, well build a pool contract that can receive liquidity from users and make swaps within a price range. To keep it as simple as possible, well provide liquidity only in one price range and well allow to make swaps only in one direction. Also, well calculate all the required math manually to get better intuition before starting using mathematical libs in Solidity. Lets model the situation well build: There will be an ETH/USDC pool contract. ETH will be the $x$ reserve, USDC will be the $y$ reserve. Well set the current price to 5000 USDC per 1 ETH. The range well provide liquidity into is 4545-5500 USDC per 1 ETH. Well buy some ETH from the pool. At this point, since we have only one price range, we want the price of the trade to stay within the price range. Visually, this model looks like this: Before getting to code, lets figure out the math and calculate all the parameters of the model. To keep things simple, Ill do math calculations in Python before implementing them in Solidity. This will allow us to focus on the math without diving into the nuances of math in Solidity. This also means that, in smart contracts, well hardcode all the amounts. This will allow us to start with a simple minimal viable product. For your convenience, I put all the Python calculations in  unimath.py . Youll find the complete code of this milestone in  this Github branch . If you have any questions feel free asking them in  the GitHub Discussion of this milestone !    \\[ \\] First Swap", "labels": ["Documentation"]}, {"title": "Second Swap #", "html_url": "https://uniswapv3book.com/docs/milestone_2/introduction/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Introduction   Second Swap Second Swap  # Alright, this is where it gets real. So far, our implementation has been looking too synthetic and static. We have calculated and hard coded all the amounts to make the learning curve less steep, and now were ready to make it dynamic. Were going to implement the second swap, that is a swap in the opposite direction: sell ETH to buy USDC. To do this, were going to improve our smart contracts significantly: We need to implement math calculations in Solidity. However, since implementing math in Solidity is tricky due to Solidity supporting only integer division, well use third-party libraries. Well need to let users choose swap direction, and the pool contract will need to support swapping in both directions. Well improve the contract and will bring it closer to multi-range swaps, which well implement in the next milestone. Finally, well update the UI to support swaps in both directions AND output amount calculation! This will require us implementing another contract, Quoter. In the end of this milestone, well have an app that works almost like a real DEX! Lets begin! Youll find the complete code of this chapter in  this Github branch . This milestone introduces a lot of code changes in existing contracts.  Here you can see all changes since the last milestone If you have any questions feel free asking them in  the GitHub Discussion of this milestone ! Second Swap", "labels": ["Documentation"]}, {"title": "Cross-tick Swaps #", "html_url": "https://uniswapv3book.com/docs/milestone_3/introduction/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Introduction   Cross-tick Swaps Cross-tick Swaps  # We have made a great progress so far and our Uniswap V3 implementation is quite close to the original one! However, our implementation only supports swaps within a price rangeand this is what were going to improve in this milestone. In this milestone, well: update  mint  function to provide liquidity in different price ranges; update  swap  function to cross price ranges when theres not enough liquidity in the current price range; learn how to calculate liquidity in smart contracts; implement slippage protection in  mint  and  swap  functions; update the UI application to allow to add liquidity at different price ranges; learn a little bit more about fixed-point numbers. In this milestone, well complete swapping, the core functionality of Uniswap! Lets begin! Youll find the complete code of this chapter in  this Github branch . This milestone introduces a lot of code changes in existing contracts.  Here you can see all changes since the last milestone If you have any questions feel free asking them in  the GitHub Discussion of this milestone ! Cross-tick Swaps", "labels": ["Documentation"]}, {"title": "Multi-pool Swaps #", "html_url": "https://uniswapv3book.com/docs/milestone_4/introduction/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Introduction   Multi-pool Swaps Multi-pool Swaps  # After implementing cross-tick swaps, weve got really close to real Uniswap V3 swaps. One significant limitation of our implementation is that it allows only swaps within a poolif theres no pool for a pair of tokens, then swapping between these tokens is not possible. This is not so in Uniswap since it allows multi-pool swaps. In this chapter, were going to add multi-pool swaps to our implementation. Heres the plan: first, well learn about and implement Factory contract; then, well see how chained or multi-pool swaps work and implement Path library; then, well update the front-end app to support multi-pool swaps; well implement a basic router that finds a path between two tokens; along the way, well also learn about tick spacing which is a way of optimizing swaps. After finishing this chapter, our implementation will be able to handle multi-pool swaps, for example, swapping WBTC for WETH via different stablecoins: WETH  USDC  USDT  WBTC. Lets begin! Youll find the complete code of this chapter in  this Github branch . This milestone introduces a lot of code changes in existing contracts.  Here you can see all changes since the last milestone If you have any questions feel free asking them in  the GitHub Discussion of this milestone ! Multi-pool Swaps", "labels": ["Documentation"]}, {"title": "Fees and Price Oracle #", "html_url": "https://uniswapv3book.com/docs/milestone_5/introduction/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Introduction   Fees and Price Oracle Fees and Price Oracle  # In this milestone, were going to add two new features to our Uniswap implementation. They share one similarity: they work on top of what we have already builtthats why weve delayed them until this milestone. However, theyre not equally important. Were going to add swap fees and a price oracle: Swap fees is a crucial mechanism of the DEX design were implementing. Theyre the glue that makes things stick together. Swap fees incentivize liquidity providers to provide liquidity, and no trades are possible without liquidity, as we have already learned. A price oracle, on the other hand, is an optional utility function of a DEX. A DEX, while conducting trades, can also function as a price oraclethat is, provide token prices to other services. This doesnt affect actual swaps but provides a useful service to other on-chain applications. Alright, lets get building! Youll find the complete code of this chapter in  this Github branch . This milestone introduces a lot of code changes in existing contracts.  Here you can see all changes since the last milestone If you have any questions feel free asking them in  the GitHub Discussion of this milestone ! Fees and Price Oracle", "labels": ["Documentation"]}, {"title": "NFT Positions #", "html_url": "https://uniswapv3book.com/docs/milestone_6/introduction/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Introduction   NFT Positions NFT Positions  # This is the cherry on the cake of this book. In this milestone, were going to learn how Uniswap contract can be extended and integrated into third-party protocols. This possibility is a direct consequence of having core contracts with only crucial functions, which allows to integrate them into other contracts without the need of adding new features to core contracts. A bonus feature of Uniswap V3 was the ability to turn liquidity positions into NFT tokens. Heres an example of one such NFT tokens: It shows token symbols, pool fee, position ID, lower and upper ticks, token addresses, and the segment of the curve the position is provided at. You can see all Uniswap V3 NFT positions in  this OpenSea collection . In this milestone, were going to add NFT-tokenization of liquidity positions! Lets go! Youll find the complete code of this chapter in  this Github branch . This milestone introduces a lot of code changes in existing contracts.  Here you can see all changes since the last milestone If you have any questions feel free asking them in  the GitHub Discussion of this milestone !    \\[ \\] NFT Positions", "labels": ["Documentation"]}, {"title": "Introduction to markets #", "html_url": "https://uniswapv3book.com/docs/introduction/introduction-to-markets/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Introduction to Markets   Introduction to markets How centralized exchanges work How decentralized exchanges work Automated Market Makers What is an AMM? Introduction to markets  # How centralized exchanges work  # In this book, well build a decentralized exchange (DEX) that will run on Ethereum. Therere multiple approaches to how an exchange can be designed. All centralized exchanges have  an order book  at their core. An order book is just a journal that stores all sell and buy orders that traders want to make. Each order in this book contains a price the order must be executed at and the amount that must be bought or sold. For trading to happen, there must exist  liquidity , which is simply the availability of assets on a market. If you want to buy a wardrobe but no one is selling one, theres no liquidity. If you want to sell a wardrobe but no one wants to buy it, theres liquidity but no buyers. If theres no liquidity, theres nothing to buy or sell. On centralized exchanges, the order book is where liquidity is accumulated. If someone places a sell order, they provide liquidity to the market. If someone places a buy order, they expected the market to have liquidity, otherwise, no trade is possible. When theres no liquidity, but markets are still interested in trades,  market makers  come into play. A market maker is a firm or an individual who provides liquidity to markets, that is someone who has a lot of money and who buys different assets to sell them on exchanges. For this job market makers are paid by exchanges.  Market makers make money on providing liquidity to exchanges . How decentralized exchanges work  # Dont be surprised, decentralized exchanges also need liquidity. And they also need someone who provides it to traders of a wide variety of assets. However, this process cannot be handled in a centralized way.  A decentralized solution must be found.  There are multiple decentralized solutions and some of them are implemented differently. Our focus will be on how Uniswap solves this problem. Automated Market Makers  # The evolution of on-chain markets  brought us to the idea of Automated Market Makers (AMM). As the name implies, this algorithm works exactly like market makers but in an automated way. Moreover, its decentralized and permissionless, that is: its not governed by a single entity; all assets are not stored in one place; anyone can use it from anywhere. What is an AMM?  # An AMM is a set of smart contracts that define how liquidity is managed. Each trading pair (e.g. ETH/USDC) is a separate contract that stores both ETH and USDC and thats programmed to mediate trades: exchanging ETH for USDC and vice versa. The core idea is  pooling : each contract is a  pool  that stores liquidity lets different users (including other smart contract) to trade in a permissioned way. There are two roles,  liquidity providers  and traders, and these roles interact with each other through pools of liquidity, and the way they can interact with pools is programmed and immutable. What makes this approach different from centralized exchanges is that  the smart contracts are fully automated and not managed by anyone . There are no managers, admins, privileged users, etc. There are only liquidity providers and traders (they can be the same people), and all the algorithms are programmed, immutable, and public. Lets now look closer at how Uniswap implements an AMM. Please note that I use  pool  and  pair  terms interchangeably throughout the book because a Uniswap pool is a pair of two tokens. If you have any questions feel free asking them in  the GitHub Discussion of this milestone ! Introduction to markets How centralized exchanges work How decentralized exchanges work Automated Market Makers What is an AMM?", "labels": ["Documentation"]}, {"title": "Calculating liquidity #", "html_url": "https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Calculating Liquidity   Calculating liquidity Price Range Calculation Token Amounts Calculation Liquidity Amount Calculation Token Amounts Calculation, Again Calculating liquidity  # Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract. Heres what we need to know to add liquidity to the pool contract: A price range. As a liquidity provider, we want to provide liquidity at a specific price range, and itll only be used in this range. Amount of liquidity, which is the amounts of two tokens. Well need to transfer these amounts to the pool contract. Here, were going to calculate these manually, but, in a later chapter, a contract will do this for us. Lets begin with a price range. Price Range Calculation  # Recall that, in Uniswap V3, the entire price range is demarcated into ticks: each tick corresponds to a price and has an index. In our first pool implementation, were going to buy ETH for USDC at the price of  $5000  per 1 ETH. Buying ETH will remove some amount of it from the pool and will push the price slightly above  $5000 . We want to provide liquidity at a range that includes this price. And we want to be sure that the final price will stay  within this range  (well do multi-range swaps in a later milestone). Well need to find three ticks: The current tick will correspond to the current price (5000 USDC for 1 ETH). The lower and upper bounds of the price range were providing liquidity into. Let the lower price be  $4545  and the upper price be  $5500 . From the theoretical introduction we know that: $$\\sqrt{P} = \\sqrt{\\frac{y}{x}}$$ Since weve agreed to use ETH as the $x$ reserve and USDC as the $y$ reserve, the prices at each of the ticks are: $$\\sqrt{P_c} = \\sqrt{\\frac{5000}{1}} = \\sqrt{5000} \\approx 70.71$$ $$\\sqrt{P_l} = \\sqrt{\\frac{4545}{1}} \\approx 67.42$$ $$\\sqrt{P_u} = \\sqrt{\\frac{5500}{1}} \\approx 74.16$$ Where $P_c$ is the current price, $P_l$ is the lower bound of the range, $P_u$ is the upper bound of the range. Now, we can find corresponding ticks. We know that prices and ticks are connected via this formula: $$\\sqrt{P(i)}=1.0001^{\\frac{i}{2}}$$ Thus, we can find tick $i$ via: $$i = log_{\\sqrt{1.0001}} \\sqrt{P(i)}$$ The square roots in this formula cancel out, but since were working with $\\sqrt{p}$ we need to preserve them. Lets find the ticks: Current tick: $i_c = log_{\\sqrt{1.0001}} 70.71 = 85176$ Lower tick: $i_l = log_{\\sqrt{1.0001}} 67.42 = 84222$ Upper tick: $i_u = log_{\\sqrt{1.0001}} 74.16 = 86129$ To calculate these, I used Python: import  math    def   price_to_tick (p):       return  math . floor(math . log(p,  1.0001 ))    price_to_tick( 5000 )  >   85176   Thats it for price range calculation! Last thing to note here is that Uniswap uses  Q64.96 number  to store $\\sqrt{P}$. This is a fixed point number that has 64 bits for the integer part and 96 bits for the fractional part. In our above calculations, prices are floating point numbers:  70.71 ,  67.42 ,  74.16 . We need to convert them to Q64.96. Luckily, this is simple: we need to multiply the numbers by $2^{96}$ (Q-number is a binary fixed point number, so we need to multiply our decimals numbers by the base of Q64.96, which is $2^{96}$). Well get: $$\\sqrt{P_c} = 5602277097478614198912276234240$$ $$\\sqrt{P_l} = 5314786713428871004159001755648$$ $$\\sqrt{P_u} = 5875717789736564987741329162240$$ In Python: q96  =   2 ** 96   def   price_to_sqrtp (p):       return  int(math . sqrt(p)  *  q96)    price_to_sqrtp( 5000 )  >   5602277097478614198912276234240   Notice that were multiplying before converting to integer. Otherwise, well lose precision. Token Amounts Calculation  # Next step is to decide how many tokens we want to deposit into the pool. The answer is: as many as we want. The amounts are not strictly defined, we can deposit as much as it is enough to buy a small amount of ETH without making the current price leave the price range we put liquidity into. During development and testing well be able to mint any amount of tokens, so getting the amounts we want is not a problem. For our first swap, lets deposit 1 ETH and 5000 USDC. Recall that the proportion of current pool reserves tells the current spot price. So if we want to put more tokens into the pool and keep the same price, the amounts must be proportional, e.g.: 2 ETH and 10,000 USDC; 10 ETH and 50,000 USDC, etc. Liquidity Amount Calculation  # Next, we need to calculate $L$ based on the amounts well deposit. This is a tricky part, so hold tight! From the theoretical introduction, you remember that: $$L = \\sqrt{xy}$$ However, this formula is for the infinite curve  But we want to put liquidity into a limited price range, which is just a segment of that infinite curve. We need to calculate $L$ specifically for the price range were going to deposit liquidity into. We need some more advanced calculations. To calculate $L$ for a price range, lets look at one interesting fact we have discussed earlier: price ranges can be depleted. Its absolutely possible to buy the entire amount of one token from a price range and leave the pool with only the other token. At the points $a$ and $b$, theres only one token in the range: ETH at the point $a$ and USDC at the point $b$. That being said, we want to find an $L$ that will allow the price to move to either of the points. We want enough liquidity for the price to reach either of the boundaries of a price range. Thus, we want $L$ to be calculated based on the maximum amounts of $\\Delta x$ and $\\Delta y$. Now, lets see what the prices are at the edges. When ETH is bought from a pool, the price is growing; when USDC is bought, the price is falling. Recall that the price is $\\frac{y}{x}$. So, at the point $a$, the price is lowest of the range; at the point $b$, the price is highest. In fact, prices are not defined at these points because theres only one reserve in the pool, but what we need to understand here is that the price around the point $b$ is higher than the start price, and the price at the point $a$ is lower than the start price. Now, break the curve from the image above into two segments: one to the left of the start point and one to the right of the start point. Were going to calculate  two  $L$s, one for each of the segments. Why? Because each of the two tokens of a pool contributes to  either of the segments : the left segment is made entirely of token $x$, the right segment is made entirely of token $y$. This comes from the fact that, during swapping, the price moves in either direction: its either growing or falling. For the price to move, only either of the tokens is needed: when the price is growing, only token $x$ is needed for the swap (were buying token $x$, so we want to take only token $x$ from the pool); when the price is falling, only token $y$ is needed for the swap. Thus, the liquidity in the segment of the curve to the left of the current price consists only of token $x$ and is calculated only from the amount of token $x$ provided. And, similarly, the liquidity in the segment of the curve to the right of the current price consists only of token $y$ and is calculated only from the amount of token $y$ provided. This is why, when providing liquidity, we calculate two $L$s and pick one of them. Which one? The smaller one. Why? Because the bigger one already includes the smaller one! We want the new liquidity to be distributed  evenly  along the curve, thus we want to add the same $L$ to the left and to the right of the current price. If we pick the bigger one, the user would need to provide more liquidity to compensate the shortage in the smaller one. This is doable, of course, but this would make the smart contract more complex. What happens with the remainder of the bigger $L$? Well, nothing. After picking the smaller $L$ we can simply convert it to a smaller amount of the token that resulted in the bigger $L$this will adjust it down. After that, well have token amounts that will result in the same $L$. And the final detail I need to focus your attention on here is:  new liquidity must not change the current price . That is, it must be proportional to the current proportion of the reserves. And this is why the two $L$s can be differentwhen the proportion is not preserved. And we pick the small $L$ to reestablish the proportion. I hope this will make more sense after we implement this in code! Now, lets look at the formulas. Lets recall how $\\Delta x$ and $\\Delta y$ are calculated: $$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}} L$$ $$\\Delta y = \\Delta \\sqrt{P} L$$ We can expands these formulas by replacing the delta Ps with actual prices (we know them from the above): $$\\Delta x = (\\frac{1}{\\sqrt{P_c}} - \\frac{1}{\\sqrt{P_b}}) L$$ $$\\Delta y = (\\sqrt{P_c} - \\sqrt{P_a}) L$$ $P_a$ is the price at the point $a$, $P_b$ is the price at the point $b$, and $P_c$ is the current price (see the above chart). Notice that, since the price is calculated as $\\frac{y}{x}$ (i.e. its the price of $x$ in terms of $y$), the price at point $b$ is higher than the current price and the price at $a$. The price at $a$ is the lowest of the three. Lets find the $L$ from the first formula: $$\\Delta x = (\\frac{1}{\\sqrt{P_c}} - \\frac{1}{\\sqrt{P_b}}) L$$ $$\\Delta x = \\frac{L}{\\sqrt{P_c}} - \\frac{L}{\\sqrt{P_b}}$$ $$\\Delta x = \\frac{L(\\sqrt{P_b} - \\sqrt{P_c})}{\\sqrt{P_b} \\sqrt{P_c}}$$ $$L = \\Delta x \\frac{\\sqrt{P_b} \\sqrt{P_c}}{\\sqrt{P_b} - \\sqrt{P_c}}$$ And from the second formula: $$\\Delta y = (\\sqrt{P_c} - \\sqrt{P_a}) L$$ $$L = \\frac{\\Delta y}{\\sqrt{P_c} - \\sqrt{P_a}}$$ So, these are our two $L$s, one for each of the segments: $$L = \\Delta x \\frac{\\sqrt{P_b} \\sqrt{P_c}}{\\sqrt{P_b} - \\sqrt{P_c}}$$ $$L = \\frac{\\Delta y}{\\sqrt{P_c} - \\sqrt{P_a}}$$ Now, lets plug the prices we calculated earlier into them: $$L = \\Delta x \\frac{\\sqrt{P_b}\\sqrt{P_c}}{\\sqrt{P_b}-\\sqrt{P_c}} = 1 ETH * \\frac{5875 * 5602}{5875 - 5602}$$ After converting to Q64.96, we get: $$L = 1519437308014769733632$$ And for the other $L$: $$L = \\frac{\\Delta y}{\\sqrt{P_c}-\\sqrt{P_a}} = \\frac{5000USDC}{5602 - 5314}$$ $$L = 1517882343751509868544$$ Of these two, well pick the smaller one. In Python: sqrtp_low  =  price_to_sqrtp( 4545 )  sqrtp_cur  =  price_to_sqrtp( 5000 )  sqrtp_upp  =  price_to_sqrtp( 5500 )    def   liquidity0 (amount, pa, pb):       if  pa  >  pb:          pa, pb  =  pb, pa       return  (amount  *  (pa  *  pb)  /  q96)  /  (pb  -  pa)    def   liquidity1 (amount, pa, pb):       if  pa  >  pb:          pa, pb  =  pb, pa       return  amount  *  q96  /  (pb  -  pa)    eth  =   10 ** 18   amount_eth  =   1   *  eth  amount_usdc  =   5000   *  eth    liq0  =  liquidity0(amount_eth, sqrtp_cur, sqrtp_upp)  liq1  =  liquidity1(amount_usdc, sqrtp_cur, sqrtp_low)  liq  =  int(min(liq0, liq1))  >   1517882343751509868544   Token Amounts Calculation, Again  # Since we choose the amounts were going to deposit, the amounts can be wrong. We cannot deposit any amounts at any price ranges; liquidity amount needs to be distributed evenly along the curve of the price range were depositing into. Thus, even though users choose amounts, the contract needs to re-calculate them, and actual amounts will be slightly different (at least because of rounding). Luckily, we already know the formulas: $$\\Delta x = \\frac{L(\\sqrt{P_b} - \\sqrt{P_c})}{\\sqrt{P_b} \\sqrt{P_c}}$$ $$\\Delta y = L(\\sqrt{P_c} - \\sqrt{P_a})$$ In Python: def   calc_amount0 (liq, pa, pb):       if  pa  >  pb:          pa, pb  =  pb, pa       return  int(liq  *  q96  *  (pb  -  pa)  /  pa  /  pb)      def   calc_amount1 (liq, pa, pb):       if  pa  >  pb:          pa, pb  =  pb, pa       return  int(liq  *  (pb  -  pa)  /  q96)    amount0  =  calc_amount0(liq, sqrtp_upp, sqrtp_cur)  amount1  =  calc_amount1(liq, sqrtp_low, sqrtp_cur)  (amount0, amount1)  >  ( 998976618347425408 ,  5000000000000000000000 )  As you can see, the number are close to the amounts we want to provide, but ETH is slightly smaller. Hint : use  cast --from-wei AMOUNT  to convert from wei to ether, e.g.: cast --from-wei 998976618347425280  will give you  0.998976618347425280 .    \\[ \\] Calculating liquidity Price Range Calculation Token Amounts Calculation Liquidity Amount Calculation Token Amounts Calculation, Again", "labels": ["Documentation"]}, {"title": "Constant Function Market Makers #", "html_url": "https://uniswapv3book.com/docs/introduction/constant-function-market-maker/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Constant Function Market Makers   Constant Function Market Makers The trade function Pricing The Curve Constant Function Market Makers  # This chapter retells  the whitepaper of Uniswap V2 . Understanding this math is crucial to build a Uniswap-like DEX, but its totally fine if you dont understand everything at this stage. As I mentioned in the previous section, there are different approaches to building AMM. Well be focusing on and building one specific type of AMMConstant Function Market Maker. Dont be scared by the long name! At its core is a very simple mathematical formula: $$x * y = k$$ Thats it, this is the AMM. $x$ and $y$ are pool contract reservesthe amounts of tokens it currently holds.  k  is just their product, actual value doesnt matter. Why there are only two reserves,  x  and  y ? Each Uniswap pool can hold only two tokens. We use  x  and  y  to refer to reserves of one pool, where  x  is the reserve of the first token and  y  is the reserve of the other token, and the order doesnt matter. The constant function formula says:  after each trade,  k  must remain unchanged . When traders make trades, they put some amount of one token into a pool (the token they want to sell) and remove some amount of the other token from the pool (the token they want to buy). This changes the reserves of the pool, and the constant function formula says that  the product  of reserves must not change. As we will see many times in this book, this simple requirement is the core algorithm of how Uniswap works. The trade function  # Now that we know what pools are, lets write the formula of how trading happens in a pool: $$(x + r\\Delta x)(y - \\Delta y) = k$$ Theres a pool with some amount of token 0 ($x$) and some amount of token 1 ($y$) When we buy token 1 for token 0, we give some amount of token 0 to the pool ($\\Delta x$). The pool gives us some amount of token 1 in exchange ($\\Delta y$). The pool also takes a small fee ($r = 1 - \\text{swap fee}$) from the amount of token 0 we gave. The reserve of token 0 changes ($x + r \\Delta x$), and the reserve of token 1 changes as well ($y - \\Delta y$). The product of updated reserves must still equal $k$. Well use token 0 and token 1 notation for the tokens because this is how theyre referenced in the code. At this point, it doesnt matter which of them is 0 and which is 1. Were basically giving a pool some amount of token 0 and getting some amount of token 1. The job of the pool is to give us a correct amount of token 1 calculated at a fair price. This leads us to the following conclusion:  pools decide what trade prices are . Pricing  # How do we calculate the prices of tokens in a pool? Since Uniswap pools are separate smart contracts,  tokens in a pool are priced in terms of each other . For example: in a ETH/USDC pool, ETH is priced in terms of USDC and USDC is priced in terms of ETH. If 1 ETH costs 1000 USDC, then 1 USDC costs 0.001 ETH. The same is true for any other pool, whether its a stablecoin pair or not (e.g. ETH/BTC). In the real world, everything is priced based on  the law of supply and demand . This also holds true for AMMs. Well put the demand part aside for now and focus on supply. The prices of tokens in a pool are determined by the supply of the tokens, that is by  the amounts of reserves of the tokens  that the pool is holding. Token prices are simply relations of reserves: $$P_x = \\frac{y}{x}, \\quad P_y=\\frac{x}{y}$$ Where $P_x$ and $P_y$ are prices of tokens in terms of the other token. Such prices are called  spot prices  and they only reflect current market prices. However, the actual price of a trade is calculated differently. And this is where we need to bring the demand part back. Concluding from the law of supply and demand,  high demand increases the price and this is a property we need to have in a permissionless system. We want the price to be high when demand is high, and we can use pool reserves to measure the demand: the more tokens you want to remove from a pool (relative to pools reserves), the higher the impact of demand is. Lets return to the trade formula and look at it closer: $$(x + r\\Delta x)(y - \\Delta y) = xy$$ As you can see, we can derive $\\Delta x$ and $\\Delta y$ from it, which means we can calculate the output amount of a trade based on the input amount and vice versa: $$\\Delta y = \\frac{yr\\Delta x}{x + r\\Delta x}$$ $$\\Delta x = \\frac{x \\Delta y}{r(y - \\Delta y)}$$ In fact, these formulas free us from calculating prices! We can always find the output amount using the $\\Delta y$ formula (when we want to sell a known amount of tokens) and we can always find the input amount using the $\\Delta x$ formula (when we want to buy a known amount of tokens). Notice that each of these formulas is a relation of reserves ($x/y$ or $y/x$) and they also take the trade amount ($\\Delta x$ in the former and $\\Delta y$ in the latter) into consideration.  These are the pricing functions that respect both supply and demand . And we dont even need to calculate the prices! Heres how you can derive the above formulas from the trade function: $$(x + r\\Delta x)(y - \\Delta y) = xy$$ $$y - \\Delta y = \\frac{xy}{x + r\\Delta x}$$ $$-\\Delta y = \\frac{xy}{x + r\\Delta x} - y$$ $$-\\Delta y = \\frac{xy - y({x + r\\Delta x})}{x + r\\Delta x}$$ $$-\\Delta y = \\frac{xy - xy - y r \\Delta x}{x + r\\Delta x}$$ $$-\\Delta y = \\frac{- y r \\Delta x}{x + r\\Delta x}$$ $$\\Delta y = \\frac{y r \\Delta x}{x + r\\Delta x}$$ And: $$(x + r\\Delta x)(y - \\Delta y) = xy$$ $$x + r\\Delta x = \\frac{xy}{y - \\Delta y}$$ $$r\\Delta x = \\frac{xy}{y - \\Delta y} - x$$ $$r\\Delta x = \\frac{xy - x(y - \\Delta y)}{y - \\Delta y}$$ $$r\\Delta x = \\frac{xy - xy + x \\Delta y}{y - \\Delta y}$$ $$r\\Delta x = \\frac{x \\Delta y}{y - \\Delta y}$$ $$\\Delta x = \\frac{x \\Delta y}{r(y - \\Delta y)}$$ The Curve  # The above calculations might seem too abstract and dry. Lets visualize the constant product function to better understand how it works. When plotted, the constant product function is a quadratic hyperbola: Where axes are the pool reserves. Every trade starts at the point on the curve that corresponds to the current ratio of reserves. To calculate the output amount, we need to find a new point on the curve, which has the $x$ coordinate of $x+\\Delta x$, i.e. current reserve of token 0 + the amount were selling. The change in $y$ is the amount of token 1 well get. Lets look at a concrete example: The purple line is the curve, the axes are the reserves of a pool (notice that theyre equal at the start price). Start price is 1. Were selling 200 of token 0. If we use only the start price, we expect to get 200 of token 1. However, the execution price is 0.666, so we get only 133.333 of token 1! This example is from  the Desmos chart  made by  Dan Robinson , one of the creators of Uniswap. To build a better intuition of how it works, try making up different scenarios and plotting them on the graph. Try different reserves, see how output amount changes when $\\Delta x$ is small relative to $x$. As the legend goes, Uniswap was invented in Desmos. I bet youre wondering why using such a curve? It might seem like it punishes you for trading big amounts. This is true, and this is a desirable property! The law of supply and demand tells us that when demand is high (and supply is constant) the price is also high. And when demand is low, the price is also lower. This is how markets work. And, magically, the constant product function implements this mechanism! Demand is defined by the amount you want to buy, and supply is the pool reserves. When you want to buy a big amount relative to pool reserves the price is higher than when you want to buy a smaller amount. Such a simple formula guarantees such a powerful mechanism! Even though Uniswap doesnt calculate trade prices, we can still see them on the curve. Surprisingly, there are multiple prices when making a trade: Before a trade, theres  a spot price . Its equal to the relation of reserves, $y/x$ or $x/y$ depending on the direction of the trade. This price is also  the slope of the tangent line  at the starting point. After a trade, theres a new spot price, at a different point on the curve. And its the slope of the tangent line at this new point. The actual price of the trade is the slope of the line connecting the two points! And thats the whole math of Uniswap! Phew! Well, this is the math of Uniswap V2, and were studying Uniswap V3. So in the next part, well see how the mathematics of Uniswap V3 is different.    \\[ \\] Constant Function Market Makers The trade function Pricing The Curve", "labels": ["Documentation"]}, {"title": "Different Price Ranges #", "html_url": "https://uniswapv3book.com/docs/milestone_3/different-ranges/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Different Price Ranges   Different Price Ranges Limit Orders Updating  mint  Function Different Price Ranges  # The way we implemented it, our Pool contract creates only price ranges that include the current price: // src/UniswapV3Pool.sol  function   mint (      ...      amount0  =  Math.calcAmount0Delta(          slot0_.sqrtPriceX96,          TickMath.getSqrtRatioAtTick(upperTick),          amount      );        amount1  =  Math.calcAmount1Delta(          slot0_.sqrtPriceX96,          TickMath.getSqrtRatioAtTick(lowerTick),          amount      );        liquidity  +=   uint128 (amount);      ...  }  From this piece you can also see that we always update the liquidity tracker (which tracks only currently available liquidity, i.e. liquidity available at the current price). However, in reality, price ranges can also be created  below or above  the current price. Thats it: the design of Uniswap V3 allows liquidity provider to provide liquidity that doesnt get immediately used. Such liquidity gets injected when current price gets into such sleeping price ranges. These are kinds of price ranges that can exist: Active price range, i.e. one that includes current price. Price range placed below current price. The upper tick of this range is below the current tick. Price range placed above current price. The lower tick of this range is above the current tick. Limit Orders  # An interesting fact about inactive liquidity (i.e. liquidity not provided at current price) is that it acts as  limit orders . In trading, limit orders are orders that get executed when price crosses a level chosen by trader. For example, you can place a limit order that buys 1 ETH when its price drops to $1000. Similarly, you can use limit order to sell assets. With Uniswap V3, you can get similar behavior by placing liquidity at ranges that are below or above current price. Lets see how this works: If you provide liquidity below current price (i.e. the price range you chose lays entirely below the current price) or above it, then your whole liquidity will be composed of  only one asset the asset will be the cheaper one of the two. In our example, were building a pool with ETH being token $x$ and USDC being token $y$, and we define the price as: $$P = \\frac{y}{x}$$ If we put liquidity below current price, then the liquidity will be composed of USDC solely because, where we added the liquidity, the price of USDC is lower than the current price. Likewise, when we put liquidity above current price, then the liquidity will be composed of ETH because ETH is cheaper in that range. Recall this illustration from the introduction: If we buy all available amount of ETH from this range, the range will contain only the other token, USDC, and the price will move to the right of the curve. The price, as we defined it ($\\frac{y}{x}$), will  increase . If theres a price range to the right of this one, it needs to have ETH liquidity, and only ETH, not USDC: it needs to provide ETH for next swaps. If we keep buying and rising the price, we might drain the next price range as well, which means buying all its ETH and selling USDC. Again, the price range ends up having only USDC and current price moves outside of it. Similarly, if were buying USDC token, we move the price to the left and removing USDC tokens from the pool. The next price range will only contain USDC tokens to satisfy our demand, and, similarly to the above scenario, will end up containing only ETH tokens if we buy all USDC from it. Note the interesting fact: when crossing an entire price range, its liquidity is swapped from one token to another. And if we set a very narrow price range, one that gets crossed quickly during a price move, we get a limit order! For example, if you want to buy ETH at a lower price, you need to place a price range containing only USDC at the lower price and wait for current price to cross it. After that, youll need to remove your liquidity and get it whole converted to ETH! I hope this example didnt confuse you! I think this is good way to explain the dynamics of price ranges. Updating  mint  Function  # To support all the kinds of price ranges, we need to know whether the current price is below, inside, or above the price range specified by user and calculate token amounts accordingly. If the price range is above the current price, we want the liquidity to be composed of token $x$: // src/UniswapV3Pool.sol  function   mint (      ...       if  (slot0_.tick  <  lowerTick) {          amount0  =  Math.calcAmount0Delta(              TickMath.getSqrtRatioAtTick(lowerTick),              TickMath.getSqrtRatioAtTick(upperTick),              amount          );      ...  When the price range includes the current price, we want both tokens in amounts proportional to the price (this is the scenario we implemented earlier): }  else   if  (slot0_.tick  <  upperTick) {      amount0  =  Math.calcAmount0Delta(          slot0_.sqrtPriceX96,          TickMath.getSqrtRatioAtTick(upperTick),          amount      );        amount1  =  Math.calcAmount1Delta(          slot0_.sqrtPriceX96,          TickMath.getSqrtRatioAtTick(lowerTick),          amount      );        liquidity  =  LiquidityMath.addLiquidity(liquidity,  int128 (amount));  Notice that this is the only scenario where we want to update  liquidity  since the variable tracks liquidity thats available immediately. In all other cases, when the price range is below the current price, we want the range to contain only token $y$: }  else  {      amount1  =  Math.calcAmount1Delta(          TickMath.getSqrtRatioAtTick(lowerTick),          TickMath.getSqrtRatioAtTick(upperTick),          amount      );  }  And thats it!    \\[ \\] Different Price Ranges Limit Orders Updating  mint  Function", "labels": ["Documentation"]}, {"title": "ERC721 Overview #", "html_url": "https://uniswapv3book.com/docs/milestone_6/erc721-overview/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   ERC721 Overview   ERC721 Overview ERC721 Overview  # Lets begin with an overview of  EIP-721 , the standard that defines NFT contracts. ERC721 is a variant of ERC20. The main difference between them is that ERC721 tokens are  non-fungible , that is: one token is not identical to another. To distinguish ERC721 tokens, each of them has a unique ID, which is almost always the counter at which a token was minted. ERC721 tokens also have an extended concept of ownership: owner of each token is tracked and stored in the contract. This means that only distinct tokens, identified by token IDs, can be transferred (or approved for transfer). What Uniswap V3 liquidity positions and NFTs have in common is this non-fungibility: NFTs and liquidity positions are not interchangeable and are identified by unique IDs. Its this similarity that will allow us to merge the two concepts. The biggest difference between ERC20 and ERC721 is the  tokenURI  function in the latter. NFT tokens, which are implemented as ERC721 smart contracts, have linked assets that are stored externally, not on blockchain. To link token IDs to images (or sounds, or anything else) stored outside of blockchain, ERC721 defines the  tokenURI  function. The function is expected to return a link to a JSON file that defines NFT token metadata, e.g.: {       \"name\" :  \"Thor's hammer\" ,       \"description\" :  \"Mjlnir, the legendary hammer of the Norse god of thunder.\" ,       \"image\" :  \"https://game.example/item-id-8u5h2m.png\" ,       \"strength\" :  20   }  (This example is taken from the  ERC721 documentation on OpenZeppelin ) Such JSON file defines: the name of a token, the description of a collection, the link to the image of a token, properties of a token. Alternatively, we may store JSON metadata and token images on-chain. This is very expensive of course (saving data on-chain is the most expensive operation in Ethereum), but we can make it cheaper if we store templates. All tokens within a collection have similar metadata (mostly identical but image links and properties are different for each token) and visuals. For the latter, we can use SVG, which is an HTML-like format, and HTML is a good templating language. When storing JSON metadata and SVG on-chain, the  tokenURI  function, instead of returning a link, would return JSON metadata directly, using the  data URI scheme  to encode it. SVG images would also be inlined, it wont be necessary making external requests to download token metadata and image. ERC721 Overview", "labels": ["Documentation"]}, {"title": "Factory Contract #", "html_url": "https://uniswapv3book.com/docs/milestone_4/factory-contract/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Factory Contract   Factory Contract CREATE  and  CREATE2  Opcodes Tick Spacing Factory Implementation Pool Initialization PoolAddress  Library Simplified Interfaces of Manager and Quoter Factory Contract  # Uniswap is designed in a way that assumes many discrete Pool contracts, with each pool handling swaps of one token pair. This looks problematic when we want to swap between two tokens that dont have a poolif theres no pool, no swaps are possible. However, we can still do intermediate swaps: first swap to a token that has pairs with either of the tokens and then swap this token to the target token. This can also go deeper and have more intermediate tokens. However, doing this manually is cumbersome, and, luckily, we can make the process easier by implementing it in our smart contracts. Factory  contract is a contract that serves multiple purposes: It acts as a centralized registry of Pool contracts. Using a factory, you can find all deployed pools, their tokens, and addresses. It simplifies deployment of Pool contracts. EVM allows to deploy smart contracts from smart contractsFactory uses this feature to make pools deployment a breeze. It makes pool addresses predictable and allows to compute them without making calls to the registry. This makes pools easily discoverable. Lets build Factory contract! But before doing this, we need to learn something new. CREATE  and  CREATE2  Opcodes  # EVM has two ways of deploying contracts: via  CREATE  or via  CREATE2  opcode. The only difference between them is how new contract address is generated: CREATE  uses deployers account  nonce  to generate a contract address (in pseudocode): KECCAK256(deployer.address, deployer.nonce)  nonce  is an account-specific counter of transactions. Using  nonce  in new contract address generation makes it hard to compute an address in other contracts or off-chain apps, mainly because, to find the nonce a contract was deployed at, one needs to scan historical account transactions. CREATE2  uses a custom  salt  to generate a contract address. This is just an arbitrary sequence of bytes chosen by a developer, which is used to make address generation deterministic (and reduces the chance of a collision). KECCAK256(deployer.address, salt, contractCodeHash)  We need to know the difference because Factory uses  CREATE2  when deploying Pool contracts so pools get unique and deterministic addresses that can be computed in other contracts and off-chain apps. Specifically, for salt, Factory computes a hash using these pool parameters: keccak256(abi.encodePacked(token0, token1, tickSpacing))  token0  and  token1  are the addresses of pool tokens, and  tickSpacing  is something were going to learn about next. Tick Spacing  # Recall the loop in  swap  function: while  (      state.amountSpecifiedRemaining  >   0   &&       state.sqrtPriceX96  !=  sqrtPriceLimitX96  ) {      ...      (step.nextTick, )  =  tickBitmap.nextInitializedTickWithinOneWord(...);      (state.sqrtPriceX96, step.amountIn, step.amountOut)  =  SwapMath.computeSwapStep(...);      ...  }  This loop finds initialized ticks that have some liquidity by iterating them in either of the directions. This iterating, however, is an expensive operation: if a tick is far away, the code would need to pass all the ticks between the current and the target one, which consumes gas. To make this loop more gas-efficient, Uniswap pools have  tickSpacing  setting, which sets, as the name suggest, the distance between ticks: the wider the distance, the more gas efficient swaps are. However, the wider a tick spacing the lower the precision. Low volatility pairs (e.g. stablecoin pairs) need higher precision because price movements are narrow in such pairs. Medium and high volatility pairs need lower precision since price movement are wide in such pairs. To handle this diversity, Uniswap allows to pick a tick spacing when a pair is deployed. Uniswap allows deployers to choose from these options: 10, 60, or 200. And well have only 10 and 60 for simplicity. In technical terms, tick indexes can only be multiples of  tickSpacing : if  tickSpacing  is 10, only multiples of 10 will be valid as tick indexes (10, 20, 5000, 5010, but not 8, 12, 5001, etc.). However, and this is important, this doesnt apply to the current priceit can still be any tick because we want it to be as precise as possible.  tickSpacing  is only applied to price ranges. Thus, each pool is uniquely identified by this set of parameters: token0 , token1 , tickSpacing ; And, yes, there can be pools with the same tokens but different tick spacings. Factory contract uses this set of parameters as a unique identifier of a pool and passes it as a salt to generate a new pool contract address. From now on, well assume the tick spacing of 60 for all our pools, and well use 10 for stablecoin pairs. Factory Implementation  # In the constructor of Factory, we need to initialize supported tick spacings: // src/UniswapV3Factory.sol  contract   UniswapV3Factory   is  IUniswapV3PoolDeployer {       mapping ( uint24   =>   bool )  public  tickSpacings;       constructor () {          tickSpacings[ 10 ]  =   true ;          tickSpacings[ 60 ]  =   true ;      }        ...  We couldve made them constants, but well need to have it as a mapping for a later milestone (tick spacings will have different swap fee amounts). Factory contract is a contract with only one function  createPool . The function begins with necessary checks we need to make before creating a pool: // src/UniswapV3Factory.sol  contract   UniswapV3Factory   is  IUniswapV3PoolDeployer {      PoolParameters  public  parameters;       mapping ( address   =>   mapping ( address   =>   mapping ( uint24   =>   address )))           public  pools;        ...         function   createPool (           address  tokenX,           address  tokenY,           uint24  tickSpacing      )  public   returns  ( address  pool) {           if  (tokenX  ==  tokenY) revert TokensMustBeDifferent();           if  ( ! tickSpacings[tickSpacing]) revert UnsupportedTickSpacing();            (tokenX, tokenY)  =  tokenX  <  tokenY               ?  (tokenX, tokenY)               :  (tokenY, tokenX);             if  (tokenX  ==   address ( 0 )) revert TokenXCannotBeZero();           if  (pools[tokenX][tokenY][tickSpacing]  !=   address ( 0 ))              revert PoolAlreadyExists();                    ...  Notice that this is first time when were sorting tokens: (tokenX, tokenY)  =  tokenX  <  tokenY       ?  (tokenX, tokenY)       :  (tokenY, tokenX);  From now on, well also expect pool token addresses to be sorted, i.e.  token0  goes before  token1  when sorted. Well enforce this to make salt (and pool addresses) computation consistent. This change also affects how we deploy tokens in tests and the deployment script: we need to ensure that WETH is always  token0  to make price calculations simpler in Solidity (otherwise, wed need to use fractional prices, like 1/5000). If WETH is not  token0  in your tests, change the order of token deployments. After that, we prepare pool parameters and deploy a pool: parameters  =  PoolParameters({      factory :   address (this),      token0 :  tokenX,      token1 :  tokenY,      tickSpacing :  tickSpacing  });    pool  =   address (       new  UniswapV3Pool{          salt :  keccak256(abi.encodePacked(tokenX, tokenY, tickSpacing))      }()  );    delete  parameters;  This piece looks weird because  parameters  is not used. Uniswap uses  Inversion of Control  to pass parameters to a pool during deployment. Lets look at updated Pool contract constructor: // src/UniswapV3Pool.sol  contract   UniswapV3Pool   is  IUniswapV3Pool {      ...       constructor () {          (factory, token0, token1, tickSpacing)  =  IUniswapV3PoolDeployer(              msg.sender          ).parameters();      }      ..  }  Aha! Pool expects its deployer to implement  IUniswapV3PoolDeployer  interface (which only defines the  parameters()  getter) and calls it in the constructor during deployment to get the parameters. This is what the flow looks like: Factory : defines  parameters  state variable (implements  IUniswapV3PoolDeployer ) and sets it before deploying a pool. Factory : deploys a pool. Pool : in the constructor, calls  parameters()  function on its deployer and expects that pool parameters are returned. Factory : calls  delete parameters;  to clean up the slot of  parameters  state variable and to reduce gas consumption. This is a temporary state variable that has a value only during a call to  createPool() . After a pool is created, we keep it in the  pools  mapping (so it can be found by its tokens) and emit an event:     pools[tokenX][tokenY][tickSpacing]  =  pool;      pools[tokenY][tokenX][tickSpacing]  =  pool;        emit PoolCreated(tokenX, tokenY, tickSpacing, pool);  }  Pool Initialization  # As you have noticed from the code above, we no longer set  sqrtPriceX96  and  tick  in Pools constructorthis is now done in a separate function,  initialize , that needs to be called after pool is deployed: // src/UniswapV3Pool.sol  function   initialize ( uint160  sqrtPriceX96)  public  {       if  (slot0.sqrtPriceX96  !=   0 ) revert AlreadyInitialized();         int24  tick  =  TickMath.getTickAtSqrtRatio(sqrtPriceX96);        slot0  =  Slot0({sqrtPriceX96 :  sqrtPriceX96, tick :  tick});  }  So this is how we deploy pools now: UniswapV3Factory factory  =   new  UniswapV3Factory();  UniswapV3Pool pool  =  UniswapV3Pool(factory.createPool(token0, token1, tickSpacing));  pool.initialize(sqrtP(currentPrice));  PoolAddress  Library  # Lets now implement a library that will help us calculate pool contract addresses from other contracts. This library will have only one function,  computeAddress : // src/lib/PoolAddress.sol  library  PoolAddress {       function   computeAddress (           address  factory,           address  token0,           address  token1,           uint24  tickSpacing      )  internal   pure   returns  ( address  pool) {          require(token0  <  token1);          ...  The function needs to know pool parameters (theyre used to build a salt) and Factory contract address. It expects the tokens to be sorted, which we discussed above. Now, the core of the function: pool  =   address (       uint160 (           uint256 (              keccak256(                  abi.encodePacked(                       hex\"ff\" ,                      factory,                      keccak256(                          abi.encodePacked(token0, token1, tickSpacing)                      ),                      keccak256(type( UniswapV3Pool ).creationCode)                  )              )          )      )  );  This is what  CREATE2  does under the hood to calculate new contract address. Lets unwind it: first, we calculate salt ( abi.encodePacked(token0, token1, tickSpacing) ) and hash it; then, we obtain Pool contract code ( type(UniswapV3Pool).creationCode ) and also hash it; then, we build a sequence of bytes that includes:  0xff , Factory contract address, hashed salt, and hashed Pool contract code; we then hash the sequence and convert it to an address. These steps implement contract address generation as its defined in  EIP-1014 , which is the EIP that added  CREATE2  opcode. Lets look closer at the values that constitute the hashed byte sequence: 0xff , as defined in the EIP, is used to distinguish addresses generated by  CREATE  and  CREATE2 ; factory  is the address of the deployer, in our case a Factory contract; salt was discussed earlierit uniquely identifies a pool; hashed contract code is needed to protect from collisions: different contracts can have the same salt, but their code hash will be different. So, according to this scheme, a contract address is a hash of the values that uniquely identify this contract, including its deployer, code, and unique parameters. We can use this function from anywhere to find out a pool address without making any external calls and without querying the factory. Simplified Interfaces of Manager and Quoter  # In Manager and Quoter contracts, we no longer need to ask users for pool address! This makes interaction with the contracts easier because users dont need to know pool addresses, they only need to know tokens. However, users also need to specify tick spacing because its included in pools salt. Moreover, we no longer need to ask users for the  zeroForOne  flag because we can now always figure it out thanks to tokens sorting.  zeroForOne  is true when from token is less than to token, since pools  token0  is always less than  token1 . Likewise,  zeroForOne  is always false when from token is greater than to token. Addresses are hashes, and hashes are numbers, so we can say less than or greater that when comparing addresses. Factory Contract CREATE  and  CREATE2  Opcodes Tick Spacing Factory Implementation Pool Initialization PoolAddress  Library Simplified Interfaces of Manager and Quoter", "labels": ["Documentation"]}, {"title": "Output Amount Calculation #", "html_url": "https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Output Amount Calculation   Output Amount Calculation Output Amount Calculation  # Our collection of Uniswap math formulas lacks a final piece: the formula of calculating the output amount when selling ETH (that is: selling token $x$). In the previous milestone, we had an analogous formula for the scenario when ETH is bought (buying token $x$): $$\\Delta \\sqrt{P} = \\frac{\\Delta y}{L}$$ This formula finds the change in the price when selling token $y$. We then added this change to the current price to find the target price: $$\\sqrt{P_{target}} = \\sqrt{P_{current}} + \\Delta \\sqrt{P}$$ Now, we need a similar formula to find the target price when selling token $x$ (ETH in our case) and buying token $y$ (USDC in our case). Recall that the change in token $x$ can be calculated as: $$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}}L$$ From this formula, we can find the target price: $$\\Delta x = (\\frac{1}{\\sqrt{P_{target}}} - \\frac{1}{\\sqrt{P_{current}}}) L$$ $$= \\frac{L}{\\sqrt{P_{target}}} - \\frac{L}{\\sqrt{P_{current}}}$$ From this, we can find $\\sqrt{P_{target}}$ using basic algebraic transformations: $$\\sqrt{P_{target}} = \\frac{\\sqrt{P}L}{\\Delta x \\sqrt{P} + L}$$ Knowing the target price, we can find the output amount similarly to how we found it in the previous milestone. Lets update our Python script with the new formula: # Swap ETH for USDC   amount_in  =   0.01337   *  eth    print( f \" \\n Selling  { amount_in / eth }  ETH\" )    price_next  =  int((liq  *  q96  *  sqrtp_cur)  //  (liq  *  q96  +  amount_in  *  sqrtp_cur))    print( \"New price:\" , (price_next  /  q96)  **   2 )  print( \"New sqrtP:\" , price_next)  print( \"New tick:\" , price_to_tick((price_next  /  q96)  **   2 ))    amount_in  =  calc_amount0(liq, price_next, sqrtp_cur)  amount_out  =  calc_amount1(liq, price_next, sqrtp_cur)    print( \"ETH in:\" , amount_in  /  eth)  print( \"USDC out:\" , amount_out  /  eth)  Its output: Selling 0.01337 ETH  New price: 4993.777388290041  New sqrtP:  5598789932670289186088059666432   New tick:  85163   ETH in: 0.013369999999998142  USDC out: 66.80838889019013  Which means that well get 66.8 USDC when selling 0.01337 ETH using the liquidity we provided in the previous step. This looks good, but enough of Python! Were going to implement all the math calculations in Solidity.    \\[ \\] Output Amount Calculation", "labels": ["Documentation"]}, {"title": "Swap Fees #", "html_url": "https://uniswapv3book.com/docs/milestone_5/swap-fees/", "body": "Swap Fees #", "labels": ["Documentation"]}, {"title": "Cross-Tick Swaps #", "html_url": "https://uniswapv3book.com/docs/milestone_3/cross-tick-swaps/", "body": "Cross-Tick Swaps #", "labels": ["Documentation"]}, {"title": "Flash Loan Fees #", "html_url": "https://uniswapv3book.com/docs/milestone_5/flash-loan-fees/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Flash Loan Fees   Flash Loan Fees Flash Loan Fees  # In a previous chapter we implemented flash loans and made them free. However, Uniswap collects swap fees on flash loans, and were going to add this to our implementation: the amounts repaid by flash loan borrowers must include a fee. Heres what the updated  flash  function looks like: function   flash (       uint256  amount0,       uint256  amount1,       bytes  calldata data  )  public  {       uint256  fee0  =  Math.mulDivRoundingUp(amount0, fee,  1 e6);       uint256  fee1  =  Math.mulDivRoundingUp(amount1, fee,  1 e6);         uint256  balance0Before  =  IERC20(token0).balanceOf( address (this));       uint256  balance1Before  =  IERC20(token1).balanceOf( address (this));         if  (amount0  >   0 ) IERC20(token0).transfer(msg.sender, amount0);       if  (amount1  >   0 ) IERC20(token1).transfer(msg.sender, amount1);        IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(          fee0,          fee1,          data      );         if  (IERC20(token0).balanceOf( address (this))  <  balance0Before  +  fee0)          revert FlashLoanNotPaid();       if  (IERC20(token1).balanceOf( address (this))  <  balance1Before  +  fee1)          revert FlashLoanNotPaid();        emit Flash(msg.sender, amount0, amount1);  }  Whats changed is that were now calculating fees on the amounts requested by caller and then expect pool balances to have grown by the fee amounts. Flash Loan Fees", "labels": ["Documentation"]}, {"title": "Math in Solidity #", "html_url": "https://uniswapv3book.com/docs/milestone_2/math-in-solidity/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Math in Solidity   Math in Solidity Re-using Math Contracts Math in Solidity  # Due to Solidity not supporting numbers with th fractional part, math in Solidity is somewhat complicated. Solidity gives us integer and unsigned integer types, which are not enough for for more or less complex math calculations. Another difficulty is gas consumption: the more complex an algorithm, the more gas it consumes. Thus, if we need to have advanced math operations (like  exp ,  ln ,  sqrt ), we want them to be as gas efficient as possible. And another big problem is the possibility of under/overflow. When multiplying  uint256  numbers, theres a risk of an overflow: the result number might be so big that it wont fit into 256 bits. All these difficulties force us to use third-party math libraries that implement advanced math operations and, ideally, optimize their gas consumption. In the case when theres no library for an algorithm we need, well have to implement it ourselves, which is a difficult task if we need to implement a unique computation. Re-using Math Contracts  # In our Uniswap V3 implementation, were going to use two third-party math contracts: PRBMath , which is a great library of advanced fixed-point math algorithms. Well use  mulDiv  function to handle overflows when multiplying and then dividing integer numbers. TickMath  from the original Uniswap V3 repo. This contract implements two functions,  getSqrtRatioAtTick  and  getTickAtSqrtRatio , which convert $\\sqrt{P}$s to ticks and back. Lets focus on the latter. In our contracts, well need to convert ticks to corresponding $\\sqrt{P}$ and back. The formulas are: $$\\sqrt{P(i)} = \\sqrt{1.0001^i} = 1.0001^{\\frac{i}{2}}$$ $$i = log_{\\sqrt{1.0001}}\\sqrt{P(i)}$$ These are complex mathematical operations (for Solidity, at least) and they require high precision because we dont want to allow rounding errors when calculating prices. To have better precision and optimization well need unique implementation. If you look at the original code of  getSqrtRatioAtTick  and  getTickAtSqrtRatio  youll see that theyre quite complex: therere a lot of magic numbers (like  0xfffcb933bd6fad37aa2d162d1a594001 ), multiplication, and bitwise operations. At this point, were not going to analyze the code or re-implement it since this is a very advanced and somewhat different topic. Well use the contract as is. And, in a later milestone, well break down the computations.    \\[ \\] Math in Solidity Re-using Math Contracts", "labels": ["Documentation"]}, {"title": "NFT Manager Contract #", "html_url": "https://uniswapv3book.com/docs/milestone_6/nft-manager/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   NFT Manager   NFT Manager Contract The Minimal Contract Minting Adding Liquidity Remove Liquidity Collecting Tokens Burning NFT Manager Contract  # Obviously, were not going to add NFT-related functionality to the pool contractwe need a separate contract that will merge NFTs and liquidity positions. Recall that, while working on our implementation, we built the  UniswapV3Manager  contract to facilitate interaction with pool contracts (to make some calculations simpler and to enable multi-pool swaps). This contract was a good demonstration of how core Uniswap contracts can be extended. And were going to push this idea a little bit further. Well need a manager contract that will implement the ERC721 standard and will manage liquidity positions. The contract will have the standard NFT functionality (minting, burning, transferring, balances and ownership tracking, etc.) and will allow to provide and remove liquidity to pools. The contract will need to be the actual owner of liquidity in pools because we dont want to let users to add liquidity without minting a token and removing entire liquidity without burning one. We want every liquidity position to be linked to an NFT token, and we want to them to be synchronized. Lets see what functions well have in the new contract: since itll be an NFT contract, itll have all the ERC721 functions, including  tokenURI , which returns the URI of the image of an NFT token; mint  and  burn  to mint and burn liquidity and NFT tokens at the same time; addLiquidity  and  removeLiquidity  to add and remove liquidity in existing positions; collect , to collect tokens after removing liquidity. Alright, lets get to code. The Minimal Contract  # Since we dont want to implement the ERC721 standard from scratch, were going to use a library. We already have  Solmate  in the dependencies, so were going to use  its ERC721 implementation . Using  the ERC721 implementation from OpenZeppelin  is also an option, but I personally prefer the gas optimized contracts from Solmate. This will be the bare minimum of the NFT manager contract: contract   UniswapV3NFTManager   is  ERC721 {       address   public   immutable  factory;         constructor ( address  factoryAddress)          ERC721( \"UniswapV3 NFT Positions\" ,  \"UNIV3\" )      {          factory  =  factoryAddress;      }         function   tokenURI ( uint256  tokenId)           public            view            override            returns  ( string   memory )      {           return   \"\" ;      }  }  tokenURI  will return an empty string until we implement a metadata and SVG renderer. Weve added the stub so that the Solidity compiler doesnt fail while were working on the rest of the contract (the  tokenURI  function in the Solmate ERC721 contract is virtual, so we must implement it). Minting  # Minting, as we discussed earlier, will involve two operations: adding liquidity to a pool and minting an NFT. To keep the links between pool liquidity positions and NFTs, well need a mapping and a structure: struct   TokenPosition  {       address  pool;       int24  lowerTick;       int24  upperTick;  }  mapping ( uint256   =>  TokenPosition)  public  positions;  To find a position we need: a pool address; an owner address; the boundaries of a position (lower and upper ticks). Since the NFT manager contract will be the owner of all positions created via it, we dont need to store positions owner address and we can only store the rest data. The keys in the  positions  mapping are token IDs; the mapping links NFT IDs to the position data thats required to find a liquidity position. Lets implement minting: struct   MintParams  {       address  recipient;       address  tokenA;       address  tokenB;       uint24  fee;       int24  lowerTick;       int24  upperTick;       uint256  amount0Desired;       uint256  amount1Desired;       uint256  amount0Min;       uint256  amount1Min;  }    function   mint (MintParams calldata params)  public   returns  ( uint256  tokenId) {      ...  }  The minting parameters are identical to those of  UniswapV3Manager , with an addition of  recipient , which will allow to mint NFT to another address. In the  mint  function, we first add liquidity to a pool: IUniswapV3Pool pool  =  getPool(params.tokenA, params.tokenB, params.fee);    ( uint128  liquidity,  uint256  amount0,  uint256  amount1)  =  _addLiquidity(      AddLiquidityInternalParams({          pool :  pool,          lowerTick :  params.lowerTick,          upperTick :  params.upperTick,          amount0Desired :  params.amount0Desired,          amount1Desired :  params.amount1Desired,          amount0Min :  params.amount0Min,          amount1Min :  params.amount1Min      })  );  _addLiquidity  is identical to the body of  mint  function in the  UniswapV3Manager  contract: it converts ticks to $\\sqrt(P)$, computes liquidity amount, and calls  pool.mint() . Next, we mint an NFT: tokenId  =  nextTokenId ++ ;  _mint(params.recipient, tokenId);  totalSupply ++ ;  tokenId  is set to the current  nextTokenId  and the latter is then incremented. The  _mint  function is provided by the ERC721 contract from Solmate. After minting a new token, we update  totalSupply . Finally, we need to store the information about the new token and the new position: TokenPosition  memory  tokenPosition  =  TokenPosition({      pool :   address (pool),      lowerTick :  params.lowerTick,      upperTick :  params.upperTick  });    positions[tokenId]  =  tokenPosition;  This will later help us find liquidity position by token ID. Adding Liquidity  # Next, well implement a function to add liquidity to an existing position, in the case when we want more liquidity to a position that already has some. In such cases, we dont want to mint an NFT, but only to increase the amount of liquidity in an existing position. For that, well only need to provide a token ID and token amounts: function   addLiquidity (AddLiquidityParams calldata params)       public        returns  (           uint128  liquidity,           uint256  amount0,           uint256  amount1      )  {      TokenPosition  memory  tokenPosition  =  positions[params.tokenId];       if  (tokenPosition.pool  ==   address ( 0x00 )) revert WrongToken();        (liquidity, amount0, amount1)  =  _addLiquidity(          AddLiquidityInternalParams({              pool :  IUniswapV3Pool(tokenPosition.pool),              lowerTick :  tokenPosition.lowerTick,              upperTick :  tokenPosition.upperTick,              amount0Desired :  params.amount0Desired,              amount1Desired :  params.amount1Desired,              amount0Min :  params.amount0Min,              amount1Min :  params.amount1Min          })      );  }  This function ensures theres an existing token and calls  pool.mint()  with parameters of an existing position. Remove Liquidity  # Recall that in the  UniswapV3Manager  contract we didnt implement a  burn  function because we wanted users to be owners of liquidity positions. Now, we want the NFT manager to be the owner. And we can have liquidity burning implemented in it: struct   RemoveLiquidityParams  {       uint256  tokenId;       uint128  liquidity;  }    function   removeLiquidity (RemoveLiquidityParams  memory  params)       public       isApprovedOrOwner(params.tokenId)       returns  ( uint256  amount0,  uint256  amount1)  {      TokenPosition  memory  tokenPosition  =  positions[params.tokenId];       if  (tokenPosition.pool  ==   address ( 0x00 )) revert WrongToken();        IUniswapV3Pool pool  =  IUniswapV3Pool(tokenPosition.pool);        ( uint128  availableLiquidity, , , , )  =  pool.positions(          poolPositionKey(tokenPosition)      );       if  (params.liquidity  >  availableLiquidity) revert NotEnoughLiquidity();        (amount0, amount1)  =  pool.burn(          tokenPosition.lowerTick,          tokenPosition.upperTick,          params.liquidity      );  }  Were again checking that provided token ID is valid. And we also need to ensure that a position has enough liquidity to burn. Collecting Tokens  # The NFT manager contract can also collect tokens after burning liquidity. Notice that collected tokens are send to  msg.sender  since the contract manages liquidity on behalf of the caller: struct   CollectParams  {       uint256  tokenId;       uint128  amount0;       uint128  amount1;  }    function   collect (CollectParams  memory  params)       public       isApprovedOrOwner(params.tokenId)       returns  ( uint128  amount0,  uint128  amount1)  {      TokenPosition  memory  tokenPosition  =  positions[params.tokenId];       if  (tokenPosition.pool  ==   address ( 0x00 )) revert WrongToken();        IUniswapV3Pool pool  =  IUniswapV3Pool(tokenPosition.pool);        (amount0, amount1)  =  pool.collect(          msg.sender,          tokenPosition.lowerTick,          tokenPosition.upperTick,          params.amount0,          params.amount1      );  }  Burning  # Finally, burning. Unlike the other functions of the contract, this function doesnt do anything with a pool: it only burns an NFT. And to burn an NFT, the underlying position must be empty and tokens must be collected. So, if we want to burn an NFT, we need to: call  removeLiquidity  an remove the entire position liquidity; call  collect  to collect the tokens after burning the position; call  burn  to burn the token. function   burn ( uint256  tokenId)  public  isApprovedOrOwner(tokenId) {      TokenPosition  memory  tokenPosition  =  positions[tokenId];       if  (tokenPosition.pool  ==   address ( 0x00 )) revert WrongToken();        IUniswapV3Pool pool  =  IUniswapV3Pool(tokenPosition.pool);      ( uint128  liquidity, , ,  uint128  tokensOwed0,  uint128  tokensOwed1)  =  pool          .positions(poolPositionKey(tokenPosition));         if  (liquidity  >   0   ||  tokensOwed0  >   0   ||  tokensOwed1  >   0 )          revert PositionNotCleared();         delete  positions[tokenId];      _burn(tokenId);      totalSupply -- ;  }  Thats it!    \\[ \\] NFT Manager Contract The Minimal Contract Minting Adding Liquidity Remove Liquidity Collecting Tokens Burning", "labels": ["Documentation"]}, {"title": "Providing Liquidity #", "html_url": "https://uniswapv3book.com/docs/milestone_1/providing-liquidity/", "body": "Providing Liquidity #", "labels": ["Documentation"]}, {"title": "Swap Path #", "html_url": "https://uniswapv3book.com/docs/milestone_4/path/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Swap Path   Swap Path Path Library Calculating the Number of Pools in a Path Figuring Out If a Path Has Multiple Pools Extracting First Pool Parameters From a Path Proceeding to a Next Pair in a Path Decoding First Pool Parameters Swap Path  # Lets imagine that we have only these pools: WETH/USDC, USDC/USDT, WBTC/USDT. If we want to swap WETH for WBTC, well need to make multiple swaps (WETHUSDCUSDTWBTC) since theres no WETH/WBTC pool. We can do this manually or we can improve our contracts to handle such chained, or multi-pool, swaps. Of course, well do the latter! When doing multi-pool swaps, were sending output of a previous swap to the input of the next one. For example: in WETH/USDC pool, were selling WETH and buying USDC; in USDC/USDT pool, were selling USDC from the previous swap and buying USDT; in WBTC/USDT pool, were selling USDT from the previous pool and buying WBTC. We can turn this series into a path: WETH/USDC,USDC/USDT,WBTC/USDT  And iterate over such path in our contracts to perform multiple swaps in one transaction. However, recall from the previous chapter that we dont need to know pool addresses and, instead, we can derive them from pool parameters. Thus, the above path can be turned into a series of tokens: WETH, USDC, USDT, WBTC  And recall that tick spacing is another parameter (besides tokens) that identifies a pool. Thus, the above path becomes: WETH, 60, USDC, 10, USDT, 60, WBTC  Where 60 and 10 are tick spacings. Were using 60 in volatile pairs (e.g. ETH/USDC, WBTC/USDT) and 10 in stablecoin pairs (USDC/USDT). Now, having such path, we can iterate over it to build pool parameters for each of the pool: WETH, 60, USDC ; USDC, 10, USDT ; USDT, 60, WBTC . Knowing these parameters, we can derive pool addresses using  PoolAddress.computeAddress , which we implemented in the previous chapter. We also can use this concept when doing swaps within one pool: the path would simple contain the parameters of one pool. And, thus, we can use swap paths in all swaps, universally. Lets build a library to work with swap paths. Path Library  # In code, a swap path is a sequence of bytes. In Solidity, a path can be built like that: bytes .concat(       bytes20 ( address (weth)),       bytes3 ( uint24 ( 60 )),       bytes20 ( address (usdc)),       bytes3 ( uint24 ( 10 )),       bytes20 ( address (usdt)),       bytes3 ( uint24 ( 60 )),       bytes20 ( address (wbtc))  );  And it looks like that: 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2  # weth address     00003c                                    # 60     A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48  # usdc address     00000a                                    # 10     dAC17F958D2ee523a2206206994597C13D831ec7  # usdt address     00003c                                    # 60     2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599  # wbtc address   These are the functions that well need to implement: calculating the number of pools in a path; figuring out if a path has multiple pools; extracting first pool parameters from a path; proceeding to the next pair in a path; and decoding first pool parameters. Calculating the Number of Pools in a Path  # Lets begin with calculating the number of pools in a path: // src/lib/Path.sol  library  Path {       /// @dev The length the bytes encoded address       uint256   private   constant  ADDR_SIZE  =   20 ;       /// @dev The length the bytes encoded tick spacing       uint256   private   constant  TICKSPACING_SIZE  =   3 ;         /// @dev The offset of a single token address + tick spacing       uint256   private   constant  NEXT_OFFSET  =  ADDR_SIZE  +  TICKSPACING_SIZE;       /// @dev The offset of an encoded pool key (tokenIn + tick spacing + tokenOut)       uint256   private   constant  POP_OFFSET  =  NEXT_OFFSET  +  ADDR_SIZE;       /// @dev The minimum length of a path that contains 2 or more pools;       uint256   private   constant  MULTIPLE_POOLS_MIN_LENGTH  =           POP_OFFSET  +  NEXT_OFFSET;        ...  We first define a few constants: ADDR_SIZE  is the size of an address, 20 bytes; TICKSPACING_SIZE  is the size of a tick spacing, 3 bytes ( uint24 ); NEXT_OFFSET  is the offset of a next token addressto get it, we skip an address and a tick spacing; POP_OFFSET  is the offset of a pool key (token address + tick spacing + token address); MULTIPLE_POOLS_MIN_LENGTH  is the minimum length of a path that contains 2 or more pools (one set of pool parameters + tick spacing + token address). To count the number of pools in a path, we subtract the size of an address (first or last token in a path) and divide the remaining part by  NEXT_OFFSET  (address + tick spacing): function   numPools ( bytes   memory  path)  internal   pure   returns  ( uint256 ) {       return  (path.length  -  ADDR_SIZE)  /  NEXT_OFFSET;  }  Figuring Out If a Path Has Multiple Pools  # To check if there are multiple pools in a path, we need to compare the length of a path with  MULTIPLE_POOLS_MIN_LENGTH : function   hasMultiplePools ( bytes   memory  path)  internal   pure   returns  ( bool ) {       return  path.length  >=  MULTIPLE_POOLS_MIN_LENGTH;  }  Extracting First Pool Parameters From a Path  # To implement other functions, well need a helper library because Solidity doesnt have native bytes manipulation functions. Specifically, well need a function to extract a sub-array from an array of bytes, and a couple of functions to convert bytes to  address  and  uint24 . Luckily, theres a great open-source library called  solidity-bytes-utils . To use the library, we need to extend the  bytes  type in the  Path  library: library  Path {       using  BytesLib  for   bytes ;      ...  }  We can implement  getFirstPool  now: function   getFirstPool ( bytes   memory  path)       internal        pure        returns  ( bytes   memory )  {       return  path.slice( 0 , POP_OFFSET);  }  The function simply returns the first token address + tick spacing + token address segment encoded as bytes. Proceeding to a Next Pair in a Path  # Well use the next function when iterating over a path and throwing away processed pools. Notice that were removing token address + tick spacing, not full pool parameters, because we need the other token address to calculate next pool address. function   skipToken ( bytes   memory  path)  internal   pure   returns  ( bytes   memory ) {       return  path.slice(NEXT_OFFSET, path.length  -  NEXT_OFFSET);  }  Decoding First Pool Parameters  # And, finally, we need to decode the parameters of the first pool in a path: function   decodeFirstPool ( bytes   memory  path)       internal        pure        returns  (           address  tokenIn,           address  tokenOut,           uint24  tickSpacing      )  {      tokenIn  =  path.toAddress( 0 );      tickSpacing  =  path.toUint24(ADDR_SIZE);      tokenOut  =  path.toAddress(NEXT_OFFSET);  }  Unfortunately,  BytesLib  doesnt implement  toUint24  function but we can implement it ourselves!  BytesLib  has multiple  toUintXX  functions, so we can take one of them and convert to a  uint24  one: library  BytesLibExt {       function   toUint24 ( bytes   memory  _bytes,  uint256  _start)           internal            pure            returns  ( uint24 )      {          require(_bytes.length  >=  _start  +   3 ,  \"toUint24_outOfBounds\" );           uint24  tempUint;             assembly  {              tempUint  :=   mload ( add ( add (_bytes,  0x3 ), _start))          }             return  tempUint ;       }  }  Were doing this in a new library contract, which we can then use in our Path library alongside  BytesLib : library  Path {       using  BytesLib  for   bytes ;       using  BytesLibExt  for   bytes ;      ...  }  Swap Path Path Library Calculating the Number of Pools in a Path Figuring Out If a Path Has Multiple Pools Extracting First Pool Parameters From a Path Proceeding to a Next Pair in a Path Decoding First Pool Parameters", "labels": ["Documentation"]}, {"title": "Introduction to Uniswap V3 #", "html_url": "https://uniswapv3book.com/docs/introduction/uniswap-v3/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Uniswap V3   Introduction to Uniswap V3 Concentrated Liquidity The Mathematics of Uniswap V3 Pricing Ticks Introduction to Uniswap V3  # This chapter retells  the whitepaper of Uniswap V3 . Again, its totally ok if you dont understand all the concepts. They will be clearer when converted to code. To better understand the innovations Uniswap V3 brings, lets first look at the imperfections of Uniswap V2. Uniswap V2 is a general exchange that implements one AMM algorithm. However, not all trading pairs are equal. Pairs can be grouped by price volatility: Tokens with medium and high price volatility. This group includes most tokens since most tokens dont have their prices pegged to something and are subject to market fluctuations. Tokens with low volatility. This group includes pegged tokens, mainly stablecoins: USDC/USDT, USDC/DAI, USDT/DAI, etc. Also: ETH/stETH, ETH/rETH (variants of wrapped ETH). These groups require different, lets call them, pool configurations. The main difference is that pegged tokens require high liquidity to reduce the demand effect (we learned about it in the previous chapter) on big trades. The prices of USDC and USDT must stay close to 1, no matter how big the number of tokens we want to buy and sell. Since Uniswap V2s general AMM algorithm is not very well suited for stablecoin trading, alternative AMMs (mainly  Curve ) were more popular for stablecoin trading. What caused this problem is that liquidity in Uniswap V2 pools is distributed infinitelypool liquidity allows trades at any price, from 0 to infinity: This might not seem like a bad thing, but this makes capital inefficient. Historical prices of an asset stay within some defined range, whether its narrow or wide. For example, the historical price range of ETH is from  $0.75  to  $4,800  (according to  CoinMarketCap ). Today (June 2022, 1 ETH costs  $1,800 ), no one would buy 1 ether at  $5000 , so it makes no sense to provide liquidity at this price. Thus, it doesnt really make sense providing liquidity in a price range thats far away from the current price or that will never be reached. However, we all believe in ETH reaching $10,000 one day. Concentrated Liquidity  # Uniswap V3 introduces  concentrated liquidity : liquidity providers can now choose the price range they want to provide liquidity into. This improves capital efficiency by allowing to put more liquidity into a narrow price range, which makes Uniswap more diverse: it can now have pools configured for pairs with different volatility. This is how V3 improves V2. In a nutshell, a Uniswap V3 pair is many small Uniswap V2 pairs. The main difference between V2 and V3 is that, in V3, there are  many price ranges  in one pair. And each of these shorter price ranges has  finite reserves . The entire price range from 0 to infinite is split into shorter price ranges, with each of them having its own amount of liquidity. But, whats crucial is that within that shorter price ranges,  it works exactly as Uniswap V2 . This is why I say that a V3 pair is many small V2 pairs. Now, lets try to visualize it. What were saying is that we dont want the curve to be infinite. We cut it at the points $a$ and $b$ and say that these are the boundaries of the curve. Moreover, we shift the curve so the boundaries lay on the axes. This is what we get: It looks lonely, doesnt it? This is why there are many price ranges in Uniswap V3so they dont feel lonely  As we saw in the previous chapter, buying or selling tokens moves the price along the curve. A price range limits the movement of the price. When the price moves to either of the points, the pool becomes  depleted : one of the token reserves will be 0 and buying this token wont be possible. On the chart above, lets assume that the start price is at the middle of the curve. To get to the point $a$, we need to buy all available $y$ and maximize $x$ in the range; to get to the point $b$, we need to buy all available $x$ and maximize $y$ in the range. At these points, theres only one token in the range! Fun fact: this allows to use Uniswap V3 price ranges as limit-orders! What happens when the current price range gets depleted during a trade? The price slips into the next price range. If the next price range doesnt exist, the trade ends up fulfilled partially-well see how this works later in the book. This is how liquidity is spread in  the USDC/ETH pool in production : You can see that theres a lot of liquidity around the current price but the further away from it the less liquidity there isthis is because liquidity providers strive to have higher efficiency of their capital. Also, the whole range is not infinite, its upper boundary is shown on the image. The Mathematics of Uniswap V3  # Mathematically, Uniswap V3 is based on V2: it uses the same formulas, but theyre lets call it  augmented . To handle transitioning between price ranges, simplify liquidity management, and avoid rounding errors, Uniswap V3 uses these new concepts: $$L = \\sqrt{xy}$$ $$\\sqrt{P} = \\sqrt{\\frac{y}{x}}$$ $L$ is  the amount of liquidity . Liquidity in a pool is the combination of token reserves (that is, two numbers). We know that their product is $k$, and we can use this to derive the measure of liquidity, which is $\\sqrt{xy}$a number that, when multiplied by itself, equals to $k$. $L$ is the geometric mean of $x$ and $y$. $y/x$ is the price of token 0 in terms of 1. Since token prices in a pool are reciprocals of each other, we can use only one of them in calculations (and by convention Uniswap V3 uses $y/x$). The price of token 1 in terms of token 0 is simply $\\frac{1}{y/x}=\\frac{x}{y}$. Similarly, $\\frac{1}{\\sqrt{P}} = \\frac{1}{\\sqrt{y/x}} = \\sqrt{\\frac{x}{y}}$. Why using $\\sqrt{p}$ instead of $p$? There are two reasons: Square root calculation is not precise and causes rounding errors. Thus, its easier to store the square root without calculating it in the contracts (we will not store $x$ and $y$ in the contracts). $\\sqrt{P}$ has an interesting connection to $L$: $L$ is also the relation between the change in output amount and the change in $\\sqrt{P}$. $$L = \\frac{\\Delta y}{\\Delta\\sqrt{P}}$$ Proof: $$L = \\frac{\\Delta y}{\\Delta\\sqrt{P}}$$ $$\\sqrt{xy} = \\frac{y_1 - y_0}{\\sqrt{P_1} - \\sqrt{P_0}}$$ $$\\sqrt{xy} (\\sqrt{P_1} - \\sqrt{P_0}) = y_1 - y_0$$ $$\\sqrt{xy} (\\sqrt{\\frac{y_1}{x_1}} - \\sqrt{\\frac{y_0}{x_0}}) = y_1 - y_0$$ $$\\textrm{Since } \\sqrt{x_1y_1} = \\sqrt{x_0y_0} = \\sqrt{xy} = L,$$ $$\\sqrt{\\frac{x_1y_1y_1}{x_1}} - \\sqrt{\\frac{x_0y_0y_0}{x_0}} = y_1 - y_0$$ $$\\sqrt{y_1^2} - \\sqrt{y_0^2} = y_1 - y_0$$ $$y_1 - y_0 = y_1 - y_0$$ Pricing  # Again, we dont need to calculate actual priceswe can calculate output amount right away. Also, since were not going to track and store $x$ and $y$, our calculation will be based only on $L$ and $\\sqrt{P}$. From the above formula, we can find $\\Delta y$: $$\\Delta y = \\Delta \\sqrt{P} L$$ See the third step in the proof above. As we discussed above, prices in a pool are reciprocals of each other. Thus, $\\Delta x$ is: $$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}} L$$ $L$ and $\\sqrt{P}$ allow us to not store and update pool reserves. Also, we dont need to calculate $\\sqrt{P}$ each time because we can always find $\\Delta \\sqrt{P}$ and its reciprocal. Ticks  # As we learned in this chapter, the infinite price range of V2 is split into shorter price ranges in V3. Each of these shorter price ranges is limited by boundariesupper and lower points. To track the coordinates of these boundaries, Uniswap V3 uses  ticks . In V3, the entire price range is demarcated by evenly distributed discrete ticks. Each tick has an index and corresponds to a certain price: $$p(i) = 1.0001^i$$ Where $p(i)$ is the price at tick $i$. Taking powers of 1.0001 has a desirable property: the difference between two adjacent ticks is 0.01% or  1 basis point . Basis point (1/100th of 1%, or 0.01%, or 0.0001) is a unit of measure of percentages in finance. You couldve heard about basis point when central banks announced changes in interest rates. As we discussed above, Uniswap V3 stores $\\sqrt{P}$, not $P$. Thus, the formula is in fact: $$\\sqrt{p(i)} = \\sqrt{1.0001}^i = 1.0001 ^{\\frac{i}{2}}$$ So, we get values like: $\\sqrt{p(0)} = 1$, $\\sqrt{p(1)} = \\sqrt{1.0001} \\approx 1.00005$, $\\sqrt{p(-1)} \\approx 0.99995$. Ticks are integers that can be positive and negative and, of course, theyre not infinite. Uniswap V3 stores $\\sqrt{P}$ as a fixed point Q64.96 number, which is a rational number that uses 64 bits for the integer part and 96 bits for the fractional part. Thus, prices (equal to the square of $\\sqrt{P}$) are within the range: $[2^{-128}, 2^{128}]$. And ticks are within the range: $$[log_{1.0001}2^{-128}, log_{1.0001}{2^{128}}] = [-887272, 887272]$$ For deeper dive into the math of Uniswap V3, I cannot but recommend  this technical note  by  Atis Elsts .    \\[ \\] Introduction to Uniswap V3 Concentrated Liquidity The Mathematics of Uniswap V3 Pricing Ticks", "labels": ["Documentation"]}, {"title": "Development environment #", "html_url": "https://uniswapv3book.com/docs/introduction/dev-environment/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Development Environment   Development environment Quick Introduction to Ethereum Local Development Environment Foundry Ethers.js MetaMask React Setting Up the Project Development environment  # Were going to build two applications: An on-chain one: a set of smart contracts deployed on Ethereum. An off-chain one: a front-end application that will interact with the smart contracts. While the front-end application development is part of this book, it wont be our main focus. We will build it solely to demonstrate how smart contracts are integrated with front-end applications. Thus, the front-end application is optional, but Ill still provide the code. Quick Introduction to Ethereum  # Ethereum is a blockchain that allows anyone to run applications on it. It might look like a cloud provider, but there are multiple differences: You dont pay for hosting your application. But you pay for deployment. Your application is immutable. That is: you wont be able to modify it after its deployed. Users will pay to use your application. To better understand these moments, lets see what Ethereum is made of. At the core of Ethereum (and any other blockchain) is a database. The most valuable data in Ethereums database is  the state of accounts . An account is an Ethereum address with associated data: Balance: accounts ether balance. Code: bytecode of the smart contract deployed at this address. Storage: space used by smart contracts to store data. Nonce: a serial integer thats used to protect against replay attacks. Ethereums main job is building and maintaining this data in a secure way that doesnt allow unauthorized access. Ethereum is also a network, a network of computers that build and maintain the state independently of each other. The main goal of the network is to  decentralize access to the database : there must be no single authority thats allowed to modify anything in the database unilaterally. This is achieved by a means of  consensus , which is a set of rules all the nodes in the network follow. If one party decides to abuse a rule, itll be excluded from the network. Fun fact: blockchain can use MySQL! Nothing prevents this besides performance. In its turn, Ethereum uses  LevelDB , a fast key-value database. Every Ethereum node also runs EVM, Ethereum Virtual Machine. A virtual machine is a program that can run other programs, and EVM is a program that executes smart contracts. Users interact with contracts through transactions: besides simply sending ether, transactions can contain smart contract call data. It includes: An encoded contract function name. Function parameters. Transactions are packed in blocks and blocks then mined by miners. Each participant of the network can validate any transaction and any block. In a sense, smart contracts are similar to JSON APIs but instead of endpoints you call smart contract functions and you provide function arguments. Similar to API backends, smart contracts execute programmed logic, which can optionally modify smart contract storage. Unlike JSON API, you need to send a transaction to mutate blockchain state, and youll need to pay for each transaction youre sending. Finally, Ethereum nodes expose a JSON-RPC API. Through this API we can interact with a node to: get account balance, estimate gas costs, get blocks and transactions, send transactions, and execute contract calls without sending transactions (this is used to read data from smart contracts).  Here  you can find the full list of available endpoints. Transactions are also sent through the JSON-RPC API, see  eth_sendTransaction . Local Development Environment  # There are multiple smart contract development environments that are used today: Truffle Hardhat Foundry Truffle is the oldest of the three and is the less popular of them. Hardhat is its improved descendant and is the most widely used tool. Foundry is the new kid on the block, which brings a different view on testing. While HardHat is still a popular solution, more and more projects are switching to Foundry. And there are multiple reasons for that: With Foundry, we can write tests in Solidity. This is much more convenient because we dont need to jump between JavaScript (Truffle and HardHat use JS for tests and automation) and Solidity during development. Writing tests in Solidity is much more convenient because you have all the native features (e.g. you dont need a special type for big numbers and you dont need to convert between strings and  BigNumber ). Foundry doesnt run a node during testing. This makes testing and iterating on features much faster! Truffle and HardHat start a node whenever you run tests; Foundry executes tests on an internal EVM. That being said, well use Foundry as our main smart contract development and testing tool. Foundry  # Foundry  is a set of tools for Ethereum applications development. Specifically, were going to use: Forge , a testing framework for Solidity. Anvil , a local Ethereum node designed for development with Forge. Well use it to deploy our contracts to a local node and connect to it through the front-end app. Cast , a CLI tool with a ton of helpful features. Forge makes smart contracts developers life so much easier. With Forge, we dont need to run a local node to test contracts. Instead, Forge runs tests on its internal EVM, which is much faster and doesnt require sending transactions and mining blocks. Forge lets us write tests in Solidity! Forge also makes it easier to simulate blockchain state: we can easily fake our ether or token balance, execute contracts from other addresses, deploy any contracts at any address, etc. However, well still need a local node to deploy our contract to. For that, well use Anvil. Front-end applications use JavaScript Web3 libraries to interact with Ethereum nodes (to send transaction, query state, estimate transaction gas cost, etc.)this is why well need to run a local node. Ethers.js  # Ethers.js  is a set of Ethereum utilities written in JavaScript. This is one of the two (the other one is  web3.js ) most popular JavaScript libraries used in decentralized applications development. These libraries allow us to interact with an Ethereum node via the JSON-API, and they come with multiple utility functions that make developers life easier. MetaMask  # MetaMask  is an Ethereum wallet in your browser. Its a browser extension that creates and securely stores Ethereum private keys. MetaMask is the main Ethereum wallet application used by millions of users. Well use it to sign transactions that well send to our local node. React  # React  is a well-known JavaScript library for building front-end applications. You dont need to know React, Ill provide a template application. Setting Up the Project  # To set up the project, create a new folder and run  forge init  in it: $ mkdir uniswapv3clone  $ cd uniswapv3clone  $ forge init  If youre using Visual Studio Code, add  --vscode  flag to  forge init :  forge init --vscode . Forge will initialize the project with VSCode specific settings. Forge will create sample contracts in  src ,  test , and  script  foldersthese can be removed. To set up the front-end application: $ npx create-react-app ui  Its located in a subfolder so theres no conflict between folder names. Development environment Quick Introduction to Ethereum Local Development Environment Foundry Ethers.js MetaMask React Setting Up the Project", "labels": ["Documentation"]}, {"title": "First Swap #", "html_url": "https://uniswapv3book.com/docs/milestone_1/first-swap/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   First Swap   First Swap Calculating Swap Amounts Implementing a Swap Testing Swapping Homework First Swap  # Now that we have liquidity, we can make our first swap! Calculating Swap Amounts  # First step, of course, is to figure out how to calculate swap amounts. And, again, lets pick and hardcode some amount of USDC were going to trade in for ETH. Let it be 42! Were going to buy ETH for 42 USDC. After deciding how many tokens we want to sell, we need to calculate how many tokens well get in exchange. In Uniswap V2, we wouldve used current pool reserves, but in Uniswap V3 we have $L$ and $\\sqrt{P}$ and we know the fact that, when swapping within a price range, only $\\sqrt{P}$ changes and $L$ remains unchanged (Uniswap V3 acts exactly as V2 when swapping is done only within one price range). We also know that: $$L = \\frac{\\Delta y}{\\Delta \\sqrt{P}}$$ And we know $\\Delta y$! This is the 42 USDC were going to trade in! Thus, we can find how selling 42 USDC will affect the current $\\sqrt{P}$ given the $L$: $$\\Delta \\sqrt{P} = \\frac{\\Delta y}{L}$$ In Uniswap V3, we choose  the price we want our trade to lead to  (recall that swapping changes the current price, i.e. it moves the current price along the curve). Knowing the target price, the contract will calculate the amount of input token it needs to take from us and the respective amount of output token itll give us. Lets plug in our numbers into the above formula: $$\\Delta \\sqrt{P} = \\frac{42 \\enspace USDC}{1517882343751509868544} = 2192253463713690532467206957$$ After adding this to the current $\\sqrt{P}$, well get the target price: $$\\sqrt{P_{target}} = \\sqrt{P_{current}} + \\Delta \\sqrt{P}$$ $$\\sqrt{P_{target}} = 5604469350942327889444743441197$$ To calculate the target price in Python: amount_in  =   42   *  eth  price_diff  =  (amount_in  *  q96)  //  liq  price_next  =  sqrtp_cur  +  price_diff  print( \"New price:\" , (price_next  /  q96)  **   2 )  print( \"New sqrtP:\" , price_next)  print( \"New tick:\" , price_to_tick((price_next  /  q96)  **   2 ))  # New price: 5003.913912782393   # New sqrtP: 5604469350942327889444743441197   # New tick: 85184   After finding the target price, we can calculate token amounts using the amounts calculation functions from a previous chapter: $$ x = \\frac{L(\\sqrt{p_b}-\\sqrt{p_a})}{\\sqrt{p_b}\\sqrt{p_a}}$$ $$ y = L(\\sqrt{p_b}-\\sqrt{p_a}) $$ In Python: amount_in  =  calc_amount1(liq, price_next, sqrtp_cur)  amount_out  =  calc_amount0(liq, price_next, sqrtp_cur)    print( \"USDC in:\" , amount_in  /  eth)  print( \"ETH out:\" , amount_out  /  eth)  # USDC in: 42.0   # ETH out: 0.008396714242162444   To verify the amounts, lets recall another formula: $$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}} L$$ Using this formula, we can find the amount of ETH were buying, $\\Delta x$, knowing the price change, $\\Delta\\frac{1}{\\sqrt{P}}$, and liquidity $L$. Be careful though: $\\Delta \\frac{1}{\\sqrt{P}}$ is not $\\frac{1}{\\Delta \\sqrt{P}}$! The former is the change of the price of ETH, and it can be found using this expression: $$\\Delta \\frac{1}{\\sqrt{P}} = \\frac{1}{\\sqrt{P_{target}}} - \\frac{1}{\\sqrt{P_{current}}}$$ Luckily, we already know all the values, so we can plug them in right away (this might not fit on your screen!): $$\\Delta \\frac{1}{\\sqrt{P}} = \\frac{1}{5604469350942327889444743441197} - \\frac{1}{5602277097478614198912276234240}$$ $$= -6.982190286589445\\text{e-}35 * 2^{96} $$ $$= -0.00000553186106731426$$ Now, lets find $\\Delta x$: $$\\Delta x = -0.00000553186106731426 * 1517882343751509868544 = -8396714242162698 $$ Which is 0.008396714242162698 ETH, and its very close to the amount we found above! Notice that this amount is negative since were removing it from the pool. Implementing a Swap  # Swapping is implemented in  swap  function: function   swap ( address  recipient)       public        returns  ( int256  amount0,  int256  amount1)  {      ...  At this moment, it only takes a recipient, who is a receiver of tokens. First, we need to find the target price and tick, as well as calculate the token amounts. Again, well simply hard code the values we calculated earlier to keep things as simple as possible: ...  int24  nextTick  =   85184 ;  uint160  nextPrice  =   5604469350942327889444743441197 ;    amount0  =   - 0 . 008396714242162444   ether ;  amount1  =   42   ether ;  ...  Next, we need to update the current tick and  sqrtP  since trading affects the current price: ...  (slot0.tick, slot0.sqrtPriceX96)  =  (nextTick, nextPrice);  ...  Next, the contract sends tokens to the recipient and lets the caller transfer the input amount into the contract: ...  IERC20(token0).transfer(recipient,  uint256 ( - amount0));    uint256  balance1Before  =  balance1();  IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(      amount0,      amount1  );  if  (balance1Before  +   uint256 (amount1)  <  balance1())      revert InsufficientInputAmount();  ...  Again, were using a callback to pass the control to the caller and let it transfer the tokens. After that, were checking that pools balance is correct and includes the input amount. Finally, the contract emits a  Swap  event to make the swap discoverable. The event includes all the information about the swap: ...  emit Swap(      msg.sender,      recipient,      amount0,      amount1,      slot0.sqrtPriceX96,      liquidity,      slot0.tick  );  And thats it! The function simply sends some amount of tokens to the specified recipient address and expects a certain number of the other token in exchange. Throughout this book, the function will get much more complicated. Testing Swapping  # Now, we can test the swap function. In the same test file, create  testSwapBuyEth  function and set up the test case. This test case uses the same parameters as  testMintSuccess : function   testSwapBuyEth ()  public  {      TestCaseParams  memory  params  =  TestCaseParams({          wethBalance :   1   ether ,          usdcBalance :   5000   ether ,          currentTick :   85176 ,          lowerTick :   84222 ,          upperTick :   86129 ,          liquidity :   1517882343751509868544 ,          currentSqrtP :   5602277097478614198912276234240 ,          shouldTransferInCallback :   true ,          mintLiqudity :   true       });      ( uint256  poolBalance0,  uint256  poolBalance1)  =  setupTestCase(params);        ...  Next steps will be different, however. Were not going to test that liquidity has been correctly added to the pool since we tested this functionality in the other test cases. To make the test swap, we need 42 USDC: token1.mint( address (this),  42   ether );  Before making the swap, we need to ensure we can transfer tokens to the pool contract when it requests them: function   uniswapV3SwapCallback ( int256  amount0,  int256  amount1)  public  {       if  (amount0  >   0 ) {          token0.transfer(msg.sender,  uint256 (amount0));      }         if  (amount1  >   0 ) {          token1.transfer(msg.sender,  uint256 (amount1));      }  }  Since amounts during a swap can be positive (the amount thats sent to the pool) and negative (the amount thats taken from the pool), in the callback, we only want to send the positive amount, i.e. the amount were trading in. Now, we can call  swap : ( int256  amount0Delta,  int256  amount1Delta)  =  pool.swap( address (this));  The function returns token amounts used in the swap, and we can check them right away: assertEq(amount0Delta,  - 0 . 008396714242162444   ether ,  \"invalid ETH out\" );  assertEq(amount1Delta,  42   ether ,  \"invalid USDC in\" );  Then, we need to ensure that tokens were actually transferred from the caller: assertEq(      token0.balanceOf( address (this)),       uint256 (userBalance0Before  -  amount0Delta),       \"invalid user ETH balance\"   );  assertEq(      token1.balanceOf( address (this)),       0 ,       \"invalid user USDC balance\"   );  And sent to the pool contract: assertEq(      token0.balanceOf( address (pool)),       uint256 ( int256 (poolBalance0)  +  amount0Delta),       \"invalid pool ETH balance\"   );  assertEq(      token1.balanceOf( address (pool)),       uint256 ( int256 (poolBalance1)  +  amount1Delta),       \"invalid pool USDC balance\"   );  Finally, were checking that the pool state was updated correctly: ( uint160  sqrtPriceX96,  int24  tick)  =  pool.slot0();  assertEq(      sqrtPriceX96,       5604469350942327889444743441197 ,       \"invalid current sqrtP\"   );  assertEq(tick,  85184 ,  \"invalid current tick\" );  assertEq(      pool.liquidity(),       1517882343751509868544 ,       \"invalid current liquidity\"   );  Notice that swapping doesnt change the current liquidityin a later chapter, well see when it does change it. Homework  # Write a test that fails with  InsufficientInputAmount  error. Keep in mind that theres a hidden bug     \\[ \\] First Swap Calculating Swap Amounts Implementing a Swap Testing Swapping Homework", "labels": ["Documentation"]}, {"title": "Multi-pool Swaps #", "html_url": "https://uniswapv3book.com/docs/milestone_4/multi-pool-swaps/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Multi-pool Swaps   Multi-pool Swaps Updating Manager Contract Single-pool and Multi-pool Swaps Core Swapping Logic Single-pool Swapping Multi-pool Swapping Swap Callback Updating Quoter Contract Single-pool Quoting Multi-pool Quoting Multi-pool Swaps  # Were now proceeding to the core of this milestoneimplementing multi-pool swaps in our contracts. We wont touch Pool contract in this milestone because its a core contract that should implement only core features. Multi-pool swaps is a utility feature, and well implement it in Manager and Quoter contracts. Updating Manager Contract  # Single-pool and Multi-pool Swaps  # In our current implementation,  swap  function in Manager contract supports only single-pool swaps and takes pool address in parameters: function   swap (       address  poolAddress_,       bool  zeroForOne,       uint256  amountSpecified,       uint160  sqrtPriceLimitX96,       bytes  calldata data  )  public   returns  ( int256 ,  int256 ) { ... }  Were going to split it into two functions: single-pool swap and multi-pool swap. These functions will have different set of parameters: struct   SwapSingleParams  {       address  tokenIn;       address  tokenOut;       uint24  tickSpacing;       uint256  amountIn;       uint160  sqrtPriceLimitX96;  }    struct   SwapParams  {       bytes  path;       address  recipient;       uint256  amountIn;       uint256  minAmountOut;  }  SwapSingleParams  takes pool parameters, input amount, and a limiting pricethis is pretty much identical to what we had before. Notice, that  data  is no longer required. SwapParams  takes path, output amount recipient, input amount, and minimal output amount. The latter parameter replaces  sqrtPriceLimitX96  because, when doing multi-pool swaps, we cannot use the slippage protection from Pool contract (which uses a limiting price). We need to implement another slippage protection, which checks the final output amount and compares it with  minAmountOut : the slippage protection fails when the final output amount is smaller than  minAmountOut . Core Swapping Logic  # Lets implement an internal  _swap  function that will be called by both single- and multi-pool swap functions. Itll prepare parameters and call  Pool.swap . function   _swap (       uint256  amountIn,       address  recipient,       uint160  sqrtPriceLimitX96,      SwapCallbackData  memory  data  )  internal   returns  ( uint256  amountOut) {      ...  SwapCallbackData  is a new data structure that contains data we pass between swap functions and  uniswapV3SwapCallback : struct   SwapCallbackData  {       bytes  path;       address  payer;  }  path  is a swap path and  payer  is the address that provides input tokens in swapswell have different payers during multi-pool swaps. First thing we do in  _swap , is extracting pool parameters using  Path  library: // function _swap(...) {  ( address  tokenIn,  address  tokenOut,  uint24  tickSpacing)  =  data      .path      .decodeFirstPool();  Then we identify swap direction: bool  zeroForOne  =  tokenIn  <  tokenOut;  Then we make the actual swap: // function _swap(...) {  ( int256  amount0,  int256  amount1)  =  getPool(      tokenIn,      tokenOut,      tickSpacing  ).swap(          recipient,          zeroForOne,          amountIn,          sqrtPriceLimitX96  ==   0                ?  (                  zeroForOne                       ?  TickMath.MIN_SQRT_RATIO  +   1                        :  TickMath.MAX_SQRT_RATIO  -   1               )               :  sqrtPriceLimitX96,          abi.encode(data)      );  This piece is identical to what we had before but this time were calling  getPool  to find the pool.  getPool  is a function that sorts tokens and calls  PoolAddress.computeAddress : function   getPool (       address  token0,       address  token1,       uint24  tickSpacing  )  internal   view   returns  (IUniswapV3Pool pool) {      (token0, token1)  =  token0  <  token1           ?  (token0, token1)           :  (token1, token0);      pool  =  IUniswapV3Pool(          PoolAddress.computeAddress(factory, token0, token1, tickSpacing)      );  }  After making a swap, we need to figure out which of the amounts is the output one: // function _swap(...) {  amountOut  =   uint256 ( - (zeroForOne  ?  amount1  :  amount0));  And thats it. Lets now look at how single-pool swap works. Single-pool Swapping  # swapSingle  acts simply as a wrapper of  _swap : function   swapSingle (SwapSingleParams calldata params)       public        returns  ( uint256  amountOut)  {      amountOut  =  _swap(          params.amountIn,          msg.sender,          params.sqrtPriceLimitX96,          SwapCallbackData({              path :  abi.encodePacked(                  params.tokenIn,                  params.tickSpacing,                  params.tokenOut              ),              payer :  msg.sender          })      );  }  Notice that were building a one-pool path here: single-pool swap is a multi-pool swap with one pool . Multi-pool Swapping  # Multi-pool swapping is only slightly more difficult than single-pool swapping. Lets look at it: function   swap (SwapParams  memory  params)  public   returns  ( uint256  amountOut) {       address  payer  =  msg.sender;       bool  hasMultiplePools;      ...  First swap is paid by user because its user who provides input tokens. Then, we start iterating over pools in the path: ...  while  ( true ) {      hasMultiplePools  =  params.path.hasMultiplePools();        params.amountIn  =  _swap(          params.amountIn,          hasMultiplePools  ?   address (this)  :  params.recipient,           0 ,          SwapCallbackData({              path :  params.path.getFirstPool(),              payer :  payer          })      );      ...  In each iteration, were calling  _swap  with these parameters: params.amountIn  tracks input amounts. During the first swap its the amount provided by user. During next swaps its the amounts returned from previous swaps. hasMultiplePools ? address(this) : params.recipient if there are multiple pools in the path, recipient is the manager contract, itll store tokens between swaps. If theres only one pool (last one) in the path, recipient is the one specified in the parameters (usually the same user that initiates the swap). sqrtPriceLimitX96  is set to 0 to disable slippage protection in the Pool contract. Last parameter is what we pass to  uniswapV3SwapCallback well look at it shortly. After making one swap, we need to proceed to next pool in a path or return:     ...         if  (hasMultiplePools) {          payer  =   address (this);          params.path  =  params.path.skipToken();      }  else  {          amountOut  =  params.amountIn;           break ;      }  }  This is where were changing payer and removing a processed pool from the path. Finally, the new slippage protection: if  (amountOut  <  params.minAmountOut)      revert TooLittleReceived(amountOut);  Swap Callback  # Lets look at the updated swap callback: function   uniswapV3SwapCallback (       int256  amount0,       int256  amount1,       bytes  calldata data_  )  public  {      SwapCallbackData  memory  data  =  abi.decode(data_, (SwapCallbackData));      ( address  tokenIn,  address  tokenOut, )  =  data.path.decodeFirstPool();         bool  zeroForOne  =  tokenIn  <  tokenOut;         int256  amount  =  zeroForOne  ?  amount0  :  amount1;         if  (data.payer  ==   address (this)) {          IERC20(tokenIn).transfer(msg.sender,  uint256 (amount));      }  else  {          IERC20(tokenIn).transferFrom(              data.payer,              msg.sender,               uint256 (amount)          );      }  }  The callback expects encoded  SwapCallbackData  with path and payer address. It extracts pool tokens from the path, figures out swap direction ( zeroForOne ), and the amount the contract needs to transfer out. Then, it acts differently depending on payer address: If payer is the current contract (this is so when making consecutive swaps), it transfers tokens to the next pool (the one that called this callback) from current contracts balance. If payer is a different address (the user that initiated the swap), it transfers tokens from users balance. Updating Quoter Contract  # Quoter is another contract that needs to be updated because we want to use it to also find output amounts in multi-pool swaps. Similarly to Manager, well have two variants of  quote  function: single-pool and multi-pool one. Lets look at the former first. Single-pool Quoting  # We need to make only a couple of changes in our current  quote  implementation: rename it to  quoteSingle ; extract parameters into a struct (this is mostly a cosmetic change); instead of a pool address, take two token addresses and a tick spacing in the parameters. // src/UniswapV3Quoter.sol  struct   QuoteSingleParams  {       address  tokenIn;       address  tokenOut;       uint24  tickSpacing;       uint256  amountIn;       uint160  sqrtPriceLimitX96;  }    function   quoteSingle (QuoteSingleParams  memory  params)       public        returns  (           uint256  amountOut,           uint160  sqrtPriceX96After,           int24  tickAfter      )  {      ...  And the only change we have in the body of the function is usage of  getPool  to find the pool address:     ...      IUniswapV3Pool pool  =  getPool(          params.tokenIn,          params.tokenOut,          params.tickSpacing      );         bool  zeroForOne  =  params.tokenIn  <  params.tokenOut;      ...  Multi-pool Quoting  # Multi-pool quoting implementation is similar to the multi-pool swapping one, but it uses fewer parameters. function   quote ( bytes   memory  path,  uint256  amountIn)       public        returns  (           uint256  amountOut,           uint160 []  memory  sqrtPriceX96AfterList,           int24 []  memory  tickAfterList      )  {      sqrtPriceX96AfterList  =   new   uint160 [](path.numPools());      tickAfterList  =   new   int24 [](path.numPools());      ...  As parameters, we only need input amount and swap path. The function returns similar values as  quoteSingle , but price after and tick after are collected after each swap, thus we need to returns arrays. uint256  i  =   0 ;  while  ( true ) {      ( address  tokenIn,  address  tokenOut,  uint24  tickSpacing)  =  path          .decodeFirstPool();        (           uint256  amountOut_,           uint160  sqrtPriceX96After,           int24  tickAfter      )  =  quoteSingle(              QuoteSingleParams({                  tokenIn :  tokenIn,                  tokenOut :  tokenOut,                  tickSpacing :  tickSpacing,                  amountIn :  amountIn,                  sqrtPriceLimitX96 :   0               })          );        sqrtPriceX96AfterList[i]  =  sqrtPriceX96After;      tickAfterList[i]  =  tickAfter;      amountIn  =  amountOut_;      i ++ ;         if  (path.hasMultiplePools()) {          path  =  path.skipToken();      }  else  {          amountOut  =  amountIn;           break ;      }  }  The logic of the loop is identical to the one in the updated  swap  function: get current pools parameters; call  quoteSingle  on current pool; save returned values; repeat if therere more pools in the path, or return otherwise. Multi-pool Swaps Updating Manager Contract Single-pool and Multi-pool Swaps Core Swapping Logic Single-pool Swapping Multi-pool Swapping Swap Callback Updating Quoter Contract Single-pool Quoting Multi-pool Quoting", "labels": ["Documentation"]}, {"title": "NFT Renderer #", "html_url": "https://uniswapv3book.com/docs/milestone_6/nft-renderer/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   NFT Renderer   NFT Renderer SVG Template Dependencies Format of the Result Implementing the Renderer SVG Rendering JSON Rendering Filling the Gap in  tokenURI Gas Costs Testing NFT Renderer  # Now we need to build an NFT renderer: a library that will handle calls to  tokenURI  in the NFT manager contract. It will render JSON metadata and an SVG for each minted token. As we discussed earlier, well use the data URI format, which requires base64 encodingthis means well need a base64 encoder in Solidity. But first, lets look at what our tokens will look like. SVG Template  # I built this simplified variation of the Uniswap V3 NFTs: This is what its code looks like; <svg   xmlns= \"http://www.w3.org/2000/svg\"   viewBox= \"0 0 300 480\" >      <style>       .tokens {        font: bold 30px sans-serif;      }        .fee {        font: normal 26px sans-serif;      }        .tick {        font: normal 18px sans-serif;      }     </style>        <rect   width= \"300\"   height= \"480\"   fill= \"hsl(330,40%,40%)\"   />      <rect   x= \"30\"   y= \"30\"   width= \"240\"   height= \"420\"   rx= \"15\"   ry= \"15\"   fill= \"hsl(330,90%,50%)\"   stroke= \"#000\"   />        <rect   x= \"30\"   y= \"87\"   width= \"240\"   height= \"42\"   />      <text   x= \"39\"   y= \"120\"   class= \"tokens\"   fill= \"#fff\" >       WETH/USDC     </text>        <rect   x= \"30\"   y= \"132\"   width= \"240\"   height= \"30\"   />      <text   x= \"39\"   y= \"120\"   dy= \"36\"   class= \"fee\"   fill= \"#fff\" >       0.05%     </text>        <rect   x= \"30\"   y= \"342\"   width= \"240\"   height= \"24\"   />      <text   x= \"39\"   y= \"360\"   class= \"tick\"   fill= \"#fff\" >       Lower tick: 123456     </text>        <rect   x= \"30\"   y= \"372\"   width= \"240\"   height= \"24\"   />      <text   x= \"39\"   y= \"360\"   dy= \"30\"   class= \"tick\"   fill= \"#fff\" >       Upper tick: 123456     </text>   </svg>   This is a simple SVG template, and were going to make a Solidity contract that fills the fields in this template and returns it in  tokenURI . The fields that will be filled uniquely for each token: the color of the background, which is set in the first two  rect s; the hue component (330 in the template) will be unique for each token; the names of the tokens of a pool the position belongs to (WETH/USDC in the template); the fee of a pool (0.05%); tick values of the boundaries of the position (123456). Here are examples of NFTs our contract will be able to produce:   Dependencies  # Solidity doesnt provide native Base64 encoding tool so well use a third-party one. Specifically, well use  the one from OpenZeppelin . Another tedious thing about Solidity is that is has very poor support for operations with strings. For example, theres no way to convert integers to stringsbut we need that to render pool fee and position ticks in the SVG template. Well use  the Strings library from OpenZeppelin  to do that. Format of the Result  # The data produced by the renderer will have this format: data:application/json;base64,BASE64_ENCODED_JSON  The JSON will look like that: {     \"name\" :  \"Uniswap V3 Position\" ,     \"description\" :  \"USDC/DAI 0.05%, Lower tick: -520, Upper text: 490\" ,     \"image\" :  \"BASE64_ENCODED_SVG\"   }  The image will be the above SVG template filled with position data and encoded in Base64. Implementing the Renderer  # Well implement the renderer in a separate library contract to not make the NFT manager contract too noisy: library  NFTRenderer {       struct   RenderParams  {           address  pool;           address  owner;           int24  lowerTick;           int24  upperTick;           uint24  fee;      }         function   render (RenderParams  memory  params) {          ...      }  }  In the  render  function, well first render an SVG, then a JSON. To keep the code cleaner, well break down each step into smaller steps. We begin with fetching token symbols: function   render (RenderParams  memory  params) {      IUniswapV3Pool pool  =  IUniswapV3Pool(params.pool);      IERC20 token0  =  IERC20(pool.token0());      IERC20 token1  =  IERC20(pool.token1());       string   memory  symbol0  =  token0.symbol();       string   memory  symbol1  =  token1.symbol();        ...  SVG Rendering  # Then we can render the SVG template: string   memory  image  =   string .concat(       \"<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 480'>\" ,       \"<style>.tokens { font: bold 30px sans-serif; }\" ,       \".fee { font: normal 26px sans-serif; }\" ,       \".tick { font: normal 18px sans-serif; }</style>\" ,      renderBackground(params.owner, params.lowerTick, params.upperTick),      renderTop(symbol0, symbol1, params.fee),      renderBottom(params.lowerTick, params.upperTick),       \"</svg>\"   );  The template is broken down into multiple steps: first comes the header, which includes the CSS styles; then the background is rendered; then the top position information is rendered (token symbols and fee); finally, the bottom information is rendered (position ticks). The background is simply two  rect s. To render them we need to find the unique hue of this token and then we concatenate all the pieces together: function   renderBackground (       address  owner,       int24  lowerTick,       int24  upperTick  )  internal   pure   returns  ( string   memory  background) {       bytes32  key  =  keccak256(abi.encodePacked(owner, lowerTick, upperTick));       uint256  hue  =   uint256 (key)  %   360 ;        background  =   string .concat(           '<rect width=\"300\" height=\"480\" fill=\"hsl(' ,          Strings.toString(hue),           ',40%,40%)\"/>' ,           '<rect x=\"30\" y=\"30\" width=\"240\" height=\"420\" rx=\"15\" ry=\"15\" fill=\"hsl(' ,          Strings.toString(hue),           ',100%,50%)\" stroke=\"#000\"/>'       );  }  The top template renders token symbols and pool fee: function   renderTop (       string   memory  symbol0,       string   memory  symbol1,       uint24  fee  )  internal   pure   returns  ( string   memory  top) {      top  =   string .concat(           '<rect x=\"30\" y=\"87\" width=\"240\" height=\"42\"/>' ,           '<text x=\"39\" y=\"120\" class=\"tokens\" fill=\"#fff\">' ,          symbol0,           \"/\" ,          symbol1,           \"</text>\"            '<rect x=\"30\" y=\"132\" width=\"240\" height=\"30\"/>' ,           '<text x=\"39\" y=\"120\" dy=\"36\" class=\"fee\" fill=\"#fff\">' ,          feeToText(fee),           \"</text>\"       );  }  Fees are rendered as numbers with a fractional part. Since all possible fees are known in advance we dont need to convert integers to fractional numbers and can simply hardcode the values: function   feeToText ( uint256  fee)       internal        pure        returns  ( string   memory  feeString)  {       if  (fee  ==   500 ) {          feeString  =   \"0.05%\" ;      }  else   if  (fee  ==   3000 ) {          feeString  =   \"0.3%\" ;      }  }  In the bottom part we render position ticks: function   renderBottom ( int24  lowerTick,  int24  upperTick)       internal        pure        returns  ( string   memory  bottom)  {      bottom  =   string .concat(           '<rect x=\"30\" y=\"342\" width=\"240\" height=\"24\"/>' ,           '<text x=\"39\" y=\"360\" class=\"tick\" fill=\"#fff\">Lower tick: ' ,          tickToText(lowerTick),           \"</text>\" ,           '<rect x=\"30\" y=\"372\" width=\"240\" height=\"24\"/>' ,           '<text x=\"39\" y=\"360\" dy=\"30\" class=\"tick\" fill=\"#fff\">Upper tick: ' ,          tickToText(upperTick),           \"</text>\"       );  }  Since ticks can be positive and negative, we need to render them properly (with or without the minus sign): function   tickToText ( int24  tick)       internal        pure        returns  ( string   memory  tickString)  {      tickString  =   string .concat(          tick  <   0   ?   \"-\"   :   \"\" ,          tick  <   0                ?  Strings.toString( uint256 ( uint24 ( - tick)))               :  Strings.toString( uint256 ( uint24 (tick)))      );  }  JSON Rendering  # Now, lets return to the  render  function and render the JSON. First, we need to render a token description: function   render (RenderParams  memory  params) {      ... SVG rendering ...         string   memory  description  =  renderDescription(          symbol0,          symbol1,          params.fee,          params.lowerTick,          params.upperTick      );        ...  Token description is a text string that contains all the same information that we render in tokens SVG: function   renderDescription (       string   memory  symbol0,       string   memory  symbol1,       uint24  fee,       int24  lowerTick,       int24  upperTick  )  internal   pure   returns  ( string   memory  description) {      description  =   string .concat(          symbol0,           \"/\" ,          symbol1,           \" \" ,          feeToText(fee),           \", Lower tick: \" ,          tickToText(lowerTick),           \", Upper text: \" ,          tickToText(upperTick)      );  }  We can now assemble the JSON metadata: function   render (RenderParams  memory  params) {       string   memory  image  =  ...SVG rendering...       string   memory  description  =  ...description rendering...         string   memory  json  =   string .concat(           '{\"name\":\"Uniswap V3 Position\",' ,           '\"description\":\"' ,          description,           '\",' ,           '\"image\":\"data:image/svg+xml;base64,' ,          Base64.encode( bytes (image)),           '\"}'       );  And, finally, we can return the result: return        string .concat(           \"data:application/json;base64,\" ,          Base64.encode( bytes (json))      );  Filling the Gap in  tokenURI   # Now were ready to return to the  tokenURI  function in the NFT manager contract and add the actual rendering: function   tokenURI ( uint256  tokenId)       public        view        override        returns  ( string   memory )  {      TokenPosition  memory  tokenPosition  =  positions[tokenId];       if  (tokenPosition.pool  ==   address ( 0x00 )) revert WrongToken();        IUniswapV3Pool pool  =  IUniswapV3Pool(tokenPosition.pool);         return           NFTRenderer.render(              NFTRenderer.RenderParams({                  pool :  tokenPosition.pool,                  owner :   address (this),                  lowerTick :  tokenPosition.lowerTick,                  upperTick :  tokenPosition.upperTick,                  fee :  pool.fee()              })          );  }  Gas Costs  # With all its benefits, storing data on-chain has a huge disadvantage: contract deployments become very expensive. When deploying a contract, you pay for the size of the contract, and all the strings and templates increase gas spending significantly. This gets even worse the more advanced your SVGs are: the more there are shapes, CSS styles, animations, etc. the more expensive it gets. Keep in mind that the NFT renderer we implemented above is not gas optimized: you can see the repetitive  rect  and  text  tag strings that can be extracted into internal functions. I sacrificed gas efficiency for the readability of the contract. In real NFT projects that store all data on-chain, code readability is usually very poor due to heavy gas cost optimizations. Testing  # The last thing I wanted to focus here is how we can test the NFT images. Its very important to keep all changes in NFT images tracked to ensure no change breaks rendering. For this, we need a way to test the output of  tokenURI  and its different variations (we can even pre-render the whole collection and have tests to ensure no image get broken during development). To test the output of  tokenURI , I added this custom assertion: assertTokenURI(      nft.tokenURI(tokenId0),       \"tokenuri0\" ,       \"invalid token URI\"   );  The first argument is the actual output and the second argument is the name of the file that stores the expected one. The assertion loads the content of the file and compares it with the actual one: function   assertTokenURI (       string   memory  actual,       string   memory  expectedFixture,       string   memory  errMessage  )  internal  {       string   memory  expected  =  vm.readFile(           string .concat( \"./test/fixtures/\" , expectedFixture)      );        assertEq(actual,  string (expected), errMessage);  }  We can do this in Solidity thanks to the  vm.readFile()  cheat code provided by  forge-std  library, which is a helper library that comes with Forge. Not only this is simple and convenient, this is also secure: we can configure filesystem permissions to allow only permitted file operations. Specifically, to make the above test work, we need to add this  fs_permissions  rule to  foundry.toml : fs_permissions  = [{ access = 'read' , path = '.' }]  And this is how you can read the SVG from a  tokenURI  fixture: $ cat test/fixtures/tokenuri0  \\      | awk -F  ','   '{print $2}'   \\      | base64 -d -  \\      | jq -r .image  \\      | awk -F  ','   '{print $2}'   \\      | base64 -d - > nft.svg  \\       &&  open nft.svg  Ensure you have  jq tool  installed. NFT Renderer SVG Template Dependencies Format of the Result Implementing the Renderer SVG Rendering JSON Rendering Filling the Gap in  tokenURI Gas Costs Testing", "labels": ["Documentation"]}, {"title": "Protocol Fees #", "html_url": "https://uniswapv3book.com/docs/milestone_5/protocol-fees/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Protocol Fees   Protocol Fees Protocol Fees  # While working on the Uniswap implementation, youve probably asked yourself, How does Uniswap make money? Well, it doesnt (at least as of September 2022). In the implementation weve built so far, traders pay liquidity providers for providing liquidity, and Uniswap Labs, as the company that developed the DEX, is not part of this process. Neither traders, nor liquidity providers pay Uniswap Labs for using the Uniswap DEX. How come? In fact, theres a way for Uniswap Labs to start making money on the DEX. However, the mechanism hasnt been enabled yet (again, as of September 2022). Each Uniswap pool has  protocol fees  collection mechanism. Protocol fees are collected from swap fees: a small portion of swap fees is subtracted and saved as protocol fees to later be collected by Factory contract owner (Uniswap Labs). The size of protocol fees is expected to be determined by UNI token holders, but it must be between $1/4$ and $1/10$ (inclusive) of swap fees. For brevity, were not going to add protocol fees to our implementation, but lets see how theyre implemented in Uniswap. Protocol fee size is stored in  slot0 : // UniswapV3Pool.sol  struct   Slot0  {      ...       // the current protocol fee as a percentage of the swap fee taken on withdrawal       // represented as an integer denominator (1/x)%       uint8  feeProtocol;      ...  }  And a global accumulator is needed to track accrued fees: // accumulated protocol fees in token0/token1 units  struct   ProtocolFees  {       uint128  token0;       uint128  token1;  }  ProtocolFees  public   override  protocolFees;  Protocol fees are set in the  setFeeProtocol  function: function   setFeeProtocol ( uint8  feeProtocol0,  uint8  feeProtocol1)  external   override  lock onlyFactoryOwner {      require(          (feeProtocol0  ==   0   ||  (feeProtocol0  >=   4   &&  feeProtocol0  <=   10 ))  &&               (feeProtocol1  ==   0   ||  (feeProtocol1  >=   4   &&  feeProtocol1  <=   10 ))      );       uint8  feeProtocolOld  =  slot0.feeProtocol;      slot0.feeProtocol  =  feeProtocol0  +  (feeProtocol1  <<   4 );      emit SetFeeProtocol(feeProtocolOld  %   16 , feeProtocolOld  >>   4 , feeProtocol0, feeProtocol1);  }  As you can see, its allowed to set protocol fees separate for each of the tokens. The values are two  uint8  that are packed to be stored in one  uint8 :  feeProtocol1  is shifted to the left by 4 bits (this is identical to multiplying it by 16) and added to  feeProtocol0 . To unpack  feeProtocol0 , a remainder of division  slot0.feeProtocol  by 16 is taken;  feeProtocol1  is simply shifting  slot0.feeProtocol  to the right by 4 bits. Such packing works because neither  feeProtocol0 , nor  feeProtocol1  can be greater than 10. Before beginning a swap, we need to choose one of the protocol fees depending on swap direction (swap and protocol fees are collected on input tokens): function   swap (...) {      ...       uint8  feeProtocol  =  zeroForOne  ?  (slot0_.feeProtocol  %   16 )  :  (slot0_.feeProtocol  >>   4 );      ...  To accrue protocol fees, we subtract them from swap fees right after computing swap step amounts: ...  while  (...) {      (..., step.feeAmount)  =  SwapMath.computeSwapStep(...);         if  (cache.feeProtocol  >   0 ) {           uint256  delta  =  step.feeAmount  /  cache.feeProtocol;          step.feeAmount  -=  delta;          state.protocolFee  +=   uint128 (delta);      }        ...  }  ...  After a swap is done, the global protocol fees accumulator needs to be updated: if  (zeroForOne) {       if  (state.protocolFee  >   0 ) protocolFees.token0  +=  state.protocolFee;  }  else  {       if  (state.protocolFee  >   0 ) protocolFees.token1  +=  state.protocolFee;  }  Finally, Factory contract owner can collect accrued protocol fees by calling  collectProtocol : function   collectProtocol (       address  recipient,       uint128  amount0Requested,       uint128  amount1Requested  )  external   override  lock onlyFactoryOwner  returns  ( uint128  amount0,  uint128  amount1) {      amount0  =  amount0Requested  >  protocolFees.token0  ?  protocolFees.token0  :  amount0Requested;      amount1  =  amount1Requested  >  protocolFees.token1  ?  protocolFees.token1  :  amount1Requested;         if  (amount0  >   0 ) {           if  (amount0  ==  protocolFees.token0) amount0 -- ;          protocolFees.token0  -=  amount0;          TransferHelper.safeTransfer(token0, recipient, amount0);      }       if  (amount1  >   0 ) {           if  (amount1  ==  protocolFees.token1) amount1 -- ;          protocolFees.token1  -=  amount1;          TransferHelper.safeTransfer(token1, recipient, amount1);      }        emit CollectProtocol(msg.sender, recipient, amount0, amount1);  }     \\[ \\] Protocol Fees", "labels": ["Documentation"]}, {"title": "Slippage Protection #", "html_url": "https://uniswapv3book.com/docs/milestone_3/slippage-protection/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Slippage Protection   Slippage Protection Slippage Protection in Swaps Slippage Protection in Minting Slippage Protection  # Slippage is a very important issued in decentralized exchanges. Slippage simply means the difference between the price that you see on the screen when initialing a transaction and the actual price the swap is executed at. This difference appears because theres a short (and sometimes long, depending on network congestion and gas costs) delay between when you send a transaction and when it gets mined. In more technical terms, blockchain state changes every block and theres no guarantee that your transaction will be applied at a specific block. Another important problem that slippage protection fixes is  sandwich attacks this is a common type of attacks on decentralized exchange users. During sandwiching, attackers wrap your swap transactions in their two transactions: one goes before your transaction and the other goes after it. In the first transaction, an attacker modifier the state of a pool so that your swap becomes very unprofitable for you and somewhat profitable for the attacker. This is achieved by adjusting pool liquidity so that your trade happens at a lower price. In the second transaction, the attacker reestablishes pool liquidity and the price. As a result, you get much less tokens than expected due to manipulated prices, and the attacker get some profit. The way slippage protection is implemented in decentralized exchanges is by letting user choose how far the actual price is allowed to drop. By default, Uniswap V3 sets slippage tolerance to 0.1%, which means a swap is executed only if the price at the moment of execution is not smaller than 99.9% of the price the user saw in the browser. This is a very tight range and users are allowed to adjust this number, which is useful when volatility is high. Lets add slippage protection to our implementation! Slippage Protection in Swaps  # To protect swaps, we need to add one more parameter to  swap  functionwe want to let user choose a stop price, a price at which swapping will stop. Well call the parameter  sqrtPriceLimitX96 : function   swap (       address  recipient,       bool  zeroForOne,       uint256  amountSpecified,       uint160  sqrtPriceLimitX96,       bytes  calldata data  )  public   returns  ( int256  amount0,  int256  amount1) {      ...       if  (          zeroForOne               ?  sqrtPriceLimitX96  >  slot0_.sqrtPriceX96  ||                   sqrtPriceLimitX96  <  TickMath.MIN_SQRT_RATIO               :  sqrtPriceLimitX96  <  slot0_.sqrtPriceX96  &&                   sqrtPriceLimitX96  >  TickMath.MAX_SQRT_RATIO      ) revert InvalidPriceLimit();      ...  When selling token $x$ ( zeroForOne  is true),  sqrtPriceLimitX96  must be between the current price and the minimal $\\sqrt{P}$ since selling token $x$ moves the price down. Likewise, when selling token $y$,  sqrtPriceLimitX96  must be between the current price and the maximal $\\sqrt{P}$ because price moves up. In the while loop, we want to satisfy two conditions: full swap amount has not been filled and current price isnt equal to  sqrtPriceLimitX96 : ..  while  (      state.amountSpecifiedRemaining  >   0   &&       state.sqrtPriceX96  !=  sqrtPriceLimitX96  ) {  ...  Which means that Uniswap V3 pools dont fail when slippage tolerance gets hit and simply executes swap partially. Another place where we need to consider  sqrtPriceLimitX96  is when calling  SwapMath.computeSwapStep : (state.sqrtPriceX96, step.amountIn, step.amountOut)  =  SwapMath      .computeSwapStep(          state.sqrtPriceX96,          (              zeroForOne                   ?  step.sqrtPriceNextX96  <  sqrtPriceLimitX96                   :  step.sqrtPriceNextX96  >  sqrtPriceLimitX96          )               ?  sqrtPriceLimitX96               :  step.sqrtPriceNextX96,          state.liquidity,          state.amountSpecifiedRemaining      );  Here, we want to ensure that  computeSwapStep  never calculates swap amounts outside of  sqrtPriceLimitX96 this guarantees that the current price will never cross the limiting price. Slippage Protection in Minting  # Adding liquidity also requires slippage protection. This comes from the fact that price cannot be changed when adding liquidity (liquidity must be proportional to current price), thus liquidity providers also suffer from slippage. Unlike  swap  function however, were not forced to implement slippage protection in Pool contractrecall that Pool contract is a core contract and we dont want to put unnecessary logic into it. This is why we made the Manager contract, and its in the Manager contract where well implement slippage protection. The Manager contract is a wrapper contract that makes calls to Pool contract more convenient. To implement slippage protection in the  mint  function, we can simply check the amounts of tokens taken by Pool and compare them to some minimal amounts chosen by user. Additionally, we can free users from calculating $\\sqrt{P_{lower}}$ and $\\sqrt{P_{upper}}$, as well as liquidity, and calculate these in  Manager.mint() . Our updated  mint  function will now take more parameters, so lets group them in a struct: // src/UniswapV3Manager.sol  contract   UniswapV3Manager  {       struct   MintParams  {           address  poolAddress;           int24  lowerTick;           int24  upperTick;           uint256  amount0Desired;           uint256  amount1Desired;           uint256  amount0Min;           uint256  amount1Min;      }         function   mint (MintParams calldata params)           public            returns  ( uint256  amount0,  uint256  amount1)      {          ...  amount0Min  and  amount1Min  are the amounts that are calculated based on slippage tolerance. They must be smaller than the desired amounts, with the gap controlled by the slippage tolerance setting. Liquidity provider expect to provide amounts not smaller than  amount0Min  and  amount1Min . Next, we calculate $\\sqrt{P_{lower}}$, $\\sqrt{P_{upper}}$, and liquidity: ...  IUniswapV3Pool pool  =  IUniswapV3Pool(params.poolAddress);    ( uint160  sqrtPriceX96, )  =  pool.slot0();  uint160  sqrtPriceLowerX96  =  TickMath.getSqrtRatioAtTick(      params.lowerTick  );  uint160  sqrtPriceUpperX96  =  TickMath.getSqrtRatioAtTick(      params.upperTick  );    uint128  liquidity  =  LiquidityMath.getLiquidityForAmounts(      sqrtPriceX96,      sqrtPriceLowerX96,      sqrtPriceUpperX96,      params.amount0Desired,      params.amount1Desired  );  ...  LiquidityMath.getLiquidityForAmounts  is a new function, well discuss it in the next chapter. Next step is to provide liquidity to the pool and check the amounts returned by the pool: if theyre too low, we revert. (amount0, amount1)  =  pool.mint(      msg.sender,      params.lowerTick,      params.upperTick,      liquidity,      abi.encode(          IUniswapV3Pool.CallbackData({              token0 :  pool.token0(),              token1 :  pool.token1(),              payer :  msg.sender          })      )  );    if  (amount0  <  params.amount0Min  ||  amount1  <  params.amount1Min)      revert SlippageCheckFailed(amount0, amount1);  Thats it!    \\[ \\] Slippage Protection Slippage Protection in Swaps Slippage Protection in Minting", "labels": ["Documentation"]}, {"title": "Tick Bitmap Index #", "html_url": "https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Tick Bitmap Index   Tick Bitmap Index Bitmap TickBitmap Contract Flipping Flags Finding Next Tick Tick Bitmap Index  # As the first step towards dynamic swaps, we need to implement an index of ticks. In the previous milestone, we used to calculate the target tick when making a swap: function   swap ( address  recipient,  bytes  calldata data)       public        returns  ( int256  amount0,  int256  amount1)  {     int24  nextTick  =   85184 ;    ...  }  When theres liquidity provided in different price ranges, we cannot simply calculate the target tick. We need to  find it . Thus, we need to index all ticks that have liquidity and then use the index to find ticks to inject enough liquidity for a swap. In this step, were going to implement such index. Bitmap  # Bitmap is a popular technique of indexing data in a compact way. A bitmap is simply a number represented in the binary system, e.g. 31337 is  111101001101001 . We can look at it as an array of zeros and ones, with each digit having an index. We then say that 0 means a flag is not set and 1 means its set. So what we get is a very compact array of indexed flags: each byte can fit 8 flags. In Solidity, we can have integers up to 256 bits, which means one  uint256  can hold 256 flags. Uniswap V3 uses this technique to store the information about initialized ticks, that is ticks with some liquidity. When a flag is set (1), the tick has liquidity; when a flag is not set (0), the tick is not initialized. Lets look at the implementation. TickBitmap Contract  # In the pool contract, the tick index is stored in a state variable: contract   UniswapV3Pool  {       using  TickBitmap  for   mapping ( int16   =>   uint256 );       mapping ( int16   =>   uint256 )  public  tickBitmap;      ...  }  This is mapping where keys are  int16 s and values are words ( uint256 ). Imagine an infinite continuous array of ones and zeros: Each element in this array corresponds to a tick. To navigate in this array, we break it into words: sub-arrays of length 256 bits. To find ticks position in this array, we do: function   position ( int24  tick)  private   pure   returns  ( int16  wordPos,  uint8  bitPos) {      wordPos  =   int16 (tick  >>   8 );      bitPos  =   uint8 ( uint24 (tick  %   256 ));  }  That is: we find its word position and then its bit in this word.  >> 8  is identical to integer division by 256. So, word position is the integer part of a tick index divided by 256, and bit position is the remainder. As an example, lets calculate word and bit positions for one of our ticks: tick  =   85176   word_pos  =  tick  >>   8   # or tick // 2**8   bit_pos  =  tick  %   256   print( f \"Word  { word_pos } , bit  { bit_pos } \" )  # Word 332, bit 184   Flipping Flags  # When adding liquidity into a pool, we need to set a couple of tick flags in the bitmap: one for the lower tick and one for the upper tick. We do this in  flipTick  method of the bitmap mapping: function   flipTick (       mapping ( int16   =>   uint256 )  storage  self,       int24  tick,       int24  tickSpacing  )  internal  {      require(tick  %  tickSpacing  ==   0 );  // ensure that the tick is spaced      ( int16  wordPos,  uint8  bitPos)  =  position(tick  /  tickSpacing);       uint256  mask  =   1   <<  bitPos;      self[wordPos]  ^=  mask;  }  Until later in the book,  tickSpacing  is always 1. After finding word and bit positions, we need to make a mask. A mask is a number that has a single 1 flag set at the bit position of the tick. To find the mask, we simply calculate  2**bit_pos  (equivalent of  1 << bit_pos ): mask  =   2 ** bit_pos  # or 1 << bit_pos   print(bin(mask))  #0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000   Next, to flip a flag, we apply the mask to the ticks word via bitwise XOR: word  =  ( 2 ** 256 )  -   1   # set word to all ones   print(bin(word  ^  mask))                                                      here  #0b1111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111   Youll see that 184th bit (counting from the right starting at 0) has flipped to 0. If a bit is zero, itll set it to 1: word  =   0   print(bin(word  ^  mask))  #0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000   Finding Next Tick  # Next step is finding ticks with liquidity using the bitmap index. During swapping, we need to find a tick with liquidity thats before or after the current tick (that is: to the left or to the right of it). In the previous milestone, we used to  calculate and hard code it , but now we need to find such tick using the bitmap index. Well do this in the  TickBitmap.nextInitializedTickWithinOneWord  function. In this function, well need to implement two scenarios: When selling token $x$ (ETH in our case), find next initialized tick in the current ticks word and  to the right  of the current tick. When selling token $y$ (USDC in our case), find next initialized tick in the next (current + 1) ticks word and  to the left  of the current tick. This corresponds to the price movement when making swaps in either directions: Be aware that, in the code, the direction is flipped: when buying token $x$, we search for initialized ticks  to the left  of the current; when selling token $x$, we search ticks  to the right . But this is only true within a word; words are ordered from left to right. When theres no initialized tick in the current word, well continue searching in an adjacent word in the next loop cycle. Now, lets look at the implementation: function   nextInitializedTickWithinOneWord (       mapping ( int16   =>   uint256 )  storage  self,       int24  tick,       int24  tickSpacing,       bool  lte  )  internal   view   returns  ( int24  next,  bool  initialized) {       int24  compressed  =  tick  /  tickSpacing;      ...  First arguments makes this function a method of  mapping(int16 => uint256) . tick  is the current tick. tickSpacing  is always 1 until we start using it in Milestone 4. lte  is the flag that sets the direction. When  true , were selling token $x$ and searching for next initialized tick to the right of the current one. When  false,  its the other way around.  lte  equals to the swap direction:  true  when selling token $x$,  false  otherwise. if  (lte) {      ( int16  wordPos,  uint8  bitPos)  =  position(compressed);       uint256  mask  =  ( 1   <<  bitPos)  -   1   +  ( 1   <<  bitPos);       uint256  masked  =  self[wordPos]  &  mask;      ...  When selling $x$, were: taking current ticks word and bit positions; making a mask where all bits to the right of the current bit position, including it, are ones ( mask  is all ones, its length =  bitPos ); applying the mask to the current ticks word.     ...      initialized  =  masked  !=   0 ;      next  =  initialized           ?  (compressed  -   int24 ( uint24 (bitPos  -  BitMath.mostSignificantBit(masked))))  *  tickSpacing           :  (compressed  -   int24 ( uint24 (bitPos)))  *  tickSpacing;      ...  Next,  masked  wont equal 0 if at least one bit of it is set to 1. If so, theres an initialized tick; if not, there isnt (not in the current word). Depending on the result, we either return the index of the next initialized tick or the leftmost bit in the next wordthis will allow to search for initialized ticks in the word during another loop cycle.     ...  }  else  {      ( int16  wordPos,  uint8  bitPos)  =  position(compressed  +   1 );       uint256  mask  =   ~ (( 1   <<  bitPos)  -   1 );       uint256  masked  =  self[wordPos]  &  mask;      ...  Similarly, when selling $y$, were: taking next ticks word and bit positions; making a different mask, where all bits to the left of next tick bit position are ones and all the bits to the right are zeros; applying the mask to the next ticks word. Again, if theres no initialized ticks to the left, the rightmost bit of the previous word is returned:     ...      initialized  =  masked  !=   0 ;       // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick      next  =  initialized           ?  (compressed  +   1   +   int24 ( uint24 ((BitMath.leastSignificantBit(masked)  -  bitPos))))  *  tickSpacing           :  (compressed  +   1   +   int24 ( uint24 ((type( uint8 ).max  -  bitPos))))  *  tickSpacing;  }  And thats it! As you can see,  nextInitializedTickWithinOneWord  doesnt find the exact tick if its far awayits scope of search is current or next ticks word. Indeed, we dont want to iterate over the infinite bitmap index.    \\[ \\] Tick Bitmap Index Bitmap TickBitmap Contract Flipping Flags Finding Next Tick", "labels": ["Documentation"]}, {"title": "Generalize Minting #", "html_url": "https://uniswapv3book.com/docs/milestone_2/generalize-minting/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Generalize Minting   Generalize Minting Indexing Initialized Ticks Token Amounts Calculation Generalize Minting  # Now, were ready to update  mint  function so we dont need to hard code values anymore and can calculate them instead. Indexing Initialized Ticks  # Recall that, in the  mint  function, we update the TickInfo mapping to store information about available liquidity at ticks. Now, we also need to index newly initialized ticks in the bitmap indexwell later use this index to find next initialized tick during swapping. First, we need to update  Tick.update  function: // src/lib/Tick.sol  function   update (       mapping ( int24   =>  Tick.Info)  storage  self,       int24  tick,       uint128  liquidityDelta  )  internal   returns  ( bool  flipped) {      ...      flipped  =  (liquidityAfter  ==   0 )  !=  (liquidityBefore  ==   0 );      ...  }  It now returns  flipped  flag, which is set to true when liquidity is added to an empty tick or when entire liquidity is removed from a tick. Then, in  mint  function, we update the bitmap index: // src/UniswapV3Pool.sol  ...  bool  flippedLower  =  ticks.update(lowerTick, amount);  bool  flippedUpper  =  ticks.update(upperTick, amount);    if  (flippedLower) {      tickBitmap.flipTick(lowerTick,  1 );  }    if  (flippedUpper) {      tickBitmap.flipTick(upperTick,  1 );  }  ...  Again, were setting tick spacing to 1 until we introduce different values in Milestone 4. Token Amounts Calculation  # The biggest change in  mint  function is switching to tokens amount calculation. In Milestone 1, we hard coded these values:     amount0  =   0 . 998976618347425280   ether ;      amount1  =   5000   ether ;  And now were going to calculate them in Solidity using formulas from Milestone 1. Lets recall those formulas: $$\\Delta x = \\frac{L(\\sqrt{p(i_u)} - \\sqrt{p(i_c)})}{\\sqrt{p(i_u)}\\sqrt{p(i_c)}}$$ $$\\Delta y = L(\\sqrt{p(i_c)} - \\sqrt{p(i_l)})$$ $\\Delta x$ is the amount of  token0 , or token $x$. Lets implement it in Solidity: // src/lib/Math.sol  function   calcAmount0Delta (       uint160  sqrtPriceAX96,       uint160  sqrtPriceBX96,       uint128  liquidity  )  internal   pure   returns  ( uint256  amount0) {       if  (sqrtPriceAX96  >  sqrtPriceBX96)          (sqrtPriceAX96, sqrtPriceBX96)  =  (sqrtPriceBX96, sqrtPriceAX96);        require(sqrtPriceAX96  >   0 );        amount0  =  divRoundingUp(          mulDivRoundingUp(              ( uint256 (liquidity)  <<  FixedPoint96.RESOLUTION),              (sqrtPriceBX96  -  sqrtPriceAX96),              sqrtPriceBX96          ),          sqrtPriceAX96      );  }  This function is identical to  calc_amount0  in our Python script. First step is to sort the prices to ensure we dont underflow when subtracting. Next, we convert  liquidity  to a Q96.64 number by multiplying it by 2**96. Next, according to the formula, we multiply it by the difference of the prices and divide it by the bigger price. Then, we divide by the smaller price. The order of division doesnt matter, but we want to have two divisions because multiplication of prices can overflow. Were using  mulDivRoundingUp  to multiply and divide in one operation. This function is based on  mulDiv  from  PRBMath : function   mulDivRoundingUp (       uint256  a,       uint256  b,       uint256  denominator  )  internal   pure   returns  ( uint256  result) {      result  =  PRBMath.mulDiv(a, b, denominator);       if  (mulmod(a, b, denominator)  >   0 ) {          require(result  <  type( uint256 ).max);          result ++ ;      }  }  mulmod  is a Solidity function that multiplies two numbers ( a  and  b ), divides the result by  denominator , and returns the remainder. If the remainder is positive, we round the result up. Next, $\\Delta y$: function   calcAmount1Delta (       uint160  sqrtPriceAX96,       uint160  sqrtPriceBX96,       uint128  liquidity  )  internal   pure   returns  ( uint256  amount1) {       if  (sqrtPriceAX96  >  sqrtPriceBX96)          (sqrtPriceAX96, sqrtPriceBX96)  =  (sqrtPriceBX96, sqrtPriceAX96);        amount1  =  mulDivRoundingUp(          liquidity,          (sqrtPriceBX96  -  sqrtPriceAX96),          FixedPoint96.Q96      );  }  This function is identical to  calc_amount1  in our Python script. Again, were using  mulDivRoundingUp  to avoid overflows during multiplication. And thats it! We can now use the functions to calculate token amounts: // src/UniswapV3Pool.sol  function   mint (...) {      ...      Slot0  memory  slot0_  =  slot0;        amount0  =  Math.calcAmount0Delta(          slot0_.sqrtPriceX96,          TickMath.getSqrtRatioAtTick(upperTick),          amount      );        amount1  =  Math.calcAmount1Delta(          slot0_.sqrtPriceX96,          TickMath.getSqrtRatioAtTick(lowerTick),          amount      );      ...  }  Everything else remains the same. Youll need to update the amounts in the pool tests, theyll be slightly different due to rounding.    \\[ \\] Generalize Minting Indexing Initialized Ticks Token Amounts Calculation", "labels": ["Documentation"]}, {"title": "Liquidity Calculation #", "html_url": "https://uniswapv3book.com/docs/milestone_3/liquidity-calculation/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Liquidity Calculation   Liquidity Calculation Implementing Liquidity Calculation for Token X Implementing Liquidity Calculation for Token Y Finding Fair Liquidity Liquidity Calculation  # Of the whole math of Uniswap V3, what we havent yet implemented in Solidity is liquidity calculation. In the Python script, we have these functions: def   liquidity0 (amount, pa, pb):       if  pa  >  pb:          pa, pb  =  pb, pa       return  (amount  *  (pa  *  pb)  /  q96)  /  (pb  -  pa)      def   liquidity1 (amount, pa, pb):       if  pa  >  pb:          pa, pb  =  pb, pa       return  amount  *  q96  /  (pb  -  pa)  Lets implement them in Solidity so we could calculate liquidity in the  Manager.mint()  function. Implementing Liquidity Calculation for Token X  # The functions were going to implement allow us to calculate liquidity ($L = \\sqrt{xy}$) when token amounts and price ranges are known. Luckily, we already know all the formulas. Lets recall this one: $$\\Delta x = \\Delta \\frac{1}{\\sqrt{P}}L$$ In a previous chapter, we used this formula to calculate swap amounts ($\\Delta x$ in this case) and now were going to use it to find $L$: $$L = \\frac{\\Delta x}{\\Delta \\frac{1}{\\sqrt{P}}}$$ Or, after simplifying it: $$L = \\frac{\\Delta x \\sqrt{P_u} \\sqrt{P_l}}{\\sqrt{P_u} - \\sqrt{P_l}}$$ We derived this formula in  Liquidity Amount Calculation . In Solidity, well again use  PRBMath  to handle overflows when multiplying and then dividing: function   getLiquidityForAmount0 (       uint160  sqrtPriceAX96,       uint160  sqrtPriceBX96,       uint256  amount0  )  internal   pure   returns  ( uint128  liquidity) {       if  (sqrtPriceAX96  >  sqrtPriceBX96)          (sqrtPriceAX96, sqrtPriceBX96)  =  (sqrtPriceBX96, sqrtPriceAX96);         uint256  intermediate  =  PRBMath.mulDiv(          sqrtPriceAX96,          sqrtPriceBX96,          FixedPoint96.Q96      );      liquidity  =   uint128 (          PRBMath.mulDiv(amount0, intermediate, sqrtPriceBX96  -  sqrtPriceAX96)      );  }  Implementing Liquidity Calculation for Token Y  # Similarly, well use the other formula from  Liquidity Amount Calculation  to find $L$ when amount of $y$ and price range is known: $$\\Delta y = \\Delta\\sqrt{P} L$$ $$L = \\frac{\\Delta y}{\\sqrt{P_u}-\\sqrt{P_l}}$$ function   getLiquidityForAmount1 (       uint160  sqrtPriceAX96,       uint160  sqrtPriceBX96,       uint256  amount1  )  internal   pure   returns  ( uint128  liquidity) {       if  (sqrtPriceAX96  >  sqrtPriceBX96)          (sqrtPriceAX96, sqrtPriceBX96)  =  (sqrtPriceBX96, sqrtPriceAX96);        liquidity  =   uint128 (          PRBMath.mulDiv(              amount1,              FixedPoint96.Q96,              sqrtPriceBX96  -  sqrtPriceAX96          )      );  }  I hope this is clear! Finding Fair Liquidity  # You might be wondering why there are two ways of calculating $L$ while we have always had only one $L$, which is calculated as $L = \\sqrt{xy}$, and which of these ways is correct. The answer is: theyre both correct. In the above formulas, we calculate $L$ based on different parameters: price range and the amount of either token. Different price ranges and different token amounts will result in different values of $L$. And theres a scenario where we need to calculate both of the $L$s and pick one of them. Recall this piece from  mint  function: if  (slot0_.tick  <  lowerTick) {      amount0  =  Math.calcAmount0Delta(...);  }  else   if  (slot0_.tick  <  upperTick) {      amount0  =  Math.calcAmount0Delta(...);        amount1  =  Math.calcAmount1Delta(...);        liquidity  =  LiquidityMath.addLiquidity(liquidity,  int128 (amount));  }  else  {      amount1  =  Math.calcAmount1Delta(...);  }  It turns out, we also need to follow this logic when calculating liquidity: if were calculating liquidity for a range thats above the current price, we use the $\\Delta x$ version on the formula; when calculation liquidity for a range thats below the current price, we use the $\\Delta y$ one; when a price range includes the current price, we calculate  both  and pick the smaller of them. Again, we discussed these ideas in  Liquidity Amount Calculation . Lets implement this logic now. When current price is below the lower bound of a price range: function   getLiquidityForAmounts (       uint160  sqrtPriceX96,       uint160  sqrtPriceAX96,       uint160  sqrtPriceBX96,       uint256  amount0,       uint256  amount1  )  internal   pure   returns  ( uint128  liquidity) {       if  (sqrtPriceAX96  >  sqrtPriceBX96)          (sqrtPriceAX96, sqrtPriceBX96)  =  (sqrtPriceBX96, sqrtPriceAX96);         if  (sqrtPriceX96  <=  sqrtPriceAX96) {          liquidity  =  getLiquidityForAmount0(              sqrtPriceAX96,              sqrtPriceBX96,              amount0          );  When current price is within a range, were picking the smaller $L$: }  else   if  (sqrtPriceX96  <=  sqrtPriceBX96) {       uint128  liquidity0  =  getLiquidityForAmount0(          sqrtPriceX96,          sqrtPriceBX96,          amount0      );       uint128  liquidity1  =  getLiquidityForAmount1(          sqrtPriceAX96,          sqrtPriceX96,          amount1      );        liquidity  =  liquidity0  <  liquidity1  ?  liquidity0  :  liquidity1;  And finally: }  else  {      liquidity  =  getLiquidityForAmount1(          sqrtPriceAX96,          sqrtPriceBX96,          amount1      );  }  Done.    \\[ \\] Liquidity Calculation Implementing Liquidity Calculation for Token X Implementing Liquidity Calculation for Token Y Finding Fair Liquidity", "labels": ["Documentation"]}, {"title": "Manager Contract #", "html_url": "https://uniswapv3book.com/docs/milestone_1/manager-contract/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Manager Contract   Manager Contract Workflow Passing Data to Callbacks Implementing Manager Contract Manager Contract  # Before deploying our pool contract, we need to solve one problem. As you remember, Uniswap V3 contracts are split into two categories: Core contracts that implement the core functions and dont provide user-friendly interfaces. Periphery contracts that implement user-friendly interfaces for the core contracts. The pool contract is a core contract, its not supposed to be user-friendly and flexible. It expects the caller to do all the calculations (prices, amounts) and to provide proper call parameters. It also doesnt use ERC20s  transferFrom  to transfer tokens from the caller. Instead, it uses two callbacks: uniswapV3MintCallback , which is called when minting liquidity; uniswapV3SwapCallback , which is called when swapping tokens. In our tests, we implemented these callbacks in the test contract. Since its only a contract that can implement them, the pool contract cannot be called by regular users (non-contract addresses). This is fine. But not anymore . Our next steps in the book is deploying the pool contract to a local blockchain and interacting with it from a front-end app. Thus, we need to build a contract that will let non-contract addresses to interact with the pool. Lets do this now! Workflow  # This is how the manager contract will work: To mint liquidity, well approve spending of tokens to the manager contract. Well then call  mint  function of the manager contract and pass it minting parameters, as well as the address of the pool we want to provide liquidity into. The manager contract will call the pools  mint  function and will implement  uniswapV3MintCallback . Itll have permissions to send our tokens to the pool contract. To swap tokens, well also approve spending of tokens to the manager contract. Well then call  swap  function of the manager contract and, similarly to minting, itll pass the call to the pool. The manager contract will send our tokens to the pool contract, the pool contract will swap them, and will send the output amount to us. Thus, the manager contract will act as a intermediary between users and pools. Passing Data to Callbacks  # Before implementing the manager contract, we need to upgrade the pool contract. The manager contract will work with any pool and itll allow any address to call it. To achieve this, we need to upgrade the callbacks: we want to pass different pool addresses and user addresses to them. Lets look at our current implementation of  uniswapV3MintCallback  (in the test contract): function   uniswapV3MintCallback ( uint256  amount0,  uint256  amount1)  public  {       if  (transferInMintCallback) {          token0.transfer(msg.sender, amount0);          token1.transfer(msg.sender, amount1);      }  }  Key points here: The function transfers tokens belonging to the test contractwe want it to transfer tokens from the caller by using  transferFrom . The function knows  token0  and  token1 , which will be different for every pool. Idea: we need to change the arguments of the callback so we could pass user and pool addresses. Now, lets look at the swap callback: function   uniswapV3SwapCallback ( int256  amount0,  int256  amount1)  public  {       if  (amount0  >   0   &&  transferInSwapCallback) {          token0.transfer(msg.sender,  uint256 (amount0));      }         if  (amount1  >   0   &&  transferInSwapCallback) {          token1.transfer(msg.sender,  uint256 (amount1));      }  }  Identically, it transfers tokens from the test contract and it knows  token0  and  token1 . To pass the extra data to the callbacks, we need to pass it to  mint  and  swap  first (since callbacks are called from these functions). However, since this extra data is not used in the functions and to not make their arguments messier, well encode the extra data using  abi.encode() . Lets define the extra data as a structure: // src/UniswapV3Pool.sol  ...  struct   CallbackData  {       address  token0;       address  token1;       address  payer;  }  ...  And then pass encoded data to the callbacks: function   mint (       address  owner,       int24  lowerTick,       int24  upperTick,       uint128  amount,       bytes  calldata data  // <--- New line  )  external   returns  ( uint256  amount0,  uint256  amount1) {      ...      IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(          amount0,          amount1,          data  // <--- New line      );      ...  }    function   swap ( address  recipient,  bytes  calldata data)  // <--- `data` added       public        returns  ( int256  amount0,  int256  amount1)  {      ...      IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(          amount0,          amount1,          data  // <--- New line      );      ...  }  Now, we can read the extra data in the callbacks in the test contract. function   uniswapV3MintCallback (       uint256  amount0,       uint256  amount1,       bytes  calldata data  )  public  {       if  (transferInMintCallback) {          UniswapV3Pool.CallbackData  memory  extra  =  abi.decode(              data,              (UniswapV3Pool.CallbackData)          );            IERC20(extra.token0).transferFrom(extra.payer, msg.sender, amount0);          IERC20(extra.token1).transferFrom(extra.payer, msg.sender, amount1);      }  }  Try updating the rest of the code yourself, and if it gets too difficult, feel free peeking  at this commit . Implementing Manager Contract  # Besides implementing the callbacks, the manager contract wont do much: itll simply redirect calls to a pool contract. This is a very minimalistic contract at this moment: pragma solidity   ^ 0 . 8 . 14 ;    import   \"../src/UniswapV3Pool.sol\" ;  import   \"../src/interfaces/IERC20.sol\" ;    contract   UniswapV3Manager  {       function   mint (           address  poolAddress_,           int24  lowerTick,           int24  upperTick,           uint128  liquidity,           bytes  calldata data      )  public  {          UniswapV3Pool(poolAddress_).mint(              msg.sender,              lowerTick,              upperTick,              liquidity,              data          );      }         function   swap ( address  poolAddress_,  bytes  calldata data)  public  {          UniswapV3Pool(poolAddress_).swap(msg.sender, data);      }         function   uniswapV3MintCallback (...) {...}       function   uniswapV3SwapCallback (...) {...}  }  The callbacks are identical to those in the test contract, with the exception that there are no  transferInMintCallback  and  transferInSwapCallback  flags since the manager contract always transfers tokens. Well, were now fully prepared for deploying and integrating with a front-end app! Manager Contract Workflow Passing Data to Callbacks Implementing Manager Contract", "labels": ["Documentation"]}, {"title": "Price Oracle #", "html_url": "https://uniswapv3book.com/docs/milestone_5/price-oracle/", "body": "Price Oracle #", "labels": ["Documentation"]}, {"title": "User Interface #", "html_url": "https://uniswapv3book.com/docs/milestone_4/user-interface/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   User Interface   User Interface AutoRouter A Simple Router Design User Interface  # After introducing swap paths, we can significantly simplify the internals of our web app. First of all, every swap now uses a path since path doesnt have to contain multiple pools. Second, its now easier to change the direction of swap: we can simply reverse the path. And, thanks to the unified pool address generation via  CREATE2  and unique salts, we no longer need to store pool addresses and care about tokens order. However, we cannot integrate multi-pool swaps in the web app without adding one crucial algorithm. Ask yourself the question: How to find a path between two tokens that dont have a pool? AutoRouter  # Uniswap implements whats called  AutoRouter , an algorithm that find shortest path between two tokens. Moreover, it also splits one payment into multiple smaller payments to find the best average exchange rate. The profit can be as big as  36.84% compared to trades that are not split . This sounds great, however, were not going to build such an advanced algorithm. Instead, well build something simpler. A Simple Router Design  # Suppose we have a whole bunch of pools: How do we find a shortest path between two tokens in such a mess? The most suitable solution for such kind of tasks is based on a  graph . A graph is a data structure that consists of nodes (objects representing something) and edges (links connecting nodes). We can turn that mess of pools into a graph where each node is a token (that has a pool) and each edge is a pool this token belongs to. So a pool represented as a graph is two nodes connected with an edge. And the above pools become this graph: The biggest advantage graphs give us is the ability to traverse its nodes, from one node to another, to find paths. Specifically, well use  A* search algorithm . Feel free learning about how the algorithm works, but, in our app, well use a library to make our life easier. The set of libraries well use is:  ngraph.ngraph  for building graphs and  ngraph.path  for finding paths (its the latter that implements A* search algorithm, as well as some others). In the UI app, lets create a path finder. This will be a class that, when instantiated, turns a list of pairs into a graph to later use the graph to find a shortest path between two tokens. import   createGraph   from   'ngraph.graph' ;  import   path   from   'ngraph.path' ;    class   PathFinder  {     constructor ( pairs ) {       this . graph   =   createGraph ();         pairs . forEach (( pair ) => {         this . graph . addNode ( pair . token0 . address );         this . graph . addNode ( pair . token1 . address );         this . graph . addLink ( pair . token0 . address ,  pair . token1 . address ,  pair . tickSpacing );         this . graph . addLink ( pair . token1 . address ,  pair . token0 . address ,  pair . tickSpacing );      });         this . finder   =   path . aStar ( this . graph );    }      ...  In the constructor, were creating an empty graph and fill it with linked nodes. Each node is a token address and links have associated data, which is tick spacingswell be able to extract this information from paths found by A*. After initializing a graph, we instantiate A* algorithm implementation. Next, we need to implement a function that will find a path between tokens and turn it into an array of token addresses and tick spacings: findPath ( fromToken ,  toToken ) {     return   this . finder . find ( fromToken ,  toToken ). reduce (( acc ,  node ,  i ,  orig ) => {       if  ( acc . length   >   0 ) {         acc . push ( this . graph . getLink ( orig [ i   -   1 ]. id ,  node . id ). data );      }         acc . push ( node . id );         return   acc ;    }, []). reverse ();  }  this.finder.find(fromToken, toToken)  returns a list of nodes and, unfortunately, doesnt contain the information about edges between them (we store tick spacings in edges). Thus, were calling  this.graph.getLink(previousNode, currentNode)  to find edges. Now, whenever user changes input or output token, we can call  pathFinder.findPath(token0, token1)  to build a new path. User Interface AutoRouter A Simple Router Design", "labels": ["Documentation"]}, {"title": "What We\u2019ll Build #", "html_url": "https://uniswapv3book.com/docs/introduction/what-we-will-build/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   What We'll Build   What Well Build Smart Contracts Front-end Application What Well Build  # The goal of the book is to build a clone of Uniswap V3. However, we wont build an exact copy. The main reason is that Uniswap is a big project with many nuances and auxiliary mechanicsbreaking down all of them would bloat the book and make it harder for readers to finish it. Instead, well build the core of Uniswap, its hardest and most important mechanisms. This includes liquidity management, swapping, fees, a periphery contract, a quoting contract, and an NFT contract. After that, Im sure, youll be able to read the original source code of Uniswap V3 and understand all the mechanics that were left outside of the scope of this book. Smart Contracts  # After finishing the book, youll have these contracts implemented: UniswapV3Pool the core pool contract that implements liquidity management and swapping. This contract is very close to  the original one , however, some implementation details are different and something is missed for simplicity. For example, our implementation will only handle exact input swaps, that is swaps with known input amounts. The original implementation also supports swaps with known  output  amounts (i.e. when you want to buy a certain amount of tokens). UniswapV3Factory the registry contract that deploys new pools and keeps a record of all deployed pools. This one is mostly identical to  the original one  besides the ability to change owner and fees. UniswapV3Manager a periphery contract that makes it easier to interact with the pool contract. This is a very simplified implementation of  SwapRouter . Again, as you can see, I dont distinguish exact input and exact output swaps and implement only the former ones. UniswapV3Quoter  is a cool contract that allows calculating swap prices on-chain. This is a minimal copy of both  Quoter  and  QuoterV2 . Again, only exact input swaps are supported. UniswapV3NFTManager  allows turning liquidity positions into NFTs. This is a simplified implementation of  NonfungiblePositionManager . Front-end Application  # For this book, I also built a simplified clone of  the Uniswap UI . This is a very dumb clone, and my React and front-end skills are very poor, but it demonstrates how a front-end application can interact with smart contracts using Ethers.js and MetaMask. What Well Build Smart Contracts Front-end Application", "labels": ["Documentation"]}, {"title": "A Little Bit More on Fixed-point Numbers #", "html_url": "https://uniswapv3book.com/docs/milestone_3/more-on-fixed-point-numbers/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   A Little Bit More on Fixed-point Numbers   A Little Bit More on Fixed-point Numbers A Little Bit More on Fixed-point Numbers  # In this bonus chapter, Id like to show you how to convert prices to ticks in Solidity. We dont need to do this in the main contracts, but its helpful to have such function in tests so we dont hardcode ticks and could write something like  tick(5000) this makes code easier to read because its more convenient for us to think in prices, not tick indexes. Recall that, to find ticks, we use  TickMath.getTickAtSqrtRatio  function, which takes $\\sqrt{P}$ as its argument, and the $\\sqrt{P}$ is a Q64.96 fixed-point number. In smart contract tests, we need to check $\\sqrt{P}$ many times in many different test cases: mostly after mints and swaps. Instead of hard coding actual values, it might be cleaner to use a helper function like  sqrtP(5000)  that converts prices to $\\sqrt{P}$. So, whats the problem? The problem is that Solidity doesnt natively support the square root operation, which means we need a third-party library. Another problem is that prices are often relatively small numbers, like 10, 5000, 0.01, etc., and we dont want to lose precision when taking square root. You probably remember that we used  PRBMath  earlier in the book to implement multiply-then-divide operation that doesnt overflow during multiplication. If you check  PRBMath.sol  contract, youll notice  sqrt  function. However, the function doesnt support fixed-point numbers, as the function description says. You can give it a try and see that  PRBMath.sqrt(5000)  results in  70 , which is an integer number with lost precision (without the fractional part). If you check  prb-math  repo, youll see these contracts:  PRBMathSD59x18.sol  and  PRBMathUD60x18.sol . Aha! These are fixed-point number implementations. Lets pick the latter and see how it goes:  PRBMathUD60x18.sqrt(5000 * PRBMathUD60x18.SCALE)  returns  70710678118654752440 . This looks interesting!  PRBMathUD60x18  is a library that implements fixed-numbers with 18 decimal places in the fractional part. So the number we got is actually 70.710678118654752440 (use  cast --from-wei 70710678118654752440 ). However, we cannot use this number! There are fixed-point numbers and fixed-point numbers. The Q64.96 fixed-point number used by Uniswap V3 is a  binary  number64 and 96 signify  binary places . But  PRBMathUD60x18  implements a  decimal  fixed-point number (UD in the contract name means unsigned, decimal), where 60 and 18 signify  decimal places . This difference is quite significant. Lets see how to convert an arbitrary number (42) to either of the above fixed-point numbers: Q64.96: $42 * 2^{96}$ or, using bitwise left shift,  2 << 96 . The result is 3327582825599102178928845914112. UD60.18: $42 * 10^{18}$. The result is 42000000000000000000. Lets now see how to convert numbers with the fractional part (42.1337): Q64.96: $421337 * 2^{92}$ or  421337 << 92 . The result is 2086359769329537075540689212669952. UD60.18: $421337 * 10^{14}$. The result is 42133700000000000000. The second variant makes more sense to us because it uses the decimal system, which we learned in our childhood. The first variant uses the binary system and its much harder for us to read. But the biggest problem with different variants is that its hard to convert between them. This all means that we need a different library, one that implements a binary fixed-point number and  sqrt  function for it. Luckily, theres such library:  abdk-libraries-solidity . The library implemented Q64.64, not exactly what we need (not 96 bits in the fractional part) but this is not a problem. Heres how we can implement the price-to-tick function using the new library: function   tick ( uint256  price)  internal   pure   returns  ( int24  tick_) {      tick_  =  TickMath.getTickAtSqrtRatio(           uint160 (               int160 (                  ABDKMath64x64.sqrt( int128 ( int256 (price  <<   64 )))  <<                       (FixedPoint96.RESOLUTION  -   64 )              )          )      );  }  ABDKMath64x64.sqrt  takes Q64.64 numbers so we need to convert  price  to such number. The price is expected to not have the fractional part, so were shifting it by 64 bits. The  sqrt  function also returns a Q64.64 number but  TickMath.getTickAtSqrtRatio  takes a Q64.96 numberthis is why we need to shift the result of the square root operation by  96 - 64  bits to the left.    \\[ \\] A Little Bit More on Fixed-point Numbers", "labels": ["Documentation"]}, {"title": "Deployment #", "html_url": "https://uniswapv3book.com/docs/milestone_1/deployment/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Deployment   Deployment Choosing Local Blockchain Network Running Local Blockchain First Deployment Interacting With Contracts, ABI Token Balance Current Tick and Price ABI Deployment  # Alright, our pool contract is done. Now, lets see how we can deploy it to a local Ethereum network so we could use it from a front-end app later on. Choosing Local Blockchain Network  # Smart contracts development requires running a local network, where you deploy your contracts during development and testing. This is what we want from such a network: Real blockchain. It must be a real Ethereum network, not an emulation. We want to be sure that our contract will work in the local network exactly as it would in the mainnet. Speed. We want our transactions to be minted immediately, so we could iterate quickly. Ether. To pay transaction fees, we need some ether, and we want the local network to allow us to generate any amount of ether. Cheat codes. Besides providing the standard API, we want a local network to allow us to do more. For example, we want to be able to deploy contracts at any address, execute transactions from any address (impersonate other address), change contract state directly, etc. There are multiple solutions as of today: Ganache  from Truffle Suite. Hardhat , which is a development environment that includes a local node besides other useful things. Anvil  from Foundry. All of these are viable solutions and each of them will satisfy our needs. Having said that, projects have been slowly migrating from Ganache (which is the oldest of the solutions) to Hardhat (which seems to be the most widely used these days), and now theres the new kid on the block: Foundry. Foundry is also the only of these solutions that uses Solidity for writing tests (the others use JavaScript). Moreover, Foundry also allows to write deployment scripts in Solidity. Thus, since weve decided to use Solidity everywhere, well use Anvil to run a local development blockchain, and well write deployment scripts in Solidity. Running Local Blockchain  # Anvil doesnt require configuration, we can run it with a single command and itll do: $ anvil                               _   _                               ( _ )  | |        __ _   _ __   __   __  _  | |       / _ `  | |  ' _  \\    \\ \\  / / | | | |      |  ( _| | | | | |   \\  V /  | | | |        \\_ _,_| |_| |_|    \\_ /   |_| |_|        0.1.0  ( d89f6af 2022-06-24T00:15:17.897682Z )       https://github.com/foundry-rs/foundry  ...  Listening on 127.0.0.1:8545  Anvil runs a single Ethereum node, so this is not really a network, but thats ok. By default, it creates 10 accounts with 10,000 ETH in each of them. It prints the addresses and related private keys when it startswell be using one of these addresses when deploying and interacting with the contract from UI. Anvil exposes JSON-RPC API interface at  127.0.0.1:8545 this interface is the main way of interacting with Ethereum nodes. You can find full API reference  here . And this is how you can call it via  curl : $ curl -X POST -H  'Content-Type: application/json'   \\    --data  '{\"id\":1,\"jsonrpc\":\"2.0\",\"method\":\"eth_chainId\"}'   \\    http://127.0.0.1:8545  { \"jsonrpc\" : \"2.0\" , \"id\" :1, \"result\" : \"0x7a69\" }   $ curl -X POST -H  'Content-Type: application/json'   \\    --data  '{\"id\":1,\"jsonrpc\":\"2.0\",\"method\":\"eth_getBalance\",\"params\":[\"0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\",\"latest\"]}'   \\    http://127.0.0.1:8545  { \"jsonrpc\" : \"2.0\" , \"id\" :1, \"result\" : \"0x21e19e0c9bab2400000\" }   You can also use  cast  (part of Foundry) for that: $ cast chain-id  31337   $ cast balance 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266  10000000000000000000000   Now, lets deploy the pool and manager contracts to the local network. First Deployment  # At its core, deploying a contract means: Compiling source code into EVM bytecode. Sending a transaction with the bytecode. Creating a new address, executing the constructor part of the bytecode, storing initialized bytecode on the address. This step is done automatically by an Ethereum node, when your contract creation transaction is mined. Deployment usually consists of multiple steps: preparing parameters, deploying auxiliary contracts, deploying main contracts, initializing contracts, etc. Scripting helps to automate these steps, and well write scripts in Solidity! Create  scripts/DeployDevelopment.sol  contract with this content: // SPDX-License-Identifier: UNLICENSED  pragma solidity   ^ 0 . 8 . 14 ;    import   \"forge-std/Script.sol\" ;    contract   DeployDevelopment   is  Script {       function   run ()  public  {        ...      }  }  It looks very similar to the test contract, with only difference is that it inherits from  Script  contract, not from  Test . And, by convention, we need to define  run  function which will be the body of our deployment script. In the  run  function, we define the parameters of the deployment first: uint256  wethBalance  =   1   ether ;  uint256  usdcBalance  =   5042   ether ;  int24  currentTick  =   85176 ;  uint160  currentSqrtP  =   5602277097478614198912276234240 ;  These are the same values we used before. Notice that were about to mint 5042 USDCthats 5000 USDC well provide as liquidity into the pool and 42 USDC well sell in a swap. Next, we define the set of steps that will be executed as the deployment transaction (well, each of the steps will be a separate transaction). For this, were using  startBroadcast/endBroadcast  cheat codes: vm.startBroadcast();  ...  vm.stopBroadcast();  These cheat codes are  provided by of Foundry . We got them in the script contract by inheriting from  forge-std/Script.sol . Everything that goes after the  broadcast()  cheat code or between  startBroadcast()/stopBroadcast()  is converted to transactions and these transactions are sent to the node that executes the script. Between the broadcast cheat codes, well put the actual deployment steps. First, we need to deploy the tokens: ERC20Mintable token0  =   new  ERC20Mintable( \"Wrapped Ether\" ,  \"WETH\" ,  18 );  ERC20Mintable token1  =   new  ERC20Mintable( \"USD Coin\" ,  \"USDC\" ,  18 );  We cannot deploy the pool without having tokens, so we need to deploy them first. Since were deploying to a local development network, we need to deploy the tokens ourselves. In the mainnet and public test networks (Ropsten, Goerli, Sepolia), the tokens are already created. Thus, to deploy to those networks, well need to write network-specific deployment scripts. The next step is to deploy the pool contract: UniswapV3Pool pool  =   new  UniswapV3Pool(       address (token0),       address (token1),      currentSqrtP,      currentTick  );  Next goes Manager contract deployment: UniswapV3Manager manager  =   new  UniswapV3Manager();  And finally, we can mint some amount of ETH and USDC to our address: token0.mint(msg.sender, wethBalance);  token1.mint(msg.sender, usdcBalance);  msg.sender  in Foundry scripts is the address that sends transactions within the  broadcast  block. Well be able to set it when running scripts. Finally, at the end of the script, add some  console.log  calls to print the addresses of deployed contracts: console.log( \"WETH address\" ,  address (token0));  console.log( \"USDC address\" ,  address (token1));  console.log( \"Pool address\" ,  address (pool));  console.log( \"Manager address\" ,  address (manager));  Alright, lets run the script (ensure Anvil is running in another terminal window): $ forge script scripts/DeployDevelopment.s.sol --broadcast --fork-url http://localhost:8545 --private-key $PRIVATE_KEY  --broadcast  enables broadcasting of transactions. Its not enabled by default because not every script sends transactions.  --fork-url  sets the address of the node to send transactions to.  --private-key  sets the sender wallet: a private key is needed to sign transactions. You can pick any of the private keys printed by Anvil when its starting. I took the first one: 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 Deployment takes several seconds. In the end, youll see a list of transactions it sent. Itll also save transactions receipts to  broadcast  folder. In Anvil, youll also see many lines with  eth_sendRawTransaction ,  eth_getTransactionByHash , and  eth_getTransactionReceipt after sending transactions to Anvil, Forge uses the JSON-RPC API to check their status and get transaction execution results (receipts). Congratulations! Youve just deployed a smart contract! Interacting With Contracts, ABI  # Now, lets see how we can interact with the deployed contracts. Every contract exposes a set of public functions. In the case of the pool contract, these are  mint(...)  and  swap(...) . Additionally, Solidity creates getters for public variables, so we can also call  token0() ,  token1() ,  positions() , etc. However, since contracts are compiled bytecodes,  function names are lost during compilation and not stored on blockchain . Instead, every function is identified by a selector, which is the first 4 bytes of the hash of the signature of the function. In pseudocode: hash(\"transfer(address,address,uint256)\")[0:4]  EVM uses  the Keccak hashing algorithm , which was standardized as SHA-3. Specifically, the hashing function in Solidity is  keccak256 . Knowing this, lets make two calls to the deployed contracts: one will be a low-level call via  curl , and one will be made using  cast . Token Balance  # Lets check the WETH balance of the deployer address. The signature of the function is  balanceOf(address)  (as defined in  ERC-20 ). To find the ID of this function (its selector), well hash it and take the first four bytes: $ cast keccak  \"balanceOf(address)\" | cut -b 1-10  0x70a08231  To pass the address, we simply append it to the function selector (and add left padding up to 32 digits since addresses take 32 bytes in function call data): 0x70a08231000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266  is the address were going to check balance of. This is our address, the first account in Anvil. Next, we execute  eth_call  JSON-RPC method to make the call. Notice that this doesnt require sending a transactionthis endpoint is used to read data from contracts. $params = '{\"from\":\"0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\",\"to\":\"0xe7f1725e7734ce288f8367e1bb143e90bb3f0512\",\"data\":\"0x70a08231000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266\"}'   $curl -X POST -H  'Content-Type: application/json'   \\    --data  '{\"id\":1,\"jsonrpc\":\"2.0\",\"method\":\"eth_call\",\"params\":[' \" $params \" ',\"latest\"]}'   \\    http://127.0.0.1:8545  { \"jsonrpc\" : \"2.0\" , \"id\" :1, \"result\" : \"0x00000000000000000000000000000000000000000000011153ce5e56cf880000\" }   The to address is the USDC token. Its printed by the deployment script and it can be different in your case. Ethereum nodes return results as raw bytes, to parse them we need to know the type of a returned value. In the case of  balanceOf  function, the type of a returned value is  uint256 . Using  cast , we can convert it to a decimal number and then convert it to ethers: $ cast --to-dec 0x00000000000000000000000000000000000000000000011153ce5e56cf880000| cast --from-wei  5042.000000000000000000  The balance is correct! We minted 5042 USDC to our address. Current Tick and Price  # The above example is a demonstration of low-level contract calls. Usually, you never do calls via  curl  and use a tool or library that makes it easier. And Cast can help us here again! Lets get the current price and tick of a pool using  cast : $ cast call POOL_ADDRESS  \"slot0()\" | xargs cast --abi-decode  \"a()(uint160,int24)\"   5602277097478614198912276234240   85176   Nice! The first value is the current $\\sqrt{P}$ and the second value is the current tick. Since  --abi-decode  requires full function signature we have to specify a() even though we only want to decode function output. ABI  # To simplify interaction with contracts, Solidity compiler can output ABI, Application Binary Interface. ABI is a JSON file that contains the description of all public methods and events of a contract. The goal of this file is to make it easier to encode function parameters and decode return values. To get ABI with Forge, use this command: $ forge inspect UniswapV3Pool abi  Feel free skimming through the file to better understand its content.    \\[ \\] Deployment Choosing Local Blockchain Network Running Local Blockchain First Deployment Interacting With Contracts, ABI Token Balance Current Tick and Price ABI", "labels": ["Documentation"]}, {"title": "Generalize Swapping #", "html_url": "https://uniswapv3book.com/docs/milestone_2/generalize-swapping/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Generalize Swapping   Generalize Swapping Filling Orders SwapMath Contract Finding Price by Swap Amount Finishing the Swap Testing Generalize Swapping  # This will be the hardest chapter of this milestone. Before updating the code, we need to understand how the algorithm of swapping in Uniswap V3 works. You can think of a swap as of filling of an order: a user submits an order to buy a specified amount of tokens from a pool. The pool will use the available liquidity to convert the input amount into an output amount of the other token. If theres not enough liquidity in the current price range, itll try to find liquidity in other price ranges (using the function we implemented in the previous chapter). Were now going to implement this logic in the  swap  function, however going to stay only within the current price range for nowwell implement cross-tick swaps in the next milestone. function   swap (       address  recipient,       bool  zeroForOne,       uint256  amountSpecified,       bytes  calldata data  )  public   returns  ( int256  amount0,  int256  amount1) {      ...  In  swap  function, we add two new parameters:  zeroForOne  and  amountSpecified .  zeroForOne  is the flag that controls swap direction: when  true ,  token0  is traded in for  token1 ; when  false,  its the opposite. For example, if  token0  is ETH and  token1  is USDC, setting  zeroForOne  to  true  means buying USDC for ETH.  amountSpecified  is the amount of tokens user wants to sell. Filling Orders  # Since, in Uniswap V3, liquidity is stored in multiple price ranges, Pool contract needs to find all liquidity thats required to fill an order from user. This is done via iterating over initialized ticks in a direction chosen by user. Before continuing, we need to define two new structures: struct   SwapState  {       uint256  amountSpecifiedRemaining;       uint256  amountCalculated;       uint160  sqrtPriceX96;       int24  tick;  }    struct   StepState  {       uint160  sqrtPriceStartX96;       int24  nextTick;       uint160  sqrtPriceNextX96;       uint256  amountIn;       uint256  amountOut;  }  SwapState  maintains current swaps state.  amountSpecifiedRemaining  tracks the remaining amount of tokens that needs to be bought by the pool. When its zero, the swap is done.  amountCalculated  is the out amount calculated by the contract.  sqrtPriceX96  and  tick  are new current price and tick after a swap is done. StepState  maintains current swap steps state. This structure tracks the state of  one iteration  of an order filling.  sqrtPriceStartX96  tracks the price the iteration begins with.  nextTick  is the next initialized tick that will provide liquidity for the swap and  sqrtPriceNextX96  is the price at the next tick.  amountIn  and  amountOut  are amounts that can be provided by the liquidity of the current iteration. After we implement cross-tick swaps (that is, swaps that happen across multiple price ranges), the idea of iterating will be clearer. // src/UniswapV3Pool.sol    function   swap (...) {      Slot0  memory  slot0_  =  slot0;        SwapState  memory  state  =  SwapState({          amountSpecifiedRemaining :  amountSpecified,          amountCalculated :   0 ,          sqrtPriceX96 :  slot0_.sqrtPriceX96,          tick :  slot0_.tick      });      ...  Before filling an order, we initialize a  SwapState  instance. Well loop until  amountSpecifiedRemaining  is 0, which will mean that the pool has enough liquidity to buy  amountSpecified  tokens from user. ...  while  (state.amountSpecifiedRemaining  >   0 ) {      StepState  memory  step;        step.sqrtPriceStartX96  =  state.sqrtPriceX96;        (step.nextTick, )  =  tickBitmap.nextInitializedTickWithinOneWord(          state.tick,           1 ,          zeroForOne      );        step.sqrtPriceNextX96  =  TickMath.getSqrtRatioAtTick(step.nextTick);  In the loop, we set up a price range that should provide liquidity for the swap. The range is from  state.sqrtPriceX96  to  step.sqrtPriceNextX96 , where the latter is the price at the next initialized tick (as returned by  nextInitializedTickWithinOneWord we know this function from a previous chapter). (state.sqrtPriceX96, step.amountIn, step.amountOut)  =  SwapMath      .computeSwapStep(          state.sqrtPriceX96,          step.sqrtPriceNextX96,          liquidity,          state.amountSpecifiedRemaining      );  Next, were calculating the amounts that can be provider by the current price range, and the new current price the swap will result in.     state.amountSpecifiedRemaining  -=  step.amountIn;      state.amountCalculated  +=  step.amountOut;      state.tick  =  TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);  }  The final step in the loop is updating the SwapState.  step.amountIn  is the amount of tokens the price range can buy from user;  step.amountOut  is the related number of the other token the pool can sell to user.  state.sqrtPriceX96  is the current price that will be set after the swap (recall that trading changes current price). SwapMath Contract  # Lets look closer at  SwapMath.computeSwapStep . // src/lib/SwapMath.sol  function   computeSwapStep (       uint160  sqrtPriceCurrentX96,       uint160  sqrtPriceTargetX96,       uint128  liquidity,       uint256  amountRemaining  )       internal        pure        returns  (           uint160  sqrtPriceNextX96,           uint256  amountIn,           uint256  amountOut      )  {      ...  This is the core logic of swapping. The function calculates swap amounts within one price range and respecting available liquidity. Itll return: the new current price and input and output token amounts. Even though the input amount is provided by user, we still calculate it to know how much of the user specified input amount was processed by one call to  computeSwapStep . bool  zeroForOne  =  sqrtPriceCurrentX96  >=  sqrtPriceTargetX96;    sqrtPriceNextX96  =  Math.getNextSqrtPriceFromInput(      sqrtPriceCurrentX96,      liquidity,      amountRemaining,      zeroForOne  );  By checking the price, we can determine the direction of the swap. Knowing the direction, we can calculate the price after swapping  amountRemaining  of tokens. Well return to this function below. After finding the new price, we can calculate input and output amounts of the swap using the function we already have ( the same functions we used to calculate token amounts from liquidity in the  mint  function): amountIn  =  Math.calcAmount0Delta(      sqrtPriceCurrentX96,      sqrtPriceNextX96,      liquidity  );  amountOut  =  Math.calcAmount1Delta(      sqrtPriceCurrentX96,      sqrtPriceNextX96,      liquidity  );  And swap the amounts if the direction is opposite: if  ( ! zeroForOne) {      (amountIn, amountOut)  =  (amountOut, amountIn);  }  Thats it for  computeSwapStep ! Finding Price by Swap Amount  # Lets now look at  Math.getNextSqrtPriceFromInput the function calculates a $\\sqrt{P}$ given another $\\sqrt{P}$, liquidity, and input amount. It tells what the price will be after swapping the specified input amount of tokens, given the current price and liquidity. Good news is that we already know the formulas: recall how we calculated  price_next  in Python: # When amount_in is token0   price_next  =  int((liq  *  q96  *  sqrtp_cur)  //  (liq  *  q96  +  amount_in  *  sqrtp_cur))  # When amount_in is token1   price_next  =  sqrtp_cur  +  (amount_in  *  q96)  //  liq  Were going to implement this in Solidity: // src/lib/Math.sol  function   getNextSqrtPriceFromInput (       uint160  sqrtPriceX96,       uint128  liquidity,       uint256  amountIn,       bool  zeroForOne  )  internal   pure   returns  ( uint160  sqrtPriceNextX96) {      sqrtPriceNextX96  =  zeroForOne           ?  getNextSqrtPriceFromAmount0RoundingUp(              sqrtPriceX96,              liquidity,              amountIn          )           :  getNextSqrtPriceFromAmount1RoundingDown(              sqrtPriceX96,              liquidity,              amountIn          );  }  The function handles swapping in both directions. Since calculations are different, well implement them in separate functions. function   getNextSqrtPriceFromAmount0RoundingUp (       uint160  sqrtPriceX96,       uint128  liquidity,       uint256  amountIn  )  internal   pure   returns  ( uint160 ) {       uint256  numerator  =   uint256 (liquidity)  <<  FixedPoint96.RESOLUTION;       uint256  product  =  amountIn  *  sqrtPriceX96;         if  (product  /  amountIn  ==  sqrtPriceX96) {           uint256  denominator  =  numerator  +  product;           if  (denominator  >=  numerator) {               return                    uint160 (                      mulDivRoundingUp(numerator, sqrtPriceX96, denominator)                  );          }      }         return            uint160 (              divRoundingUp(numerator, (numerator  /  sqrtPriceX96)  +  amountIn)          );  }  In this function, were implementing two formulas. At the first  return , it implements the same formula we implemented in Python. This is the most precise formula, but it can overflow when multiplying  amountIn  by  sqrtPriceX96 . The formula is (we discussed it in Output Amount Calculation): $$\\sqrt{P_{target}} = \\frac{\\sqrt{P}L}{\\Delta x \\sqrt{P} + L}$$ When it overflows, we use an alternative formula, which is less precise: $$\\sqrt{P_{target}} = \\frac{L}{\\Delta x + \\frac{L}{\\sqrt{P}}}$$ Which is simply the previous formula with the numerator and the denominator divided by $\\sqrt{P}$ to get rid of the multiplication in the numerator. The other function has simpler math: function   getNextSqrtPriceFromAmount1RoundingDown (       uint160  sqrtPriceX96,       uint128  liquidity,       uint256  amountIn  )  internal   pure   returns  ( uint160 ) {       return           sqrtPriceX96  +            uint160 ((amountIn  <<  FixedPoint96.RESOLUTION)  /  liquidity);  }  Finishing the Swap  # Now, lets return to the  swap  function and finish it. By this moment, we have looped over next initialized ticks, filled  amountSpecified  specified by user, calculated input and amount amounts, and found new price and tick. Since, in this milestone, were implementing only swaps within one price range, this is enough. We now need to update contracts state, send tokens to user, and get tokens in exchange. if  (state.tick  !=  slot0_.tick) {      (slot0.sqrtPriceX96, slot0.tick)  =  (state.sqrtPriceX96, state.tick);  }  First, we set new price and tick. Since this operation writes to contracts storage, we want to do it only if the new tick is different, to optimize gas consumption. (amount0, amount1)  =  zeroForOne       ?  (           int256 (amountSpecified  -  state.amountSpecifiedRemaining),           - int256 (state.amountCalculated)      )       :  (           - int256 (state.amountCalculated),           int256 (amountSpecified  -  state.amountSpecifiedRemaining)      );  Next, we calculate swap amounts based on swap direction and the amounts calculated during the swap loop. if  (zeroForOne) {      IERC20(token1).transfer(recipient,  uint256 ( - amount1));         uint256  balance0Before  =  balance0();      IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(          amount0,          amount1,          data      );       if  (balance0Before  +   uint256 (amount0)  >  balance0())          revert InsufficientInputAmount();  }  else  {      IERC20(token0).transfer(recipient,  uint256 ( - amount0));         uint256  balance1Before  =  balance1();      IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(          amount0,          amount1,          data      );       if  (balance1Before  +   uint256 (amount1)  >  balance1())          revert InsufficientInputAmount();  }  Next, were exchanging tokens with user, depending on swap direction. This piece is identical to what we had in Milestone 2, only handling of the other swap direction was added. Thats it! Swapping is done! Testing  # Test wont change significantly, we only need to pass  amountSpecified  and  zeroForOne  to  swap  function. Output amount will change insignificantly though, because its now calculated in Solidity. We can now test swapping in the opposite direction! Ill leave this for you, as a homework (just be sure to choose a small input amount so the whole swap can be handled by our single price range). Dont hesitate peeking at  my tests  if this feels difficult!    \\[ \\] Generalize Swapping Filling Orders SwapMath Contract Finding Price by Swap Amount Finishing the Swap Testing", "labels": ["Documentation"]}, {"title": "Tick Rounding #", "html_url": "https://uniswapv3book.com/docs/milestone_4/tick-rounding/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Tick Rounding   Tick Rounding nearestUsableTick  in JavaScript nearestUsableTick  in Solidity Tick Rounding  # Lets review some other changes we need to make to support different tick spacings. Tick spacing greater than 1 wont allow users to select arbitrary price ranges: tick indexes must be multiples of a tick spacing. For example, for tick spacing 60 we can have ticks: 0, 60, 120, 180, etc. Thus, when user picks a range, we need to round it so its boundaries are multiples of pools tick spacing. nearestUsableTick  in JavaScript  # In  the Uniswap V3 SDK , the function that does that is called  nearestUsableTick : /**   * Returns the closest tick that is nearest a given tick and usable for the given tick spacing   * @param tick the target tick   * @param tickSpacing the spacing of the pool   */   export   function   nearestUsableTick ( tick :   number ,  tickSpacing :   number ) {     invariant (Number. isInteger ( tick )  &&  Number. isInteger ( tickSpacing ),  'INTEGERS' )     invariant ( tickSpacing   >   0 ,  'TICK_SPACING' )     invariant ( tick   >=   TickMath . MIN_TICK   &&   tick   <=   TickMath . MAX_TICK ,  'TICK_BOUND' )     const   rounded   =  Math. round ( tick   /   tickSpacing )  *   tickSpacing      if  ( rounded   <   TickMath . MIN_TICK )  return   rounded   +   tickSpacing      else   if  ( rounded   >   TickMath . MAX_TICK )  return   rounded   -   tickSpacing      else   return   rounded   }  At its core, its just: Math. round ( tick   /   tickSpacing )  *   tickSpacing   Where  Math.round  is rounding to the nearest integer: when the fractional part is less than 0.5, it rounds to the lower integer; when its greater than 0.5 it rounds to the greater integer; and when its 0.5, it rounds to the greater integer as well. So, in the web app, well use  nearestUsableTick  when building  mint  parameters: const   mintParams   =  {     tokenA :   pair . token0 . address ,     tokenB :   pair . token1 . address ,     tickSpacing :   pair . tickSpacing ,     lowerTick :   nearestUsableTick ( lowerTick ,  pair . tickSpacing ),     upperTick :   nearestUsableTick ( upperTick ,  pair . tickSpacing ),     amount0Desired ,  amount1Desired ,  amount0Min ,  amount1Min   }  In reality, it should be called whenever user adjusts a price range because we want the user to see the actual price that will be created. In our simplified app, we do it less user-friendly. However, we also want to have a similar function in Solidity tests, but neither of the math libraries were using implements it. nearestUsableTick  in Solidity  # In our smart contract tests, we need a way to round ticks and convert rounded prices to $\\sqrt{P}$. In a previous chapter, we chose to use  ABDKMath64x64  to handle fixed-point numbers math in tests. The library, however, doesnt implement the rounding function we need to port  nearestUsableTick , so well need to implement it ourselves: function   divRound ( int128  x,  int128  y)       internal        pure        returns  ( int128  result)  {       int128  quot  =  ABDKMath64x64.div(x, y);      result  =  quot  >>   64 ;         // Check if remainder is greater than 0.5       if  (quot  %   2 ** 64   >=   0x8000000000000000 ) {          result  +=   1 ;      }  }  The function does multiple things: it divides two Q64.64 numbers; it then rounds the result to the decimal one ( result = quot >> 64 ), the fractional part is lost at this point (i.e. the result is rounded down); it then divides the quotient by $2^{64}$, takes the remainder, and compares it with  0x8000000000000000  (which is 0.5 in Q64.64); if the remainder is greater or equal to 0.5, it rounds the result to the greater integer. What we get is an integer rounded according to the rules of  Math.round  from JavaScript. We can then re-implement  nearestUsableTick : function   nearestUsableTick ( int24  tick_,  uint24  tickSpacing)       internal        pure        returns  ( int24  result)  {      result  =            int24 (divRound( int128 (tick_),  int128 ( int24 (tickSpacing))))  *            int24 (tickSpacing);         if  (result  <  TickMath.MIN_TICK) {          result  +=   int24 (tickSpacing);      }  else   if  (result  >  TickMath.MAX_TICK) {          result  -=   int24 (tickSpacing);      }  }  Thats it!    \\[ \\] Tick Rounding nearestUsableTick  in JavaScript nearestUsableTick  in Solidity", "labels": ["Documentation"]}, {"title": "User Interface #", "html_url": "https://uniswapv3book.com/docs/milestone_5/user-interface/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   User Interface   User Interface Fetching Positions Getting Pool Address Removing Liquidity User Interface  # In this milestone, weve added the ability to remove liquidity from a pool and collect accumulated fees. Thus, we need to reflect these changes in the user interface to allow users to remove liquidity. Fetching Positions  # To let user choose how much liquidity to remove, we first need to fetch users positions from a pool. To makes this easier, we can add a helper function to the Manager contract, which will return user position in a specific pool: function   getPosition (GetPositionParams calldata params)       public        view        returns  (           uint128  liquidity,           uint256  feeGrowthInside0LastX128,           uint256  feeGrowthInside1LastX128,           uint128  tokensOwed0,           uint128  tokensOwed1      )  {      IUniswapV3Pool pool  =  getPool(params.tokenA, params.tokenB, params.fee);        (          liquidity,          feeGrowthInside0LastX128,          feeGrowthInside1LastX128,          tokensOwed0,          tokensOwed1      )  =  pool.positions(          keccak256(              abi.encodePacked(                  params.owner,                  params.lowerTick,                  params.upperTick              )          )      );  }  This will free us from calculating a pool address and a position key on the front end. Then, after user typed in a position range, we can try fetching a position: const   getAvailableLiquidity   =   debounce (( amount ,  isLower ) => {     const   lowerTick   =   priceToTick ( isLower   ?   amount   :   lowerPrice );     const   upperTick   =   priceToTick ( isLower   ?   upperPrice   :   amount );       const   params   =  {       tokenA :   token0 . address ,       tokenB :   token1 . address ,       fee :   fee ,       owner :   account ,       lowerTick :   nearestUsableTick ( lowerTick ,  feeToSpacing [ fee ]),       upperTick :   nearestUsableTick ( upperTick ,  feeToSpacing [ fee ]),    }       manager . getPosition ( params )      . then ( position  =>  setAvailableAmount ( position . liquidity . toString ()))      . catch ( err  =>  console . error ( err ));  },  500 );  Getting Pool Address  # Since we need to call  burn  and  collect  on a pool, we still need to compute pools address on the front end. Recall that pool addresses are compute using the  CREATE2  opcode, which requires a salt and the hash of contracts code. Luckily, Ether.js has  getCreate2Address  function that allows to compute  CREATE2  in JavaScript: const   sortTokens   =  ( tokenA ,  tokenB ) => {     return   tokenA . toLowerCase ()  <   tokenB . toLowerCase   ?  [ tokenA ,  tokenB ]  :  [ tokenB ,  tokenA ];  }    const   computePoolAddress   =  ( factory ,  tokenA ,  tokenB ,  fee ) => {    [ tokenA ,  tokenB ]  =   sortTokens ( tokenA ,  tokenB );       return   ethers . utils . getCreate2Address (       factory ,       ethers . utils . keccak256 (         ethers . utils . solidityPack (          [ 'address' ,  'address' ,  'uint24' ],          [ tokenA ,  tokenB ,  fee ]        )),       poolCodeHash     );  }  However, pools codehash has to be hard coded because we dont want to store its code on the front end to calculate the hash. So, well use Forge to get the hash: $ forge inspect UniswapV3Pool bytecode| xargs cast keccak   0x...  And then use the output value in a JS constant: const   poolCodeHash   =   \"0x9dc805423bd1664a6a73b31955de538c338bac1f5c61beb8f4635be5032076a2\" ;  Removing Liquidity  # After obtaining liquidity amount and pool address, were ready to call  burn : const   removeLiquidity   =  ( e ) => {     e . preventDefault ();       if  ( ! token0   ||   ! token1 ) {       return ;    }       setLoading ( true );       const   lowerTick   =   nearestUsableTick ( priceToTick ( lowerPrice ),  feeToSpacing [ fee ]);     const   upperTick   =   nearestUsableTick ( priceToTick ( upperPrice ),  feeToSpacing [ fee ]);       pool . burn ( lowerTick ,  upperTick ,  amount )      . then ( tx  =>  tx . wait ())      . then ( receipt  => {         if  ( ! receipt . events [ 0 ]  ||   receipt . events [ 0 ]. event   !==   \"Burn\" ) {           throw  Error( \"Missing Burn event after burning!\" );        }           const   amount0Burned   =   receipt . events [ 0 ]. args . amount0 ;         const   amount1Burned   =   receipt . events [ 0 ]. args . amount1 ;           return   pool . collect ( account ,  lowerTick ,  upperTick ,  amount0Burned ,  amount1Burned )      })      . then ( tx  =>  tx . wait ())      . then (() =>  toggle ())      . catch ( err  =>  console . error ( err ));  }  If burning was successful, we immediately call  collect  to collect the token amounts that were freed during burning. User Interface Fetching Positions Getting Pool Address Removing Liquidity", "labels": ["Documentation"]}, {"title": "", "html_url": "https://uniswapv3book.com/docs/milestone_3/flash-loans/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Flash Loans   Flash Loans Implementing Flash Loans Flash Loans  # Both Uniswap V2 and V3 implement flash loans: unlimited and uncollateralized loans that must be repaid in the same transaction. Pools basically give users arbitrary amounts of tokens that they request, but, by the end of the call, the amounts must be repaid, with a small fee on top. The fact that flash loans must be repaid in the same transaction means that flash loans cannot be taken by regular users: as a user, you cannot program custom logic in transactions. Flash loans can only be taken and repaid by smart contracts. Flash loans is a powerful financial instrument in DeFi. While its often used to exploit vulnerabilities in DeFi protocols (by inflating pool balances and abusing flawed state management), its has many good applications (e.g. leveraged positions management on lending protocols)this is why DeFi applications that store liquidity provide permissionless flash loans. Implementing Flash Loans  # In Uniswap V2 flash loans were part of the swapping functionality: it was possible to borrow tokens during a swap, but you had to return them or an equal amount of the other pool token, in the same transaction. In V3, flash loans are separated from swappingits simply a function that gives the caller an amount of tokens they requested, calls a callback on the caller, and ensures a flash loan was repaid: function   flash (       uint256  amount0,       uint256  amount1,       bytes  calldata data  )  public  {       uint256  balance0Before  =  IERC20(token0).balanceOf( address (this));       uint256  balance1Before  =  IERC20(token1).balanceOf( address (this));         if  (amount0  >   0 ) IERC20(token0).transfer(msg.sender, amount0);       if  (amount1  >   0 ) IERC20(token1).transfer(msg.sender, amount1);        IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(data);        require(IERC20(token0).balanceOf( address (this))  >=  balance0Before);      require(IERC20(token1).balanceOf( address (this))  >=  balance1Before);        emit Flash(msg.sender, amount0, amount1);  }  The function sends tokens to the caller and then calls  uniswapV3FlashCallback  on itthis is where the caller is expected to repay the loan. Then the function ensures that its balances havent decreased. Notice that custom data is allowed to be passed to the callback. Heres an example of the callback implementation: function   uniswapV3FlashCallback ( bytes  calldata data)  public  {      ( uint256  amount0,  uint256  amount1)  =  abi.decode(          data,          ( uint256 ,  uint256 )      );         if  (amount0  >   0 ) token0.transfer(msg.sender, amount0);       if  (amount1  >   0 ) token1.transfer(msg.sender, amount1);  }  In this implementation, were simply sending tokens back to the pool (I used this callback in  flash  function tests). In reality, it can use the loaned amounts to perform some operations on other DeFi protocols. But it always must repay the loan in this callback. And thats it! Flash Loans Implementing Flash Loans", "labels": ["Documentation"]}, {"title": "Quoter Contract #", "html_url": "https://uniswapv3book.com/docs/milestone_2/quoter-contract/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Quoter Contract   Quoter Contract Recap Quoter Limitation Quoter Contract  # To integrate our updated Pool contract into the front end app, we need a way to calculate swap amounts without making a swap. Users will type in the amount they want to sell, and we want to calculate and show them the amount theyll get in exchange. Well do this through Quoter contract. Since liquidity in Uniswap V3 is scattered over multiple price ranges, we cannot calculate swap amounts with a formula (which was possible in Uniswap V2). The design of Uniswap V3 forces us to use a different approach: to calculate swap amounts, well initiate a real swap and will interrupt it in the callback function, grabbing the amounts calculated by Pool contract. That is, we have to simulate a real swap to calculate output amount! Again, well make a helper contract for that: contract   UniswapV3Quoter  {       struct   QuoteParams  {           address  pool;           uint256  amountIn;           bool  zeroForOne;      }         function   quote (QuoteParams  memory  params)           public            returns  (               uint256  amountOut,               uint160  sqrtPriceX96After,               int24  tickAfter          )      {          ...  Quoter is a contract that implements only one public function quote . Quoter is a universal contract that works with any pool so it takes pool address as a parameter. The other parameters ( amountIn  and  zeroForOne ) are required to simulate a swap. try       IUniswapV3Pool(params.pool).swap(           address (this),          params.zeroForOne,          params.amountIn,          abi.encode(params.pool)      )  {}  catch  ( bytes   memory  reason) {       return  abi.decode(reason, ( uint256 ,  uint160 ,  int24 ));  }  The only thing that the contract does is calling  swap  function of a pool. The call is expected to revert (i.e. throw an error)well do this in the swap callback. In the case of a revert, revert reason is decoded and returned;  quote  will never revert. Notice that, in the extra data, were passing only pool addressin the swap callback, well use it to get pools  slot0  after a swap. function   uniswapV3SwapCallback (       int256  amount0Delta,       int256  amount1Delta,       bytes   memory  data  )  external   view  {       address  pool  =  abi.decode(data, ( address ));         uint256  amountOut  =  amount0Delta  >   0            ?   uint256 ( - amount1Delta)           :   uint256 ( - amount0Delta);        ( uint160  sqrtPriceX96After,  int24  tickAfter)  =  IUniswapV3Pool(pool)          .slot0();  In the swap callback, were collecting values that we need: output amount, new price, and corresponding tick. Next, we need to save these values and revert: assembly  {       let  ptr  :=   mload ( 0x40 )       mstore (ptr, amountOut)       mstore ( add (ptr,  0x20 ), sqrtPriceX96After)       mstore ( add (ptr,  0x40 ), tickAfter)       revert (ptr,  96 )  }  For gas optimization, this piece is implemented in  Yul , the language used for inline assembly in Solidity. Lets break it down: mload(0x40)  reads the pointer of the next available memory slot (memory in EVM is organized in 32 byte slots); at that memory slot,  mstore(ptr, amountOut)  writes  amountOut ; mstore(add(ptr, 0x20), sqrtPriceX96After)  writes  sqrtPriceX96After  right after  amountOut ; mstore(add(ptr, 0x40), tickAfter)  writes  tickAfter  after  sqrtPriceX96After ; revert(ptr, 96)  reverts the call and returns 96 bytes (total length of the values we wrote to memory) of data at address  ptr  (start of the data we wrote above). So, were basically concatenating the bytes representations of the values we need (exactly what  abi.encode()  does). Notice that the offsets are always 32 bytes, even though  sqrtPriceX96After  takes 20 bytes ( uint160 ) and  tickAfter  takes 3 bytes ( int24 ). This is so we could use  abi.decode()  to decode the data: its counterpart,  abi.encode() , encodes all integers as 32-byte words. Aaaand, done. Recap  # Lets recap to better understand the algorithm: quote  calls  swap  of a pool with input amount and swap direction; swap  performs a real swap, it runs the loop to fill the input amount specified by user; to get tokens from user,  swap  calls the swap callback on the caller; the caller (Quote contract) implements the callback, in which it reverts with output amount, new price, and new tick; the revert bubbles up to the initial  quote  call; in  quote , the revert is caught, revert reason is decoded and returned as the result of calling  quote . I hope this is clear! Quoter Limitation  # This design has one significant limitation: since  quote  calls  swap  function of Pool contract, and  swap  function is not a pure or view function (because it modifies contract state),  quote  cannot also be pure or view.  swap  modifies state and so does  quote , even if not in Quoter contract. But we treat  quote  as a getter, a function that only reads contract data. This inconsistency means that EVM will use  CALL  opcode instead of  STATICCALL  when  quote  is called. This is not a big problem since Quoter reverts in the swap callback, and reverting resets the state modified during a callthis guarantees that  quote  wont modify the state of Pool contract (no actual trade will happen). Another inconvenience that comes from this issue is that calling  quote  from a client library (Ethers.js, Web3.js, etc.) will trigger a transaction. To fix this, well need to force the library to make a static call. Well see how to do this in Ethers.js later in this milestone. Quoter Contract Recap Quoter Limitation", "labels": ["Documentation"]}, {"title": "User Interface #", "html_url": "https://uniswapv3book.com/docs/milestone_1/user-interface/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   User Interface   User Interface Overview of Tools What is MetaMask? Convenience Libraries Workflows Connecting to Local Node Connecting to MetaMask Providing Liquidity Swapping Tokens Subscribing to Changes User Interface  # Finally, we made it to the final stop of this milestonebuilding a user interface! Since building a front-end app is not the main goal of this book, I wont show how to build such an app from scratch. Instead, Ill show how to use MetaMask to interact with smart contracts. If you want to experiment with the app and run it locally, you can fund it in the  ui  folder in the code repo. This is a simple React app, to run it locally set contracts addresses in  App.js  and run  yarn start . Overview of Tools  # What is MetaMask?  # MetaMask is an Ethereum wallet implemented as a browser extension. It creates and stores private keys, shows token balances, allows to connect to different networks, sends, and receives ether and tokenseverything a wallet has to do. Besides that, MetaMask acts as a signer and a provider. As a provider, it connects to an Ethereum node and provides an interface to use its JSON-RPC API. As a signer, it provides an interface for secure transaction signing, thus it can be used to sign any transaction using a private key from the wallet. Convenience Libraries  # MetaMask, however, doesnt provide much functionality: it can only manage accounts and send raw transactions. We need another library that will make interaction with contracts easy. And we also want a set of utilities that will make our life easier when handling EVM-specific data (ABI encoding/decoding, big numbers handling, etc.). There are multiple such libraries. The two most popular ones are:  web3.js  and  ethers.js . Picking either of them is a matter of personal preference. To me, Ethers.js seems to have a cleaner contract interaction interface, so Ill pick it. Workflows  # Lets now see how we can implement interaction scenarios using MetaMask + Ethers.js. Connecting to Local Node  # To send transactions and fetch blockchain data, MetaMask connects to an Ethereum node. To interact with our contracts, we need to connect to the local Anvil node. To do this, open MetaMask, click on the list of networks, click Add Network, and add a network with RPC URL  http://localhost:8545 . Itll automatically detect the chain ID (31337 in the case of Anvil). After connecting to the local node, we need to import our private key. In MetaMask, click on the list of addresses, click Import Account, and paste the private key of the address you picked before deploying the contracts. After that, go to the assets list and import the addresses of the two tokens. Now you should see balances of the tokens in MetaMask. MetaMask is still somewhat bugged. One problem I struggled with is that it caches blockchain state when connected to  localhost . Because of this, when restarting the node, you might see old token balances and state. To fix this, go to the advanced settings and click Reset Account. Youll need to do this each time after restarting the node. Connecting to MetaMask  # Not every website is allowed to get access to your address in MetaMask. A website first needs to connect to MetaMask. When a new website is connecting to MetaMask, youll see a window that asks for permissions. Heres how to connect to MetaMask from a front-end app: // ui/src/contexts/MetaMask.js  const   connect   =  () => {     if  ( typeof  (window. ethereum )  ===   'undefined' ) {       return   setStatus ( 'not_installed' );    }      Promise. all ([      window. ethereum . request ({  method :   'eth_requestAccounts'  }),      window. ethereum . request ({  method :   'eth_chainId'  }),    ]). then ( function  ([ accounts ,  chainId ]) {       setAccount ( accounts [ 0 ]);       setChain ( chainId );       setStatus ( 'connected' );    })      . catch ( function  ( error ) {         console . error ( error )      });  }  window.ethereum  is an object provided by MetaMask, its the interface to communicate with MetaMask. If its undefined, MetaMask is not installed. If its defined, we can send two requests to MetaMask:  eth_requestAccounts  and  eth_chainId . In fact,  eth_requestAccounts  connects a website to MetaMask. It basically queries an address from MetaMask, and MetaMask asks for permission from user. User will be able to choose which addresses to give access to. eth_chainId  will ask for the chain ID of the node MetaMask is connected to. After obtaining an address and chain ID, its a good practice to display them in the interface: Providing Liquidity  # To provide liquidity into the pool, we need to build a form that asks the user to type the amounts they want to deposit. After clicking Submit, the app will build a transaction that calls  mint  in the manager contract and provides the amounts chosen by users. Lets see how to do this. Ether.js provides  Contract  interface to interact with contracts. It makes our life much easier, since it takes on the job of encoding function parameters, creating a valid transaction, and handing it over to MetaMask. For us, calling contracts looks like calling asynchronous methods on a JS object. Lets see how to create an instance of  Contracts : token0   =   new   ethers . Contract (     props . config . token0Address ,     props . config . ABIs . ERC20 ,     new   ethers . providers . Web3Provider (window. ethereum ). getSigner ()  );  A  Contract  instance is an address and the ABI of the contract deployed at this address. The ABI is needed to interact with the contract. The third parameter is the signer interface provided by MetaMaskits used by the JS contract instance to sign transactions via MetaMask. Now, lets add a function for adding liquidity to the pool: const   addLiquidity   =  ( account , {  token0 ,  token1 ,  manager  }, {  managerAddress ,  poolAddress  }) => {     const   amount0   =   ethers . utils . parseEther ( \"0.998976618347425280\" );     const   amount1   =   ethers . utils . parseEther ( \"5000\" );  // 5000 USDC     const   lowerTick   =   84222 ;     const   upperTick   =   86129 ;     const   liquidity   =   ethers . BigNumber . from ( \"1517882343751509868544\" );     const   extra   =   ethers . utils . defaultAbiCoder . encode (      [ \"address\" ,  \"address\" ,  \"address\" ],      [ token0 . address ,  token1 . address ,  account ]    );    ...  The first thing to do is to prepare the parameters. We use the same values we calculated earlier. Next, we allow the manager contract to take our tokens. First, we check the current allowances: Promise. all (    [       token0 . allowance ( account ,  managerAddress ),       token1 . allowance ( account ,  managerAddress )    ]  )  Then, we check if either of them is enough to transfer a corresponding amount of tokens. If not, were sending an  approve  transaction, which asks the user to approve spending of a specific amount to the manager contract. After ensuring that the user has approved full amounts, we call  manager.mint  to add liquidity: . then (([ allowance0 ,  allowance1 ]) => {     return  Promise. resolve ()      . then (() => {         if  ( allowance0 . lt ( amount0 )) {           return   token0 . approve ( managerAddress ,  amount0 ). then ( tx  =>  tx . wait ())        }      })      . then (() => {         if  ( allowance1 . lt ( amount1 )) {           return   token1 . approve ( managerAddress ,  amount1 ). then ( tx  =>  tx . wait ())        }      })      . then (() => {         return   manager . mint ( poolAddress ,  lowerTick ,  upperTick ,  liquidity ,  extra )          . then ( tx  =>  tx . wait ())      })      . then (() => {         alert ( 'Liquidity added!' );      });  })  lt  is a method of  BigNumber . Ethers.js uses BigNumber to represent  uint256  type, for which JavaScript  doesnt have enough precision . This is one of the reasons why we want a convenience library. This is pretty much similar to the test contract, besides the allowances part. token0 ,  token1 , and  manager  in the above code are instances of  Contract .  approve  and  mint  are contract functions, which were generated dynamically from the ABIs we provided when instantiated the contracts. When calling these methods, Ethers.js: encodes function parameters; builds a transaction; passes the transaction to MetaMask and asks to sign it; user sees a MetaMask window and presses Confirm; sends the transaction to the node MetaMask is connected to; returns a transaction object with full information about the sent transaction. The transaction object also contains  wait  function, which we call to wait for a transaction to be minedthis allows us to wait for a transaction to be successfully executed before sending another. Ethereum requires a strict order of transaction. Remember the nonce? Its an account-wide index of transactions, sent by this account. Every new transaction increases this index, and Ethereum wont mine a transaction until a previous transaction (one with a smaller nonce) was mined. Swapping Tokens  # To swap tokens, we use the same pattern: get parameters from the user, check allowance, call  swap  on the manager. const   swap   =  ( amountIn ,  account , {  tokenIn ,  manager ,  token0 ,  token1  }, {  managerAddress ,  poolAddress  }) => {     const   amountInWei   =   ethers . utils . parseEther ( amountIn );     const   extra   =   ethers . utils . defaultAbiCoder . encode (      [ \"address\" ,  \"address\" ,  \"address\" ],      [ token0 . address ,  token1 . address ,  account ]    );       tokenIn . allowance ( account ,  managerAddress )      . then (( allowance ) => {         if  ( allowance . lt ( amountInWei )) {           return   tokenIn . approve ( managerAddress ,  amountInWei ). then ( tx  =>  tx . wait ())        }      })      . then (() => {         return   manager . swap ( poolAddress ,  extra ). then ( tx  =>  tx . wait ())      })      . then (() => {         alert ( 'Swap succeeded!' );      }). catch (( err ) => {         console . error ( err );         alert ( 'Failed!' );      });  }  The only new thing here is  ethers.utils.parseEther()  function, which we use to convert numbers to wei, the smallest unit in Ethereum. Subscribing to Changes  # For a decentralized application, its important to reflect the current blockchain state. For example, in the case of a decentralized exchange, its critical to properly calculate swap prices based on current pool reserves; outdated data can cause slippage and make a swap transaction fail. While developing the pool contract, we learned about events, which act as blockchain data indexes: whenever smart contract state is modified, its a good practice to emit an event since events are indexed for quick search. What were going to do now, is to subscribe to contract events to keep our front-end app updated. Lets build an event feed! If you checked the ABI file as I recommended earlier, you saw that it also contains description of events: event name and its fields. Well,  Ether.js parses them  and provides an interface to subscribe to new events. Lets see how this works. To subscribe to events, well use  on(EVENT_NAME, handler)  function. The callback receives all the fields of the event and the event itself as parameters: const   subscribeToEvents   =  ( pool ,  callback ) => {     pool . on ( \"Mint\" , ( sender ,  owner ,  tickLower ,  tickUpper ,  amount ,  amount0 ,  amount1 ,  event ) =>  callback ( event ));     pool . on ( \"Swap\" , ( sender ,  recipient ,  amount0 ,  amount1 ,  sqrtPriceX96 ,  liquidity ,  tick ,  event ) =>  callback ( event ));  }  To filter and fetch previous events, we can use  queryFilter : Promise. all ([     pool . queryFilter ( \"Mint\" ,  \"earliest\" ,  \"latest\" ),     pool . queryFilter ( \"Swap\" ,  \"earliest\" ,  \"latest\" ),  ]). then (([ mints ,  swaps ]) => {    ...  });  You probably noticed that some event fields are marked as  indexed such fields are indexed by Ethereum nodes, which lets search events by specific values in such fields. For example, the  Swap  event has  sender  and  recipient  fields indexed, so we can search by swap sender and recipient. And again, Ethere.js makes this easier: const   swapFilter   =   pool . filters . Swap ( sender ,  recipient );  const   swaps   =   await   pool . queryFilter ( swapFilter ,  fromBlock ,  toBlock );  And thats it! Were done with milestone 1!     \\[ \\] User Interface Overview of Tools What is MetaMask? Convenience Libraries Workflows Connecting to Local Node Connecting to MetaMask Providing Liquidity Swapping Tokens Subscribing to Changes", "labels": ["Documentation"]}, {"title": "User Interface #", "html_url": "https://uniswapv3book.com/docs/milestone_2/user-interface/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   User Interface   User Interface User Interface  # Lets make our web app work more like a real DEX. We can now remove hardcoded swap amounts and let users type arbitrary amounts. Moreover, we can now let users swap in both direction, so we also need a button to swap the token inputs. After updating, the swap form will look like: < form   className = \"SwapForm\" >      < SwapInput        amount = { zeroForOne   ?   amount0   :   amount1 }       disabled = { ! enabled   ||   loading }       readOnly = { false }       setAmount = { setAmount_ ( zeroForOne   ?   setAmount0   :   setAmount1 ,  zeroForOne )}       token = { zeroForOne   ?   pair [ 0 ]  :   pair [ 1 ]}  />      < ChangeDirectionButton   zeroForOne = { zeroForOne }  setZeroForOne = { setZeroForOne }  disabled = { ! enabled   ||   loading }  />      < SwapInput        amount = { zeroForOne   ?   amount1   :   amount0 }       disabled = { ! enabled   ||   loading }       readOnly = { true }       token = { zeroForOne   ?   pair [ 1 ]  :   pair [ 0 ]}  />      < button   className = 'swap'   disabled = { ! enabled   ||   loading }  onClick = { swap_ } > Swap < /button>   < /form>   Each input has an amount assigned to it depending on swap direction controlled by  zeroForOne  state variable. The lower input field is always read-only because its value is calculated by Quoter contract. setAmount_  function does two things: it updates the value of the top input and calls Quoter contract to calculate the value of the lower input: const   updateAmountOut   =   debounce (( amount ) => {     if  ( amount   ===   0   ||   amount   ===   \"0\" ) {       return ;    }       setLoading ( true );       quoter . callStatic       . quote ({  pool :   config . poolAddress ,  amountIn :   ethers . utils . parseEther ( amount ),  zeroForOne :   zeroForOne  })      . then (({  amountOut  }) => {         zeroForOne   ?   setAmount1 ( ethers . utils . formatEther ( amountOut ))  :   setAmount0 ( ethers . utils . formatEther ( amountOut ));         setLoading ( false );      })      . catch (( err ) => {         zeroForOne   ?   setAmount1 ( 0 )  :   setAmount0 ( 0 );         setLoading ( false );         console . error ( err );      })  })    const   setAmount_   =  ( setAmountFn ) => {     return  ( amount ) => {       amount   =   amount   ||   0 ;       setAmountFn ( amount );       updateAmountOut ( amount )    }  }  Notice the  callStatic  called on  quoter this is what we discussed in the previous chapter: we need to force Ethers.js to make a static call. Since  quote  is not a  pure  or  view  function, Ethers.js will try to call  quote  in a transaction. And thats it! The UI now allows to specify arbitrary amounts and swap in either direction! User Interface", "labels": ["Documentation"]}, {"title": "User Interface #", "html_url": "https://uniswapv3book.com/docs/milestone_3/user-interface/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   User Interface   User Interface Add Liquidity Dialog Slippage Tolerance in Swapping User Interface  # Were now ready to update the UI with the changes we made in this milestone. Well add two new features: Add Liquidity dialog window; slippage tolerance in swapping. Add Liquidity Dialog  # This change will finally remove hard coded liquidity amounts from our code and will allow use to add liquidity at arbitrary ranges. The dialog is a simple component with a couple of inputs. We can even re-use  addLiquidity  function from previous implementation. However, now we need to convert prices to tick indices in JavaScript: we want users to type in prices but the contracts expect ticks. To make our job easier, well use  the official Uniswap V3 SDK  for that. To convert price to $\\sqrt{P}$, we can use  encodeSqrtRatioX96  function. The function takes two amounts as input and calculates a price by dividing one by the other. Since we only want to convert price to $\\sqrt{P}$, we can pass 1 as  amount0 : const   priceToSqrtP   =  ( price ) =>  encodeSqrtRatioX96 ( price ,  1 );  To convert price to tick index, we can use  TickMath.getTickAtSqrtRatio  function. This is an implementation of the Solidity TickMath library in JavaScript: const   priceToTick   =  ( price ) =>  TickMath . getTickAtSqrtRatio ( priceToSqrtP ( price ));  So we can now convert prices typed in by users to ticks: const   lowerTick   =   priceToTick ( lowerPrice );  const   upperTick   =   priceToTick ( upperPrice );  Another thing we need to add here is slippage protection. For simplicity, I made it a hard coded value and set it to 0.5%. Heres how to use slippage tolerance to calculate minimal amounts: const   slippage   =   0.5 ;  const   amount0Desired   =   ethers . utils . parseEther ( amount0 );  const   amount1Desired   =   ethers . utils . parseEther ( amount1 );  const   amount0Min   =   amount0Desired . mul (( 100   -   slippage )  *   100 ). div ( 10000 );  const   amount1Min   =   amount1Desired . mul (( 100   -   slippage )  *   100 ). div ( 10000 );  Slippage Tolerance in Swapping  # Even though were the only user of the application and thus will never have problems with slippage during development, lets add an input to control slippage tolerance during swaps. When swapping, slippage protection is implemented via limiting pricea price we dont to go above or below during a swap. This means that we need to know this price before sending a swap transaction. However, we dont need to calculate it on the front end because Quoter contract does this for us: function   quote (QuoteParams  memory  params)       public        returns  (           uint256  amountOut,           uint160  sqrtPriceX96After,           int24  tickAfter      ) { ... }  And were calling Quoter to calculate swap amounts. So, to calculate limiting price we need to take  sqrtPriceX96After  and subtract slippage tolerance from itthis will be the price we dont want to go below during a swap. const limitPrice  =  priceAfter.mul(( 100   -  parseFloat(slippage))  *   100 ).div( 10000 );  And thats it!    \\[ \\] User Interface Add Liquidity Dialog Slippage Tolerance in Swapping", "labels": ["Documentation"]}, {"title": "", "html_url": "https://uniswapv3book.com/categories/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Categories   Categories Tags Categories Tags", "labels": ["Documentation"]}, {"title": "", "html_url": "https://uniswapv3book.com/docs/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Docs", "labels": ["Documentation"]}, {"title": "Uniswap V3 Development Book #", "html_url": "https://uniswapv3book.com/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Introduction   Uniswap V3 Development Book This book is not for complete beginners However, this book is for blockchain beginners Useful links Questions? Where to start for a complete beginner? Uniswap Grants Program Uniswap V3 Development Book  # Welcome to the world of decentralized finances and automated market makers! This book will be your guide in this mysterious and amusing world! Together, well build one of the most interesting and important applications, which serves as a pillar of todays decentralized finances Uniswap V3 ! This book will guide you through the development of a decentralized application, including: smart-contract development (in  Solidity ); contracts testing and deployment (using Forge and Anvil from  Foundry ); design and mathematics of a decentralized exchange; development of a front-end application for the exchange ( React  and  MetaMask ). This book is not for complete beginners  # I expect you to be an experienced developer, who has ever programmed in any programming language. Itll also be helpful if you know  the syntax of Solidity , the main programming language of this book. If not, its not a big problem: well learn a lot about Solidity and Ethereum Virtual Machine during our journey. However, this book is for blockchain beginners  # If you only heard about blockchains and were interested but havent had a chance to dive deeper, this book is for you! Yes, for you personally! Youll learn how to develop for blockchains (specifically, Ethereum), how blockchains work, how to program and deploy smart contracts, and how to run and test them on your computer. Alright, lets get started! Useful links  # This book is available at:  https://uniswapv3book.com/ This book is hosted on GitHub:  https://github.com/Jeiwan/uniswapv3-book All source codes are hosted in a separate repo:  https://github.com/Jeiwan/uniswapv3-code If you think you can help Uniswap, they have  a grants program . If youre interested in DeFi and blockchains,  follow me on Twitter . Questions?  # Each milestone has its own section in  the GitHub Discussions . Dont hesitate to ask questions about anything thats not clear in the book! Where to start for a complete beginner?  # This book will be easy for those who know something about constant-function market makers and Uniswap. If youre a complete beginner in decentralized exchanges, heres how Id recommend starting: Read my Uniswap V1 series. It covers the very basics of Uniswap, and the code is much more simpler. If you have some experience with Solidity, skip the code since its very basic and Uniswap V2 does it better. Programming DeFi: Uniswap. Part 1 Programming DeFi: Uniswap. Part 2 Programming DeFi: Uniswap. Part 3 Read my Uniswap V2 series. I dont go too deep into the math and underlying concepts here since theyre covered in the V1 series, but the code of V2 is really worth getting familiar withitll hopefully teach you a different way of thinking about smart contracts programming (its not how we usually write programs). Programming DeFi: Uniswap V2. Part 1 Programming DeFi: Uniswap V2. Part 2 Programming DeFi: Uniswap V2. Part 3 Programming DeFi: Uniswap V2. Part 4 If math is an issue, consider going through  Algebra 1  and  Algebra 2  courses on Khan Academy. The math of Uniswap is not hard, but it requires the skill of basic algebraic manipulations. Uniswap Grants Program  # To write this book, I received a grant from  Uniswap Foundation . Without the grant, I wouldnt probably have had enough motivation and patience to dig Uniswap into its deepest depths and to finish the book. The grant is also the main reason why the book is open-source and free for anyone. You can  learn more about Uniswap Grants Program  (and maybe apply!). Uniswap V3 Development Book This book is not for complete beginners However, this book is for blockchain beginners Useful links Questions? Where to start for a complete beginner? Uniswap Grants Program", "labels": ["Documentation"]}, {"title": "", "html_url": "https://uniswapv3book.com/docs/introduction/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Milestone 0. Introduction", "labels": ["Documentation"]}, {"title": "", "html_url": "https://uniswapv3book.com/docs/milestone_1/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Milestone 1. First Swap", "labels": ["Documentation"]}, {"title": "", "html_url": "https://uniswapv3book.com/docs/milestone_2/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Milestone 2. Second Swap", "labels": ["Documentation"]}, {"title": "", "html_url": "https://uniswapv3book.com/docs/milestone_3/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Milestone 3. Cross-tick Swaps", "labels": ["Documentation"]}, {"title": "", "html_url": "https://uniswapv3book.com/docs/milestone_4/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Milestone 4. Multi-pool Swaps", "labels": ["Documentation"]}, {"title": "", "html_url": "https://uniswapv3book.com/docs/milestone_5/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Milestone 5. Fees and Price Oracle", "labels": ["Documentation"]}, {"title": "", "html_url": "https://uniswapv3book.com/docs/milestone_6/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Milestone 6: NFT positions", "labels": ["Documentation"]}, {"title": "", "html_url": "https://uniswapv3book.com/tags/", "body": "Uniswap V3 Development Book Milestone 0. Introduction Introduction to Markets Constant Function Market Makers Uniswap V3 Development Environment What We'll Build Milestone 1. First Swap Introduction Calculating Liquidity Providing Liquidity First Swap Manager Contract Deployment User Interface Milestone 2. Second Swap Introduction Output Amount Calculation Math in Solidity Tick Bitmap Index Generalize Minting Generalize Swapping Quoter Contract User Interface Milestone 3. Cross-tick Swaps Introduction Different Price Ranges Cross-Tick Swaps Slippage Protection Liquidity Calculation A Little Bit More on Fixed-point Numbers Flash Loans User Interface Milestone 4. Multi-pool Swaps Introduction Factory Contract Swap Path Multi-pool Swaps User Interface Tick Rounding Milestone 5. Fees and Price Oracle Introduction Swap Fees Flash Loan Fees Protocol Fees Price Oracle User Interface Milestone 6: NFT positions Introduction ERC721 Overview NFT Manager NFT Renderer   Tags   Categories Tags Categories Tags", "labels": ["Documentation"]}, {"title": "Introduction", "html_url": "https://www.mev.wiki/", "body": "Introduction Welcome to the MEV Wiki.   Introduction This is a public resource for learning about  MEV (Maximal Extractable Value). We cover a range of topics including the key concepts, research on this the topic, different approaches to tackling this issue by various projects out there.  Find any errors or wants to share your opinions? See how you can contribute  here .  What is MEV? Maximal (formerly \"miner\" in the context of Proof of Work) extractable value (MEV) refers to the maximum value that can be extracted from block production in excess of the standard block reward and gas fees by censoring and/or changing the order of transactions in a block. When someone sends a transaction in the blockchain, there is a delay between the time when the transaction is broadcasted to the network and when it is actually mined into a block. During this period, transactions sit in a pending transaction pool called the mempool where contents are visible to everyone. Arbitrageurs and miners can monitor the mempool and find opportunities to maximize their own profits e.g. by frontrunning transactions. If a front-runner is a miner, they can also reorder or even censor transactions. MEV income can also be shared with non miners & traders who participate in some profit sharing schemes within the category of  FaaS/MEVA .   Why does this matter  ? MEV can harm users MEV is an invisible tax that miners can collect from users. MEV can destabilize Ethereum If block rewards are small enough compared to MEV, it can be rational for miners to destabilize consensus by reordering or censoring transactions.  Just how bad is the problem? You can use the  Flashbots Dashboard  to track Extracted MEV to better assess this worsening trend realtime. Snapshot of Extracted MEV on 28 Sep 2021 from Flashbots It is estimated that more than $727M of MEV has been extracted since 1st January 2020. Snapshot of Extracted MEV Split on 28 Sep 2021 from Flashbots The majority of extracted MEV tend to be from  Arbitrage  opportunities on various  AMMs , with a large percentage of income going to searchers, bots & participants in profit sharing MEV infrastructures (eg.  Flashbot's  MEV-GETH) Another useful tracker for gas consumption of back-running bots:   Dune Analytics  provides very detailed statistics on this worsening MEV situation. Link:  According to  https://research.paradigm.xyz/MEV    Next Resource  List Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Attack Examples", "html_url": "https://www.mev.wiki/attack-examples", "body": "Attack Examples Some example of attacks. Front-running Sandwich attack Back-running Liquidations Time bandit attack Uncle bandit attack Previous Transaction Ordering Next Front-running Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Attempts to trick the bots", "html_url": "https://www.mev.wiki/attempts-to-trick-the-bots", "body": "Attempts to trick the bots What are the ways some have come up with to trick bots? Salmonella Kattana Other attempts   Previous Uncle bandit attack Next Salmonella Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Contributions", "html_url": "https://www.mev.wiki/contributions", "body": "Contributions BUIDL with MEV Wiki If you would like to contribute to this Wiki on MEV knowledge, please click the \"Edit on Github\" button on any page. Then  create a Github pull request  to suggest your changes.  This wiki is maintained & sponsored by  Automata Network . If you would like to become a contributor, please join Automata  Discord Server .   Previous Miscellaneous Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Miscellaneous", "html_url": "https://www.mev.wiki/miscellaneous", "body": "Miscellaneous What Happens when Ethereum moves to Proof-of-Stake? The move from PoW to PoS consensus means the Ethereum network becomes secured by a set validators, who stake their ETH and vote on consensus, as opposed to miners who run mining equipment to solve for the proof of work. This change of consensus is set to happen likely some time in 2021. Some have suggested that this means Miner Extractable Value will become Validator Extractable Value. This is an ongoing discussion and you can follow this here:  Link:  https://hackmd.io/@flashbots/ryuH4gn7d  From Paradigm's piece \"On Staking Pools and Staking Derivatives\" - Staking pools and their staking derivatives are subject to similar market realities as MEV extraction, in the sense that their existence is inevitable. Institutional staking pools (e.g. exchanges) may have social and reputational constraints that prevent them from extracting certain forms of MEV. This allows smaller staking firms and decentralized pools without these constraints to provide higher returns for their stakers. This could turn the decentralization premium for using a decentralized staking pool into a decentralization discount. Link:  https://research.paradigm.xyz/staking  Other Academic Papers Tesseract Tesseract proposes a front-running resistant exchange relying on Intel SGX as a trusted execution environment. Link:   https://eprint.iacr.org/2017/1153.pdf  Calypso Enables a blockchain to hold and manage secrets on-chain with the convenient property that it is able to protect against front-running. Link:  https://eprint.iacr.org/2018/209.pdf  Previous B.Protocol Next Contributions Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Resource  List", "html_url": "https://www.mev.wiki/resource-list", "body": "Resource  List    Links Name Type  What Is Miner-Extractable Value (MEV)?    Article  Miners, Front-Running-as-a-Service Is Theft    Article  MEV and Me    Article  Ethereum is a Dark Forest    Article  Escaping the Dark Forest    Article  Ethereum Blockspace: Who Gets What and Why    Article  The fastest draw on the Blockchain: Ethereum Backrunning    Article  Security of Interoperability    Presentation  Gas Wars: Understanding Ethereum's Mempool & Miner Extractable Value    Podcast  Smart Contract Security - Incentives Beyond the Launch by Phil Daian (Devcon4)    Video  Enter the Dark Forest: the terrifying world of MEV and Flash bots    Video  Frontrunning in Decentralized Exchanges, Miner Extractable Value, and Consensus Instability    Video  How To Get Front-Run on Ethereum mainnet    Video  Flash Boys 2.0: Frontrunning, Transaction Reordering, and Consensus Instability in Decentralized Exchanges    Research Paper  Quantifying Blockchain Extractable Value: How dark is the forest?    Research Paper  High-Frequency Trading on Decentralized On-Chain Exchanges    Research Paper  Frontrunner Jones and the Raiders of the Dark Forest: An Empirical Study of Frontrunning on the Ethereum Blockchain    Research Paper Previous Introduction Next Terms and Concepts Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Solutions", "html_url": "https://www.mev.wiki/solutions", "body": "Solutions Different approaches to tackling the MEV problem There are largely 2 schools of thought when it comes to approaching the MEV problem 1.  Offense  - MEV is here to stay so let's find a way to extract and democratize it. 2.  Defense  - MEV is bad so let's try to prevent it. Projects like Automata Network are in the Defense camp where the solution  Conveyor  ingests transactions and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering. To further explain, we have put different approaches into 3 categories: Front-running as a Service (FaaS) or MEV Auctions (MEVA) MEV Minimization Other solutions   Previous Other attempts Next Front-running as a Service (FaaS) or MEV Auctions (MEVA) Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Terms and Concepts", "html_url": "https://www.mev.wiki/terms-and-concepts", "body": "Terms and Concepts Exploring the main concepts involving MEV. DeFi Automated Market Maker Arbitrage Lending Platforms Slippage Liquidations Priority Gas Auctions Transaction Ordering  Previous Resource  List Next DeFi Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Back-running", "html_url": "https://www.mev.wiki/attack-examples/back-running", "body": "Back-running What is back-running? Back-running occurs when a transaction sender wishes to have their transaction ordered immediately after some unconfirmed \"target transaction\". Example: A back-running bot that back-runs new token listings. Bot monitors the Ethereum mempool for new pairs being created on Uniswap. If it finds a new pair the bot places a buy transaction immediately behind the initial liquidity. The bot swoops in and buys as many tokens as possible (but not all of them as there needs to be an opportunity for others to buy tokens as well).The bot then waits for the price to go up as other traders buy the token from Uniswap and proceeds to sell back the tokens at a higher price. The key in this strategy is to be the first to buy tokens, but only after the token has been launched  . In order to maximise their chances of being mined immediately after their target, a typical backrunner will send many identical transactions, with gas price identical to that of the target transaction, sometimes from different accounts. 1.  https://amanusk.medium.com/the-fastest-draw-on-the-blockchain-bzrx-example-6bd19fabdbe1  Previous Sandwich attack Next Liquidations Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Front-running", "html_url": "https://www.mev.wiki/attack-examples/front-running", "body": "Front-running What is front-running? Front-running is the process by which an adversary observes transactions on the network layer and then acts upon this information by, for instance, issuing a competing transaction, with the hope that this transaction is mined before a victim transaction e.g. Transaction A is broadcasted with a higher gas price than an already pending transaction B so that A gets mined before B. Previous Attack Examples Next Sandwich attack Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Liquidations", "html_url": "https://www.mev.wiki/attack-examples/liquidations", "body": "Liquidations How are liquidations exploited? Back-running strategies also apply to liquidations whereby a transaction sender wishes to be the first to liquidate a loan right after a price oracle update (which will allow liquidation to be triggered). Fixed spread liquidation used by Compound, Aave, and dYdX allows a liquidator to purchase collateral at a fixed discount when repaying debt. Strategy 1 Strategy 2 A detects a liquidation opportunity at block B (i.e., after the execution of B). A then issues a liquidation transaction T, which is expected to be mined in the next block B +1. A attempts to destructively front-run other competing liquidators by setting high transaction fees for his liquidation transaction T. A observes a transaction T, which will create a liquidation opportunity (e.g., an oracle price update transaction which will render a collateralized debt liquidatable). A then back-runs T with a liquidation transaction TA to avoid the transaction fee bidding competition. The auction liquidation allows a liquidator to start an auction that lasts for a pre-configured period (e.g., 6 hours). Competing liquidators can engage and bid on the collateral price. Previous Back-running Next Time bandit attack Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Sandwich attack", "html_url": "https://www.mev.wiki/attack-examples/sandwich-attack", "body": "Sandwich attack What is a sandwich attack? Alice wants to buy a Token A on a Decentralised Exchange (DEX) that uses an automated market maker (AMM) model. An adversary which sees Alices transaction can create two of its own transactions which it inserts before and after Alices transaction (sandwiching it). The adversarys first transaction buys Token A, which pushes up the price for Alices transaction, and then the third transaction is the adversarys transaction to sell Token A (now at a higher price) at a profit. Previous Front-running Next Back-running Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Time bandit attack", "html_url": "https://www.mev.wiki/attack-examples/time-bandit-attack", "body": "Time bandit attack What is a time bandit attack? Time-bandit attacks are attacks where miners rewrite blockchain history to steal funds allocated by smart contracts in the past. If block rewards are small enough compared to MEV, it can be rational for miners to destabilize consensus. Imagine there are two miners, Sam and Dan, who are paid a $100 reward for each block they find. Sam has found 3 blocks, the first of which contained a $10,000 arbitrage opportunity. Now Dan has a choice: he can either mine on top of Sams 3 blocks, or he can attempt to re-mine the first block in order to take the Uniswap arbitrage for himself. The $10,000 is much more lucrative than the $100 block reward, and Dan is more rational than honest, so he decides to re-mine the first block. While Dans at it, since the current longest chain is height 3, he also re-mines the second and third blocks (and captures any MEV that was in those, too). After the re-organization, Dan owns the longest chain and he and Sam can progress from the third block. Previous Liquidations Next Uncle bandit attack Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Uncle bandit attack", "html_url": "https://www.mev.wiki/attack-examples/uncle-bandit-attack", "body": "Uncle bandit attack What is a uncle bandit attack? Bundles are groups of transactions Flashbots users submit. Those transactions must be included in the order submitted, and either the whole bundle is included, or nothing is. A bundle should never be split up. Robert Miller found that for a specific bundle, only the \"Buy\" part of a sandwich bundle submitted had landed on-chain, and right after that Buy someone else had inserted a 7 gas transaction that arbitraged it. How? In Ethereum occasionally two blocks are mined at roughly the same time, and only one block can be added to the chain. The other gets \"uncled\" or orphaned. Anyone can access transactions in an uncled block and some of the transactions may not have ended up in the non-uncled block. In a way some transactions end up in a sort of mempool like state: they are now public as a part of the uncled block and perhaps still valid too. A Sandwicher's bundle was included in an uncled block. An attacker saw this, grabbed only the Buy part of the Sandwich, threw away the rest, and added an arbitrage after. The attacker then submitted that as a bundle, which was then mined. Instead of seeing something late in time and rewinding it (time-bandit attack), the uncle bandit attack is when an attacker sees something in an uncle and brings it forward. This also shows that attacks extend beyond the mempool and into uncled blocks as well.  https://twitter.com/bertcmiller/status/1382673587715342339?s=20  Previous Time bandit attack Next Attempts to trick the bots Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Kattana", "html_url": "https://www.mev.wiki/attempts-to-trick-the-bots/kattana", "body": "Kattana What is Kattana? The Kattana team included a trap for front-running bots during their token listing. There is a line in the code that disallows the front-runner from selling all tokens. So a front-runner paid 68 ETH to the miner and ended up with tokens he wasn't able to sell. Link:   https://twitter.com/SiegeRhino2/status/1381035640989626369?s=20  Previous Salmonella Next Other attempts Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Other attempts", "html_url": "https://www.mev.wiki/attempts-to-trick-the-bots/other-attempts-to-trick-the-bot", "body": "Other attempts What are the other attempts to trick the bot? Link:   https://twitter.com/bertcmiller/status/1381296074086830091?s=20  Background Instead of users paying transaction fees via gas prices, Flashbots users pay fees via a smart contract call which transfers ETH to a miner. Miners receive bundles of transaction from users and include the bundle that pays them the most. Users love this because they only pay for transactions that are included and they can determine the fee that they are going to pay. Sandwich bots watch the mempool for users buying on DEXes and sandwich them: running the price up before the victim buys and dumping after for a profit. Those 3 txs (buy, victim transaction, sell) make up a bundle. Note the Sandwich sell transaction contains the smart contract payment to the miner. It's important that payment goes to the miner on the sell transaction! That should only happen after the bot has secured profit from selling the tokens bought in their front-run. If that sell fails then there is no payment to the miner, and thus their bundle shouldn't be included To be even more secure, bots will simulate their transactions on local infrastructure. Bots won't send transactions unless the simulation goes well. Paying transaction fees only on the sell transaction of a sandwich should defend against this. No profit, no payment. Simulation vs Reality Some really smart people found weaknesses among all of these defenses. The first defense was that simulation was done with an ERC20 transfer function that checked to see if the block was a mined by Flashbots' miners, and if so it transfers way less out. Local simulations look fine but do not work in production. The second defense - Payment only on a sell transaction Again: Sandwich bots make miner payment conditional on profit. That was broken by making the ERC20 token pay the miner. Thus even with the Sandwich bot sell failing, the miner would still get paid! Here's what actually happened: Sandwich bot gets baited and buys 100 ETH of the poisonous token. Poisonous token owner's bait triggers custom transfer function, which pays 0.1 ETH to the miner Sandwich bot's sell doesn't work because of the poisonous token. As the sandwich bot submitted these three transactions in a bundle all three were included: the successful buy, the bait, and the failed sell. The poisonous ERC20's payment via the custom transfer was what incentivized a miner to include it! It is estimated that the first person to do this made about 100 ETH. You can see the poisoned ERC20 Uniswap transactions  here  . From Victim to Predator One of their victims was one the most successful Flashbots bot operators, and they immediately sprung into action. In a short period of time the victim turned into an apex predator. They launched a similar but slightly different ERC20 (YOLOchain), and ended up successfully baiting many more sandwichers. They made 300 ETH doing so! Previous Kattana Next Solutions Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Salmonella", "html_url": "https://www.mev.wiki/attempts-to-trick-the-bots/salmonella", "body": "Salmonella What is Salmonella? Salmonella intentionally exploits the generalised nature of front-running setups. The goal of sandwich trading is to exploit the slippage of unintended victims, so this strategy turns the tables on the exploiters. Its a regular ERC20 token, which behaves exactly like any other ERC20 token in normal use-cases. However, it has some special logic to detect when anyone other than the specified owner is transacting it, and in these situations it only returns 10% of the specified amount - despite emitting event logs which match a trade of the full amount. Link:   https://github.com/Defi-Cartel/salmonella  Previous Attempts to trick the bots Next Kattana Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Front-running as a Service (FaaS) or MEV Auctions (MEVA)", "html_url": "https://www.mev.wiki/solutions/faas-or-meva", "body": "Front-running as a Service (FaaS) or MEV Auctions (MEVA) MEVA and FaaS solutions. In a FaaS or MEVA system, MEV is extracted in a variety of ways such as miners auctioning off the right to front-run users. 'Centralizing MEV extraction is good because it quarantines a revenue stream that could otherwise drive centralization in other sectors.' Vitalik Buterin    'In this article, Im going to go deep into my personal arguments for why extracting MEV in cryptocurrencies isnt like theft, why it is a critical metric for network security in any distributed system secured by economic incentives (yes, including centralized ones), and what we should do about MEV in the next 3-5 years as a community.' Phil Daian, co-author of Flash Boys 2.0     See the various solutions: Private Transactions BackRunMe by bloXroute Flashbots mistX by alchemist KeeperDAO EDEN Network (ArcherSwap) Optimism MiningDAO BackBone Cabal Previous Solutions Next Private Transactions Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "MEV Minimization", "html_url": "https://www.mev.wiki/solutions/mev-minimization", "body": "MEV Minimization MEV minimization and prevention solutions. Here are various solutions in MEV minimization: Conveyor (Automata Network) SecretSwap (Secret Network) Fair sequencing service (Chainlink) Arbitrum (Offchain Labs) Vega protocol CowSwap Veedo (StarkWare) LibSubmarine Sikka Shutter Network                       Previous BackBone Cabal Next Conveyor (Automata Network) Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Other solutions", "html_url": "https://www.mev.wiki/solutions/others", "body": "Other solutions Other ways to tackle MEV. Here are the list of other solutions: B.Protocol  Previous Shutter Network Next B.Protocol Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Arbitrage", "html_url": "https://www.mev.wiki/terms-and-concepts/arbitrage", "body": "Arbitrage What is arbitrage trading? Arbitrage is the simultaneous purchase and sale of the same asset in different markets in order to profit from differences in the asset's listed price. Previous Automated Market Maker Next Lending Platforms Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Automated Market Maker", "html_url": "https://www.mev.wiki/terms-and-concepts/automated-market-maker", "body": "Automated Market Maker What is an AMM? A type of Decentralised Exchange. Contrary to traditional limit order-book-based exchanges (which maintain a list of bids and asks for an asset pair), AMM exchanges maintain a pool of capital (a liquidity pool) with at least two assets. A smart contract governs the rules by which traders can purchase and sell assets from the liquidity pool. The most common AMM mechanism is a constant product AMM, where the product of an asset X and asset Y in a pool have to abide by a constant K. Examples of AMM Exchanges include  Uniswap ,  Sushiswap ,  Balancer . Previous DeFi Next Arbitrage Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "DeFi", "html_url": "https://www.mev.wiki/terms-and-concepts/defi", "body": "DeFi What is DeFi? DeFi is a subset of finance-focused decentralized protocols that operate autonomously on blockchain-based smart contracts. The total value locked in DeFi amounts to >$50B USD  . Link:  https://defipulse.com/    Previous Terms and Concepts Next Automated Market Maker Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Lending Platforms", "html_url": "https://www.mev.wiki/terms-and-concepts/lending-platforms", "body": "Lending Platforms What is a decentralised lending platform? Debt is an essential tool in DeFi. As DeFi applications typically operate without Know Your Customer (KYC), the borrowers debt must be over-collateralized. Hence, a borrower must collateralize (lock) 150% of the value that the borrower wishes to lend out. The collateral acts as a security to the lender if the borrower doesnt pay back the debt. Examples of lending platforms include  Aave  and  Compound . Previous Arbitrage Next Slippage Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Liquidations", "html_url": "https://www.mev.wiki/terms-and-concepts/liquidations", "body": "Liquidations What are liquidations in collaterized debt? In Lending Platforms, if the collateral value decreases and the collateralization ratio falls below 150%, the collateral can be freed up for liquidation. Liquidators can then purchase the collateral at a discount to repay the debt. Previous Slippage Next Priority Gas Auctions Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Priority Gas Auctions", "html_url": "https://www.mev.wiki/terms-and-concepts/priority-gas-auctions", "body": "Priority Gas Auctions What is a priority gas auction? As pure arbitrage opportunities offer unconditional revenue, bots often compete against each other by bidding up transaction fees (gas) in PGAs which drives up fees for other users. Previous Liquidations Next Transaction Ordering Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Slippage", "html_url": "https://www.mev.wiki/terms-and-concepts/slippage", "body": "Slippage What is price slippage? Slippage is defined as the move in the price of a security between the time you decided to transact in it and the time your order was in the market. When performing a trade on an AMM, the expected execution price may differ from the real execution price because the expected price depends on a past blockchain state, which may change between the transaction creation and its execution  e.g., due to front-running transactions. Previous Lending Platforms Next Liquidations Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Transaction Ordering", "html_url": "https://www.mev.wiki/terms-and-concepts/transaction-ordering", "body": "Transaction Ordering What is transaction ordering? Blockchains typically prescribe specific rules for consensus, but there are only loose requirements for miners on how to order transactions within a block. Many attacks are centered around how miners order transactions within blocks. Previous Priority Gas Auctions Next Attack Examples Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "EDEN Network (ArcherSwap)", "html_url": "https://www.mev.wiki/solutions/faas-or-meva/archerswap", "body": "EDEN Network (ArcherSwap)  Eden Network (Previously ArcherSwap) Eden Network is a new DEX extension for Uniswap and Sushiswap that prevents frontrunning and offers traders zero slippage and zero cost cancellation swaps. This enables users to set slippage tolerance to 0%. Miners will only be paid if \"acceptance criteria\" are met, so any transaction that fails is not included on chain. One is for searchers to submit Flashbots-compatible bundles. The other is the Archer Relay Network (powers Archerswap) where users can submit private transactions and be protected from malicious MEV. Link:   https://swap.archerdao.io/#/swap   Previous KeeperDAO Next Optimism Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "BackBone Cabal", "html_url": "https://www.mev.wiki/solutions/faas-or-meva/backbone-cabal", "body": "BackBone Cabal  BackBone Cabal BackBone Cabal is a strategy that aims to extract MEV from SushiSwap. Profits are redistributed back to users who submitted trades in the first place in the form of eliminating their transaction cost (up to 90%). YCabal creates a virtualized mempool (i.e. a MEV-relay network) that aggregates transactions (batching). Users are able to opt in and send transactions to YCabal and in return for not having to pay for gas for their transaction, YCabal batch processes it and takes the arbitrage profit. Risk by inventory price risk is carried by a Vault, where Vault depositers are returned the profit the YCabal realizes. Links: Website:  https://backbonecabal.com/  Knowledge Base:  https://backbone-kb.netlify.app/  SushiSwap Proposal:  https://forum.sushiswapclassic.org/t/proposal-ycabal-mev-strategy/3159  Previous MiningDAO Next MEV Minimization Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "BackRunMe by bloXroute", "html_url": "https://www.mev.wiki/solutions/faas-or-meva/backrunme-by-bloxroute", "body": "BackRunMe by bloXroute   BackRunMe by bloXroute BackRunMe is a service that allows users to submit private transactions (e.g. protection against frontrunning and sandwich attacks) while allowing searchers to backrun the transaction via MEV IF it produces an arbitrage profit. If it doesn't generate an arbitrage profit it is processed as a regular private transaction. BackRunMe, gives a portion of this additional profit back to the user. How BackRunMe works. The profit sharing ratio is as follows: 50% to miners, 25% to users, 20%to searchers and 5% to bloXroute. Users can use MetaMask directly on BackRunMe to trade on Uniswap or Sushiswap. Links:  https://backrunme.com/#/swap   https://medium.com/bloxroute/there-is-light-in-the-dark-forest-2d7b77f4ca2d  Previous Private Transactions Next Flashbots Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Flashbots", "html_url": "https://www.mev.wiki/solutions/faas-or-meva/flashbots", "body": "Flashbots  Flashbots Flashbots is a research and development organization formed to mitigate the negative externalities and existential risks posed by MEV. They aim to Democratize MEV Extraction through MEV-Geth, which enables a sealed-bid block space auction mechanism for communicating transaction order preference. ELI5 Link:  https://twitter.com/_silto_/status/1381292907567722498  Flashbots created an ETH node for miners, that not only watches the mempool like any other node, but also connects to a relayer (a server) operated by Flashbots. This MEV-Relay is a kind of parallel channel that directly connects miners to bots that want their transactions included. The transactions that the bots want to include are sent through the MEV-Relay as bundles containing: the transactions to execute a tip to the miner, coming as an ETH transfer These transactions use a 0 gwei gas price, as the payment to the miner is included in the transaction itself as the tip. Since these transactions are sent through a parallel private relay, it reduces the mempool bidding war, failed transactions bloating the blockchain, and overall gas cost for users. Links: GitHub:  https://github.com/flashbots  Research:  https://github.com/flashbots/mev-research  Monthly Meetings:  https://github.com/flashbots/pm  API:  https://blocks.flashbots.net/  Discord:  https://discord.gg/7hvTycdNcK  Medium:  https://medium.com/flashbots   https://medium.com/flashbots/frontrunning-the-mev-crisis-40629a613752   https://medium.com/flashbots/quantifying-mev-introducing-mev-explore-v0-5ccbee0f6d02   https://ethresear.ch/t/flashbots-frontrunning-the-mev-crisis/8251  Previous BackRunMe by bloXroute Next mistX by alchemist Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "KeeperDAO", "html_url": "https://www.mev.wiki/solutions/faas-or-meva/keeperdao", "body": "KeeperDAO  KeeperDAO KeeperDAO is similar to a mining pool for Keepers. By incentivizing a game theory optimal strategy for cooperation among on-chain arbitrageurs, KeeperDAO provides an efficient mechanism for large scale arbitrage and liquidation trades on all DeFi protocols. The Hiding Game One of the 3 games that has been built. The Hiding Game refers to the cooperation between users and keepers to hide MEV by wrapping trades/debt in specialised on-chain contracts. These contracts restrict profit extracting opportunities to KeeperDAO itself. Here's the ELI5 Users route their trades and loans through KeeperDAO, which attempts to extract any arbitrage or liquidation profit available. Those profits are returned back to the user in $ROOK tokens, and profits go into a pool controlled by $ROOK holders. By giving KeeperDAO priority access to arbitrage and liquidations, the Hiding Game maximizes the profits available from these opportunities. kCompound (Phase 2 of the Hiding Game) kCompound is the second phase of the Hiding Game. KeeperDAO posts collateral to save your position from being publicly liquidated. Instead, you get privately liquidated. KeeperDAO keeper will then find the best price for your collateral, targeting a 5% profit margin. This profit will then be split between you, the keeper, and the KeeperDAO treasury, meaning that kCompound borrowers will receive a portion of the profits from their own liquidation. Links: Website:  https://keeperdao.com/#/  Wiki:  https://github.com/keeperdao/docs/wiki  kCompound:  https://medium.com/keeperdao/introducing-kcompound-a23511c847a0  Previous mistX by alchemist Next EDEN Network (ArcherSwap) Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "MiningDAO", "html_url": "https://www.mev.wiki/solutions/faas-or-meva/miningdao", "body": "MiningDAO  MiningDAO MiningDAO is building a decentralized and transparent protocol for block formation that aims to pass 100% of MEV to miners. Anyone with an Ethereum address can propose the next block to be mined (via a block sealhash), and attach a bounty for successfully mining it. The mining pools would then mine on the highest-bounty proposal. One is for searchers to submit Flashbots-compatible bundles. The other is the Archer Relay Network (powers Archerswap) where users can submit private transactions and be protected from malicious MEV. Links: Website:  https://miningdao.io  Medium:  https://medium.com/mining-dao/introducing-miningdao-1e469626f7ad  Previous Optimism Next BackBone Cabal Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "mistX by alchemist", "html_url": "https://www.mev.wiki/solutions/faas-or-meva/mistx-by-alchemist", "body": "mistX by alchemist  MistX by alchemist mistX is a DEX that enables end users to send transactions through Flashbots bundles. All transactions are gasless. However, instead of paying gas to the miners mistX users pay miners a bribe/tip in ETH. The tip is either included in the trade or comes from the user's wallet. The exchange utilises Flashbots and as such transactions processed via mistX do not publish user transaction information to a public mempool, but instead bundle transactions together. This hides the information from front-runners and thus prevents transactions from being manipulated, front-run, or sandwiched. Link:   https://app.mistx.io/#/exchange  Previous Flashbots Next KeeperDAO Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Optimism", "html_url": "https://www.mev.wiki/solutions/faas-or-meva/optimism", "body": "Optimism  Optimism Optimism are the original proposers of MEVA. MEV Auction (MEVA) is created in which the winner of the auction has the right to reorder submitted transactions and insert their own, as long as they do not delay any specific transaction by more than N blocks. MEVA on Ethereum Implementing the Auction The auction is able to extract MEV from miners by separating two functions 1) Transaction inclusion; and 2) transaction ordering. In order to implement MEVA roles are defined.  Block producers  determine transaction inclusion, and  Sequencers  determine transaction ordering. Block producers - Transaction Inclusion Block proposers are most analogous to traditional blockchain miners. Instead of proposing blocks with an ordering, they simply propose a set of transactions to eventually be included before N blocks. Sequencers - Transaction Ordering Sequencers are elected by a smart contract managed auction run by the block producers called the MEVA contract. This auction assigns the right to sequence the last N transactions. If, within a timeout the sequencer has not submitted an ordering which is included by block proposers, a new sequencer is elected. Implementation on Layer 2 It is possible to enshrine this MEVA contract directly on layer 1 (L1) blockchain consensus protocols. However, it is also possible to non-invasively add this mechanism in layer 2 (L2) and use it to manage Optimistic Rollup transactio ordering. In L2, L1 miners are repurposed and utilized as block proposers. MEVA contract is implemented and designated a single sequencer at a time. Links:  https://optimism.io/   https://ethresear.ch/t/mev-auction-auctioning-transaction-ordering-rights-as-a-solution-to-miner-extractable-value/6788   https://docs.google.com/presentation/d/1RaF1byflrLF3yUjd-5vXDZB1ZIRofVeK3JYVD6NPr30/edit#slide=id.gc9bdacc472_0_96  Previous EDEN Network (ArcherSwap) Next MiningDAO Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Private Transactions", "html_url": "https://www.mev.wiki/solutions/faas-or-meva/private-transactions", "body": "Private Transactions  Private Transactions Typically, transactions are broadcast to the mempool where they remain pending until miners pick them and add to the block. Private transactions however, are only visible to the pool and are not broadcast to other nodes (pay more for faster transactions). Examples include  1inch Exchange's Stealth Transactions ,  Taichi Network  and  BloXroute . Taichi Network allows users to send private transactions directly to  Sparkpool,  bypassing the public  mempool. Private Transactions offered by Taichi Network  bloXroute Labs  has a wide range of offerings and their core competency is low global latency for DeFi (8% of blocks mined within 1 sec). For the other side of the coin, here is bloXroute Labs' take on why private mempools are not necessarily bad  : 1. Front-runners don't need these services to outpace regular users, who are slower by seconds. They need it to outpace one another, where improving speed 0.8->0.15 sec matters. 2. When a transaction is privately sent to pools other frontrunners can't attempt to front-run it. This helps avoid fierce escalation of fees. Link:   https://docs.bloxroute.com/apis/frontrunning-protection    Previous Front-running as a Service (FaaS) or MEV Auctions (MEVA) Next BackRunMe by bloXroute Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Arbitrum (Offchain Labs)", "html_url": "https://www.mev.wiki/solutions/mev-minimization/arbitrum-offchain-labs", "body": "Arbitrum (Offchain Labs)  Arbitrum by Offchain Labs Arbitrum is against MEVA and FaaS. 3 Modes of Arbitrum: 1. Single Sequencer: L2 MEV-Potential ( Mainnet Beta ) For Arbitrums initial, flagship Mainnet beta release, the Sequencer will be controlled by a single entity. This entity has transaction ordering rights within the narrow / 15 minute window; users are trusting the Sequencer not to frontrun them. 2. Distributed Sequencer With Fair Ordering: L2-MEV-minimized ( Mainnet Final Form ) The Arbitrum flagship chain will eventually have a distributed set of independent parties controlling the Sequencer. They will collectively propose state updates via  the first BFT algorithm that enforces fair ordering within consensus (Aequitas) . Here, L2 MEV is only possible if >1/3 of the sequencing-parties maliciously collude, hence MEV-minimized. 3. No Sequencer: No L2 MEV A chain can be created in which no permissioned entities have Sequencing rights. Ordering is determined entirely by the Inbox contract; lose the ability to get lower latency than L1, but gain is that no party involved in L2, including Arbitrum validators, has any say in transaction ordering, and thus no L2 MEV enters the picture. Links: Website:  https://offchainlabs.com/  Medium:  https://medium.com/offchainlabs/front-running-as-a-service-334c929c945  Document:  https://docs.google.com/document/d/1VOACGgTR84XWm5lH5Bki2nBcImi3lVRe2tYxf5F6XbA/edit  Previous Fair sequencing service (Chainlink) Next Vega protocol Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Conveyor (Automata Network)", "html_url": "https://www.mev.wiki/solutions/mev-minimization/conveyor-automata-network", "body": "Conveyor (Automata Network)  Conveyor - The Automata Network approach to tackling MEV At Automata, we have created  Conveyor , a service that ingests and outputs transactions in a determined order. This creates a front-running-free zone that removes the chaos of transaction reordering. When transactions are fed into Conveyor, it determines the order of the incoming transactions and makes it impossible for block producers to perform the following: 1. Inject new transactions into the Conveyor output: The inserted transactions bypassing Conveyor is detectable by anyone because of signature mismatch. 2. Delete ordered transactions: Transactions accepted by Conveyor are broadcasted everywhere so transactions cannot be deleted unless ALL block producers are colluding and censoring the transactions at the same time. From the DEXs perspective, they can choose to accept either 1. Ordered transactions from Automatas Conveyor which is free from transaction reordering and other front-running transactions 2. Other unordered transactions (which include front-running etc) that may negatively impact their users Why should users trust Conveyor? Automatas Conveyor runs on a decentralized compute plane backed by many Geode instances. Each Geode instance can be attested so anyone can publicly verify that the Geode is running on a system with genuine hardware (i.e., CPU) and that the Geode application code matches the version that is open-sourced and audited. This provides a strong guarantee that: The Geode code is untampered with The Geode data is inaccessible to even Geode providers (In which case they cannot act on said data to front-run transactions) Importantly, Automatas Conveyor is a chain-agnostic solution to the MEV issue, and works seamlessly on various platforms  zero modifications needed. An industry-first: Oblivious RAM In fully public computation, access pattern leakage is not negligible as everything is exposed. But in privacy-preserving computation, any tiny bit of information leakage becomes a significant issue. Studies have shown that access pattern leakage leads to exposure of sensitive information such as private keys from searchable encryption and trusted computing. This is where the Oblivious RAM algorithm comes into play. Automatas implementation is the first-of-its-kind in the blockchain industry, providing an exceedingly high degree of privacy in dApps. This greatly reduces the probability of user privacy being leaked even as access patterns are being monitored and analyzed by malicious actors. The Automata team has authored multiple research papers on state-of-the-art ORAM and hardware technologies to enhance the privacy and performance of existing networks. Robust P2P Primitives Using SGX Enclaves  RAID 2020  PRO-ORAM: Practical Read-Only Oblivious RAM  RAID 2019  OblivP2P: An Oblivious Peer-to-Peer Content Sharing System  USENIX Security 2016  Preventing Page Faults from Telling Your Secrets  Asia CCS 2016   Official Links  Website:  https://ata.network/   Whitepaper:  https://xata.to/lightpaper   GitHub:  https://xata.to/github   Documentation:  https://docs.ata.network/   Ambassador program form:  https://xata.to/ambassadors   FAQ:  https://xata.to/faq   Official Socials   Telegram Annoucement Channel:  https://t.me/ata_announcement   Telegram Chat Group:  https://xata.to/telegram   Twitter:  https://xata.to/twitter   Discord:  https://xata.to/discord   Medium:  https://xata.to/medium   Community Links   Korea (Telegram):  https://t.me/atanetworkkorea  Spain (Telegram):  https://t.me/atanetworkspanish  Sri Lanka (Telegram):  https://t.me/atanetworksinhala  Russian (Telegram):  https://t.me/atanetworkrussia  Malay-Indonesian (Telegram):  https://t.me/atanetworkmalaysia   Other useful links  MEV Checkup Tool:  https://mev.tax/   Coinmarketcap article:  https://xata.to/vxa   Binance research report:  https://xata.to/br   Binance launchpool annoucement:  https://xata.to/186e34  Previous MEV Minimization Next SecretSwap (Secret Network) Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "CowSwap", "html_url": "https://www.mev.wiki/solutions/mev-minimization/cowswap", "body": "CowSwap  CowSwap A collaboration between BalancerLabs and Gnosis, CowSwap is a DEX that leverages batch auctions to provide MEV protection, plus integrate with liquidity sources across DEXs to offer traders the best prices. When two traders each hold an asset the other wants, an order can be settled directly between them without an external market maker or liquidity provider. Any excess is settled in the same transaction with the best available AMM. The transaction is sent by professional solvers which set tight slippage bounds. Solvers compete with each other to achieve best prices for the user. Links: Website:  https://cowswap.exchange/#/swap  Blog:  https://blog.gnosis.pm/introducing-gnosis-protocol-v2-and-balancer-gnosis-protocol-f693b2938ae4   Previous Vega protocol Next Veedo (StarkWare) Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Fair sequencing service (Chainlink)", "html_url": "https://www.mev.wiki/solutions/mev-minimization/fair-sequencing-service-chainlink", "body": "Fair sequencing service (Chainlink)  The Fair Sequencing Service by ChainLink The idea behind FSS is to have an oracle network order the transactions sent to a particular contract SC, including both user transactions and oracle reports. Oracle nodes ingest transactions and then reach consensus on their ordering, rather than allowing a single leader to dictate it. FSS is a framework for implementing ordering policies, of which  Aequitas  (protocol for order-fairness in addition to consistency and liveness) is one example. It can alternatively support simpler approaches, such as straightforward encryption of transactions, which can then be decrypted in a threshold manner by oracle nodes after ordering. It will also support various policies for inserting oracle reports into a stream of transactions. (It can even support MEV auctions, if desired.) Links: Blog post:  https://blog.chain.link/chainlink-fair-sequencing-services-enabling-a-provably-fair-defi-ecosystem/  Whitepaper (to be released later)  Previous SecretSwap (Secret Network) Next Arbitrum (Offchain Labs) Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "LibSubmarine", "html_url": "https://www.mev.wiki/solutions/mev-minimization/libsubmarine", "body": "LibSubmarine  LibSubmarine LibSubmarine is an open-source smart contract library that protects your contract against front-runners by temporarily hiding transactions on-chain. Links: Website:  https://libsubmarine.org/  Video:  https://www.youtube.com/watch?v=N8PDKoptmPs&feature=emb_imp_woyt&ab_channel=IC3InitiativeforCryptocurrenciesandContracts  GitHub:  https://github.com/lorenzb/libsubmarine  Previous Veedo (StarkWare) Next Sikka Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "SecretSwap (Secret Network)", "html_url": "https://www.mev.wiki/solutions/mev-minimization/secretswap-secret-network", "body": "SecretSwap (Secret Network)  Secret Swap Secret Swap is an automated market maker (AMM) liquidity protocol. There is no orderbook, no centralized party, and no central facilitator of trade. Using Secret Contracts, the mempool of potential Secret Swap transactions are kept entirely encrypted - protecting users from MEV, front-running attacks and providing an increased level of privacy compared to traditional AMMs. The protocol uses swap secret contract based tokens (SNIP-20s) on Secret Network. Given the encrypted nature of SNIP-20s secret contracts, inputs to a transaction/contract are encrypted while they are on the mempool and cannot be front-run by any adversary. Users will have to pay for gas and 0.3% swap fees with the $SCRT token to use Secret Swap. Links: Website:  https://www.secretswap.io  Analytics:  http://secretanalytics.xyz  Documentation:  https://docs.secretswap.io/secretswap  Previous Conveyor (Automata Network) Next Fair sequencing service (Chainlink) Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Shutter Network", "html_url": "https://www.mev.wiki/solutions/mev-minimization/shutter-network", "body": "Shutter Network  Shutter Network Shutter Network is an open-source project that aims to prevent frontrunning and malicious MEV on Ethereum by using a threshold cryptography-based distributed key generation (DKG) protocol. A Shutter transaction is a transaction protected from frontrunning in the target smart contract system. It therefore passes through a sequence of stages before it is executed. A Shutter transaction flow: 1. Created and encrypted in the user's wallet; 2. Sent to the batcher contract as a standard Ethereum transaction; 3. Picked up and decrypted by the keypers; 4. Sent to the executor contract, and 5. Forwarded to the target contract. Links: Website:  https://shutter.ghost.io/  GitHub:  https://github.com/brainbot-com/shutter  Previous Sikka Next Other solutions Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Sikka", "html_url": "https://www.mev.wiki/solutions/mev-minimization/sikka", "body": "Sikka  Sikka Sikka's MEV solution to censorship and frontrunning problems is using a technique called Threshold Decryption, as a plugin to the Tendermint Core BFT consensus engine to create mempool level privacy. With this plugin, users are able to submit encrypted transactions to the blockchain, which are only decrypted and executed after being committed to a block by a quorum of 2/3 validators. Links: Website:  https://sikka.tech/  Presentation:  https://docs.google.com/presentation/d/1tQEUpZjy_U9J-VQAx1Wf5W9oOX5rrCY3AwjAb7ZgA68/edit#slide=id.p  Previous LibSubmarine Next Shutter Network Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Veedo (StarkWare)", "html_url": "https://www.mev.wiki/solutions/mev-minimization/veedo-starkware", "body": "Veedo (StarkWare)  Veedo by StarkWare VeeDo is StarkWares STARK-based Verifiable Delay Function (VDF), and its PoC is now live on Mainnet. VeeDo's time-locks allow information to be sealed for a predetermined period of time (during the sequencing phase), and then made public. 2 approaches using privacy to minimize MEV 1. Time-locks as part of the protocol layer 2. Time-locks on Ethereum with smart contracts - supported today Links: Website:  https://starkware.co/  Medium:  https://medium.com/starkware/presenting-veedo-e4bbff77c7ae  Presentation:  https://docs.google.com/presentation/d/1C_Rb_rtUXT2Nkettu_GPSlD9yCge8ioBNLRj5OBNbyY/edit#slide=id.gb576f94980_0_836   Previous CowSwap Next LibSubmarine Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Vega protocol", "html_url": "https://www.mev.wiki/solutions/mev-minimization/vega-protocol", "body": "Vega protocol  Vega Protocol Traditionally, fairness in a blockchain has been defined in absolute terms, i.e. once a transaction is seen by a sufficient number of validators, it will be executed in some block, soon. Vega's proposal is to add a module to blockchains that supports the concept of relative fairness so that competing transactions may be sequenced under a known and understood protocol, and not subject to a validators discretion. \" If there is a time t such that all honest validators saw a before t and b after t, then a must be scheduled before b.  This is a property that can be assured of at any time with a minimal impact on performance. To get the best combination, their current approach is a hybrid of the two. In normal operation, the protocol will assure block fairness. If the network detects that this causes a bottleneck, it temporarily switches to the timed approach (thus sacrificing a little fairness for performance), before switching back once the bottleneck is resolved. However, Vega will ultimately make the level of fairness customisable by market. Links: Website:  https://vega.xyz/  Blog:  https://blog.vega.xyz/new-paper-fairness-and-front-running-an-invitation-for-feedback-cbb39a1a3eb  Wendy, the Good Little Fairness Widget:  https://vega.xyz/papers/fairness.pdf  Video:  https://www.youtube.com/watch?v=KjfLj5fhkGQ&t=18s&ab_channel=VegaProtocol  Previous Arbitrum (Offchain Labs) Next CowSwap Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "B.Protocol", "html_url": "https://www.mev.wiki/solutions/others/b.protocol", "body": "B.Protocol   B.Protocol B.Protocol aims to shift MEV to users. Users interact with existing lending platforms via B.Protocol smart contract. Liquidity providers (LP) provide a cushion to user debt, which gives B.Protocol precedence over other liquidators. LPs share their profits with the users, where user reward is proportional to his user rating. Links: Website:  https://www.bprotocol.org/  Presentation:  https://docs.google.com/presentation/d/13UNysGCX9ZJG20lKaxr_qbhgKwcuHACdwlhGNKtzGt4/edit   Previous Other solutions Next Miscellaneous Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Overview", "html_url": "https://kb.beaconcha.in/", "body": "Overview  Next Glossary Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Attestation", "html_url": "https://kb.beaconcha.in/attestation", "body": "Attestation An overview of attestations Attestation  Every  Epoch  (~6.4 minutes) a validator proposes an attestation (vote) to the network. This vote consists of the following segments:  Committee   Validator Index  Finality vote Signature Chain head vote (vote on what the validator believes is the head of the chain)  A minimum of 16,384 validators is required to start Ethereum 2.0.  If we multiply that with the information included in each Attestation per Epoch, it adds up quickly. Therefore, Ethereum 2.0  aggregates  all of that information and minimises the data growth.   Aggregated Attestation An  aggregation  is a collection, or the gathering of things together. Your baseball card collection might represent the aggregation of lots of different types of cards. So what does that mean for Attestations?  Each block one or more committees are chosen to attest. A committee has a minimum of 128 validators, of which 16 are randomly selected to become an aggregator. As shown below, the validators broadcast their unaggregated attestation to the aggregators (red arrow). The aggregators then merge the attestations and forward a single aggregated attestation to the  block proposer .  Attestation Inclusion Lifecycle   1. Generation 2. Propagation 3. Aggregation 4. Propagation 5. Inclusion   Rewards The attestation reward is dependent on two variables, the  base reward  and the  inclusion delay. The best case for the inclusion delay is to be 1. Source: ConsenSys Codefi Analysis Base reward ( Validator effective balance * 2**6 )   / SQRT( Effective balance of  all  active validators )   Inclusion delay At the time when the validators voted on the head of the chain (Block 0),  Block 1  was not proposed yet. Therefore attestations naturally get included  one block  later; so all attestations who voted on  Block 0  being the chain head got included in  Block 1  and, the  inclusion delay  is 1.  The effects of the inclusion delay on the attestation reward  As shown below, an Inclusion delay of 2 causes the the reward to drop by 50%.  Source: Consensys  A ttestation scenarios  Missing Voting Validator These validators have a maximum of 1 epoch to submit their attestation. If the attestation was missed in epoch 0, they can submit it with an inclusion delay in epoch 1.  Missing Aggregator There are 16 Aggregators per epoch in total, additionally, random validators from the beacon-chain subscribe to  two subnets for 256 Epochs  and serve as a backup in case aggregators are missing. Missing block proposer Note that in some cases a lucky aggregator may also become the block proposer. If the attestation was not included because the block proposer has gone missing, the next block proposer would pick the aggregated attestation up and include it into the next block. However, the  inclusion delay  will increase by one.   Credits  Attestation effectiveness  -  AttestantIO   Attestation Inclusion  -  Adrian Sutton  (Consensys)   Previous Deposit Process Next Rewards and Penalties Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Ethereum 2.0 Keys", "html_url": "https://kb.beaconcha.in/ethereum-2-keys", "body": "Ethereum 2.0 Keys Extended overview of Ethereum 2.0 Keys Ethereum 2.0 Key overview General Both of these keys (ETH 1.0 and ETH 2.0) are based on the same idea and use  elliptic-curve cryptography  to create keys. However, Ethereum 2.0 has additional functionality, and its keys require different parameters when creating them, and use the  B oneh- L ynn- S hacham  (= BLS ) signature scheme. Ethereum 2 Keys Compared to Ethereum 1.0, where users only have a  single private  key to access their funds, Ethereum 2.0 offers two different keys. The  validator   private  key and the  withdrawal   private  key. The validator key As seen in the cutout below the validator signing key consists of two elements: Validator  private  key Validator  public  key The purpose of the  validator private key  is to  actively  sign on-chain (ETH2) operations such as block proposals and attestations. Therefore these keys have to be held in a hot wallet. This flexibility has the advantage to move validator signing keys very quickly from one device to another, however, if they have gotten lost or stolen, the thief has the ability to  act maliciously  in two ways: Get the validator  slashed  by: Being a  proposer  and sign two different beacon blocks for the same slot Being an  attester  and sign an attestation that \"surrounds\" another one. Being an  attester  and sign two different attestations having the same target.  Force a  voluntary exit , which stops the validator from \"staking\", and grants access to its ETH balance to the withdrawal key owner. The  validator public key  is included in the  deposit data  which allows ETH2 to identify the validator. The withdrawal key The withdrawal key is required to move the validator balance once it is possible in  Phase1/2 . Just like the validator keys, the withdrawal keys also consist of two components: Withdrawal  private  key Withdrawal  public  key Losing this key means losing access to the validator balance. However, the validator can still sign attestations and blocks since these actions require the validator private key, but there is little to no incentive to do so if the keys are lost. To withdraw, the validator status needs to be \" exited \". Multiple validators from a single wallet Each validator has their own  unique deposit data  by which they are identified by the  beaconchain .  Four keys  for  one validator . Q:  How can I re-deposit to my validator balance? (e.g.  Effective balance  has dropped) A:  Send another transaction (>=1ETH) to the  deposit contract  with the  validator specific  deposit data   as the transaction input. After the first deposit-transaction, the  unique deposit data  is stored on the blockchain and can be found on various explorers. Note:  The deposit contract requires about  150,000 gas   limit. Mnemonics for ETH2.0 validators Over the last few years, we have become so accustomed to the  12 or 24 word-system . Why do we take steps back again and make our lives more complicated and more insecure with locally stored keys? Known hardware wallets will not be able to support ETH2.0 key generation until the BLS library gets audited.  EIP-2333  and  EIP-2334  offer a solution but yet need to be implemented. With all this knowledge, we can assume that the known  Mnemonics  will not be accessible from day one of Phase 0. How does it work?  Mnemonics  and paths are a known feature and usually found when  users try to access  their hardware wallets. \"Old ETH 1.0\" path structure and example: m/44'/60'/0'/0  m / purpose' / coin_type' / account' / change / address_index  The same logic applies to ETH2.0 Keys, just with  different  parameters.  There is a single \"master key\"  (=Mnemonic phrase) which allows the user to attach as many validators to a single  withdrawal key  as they want. This way the user can  derive all keys  from the Mnemonic phrase. A simplified overview would look like the following:  Source: Carl Beekhuizen  Credits:  Nishant Das  for fact-checking Previous Port Forwarding Next The Genesis Event Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Deposit Process", "html_url": "https://kb.beaconcha.in/ethereum-2.0-depositing", "body": "Deposit Process This post will explain the depositing process and each of the phases. Before we start, to understand the basic idea of how Ethereum 2.0 keys work, the  Ethereum 2.0 Keys  blog is highly recommended. The deposit contract Let's go through each of the  states  above and explain how their  durations  are approximately determined. 1. Mempool - Status: Unknown Every signed transaction visits the  Mempool  first, which can be referred to as the waiting room for transactions. During this period, the  transaction status  is  pending . Depending on the chosen  gas fee  for the transaction, miners pick the ones that return them the most value first. If the network is highly congested (=many pending transactions), there's a high chance that new transactions will outbid(gas fees) older transactions, leading to  unknown  waiting times. 2. Deposit contract - Status: Deposited Once the transaction reaches the  deposit contract,  the deposit contract checks the transaction for its  Input data  and  value.  If the  threshold  of 1 ETH is not met or the transaction has  no/invalid  input data, the transaction will get  rejected  and returned to the sender. The user-created  input data  is a reflection of the upcoming  validator and withdrawal keys  on the Ethereum 2.0 network as seen in the picture below. The full Ethereum 2.0 keys blog is  here . Why exactly does this take at least 13.6 hours? The Ethereum 2.0 chain only considers transactions which have been in the deposit contract for at least 2048 Ethereum 1.0 blocks to ensure they never end up in a  reorged  block.  (= ETH1_FOLLOW_DISTANCE ) In addition to the 2048 Ethereum 1.0 blocks, 64  Ethereum 2.0   Epochs  ****must be**** awaited before the beacon-chain recognises the deposit. During these 64 Epochs, validators vote on newly received deposits. However,  missed block  proposals or bad Ethereum 1.0 nodes, which provide the deposit logs to the Ethereum 2.0 network can cause longer waiting times. Therefore, run your  own node ! 2048 blocks  = 2048 x 12 seconds = 24,576 seconds = 409.6 minutes =  ~6.82 hours   64 Epochs  = 64 x 6.4 minutes = 409.6 minutes =  ~6.82 hours Once the deposit is in the deposit contract, the state of the validator will switch to  Deposited  on the  beaconcha.in  explorer. Rejected Deposit Rejected Transaction 3. Validator Queue - Status: Pending The deposit is accessible now for the beacon-chain. Depending on the amount of total deposits, the validators have to wait in a queue. Eight validators per  Epoch  ( 1800 validators per day)  can get activated. 4. Staking - Status: Active The validator is now actively staking. It is proposing blocks and signing attestations - ready to earn ETH! Other validator status Deposit Invalid The transaction had an invalid  BLS  signature. Active Offline An active validator has not been attesting for at least two epochs. Exiting Online The validator  is online  and currently exiting the network because either its  balance dropped below 16ETH (forced exit)  or the  exit was requested   (voluntary exit)  by the validator. Exiting Offline The validator  is offline  and currently exiting the network because either its  balance dropped below 16ETH  or the  exit was requested  by the validator. Slashing Online The validator  is online  but was malicious and therefore forced to  exit  the network. Slashing Offline The validator  is offline  and was malicious and which lead to a forced to exit out of the network. The validator is currently in the exiting queue with a minimum of 25 minutes. Slashed The validator has been kicked out of the network. The funds will be withdrawable after 36 days. Exited The validator has exited the network. The funds will be withdrawable after 1 day. Previous The Genesis Event Next Attestation Last modified  4mo ago", "labels": ["Documentation"]}, {"title": "Glossary", "html_url": "https://kb.beaconcha.in/glossary", "body": "Glossary Beacon-chain It introduces Proof of stake to Ethereum1 and runs along it. Its also called the coordination layer. Roles : Assign validators their duties Finalize checkpoints Perform a protocol level random number generation (RNG) Progress the beacon chain Vote on the head of the chain for the fork choice  source  Slots 32 Slots = 1 Epoch  A time period of  12 seconds  in which a randomly chosen validator has time to propose a block. Each slot may or may not have a block in it. The total number of validators is split up in committees and one or more individual committees are responsible to attest to each slot. One validator from the committee will be chosen to be the aggregator, while the other 127 validators are attesting. After each Epoch, the validators are mixed and merged to new committees. There is a minimum of 128 validators per committee.  image source  Epoch 1 Epoch = 32 Slots  Represents the number of 32 slots and takes approximately  6.4 minutes.  Epochs play an important role when it comes to the  validator queue  and  finality . Deposit contract The Deposit contract is the  gateway  to Ethereum 2.0  through a smart contract  on Ethereum 1.0. The smart contract accepts any transaction with a minimum amount of 1 ETH and a valid input data. Ethereum 2.0 beacon-nodes listen to the deposit contract and use the input data to credit each validator.  More infos the Deposit Contract  Input Data The Input data, also called the  deposit data , is a user generated, 842 long sequence of characters. It represents the  validator public key and the withdrawal public key , which were signed with by the validator private key. The input data needs to be added to the transaction to the  deposit contract  in order to get identified by the  beacon-chain .  More infos about the Deposit process.  Validator Validators need to deposit 32 ETH into the validator deposit contract on the Ethereum 1.0 chain. Validator operators have to run a validator node. Its job is to propose blocks and sign attestations. A validator has to be online for at least 50% of the time in order to have positive returns. Eligible for activation & Estimated activation Refers to pending validators. The deposit has been recognized by the ETH2 chain at the timestamp of Eligible for activation. If there is a queue of  pending validators , an estimated timestamp for activation is calculated. Unique Index Every validator receives its unique index.  beaconcha.in .  Current Balance & Effective Balance The current balance is the amount of ETH held by the validator as of now. The  effective Balance  represents a value calculated by the current balance. It is used to determine the size of a reward or penalty a validator receives. The effective balance can **never be higher than 32 ETH. In order to increase the effective balance, the validator requires effective balance + 1.25 ETH.** In other words, if the effective balance is 20 ETH, a current balance of 21.25 ETH is required in order to have an effective balance of 21 ETH. The effective balance  will adjust once it drops by 0.25  below the threshold as seen in the examples above. Here are examples on how the effective balance changes If the Current balance is 32.00 ETH  the Effective balance is 32.00 ETH If the Current balance dropped from 22 ETH to 21.76 ETH  Effective balance will be  22.00 ETH If the Current balance increases to 22.25  and  the effective balance is 21 ETH, the effective balance will increase to 22 ETH Slasher The  slasher   is its own entity  but requires a beacon-node to receive  attestations . To find malicious activity by validators, the slashers iterates through all received attestations until a  slashable offense  has been found. Found slashings are broadcasted to the network and the next  block proposer  adds the proof to the block. The block proposer receives a reward for slashing the malicious validator. However, the whistleblower (=Slasher) does not receive a reward. Slashable offenses Attestation violation Double voting  An  attester  signs two different attestations  in one epoch. Surround votes  An  attester  and sign an attestation that surrounds another one. Proposer violation Double block proposal  A  block   proposer  signs two different blocks for the same slot. Attestation Votes by validators which confirm the validity of a block. (=Attester) Block proposer A chosen validator by the beacon chain to propose the next block. There can only be one valid block per  slot . Block status Proposed  The block passed and was proposed by a validator. Scheduled  Validators are currently submitting data. Missed/Skipped  The proposer didnt propose the block within the given time frame, so the block was missed/skipped. Orphaned  In order to understand this, let us look at the diagram below \"1, 2, 3, ... ,9\" represent the slots. 1. Validator at slot 1 proposes the block a. 2. Validator at slot 2 proposes b. 3. Slot 4 is being skipped because the validator didnt propose a block (e.g.: offline). 4. At slot 5/6 a fork occurs: Validator(5) proposes a block, but validator(6) doesnt receive this data (e.g.: the block didnt reach them fast enough). Therefore Validator(6) proposes its block with the most recent information it sees from validator(3). 5. The  fork choice rule  is the key here - It decides which of the available chains is the canonical one. Validator Lifecycle 1. Deposited 32 ETH has been deposited to the ETH1 deposit-contract and this state will be kept for around 7 hours. This offers security in case the ETH1 chain gets attacked. 2. Pending Waiting for activation on ETH2 Before validators enter the validator queue, they need to be voted in by other active validators. This occurs every 4 hours. Until 327680 active validators in the network, 4 validators can be activated per epoch. For every  65536  (=4 * 16384) active validator, the validator  activation rate  goes up by one. 5 validators per epoch requires 327680 active validators which translates to 1125 validators per day. 6 validators per epoch requires 393216 active validators which translates to 1350 validators per day. 7 validators per epoch requires 458752 active validators which translates to 1575 validators per day. 8 validators per epoch requires 524288 active validators which translates to 1800 validators per day. 9 validators per epoch requires 589824 active validators which translates to 2025 validators per day. 10 validators per epoch requires 655360 active validators which translates to 2200 validators per day. Amount of activations scales with the amount of active validators and the limit is the active validator set divided by 64.000 3. Active Validator Currently attesting and proposing blocks  (=block proposer) . The validator will stay active until: its balance drops below 16 ETH (ejected). voluntary exit it gets slashed 4. Slashing Validator The Validator has been malicious and will be slashed and kicked out of the system A  Penalty  is a negative reward (e.g. for going offline). A  Slashing  is a large penalty ( 1/32 of balance at stake**)** and a forceful exit ...  . - Justin Drake 5. Exiting Validator Ejected  The validator balance fell below a threshold and was kicked out by the network Exited  Voluntary exit, the withdrawal key holder has the ability to  withdraw  the current balance of the corresponding validator balance. Finalization In Ethereum 2.0  at least two third of the validators have to be honest , therefore if there are two competing Epochs and one third of the validators decide to be malicious, they will receive a penalty. Honest ones will be rewarded. In order to determine if an Epoch has been finalized, validators have to agree on the latest two epochs in a row (= justified) then all previous Epochs can be considered as finalized. Finality issues If there are less than 66.6% votes (=participation rate) in a specific epoch, the epoch cannot be justified. As mentioned in \" Finalization \", three justified epochs in a row are required to reach finality. As long as the chain cannot reach this state it has finality issues. During finality issues the validator (entry) queue will be halted and new validators will not be able to join the network, however, inactive validators with less than <16ETH balance will be kicked out of the network. This leads to more stability in the network and higher participation rate. Previous Overview Next Staking & Hardware Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Port Forwarding", "html_url": "https://kb.beaconcha.in/port-forwarding", "body": "Port Forwarding Simplified overview on how Port Forwarding works and why it is important for staking. Tbd Let's consider the following scenario You are running a validator on a local machine and use  Geth  as your Ethereum 1.0 node and  Prysm  for your Ethereum 2.0 setup. Previous Staking & Hardware Next Ethereum 2.0 Keys Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Rewards and Penalties", "html_url": "https://kb.beaconcha.in/rewards-and-penalties", "body": "Rewards and Penalties The journey of a validator balance A simplified overview of the most common validator rewards and penalties.  Epoch A validator can propose  one attestation  and  one block  per epoch and depending on their properties the reward varies. Attestation reward Rewards and penalties are based on the correctness of Source Head Target Head, Source, target,  can be either positive or negative, however the  inclusion delay  can just be positive. The  Source  has to be  correct  in order to get included.  Base Reward The  worst  inclusion speed reward is  base_reward * 1/32 * 7/8  with an inclusion distance of 32   and the  best  is  base_reward * 1/1 * 7/8  with an inclusion distance of 1.  Possible Attestation properties  Common case scenarios Assumption: The participation rate is 100% 1. You vote correctly and gets included in the next slot: you get  31/8*base_reward 2. You miss head because you got a late block and it gets included in the next slot:  15/8*base_reward 3. You miss head and target cause you got late a block, you get  -1/8* base_reward 4. You attest and vote correctly, but the next block is missed, you get  55/16 * base_reward 5. You attest correctly and get perfect inclusion distance, but you attested on a block that most people got late as in 2., you get  ~7/8 * base_reward   The last one is the most confusing one: When there is a late block where validators miss the head, the validator that misses the head earns  more  than the validator that votes correctly, as in 2.  15/8 > 7/8 Best possible reward  31/8 * base_reward   Worst possible reward with an included attestation (\"Negative Reward\")  -249/256 * base_reward Block reward Only  valid  attestations (correct source) can be included in a block and the rewards for a block proposal scale with the amount of included  attestations . Theoretically, block proposers could include aggregated attestations from a parent block, but there is incentive to do so.  Each included attestation in a block will be rewarded (if it is the first time that is included in a block) with  base_reward/8  where  8  is the  Proposer_Reward_Quotient   There is  no  penalty for not proposing a block.  A block proposer which includes slashing will be rewarded with the  slashed_validators_effective_balance / 512  where  512  is the  Whistleblower_reward_quotient   Sources   https://consensys.net/blog/codefi/rewards-and-penalties-on-ethereum-20-phase-0/   https://benjaminion.xyz/eth2-annotated-spec/phase0/beacon-chain/   Previous Attestation Next  - Beaconcha.in Explorer Mobile App <> Node Monitoring Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Staking & Hardware", "html_url": "https://kb.beaconcha.in/staking-and-hardware", "body": "Staking & Hardware General The ideal set up, and best practice is to have a  dedicated computer  for staking. Try to limit additional processes running on your staking box. Especially if it is something that is connecting to the outside world. Use Linux!  It's easy, I promise. For the foreseeable future Linux will receive better support from the client teams. It is light weight, stable, secure, and it doesn't force you to restart for updates every other day. You are  locking  up at least 32 ETH ($80,000 in Aug 2021) in this endeavour, until the Eth2 mainnet merge (expected Q1 2021). No one knows how much that ETH will be worth during that time period, but it makes sense to buy some good hardware to secure it. A  battery back up  is  strongly  recommended! Plug your modem and router in to it also. My ISP has generators to support emergency services communications, meaning the internet continues to work during a power outage as long as my equipment is powered. Your ISP may be the same.  Raspberry Pi 4 4gb  Price : $84.80 (including case, power supply, SD card, and heat sinks) Performance : While running a node and validator on a Raspberry Pi 4 seems doable now, there needs to be further testing done to ensure it can keep up when the beacon chain is struggling. Power Usage : Approximately 8 watts. This would cost about 76 cents a month to run at 13c/kWh. My opinion : I would  not  recommend purchasing a RPI4 for staking until further testing is done to confirm it is powerful enough to keep up with the beacon chain in a rough seas situation. Even if it were fast enough, I still cant help but feel that you would be better off with a, for lack of a better term real computer. Old laptop/desktop Price : Free! Well, kind of anyways. CPU : Going by  Prysmatic 's recommended minimum requirement of an  Intel i5-760 , a CPU with a passmark score above 2500 is necessary. However, their recommended specs include a CPU that scores  7075 . For staking on main net, I would strongly recommend a CPU that is  at least in the 5000s or better . My staking computer scores 8290, and it sits at 30-40% usage consistently, with spikes to 100 on occasion. Memory : Unless you go with an extremely bare bones OS, 8gb is the minimum RAM I would recommend, and if you want to run some toys like  Prometheus  &  Grafana  to create a dashboard for monitoring,  16gb of ram would be a much better option . My staking machine typically sits at about 7.5-7.9gb used total which is too close for comfort to 8gb in my opinion. Storage : An SSD is required. Pretty much any SSD should work fine. Buying one with a high terabytes written spec will help with longevity. Caveats : Stability and uptime are essential to maximize your profits. If you are using an older desktop consider replacing the PSU and the fans. Buying a  titanium  or platinum rated PSU will help save on the monthly power bill as well. If you are planning on staking with an older laptop, consider that they have reduced capacity to deal with heat due to their form factor, and in rare cases,  running while plugged in 24/7 can cause issues with the battery . If you do choose to stake with a laptop, I would recommend using one that far exceeds the CPU requirements as running a laptop at nearly full load 24/7 is not advisable. You will probably be fine, but generally speaking laptops are not designed with that in mind. New laptop If you are buying brand new, I do not see any value in paying the price premium for a portable form factor, screen, keyboard, and trackpad. Once you get your staking machine set up, you do not need any of these features, you can just remote into the staking machine from your daily driver computer. The low profile form factor will actually be a downside when taking thermal performance in to account. Laptops typically do not include an ethernet port now, which means you will be relying on wifi. Wifi is very reliable now, but you can't beat the simplicity and reliability of a cable.  New prebuilt desktop  Price:  Probably $400-600. There are likely better deals out there than the one linked above. Performance:  This will reliably and competently run nearly any amount of validator accounts. The CPU scores 6250 on passmark. It has a 512gb NVMe SSD, and 16gb of ram. Any other prebuilt desktop with similar specs will work just as well. Power Usage:  Probably around 30 watts. That is $2.85 per month at 13c/kWh. My opinion:  This is a great option. Also, it is 11\" x 10\" x 4\". Much smaller than the old fashioned desktop cases, and ATX mid tower cases most of us are probably familiar with. Custom built desktop I won't go too in-depth here because this is essentially the same as using a prebuilt desktop. However, building your own gives you the option of choosing a case you like the look of, and buying higher quality parts, and you know you aren't getting any weird proprietary parts that will be difficult to replace should they ever fail. Unfortunately with prebuilt's concessions are sometimes made with components like the PSU to assuage the accountants and boost margins. **** NUC   /   Mini PC   /   DApp Node **** Price:  $678. Performance : The  linked one  weighs in at a mighty 8394 passmark score and has 16gb of ram and a 512gb SSD. Power usage:  20-25ish watts. Around $2 a month. My opinion:  NUCs are super cute, and their small form factor gives them a very high wife approval factor. Unfortunately that does come with a bit of a price premium. I'm going to argue that you should buy a server below, but honestly this is probably a more realistic option for most people. Server  One option , or a  more modern option . You really need to look around for deals when it comes to this. Usedservers.com charges a premium for the convenience and customisation they offer. If you search through eBay, or even better your local classifieds you can often find some gear that someone paid a large pile of money to get for a few hundred bucks. Performance : Generally speaking, no matter what you buy, performance will not be an issue. The two options I linked above can be specced to the cheapest of what they offer and it will still be overkill. Power Usage:   It's bad.  My server runs around 100 watts, but it is pretty modern. If you get an older one, expect to be up around 150 watts. That's $10-14 a month. My opinion:  This is my favourite option. Enterprise servers are jam packed with features, and are specifically designed to do exactly what we are trying to do. Run 24/7/365. They have redundant power supplies in case one breaks, they often have 2 CPUs, so in the unlikely event of one going bad, you can pop it out and restart with just one. They have built in  RAID cards  so you can have redundant storage. They have hot swappable drive trays, so if one of your drives goes bad, you don't even need to shut down. All of the components are high quality and built to last. You also get monitoring and maintenance tools that are not included in consumer gear like iDRAC and iLo. That's where that power usage graph I linked above came from. Neat right?  I wouldn't necessarily recommend this option to someone running 1 validator , but if you are running several, the few extra dollars of overhead every month is worth the reliability and performance in my opinion.  Avado  It's a NUC, but expensive. The most expensive one at 1100 USD only rates in at 3349 on passmark. They have their own OS which might have a really great UX, I don't know, but it likely is not worth the price of admission.  Dappnode  is another option if you are looking for a custom built OS with an easy UX. Virtual Private Server Price:  Anywhere from $20-40 a month. Performance:  You can buy as much as you can afford. My opinion:  If you live somewhere that is prone to natural disaster or has an unstable power grid or internet connection but still want to stake, this is a good option. If you do have stable power or internet, running your own hardware will be a cheaper and more profitable solution long term. You need to evaluate the pros/cons of this for your own situation. Remember that if one of the VPS providers goes down, it will mean all of the people using that VPS service to host will also go down, and the inactivity penalties will be much larger than if you have uncorrelated down time yourself.  Source , written by  Lamboshi   Previous Glossary Next Port Forwarding Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "The Genesis Event", "html_url": "https://kb.beaconcha.in/the-genesis-event", "body": "The Genesis Event A visualisation of the Genesis Event on Ethereum 2.0 Keywords  Deposit contract  Seconds_Per_Eth1_Block  = 14 seconds Eth1_Follow_Distance =  2048 blocks * 14 seconds Min_Genesis_Time  = 1606824000 (12:00:00 pm UTC | Tuesday, December 1, 2020) Min_Genesis_Active_Validator_Count  = 16,384 Genesis_Delay  = 7 days   Ethereum 2.0 Beacon-chain  Genesis Event Conditions There are two conditions which have to get triggered to get the Ethereum 2.0 chain started! 1. The threshold of  16,384 validators  needs to be hit 2. The   ETH1  block (=Trigger block) which  determines the genesis  time for ETH2  cannot be earlier  than   min_genesis_time. Trigger ETH1 block =  min_genesis_time - genesis_delay  Scenario One  The required amount of deposits ( Min_Genesis_Active_Validator_Count)  to fulfil the first condition occurs very quickly once the deposit contract has been deployed and  before   min_genesis_time .   Once the threshold of  16,384 deposits  is met, the network will try to accomplish the second condition by trying to find the  trigger block  by calculating  min_genesis_time - genesis_delay. The goal of the trigger block  (min_genesis_time - genesis_delay)  is that the chain can never start earlier than  min_genesis_time . The second scenario will make this clearer. Scenario Two The required amount of deposits ( Min_Genesis_Active_Validator_Count)  to fulfil the first condition occurs  after  min_genesis_time.    In this case, the second condition is met first and the trigger block becomes whatever  min_genesis_time  was set.  The trigger block (second condition) is achieved right after the deposit contract receives 16,384 validator deposits.  Genesis time becomes  Trigger-block-timestamp + genesis_delay .   Sources:   Ethereum 2.0 Spec   The Genesis of a Beacon Chain  Previous Ethereum 2.0 Keys Next Deposit Process Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Beacon Fuzzer", "html_url": "https://kb.beaconcha.in/archive/beacon-fuzzer", "body": "Beacon Fuzzer Use Sigma Prime's Beacon Fuzzer to automatically find bugs. Here are the articles in this section: Fuzzing on Windows Fuzzing on macOS Archive -  Previous Medalla Testnet: Lighthouse Client - macOS Next Fuzzing on Windows Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Medalla Testnet: Lighthouse Client - macOS", "html_url": "https://kb.beaconcha.in/archive/beaconnode-and-validator-with-macos", "body": "Medalla Testnet: Lighthouse Client - macOS Altona Testnet  Official Lighthouse docs   Lighthouse Discord server  Requirements:  A synced Goerli node ( Guide  till step 3.)  1. Step  Installing Rust Open a terminal window and paste the following in: curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh \"Current installation options\"  Press  \"1\"  and confirm with Enter. \"Next time you log in this will be done automatically\"  Close  this terminal window and  open a new one. 2. Downloading and building Lighthouse git clone https://github.com/sigp/lighthouse.git cd lighthouse and then run  make Wait a few minutes  Once the process is done it will look like the following 3. Find the binary file Open  Finder  and head over to  ~/.cargo/bin/ Copy  the Lighthouse file to a more convenient folder. 4. Start the beaconnode Make sure the goerli node (ETH1) is running as mentioned in the  requirements . Drag and drop the  Lighthouse  file and add  --testnet medalla beacon --eth1 --http --graffiti \"beaconcha.in<3\"  5. Create ETH2 Wallet Lighthouse  allows you to create an ETH2 wallet and attach your validator keys. Open a new Terminal window, drag and drop the Lighthouse file and  add   account wallet create --name my-validators --passphrase-file my-validators.pass The 12 word mnemonic phrase can restore the ETH2 wallet - write the words down. The wallet is located in  $HOME/lighthouse 6. Create ETH2 Keys Use the same Terminal window, drag and drop the Lighthouse file and  add   lighthouse account validator create --wallet-name my-validators --wallet-passphrase my-validators.pass --count 1 7. Depositing to Ethereum 2.0 First, find the deposit data of the newly created ETH2 Key , which is located in  .lighthouse/validators/    There are two lighthouse folders,  .lighthouse  is a hidden folder.  Enable hidden folders with   CMD + Shift + . Open the  eth1-deposit-data.rlp  file with a  text editor.  Copy  the 842 long text sequence and  follow these  steps .  Medalla Deposit contract address:  0x07b39F4fDE4A38bACe212b546dAc87C58DfE3fDC The deposit will be recognised by the beacon-chain in 8.5 hours.  8. Starting the validator Open a new terminal window, drag and drop the  Lighthouse  file and add  validator --auto-register In total there are  three  terminal windows running simultaneously!   Track  your validator performance.    Archive -  Previous Run a Goerli node (ETH1) & beaconnode (ETH2) Next  - Archive Beacon Fuzzer Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Depositing to Ethereum 2.0", "html_url": "https://kb.beaconcha.in/archive/depositing-to-ethereum-2.0", "body": "Depositing to Ethereum 2.0 Warning The following steps occur on a Ethereum Testnet with Goerli Testnet-ETH and might be outdated for the Ethereum main-net launch. Requirements There are multiple wallets and possibilities, however, let's demonstrate the most common way for the average user.   MyCrypto  Prysm Client to  create  Ethereum 2.0 keys ( macOS  or  Windows ) at least 32 Goerli Testnet ETH (ask on  Discord ) Create  ETH 2.0 K eys For demonstration purposes the Prysm Client will be used to create Ethereum 2.0 keys, any other Ethereum 2.0 client would work as well.  Create your own keys - on  macOS  or  Windows  with the prysm client Key generation These 842 characters are the Ethereum 2.0 validator  identity . 0x22895118000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000120afd078c8e46733de1c116df653afef908cc7a809009b375ffab943f495974a700000000000000000000000000000000000000000000000000000000000000030a10010049908f68bdf86baaae2c4e1df7456f11f1f0124c25ebeeb7541ac34d6562782694d316c7a912259e2d7b4e59000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000040231464d41e1c646c708bd84fe5fd4dcc6fa2f4d9bfdfa64f40c974618c80000000000000000000000000000000000000000000000000000000000000060a4884293664737cb4860033c0150b91915ccbc9ab1337eae5b4ec70f38cddc64d2db5a450ccd667ae9ab7d0f2ae35cd40c97e3a086e57f77a489b7d73e0ad9532134906671a086dd369bd3e10b52cbc648bf352ee18aea6c7ec2fec11053aaa00x22895118000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000120afd078c8e46733de1c116df653afef908cc7a809009b375ffab943f495974a700000000000000000000000000000000000000000000000000000000000000030a10010049908f68bdf86baaae2c4e1df7456f11f1f0124c25ebeeb7541ac34d6562782694d316c7a912259e2d7b4e59000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000040231464d41e1c646c708bd84fe5fd4dcc6fa2f4d9bfdfa64f40c974618c80000000000000000000000000000000000000000000000000000000000000060a4884293664737cb4860033c0150b91915ccbc9ab1337eae5b4ec70f38cddc64d2db5a450ccd667ae9ab7d0f2ae35cd40c97e3a086e57f77a489b7d73e0ad9532134906671a086dd369bd3e10b52cbc648bf352ee18aea6c7ec2fec11053aaa0  These letters,  the input data , have to be included into the transaction to the deposit contract.  Depositing 1. Open  MyCrypto  and open your wallet and head over to  Send Assets .  2. Advanced options  Paste the 842 letters into the  Data field   0x22895118000000000000000000... .  3. Recipient  is the deposit contract  Medalla   Testnet :  0x07b39F4fDE4A38bACe212b546dAc87C58DfE3fDC 4. Amount  Minimum of 1 ETH 5. Gas Limit  500,000 6. Send transaction 7. Track your deposit on the  beaconcha.in  explorer with your Ethereum 1.0 address Transaction Overview  Guides -  Previous Pyrmont Testnet: Prysm Client - Windows Next  - Archive Run a Goerli node (ETH1) & beaconnode (ETH2) Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Run a Goerli node (ETH1) & beaconnode (ETH2)", "html_url": "https://kb.beaconcha.in/archive/eth1-infura", "body": "Run a Goerli node (ETH1) & beaconnode (ETH2) Run your own ETH1 and connect it to ETH2 General Ethereum 2.0 Testnets have been running for some time, and because the existing Ethereum 2.0 clients have always provided an Ethereum 1.0  node to users, misunderstandings arose.   In order to run a validator, an Ethereum 1.0 node must run parallel to Ethereum 2.0 to stay fully decentralized!   However, an Ethereum 1.0 node is not required if you do not want to stake. Without an Ethereum 1.0 node  syncing Ethereum 2.0 blocks is still possible and also being a reliable peer for others in the network.     Goerli-chain size is around 5GB. Connect to your  local   ETH1 node Step 1. Download  Geth   Step 2.  Find the downloaded file  and  open a  command prompt/terminal   window  Step 3. Syncing Goerli  Drag and drop the  geth  file into the terminal window and add the following   --goerli --datadir=\"$HOME/Goerli\" --rpc --rpcaddr=127.0.0.1 --rpcport=8545 The syncing-process takes about  30 minutes.   Wait for this to complete.  Once your Goerli node is synced, it should look like this and include the message:   Imported new chain segment  Step 4. Connect your beaconnode (ETH2) to Goerli (ETH1) While Goerli is in sync , drag and drop the  prysm.sh (macos) /prysm.bat (windows)  into the terminal window file and add:    beacon-chain  --datadir=$HOME/prysm --web3provider=ws://localhost:8546/ --http-web3provider=http://localhost:8545/ --datadir=$HOME/prysm Please adapt the path above to your existing beaconchain.db file.  For simplicity reasons we will use $HOME/prysm.  If the beaconnode  successfully connects  to the local Goerli node, the following message will appear  Essential commands Goerli --goerli --datadir=\"$HOME/Goerli\" --rpc --rpcaddr=127.0.0.1 --rpcport=8545 --ws --wsaddr=127.0.0.1 --wsport=8546 Beaconnode --datadir=$HOME/prysm --web3provider=ws://localhost:8546/ --http-web3provider=http://localhost:8545/ Infura as an ETH 1.0 node  1. Sign up on  Infura  2. Create a project with any name 3. Change  Endpoints: Mainnet  to  Goerli That's it!   Copy your Project ID URL and run the beacon-node with   ./prysm.sh beacon-chain --http-web3provider= https://goerli.infura.io/v3/YOUR-PROJECT-ID  Confirmation via beacon-node   Archive -  Previous Depositing to Ethereum 2.0 Next  - Archive Medalla Testnet: Lighthouse Client - macOS Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "OUTDATED: Prysm Client Guides", "html_url": "https://kb.beaconcha.in/archive/outdated-prysm-client-windows", "body": "OUTDATED: Prysm Client Guides Here are the articles in this section: Essential commands (macOS & Windows) macOS Prysm Client - Windows Previous Fuzzing on macOS Next Essential commands (macOS & Windows) Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "beaconcha.in notifications", "html_url": "https://kb.beaconcha.in/beaconcha.in-explorer/beaconcha.in-notifications", "body": "beaconcha.in notifications This article provides a tutorial on setting up and debugging notifications using beaconcha.in's web and mobile platforms.  It's worth noting that the current notification center will undergo an upgrade in late 2023 to upgrade its user-friendliness. Enabling notifications via web 1. Head over to  https://beaconcha.in/user/notifications  and log in with your e-mail address. 2. Click on \"Notifications Channels\" and make sure the desired channels are active   3. Scroll down to the  Validators  table and add your validators. Once added you can  select all  and bulk edit the notifications by clicking  Manage selected .   4. Enable the desired notification(s) and press  Save .    5. Verify that the subscriptions are enabled   6. If a notification was triggered it will show up in the Most recent column    7. Done! You may have noticed that the Notification Center allows you to configure  Push notifications  for the mobile app. This is crucial since some users may not receive any push notifications if it is disabled.  Mobile app 1. Download the app for iOS and Android here  https://beaconcha.in/mobile  2. Create an account and log in with your e-mail address   Note : If you added validators to your Notification center through  https://beaconcha.in/user/notifications  they will  not  appear in your mobile app automatically. If push notifications were enabled in the web notification center, the mobile app push the notifications through even if the validators are not visible in your app.  This UX issue will be part of the improvements later this year.   3. Add validators to your mobile app dashboard  4. Head over to the settings and enable the desired notifications    5. Click the \"Sync\" button in the Validator section      6. Done!  Verify that the notifications were added successfully by logging in at  https://beaconcha.in/user/notifications  and scrolling to the Validator table at the bottom of the page     You may have noticed that the Notification Center allows you to configure  Push notifications  for the mobile app. This is crucial since some users may not receive any push notifications if it is disabled.  Webhooks 1. Follow the steps as described  above  in \" Enabling notifications via web\" . 2. Double-check that webhooks are enabled   3. Add a webhook via  https://beaconcha.in/user/webhooks  4. Enable the same notification types as on the notification center and enable \"discord\" if the notifications should be sent to a discord channel   5. Done  Beaconcha.in Explorer -  Previous Mobile App <> Node Monitoring Next  - Beaconcha.in Explorer Block view Last modified  4mo ago", "labels": ["Documentation"]}, {"title": "Beaconcha.in Charts", "html_url": "https://kb.beaconcha.in/beaconcha.in-explorer/eth2-charts", "body": "Beaconcha.in Charts  Overview of all charts   Blocks  Displays all the  proposed, missed or oprhaned Blocks  for a specific period of time.  Validators  Displays the amount of  validators  for each timestamp.  Staked Ether  Displays the total amount of staked Ether  ( effective  balance) .  Validator Balance  Displays the  current average validator balance  of all validators.  Network Liveness  Displays how far the last finalized  Epoch  compared to the Head Epoch took place. A minimum of two epochs is caused by how  finalization  works. The network is undergoing finality issues if the network liveness is  more than two  epochs.  Participation Rate  Displays the participation of validators in the chosen time period. Calculation: Participation rate = (number of attestations in last epoch) / (number of attesting validators)  Average daily validator income  Displays the average income of all  validators  per day starting off at the  genisis block .  Staking Rewards  Displays the sum of all staking rewards and punishments of all validators on a specific day.  Example  in the picture below: 1471.15 ETH have been lost on Februar 7th.  Stake Effectiveness  Displays the measurement of the relation between  effective balance   validator  and  current balance   validator  of  all validators . 100% means that the total locked ETH is actively being staked. Due to the fact that the effective balance cannot increase more than 32, but the  current balance can , the Stake effectiveness decreases.  Balance Distribution  Displays the distribution of  current balances  of all  validators  for the current epoch.  Example  in the picture below: 5404 validators at 3.28ETH .  Effective Balance Distribution  Displays the distribution of  effective balances  of all  validators .  Example  in the picture below: 2200 at have an effective balance of 3ETH.  Income Distribution of the last 365 Days  Displays the income distribution of all  validators  of the last 365 days.  Example  in the picture below: 38 validators have gained 0.020360794 ETH.  Deposits  Displays the amount of ETH deposited to  ETH1  ( Success ), and how many of those transactions failed because of an invalid BLS signature  (ETH1 failed) .  ETH2  represents the successful deposits after their waiting time of  ~7.5 hours . Beaconcha.in Explorer -  Previous Block view Next  - Beaconcha.in Explorer Optimal Inclusion Distance Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Block view", "html_url": "https://kb.beaconcha.in/beaconcha.in-explorer/ethereum-2.0-blocks", "body": "Block view Blocks 'n' roots This post is going to lay out data, Ethereum 2.0 explorers such as  beaconcha.in  visualise Overview  Epoch ,  Slot ,  Status ,  Proposer  are covered in the  glossary  Block root The hash-tree-root of the  BeaconBlock . State root The hash-tree-root of the  BeaconState . Signature The BLS signature  obtained by  using the BeaconState, BeaconBlock and private key. def get_block_signature(state: BeaconState, block: BeaconBlock, privkey: int)  -> BLSSignature Randao Reveal TODO Grafitti A block proposer can include 32 byte long message to its block proposal. Eth 1 Data Received Eth1 Block headers and Deposit data  Block Hash:  The Hash of the received Eth1 Block. Deposit Count:  Amount of validator deposits to the deposit contract in this block. Deposit Root:  The root of the merkle tree of deposits. Attestations Amount of attestations included in this block by the block proposer. Deposits Amount of validator deposits which have been included in this block by the block proposer Voluntary Exits Amount of voluntary Exits which have been included in this block by the block proposer. Slashings Amount of slashings which have been included in this block by the block proposer.    Votes Represents the total amount of votes in a specific block. In the example below there were 128 attestations. These attestations received a  total  of 2802 votes. The aggregation bit is an additional way of representing the votes.   Attestations Slot Is the slot number to which the validator is attesting. The slot number points to the same block as the beacon-block-root. Committee Index Every epoch the total number of validators is split up in committees and one or more individual committees are responsible to attest to each slot. The committee Index is the identifier for this specific committee during a slot. Aggregation Bits Represents the aggregated attestation of all participating validators in this attestation. Each \"1\" bit is a successful attestation submitted by the validator. \"0\" bits visualise missed attestations. Validators Validators who have submitted their attestation and have been included by the block proposer. Beacon Block Root The beacon block root points to the block to which validators are attesting. The difference between the block number in which the attestation has been included, and the one the beacon block root is pointing to, causes the attestation inclusion delay. Source & Target These are two additional votes a validator has to submit. The source points to the latest justified epoch, and the target to the latest epoch boundary. Signature Beaconcha.in Explorer -  Previous beaconcha.in notifications Next  - Beaconcha.in Explorer Beaconcha.in Charts Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Mobile App <> Node Monitoring", "html_url": "https://kb.beaconcha.in/beaconcha.in-explorer/mobile-app-less-than-greater-than-beacon-node", "body": "Mobile App <> Node Monitoring A step by step tutorial on how to monitor your staking device & beaconnode on the beaconcha.in mobile app. General This is a free monitoring tool provided by  beaconcha.in  to enhance the solo staking experience. The user specifies the monitoring endpoint on its beacon & validator node. By using this endpoint, beaconcha.in will be allowed and is required to store the given data to display it in the beaconcha.in the mobile application. To protect user privacy, the IP address will  never  be stored. Requirements beaconcha.in  Account  beaconcha.in  Mobile App  Lighthouse   v.1.4.0  or higher Prysm   v1.3.10  or higher Nimbus   v1.4.1   or higher Teku v22.3.0 or higher Lodestar   v1.6.0   or higher Staking on Linux (No windows support by clients yet!) Please adjust the network on the beaconcha.in browser and mobile app accordingly. Both, the beaconcha.in  explorer  and the  mobile app  are open source! Lighthouse A step by step guide on the Prater Testnet. Please adjust the network for your own needs. 1. Open the  Mobile App   Tab and enter a name for your staking setup.  Use the same worker name even if your beaconnode runs on a seperate machine than your validator node.  __ __Copy the generated flag and paste it add it to your  beacon & validator node  __ If your beacon-node or Ethereum 1.0 node is not in sync yet, you will see some warning logs!  2. Open the  beaconcha.in mobile app  and login with your account under  Preferences.  Your staking device will appear under  Machines  ! Prysm 1. Head over to the  beaconcha.in settings  and open the prysm section: 2. Open a  new Terminal  and copy paste the commands 3. Make sure your Prysm client (beacon & validator) is already up and running. The exporter will now send the data to your mobile app! 4. Wait a few minutes and open the  beaconcha.in mobile app  and login with your account under  Preferences.   Your staking device will appear under  Machines  ! Nimbus 1. Head over to the  beaconcha.in settings  and open the nimbus section: 2. Add  --metrics --metrics-port=8008  to your nimbus client! Otherwise the exporter will not be able to get any data from your client. 3. Wait a few minutes and open the  beaconcha.in mobile app  and login with your account under  Preferences.   Your staking device will appear under  Machines  ! Teku Add the following endpoint to your teku node  --metrics-publish-endpoint https://beaconcha.in/api/v1/client/metrics?apikey=YOUR_API_KEY You can find your API Key here:  https://beaconcha.in/user/settings#app  Lodestar Add the following CLI flag to your Lodestar validator and beaconnode  --monitoring.endpoint 'https://beaconcha.in/api/v1/client/metrics?apikey=YOUR_API_KEY' You can find your API Key in the  account settings . Check out the Lodestar documentation about  client monitoring  for further details. Monitoring with Rocket Pool Works with Lighthouse, Lodestar, Teku and Nimbus only. ****  Lighthouse, Lodestar and Teku Add Your  beaconcha.in API key  in Monitoring/Metrics (service config)  **** Nimbus Nimbus does not expose every data, thus, some data such as validators are not visible in the app. Guide:  https://gist.github.com/jshufro/89e32d417801bf3dfb02c32a983b63cf  Previous Rewards and Penalties Next  - Beaconcha.in Explorer beaconcha.in notifications Last modified  4mo ago", "labels": ["Documentation"]}, {"title": "Optimal Inclusion Distance", "html_url": "https://kb.beaconcha.in/beaconcha.in-explorer/optimal-inclusion-distance", "body": "Optimal Inclusion Distance  The attestation for  slot 156508  was included in  slot 156510  but why is the inclusion distance 0? If were to use the formula from above and set the inclusion delay to 0, the rewards would be 0 for a proposed attestation. Missed blocks are  not added  to the inclusion distance, but since the attestant is not responsible for the block proposal, and to only warn the user about its faults (e.g. slow internet connection, power failure etc.), the  beaconcha.in explorer  displays the distance as 0. Beaconcha.in Explorer -  Previous Beaconcha.in Charts Next  - Guides Step by Step: How to join the Ethereum 2.0 Testnet Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Pyrmont Testnet: Prysm Client - Windows", "html_url": "https://kb.beaconcha.in/guides/pyrmont-windows", "body": "Pyrmont Testnet: Prysm Client - Windows A guide for non-technical users Disclaimer The following steps only apply for the  Pyrmont Testnet  and may be outdated in a few weeks as Ethereum 2.0 clients develop rapidly, however, we will try to keep these documents updated. There are multiple ways on how to get started, we will use the one which is the easiest as of now.     Official Prysm docs   Prysmatic labs discord server   Official  Pyrmont  Launchpad  Choosing Eth1 & Eth2 clients Head over to   the  Pyrmont launchpad  Choose  Geth as your Eth 1  client and in the next step choose  Prysm as your Eth 2 client. Start Ethereum 1.0 Node 1. Create a folder named  prysm  in  C:\\ 2. Download  Geth  and open a terminal window. 3. Double click the .exe  geth-windows-amd64-x.x.xx-cc05b050 . Once the installation is complete there should be  geth.exe  in the directory chosen during the installation.  4. Drag and Drop  the  geth.exe  file and add  --datadir=\"C:\\prysm\" --goerli --http This terminal window needs to run in parallel to the Ethereum 2.0 node, which will be covered in the next steps.  Wait for the Ethereum 1.0 node to be in sync. The logs will look like the following once the node is in sync Generate Key Pairs Choose the amount of validators you would like to run and Windows as the operating system. Each validator will cost 32 Goerli ETH.   Request  Goerli Eth from the r/ethstaker discord  here  or in the prysmatic labs discord  here . Creating keys Download the  eth2.0-deposit-cli  Move  the downloaded file into  prysm .  Open a Terminal window  and drag&drop the  deposit.exe  file into the terminal as shown below. Follow the instructions to create your Ethereum 2.0 keys!  Drag and drop  the Eth2.0-deposit-cli file and  add  new-mnemonic --chain pyrmont WRITE DOWN THE GENERATED 24 WORD MNEMONIC PHRASE  Let's go to the  next page  and upload our  deposit-data-[timestamp].json  file  (located in the path shown in the terminal) , continue  and deposit 32 goerli Eth .   Downloading Prysm This is only required for the initial setup Open a Terminal window and run:  1.   cd C:\\prysm   changes the directory    2. curl https://raw.githubusercontent.com/prysmaticlabs/prysm/master/prysm.bat --output prysm.bat  Downloads the prysm.bat file   3. reg add HKCU\\Console /v VirtualTerminalLevel /t REG_DWORD /d 1  Changes some vizulations in the terminal window Importing validator keys  Drag and drop  the prysm.bat file and  add  validator accounts import --keys-dir=  AND  the path to your newly created keys .  For this example the path is  C:\\Users\\Inan\\validator_keys Which results   prysm.bat validator accounts import --keys-dir=C:\\Users\\Inan\\validator_keys Enter a new wallet directory and a new password.   In this example we chose  C:\\prysm  as the new wallet directory. Start the beacon node Open a new terminal window,  drag & drop the prysm.bat  file and add  beacon-chain --datadir=C:\\prysm --http-web3provider=http://localhost:8545/ --pyrmont Start the validator node Open a new terminal window,  drag & drop the prysm.bat  file and add  validator --wallet-dir=C:\\prysm --datadir=C:\\prysm --pyrmont Enter your wallet password which was set in the previous step.  Find the  validator public keys  in the logs Enter your wallet password which was set in the  previous step .   That's it. We are done! Your setup should now have three running terminal windows Enter your pubkey on the  beaconcha.in  explorer  to track its current status and performance. Find out what each of the validator status mean -  \" What does \" Unknown status \" mean?\"   Guides -  Previous Step by Step: How to join the Ethereum 2.0 Testnet Next  - Archive Depositing to Ethereum 2.0 Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Step by Step: How to join the Ethereum 2.0 Testnet", "html_url": "https://kb.beaconcha.in/guides/tutorial-eth2-multiclient", "body": "Step by Step: How to join the Ethereum 2.0 Testnet A guide for non-technical users using the Prysm and Lighthouse client General This guide is designed for  non-technical  people. It focuses on  Windows10 and MacOs  and is an ongoing process, and it will be updated as we collect feedback and adapt to the most recent client changes! Note: There are  multiple  ways to join the ETH2.0 Testnet by using different clients. Requirements Recommended:  8GB RAM, 100GB SSD,  Metamask   wallet installed   Minimum:  4GB RAM, 20GB SSD,  Metamask   wallet installed Before we start, it is recommended reading the  glossary  but not a requirement. Start Staking 1.  Prysm Client  by  Prysmatic Labs  -  Discord channel   Windows  2.  Lighthouse Client  by  Sigma Prime  -  Discord channel   macos   Run a Goerli node (ETH1) & beaconnode (ETH2)  Beaconcha.in Explorer -  Previous Optimal Inclusion Distance Next  - Guides Pyrmont Testnet: Prysm Client - Windows Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Fuzzing on macOS", "html_url": "https://kb.beaconcha.in/archive/beacon-fuzzer/macos", "body": "Fuzzing on macOS Beacon Fuzzer guide for macOS users. General  Fuzzing  or  fuzz testing  is an automated software testing technique that involves providing invalid, unexpected, or random data as inputs to a computer program.  https://github.com/sigp/beacon-fuzz   Lighthouse Discord Channel  Requirements  Install Docker  8-16 GB RAM  2-4 Core CPU Configure Docker file sharing settings Make sure that the paths   /Users  ,  /Volumes  ,  /private  ,   /tmp  have been entered. Fuzzing Step 0.  Open up a  Terminal  and test if docker is up and running  docker -v Step 1.   Clone the repository  git clone https://github.com/sigp/beacon-fuzz Step 2. Change your directory  cd beacon-fuzz/eth2fuzz Step 3.  Build  all  Ethereum 2.0 client docker containers  make fuzz-all  This process can take up to one hour. Once the building process is done, the Fuzzer will start by fuzzing the Lighthouse client and fuzz the next client after one hour. The total process takes 5hours. Fuzzing Lighthouse Report & find bugs Step 0. Open  Finder  and head over to its  Preferences  Change the search settings to  Search the Current Folder Step 1. If the fuzzer finds a bug it creates a  crash   file   in the workspace folder  ~/beacon-fuzz/eth2fuzz/workspace  Step 2. Search the workspace folder for files called \" crash-...\" , which is the bug file and compress it to a  zip.file  An example:   crash-efc8b3f0753ddd9df52b066d2f4549d548a21a58 Post the zip file on the beacon-fuzz  github repository . Previous Installing Docker on Windows Home Next  - Archive OUTDATED: Prysm Client Guides Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Fuzzing on Windows", "html_url": "https://kb.beaconcha.in/archive/beacon-fuzzer/windows", "body": "Fuzzing on Windows Beacon Fuzzer guide for windows users. General  Fuzzing  or  fuzz testing  is an automated software testing technique that involves providing invalid, unexpected, or random data as inputs to a computer program.  https://github.com/sigp/beacon-fuzz   Lighthouse Discord Channel  Requirements Install  Docker  on  Windows Pro  or  Windows Home  Install  MAKE  for Windows (External  Video Guide  &  StackOverflow ) 8-16 GB RAM  2-4 Core CPU   Download the Fuzzer Step 0.  Open a  terminal window  and test if docker is up and running with   docker -v Step 0. Continue with   cd desktop   followed by   git clone https://github.com/sigp/beacon-fuzz  Edit the MAKE file Head over to the desktop and open the downloaded folder  beacon-fuzz  . Continue to the subfolder  eth2fuzz  and open the  Makefile  file with  a text editor . Replace all  DOCKER_BUILDKIT=1  in the  Makefile  with  docker build \\  and  save  the changes. There are five  \"DOCKER_BUILDKIT=1\"  in total.   Alternatively, copy this  file , which has everything replaced.  Fuzzing Step 0. Open a  terminal window  and go to the eth2fuzz directory with    cd desktop/beacon-fuzz/eth2fuzz Step 1. Build all clients and start fuzzing by running  make fuzz-all That's it, the process will take multiple hours! Report Bugs Search the  beacon-fuzz  folder for files called \" crash-...\" , which is the bug file, and compress it  to a  zip file.   Web tool  to convert files into zip.   Post the zip file on the beacon-fuzz  github repository . An example:   crash-efc8b3f0753ddd9df52b066d2f4549d548a21a58   Archive -  Previous Beacon Fuzzer Next Installing Docker on Windows Pro Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "macOS", "html_url": "https://kb.beaconcha.in/archive/outdated-prysm-client-windows/macos-prysm", "body": "macOS Here are the articles in this section: Beaconnode & validator using prysm.sh (recommended) Run a Slasher using prysm.sh Beaconnode & validator using Docker Previous Essential commands (macOS & Windows) Next Beaconnode & validator using prysm.sh (recommended) Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Prysm Client - Windows", "html_url": "https://kb.beaconcha.in/archive/outdated-prysm-client-windows/prysm-client-windows", "body": "Prysm Client - Windows Here are the articles in this section: Beaconnode & validator using prysm.bat (recommended) Beaconnode & validator using Docker Slasher with Windows using prysm.bat Previous Beaconnode & validator using Docker Next Beaconnode & validator using prysm.bat (recommended) Last modified  2yr ago", "labels": ["Documentation"]}, {"title": "Essential commands (macOS & Windows)", "html_url": "https://kb.beaconcha.in/archive/outdated-prysm-client-windows/tl-dr-essential-commands-macos-and-windows", "body": "Essential commands (macOS & Windows) A summary of the most important flags to run the prysm client with  prysm.sh  or  prysm.bat.   For beginner friendly guides please look  here for Windows  and  here for macOS . Windows Get prysm.bat file  curl https://raw.githubusercontent.com/prysmaticlabs/prysm/master/prysm.bat --output prysm.bat Beacon-node  prysm.bat beacon-chain --datadir=$HOME/prysm Create new keys prysm.bat validator accounts create --keystore-path=$HOME/prysm --password=yourPassword Validator   prysm.bat validator --keystore-path=$HOME/prysm --password=yourPassword   Slasher   prysm.bat slasher --datadir=$HOME/prysm macOS Get pryms.sh file  curl https://raw.githubusercontent.com/prysmaticlabs/prysm/master/prysm.sh --output prysm.sh && chmod +x prysm.sh Beacon-node  prysm.sh beacon-chain --datadir=$HOME/prysm Create new keys prysm.bat validator accounts create --keystore-path=$HOME/prysm --password=yourPassword Validator   prysm.sh validator --keystore-path=$HOME/prysm --password=yourPassword   Slasher   prysm.sh slasher --datadir=$HOME/prysm Archive -  Previous OUTDATED: Prysm Client Guides Next macOS Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Installing Docker on Windows Home", "html_url": "https://kb.beaconcha.in/archive/beacon-fuzzer/windows/installing-docker-on-windows-home", "body": "Installing Docker on Windows Home Installing Docker on Windows Home Step 0. Make sure you have  Windows10 Home . Since Docker is not available for Windows 10 Home, some workarounds are required and are solved by following this guide. Step 1.  Download Docker  but do not install yet.  Install  Hyper-V  by running the  .bat  file. ( source )  Virtualization  must be enabled ( Guide ) virtualization Step 2. Pretend being a Windows10 Pro user 1. Open the \"Registry Editor\" and go to the following path: Computer\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion   2. Change   EditionID  to  Professional  and  ProductName  to  Windows 10 Pro   3. Immediately  open the downloaded Docker File and  install Docker . registryEditor In case of a  PC restart, shutdown or Docker shutdown , the registry change above needs to be re-entered otherwise Docker will not start. Step 3. Change Docker File sharing settings and give access to  C: Step.4 Change Docker's default memory to 4.00 GB Previous Installing Docker on Windows Pro Next Fuzzing on macOS Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Installing Docker on Windows Pro", "html_url": "https://kb.beaconcha.in/archive/beacon-fuzzer/windows/installing-docker-on-windows-pro", "body": "Installing Docker on Windows Pro I nstalling Docker on Windows Pro Step 0. Make sure you have  Windows10 Pro . Step 1.  Download Docker   Virtualization  must be enabled ( Guide ) virtualization Step 2. Change Docker File sharing settings and give access to  C: Step.4 Change Docker's default memory to 4.00 GB Previous Fuzzing on Windows Next Installing Docker on Windows Home Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Beaconnode & validator using Docker", "html_url": "https://kb.beaconcha.in/archive/outdated-prysm-client-windows/macos-prysm/docker-beaconnode-and-validator-macos", "body": "Beaconnode & validator using Docker   Official  PrysmaticLabs Docs  Step 0.   Install docker   Step 1. Check if  Docker  is installed through the terminal.  This can be done by pressing  CMD+Space  and searching for  Terminal . Run  docker -v  . If the output returns the docker version, Docker is installed correctly.  Step 2. Download and install latest beaconchain updates docker pull gcr.io/prysmaticlabs/prysm/beacon-chain:latest Download and install latest validator updates docker pull gcr.io/prysmaticlabs/prysm/validator:latest Create a docker network docker network create --attachable medalla Start the beaconnode docker run -ti --name beacon-chain --network medalla -v $HOME/prysm:/data  -p 12000:12000/udp -p 13000:13000 gcr.io/prysmaticlabs/prysm/beacon-chain:latest --datadir=/data --rpc-host=0.0.0.0 The directory  $HOME/prysm  contains all the beaconchain data and can be accessed through  Finder. Wait  for the beaconnode to be in sync with the blockchain.  This may take a few hours and you will see the following message: INFO initial-sync: Synced up to slot XXXXX  Step 3. Create ETH2 Keys Open a  new Terminal  window and run: docker run -it -v $HOME/eth2validator:/data gcr.io/prysmaticlabs/prysm/validator:latest accounts create --keystore-path=/data --password=yourPassword The created Keys are now located in  $HOME/eth2validator  Copy the Raw Transaction Data  and go to the  participation page . Some of the instructions on the participation page will be ignored because they are not required anymore.  Follow the steps below to get Goerli ETH and to deposit them   to activate your validator. If you cannot get any Goerli ETH through the participation page, join the  Prysm Discord  channel. Step 4. Start the validator Open a  new Terminal  window and run: docker run -ti --name validator --network medalla -v $HOME/eth2validator:/data gcr.io/prysmaticlabs/prysm/validator:latest --keystore-path=/data --datadir=/data --password=yourPassword --beacon-rpc-provider=beacon-chain:4000 Step 5. Track your validator performance on  beaconcha.in  with your public key (orange).  Once the blockchain recognises the deposit, the  beaoncha.in  explorer will allow you to track the validator more accurately. Wait for the inclusionSlot (red) to be reached. Once the blockchain has processed this slot, you will be staking! The Slot number can be tracked  here .  Running multiple validators  Repeat  Step 3.  and  create more keys  into the same directory.   Use the same password for all keys. Copy the  Raw Transaction Data  for each validator, re-do the process on the  participation page  and deposit for each of them. Once the system has received all deposits, you can just start a single validator \"window\", and it will use  all  of the created keys (=multiple validators). For further assistance, please join the Prysmatic Labs Discord  channel .  Previous Run a Slasher using prysm.sh Next Prysm Client - Windows Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Beaconnode & validator using prysm.sh (recommended)", "html_url": "https://kb.beaconcha.in/archive/outdated-prysm-client-windows/macos-prysm/run-with-macos-using-prysm.sh", "body": "Beaconnode & validator using prysm.sh (recommended)   Official  PrysmaticLabs Docs  Step 0. Install Homebrew Check if  Homebrew  is installed through the terminal.  This can be done by pressing  CMD+Space  and searching for  Terminal . Run  brew help  If the output is  command not found ,  Homebrew  needs to be installed, and if it matches the picture below  skip to Step 1.   In order to  install Homebrew  use the following code:  /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" Step 1. Install GPG  brew install gnupg Create the prysm directory:  mkdir prysm Enter the prysm directory:  cd prysm Get the prysm.sh script and make it executable:  curl https://raw.githubusercontent.com/prysmaticlabs/prysm/master/prysm.sh --output prysm.sh && chmod +x prysm.sh  Step 2. Start the beaconnode Drag and drop the  prysm.sh  file into the  Terminal  window and add:  beacon-chain --datadir=$HOME/prysm The directory  $HOME/prysm  contains all the beaconchain data and can be accessed through  Finder. Wait  for the beaconnode to be in sync with the blockchain.  This may take a few hours and you will see the following message: INFO initial-sync: Synced up to slot XXXXX  Step 3. Create ETH2 Keys Drag and drop the  prysm.sh  file into  a new(!)   Terminal  window and add:     validator accounts create --keystore-path=$HOME/prysm --password=yourPassword   The created keys are now located in  $HOME/prysm Copy the Raw Transaction Data  and go to the  participation page . Some of the instructions on the participation page will be ignored because they are not required anymore.  Follow the steps below to get Goerli ETH and to deposit them   to activate your validator. If you cannot get any Goerli ETH through the participation page, join the  Prysm Discord  channel. Step 4. Start the validator Drag and drop the  prysm.sh  file into  a new(!)   Terminal  window and add:   validator --keystore-path=$HOME/prysm --password=yourPassword  Step 5. Track your validator performance on  beaconcha.in  with your public key (orange).  Once the blockchain recognises the deposit, the  beaoncha.in  explorer will allow you to track the validator more accurately. Wait for the inclusionSlot (red) to be reached. Once the blockchain has processed this slot, you will be staking! The Slot number can be tracked  here . Running multiple validators  Repeat  Step 3.  and  create more keys  into the same directory.   Use the same password for all keys. Copy the  Raw Transaction Data  for each validator, re-do the process on the  participation page  and deposit for each of them. Once the system has received all deposits, you can just start a single validator \"window\", and it will use  all  of the created keys (=multiple validators). For further assistance, please join the Prysmatic Labs Discord  channel . Previous macOS Next Run a Slasher using prysm.sh Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Run a Slasher using prysm.sh", "html_url": "https://kb.beaconcha.in/archive/outdated-prysm-client-windows/macos-prysm/slasher-windows-macos-prysm", "body": "Run a Slasher using prysm.sh General The slasher's purpose is to find malicious validators  in the Ethereum 2.0 network  and report slashable offenses to the beacon-node.    How does the slasher work? The  slasher is its own entity  but requires a beacon-node to receive attestations. To find malicious activity by validators, the slashers iterates through all received attestations until a  slashable offense  is found. Found slashings are broadcasted to the network and the next block proposer adds the proof to the block. The block proposer get the reward for slashing - not the whistleblower(=Slasher). Run a slasher  Make sure your  beacon-node  is  in sync .  If you need to run a beacon-node and validator,  here is a guide for Windows  and  here for macOS .   Step 1. Drag and drop the  prysm.sh  file into the  Terminal  window and add: slasher  --datadir=$HOME/prysm  That's it!  The slasher now iterates through all attestations and sends proof to the detection service.   Debug mode enabled with  --verbosity=debug For  selfish  slashing, add  --disable-broadcast-slashings  to the beaconnode.   Previous Beaconnode & validator using prysm.sh (recommended) Next Beaconnode & validator using Docker Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Beaconnode & validator using Docker", "html_url": "https://kb.beaconcha.in/archive/outdated-prysm-client-windows/prysm-client-windows/docker-beaconnode-and-validator", "body": "Beaconnode & validator using Docker   Official  PrysmaticLabs Docs  A folder named \"prysm\" in C:\\ needs to be created which will also be the location of the beaconchain data. prysmFolder Step 0. Start Docker, open a  Command Prompt  window and type  docker -v . If Docker is installed correctly, it will return you the Docker Version. If not, please make sure to follow the steps in  Installing Docker on Windows Pro  if you are on the professional version and  Installing Docker on Windows Home  if you are on the home version . If the previous command was successful, run the following code: reg add HKCU\\Console /v VirtualTerminalLevel /t REG_DWORD /d 1   This is not required. By using this command, cosmetics of the command prompt window change. Step 1. Download and install latest beaconchain updates docker pull gcr.io/prysmaticlabs/prysm/beacon-chain:latest dockerPull Download and install latest validator updates docker pull gcr.io/prysmaticlabs/prysm/validator:latest Create a docker network  docker network create --attachable medalla Start the beaconnode docker run -ti --name beacon-chain --network medalla -v c:/prysm:/data -p 12000:12000/udp -p 13000:13000 gcr.io/prysmaticlabs/prysm/beacon-chain:latest --datadir=/data --rpc-host=0.0.0.0 Wait  for your beaconnode to be in sync with the blockchain.  This may take a few hours and you will see the following message: INFO initial-sync: Synced up to slot XXXXX   Step.2 Create ETH2 keys docker run -it -v c:/prysm:/data gcr.io/prysmaticlabs/prysm/validator:latest accounts create --keystore-path=/data --password=yourPassword The output should look like the image below.  If you didn't change  --password=yourPassword  , your validator keys will have  yourPassword  as its password. The newly created keys should be in  C:\\prysm . Make sure they are available. Copy the Raw Transaction Data  and go to the  participation page .  keyCreation Step 3. Some of the instructions on the  participation page  will be ignored because they were not optimized for Windows10 (yet).   Follow the steps below to get Goerli ETH and to deposit them to activate your validator. If you cannot get any Goerli ETH through the participation page, join the  Prysm Discord  channel. Step 4. Open  a new  command prompt window. Start your validator docker run -ti -name validator --network medalla -v c:/prysm:/data gcr.io/prysmaticlabs/prysm/validator:latest --keystore-path=/data --datadir=/data --password=yourPassword --medalla --beacon-rpc-provider=beacon-chain:4000  Step 5. Track your validator performance on  beaconcha.in  with your public key (orange).  Once the blockchain recognises the deposit, the  beaoncha.in  explorer will allow you to track the validator more accurately. Wait for the inclusionSlot (red) to be reached. Once the blockchain has processed this slot, you will be staking! The Slot number can be tracked  here . Validator&beaconcha.in Running multiple validators (voluntarily) Repeat  Step 2.  and  create more keys  into the same directory.   Use the same password for all keys. Copy the  Raw Transaction Data  for each validator, re-do the process on the  participation page  and deposit for each of them. Once the system has received all deposits, you can just start a single validator window, and it will use  all  of the created keys (=multiple validators). For further assistance, please join the Prysmatic Labs Discord  channel . Previous Beaconnode & validator using prysm.bat (recommended) Next Installing Docker on Windows Home Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Beaconnode & validator using prysm.bat (recommended)", "html_url": "https://kb.beaconcha.in/archive/outdated-prysm-client-windows/prysm-client-windows/script-beaconnode-and-validator", "body": "Beaconnode & validator using prysm.bat (recommended)   Official  PrysmaticLabs Docs  Step 0. Create a folder named  prysm  in the  C:\\  directory.  prysmFolder  Step 1. Enter the following code into the  command prompt window : cd C:\\prysm   and then follow up with :   curl https://raw.githubusercontent.com/prysmaticlabs/prysm/master/prysm.bat --output prysm.bat The  prysm.bat  file should appear in the  C:\\prysm  directory.  Step 2.   This Step is not required. By using this command, cosmetics of the command prompt window change. Use the following code: reg add HKCU\\Console /v VirtualTerminalLevel /t REG_DWORD /d 1 \u0000\u0000 Step 3.   Start the beaconnode   Drag and drop the  prysm.bat  file into the command prompt window and add:     beacon-chain --datadir=C:\\prysm Wait  for the beaconnode to be in sync with the blockchain.  This may take a few hours and you will see the following message: INFO initial-sync: Synced up to slot XXXXX  Step 4. Create ETH2 keys Drag and drop the  prysm.bat  file into the command prompt window and add:    validator accounts create --keystore-path=C:\\prysm --password=yourPassword Copy the Raw Transaction Data  and go to the  participation page .  Some of the instructions on the  participation page  will be ignored because they were not optimized for Windows10 (yet).  Follow the steps below to get Goerli ETH and to deposit them to activate your validator. If you cannot get any Goerli ETH through the participation page, join the  Prysm Discord  channel. Step 5. Start the validator Drag and drop the  prysm.bat  file into  a seperate  command prompt window  while the beaconnode is running in a different command prompt window  and add:  validator --keystore-path=C:\\prysm --password=yourPassword  Step 6. Track your validator performance on  beaconcha.in  with your public key (orange).  Once the blockchain recognises the deposit, the  beaoncha.in  explorer will allow you to track the validator more accurately. Wait for the inclusionSlot (red) to be reached. Once the blockchain has processed this slot, you will be staking! The Slot number can be tracked  here .  Running multiple validators  Repeat  Step 4.  and  create more keys  into the same directory.   Use the same password for all keys. Copy the  Raw Transaction Data  for each validator, re-do the process on the  participation page  and deposit for each of them. Once the system has received all deposits, you can just start a single validator window, and it will use  all  of the created keys (=multiple validators). For further assistance, please join the Prysmatic Labs Discord  channel .   Previous Prysm Client - Windows Next Beaconnode & validator using Docker Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Slasher with Windows using prysm.bat", "html_url": "https://kb.beaconcha.in/archive/outdated-prysm-client-windows/prysm-client-windows/slasher-with-windows-using-prysm.bat", "body": "Slasher with Windows using prysm.bat General The slasher's purpose is to find malicious validators  in the Ethereum 2.0 network  and report slashable offenses to the beacon-node.    How does the slasher work? The  slasher is its own entity  but requires a beacon-node to receive attestations. To find malicious activity by validators, the slashers iterates through all received attestations until a  slashable offense  is found. Found slashings are broadcasted to the network and the next block proposer adds the proof to the block. The block proposer get the reward for slashing - not the whistleblower(=Slasher). Run a slasher  Make sure your  beacon-node  is  in sync .  If you need to run a beacon-node and validator,  here is a guide for Windows  and  here for macOS .   Step 1. Drag and drop the  prysm.bat  file into the  Terminal  window and add: slasher  --datadir=$HOME/prysm  That's it!  The slasher now iterates through all attestations and sends proof to the detection service.   Debug mode enabled with  --verbosity=debug For  selfish  slashing, add  --disable-broadcast-slashings  to the beaconnode.   Previous Installing Docker on Windows Pro Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Installing Docker on Windows Home", "html_url": "https://kb.beaconcha.in/archive/outdated-prysm-client-windows/prysm-client-windows/docker-beaconnode-and-validator/installdocker", "body": "Installing Docker on Windows Home Installing Docker on Windows Home Step 0. Make sure you have  Windows10 Home . Since Docker is not available for Windows 10 Home, some workarounds are required and are solved by following this guide. Step 1.  Download Docker  but do not install yet.  Install  Hyper-V  by running the  .bat  file. ( source )  Virtualization  must be enabled ( Guide ) virtualization Step 2. Pretend being a Windows10 Pro user 1. Open the \"Registry Editor\" and go to the following path: Computer\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion   2. Change   EditionID  to  Professional  and  ProductName  to  Windows 10 Pro   3. Immediately  open the downloaded Docker File and  install Docker . registryEditor In case of a  PC restart, shutdown or Docker shutdown , the registry change above needs to be re-entered otherwise Docker will not start. Step 3. Change Docker File sharing settings and create a folder named  \"prysm\"  in that specific directory.  In this case the \"prysm\"-folder has been created in C:\\prysm.   dockerWindows Step.4 Change Docker's default memory to 4GB. dockerMemory Previous Beaconnode & validator using Docker Next Installing Docker on Windows Pro Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "Installing Docker on Windows Pro", "html_url": "https://kb.beaconcha.in/archive/outdated-prysm-client-windows/prysm-client-windows/docker-beaconnode-and-validator/installingdocker", "body": "Installing Docker on Windows Pro Installing Docker on Windows Pro Step 0. Make sure you have  Windows10 Pro . Step 1.  Download Docker .     Virtualization  must be enabled ( Guide )  virtualization Step 2. Change Docker File sharing settings and create a folder named  \"prysm\"  in that specific directory.  In this case the \"prysm\"-folder has been created in C:\\prysm.   dockerWindows Step.4 Change Docker's default memory to 4GB dockerMemory Previous Installing Docker on Windows Home Next Slasher with Windows using prysm.bat Last modified  3yr ago", "labels": ["Documentation"]}, {"title": "What is LayerZero", "html_url": "https://layerzero.gitbook.io/docs/", "body": "What is LayerZero Omnichain communication, interoperability, decentralized infrastructure LayerZero's default oracle will be updated to Google Cloud Oracle as of 9/19/23 , details of which you can find  here . LayerZero is an omnichain interoperability protocol designed for lightweight message passing across chains. LayerZero provides authentic and guaranteed message delivery with configurable trustlessness. Where can I find more information? For the message protocol design, check out the  white paper  found on the  website .  If you are looking for a detailed system architecture explanation, check out the architectures section on the  Endpoint  and the Ultra-Light Node.  Code Examples Learn how to  integrate LayerZero  into your contracts and take a look at our deployed contracts for  Mainnet  and  Testnet  usage. If you want to see some examples to play around head over to  our github . See how to  send a LayerZero message   Next  - Bug Bounty Bug Bounty Program Last modified  11d ago", "labels": ["Documentation"]}, {"title": "Code Examples", "html_url": "https://layerzero.gitbook.io/docs/aptos-guide/code-examples", "body": "Code Examples Take a look at the following MOVE Examples to get started: LayerZero-Aptos-Contract/bridge.move at main  LayerZero-Labs/LayerZero-Aptos-Contract GitHub TokenBridge LayerZero-Aptos-Contract/counter.move at main  LayerZero-Labs/LayerZero-Aptos-Contract GitHub OmniCounter Aptos Guide -  Previous LZApp Modules Next OmniCounter.move Last modified  10mo ago", "labels": ["Documentation"]}, {"title": "LZApp Modules", "html_url": "https://layerzero.gitbook.io/docs/aptos-guide/lzapp-modules", "body": "LZApp Modules We provide some common modules to help build your UAs to let you put more focus on your business logic. These modules provide many useful functions that are commonly used in most UAs. You can use them directly as they are already deployed by LayerZero, or you can copy them to your own modules and modify them to fit your needs. LZApp The LZApp module provides a simple way for you to manage your UA's configurations and handle error messages. 1. Provides entry functions to config instead of calling from app with  UaCapability 2. Allows the app to drop/store the next payload 3. Enables to send a layerzero message with Aptos coin and/or ZRO coin It is very simple to use it, initializing by calling the following in your UA: fun init<UA>(account: &signer, cap: UaCapability<UA>) LayerZero-Aptos-Contract/lzapp.move at main  LayerZero-Labs/LayerZero-Aptos-Contract GitHub LZApp Module LayerZero-Aptos-Contract/remote.move at main  LayerZero-Labs/LayerZero-Aptos-Contract GitHub LZApp Remote Module Previous Receive Messages Next  - Aptos Guide Code Examples Last modified  10mo ago", "labels": ["Documentation"]}, {"title": "Getting Started", "html_url": "https://layerzero.gitbook.io/docs/aptos-guide/master", "body": "Getting Started Developing on LayerZero is as simple as it gets - just implement the  register_ua() ,  send()  and  lz_receive()  interfaces and your app is ready to send messages across connected chains. To get started, check  register_ua() ,  send() and lz_receive() . Or dive right in with a simple code example  here . FAQ Learn answers to  Frequently Asked Questions . Talk to the Team  Twitter   Telegram   Discord   Medium  Official Website  https://layerzero.network/  EVM Guides -  Previous Omnichain Governance Next Register UA Last modified  10mo ago", "labels": ["Documentation"]}, {"title": "UA Custom Configuration", "html_url": "https://layerzero.gitbook.io/docs/aptos-guide/ua-custom-configuration", "body": "UA Custom Configuration User Application contracts may set their own configuration for message library, relayer, oracle, etc. public fun set_config < UA > (     major_version :   u64 ,     minor_version :   u8 ,     chain_id :   u64 ,     config_type :   u8 ,     config_bytes :  vector < u8 > ,     _cap :   & UaCapability < UA > )  public fun set_send_msglib < UA > ( chain_id :   u64 ,  major_version :   u64 ,  minor_version :   u8 ,  _cap :   & UaCapability < UA > )  public fun set_receive_msglib < UA > ( chain_id :   u64 ,  major_version :   u64 ,  minor_version :   u8 ,  _cap :   & UaCapability < UA > )  public fun set_executor < UA > ( chain_id :   u64 ,  version :   u64 ,  executor :  address ,  _cap :   & UaCapability < UA > ) Previous Estimating Message Fees Next  - Ecosystem Relayer Last modified  13d ago", "labels": ["Documentation"]}, {"title": "Bug Bounty Program", "html_url": "https://layerzero.gitbook.io/docs/bug-bounty/bug-bounty-program", "body": "Bug Bounty Program LayerZero has an absolute commitment to continuously evaluating and improving security, to demonstrate this we are pleased to run the largest live bug bounty program across the industry at up to $15M! You can read more about the program and make reports via  Immunefi .    To date LayerZero has awarded almost $1M to white hats that have made disclosures. A separate bug bounty of up to $2M exists specifically covering  The Aptos Bridge , which will in time increase in scope to join the above program. More details on this separate bounty program can be found  here . Previous What is LayerZero Next  - Concepts Messaging Properties Last modified  12d ago", "labels": ["Documentation"]}, {"title": "Oracle", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/oracle", "body": "Oracle Helps secure the network. Each User Application can opt-in to any Oracle LayerZero's default oracle provider will be updated as of 9/19/23 , details of which you can find  here .  The Oracle performs a role in securing LayerZero's messaging protocol by moving data between chains. Each oracle has the task of moving a requested block header from a source chain to a destination chain.  An oracle works in tandem with a  Relayer . Each User Application contract built on LayerZero will work without configuration using defaults, but a UA will also be able to configure its own  Oracle  and  Relayer . Previous Max Proof Cost Estimate Next Default Oracle Updates Last modified  13d ago", "labels": ["Documentation"]}, {"title": "Relayer", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/relayer", "body": "Relayer Relayers perform a critical role in the LayerZero message protocol by delivering messages. Relayers work in tandem with an  Oracle  to transmit messages between chains. By default,  User Applications  will use the LayerZero Relayer. This means you do not need to run your own Relayer. If you want to select a custom Relayer you will need to  set a custom UA configuration . If you wish to learn more about operating and/or building your own Relayer read on. Aptos Guide -  Previous UA Custom Configuration Next Overview Last modified  16d ago", "labels": ["Documentation"]}, {"title": "Advanced", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/advanced", "body": "Advanced Looking to set your UA  configuration ? Check  here  to set a custom  blockConfirmations  and other UA app config values. Previous Set Trusted Remotes Next Development Staging Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Best Practice", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/best-practice", "body": "Best Practice It is highly recommended User Applications implement the  ILayerZeroApplicationConfig . Implementing this interface will provide you with  forceResumeReceive  which, in the worse case can allow the owner/multisig to unblock the queue of messages if something unexpected happens. Instant Finality Guarantee (IFG) Reverting in UA is cumbersome and expensive. It is more efficient to design your UA with IFG such that if a transaction was accepted at source, the transaction will be accepted at the remote. For example, Stargate has a credit management system (Delta Algorithm) to guarantee that if a swap was accepted at source, the destination must have enough asset to complete the swap, hence the IFG.  Tracking the Nonce It is important for UA to keep track of their own nonce (e.g. by events) to correlate the send and receive side transactions. UA at send() side can query the nonce at endpoint.getOutboundNonce interface, and in lzReceive() the inboundNonce is in the arguments. One Action Per Message Try to do only one thing per message. The implication is that if the message was burnt (misconfiguration, bad code etc.. the damage to the state is minimal.  Store Failed Messages If the message execution fails at the destination, try-catch, and store it for future retry. From LayerZero's perspective, the message has been delivered. It is much cheaper and easier for your programs to recover from the last state at the destination chain.  Store a hash of the message payload is much cheaper than storing the whole message.  Gas for Message Types If your app includes multiple message types to be sent across chains, compute a rough gas estimate at the destination chain  per each message type . Your message may fail for the out-of-gas exception at the destination if your app did not instruct the relayer to put extra gas on contract execution. And the UA should enforce the gas estimate on-chain at the source chain to prevent users from inputting too low the value for gas. Address Sanity Check Check the address size according to the source chain (e.g. address size == 20 bytes on EVM chains) to prevent a vector unauthenticated contract call.  Messages Encoding Use type-safe bytes codec. Use custom codec only if you are comfortable with it and your app requires deep optimization.   Previous Failure Revert Messages Next  - EVM Guides LayerZero Omnichain Contracts Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Code Examples", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/code-examples", "body": "Code Examples Take a look at our Solidity Examples repo or some great template code to get you started It is recommended User Applications implement NonblockingLzApp which allow you to easily override two functions to add send + receive functionality to your contracts! GitHub - LayerZero-Labs/solidity-examples: example contracts GitHub LayerZero Solidity Examples npm: @layerzerolabs/solidity-examples npm NPM package to go along with Solidity Examples The primary way to implement LayerZero messaging in your contract is to use LzApp or NonblockingLzApp:   solidity-examples/contracts/lzApp at main  LayerZero-Labs/solidity-examples GitHub There are implementations of Tokens (OFT) and NFTs (ONFT) as well: solidity-examples/contracts/examples at main  LayerZero-Labs/solidity-examples GitHub Previous UA Configuration Lock Next OmniCounter.sol Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Error Messages", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/error-messages", "body": "Error Messages The most common problem: Not sending msg.value when calling send() on the endpoint. See  notes here.   See  here  for how much msg.value to send to cover the message cost. Is your transaction failing on destination with an unhelpful messages like this:    ? Make sure you are sending the message to a destination contract that exists! If you've experimented with custom configuration, review the  docs here  For a description of every possible onchain failure take a look at this  page . Previous ILayerZeroRelayer.sol Next StoredPayload Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Interfaces", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/interfaces", "body": "Interfaces Interfaces to the LayerZero contracts Interfaces for interacting with LayerZero contracts, including the  Endpoint . Previous PingPong.sol Next EVM (Solidity) Interfaces Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "LayerZero Integration Checklist", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/layerzero-integration-checklist", "body": "LayerZero Integration Checklist The checklist below is intended to help prepare a project that integrates LayerZero for an external audit or Mainnet deployment Use the latest version of  solidity-examples  package. Do not copy contracts from LayerZero repositories directly to your project. If your project requires token bridging inherit your token from  OFT  or  ONFT . For new tokens use  OFT  or  ONFT , for bridging existing tokens use  ProxyOFT  or  ProxyONFT . For bridging only between EVM chains use  OFT  and for bridging between EVM and non EVM chains (e.g., Aptos) use  OFTV2 . Do not hardcode LayerZero chain Ids. Use admin restricted setters instead. Do not hardcode address zero ( address(0) ) as  zroPaymentAddress  when estimating fees and sending messages. Pass it as a parameter instead. Do not hardcode  useZro  to  false  when estimating fees and sending messages. Pass it as a parameter instead. Do not hardcode zero bytes ( bytes(0) ) as  adapterParamers . Pass them as a parameter instead. Make sure to test the amount of gas required for the execution on the destination. Use custom adapter parameters and specify minimum destination gas for each cross-chain path when the default amount of gas ( 200,000 ) is not enough. This requires whoever calls the send function to provide the adapter params with a destination  gas >= amount  set in the  minDstGasLookup  for that chain. So that your users don't run into failed messages on the destination. It makes it a smoother end-to-end experience for all. Do not add  requires  statements that repeat existing checks in the parent contracts. For example,  lzReceive  function in  LzApp  contract checks that the message sender is LayerZero endpoint and the  scrAddress  is a trusted remote, do not perform the same checks in  nonblockingLzReceive . If your contract derives from  LzApp , do not call   lzEndpoint.send  directly, use  _lzSend . For ONFTs that allow minting a range of tokens on each chain, make the variables that specify the range  (e.g.  startMintId  and  endMintId)  immutable.   Previous 1155 Next  - EVM Guides LayerZero Tooling Last modified  7mo ago", "labels": ["Documentation"]}, {"title": "LayerZero Omnichain Contracts", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/layerzero-omnichain-contracts", "body": "LayerZero Omnichain Contracts Want to send your tokens cross chain? OFT   Omnichain Fungible Tokens  enable a token to be sent across current (and even future) chains! There is no requirement for liquidity, and there are no fees! ONFT  Omnichain Non Fungible Tokens  allow your NFT project to send tokens across chains. See the  Lil Pudgies bridge  in action!  EVM Guides -  Previous Best Practice Next OFT Last modified  7mo ago", "labels": ["Documentation"]}, {"title": "LayerZero Tooling", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/layerzero-tooling", "body": "LayerZero Tooling Configuration tools around setting up your UA Config and Wire Up Config A set of common tasks for contracts integrating LayerZero Installation $  npm   install  @layerzerolabs/ua-utils The plugin depends on  @nomiclabs/hardhat-ethers , so you need to import both plugins in your  hardhat.config.js : require ( \"@nomiclabs/hardhat-ethers\" ); require ( \"@layerzerolabs/ua-utils\" ); Or if you are using TypeScript, in your  hardhat.config.ts : import   \"@nomiclabs/hardhat-ethers\" ; import   \"@layerzerolabs/ua-utils\" ; UA Config This config is used to  Lock in UA Configuration . To use this script please fill in your Application Configuration according to your applications needs. Wire Up Configuration This config can be used to set the following on your UA contract:  function setFeeBp(uint16, bool, uint16) function setDefaultFeeBp(uint16) function setMinDstGas(uint16, uint16, uint) function setUseCustomAdapterParams(bool) function setTrustedRemote(uint16, bytes) To use this script please fill in your Wire Up Configuration according to your applications needs. EVM Guides -  Previous LayerZero Integration Checklist Next UA Configuration Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Getting Started", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/master", "body": "Getting Started Developing on LayerZero is as simple as it gets - just implement the  send()  and  lzReceive()  interfaces and your app is ready to send messages across connected chains. To get started, check  send() and  lzReceive() . Or dive right in with a simple code example  here . FAQ Learn answers to  Frequently Asked Questions . User Applications User Application contracts built on LayerZero send secure messages between different blockchains! Here is an example of a  OmnichainFungibleToken (OFT)  Talk to the Team  Twitter   Telegram   Discord  (join  dev-announcements  for updates!)  Medium  Official Website  https://layerzero.network/  Concepts -  Previous FAQ Next Send Messages Last modified  10mo ago", "labels": ["Documentation"]}, {"title": "Omnichain Governance", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/omnichain-governance", "body": "Omnichain Governance LayerZero enables multichain governance solutions. All votes. All chains. Recently, the team produced contracts for omnichain governance for  Uniswap . Take a look! GitHub - LayerZero-Labs/omnichain-governance-executor GitHub Previous Wire Up Configuration Next  - Aptos Guide Getting Started Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "UA Custom Configuration", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/ua-custom-configuration", "body": "UA Custom Configuration User Application contracts may set their own configuration for block confirmation, send version, relayer, oracle, etc. When a UA wishes to configure their own block confirmations both the  outboundBlockConfirmations  of the source  and  the  inboundBlockConfirmations  of the destination must be configured and match. How to Configure A User Application (UA) can use non-default protocol settings, and to do so it must implement the interface  ILayerZeroUserApplicationConfig . The UA may then manually update its  ApplicationConfig  . See examples below as well as the  CONFIG_TYPES .  Set: Inbound Proof Library   1   let  config  =  ethers . utils . defaultAbiCoder . encode (     2   [ \"uint16\" ],   3   [ inboundProofLibraryVersion ]   4   )   5   await  lzEndpoint . setConfig (   6   0 ,   7      dstChainId ,   8   CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION ,   9      config 10   ) Set: Inbound Block Confirmations   1   let  config  =  ethers . utils . defaultAbiCoder . encode (   2   [ \"uint16\" ],   3   [ 42 ]   4   )   5   await  lzEndpoint . setConfig (   6   0 ,   7      dstChainId ,   8   CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS ,   9      config 10   ) Set: Relayer   1   let  config  =  ethers . utils . solidityPack (   2   [ \"address\" ],   3   [ relayerAddr ]   4   )   5   await  lzEndpoint . setConfig (   6   0 ,   7      dstChainId ,   8   CONFIG_TYPE_RELAYER ,   9      config  10   ) Set: Outbound Proof Type/LibraryVersion   1   let  config  =  ethers . utils . defaultAbiCoder . encode (   2   [ \"uint16\" ],   3   [ outboundProofType ]   4   )   5   await  lzEndpoint . setConfig (   6   0 ,   7      dstChainId ,   8   CONFIG_TYPE_OUTBOUND_PROOF_TYPE ,   9      config 10   ) Set: Outbound Block Confirmations   1   let  config  =  ethers . utils . defaultAbiCoder . encode (   2   [ \"uint16\" ],   3   [ 17 ]   // outbound block confirmations    4   )   5   await  lzEndpoint . setConfig (   6   0 ,   7      dstChainId ,   8   CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS ,   9      config 10   ) Set: Oracle Oracle settings are configured per channel pathway, meaning UAs who want to lock Oracle configs will need to call  setConfig  per chain pairing.   1   let  config  =  ethers . utils . defaultAbiCoder . encode (   2   [ \"address\" ],   3   [ oracleAddr ]   4   )   5   await  lzEndpoint . setConfig (   6   0 ,   7      dstChainId ,   8   CONFIG_TYPE_ORACLE ,   9      config 10   ) Config Types CONFIG_TYPE_INBOUND_PROOF_LIBRARY_VERSION 1 CONFIG_TYPE_INBOUND_BLOCK_CONFIRMATIONS 2 CONFIG_TYPE_RELAYER 3 CONFIG_TYPE_OUTBOUND_PROOF_TYPE 4 CONFIG_TYPE_OUTBOUND_BLOCK_CONFIRMATIONS 5 CONFIG_TYPE_ORACLE 6 Previous NonblockingLzApp Next UA Configuration Lock Last modified  10d ago", "labels": ["Documentation"]}, {"title": "FAQ", "html_url": "https://layerzero.gitbook.io/docs/faq/faq-1", "body": "FAQ Frequently Asked Questions What is LayerZero? LayerZero enables messages to be sent between blockchains. How do I send a cross-chain message? See example contracts  here  and details on sending messages  here . What blockchains are supported? See a table of  supported blockchains . The team is always working to add more chains, so check back frequently! What is a User Application? A  User Application (UA)  is any contract that uses LayerZero to send & receive messages between blockchains.  What is an Endpoint? The deployed contract on which your User Application calls  send()  to transmit messages and set its own UA configuration. Heres is the list of  endpoint addresses  with which you may interact with. What is an Ultra Light Node? The UltraLightNode.sol is a smart contract at the heart of the message protocol, sitting behind the Endpoint, it enables all the features of LayerZero. In the future, UAs will benefit from new versions of the Ultra Light Node, the most recent version of the ULN is v2. What is an Oracle? An Oracle is required by each User Application and assists in sending messages. User Applications use the default Oracle automatically so you don't need you configure it, but you can if you want to. What is a Relayer? User Applications use the LayerZero Relayer by default, without additional configuration. However, a  Relayer  is required by each  User Application  and plays a crucial role in delivering cross chain messages. If desirable, User Applications may be configured to use a different relayer.   Technical Section Two Modes: Blocking and Nonblocking: LayerZero UserApplications can choose to be Blocking or Nonblocking (see the  examples ).  All messages are nonce-ordered, which means they will arrive from a source chain & source UA address in the order they are sent.  By default, messages will be queued if there is an out-of-gas, or logical error on the destination. If contract developers wish to avoid the default blocking mechanism, instead use NonblockingLzApp which will continue with the flow of messages, a design which stores out-of-gas messages on the destination to be retried (by anyone) at anytime. Can LayerZero users enjoy the benefit of any future optimized proof technology, e.g. ZKP based? Yes, LayerZero has the ability to add new Messaging Libraries. LayerZero Labs will keep bringing the best research into production. Existing users can easily perform a library migration on-chain. Concepts -  Previous Glossary Next  - EVM Guides Getting Started Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Future-Proof Architecture", "html_url": "https://layerzero.gitbook.io/docs/faq/future-proof-architecture", "body": "Future-Proof Architecture Immutable Endpoint  LayerZero Endpoint is the only interface for a User Application (UA). The Endpoint allows UAs to configure the Messaging Library used for sending and receiving verified messages, and guarantees the message delivering ordering across all messaging libraries.  Send() : the message will be sent through the endpoint first and then redirected to the UA-configured Messaging Library  Receive() : the message will be verified at the Messaging Library first then forwarded to the endpoint and eventually delivered to the UA.  Perpetual Messaging All Messaging Libraries, once deployed, will be in service in perpetuity, which means that no entity, including the LayerZero Labs multi-sig, can de-register any Messaging Library or change the Messaging Library configuration of a UA, i.e. if the UA has specified a Messaging Library to use, no entity can stop the messaging flow.  Continuous Improvement  LayerZero can deploy new Messaging Libraries for security and performance optimization (e.g. more efficient proof technologies). This allows LayerZero to bring the best research into production and support the system with the best technology. The UA interface won't change and UA can simply migrate to any new version with ease. For each Messaging Library (e.g. Ultra-Light Node), LayerZero can deploy new proof validation libraries for security or performance reasons.  Immutable UA Configuration If the UA has specified a validation library to use, no entity can change the configuration. Concepts -  Previous LayerZero Endpoint Next  - Concepts Glossary Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Glossary", "html_url": "https://layerzero.gitbook.io/docs/faq/glossary", "body": "Glossary This glossary defines and explains many LayerZero concepts and terminology. User Application (UA) A User Application (UA) is any contract that uses LayerZero to  send  &  receive  messages between blockchains. We define UA as a tuple ( chainId ,  contractAddress ) the UA that  send()  the message at the source chain as  srcUA  ( srcChain ,  srcAddress ) the UA that  lzReceive()  at the destination chain as  dstUA  ( dstChain ,  dstAddress ) In LayerZero's perspective,  srcUA  and  dstUA  are different, though they might be the same entity.  Ultra-Light Node (ULN) ULN is a messaging protocol, firstly introduced in the LayerZero white paper, that allows lightweight cross-chain messaging with configurable trustlessness on the specification of Oracle and Relayer, the two roles that are relaying block information and transaction proof across chains.  Oracle A contract address that can be notified to move a block header. What is a Relayer? Any process that delivers a transaction proof in the LayerZero system. Messaging Library The contract that handles the message payload packing on the source chain and verification on the destination chain. Ultra-Light Node is an implementation of Messaging Library Proof Library The contract that verifies the validity of a proof. Merkle Patricia Tree inclusion proof is an implementation of Proof Library. Concepts -  Previous Future-Proof Architecture Next  - Concepts FAQ Last modified  2mo ago", "labels": ["Documentation"]}, {"title": "LayerZero Endpoint", "html_url": "https://layerzero.gitbook.io/docs/faq/layerzero-endpoint", "body": "LayerZero Endpoint Messages in LayerZero are sent and received by LayerZero  Endpoints , which handle message transmission, verification, and receipt; these endpoints consist of two components: a collection of versioned  messaging libraries , and a  proxy  to route messages to the correct library version. When a message arrives at an endpoint, the endpoint selects the User Application configured library version to handle the message. The endpoint keeps all message states across versions and this allows libraries to be easily upgraded for fixes or optimizations.   Messaging Library Versioning UAs can specify a particular messaging library version to tightly control messaging behaviors, or alternatively specify  DEFAULT_VERSION  to take advantage of library auto-upgrade. Note that the library versions on the  send()  and  lzReceive()  sides must be the same for an  INFLIGHT  message to be delivered. Ultra-Light Node is the V1 of messaging libraries. interface  ILayerZeroEndpoint.sol    // @notice set the send() LayerZero messaging library version to _version   // @param _version - new messaging library version   function   setSendVersion ( uint16  _version )   external ;    // @notice set the lzReceive() LayerZero messaging library version to _version   // @param _version - new messaging library version   function   setReceiveVersion ( uint16  _version )   external ;     // @notice get the send() LayerZero messaging library version   // @param _userApplication - the contract address of the user application   function   getSendVersion ( address  _userApplication )   external   view   returns   ( uint16 );    // @notice get the lzReceive() LayerZero messaging library version   // @param _userApplication - the contract address of the user application   function   getReceiveVersion ( address  _userApplication )   external   view   returns   ( uint16 ) Messaging Library Migration The LayerZero endpoint has only implemented one library version (Ultra-Light Node). We will release guides for migration when we have deployed any new messaging library. Concepts -  Previous Messaging Properties Next  - Concepts Future-Proof Architecture Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Messaging Properties", "html_url": "https://layerzero.gitbook.io/docs/faq/messaging-properties", "body": "Messaging Properties Message State Messages are sent from the  User Application (UA)  at source  srcUA   to the UA at the destination  dstUA . Once the message is received by  dstUA , the message is considered delivered (transitioning from  INFLIGHT  to either  SUCCESS  or  STORED ) Message State  Cases INFLIGHT After a message is sent SUCCESS A1:  dstUA  success OK() A2:  dstUA  fails with caught error/exception STORED B1:  dstUA  fails with uncaught error/exception // message handling at destination chain  try  ILayerZeroReceiver ( _dstAddress ). lzReceive { gas :  _gasLimit }( _srcChainId ,  _srcAddress ,  _nonce ,  _payload )   {   // message state becomes SUCCESS }  catch  {   // message state becomes STORED   emit   PayloadStored ( _srcChainId ,  _srcAddress ,  _dstAddress ,  _payload ); } Case A2:  dstUA  is expected to store the message in their contract to be retried (LayerZero will not store any successfully delivered messages).  dstUA  is expected to monitor and retry  STORED  messages on behalf of its users.  Case B1:  dstUA  is expected to gracefully  handle all errors/exceptions  when receiving a message, and any uncaught errors/exceptions (including out-of-gas) will cause the message to transition into  STORED . A  STORED  message will block the delivery of any future message from  srcUA  to all  dstUA  on the same destination chain and can be retried until the message becomes  SUCCESS .  dstUA  should implement a handler to transition the stored message from  STORED  to  SUCCESS . If a bug in  dstUA  contract results in an unrecoverable error/exception, LayerZero provides a last-resort interface to force resume message delivery,  only  by the  dstUA  contract.  Message Ordering LayerZero provides ordered delivery of messages from a given sender to a destination chain, i.e.  srcUA ->  dstChain . In other words, the message order nonce is shared by all  dstUA  on the same  dstChain . That's why a  STORED  message  blocks  the message pathway from  srcUA  to all  dstUA  on the same destination chain.  If it isn't necessary to preserve the sequential nonce property for a particular  dstUA  the sender must add the nonce into the payload and handle it end-to-end within the UA.  UAs can implement a  non-blocking pattern  in their contract code.  Extensibility  Message Adapter Parameters LayerZero allows UAs to add arbitrary transaction params in the  send()  function, providing a high level of flexibility and opening up opportunities for a diverse set of 3rd party plugins This is implemented as an unreserved byte array parameter to the send() function, with UAs allowed to write any additional data necessary into that parameter. We recommend that UAs leave some degree of configurability for the extra parameters to allow for feature extensions. One great feature of  _adapterParams  is performing an  Airdrop . Patterns Non-Reentrancy LayerZero Endpoint has a non-reentrancy guard for both the  send()  and  receive() , respectively. In other words, both  send()  and  receive()  can not call themselves on the same chain. UAs  should not  rely on LayerZero to perform the non-reentrancy check. However, UAs can query the endpoint to see if the endpoint    isSendingPayload()  or  isReceivingPayload()   for finer-grained reentrancy control.  Message Chaining UAs can call  send()  in the  receive()  calls on the same chain. Example applications for calling  send()  in the  receive()  include (e.g.  Ping Pong ): the UA at the source chain wants a message receipt  (Chain A -> Chain B -> Chain A) the UA at the destination reroutes the message (Chain A -> Chain B -> Chain C)   function   lzReceive ( uint16  _srcChainId ,   bytes   memory  _fromAddress ,   uint64 ,   /*_nonce*/   bytes   memory  _payload )   external  override  {   ...   // message chaining         endpoint . send { value :  messageFee }(     ...   );   } However, the fee for sending messages on another chain is not observable on-chain. UAs would need to create some fee estimate heuristics. Optionally, user apps can store the chained message and then resend them with another transaction.  Multi-Send UAs can send multiple messages in one transaction at the source chain. The endpoint non-reentrancy will not block this pattern.    function   sendFirstMessage (   uint  gasAmountForDst ,   uint16 []   calldata  chainIds ,   bytes []   calldata  dstAddresses )   external   payable   {   ...   for ( uint  i  =   0 ;  i  <  chainIds . length ;  i ++ ){             endpoint . send { value :  fee }( chainIds [ i ],  dstAddresses [ i ],  messageString ,  msg . sender ,   address ( 0x0 ),  _relayerParams );   }   }   Bug Bounty -  Previous Bug Bounty Program Next  - Concepts LayerZero Endpoint Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Audits", "html_url": "https://layerzero.gitbook.io/docs/technical-reference/audits", "body": "Audits LayerZero Labs has commissioned 35+ audits with the most recent audits on  Github . Nearly all code written by LayerZero Labs since inception have been immutable smart contracts audited externally and rigorously reviewed internally at least 3+ times each. GitHub - LayerZero-Labs/Audits GitHub LayerZero Labs Audit Repository Previous Deprecated Libraries Last modified  7mo ago", "labels": ["Documentation"]}, {"title": "LayerZero Interfaces", "html_url": "https://layerzero.gitbook.io/docs/technical-reference/interfaces", "body": "LayerZero Interfaces Developers may need one or more of these interfaces when working with LayerZero contracts. https://github.com/LayerZero-Labs/LayerZero/tree/main/contracts/interface github.com Ultra-Light Node Interfaces See our contract interfaces  here . Previous Multisig Wallets Next  - Technical Reference SDK Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Mainnet", "html_url": "https://layerzero.gitbook.io/docs/technical-reference/mainnet", "body": "Mainnet LayerZero mainnet deployments. The  Mainnet Contract Addresses  are all you need to start sending messages. LayerZero endpoints are deployed onto a variety of chains, including the primary L1s and possibly even some experimental chains! To start sending messages here is an outline what you'll need: Access to JSON-RPC provider data, for the chains you want to use (or your own nodes) ETH, BNB, AVAX, etc.. for the chains you need Hardhat project (perhaps check out our solidity-examples repo) Good vibes Previous Default Config Next Mainnet Addresses Last modified  1mo ago", "labels": ["Documentation"]}, {"title": "Proof Types", "html_url": "https://layerzero.gitbook.io/docs/technical-reference/proof-types", "body": "Proof Types Proof Type 1 - Merkle Patricia Tree (MPT) inclusion proof. Technical Reference -  Previous SDK Next Deprecated Libraries Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "SDK", "html_url": "https://layerzero.gitbook.io/docs/technical-reference/sdk", "body": "SDK Coming Soon SDK for Testnet / Mainnet Deployment Addresses. Technical Reference -  Previous LayerZero Interfaces Next  - Technical Reference Proof Types Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Testnet", "html_url": "https://layerzero.gitbook.io/docs/technical-reference/testnet", "body": "Testnet LayerZero testnet is a deployed set of Endpoints on the chains we operate on. The  Testnet Contract Addresses  are all you need to start sending messages. LayerZero endpoints are deployed onto a variety of chains, including the primary L1s and possibly even some experimental chains! To start sending messages here is an outline what you'll need: Access to JSON-RPC provider data, for the chains you want to use (or your own nodes) Test ether Hardhat project (perhaps check out our solidity-examples repo) Good vibes Previous zkLightClient Addresses Next Testnet Addresses Last modified  13d ago", "labels": ["Documentation"]}, {"title": "Estimating Message Fees", "html_url": "https://layerzero.gitbook.io/docs/aptos-guide/code-examples/estimating-message-fees", "body": "Estimating Message Fees Get the quantity of native gas token to pay to send a message If you want to know how much  AptosCoin  to pay for the message, you can call the Endpoint's  quote_fee() to get the fee tuple (native_fee (in coin), layerzero_fee (in coin)). public fun  quote_fee (     ua_address :  address ,     dst_chain_id :   u64 ,     payload_size :   u64 ,     pay_in_zro :   bool ,     adapter_params :  vector < u8 > ,     msglib_params :  vector < u8 > ):   ( u64 ,   u64 ) Previous OmniCounter.move Next  - Aptos Guide UA Custom Configuration Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "OmniCounter.move", "html_url": "https://layerzero.gitbook.io/docs/aptos-guide/code-examples/messagecounter.move", "body": "OmniCounter.move A LayerZero User Application example to demonstrate message sending. The OmniCounter OmniCounter is a contract that increments a counter -- but there's a twist. This OmniCounter increments the counter on another chain. The Details To send cross chain messages, contracts will use an  endpoint  to  send()  from the source chain and  lz_receive()  to receive the message on the destination chain. LayerZero-Aptos-Contract/counter.move at main  LayerZero-Labs/LayerZero-Aptos-Contract GitHub Aptos Guide -  Previous Code Examples Next Estimating Message Fees Last modified  10mo ago", "labels": ["Documentation"]}, {"title": "Register UA", "html_url": "https://layerzero.gitbook.io/docs/aptos-guide/master/how-to-send-a-message", "body": "Register UA Before sending messages on LayerZero you need to register your UA. public fun register_ua < UA > ( account :   & signer ):   UaCapability < UA > The  UA  type is an identifier of your application. You can use any type as  UA , e.g.  0x1::MyApp::MyApp  as a  UA .  Only one  UA  is allowed per address. That means there won't be a case where two UA  types share the same address. When calling  register_ua() , you will get a  UaCapability<UA>  returned. It is the resource for authenticating any LayerZero functions, such as sending messages and setting configurations. Aptos Guide -  Previous Getting Started Next Send Messages Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Send Messages", "html_url": "https://layerzero.gitbook.io/docs/aptos-guide/master/how-to-send-a-message-1", "body": "Send Messages Use LayerZero to send a bytes payload from one chain to another. To send a message, call the Endpoint's send() function. Initiate the send() function  in your contracts to send a cross chain message.  public fun send < UA > (     dst_chain_id :   u64 ,     dst_address :  vector < u8 > ,     payload :  vector < u8 > ,     native_fee :   Coin < AptosCoin > ,     zro_fee :   Coin < ZRO > ,     adapter_params :  vector < u8 > ,     msglib_params :  vector < u8 > ,     _cap :   & UaCapability < UA > ):   ( u64 ,   Coin < AptosCoin > ,   Coin < ZRO > ) You can send any message ( payload ) to any address on any chain and pay fee with  AptosCoin . So far we only support  AptosCoin  as fee.  ZRO  coin will be supported to pay the protocol fee in the future. The  msglib_params  is for passing parameters to the message libraries. So far, it is not used and can be empty. Estimating Message Fees If you want to know how much to give to the send() function to pay for you message please refer to this  section on estimating fees . Previous Register UA Next Receive Messages Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Receive Messages", "html_url": "https://layerzero.gitbook.io/docs/aptos-guide/master/receive-messages", "body": "Receive Messages Destination contracts must implement lzReceive() to handle incoming messages The UA has to provide a public entry function  lz_receive()  for executors to receive messages from other chains and execute your business logic. public entry fun lz_receive < Type1 ,   Type2 ,   ... > ( src_chain_id :   u64 ,  src_address :  vector < u8 > ,  payload :  vector < u8 > ) The  lz_receive()  function has to call the Endpoint's  lz_receive()  function to verify the payload and get the nonce. // endpoint's lz_receive() public fun lz_receive < UA > (     src_chain_id :   u64 ,     src_address :  vector < u8 > ,     payload :  vector < u8 > ,     _cap :   & UaCapability < UA > ):   u64 When an executor calls your UA's  lz_receive() , it needs to know what generic types  <Type1, Type2, ...>  to use for consuming the payload. So if your UA needs those types, you also need to provide a public entry function  lz_receive_types()  to return the types. Make sure to assert the provided types against the payload. For example, if the payload indicates coinType A, then the provided coinType must be A. public fun  lz_receive_types ( src_chain_id :   u64 ,  src_address :  vector < u8 > ,  payload :  vector < u8 > ):  vector < TypeInfo > Blocking Mode LayerZero is by BLOCKING by default, which means if the message payload fails in the  lz_receive()  function, your UA will be blocked and cannot receive next messages from that path until the failed message is received successfully. If this happens, you may have to drop the message or store it and retry later. We provide  LZApp Modules  to help you handle it. Previous Send Messages Next  - Aptos Guide LZApp Modules Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Chainlink Oracle", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/oracle/chainlink-oracle", "body": "Chainlink Oracle Contract Addresses to use Chainlink with LayerZero To use the Chainlink oracle with your LayerZero UserApplication, configure your app with the addresses below. Chainlink Oracle Addresses Ethereum:  0x150A58e9E6BF69ccEb1DBA5ae97C166DC8792539 BNB:  0x150A58e9E6BF69ccEb1DBA5ae97C166DC8792539 Avalanche:  0x150A58e9E6BF69ccEb1DBA5ae97C166DC8792539 Polygon:  0x150A58e9E6BF69ccEb1DBA5ae97C166DC8792539 Arbitrum:  0x150A58e9E6BF69ccEb1DBA5ae97C166DC8792539 Optimism:  0x150A58e9E6BF69ccEb1DBA5ae97C166DC8792539 Fantom:  0x150A58e9E6BF69ccEb1DBA5ae97C166DC8792539 There is some additional information for Chainlink that can be found  here .    Participating Node Operators Currently these Chainlink nodes provide support and redundancy for the Chainlink Oracle   DexTrac Chainlayer LinkForest LinkPool  Previous TSS Oracle Next Overview of Polyhedra zkLightClient Last modified  16d ago", "labels": ["Documentation"]}, {"title": "Configuring Custom Oracle", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/oracle/configuring-custom-oracle", "body": "Configuring Custom Oracle Learn how to seamlessly set up and integrate a new Oracle for your User Application (UA). This tutorial provides a step-by-step guide on setting a new Oracle for your User Application (UA). Understanding Oracle Configuration In LayerZero, Oracle configurations help enable smooth messaging across chain pathways. A chain pathway represents a connected route that utilizes both the Oracle and Relayer to facilitate message routing between blockchains. 1. Consistent Oracle Configuration:  It's essential to ensure that the same Oracle provider is present on both the source and destination chains. This uniformity guarantees that messages can be reliably sent and received in both directions on the pathway. 2. Payment and Delivery Logic:  If you're paying Oracle A on the source chain, you'd expect Oracle A to also handle the delivery on the destination chain. Hence, if Oracle A is available on both chains, it can be used in both directions. On the other hand, if Oracle A is only present on one chain, you'd need to opt for an alternative that's supported on both chain directions. Remember, the objective is to ensure that the Oracle setup supports the chain pathways, as they are the conduits for message routing. This is vital for efficient, error-free cross-chain communication. Prerequisites You should have an LZApp to start with that's already working with default settings. While we use  OmniCounter  in this tutorial, any app that inherits  LZApp.sol  (including the OFT and ONFT standards) can be used. In order to set a new Oracle, all a user will need to do is call the  setConfig  function on Chain A and Chain B. Below is a simple example for how to set your Oracle, using the Ethereum Goerli and Optimism Goerli Testnets.  Example: Setting an Oracle using Ethereum Goerli and Optimism Goerli Testnets 1. Deploying OmniCounter After deploying OmniCounter on both Goerli and OP-Goerli, ensure that: You've correctly called  setTrustedRemote . The  incrementCounter  function works by default on both contracts. // SPDX-License-Identifier: MIT  pragma   solidity   ^ 0.8.0 ; pragma  abicoder v2 ;  import   \"https://github.com/LayerZero-Labs/solidity-examples/blob/e43908440cefdcbc93cd8e0ea863326c4bd904eb/contracts/lzApp/NonblockingLzApp.sol\" ;  /// @title A LayerZero example sending a cross chain message from a source chain to a destination chain to increment a counter contract   OmniCounter   is  NonblockingLzApp  {   bytes   public   constant  PAYLOAD  =   \"\\x01\\x02\\x03\\x04\" ;   uint   public  counter ;    constructor ( address  _lzEndpoint )   NonblockingLzApp ( _lzEndpoint )   {}    function   _nonblockingLzReceive ( uint16 ,   bytes   memory ,   uint64 ,   bytes   memory )   internal  override  {         counter  +=   1 ;   }    function   estimateFee ( uint16  _dstChainId ,   bool  _useZro ,   bytes   calldata  _adapterParams )   public   view   returns   ( uint  nativeFee ,   uint  zroFee )   {   return  lzEndpoint . estimateFees ( _dstChainId ,   address ( this ),  PAYLOAD ,  _useZro ,  _adapterParams );   }    function   incrementCounter ( uint16  _dstChainId )   public   payable   {   _lzSend ( _dstChainId ,  PAYLOAD ,   payable ( msg . sender ),   address ( 0x0 ),   bytes ( \"\" ),  msg . value );   } } 2. Setting a New Oracle To modify your UA contracts, you'll need to invoke the  setConfig  function. This can be done directly from a verified block explorer or using scripting tools. In this tutorial, we'll demonstrate using Remix.  Here's how to set the Oracle for the Goerli OmniCounter using the Goerli TSS Oracle address,  0x36ebea3941907c438ca8ca2b1065deef21ccdaed :   1   let  config  =  ethers . utils . defaultAbiCoder . encode (   2   [ \"address\" ],     3   [ \"0x36ebea3941907c438ca8ca2b1065deef21ccdaed\" ]   // oracleAddress   4   )   5   await  lzEndpoint . setConfig (   6   0 ,   // default library version   7   10132 ,   // dstChainId   8   6 ,   // CONFIG_TYPE_ORACLE   9   0x00000000000000000000000036ebea3941907c438ca8ca2b1065deef21ccdaed   // config 10   ) This process should be repeated on both the source and destination contracts. Ensure you adjust the  _dstChainId  and  oracleAddress  based on the contract's location. For instance, on OP Goerli, use the OP Goerli TSS Oracle Address and set the destination chain to  10121  for Goerli ETH. In Remix, passing these arguments will show the following: 3. Checking Oracle Configuration To ensure your Oracle setup is correctly configured: Navigate to the Block Explorer : Go to your chain's  Endpoint Address  on the designated block explorer. Access the Contract Details : Click on \"Read Contract\". Here, you should see an option labeled  defaultReceiveLibraryAddress . Select it to navigate to LayerZero's UltraLightNode. Query the UltraLightNode Contract : getConfig : This returns the current configuration of your UA Contract. defaultAppConfig : This gives the default configuration based on the latest library version. To use this, you'll need to provide the  _dstChainId  parameter. View the Oracle Parameter For the  defaultAppConfig , simply pass the  _dstChainId  and observe the returned oracle parameter. For the  getConfig , pass the  _dstChainId , your UA Contract Address, and set the constant  CONFIG_TYPE_ORACLE  to  6 . Compare Oracle Addresses : At the time of writing this tutorial, TSS is the default testnet Oracle. Therefore, if you haven't made any changes, both  getConfig  and  defaultAppConfig  should return identical Oracle addresses. However, if you've opted for a different Oracle from the current default, the two queries should return different Oracle addresses. Understanding Query Results:  You might notice a difference in how the queries present the Oracle: defaultAppConfig : This query returns the Oracle as an address. getConfig : In contrast, this displays the Oracle as a bytes value. However, don't be alarmed by this variation. If the only discrepancy between the two results is the presence of '0' padding, then both queries are referencing the same Oracle. 4. Testing Message Delivery Validate your Oracle setup by calling  incrementCounter . The protocol should now reflect your custom Oracle configuration and be capable to send messages in both directions. Congratulations on your successful configuration!  A successful oracle configuration will not impact message delivery. Troubleshooting Encountering a  FAILED  message status on LayerZero Scan? This likely points to a misconfiguration of the oracle address on either one or both contracts. A failed oracle configuration will impact message delivery. Ensure you're using the local oracle address (i.e., the same chain as your UA) when invoking  setConfig . Double-check the  dstChainId  you're passing. For further customization, refer to the  UA Custom Configuration  documentation.   Previous Default Oracle Updates Next Develop an Oracle Last modified  9d ago", "labels": ["Documentation"]}, {"title": "Default Oracle Updates", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/oracle/default-oracle-updates", "body": "Default Oracle Updates Keep up to the date with the latest Oracle for Default User Applications (UAs). By default, UAs opt into the LayerZero Protocol library updates. These updates generally bring improvements and changes to the reliability of the protocol's generic messaging.  These libraries are append-only, meaning that previous versions will always be available for UAs that decide to not use the default config. Opting Out of Defaults For UAs that want to fully control or lock their Oracle properties, see  UA Custom Configuration  to learn more.  Locking UA configuration guarantees that only UA owners can change their LZ app configs; UAs that opt-in to LayerZero defaults accept LayerZero's future changes to default configurations (i.e. best practice changes to block confirmations & proof libraries etc.) Projects with custom configuration will not have any impact on their settings, but are free to reconfigure settings back to Defaults or to any other Oracle at any given time. Google Cloud Oracle (default as of 9/19/23) Google Cloud (GCP) provides a Google Cloud Oracle to secure messaging in the LayerZero Protocol.  The Google Cloud Oracle is the default Oracle for all dApps built using the LayerZero protocol. Enterprises and developers of all sizes can now rely on the combination of an established entity (GCP) and a leading Web3 company (LayerZero) to address their interoperability challenges. That said, each Oracle provides unique costs and benefits. UAs are encouraged to select the best Oracle that suits their needs. Ecosystem -  Previous Oracle Next Configuring Custom Oracle Last modified  12d ago", "labels": ["Documentation"]}, {"title": "Develop an Oracle", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/oracle/develop-an-oracle", "body": "Develop an Oracle Get paid to perform one of the roles in the LayerZero system. Oracle Specification Performing the job of an Oracle means moving a piece of the message data from one chain and storing it in another. Please refer to our Oracle Specification document to learn more.  Two of the primary requirements for operating an Oracle (per-chain): Deploy and maintain balances in your own contract. Implement and operate a system that can submit data from Chain A to Chain B. In this gitbook, we wont get into the details of the implementation of an Oracle because the LayerZero relies on other ecosystem parters. We do however expose some example solidity contracts to demonstrate the contractual portion of a simple Oracle on an EVM: ILayerZeroOracle.sol See the LayerZero  Oracle contract interface . LayerZeroOracleMock.sol Heres the Oracle we use for internal testing: // SPDX-License-Identifier: BUSL-1.1  pragma   solidity   0.7.6 ;  import   \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\" ; import   \"@openzeppelin/contracts/access/Ownable.sol\" ; import   \"../interfaces/ILayerZeroOracle.sol\" ; import   \"../interfaces/ILayerZeroUltraLightNodeV1.sol\" ;  contract   LayerZeroOracleMock   is  ILayerZeroOracle ,  Ownable ,  ReentrancyGuard  {   mapping ( address   =>   bool )   public  approvedAddresses ;   mapping ( uint16   =>   mapping ( uint16   =>   uint ))   public  chainPriceLookup ;   uint   public  fee ;     ILayerZeroUltraLightNodeV1  public  uln ;   // ultraLightNode instance    event   OracleNotified ( uint16  dstChainId ,   uint16  _outboundProofType ,   uint  blockConfirmations );   event   Withdraw ( address  to ,   uint  amount );    constructor ()   {         approvedAddresses [ msg . sender ]   =   true ;   }    function   notifyOracle ( uint16  _dstChainId ,   uint16  _outboundProofType ,   uint64  _outboundBlockConfirmations )   external  override  {   emit   OracleNotified ( _dstChainId ,  _outboundProofType ,  _outboundBlockConfirmations );   }    function   updateHash ( uint16  _remoteChainId ,   bytes32  _blockHash ,   uint  _confirmations ,   bytes32  _data )   external   {   require ( approvedAddresses [ msg . sender ],   \"LayerZeroOracleMock: caller must be approved\" );         uln . updateHash ( _remoteChainId ,  _blockHash ,  _confirmations ,  _data );   }    function   withdraw ( address   payable  _to ,   uint  _amount )   public  onlyOwner nonReentrant  {   ( bool  success ,   )   =  _to . call { value :  _amount }( \"\" );   require ( success ,   \"failed to withdraw\" );   emit   Withdraw ( _to ,  _amount );   }    // owner can set uln   function   setUln ( address  ulnAddress )   external  onlyOwner  {         uln  =   ILayerZeroUltraLightNodeV1 ( ulnAddress );   }    // mock, doesnt do anything   function   setJob ( uint16  _chain ,   address  _oracle ,   bytes32  _id ,   uint  _fee )   public  onlyOwner  {}    function   setDeliveryAddress ( uint16  _dstChainId ,   address  _deliveryAddress )   public  onlyOwner  {}    function   setPrice ( uint16  _destinationChainId ,   uint16  _outboundProofType ,   uint  _price )   external  onlyOwner  {         chainPriceLookup [ _outboundProofType ][ _destinationChainId ]   =  _price ;   }    function   setApprovedAddress ( address  _oracleAddress ,   bool  _approve )   external   {         approvedAddresses [ _oracleAddress ]   =  _approve ;   }    function   isApproved ( address  _relayerAddress )   public   view  override  returns   ( bool )   {   return  approvedAddresses [ _relayerAddress ];   }    function   getPrice ( uint16  _destinationChainId ,   uint16  _outboundProofType )   external   view  override  returns   ( uint )   {   return  chainPriceLookup [ _outboundProofType ][ _destinationChainId ];   }    fallback ()   external   payable   {}    receive ()   external   payable   {} }    Previous Configuring Custom Oracle Next Google Cloud Oracle Last modified  16d ago", "labels": ["Documentation"]}, {"title": "Google Cloud Oracle", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/oracle/google-cloud-oracle", "body": "Google Cloud Oracle Contract Addresses to use Google Oracle with LayerZero The Google Oracle, as of 9/19/23, is the default oracle configuration for LayerZero messaging. Mainnet Addresses Ethereum:  0xD56e4eAb23cb81f43168F9F45211Eb027b9aC7cc BNB:  0xD56e4eAb23cb81f43168F9F45211Eb027b9aC7cc Avalanche:  0xD56e4eAb23cb81f43168F9F45211Eb027b9aC7cc Polygon:  0xD56e4eAb23cb81f43168F9F45211Eb027b9aC7cc Arbitrum:  0xD56e4eAb23cb81f43168F9F45211Eb027b9aC7cc Optimism:  0xD56e4eAb23cb81f43168F9F45211Eb027b9aC7cc Fantom:  0xD56e4eAb23cb81f43168F9F45211Eb027b9aC7cc Gnosis:  0xD56e4eAb23cb81f43168F9F45211Eb027b9aC7cc Base:  0xD56e4eAb23cb81f43168F9F45211Eb027b9aC7cc Harmony:  0xD56e4eAb23cb81f43168F9F45211Eb027b9aC7cc Moonbeam:  0xD56e4eAb23cb81f43168F9F45211Eb027b9aC7cc Celo:  0xD56e4eAb23cb81f43168F9F45211Eb027b9aC7cc Arbitrum Nova:  0xD56e4eAb23cb81f43168F9F45211Eb027b9aC7cc Linea:  0xD56e4eAb23cb81f43168F9F45211Eb027b9aC7cc Previous Develop an Oracle Next TSS Oracle Last modified  13d ago", "labels": ["Documentation"]}, {"title": "Overview of Polyhedra zkLightClient", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/oracle/overview-of-polyhedra-zklightclient", "body": "Overview of Polyhedra zkLightClient Integration of zero-knowledge proof technology will enhance security, performance, and cost-efficiency for cross-chain interoperability on all chains supported by LayerZero  Polyhedra Network  is building the next generation of infrastructure for Web3 interoperability by leveraging advanced zero-knowledge proof (ZKP) technology, a fundamental cryptographic primitive that guarantees the validity of data and computations while maintaining data confidentiality. The Polyhedra Network team designed and developed Polyhedra zkLightClient technology, a cutting-edge solution built on LayerZero Protocol, providing secure and efficient cross-chain infrastructures for Layer-1 and Layer-2 interoperability. Previous Chainlink Oracle Next zkLightClient on LayerZero Last modified  16d ago", "labels": ["Documentation"]}, {"title": "TSS Oracle", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/oracle/tss-oracle", "body": "TSS Oracle Contract Addresses to use TSS Oracle with LayerZero To use the TSS oracle with your LayerZero UserApplication, configure your app with the addresses below. TSS Oracle Mainnet Addresses Ethereum:  0x5a54fe5234e811466d5366846283323c954310b2 BNB:  0x5a54fe5234e811466d5366846283323c954310b2 Avalanche:  0x5a54fe5234e811466d5366846283323c954310b2 Polygon:  0x5a54fe5234e811466d5366846283323c954310b2 Arbitrum:  0xa0cc33dd6f4819d473226257792afe230ec3c67f Optimism:  0xa0cc33dd6f4819d473226257792afe230ec3c67f Fantom:  0xa0cc33dd6f4819d473226257792afe230ec3c67f DFK:  0x88bd5f18a13c22c41cf5c8cba12eb371c4bd18d9 Harmony:  0x3e2ef091d7606e4ca3b8d84bcaf23da0ffa11053 Moonbeam:  0xdeef80c12d49e5da8e01b05636e2d0c776f6b78d Celo:  0x071c3f1bc3046c693c3abbc03a87ca9a30e43be2 Dexalot:  0xa6bf2be6c60175601bf88217c75dd4b14abb5fbb Fuse:  0xa6bf2be6c60175601bf88217c75dd4b14abb5fbb Gnosis:  0xa6bf2be6c60175601bf88217c75dd4b14abb5fbb Metis:  0xa6bf2be6c60175601bf88217c75dd4b14abb5fbb Klaytn:  0xa6bf2be6c60175601bf88217c75dd4b14abb5fbb CoreDAO:  0xa6bf2be6c60175601bf88217c75dd4b14abb5fbb OKX (OKT):  0xa6bf2be6c60175601bf88217c75dd4b14abb5fbb Goerli:  0xa6bf2be6c60175601bf88217c75dd4b14abb5fbb Dos:  0xa6bf2be6c60175601bf88217c75dd4b14abb5fbb Sepolia:  0xa6bf2be6c60175601bf88217c75dd4b14abb5fbb zkSync:  0xcb7ad38d45ab5bcf5880b0fa851263c29582c18a Polygon zkEVM:  0xa6bf2be6c60175601bf88217c75dd4b14abb5fbb Moonriver:  0x84070061032f3e7ea4e068f447fb7cdfc98d57fe Shrapnel:  0xa6bf2be6c60175601bf88217c75dd4b14abb5fbb Tenet:  0x282b3386571f7f794450d5789911a9804FA346b4 Nova:  0x37aaaf95887624a363effB7762D489E3C05c2a02 Canto:  0x377530cdA84DFb2673bF4d145DCF0C4D7fdcB5b6 Meter:  0x51A6E62D12F2260E697039Ff53bCB102053f5ab7 Kava:  0xAaB5A48CFC03Efa9cC34A2C1aAcCCB84b4b770e4 Base:  0xAaB5A48CFC03Efa9cC34A2C1aAcCCB84b4b770e4 Linea:  0xcb566e3B6934Fa77258d68ea18E931fa75e1aaAa Mantle:  0xAaB5A48CFC03Efa9cC34A2C1aAcCCB84b4b770e4 Zora:  0xcb566e3B6934Fa77258d68ea18E931fa75e1aaAa Telos:  0x4514FC667a944752ee8A29F544c1B20b1A315f25 Meritcircle:  0xcb566e3B6934Fa77258d68ea18E931fa75e1aaAa Aptos:  0x12e12de0af996d9611b0b78928cd9f4cbf50d94d972043cdd829baa77a78929b TSS Oracle Testnet Addresses Ethereum:  0x36ebea3941907c438ca8ca2b1065deef21ccdaed BNB:  0x53ccb44479b2666cf93f5e815f75738aa5c6d3b9 Avalanche:  0x92cfdb3789693c2ae7225fcc2c263de94d630be4 Polygon:  0xaec5e56217a963bde38a3b6e0c3cb5e864450c86 Arbitrum:  0x9e13017d416cdf0816bccac744760dd1c374cd20 Optimism:  0x97597016f7dac89e55005105fc755c0513973fa8 Fantom:  0x9b743b9846230b657546fb942c6b11a23cfecd9a DFK:  0x7cfb4fadedc96793f844371d8498f4fdcd37da61 Dexalot:  0xab38efc6917086576137e4927af3a4d57da5f00c Moonbeam:  0xa85bfaa7bec20e014e5c29cb3536231116f3f789 Harmony:  0xb099d5a9652a80ff8f4234bde00f66531aa91c50 Celo:  0x894a918a9c2bfa6d32874e40ef4bba75b820b17c Fuse:  0x340b5e5e90a6d177e7614222081e0f9cdd54f25c Klaytn:  0xd682ecf100f6f4284138aa925348633b0611ae21 Metis:  0xd682ecf100f6f4284138aa925348633b0611ae21 CoreDAO:  0xb0487596a0b62d1a71d0c33294bd6eb635fc6b09 Gnosis:  0xd682ecf100f6f4284138aa925348633b0611ae21 zkSync:  0x2DCC8cFb612fDbC0Fb657eA1B51A6F77b8b86448 OKX (OKT):  0xd682ecf100f6f4284138aa925348633b0611ae21 Linea:  0x00c5c0b8e0f75ab862cbaaecfff499db555fbdd2 Base:  0x53fd4c4fbbd53f6bc58cae6704b92db1f360a648 Sepolia:  0x00c5c0b8e0f75ab862cbaaecfff499db555fbdd2 Meter:  0x0e8738298a8e437035e3aebd57f8dddc1a1bc44a Polygon zkEVM:  0x00c5c0b8e0f75ab862cbaaecfff499db555fbdd2 Kava:  0x6C7Ab2202C98C4227C5c46f1417D81144DA716Ff Tenet:  0x6C7Ab2202C98C4227C5c46f1417D81144DA716Ff Canto:  0x3aCAAf60502791D199a5a5F0B173D78229eBFe32 Aptos:  0x47a30bcdb5b5bdbf6af883c7325827f3e40b3f52c3538e9e677e68cf0c0db060 Meritcircle:  0x3aCAAf60502791D199a5a5F0B173D78229eBFe32 Mantle:  0x45841dd1ca50265Da7614fC43A361e526c0e6160 Zora:  0x6C7Ab2202C98C4227C5c46f1417D81144DA716Ff Loot:  0x6C7Ab2202C98C4227C5c46f1417D81144DA716Ff Telos:  0x6C7Ab2202C98C4227C5c46f1417D81144DA716Ff Tomo:  0x6C7Ab2202C98C4227C5c46f1417D81144DA716Ff opBNB:  0x6C7Ab2202C98C4227C5c46f1417D81144DA716Ff Shimmer:  0x6C7Ab2202C98C4227C5c46f1417D81144DA716Ff Aurora:  0x6C7Ab2202C98C4227C5c46f1417D81144DA716Ff Lif3:  0x45841dd1ca50265Da7614fC43A361e526c0e6160  Previous Google Cloud Oracle Next Chainlink Oracle Last modified  12d ago", "labels": ["Documentation"]}, {"title": "Develop a Relayer", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/relayer/develop-a-relayer", "body": "Develop a Relayer  To run your own Relayer, follow these high level requirements for each chain: Deploy and maintain a contract that implements  ILayerZeroRelayerV2  interface. A reference Relayer implementation can be found  here . Make sure your Relayer contract has access to up-to-date gas price information for all destination chains in order to accurately estimate transaction delivery fees. Configure your application to use your custom Relayer contract by calling  setConfig  in  Endpoint  contract. More information about setting a custom configuration can be found  here . Have access to your own nodes RPC + WS (or rely on one or more providers). Maintain and balance wallets used for delivering messages/payloads. Create an off-chain service that listens to  Packet  event emitted by  UltraLightNodeV2  on the source chain, waits for the configured number of confirmations  and calls  validateTransactionProof  in  UltraLightNodeV2  on the destination providing data from the event and the transaction proof. A reference implementation of transaction proof generation can be found  here  Off-chain Relayer is implementation agnostic. As long as it performs the core function of delivering the message, the implementation is open to interpretation and can be modified.     Previous Overview Next LayerZero Relayer Last modified  16d ago", "labels": ["Documentation"]}, {"title": "LayerZero Relayer", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/relayer/layerzero-relayer", "body": "LayerZero Relayer The Relayer run by LayerZero Labs and reference implementation. User Applications that opt in to the default configuration will use the LayerZero Labs Relayer.  LayerZero Labs runs and maintains a Relayer as a production asset for the ecosystem. Gas Convention The LayerZero Relayer assumes only a base gas for destination contract call, e.g. 200k gas for a call on Ethereum. It will only be enough for very simple applications.  If your app requires more gas, please use the  adapter parameters  specified here. Previous Develop a Relayer Next Max Proof Cost Estimate Last modified  4mo ago", "labels": ["Documentation"]}, {"title": "Max Proof Cost Estimate", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/relayer/max-proof-cost-estimate", "body": "Max Proof Cost Estimate", "labels": ["Documentation"]}, {"title": "Overview", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/relayer/overview", "body": "Overview Scope of Work Relay proof across chains, and pay the cost for lzReceive execution.  Gas Composition The receiving side smart contract overhead + proof cost + lzReceive. Plus, the gas varies from chain to chain. lzReceive we will have a default configuration per chain: Text Overhead Max Proof Cost (Estimate) default lzReceive Ethereum  240303  Avalanche  265574  BSC  283471  Polygon  341630  Arbitrum  173074  Optimism  N/A  Fantom  Need Valid RPC  Market Risk Charging native token A at the source chain, but paying native token B at the destination chain.  The business itself is long A / short B, can hedge the market risk with short A / long B in exchanges, or balance the book timely.  Ecosystem -  Previous Relayer Next Develop a Relayer Last modified  15d ago", "labels": ["Documentation"]}, {"title": "Development Staging", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/advanced/development-staging", "body": "Development Staging Local Use Endpoint Mock Use the endpoint mock to locally test your app logic fully. The mock gives you an abstraction of LayerZero messaging behavior and allows you to focus on your domain logic.   Portable Configuration LayerZero assumes contracts on different chains whitelist the counterparts on the other chains. An N-chain UA would need to wire N^2 paths accurately. If the app has multiple configurations for each path, e.g. token swap, it will be even harder. The problem will compound if the UA needs to add new chains (worse if with different runtimes like EVM and Solana contracts).  It is very important for your configuration script  unit-testable  and  portable  to production.  Testnet Smoke-Test Your Deployment After your deployment and configuration, you should do a quick smoke test to test whether message pathways are properly wired before shipping to production.  Mainnet If you are doing everything right in the Testnet stage, Mainnet should just be repeating the process but with more caution. Good luck with the launch!     EVM Guides -  Previous Advanced Next Relayer Adapter Parameters Last modified  11mo ago", "labels": ["Documentation"]}, {"title": "NonblockingLzApp", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/advanced/nonblockinglzapp", "body": "NonblockingLzApp As mentioned in the  Message Ordering  section, the Endpoint will catch any unhandled error/exception from the downstream UA and block the message queue from the source contract at the source chain to all destination contracts at the destination chain, until the stored message has been retried successfully.  However, UA can write a nonblocking receiver as a proxy layer to try-catch all errors/exceptions locally for future retry so that the message queue at the destination LayerZero Endpoint will never be blocked. We provide a  NonblockingLzApp  abstract contract as a template contract for UAs to build on.  UAs simply need to inherit the class and override the  _LzReceive   internal  function.  Be sure to  setTrustedRemote()  to enable inbound communication on all contracts! solidity-examples/NonblockingLzApp.sol at main  LayerZero-Labs/solidity-examples GitHub Previous Relayer Adapter Parameters Next  - EVM Guides UA Custom Configuration Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Relayer Adapter Parameters", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/advanced/relayer-adapter-parameters", "body": "Relayer Adapter Parameters Advanced relayer usage, and usage of _adapterParams Looking to  Airdrop  native gas tokens on a destination chain? Abstract: Every transaction costs a certain amount of gas. Since LayerZero delivers the destination transaction when a message is sent it must pay for that destination gas. A default of 200,000 gas is priced into the call for simplicity.  As a message sender, your contract may use more or less than 200k on destination.  To instruct LayerZero to use a custom amount of gas, you must pass the  adapterParams  argument of  send()  or  estimateFees() Version 1 - Example: You want to call  estimateFees()  and get a quote for a custom gas amount. Description Type Example Value version uint16 1 value uint256 200000 Encode the  adapterParams  and use them in the  send()  or  estimateFees()  function call: Heres an example of how to encode the  adapterParams // v1 adapterParams, encoded for version 1 style, and 200k gas quote let  adapterParams  =  ethers . utils . solidityPack (   [ 'uint16' , 'uint256' ],   [ 1 ,   200000 ] ) The resulting  adapterParams  should look like this (34 total bytes in length):  0x00010000000000000000000000000000000000000000000000000000000000030d40 The above  adapterParams  can be sent to  send()  (or  estimateFees() ) to receive a quote for a non standard amount of gas for the destination  lzReceive()  . If your logic on the destination chain is very simple you may ask the Relayer to pay a bit less than the default. If your message logic on the destination if very gas intense you may be required to pay more than the default of 200k gasLimit.   Airdrop Version 2 - Here is an example of how to encode the  adapterParams  for version 2, which may modify the default 200k gas, and instructs the Relayer to send native gas into a wallet address!  Description Type Example Value version uint16 2 gasAmount uint 200000 nativeForDst uint 55555555555 addressOnDst address 0x1234512345123451234512345123451234512345 // v2 adapterParams, encoded for version 2 style // which can instruct the LayerZero message to give  // destination 55555555555 wei of native gas into a specific wallet let  adapterParams  =  ethers . utils . solidityPack (   [ \"uint16\" ,   \"uint\" ,   \"uint\" ,   \"address\" ],   [ 2 ,   200000 ,   55555555555 ,   \"0x1234512345123451234512345123451234512345\" ] ) The above  adapterParams  can be sent to  send()  or  estimateFees()  to receive a quote for a non standard amount of gas for the destination  lzReceive()  and to give an amount of destination native gas to an address! // airdrop caps out at these values, per network (values shown imply 18 decimals) // Note: these values may change occasionally. Read onchain values in Relayer.sol for accuracy. ethereum :   0.24 bsc :   1.32 avalanche :   18.47 polygon :   681 arbitrum :   0.24 optimism :   0.24 fantom :   1304 swimmer :   30000 Previous Development Staging Next NonblockingLzApp Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Estimating Message Fees", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/code-examples/estimating-message-fees", "body": "Estimating Message Fees Get the quantity of native gas token to pay to send a message Call  estimateFees()  to return a tuple containing the cross chain message fee. There are 2 values returned as a tuple via estimateFees(). Use the 0th index to get the fee in wei to pass as value to Endpoint.send() You do not need to implement this function. This is just to show how the fee is calculated by the  endpoint  for the  send()  function. The  estimateFees()  function returns a dynamic fee based on Oracle and Relayer prices for the destination  chainId, your UserApplication contract, and payload parameters. In solidity, you can use the  ILayerZeroEndpoint.sol interface  to call the view function to get the send() fees. Endpoint  estimateFees() Set  _payInZRO  to  false // Endpoint.sol estimateFees() returns the fees for the message function   estimateFees ( uint16  _dstChainId ,   address  _userApplication ,   bytes   calldata  _payload ,   bool  _payInZRO ,   bytes   calldata  _adapterParams )   external   view  override  returns   ( uint  nativeFee ,   uint  zroFee )   {     LibraryConfig  storage  uaConfig  =  uaConfigLookup [ _userApplication ];     ILayerZeroMessagingLibrary lib  =  uaConfig . sendVersion  ==  DEFAULT_VERSION  ?  defaultSendLibrary  :  uaConfig . sendLibrary ;   return  lib . estimateFees ( _dstChainId ,  _userApplication ,  _payload ,  _payInZRO ,  _adapterParams ); }  Our implementation of  lib.estimateFees()  illustrates how the total fee is calculated, which is the cumulative amount the oracle and relayer are collecting plus, potentially, a small protocol fee. // full estimateFees implementation function   estimateFees ( uint16  _chainId ,   address  _ua ,   bytes   calldata  _payload ,   bool  _payInZRO ,   bytes   calldata  _adapterParams )   external   view  override  returns   ( uint  nativeFee ,   uint  zroFee )   {   uint16  chainId  =  _chainId ;   address  ua  =  _ua ;   uint  payloadSize  =  _payload . length ;   bytes   memory  adapterParam  =  _adapterParams ;      ApplicationConfiguration  memory  uaConfig  =   getAppConfig ( chainId ,  ua );    // Relayer Fee   uint  relayerFee ;   {   if   ( adapterParam . length  ==   0 )   {   bytes   memory  defaultAdapterParam  =  defaultAdapterParams [ chainId ][ uaConfig . outboundProofType ];             relayerFee  =   ILayerZeroRelayer ( uaConfig . relayer ). getPrice ( chainId ,  uaConfig . outboundProofType ,  ua ,  payloadSize ,  defaultAdapterParam );   }   else   {             relayerFee  =   ILayerZeroRelayer ( uaConfig . relayer ). getPrice ( chainId ,  uaConfig . outboundProofType ,  ua ,  payloadSize ,  adapterParam );   }   }    // Oracle Fee   uint  oracleFee  =   ILayerZeroOracle ( uaConfig . oracle ). getPrice ( chainId ,  uaConfig . outboundProofType );    // LayerZero Fee   {   uint  protocolFee  =  treasuryContract . getFees ( _payInZRO ,  relayerFee ,  oracleFee );         _payInZRO  ?  zroFee  =  protocolFee  :  nativeFee  =  protocolFee ;   }    // return the sum of fees     nativeFee  =  nativeFee . add ( relayerFee ). add ( oracleFee ); } Offchain Fee Estimation Example const  fees  =   await  endpoint . estimateFees (     dstChainId ,   // the destination LayerZero chainId     uaContractAddress ,   // your contract address that calls Endpoint.send()   \"0x\" ,   // empty payload   false ,   // _payInZRO   \"0x\"   // default '0x' adapterParams, see: Relayer Adapter Param docs ) console . log ( ` fees[0] is the message fee in wei:  ${ fees [ 0 ] } ` ) Check out  adapterParams  to customize the gas amount or airdrop native ETH!  AdapterParams  shows how to pack some additional settings to be used by estimateFees() and send() - it instructs LayerZero to use more gas which may be necessary to not run into a  StoredPayload . Previous LZEndpointMock.sol Next PingPong.sol Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "LZEndpointMock.sol", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/code-examples/lzendpointmock.sol", "body": "LZEndpointMock.sol A mock LayerZero endpoint contract for local testing. To enable testing locally we provide a mock that emulates a real endpoint. It has a  send()  method just like a real endpoint on main/test networks and it forwards the payload straight to the  lzReceive()  function (so you dont need a production oracle or relayer -- allowing you to test the contract logic easily).  This contract helps the LayerZero team with our own testing! solidity-examples/LZEndpointMock.sol at main  LayerZero-Labs/solidity-examples GitHub Previous OmniCounter.sol Next Estimating Message Fees Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "OmniCounter.sol", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/code-examples/messagecounter.sol", "body": "OmniCounter.sol A LayerZero User Application example to demonstrate message sending. The OmniCounter OmniCounter is a contract that increments a counter -- but there's a twist. This OmniCounter increments the counter on another chain. The Details To send cross chain messages, contracts will use an  endpoint  to  send()  from the source chain and  lzReceive()  to receive the message on the destination chain. Here you may find a table of  the Testnet Endpoints .  OmniCounter.sol can send and receive LayerZero messages. Let's highlight the two important features of this contract: _lzSend()  is overridden and called within  incrementCounter()  to send the message to another chain. _nonblockingLzReceive()  is overridden and it will be called on the destination chain which receives the message when receiving a message.  If you want to deploy and try this contract yourself you will need to construct it with  an Endpoint address . And will need the two  interfaces . solidity-examples/OmniCounter.sol at main  LayerZero-Labs/solidity-examples GitHub Take a look at the simplest usage of LayerZero: the OmniCounter If you want to copy this code, follow the link above to github! Clone the github repo, take a look at the README, and deploy your own OmniCounters. If you were to deploy this contract, you would need to do so on at least 2 chains. Once deployed, call  incrementCounter  to increment the counter on a destination chain! EVM Guides -  Previous Code Examples Next LZEndpointMock.sol Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "PingPong.sol", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/code-examples/pingpong.sol", "body": "PingPong.sol Demonstrate an onchain call to estimateFees() and a \"recursive\" call within lzReceive() This example contract demonstrates: estimateFees() : how to get the message fee on chain call  send()  within  lzReceive() using a contract to pay the message fee (as opposed to the msg.sender) Warning: This contract will continuously send calls between two chains until one of them runs out of gas! solidity-examples/PingPong.sol at main  LayerZero-Labs/solidity-examples GitHub PingPong.sol  Previous Estimating Message Fees Next  - EVM Guides Interfaces Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Common Errors and Handling", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/error-messages/error-layerzero-relayer-fee-failed", "body": "Common Errors and Handling The most common error is not sending the gas fee when calling send(..., {value: fee}) Are you getting this error when  sending a message ?  LayerZero: not enough native for fees When sending a message via the endpoint  send()  you must pass a  value  so LayerZero is compensated for the extra gas required to deliver the transaction to the destination chain. This  msg.value  refers to the parameter of the transaction that sends the native gas token.   The parameters for  estimateFees()  and  send()   MUST  be the same Rule of Thumb: if you have an estimateFee value that works, try to send a transaction with (value - 1). it should revert.  You can  get a quote  for any LayerZero message. Previous Fix a StoredPayload Next Failure Revert Messages Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Failure Revert Messages", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/error-messages/failure-revert-messages", "body": "Failure Revert Messages A full description of the errors found in LayerZero contracts LayerZero: only endpoint Only the endpoint can be the caller of the function. LayerZero: invalid relayer Relayer delivering the message is NOT the relayer the UA has configured. LayerZero: invalid inbound proof library User Application has configured an invalid proof library version for remote chainId LayerZero: not enough block confirmations During message delivery, the Oracle didnt wait enough block confirmations as specified by the UA. LayerZero: _packet.ulnAddress is invalid Invalid source sender of the message. LayerZero: invalid dst address The LayerZero message specifies a different destination contract address than the relayer. LayerZero: must be paid by sender or origin Endpoint.send() was flagged to be paid in tokens, but the address is invalid. LayerZero: not enough native for fees User Application needs to send more msg.value (see: Endpoint.estimateFees()) LayerZero: failed to refund The specified _refundAddress is not payable, or invalid. (Try sending the exact amount) LayerZero: oracle data can only update if it has more confirmations The Oracle tried to update the data, but it was identical to what already existed. LayerZero: invalid inbound proof library version setConfig() cannot set the specified inbound proof library version LayerZero: invalid outbound proof type setConfig() cannot set the specified outbound proof type LayerZero: Invalid config type setConfig() does not know how to set this value LayerZero: only treasury withdrawZRO() called by invalid address LayerZero: only relayerFee contract Only a certain address can call withdraw on the UltraLightNode LayerZero: unsupported withdraw type withdrawZRO() called with invalid type Previous Common Errors and Handling Next  - EVM Guides Best Practice Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Fix a StoredPayload", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/error-messages/fix-a-storedpayload", "body": "Fix a StoredPayload Manually fix a StoredPayload by sending a transaction on the destination chain. A StoredPayload contains the data for a message that ran out of gas (most likely) In order to deliver this message, once its stored, you must call a transaction on the Endpoint.sol called  retryPayload Youll need 3 things: source Chain ID of the chain the message was sent from source UserApplication address UA payload If we  refer back to here , we know how to get these 3 items. Or use a block explorer and find the destination trasaction, and look in the Logs tab. The Logs tab of most block explorers shows the StoredPayload event values. You will need the srcChainId, srcAddress, and payload Now we simply need an instance of the Endpoint contract on the  destination  chain. And to call the transaction, to \"unstick\" the StoredPayload. Heres a code snippet:   // some ethers.js code to show how to deliver a StoredPayload let  endpoint  =   await  ethers . getContract ( \"Endpoint\" )  let  srcChainId  =   9 // trustedRemote is the remote + local format let  trustedRemote  =  hre . ethers . utils . solidityPack (   [ 'address' , 'address' ],   [ remoteContract . address ,  localContract . address ] ) let  payload  =   \"0x000000...0000000000\"   // copy and paste entire payload here let  tx  =   await  endpoint . retryPayload (     srcChainId ,     trustedRemote ,     payload ) Thats it! If your transaction succeeds, the StoredPayload should be cleared and messages will resume if you send another message across the pathway. If you get an error about invalid payload, you may have copied it wrong. Be sure to prefix the srcAddress and the payload with 0x so that ethers.js is happy. Previous StoredPayload Detection Next Common Errors and Handling Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "StoredPayload", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/error-messages/storedpayload", "body": "StoredPayload If a message arrives at the destination and reverts or runs out of gas during execution it is saved on the destination side. Anyone can go to the destination chain and pay for the transaction to be retried, however if there is a logical error it may need to be force ejected. StoredPayloads will block the nonce-ordered flow of messages. You can check for a StoredPayload using the Endpoint.sol's  hasStoredPayload  function, supplying the source  chainId  and source User Application address (which is in the  TrustedRemote  40byte format). Check for StoredPayload // Endpoint.sol check for StoredPayload  function   hasStoredPayload ( uint16  _srcChainId ,   bytes   calldata  _srcAddress )   external   view  override  returns   ( bool )   {      StoredPayload  storage  sp  =  storedPayload [ _srcChainId ][ _srcAddress ];   return  sp . payloadHash  !=   bytes32 ( 0 ); } To clear a StoredPayload, call  retryPayload  on the message that was stored, on the destination chain. You should call this function on the  Endpoint . // Endpoint.sol function   retryPayload (   uint16  _srcChainId ,     bytes   calldata  _srcAddress ,     bytes   calldata  _payload )   external  override receiveNonReentrant  {   ...   } Note: most block explorers will  show  the payload parameter in the Logs tab, which could make it easy to find in the case you need to call  retryPayload  to unblock the queue. Also, you may implement your UA as the  NonblockingLzApp  which is an option offered that allows messages to flow regardless of error (which will all be stored on the destination to be dealt with anytime) Force eject the StoredPayload, unblocking the queue by DESTROYING (see: be very careful)  the transaction forever. This is a very powerful function, and only the User Application  onlyOwner  can perform it. // Endpoint.sol function   forceResumeReceive (   uint16  _srcChainId ,     bytes   calldata  _srcAddress )   external  override onlyOwner  { Fix a Stored Payload Go here for information on  fixing a StoredPayload  EVM Guides -  Previous Error Messages Next StoredPayload Detection Last modified  2mo ago", "labels": ["Documentation"]}, {"title": "StoredPayload Detection", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/error-messages/storedpayload-detection", "body": "StoredPayload Detection Find the hidden reason for a StoredPayload What does a StoredPayload look like on chain & How to deal with it If you see a transaction like this, then you may have a StoredPayload: https://optimistic.etherscan.io/tx/0xd3229bfe9bb64425eef6457e1198e7c2d96c3abc1721e2b0846459a291d1ff60 optimistic.etherscan.io Example StoredPayload Tx See the orange text? Although the transaction may say it succeeded, LayerZero may have a StoredPayload blocking the queue of message until dealt with. Go to the \"Logs\" tab to see the reason If there is no  reason  string, it could be out of gas. If there is a  reason  copy the bytes into a hex-to-string converter to see the reason (example below): LzReceiver: invalid source sending contract  OK! Thats some helpful information - Although we ran into a StoredPayload, we now know the reason:  LzReceiver: invalid source sending contract The error reminds us that we must  setTrustedRemote  first on the destination to allow inbound communication from the source sending User Application contract.   Previous StoredPayload Next Fix a StoredPayload Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "EVM (Solidity) Interfaces", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/interfaces/evm-solidity-interfaces", "body": "EVM (Solidity) Interfaces User Application  ILayerZeroEndpoint.sol   ILayerZeroReceiver.sol   ILayerZeroUserApplicationConfig.sol   ILayerZeroEndpointLibrary.sol   ILayerZeroLibraryReceiver.sol  Oracle  ILayerZeroOracle.sol  Relayer  ILayerZeroRelayer.sol   These interfaces can be found in the  LayerZero GitHub : ILayerZeroValidationLibrary.sol ILayerZeroUltraLightNodeV1.sol ILayerZeroValidationLibrary.sol EVM Guides -  Previous Interfaces Next ILayerZeroReceiver Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "OFT", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/layerzero-omnichain-contracts/oft", "body": "OFT Omnichain Fungible Token Here are the articles in this section: IERC165 OFT Interface Ids OFT (V1) vs OFTV2 - Which should I use? OFT (V1) OFTV2 EVM Guides -  Previous LayerZero Omnichain Contracts Next IERC165 OFT Interface Ids Last modified  7mo ago", "labels": ["Documentation"]}, {"title": "ONFT", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/layerzero-omnichain-contracts/onft", "body": "ONFT Omnichain NonFungible Token Here are the articles in this section: 721 1155 Previous OFTV2 Next 721 Last modified  7mo ago", "labels": ["Documentation"]}, {"title": "UA Configuration", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/layerzero-tooling/ua-configuration", "body": "UA Configuration Describes the available config options in the appConfig.json Tasks The package adds the following tasks: getDefaultConfig  returns the default configuration for the specified chains. Usage: npx hardhat getDefaultConfig  --networks  ethereum,bsc,polygon,avalanche getConfig  returns the configuration of the specified contract. Parameters: address  - the contract address. An optional parameter. Either contract name or contract address must be specified. name  - the contract name. An optional parameter. It must be specified only if the contract was deployed using  hardhat-deploy  and the deployments information is located in the deployments folder. network  - the network the contract is deployed to. remote-networks  - a comma separated list of remote networks the contract is configured with. Usage: npx hardhat getConfig  --network  ethereum --remote-networks bsc,polygon,avalanche  --name  OFT setConfig  sets the configuration of the specified contract. Parameters: config-path  - the relative path to a file containing the configuration. address  - the address of the deployed contracts. An optional parameter. It should be provided if the contract address is the same on all chains. For contracts with different addresses, specify the address for each chain in the config. name  - the name of the deployed contracts. An optional parameter. It should be provided only if the same contract deployed on all chains using  hardhat-deploy  and the deployment information is located in the deployments folder. For contracts with different names, specify the name for each chain in the config. gnosis-config-path  - the relative path to a file containing the gnosis configuration. An optional parameter. If specified, the transactions will be sent to Gnosis. Usage: npx hardhat setConfig  --networks  ethereum,bsc,avalanche  --name  OFT --config-path  \"./appConfig.json\"  --gnosis-config-path  \"./gnosisConfig.json\"   Below is an example of the application configuration {   \"ethereum\" :   {   \"address\" :   \"\" ,   \"name\" :   \"ProxyOFT\" ,   \"sendVersion\" :   2 ,   \"receiveVersion\" :   2 ,   \"remoteConfigs\" :   [   {   \"remoteChain\" :   \"bsc\" ,   \"inboundProofLibraryVersion\" :   1 ,   \"inboundBlockConfirmations\" :   20 ,   \"relayer\" :   \"0x902F09715B6303d4173037652FA7377e5b98089E\" ,   \"outboundProofType\" :   1 ,   \"outboundBlockConfirmations\" :   15 ,   \"oracle\" :   \"0x5a54fe5234E811466D5366846283323c954310B2\"   },   {   \"remoteChain\" :   \"avalanche\" ,   \"inboundProofLibraryVersion\" :   1 ,   \"inboundBlockConfirmations\" :   12 ,   \"relayer\" :   \"0x902F09715B6303d4173037652FA7377e5b98089E\" ,   \"outboundProofType\" :   1 ,   \"outboundBlockConfirmations\" :   15 ,   \"oracle\" :   \"0x5a54fe5234E811466D5366846283323c954310B2\"   }   ]   },   \"bsc\" :   {     \"address\" :   \"0x0702c7B1b18E5EBf022e17182b52F0AC262A8062\" ,   \"name\" :   \"\" ,   \"sendVersion\" :   2 ,   \"receiveVersion\" :   2 ,   \"remoteConfigs\" :   [   {   \"remoteChain\" :   \"ethereum\" ,   \"inboundProofLibraryVersion\" :   1 ,   \"inboundBlockConfirmations\" :   15 ,   \"relayer\" :   \"0xA27A2cA24DD28Ce14Fb5f5844b59851F03DCf182\" ,   \"outboundProofType\" :   1 ,   \"outboundBlockConfirmations\" :   20 ,   \"oracle\" :   \"0x5a54fe5234E811466D5366846283323c954310B2\"   }   ]   } } The top level elements represent chains the contracts are deployed to. The configuration section for each chain has the following fields: address  - the contract address. An optional parameter. It should be provided if no address was specified in the task parameters. name  - the contract name. An optional parameter. It should be provided only if the contract was deployed using  hardhat-deploy  and the deployment information is located in the deployments folder. sendVersion  - the version of a messaging library contract used to send messages. If it isn't specified, the default version will be used. receiveVersion  - the version of a messaging library contract used to receive messages. If it isn't specified, the default version will be used. remoteConfigs  - an array of configuration settings for remote chains.   The configuration section for each chain has the following fields: remoteChain  - the remote chain name. inboundProofLibraryVersion  - the version of proof library for inbound messages. inboundBlockConfirmations  - the number of block confirmations for inbound messages. relayer  - the address of Relayer contract. outboundProofType  - proof type used for outbound messages. outboundBlockConfirmations  - the number of block confirmations for outbound messages. oracle  - the address of the Oracle contract.   Below is an example of the Gnosis configuration {   \"ethereum\" :   {   \"safeAddress\" :   \"0xa36B7e7894aCfaa6c35A8A0EC630B71A6B8A6D22\" ,   \"url\" :   \"https://safe-transaction.mainnet.gnosis.io/\"   },   \"bsc\" :   {   \"safeAddress\" :   \"0x4755D44c1C196dC524848200B0556A09084D1dFD\" ,   \"url\" :   \"https://safe-transaction.bsc.gnosis.io/\"   },   \"avalanche\" :   {   \"safeAddress\" :   \"0x4FF2C33FD9042a76eaC920C037383E51659417Ee\" ,   \"url\" :   \"https://safe-transaction.avalanche.gnosis.io/\"   } } For each chain you need to specify your Gnosis safe address and Gnosis Safe API url. You can find the list of supported chains and API urls in  Gnosis Safe documentation . EVM Guides -  Previous LayerZero Tooling Next Wire Up Configuration Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Wire Up Configuration", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/layerzero-tooling/wire-up-configuration", "body": "Wire Up Configuration Describes the available config options in the wireUpConfig.json Available configuration options To use the LayerZero wire up configuration please correctly fill in your wireUpConfig.json {   \"proxyContractConfig\"   {   \"chain\" :   \"avalanche\" ,   \"name\" :   \"ProxyOFT\"   },   \"contractConfig\"   {   \"name\" :   \"OFT\"   },   \"chainConfig\" :   {   \"avalanche\" :   {   \"defaultFeeBp\" :   2 ,     \"useCustomAdapterParams\" :   true ,   \"remoteNetworkConfig\" :   {   \"ethereum\" :   {   \"feeBpConfig\" :   {   \"feeBp\" :   5 ,   \"enabled\" :   true   },   \"minDstGasConfig\" :   [ 100000 ,   200000 ]   },   \"polygon\" :   {   \"minDstGasConfig\" :   [ 100000 ,   160000 ]   }   }     }   } } The  proxyContractConfig  is an  optional  setting, that defines the proxy chain and proxy contract name. chain : An  optional  string, defines the proxy chain. name : An  optional  string, defines the proxy contract name. address : A  optional  string, defines the contract address. Used when  deployments  folder are not available. Uses standard LzApp/Nonblocking/OFT/ONFT abi calls such as: function setFeeBp(uint16, bool, uint16) function setDefaultFeeBp(uint16) function setMinDstGas(uint16, uint16, uint) function setUseCustomAdapterParams(bool) function setTrustedRemote(uint16, bytes) The  contractConfig  is a  conditionally required  setting, that defines the contract name. name : A  conditionally required  string, defines the contract name. Used when all contract names are the same on all chains, excluding proxy. The  chainConfig : is  required  and defines the chain settings (default fees, useCustomAdapterParams) and the remote chain configs (minDstGas config based of packetType, and custom feeBP per chain) name : A  conditionally required  string, defines the contract name. Used when contract names differ per chain. address : A  conditionally required  string, defines the contract address. Used when  deployments  folder are not available. Uses standard LzApp/Nonblocking/OFT/ONFT abi calls. defaultFeeBp : An  optional  number, defines the default fee bp for the chain. (Available in  OFTV2 w/ fee .) useCustomAdapterParams : An  optional  bool that defaults to  false . Uses default 200k destination gas  on  all cross chain messages. When  false  adapter parameters must be empty. When useCustomAdapterParams is  true  the  minDstGasLookup  must be set for each  packet type  and each  chain . This requires whoever calls the send function to provide the adapter params with a destination gas >= amount set for that packet type and that destination chain. The  remoteNetworkConfig  is a  required  setting that defines the remote chain configs (minDstGas config based on packetType, and custom feeBP per chain) minDstGasConfig : is an  optional  array of numbers that defines the minDstGas required based off packetType. In the example above minDstGasConfig has a length of 2 with the indexes representing the packet type. So for example when the UA on  Avalanche  sends  packet type 0  to  Ethereum  the minDstGas will be 100000. When the UA on  Avalanche  sends  packet type 1  to  Polygon  the minDstGas will be 160000. The  feeBpConfig  is an  optional  setting that defines custom feeBP per chain. ( Note: setting custom fee per chain with enabled = TRUE, will triumph over defaultFeeBp.) feeBp : is an  optional  number, defines custom feeBP per chain. enabled : is an  optional  bool,  defines if custom feeBP per chain is enabled Example wireUpConfigs Example 1: {   \"contractConfig\"   {   \"name\" :   \"OFT\"   },   \"fuji\" :   {   \"defaultFeeBp\" :   5 ,   \"useCustomAdapterParams\" :   true ,   \"remoteNetworkConfig\" :   {   \"arbitrum-goerli\" :   {   \"minDstGasConfig\" :   [ 2000000 ,   3200000 ]   },   \"bsc-testnet\" :   {   \"minDstGasConfig\" :   [ 100000 ,   160000 ]   }   }   } } This configuration is setting a defaultFeeBp of 5 for all transactions on fuji. This configuration is also setting the minDstGasLookup based on packet types. The minDstGasConfig has a length of 2 with the indexes representing the packet type. So for example when the UA on fuji sends  packet type 0  to arbitrum-goerli the minDstGas will be 2000000. When the UA on fuji sends  packet type 1  to bsc-testnet the minDstGas will be 160000. Example 2: {   \"proxyContractConfig\" :   {   \"chain\" :   \"fuji\" ,   \"name\" :   \"ExampleProxyOFTV2\"   }   \"chainConfig\" :   {   \"fuji\" :   {   \"remoteNetworkConfig\" :   {   \"arbitrum-goerli\" :   {   \"feeBpConfig\" :   {   \"enabled\" :   true ,   \"feeBp\" :   2   }   },   \"bsc-testnet\" :   {   \"feeBpConfig\" :   {   \"enabled\" :   true ,   \"feeBp\" :   3   }   }   }   },   \"bsc-testnet\" :   {   \"name\" :   \"BscOFTV2\" ,   \"remoteNetworkConfig\" :   {   \"arbitrum-goerli\" :   {   \"feeBpConfig\" :   {   \"feeBp\" :   5 ,   \"enabled\" :   true   }   },   \"fuji\" :   {   \"feeBpConfig\" :   {   \"feeBp\" :   4 ,   \"enabled\" :   true   }   }   }   },   \"arbitrum-goerli\" :   {   \"name\" :   \"ArbitrumOFTV2\" ,   \"remoteNetworkConfig\" :   {   \"bsc-testnet\" :   {   \"feeBpConfig\" :   {   \"feeBp\" :   1 ,   \"enabled\" :   true   }   },   \"fuji\" :   {   \"feeBpConfig\" :   {   \"feeBp\" :   2 ,   \"enabled\" :   true   }   }   }   }   } } This configuration uses name per chain because each chain has a different contract name. This configuration is setting a custom bp fee per pathway instead of a defaultFeeBp. This configuration is not using custom adapter params and is opting into the  default 200000 gas . Example 3: {   \"proxyContractConfig\" :   {   \"chain\" :   \"fuji\" ,   \"address\" :   \"0x0000000000000000000000000000000000000000\"   },   \"chainConfig\" :   {   \"fuji\" :   {   \"defaultFeeBp\" :   0 ,   \"useCustomAdapterParams\" :   true ,   \"remoteNetworkConfig\" :   {   \"bsc-testnet\" :   {   \"feeBpConfig\" :   {   \"enabled\" :   false ,   \"feeBp\" :   0   },   \"minDstGasConfig\" :   [ 100000 ,   160000 ]   }   }   },   \"bsc-testnet\" :   {   \"address\" :   \"0x0000000000000000000000000000000000000000\" ,   \"defaultFeeBp\" :   0 ,   \"useCustomAdapterParams\" :   true ,   \"remoteNetworkConfig\" :   {   \"fuji\" :   {   \"feeBpConfig\" :   {   \"feeBp\" :   0 ,   \"enabled\" :   false   },   \"minDstGasConfig\" :   [ 100000 ,   160000 ]   }   }   }   } } This configuration uses address per chain and relys on the contracts containing the following ABI's: function setTrustedRemote(uint16, bytes) function setUseCustomAdapterParams(bool) function setMinDstGas(uint16, uint16, uint) function setDefaultFeeBp(uint16) function setFeeBp(uint16, bool, uint16)  Previous UA Configuration Next  - EVM Guides Omnichain Governance Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Send Messages", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/master/how-to-send-a-message", "body": "Send Messages Use LayerZero to send a bytes payload from one chain to another. To send a message, call the Endpoint's  send()  function. Initiate the send()  function in your contracts (similar to the  CounterMock ) to send a cross chain message.  // an endpoint is the contract which has the send() function ILayerZeroEndpoint  public  endpoint ; // remote address concated with local address packed into 40 bytes bytes   memory  remoteAndLocalAddresses  =  abi . encodePacked ( remoteAddress ,  localAddress ); // call send() to send a message/payload to another chain endpoint . send { value : msg . value }(   10001 ,   // destination LayerZero chainId     remoteAndLocalAddresses ,   // send to this address on the destination             bytes ( \"hello\" ),   // bytes payload     msg . sender ,   // refund address   address ( 0x0 ),   // future parameter   bytes ( \"\" )   // adapterParams (see \"Advanced Features\")   ); Here is an explanation of the  endpoint.send()  interface: // @notice send a LayerZero message to the specified address at a LayerZero endpoint specified by our chainId. // @param _dstChainId - the destination chain identifier // @param _remoteAndLocalAddresses - remote address concated with local address packed into 40 bytes // @param _payload - a custom bytes payload to send to the destination contract // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination function   send (   uint16  _dstChainId ,     bytes   calldata  _remoteAndLocalAddresses ,     bytes   calldata  _payload ,     address   payable  _refundAddress ,     address  _zroPaymentAddress ,     bytes   calldata  _adapterParams )   external   payable ; You will note in the topmost example we call  send()  with  {value: msg.value}  this is because  send()  requires a bit of  native gas token so the relayer can complete the message delivery on the destination chain. If you don't set this value  you might get this error  when calling  endpoint.send() Putting it into a more complete example, your User Application contract may look something like this: pragma   solidity   0.8.4 ; pragma  abicoder v2 ;  import   \"../lzApp/NonblockingLzApp.sol\" ;  /// @title A LayerZero example sending a cross chain message from a source chain to a destination chain to increment a counter contract   OmniCounter   is  NonblockingLzApp  {   uint   public  counter ;    constructor ( address  _lzEndpoint )   NonblockingLzApp ( _lzEndpoint )   {}    function   _nonblockingLzReceive ( uint16 ,   bytes   memory ,   uint64 ,   bytes   memory )   internal  override  {   // _nonblockingLzReceive is how we provide custom logic to lzReceive()   // in this case, increment a counter when a message is received.         counter  +=   1 ;   }    function   incrementCounter ( uint16  _dstChainId )   public   payable   {   // _lzSend calls endpoint.send()   _lzSend ( _dstChainId ,   bytes ( \"\" ),   payable ( msg . sender ),   address ( 0x0 ),   bytes ( \"\" ));   } } There you have it! Call  incrementCounter()  to send a LayerZero message to another chain.   See the  next section  for how to handle receiving the message by implementing  lzReceive()  and also see how to execute any smart contract logic on the destination. Putting together a full User Application contract simply means implementing a way to call  endpoint.send()  and ensuring  lzReceive()  is overridden to handle receiving messages (see  ILayerZeroReceiver.sol  for the  lzReceive()  interface)  OmniChainToken  is a slightly more complex example of a omnichain contract. Estimating Message Fees If you want to know how much  {value: xxx}  to give to the send() function to pay for you message please refer to this  section on estimating fees . Adapter Parameters Also see advanced message features using  Adapter Parameters  (aka:  _adapterParameters ) EVM Guides -  Previous Getting Started Next Receive Messages Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Receive Messages", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/master/receive-messages", "body": "Receive Messages Destination contracts must implement lzReceive() to handle incoming messages The code snippet explains how the message will be received. To receive a message, your User Application contract must implement the ILayerZeroReceiver interface and override the  lzReceive()  function pragma   solidity   >= 0.5.0 ;  interface   ILayerZeroReceiver   {   // @notice LayerZero endpoint will invoke this function to deliver the message on the destination   // @param _srcChainId - the source endpoint identifier   // @param _srcAddress - the source sending contract address from the source chain   // @param _nonce - the ordered message nonce   // @param _payload - the signed payload is the UA bytes has encoded to be sent   function   lzReceive ( uint16  _srcChainId ,   bytes   calldata  _srcAddress ,   uint64  _nonce ,   bytes   calldata  _payload )   external ; } Below is a snippet that shows an implementation of  lzReceive() . Here we demonstrate how to extract an  address  out of the payload and increment a counter each time this contract receives any message.  UAs should authenticate the received messages with: the caller is the known LayerZero endpoint the srcAddress  is a trusted known address on the  _srcChain . If the application will connect non-evm chains, the UA should use  bytes  to store addresses.  mapping ( address   =>   uint )   public  addrCounter ; mapping ( uint16   =>   bytes )   public  trustedRemoteLookup ;  // override from ILayerZeroReceiver.sol function   lzReceive ( uint16  _srcChainId ,   bytes   memory  _srcAddress ,   uint64  _nonce ,   bytes   memory  _payload )  override  external   {   require ( msg . sender  ==   address ( endpoint ));   require ( keccak256 ( _srcAddress )   ==   keccak256 ( trustedRemoteLookup [ _srcChainId ]);   address  fromAddress ;   assembly   {         fromAddress  :=   mload ( add ( _srcAddress ,   20 ))   }     addrCounter [ fromAddress ]   +=   1 ; } Check the  CounterMock  for examples.  Previous Send Messages Next Set Trusted Remotes Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Set Trusted Remotes", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/master/set-trusted-remotes", "body": "Set Trusted Remotes For a contract using LayerZero, a trusted remote is another contract it will accept messages from. What is a Trusted Remote? A trusted remote is the 40 bytes (for evm-to-evm messaging) that identifies another contract which you will receive messages from within your LayerZero User Application contract. The 40 bytes object is the packed bytes of the   remoteAddress  +  localAddress The reason to care about Trusted Remotes is that from a security perspective contracts should only receive messages from known contracts. Hence, contracts are securely connected by \"setting trusted remotes\" The team has produced this  GitHub Repository  as an example of how to automate setting trusted remotes. 40 byte Format for EVM <> EVM, A Trusted Remote is 40 bytes. It is the REMOTE contract address concatenated with the LOCAL contract address. Solana, Aptos, et al. & 32 Byte Addresses For NON-evm chains with addresses that are not 20 bytes obviously the Trusted Remotes will not be exactly 40 bytes, but we will regularly use \"40 byte\" Trusted Remotes in the nomenclature. Generate TrustedRemote Using Ethers.js  // the trusted remote (or sometimes referred to as the path or pathData) // is the packed 40 bytes object of the REMOTE + LOCAL user application contract addresses let  trustedRemote  =  hre . ethers . utils . solidityPack (   [ 'address' , 'address' ],   [ remoteContract . address ,  localContract . address ] )  Trusted Remote Usage: The Trusted Remote is now used in a few places. Here is a list of which functions expect the trusted remote format: Function Param Is it a trusted remote? Endpoint retryPayload() _srcAddress  Endpoint  hasStoredPayload() _srcAddress  Endpoint  forceResumeReceive() _srcAddress  LzApp  setTrustedRemote() _path  LzApp  isTrustedRemote() _srcAddress  lzReceive() _srcAddress  Previous Receive Messages Next  - EVM Guides Advanced Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "UA Configuration Lock", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/ua-custom-configuration/ua-configuration-lock", "body": "UA Configuration Lock UA's can lock their LayerZero App configurations for full control of config changes. For UAs that want to fully control their config changes & security settings, the below sections describe how to do so.  Locking UA configuration guarantees that only UA owners can change their LZ app configs; UAs that opt-in to LayerZero defaults accept LayerZero's future changes to default configurations (i.e. best practice changes to block confirmations & proof libraries etc.) There are 8 settings to fully lock your UA configuration 2 settings on the Endpoint Send Version Receive Version 6 settings on each pathway Inbound Proof Library  Inbound Block Confirmations  Relayer  Outbound Proof Type Outbound Block Confirmations  Oracle Steps for locking UA Configuration 1. Set the  send version  and  receive version  of your UA on the LayerZero Endpoint. This locks you to a core library version, currently UltraLigntNodeV2. In the event new libraries are implemented, only UA owners can upgrade their core library version. 2. Per pathway, UAs can configure up to all 6 settings and can lock each of these settings individually. For example, if a UA wants a specific Oracle but prefers the defaults for the other 5 settings, the UA only needs to set its configuration for the Oracle. UAs preferring to lock all 6 settings can easily do so. Once locked, only UA owners can make future configuration changes.  We provide an interface for UA contracts to set their  ILayerZeroUserApplicationConfig . We also provide code snippets  here . Note: To lock any of the 6 settings for each pathway, you  MUST  first lock send & receive versions to a core library. EVM Guides -  Previous UA Custom Configuration Next  - EVM Guides Code Examples Last modified  15d ago", "labels": ["Documentation"]}, {"title": "Default Config", "html_url": "https://layerzero.gitbook.io/docs/technical-reference/mainnet/default-config", "body": "Default Config To simplify writing a User Application contract, LayerZero does not require any configuration. In this case, a UA sending messages will be using the system defaults. Note: Should you choose to not manually set your configuration, the Default configuration will automatically be set for your application. The Default configuration is set and owned by the LayerZero Labs Multisig and may be updated in the future. The Default Configuration Oracle: Industry TSS Oracle (Polygon, Sequoia)  Relayer: LayerZero Labs Library Version (send & receive):  UltraLightNodeV2.sol  Outbound Proof Type:  1, MPT  Outbound Confirmations: Varies per source chain, see below Inbound Proof Library: 1, MPT Inbound Confirmation: Varies per source chain, see below Sending Messages Default  _adapterParams Type: Version 1 Gas Amount: 200,000 // These are the default Block Confirmations waited by LayerZero before delivering messages const  defaultBlockConfs  =   {     [ ETHEREUM ] :   15 ,   [ BSC ] :   20 ,   [ AVALANCHE ] :   12 ,   [ POLYGON ] :   512 ,   [ ARBITRUM ] :   20 ,   [ OPTIMISM ] :   20 ,   [ FANTOM ] :   5 ,   [ DFK ] :   10 ,   [ HARMONY ] :   5 ,   [ MOONBEAM ] :   10 ,   [ APTOS ] :   500000 ,   [ CELO ] :   5 ,   [ DEXALOT ] :   10 ,   [ KLAYTN ] :   5 ,   [ METIS ] :   5 ,   [ FUSE ] :   5 ,   [ GNOSIS ] :   5 ,   [ COREDAO ] :   21 ,   [ OKX ] :   2 ,   [ DOS ] :   2 ,   [ SEPOLIA ] :   10 ,   [ ZKSYNC ] :   20 ,   [ ZKPOLYGON ] :   20 ,   [ MOONRIVER ] :   10 ,   [ METER ] :   2 ,   [ NOVA ] :   20 ,   [ TENET ] :   2 ,   [ CANTO ] :   2 ,   [ KAVA ] :   2 , } Transactions originating from the above chains should be delivered after a minimum of the specified source Block Confirmations  Previous UltraLightNodeV2 And NonceContract Addresses Next Multisig Wallets Last modified  2mo ago", "labels": ["Documentation"]}, {"title": "LayerZero Labs Relayer.sol Addresses", "html_url": "https://layerzero.gitbook.io/docs/technical-reference/mainnet/layerzero-labs-relayer.sol-addresses", "body": "LayerZero Labs Relayer.sol Addresses The team operates and maintains a production Relayer for the protocol. Ethereum  0x902f09715b6303d4173037652fa7377e5b98089e  BNB Chain  0xa27a2ca24dd28ce14fb5f5844b59851f03dcf182  Avalanche  0xcd2e3622d483c7dc855f72e5eafadcd577ac78b4  Polygon  0x75dc8e5f50c8221a82ca6af64af811caa983b65f  Arbitrum  0x177d36dbe2271a4ddb2ad8304d82628eb921d790  Optimism  0x81e792e5a9003cc1c8bf5569a00f34b65d75b017  Fantom  0x52eea5c490fb89c7a0084b32feab854eeff07c82  DFK  0x473132bb594caef281c68718f4541f73fe14dc89  Harmony  0x7cbd185f21bef4d87310d0171ad5f740bc240e26  Dexalot  0x5b19bd330a84c049b62d5b0fc2ba120217a18c1c  Celo  0x15e51701f245f6d5bd0fee87bcaf55b0841451b3  Moonbeam  0xcccdd23e11f3f47c37fc0a7c3be505901912c6cc  Fuse  0x5b19bd330a84c049b62d5b0fc2ba120217a18c1c  Gnosis  0x5b19bd330a84c049b62d5b0fc2ba120217a18c1c  Klaytn  0x5b19bd330a84c049b62d5b0fc2ba120217a18c1c  Metis  0x5b19bd330a84c049b62d5b0fc2ba120217a18c1c  CoreDAO  0xfe7c30860d01e28371d40434806f4a8fcdd3a098  OKT (OKX)  0xfe7c30860d01e28371d40434806f4a8fcdd3a098  Polygon zkEVM  0xa658742d33ebd2ce2f0bdff73515aa797fd161d9  Canto  0x5b19bd330a84c049b62d5b0fc2ba120217a18c1c  zkSync Era  0x9923573104957bf457a3c4df0e21c8b389dd43df  Moonriver  0xe9ae261d3aff7d3fccf38fa2d612dd3897e07b2d  Tenet  0xaab5a48cfc03efa9cc34a2c1aacccb84b4b770e4  Arbitrum Nova  0xa658742d33ebd2ce2f0bdff73515aa797fd161d9  Meter.io  0x442b4bef4d1df08ebbff119538318e21b3c61eb9  Base  0xcb566e3B6934Fa77258d68ea18E931fa75e1aaAa  Linea  0xA658742d33ebd2ce2F0bdFf73515Aa797Fd161D9  Previous Mainnet Addresses Next UltraLightNodeV2 And NonceContract Addresses Last modified  23d ago", "labels": ["Documentation"]}, {"title": "Multisig Wallets", "html_url": "https://layerzero.gitbook.io/docs/technical-reference/mainnet/multisig-wallets", "body": "Multisig Wallets Multisigs Ethereum 0xCDa8e3ADD00c95E5035617F970096118Ca2F4C92 BNB 0x8D452629c5FfCDDE407069da48c096e1F8beF22c Avalanche 0xcE958C3Fb6fbeCAA5eef1E4dAbD13418bc1ba483 Polygon 0xF1a5F92F5F89e8b539136276f827BF1648375312 Arbitrum 0xFE22f5D2755b06b9149656C5793Cb15A08d09847 Optimism 0x2458BAAbfb21aE1da11D9dD6AD4E48aB2fBF9959 Fantom 0x42A36d2E002E38805109905db20FDB7a0B9e481c Metis 0xF7715218344c32Efbf93F81C4C178B2dA0b3b12D Previous Default Config Next  - Technical Reference LayerZero Interfaces Last modified  5mo ago", "labels": ["Documentation"]}, {"title": "Mainnet Addresses", "html_url": "https://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids", "body": "Mainnet Addresses The omnichain contracts for sending messages Official Endpoint Addresses These are the mainnet contract addresses  of the contracts on which you would  call  send()  See  testnet  here to play around. Note:   chainId  values are not related to EVM ids. Since LayerZero will span EVM & non-EVM chains the  chainId  are proprietary to our Endpoints. Ethereum chainId :  101 endpoint :  0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675 BNB Chain chainId :  102 endpoint :  0x3c2269811836af69497E5F486A85D7316753cf62 Avalanche chainId :  106 endpoint :  0x3c2269811836af69497E5F486A85D7316753cf62 Aptos chainId :  108 endpoint :   0x54ad3d30af77b60d939ae356e6606de9a4da67583f02b962d2d3f2e481484e90 layerzero_apps: 0x43d8cad89263e6936921a0adb8d5d49f0e236c229460f01b14dca073114df2b9 Polygon chainId :  109 endpoint :  0x3c2269811836af69497E5F486A85D7316753cf62 Arbitrum chainId :  110 endpoint :  0x3c2269811836af69497E5F486A85D7316753cf62 Optimism chainId :  111 endpoint :  0x3c2269811836af69497E5F486A85D7316753cf62 Fantom chainId :  112 endpoint :  0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7 DFK chainId :  115 endpoint :  0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4 Harmony chainId :  116 endpoint :  0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4 Dexalot chainId :  118 endpoint :  0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4 Celo chainId :  125 endpoint :  0x3A73033C0b1407574C76BdBAc67f126f6b4a9AA9 Moonbeam chainId :  126 endpoint :  0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4 Fuse chainId :  138 endpoint :  0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4 Gnosis chainId :  145 endpoint :  0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4 Klaytn chainId :  150 endpoint :  0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4 Metis chainId :  151 endpoint :  0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4 CoreDAO chainId :  153 endpoint :  0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4 OKT (OKX) chainId :  155 endpoint :  0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4 Polygon zkEVM chainId :  158 endpoint :  0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4 Canto chainId :  159 endpoint :  0x9740FF91F1985D8d2B71494aE1A2f723bb3Ed9E4 zkSync Era chainId :  165 endpoint :  0x9b896c0e23220469C7AE69cb4BbAE391eAa4C8da Moonriver chainId :  167 endpoint :  0x7004396C99D5690da76A7C59057C5f3A53e01704 Tenet chainId :  173 endpoint :  0x2D61DCDD36F10b22176E0433B86F74567d529aAa Arbitrum Nova chainId :  175 endpoint :  0x4EE2F9B7cf3A68966c370F3eb2C16613d3235245 Meter.io chainId :  176 endpoint :  0xa3a8e19253Ab400acDac1cB0eA36B88664D8DedF Sepolia This endpoint is connected to Ethereum, Arbitrum, Optimism only on mainnet. chainId :  161 endpoint :  0x7cacBe439EaD55fa1c22790330b12835c6884a91 Kava chainId :  177 endpoint :  0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7 Linea chainId :  183 endpoint :  0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7  Base chainId :  184 endpoint :  0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7  Mantle chainId :  181 endpoint :  0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7  Loot  chainId :  197 endpoint :  0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7 MeritCircle (aka Beam) chainId :  198 endpoint :  0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7 Zora chainId :  195 endpoint :  0xb6319cC6c8c27A8F5dAF0dD3DF91EA35C4720dd7 Technical Reference -  Previous Mainnet Next LayerZero Labs Relayer.sol Addresses Last modified  27d ago", "labels": ["Documentation"]}, {"title": "UltraLightNodeV2 And NonceContract Addresses", "html_url": "https://layerzero.gitbook.io/docs/technical-reference/mainnet/ultralightnodev2-and-noncecontract-addresses", "body": "UltraLightNodeV2 And NonceContract Addresses Ethereum UltraLightNodeV2.sol:   0x4d73adb72bc3dd368966edd0f0b2148401a178e2  NonceContract.sol:   0x5B905fE05F81F3a8ad8B28C6E17779CFAbf76068  BNB Chain UltraLightNode.sol:   0x4D73AdB72bC3DD368966edD0f0b2148401A178E2  NonceContract.sol:   0x5B905fE05F81F3a8ad8B28C6E17779CFAbf76068  Avalanche UltraLightNode.sol:   0x4D73AdB72bC3DD368966edD0f0b2148401A178E2  NonceContract.sol:   0x5B905fE05F81F3a8ad8B28C6E17779CFAbf76068  Polygon UltraLightNode.sol:   0x4D73AdB72bC3DD368966edD0f0b2148401A178E2  NonceContract.sol:   0x5B905fE05F81F3a8ad8B28C6E17779CFAbf76068  Arbitrum UltraLightNode.sol:   0x4D73AdB72bC3DD368966edD0f0b2148401A178E2  NonceContract.sol:   0x5B905fE05F81F3a8ad8B28C6E17779CFAbf76068  Optimism UltraLightNode.sol:   0x4D73AdB72bC3DD368966edD0f0b2148401A178E2  NonceContract.sol:   0x5B905fE05F81F3a8ad8B28C6E17779CFAbf76068  Fantom UltraLightNode.sol:   0x4D73AdB72bC3DD368966edD0f0b2148401A178E2  NonceContract.sol:   0x5B905fE05F81F3a8ad8B28C6E17779CFAbf76068  Metis UltraLightNode.sol:   0x38dE71124f7a447a01D67945a51eDcE9FF491251  NonceContract.sol:   0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675  Base UltraLightNode.sol:   0x38dE71124f7a447a01D67945a51eDcE9FF491251  NonceContract.sol:   0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675  Linea UltraLightNode.sol:   0x38dE71124f7a447a01D67945a51eDcE9FF491251  NonceContract.sol:   0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675   Table below shows the default send and receive versions which correspond to the UltraLightNodeV2.sol. It is send/recv version 2 for earlier deployments, and 1 for more recently supported chains. UltraLightNodeV2.sol is the default send & receive version for all chains      Previous LayerZero Labs Relayer.sol Addresses Next Default Config Last modified  22d ago", "labels": ["Documentation"]}, {"title": "Deprecated Libraries", "html_url": "https://layerzero.gitbook.io/docs/technical-reference/proof-types/deprecated-libraries", "body": "Deprecated Libraries These libraries are deprecated. Please use V2. NETWORK UltraLightNode (Messaging Library V1) Ethereum Validation Library V1 BNB Validation Library V1 Avalanche Validation Library V1 Polygon Validation Library V1 Arbitrum Validation Library V1 Optimism Validation Library V1 Fantom Validation Library V1  Technical Reference -  Previous Proof Types Next  - Technical Reference Audits Last modified  1yr ago", "labels": ["Documentation"]}, {"title": "Default Config", "html_url": "https://layerzero.gitbook.io/docs/technical-reference/testnet/default-config", "body": "Default Config User Applications default configuration To simplify writing a User Application contract, LayerZero does not require any configuration. In this case, a UA sending messages will be using the system defaults. The Default Configuration Oracle: Industry TSS Oracle (Polygon, Sequoia)  Relayer: LayerZero Labs Library Version: 1 Outbound Proof Type:  1, MPT  Outbound Confirmations: 4 Inbound Proof Library: 1, MPT Inbound Confirmation: 4 Sending messages Default  _adapterParams Type: Version 1 Gas Amount: 200,000 Default Block Confirmation // These are the default amount of block confirmations waiting before delivering messages (TESTNET) const  defaultBlockConfs  =   {   [ ChainId . BSC_TESTNET ] :   5 ,   [ ChainId . FUJI ] :   6 ,   [ ChainId . MUMBAI ] :   10 ,   [ ChainId . FANTOM_TESTNET ] :   7 ,   [ ChainId . SWIMMER_TESTNET ] :   5 ,   [ ChainId . DFK_TESTNET ] :   1 ,     [ ChainId . HARMONY_TESTNET ] :   5 ,   [ ChainId . MOONBEAM_TESTNET ] :   3 ,   [ ChainId . CASTLECRUSH_TESTNET ] :   1 ,   [ ChainId . GOERLI ] :   3 ,   [ ChainId . ARBITRUM_GOERLI ] :   3 ,   [ ChainId . OPTIMISM_GOERLI ] :   3 ,   [ ChainId . INTAIN_TESTNET ] :   1 ,   [ ChainId . CELO_TESTNET ] :   1 ,   [ ChainId . FUSE_TESTNET ] :   1 ,   [ ChainId . APTOS_TESTNET ] :   10 ,   [ ChainId . DOS_TESTNET ] :   1 ,   [ ChainId . ZKSYNC_TESTNET ] :   10 ,   [ ChainId . SHRAPNEL_TESTNET ] :   1 ,   [ ChainId . KLAYTN_TESTNET ] :   1 ,   [ ChainId . METIS_TESTNET ] :   1 ,   [ ChainId . COREDAO_TESTNET ] :   1 ,   [ ChainId . GNOSIS_TESTNET ] :   1 , } Transactions originating from the above chains should be delivered after a minimum of the specified source Block Confirmations  Previous Testnet Addresses Next  - Technical Reference Mainnet Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "Testnet Addresses", "html_url": "https://layerzero.gitbook.io/docs/technical-reference/testnet/testnet-addresses", "body": "Testnet Addresses Supported Chains (Testnet)To send and receive messages, LayerZero endpoints use a chainId to identify different blockchains. Below is a table of the supported test networks along with their unique chainId.Review carefully. LayerZero assigns proprietary IDs to each chain. Official Endpoint Addresses (TESTNET) Note:  chainId  values are not related to EVM IDs. Since LayerZero will span EVM &  non-EVM chains the  chainId  are proprietary to our Endpoints. These are the addresses of the contracts on which you  would call  send()  By the way, if you want to go straight to  mainnet , look no further. Goerli (Ethereum Testnet) chainId :  10121 endpoint :  0xbfD2135BFfbb0B5378b56643c2Df8a87552Bfa23 BNB Chain (Testnet) chainId :  10102 endpoint :  0x6Fcb97553D41516Cb228ac03FdC8B9a0a9df04A1 Fuji (Avalanche Testnet) chainId :  10106 endpoint :  0x93f54D755A063cE7bB9e6Ac47Eccc8e33411d706 Aptos (Testnet) chainId :  10108 endpoint :  0x1759cc0d3161f1eb79f65847d4feb9d1f74fb79014698a23b16b28b9cd4c37e3 Mumbai (Polygon Testnet) chainId :  10109 endpoint :  0xf69186dfBa60DdB133E91E9A4B5673624293d8F8 Fantom (Testnet) chainId :  10112 endpoint :  0x7dcAD72640F835B0FA36EFD3D6d3ec902C7E5acf Arbitrum-Goerli (Testnet) chainId :  10143 endpoint :  0x6aB5Ae6822647046626e83ee6dB8187151E1d5ab Optimism-Goerli (Testnet) chainId :  10132 endpoint :  0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1 Harmony (Testnet) chainId :  10133 endpoint :  0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1 Moonbeam (Testnet) chainId :  10126 endpoint :   0xb23b28012ee92E8dE39DEb57Af31722223034747 Celo (Testnet) chainId :  10125 endpoint :  0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1 Dexalot (Testnet) chainId :  10118 endpoint :  0x6C7Ab2202C98C4227C5c46f1417D81144DA716Ff Portal Fantasy (Testnet) chainId :  10128 endpoint :  0xd682ECF100f6F4284138AA925348633B0611Ae21 Klaytn (Testnet) chainId :  10150 endpoint :  0x6aB5Ae6822647046626e83ee6dB8187151E1d5ab Metis (Testnet) chainId :  10151 endpoint :  0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1 CoreDao (Testnet) chainId :  10153 endpoint :  0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1 Gnosis (Testnet) chainId :  10145 endpoint :  0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1 zkSync (Testnet) chainId :  10165 endpoint :  0x093D2CF57f764f09C3c2Ac58a42A2601B8C79281 OKX (Testnet) chainId :  10155 endpoint :  0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1 Base (Testnet) chainId :  10160 endpoint :  0x6aB5Ae6822647046626e83ee6dB8187151E1d5ab Meter (Testnet) chainId :  10156 endpoint :  0x3De2f3D1Ac59F18159ebCB422322Cb209BA96aAD Linea (ConsenSys zkEVM - Testnet) chainId :  10157 endpoint :  0x6aB5Ae6822647046626e83ee6dB8187151E1d5ab DOS (Testnet) chainId :  10162 endpoint :  0x45841dd1ca50265Da7614fC43A361e526c0e6160 Sepolia (Testnet) chainId :  10161 endpoint :  0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1 Polygon zkEVM (Testnet) chainId :  10158 endpoint :  0x6aB5Ae6822647046626e83ee6dB8187151E1d5ab Scroll (Testnet) chainId :  10170 endpoint :  0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1 Tenet (Testnet) chainId :  10173 endpoint :  0x6aB5Ae6822647046626e83ee6dB8187151E1d5ab Canto (Testnet) chainId :  10159 endpoint :  0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1 Kava (Testnet) chainId :  10172 endpoint :  0x8b14D287B4150Ff22Ac73DF8BE720e933f659abc Orderly (Testnet - opstack) chainId :  10200 endpoint : 0x83c73Da98cf733B03315aFa8758834b36a195b87 BlockGen (Testnet) chainId :  10177 endpoint :  0x55370E0fBB5f5b8dAeD978BA1c075a499eB107B8 MeritCircle (Testnet) chainId :  10178 endpoint :  0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1 Mantle (Testnet) chainId :  10181 endpoint :  0x2cA20802fd1Fd9649bA8Aa7E50F0C82b479f35fe Hubble (Testnet) chainId :  10182 endpoint :  0x8b14D287B4150Ff22Ac73DF8BE720e933f659abc Aavegotchi (Testnet) chainId :  10191 endpoint :  0xfeBE4c839EFA9f506C092a32fD0BB546B76A1d38 Loot (Testnet) chainId :  10197 endpoint :  0x83c73Da98cf733B03315aFa8758834b36a195b87 Telos (Testnet) chainId :  10199 endpoint :  0x83c73Da98cf733B03315aFa8758834b36a195b87 Zora (Testnet) chainId :  10195 endpoint :  0x83c73Da98cf733B03315aFa8758834b36a195b87 Tomo (Testnet) chainId :  10196 endpoint :  0xae92d5aD7583AD66E49A0c67BAd18F6ba52dDDc1 opBNB (Testnet) chainId :  10202 endpoint :  0x83c73Da98cf733B03315aFa8758834b36a195b87 Shimmer (Testnet) chainId :  10203 endpoint :  0x83c73Da98cf733B03315aFa8758834b36a195b87 Aurora (Testnet) chainId :  10201 endpoint :  0x83c73Da98cf733B03315aFa8758834b36a195b87 Lif3 (Testnet) chainId :  10205 endpoint :  0x55370E0fBB5f5b8dAeD978BA1c075a499eB107B8 Technical Reference -  Previous Testnet Next Default Config Last modified  26d ago", "labels": ["Documentation"]}, {"title": "zkLightClient Addresses", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/oracle/overview-of-polyhedra-zklightclient/zklightclient-addresses", "body": "zkLightClient Addresses Contract Addresses to use zkLightClient with LayerZero To use the Polyhedra zkLightClient with your LayerZero UserApplication, configure your app with the oracle addresses below. zkLightClient Addresses (Mainnets) Ethereum 0x394ee343625B83B5778d6F42d35142bdf26dBAcD BNB Smart Chain 0x76ce31EfB81a013b609CeeF1Cc4F4E5aEeA70B7f Polygon 0x9D88a2f4253b106A1F8e169485490f7230b4276e CoreDAO:  0x6590C7e65EEC453a78199B0bE418dF7291DF9039 Avalanche 0xD59DdbF4c0E1ed3debD2f7afFc1fA9dEF198A652 Fantom 0x7cE1fab01F3cd7253731a9e11180d49ac960285C Optimism 0x40b237EDdb5B851C60630446ca120A1D5c7B6253 Arbitrum One 0x2274D83ed2B4c1fCd6C1CCBF9b734F7e436DfD44 Moonbeam0xE04E090a49aE0AF87583B808B05d2dc8c4d1E712 Gnosis Chain 0xFd1fabb34c4D6B5D30a1bFE2Fa76Cc15206fb368 Metis 0x057DCB38db5350Db12DCD94428c303D523f72153 Arbitrum Nova 0xD2C51b14cA69D7E557719A8534e1c5514f28DB3b zkLightClient Addresses (Testnets) Ethereum Goerli Testnet:  0x55d193eF196Be455c9c178b0984d7F9cE750CCb4 BNB Smart Chain Testnet:  0x2C41853Ed4681A39c89c61Cdeb8c155561391215 Avalanche Fuji Testnet:  0x8517BA5E3eda338d9707a7B4a36033331e3d3B00 Optimism Goerli Testnet:  0x1853f53Aa7d9f6aF8537833c4255f928ab8F9D61 Arbitrum Goerli Testnet:  0xbFB5FEE3DCf2aF08F9f7a05049806fBC2E72A702 Previous zkLightClient on LayerZero Next  - Technical Reference Testnet Last modified  16d ago", "labels": ["Documentation"]}, {"title": "zkLightClient on LayerZero", "html_url": "https://layerzero.gitbook.io/docs/ecosystem/oracle/overview-of-polyhedra-zklightclient/zklightclient-on-layerzero", "body": "zkLightClient on LayerZero Integrating Polyhedra zkLightClient technology into LayerZero LayerZero is an omnichain interoperability protocol that enables cross-chain messaging. Applications built using blockchain technology (decentralized applications) can use the LayerZero protocol to connect to 30+ supported blockchains seamlessly. This allows dApp users to interact securely and efficiently with assets across chains.  Polyhedra's zkLightClient technology is fully integrated with LayerZero's messaging protocol, so application developers can use zero-knowledge-proof technology without barriers. Developers can easily build cross-chain applications on top of LayerZero through its extensive developer tooling and community support.  Incorporating Polyhedra zkLightClient technology into Layerzero Network LayerZero's ULNv2 validation library relies on two parties, the Oracle and Relayer, to transfer messages between on-chain endpoints. When LayerZero sends a message from chain A to chain B, the message is routed through the endpoint on chain A to the ULNv2 validation library. The ULNv2 library notifies the Oracle and Relayer of the message and its destination chain. The Oracle forwards the packet hash to the endpoint on chain B, and the Relayer submits the packet to be verified on-chain against the hash and delivers the message. On-chain light clients allow for the source chain's validator set to attest to something that occurred on their chain to a destination chain. In conjunction with other libraries, light clients add a layer of security on top of the LayerZero messaging protocol. On-chain transaction verification has been cost-prohibitive to the tune of  $50m-$100m/day per pair-wise chain connected to Ethereum due to the presence of extensive transaction logs, which are necessary for the proof but not for the application itself.   Polyhedra's zkLightClient technology, built on LayerZero, harnesses the compression of ZKP technology and reduces the on-chain verification tremendously with lower latency by using efficient ZKP protocols. In addition, multiple transaction verifications can be batched into a single zero-knowledge proof.  Previous Overview of Polyhedra zkLightClient Next zkLightClient Addresses Last modified  15d ago", "labels": ["Documentation"]}, {"title": "ILayerZeroEndpoint", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/interfaces/evm-solidity-interfaces/ilayerzeroendpoint", "body": "ILayerZeroEndpoint // SPDX-License-Identifier: BUSL-1.1  pragma   solidity   >= 0.5.0 ;  import   \"./ILayerZeroUserApplicationConfig.sol\" ;  interface   ILayerZeroEndpoint   is  ILayerZeroUserApplicationConfig  {   // @notice send a LayerZero message to the specified address at a LayerZero endpoint.   // @param _dstChainId - the destination chain identifier   // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains   // @param _payload - a custom bytes payload to send to the destination contract   // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address   // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction   // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination   function   send ( uint16  _dstChainId ,   bytes   calldata  _destination ,   bytes   calldata  _payload ,   address   payable  _refundAddress ,   address  _zroPaymentAddress ,   bytes   calldata  _adapterParams )   external   payable ;    // @notice used by the messaging library to publish verified payload   // @param _srcChainId - the source chain identifier   // @param _srcAddress - the source contract (as bytes) at the source chain   // @param _dstAddress - the address on destination chain   // @param _nonce - the unbound message ordering nonce   // @param _gasLimit - the gas limit for external contract execution   // @param _payload - verified payload to send to the destination contract   function   receivePayload ( uint16  _srcChainId ,   bytes   calldata  _srcAddress ,   address  _dstAddress ,   uint64  _nonce ,   uint  _gasLimit ,   bytes   calldata  _payload )   external ;    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain   // @param _srcChainId - the source chain identifier   // @param _srcAddress - the source chain contract address   function   getInboundNonce ( uint16  _srcChainId ,   bytes   calldata  _srcAddress )   external   view   returns   ( uint64 );    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM   // @param _srcAddress - the source chain contract address   function   getOutboundNonce ( uint16  _dstChainId ,   address  _srcAddress )   external   view   returns   ( uint64 );    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery   // @param _dstChainId - the destination chain identifier   // @param _userApplication - the user app address on this EVM chain   // @param _payload - the custom message to send over LayerZero   // @param _payInZRO - if false, user app pays the protocol fee in native token   // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain   function   estimateFees ( uint16  _dstChainId ,   address  _userApplication ,   bytes   calldata  _payload ,   bool  _payInZRO ,   bytes   calldata  _adapterParam )   external   view   returns   ( uint  nativeFee ,   uint  zroFee );    // @notice get this Endpoint's immutable source identifier   function   getChainId ()   external   view   returns   ( uint16 );    // @notice the interface to retry failed message on this Endpoint destination   // @param _srcChainId - the source chain identifier   // @param _srcAddress - the source chain contract address   // @param _payload - the payload to be retried   function   retryPayload ( uint16  _srcChainId ,   bytes   calldata  _srcAddress ,   bytes   calldata  _payload )   external ;    // @notice query if any STORED payload (message blocking) at the endpoint.   // @param _srcChainId - the source chain identifier   // @param _srcAddress - the source chain contract address   function   hasStoredPayload ( uint16  _srcChainId ,   bytes   calldata  _srcAddress )   external   view   returns   ( bool );    // @notice query if the _libraryAddress is valid for sending msgs.   // @param _userApplication - the user app address on this EVM chain   function   getSendLibraryAddress ( address  _userApplication )   external   view   returns   ( address );    // @notice query if the _libraryAddress is valid for receiving msgs.   // @param _userApplication - the user app address on this EVM chain   function   getReceiveLibraryAddress ( address  _userApplication )   external   view   returns   ( address );    // @notice query if the non-reentrancy guard for send() is on   // @return true if the guard is on. false otherwise   function   isSendingPayload ()   external   view   returns   ( bool );    // @notice query if the non-reentrancy guard for receive() is on   // @return true if the guard is on. false otherwise   function   isReceivingPayload ()   external   view   returns   ( bool );    // @notice get the configuration of the LayerZero messaging library of the specified version   // @param _version - messaging library version   // @param _chainId - the chainId for the pending config change   // @param _userApplication - the contract address of the user application   // @param _configType - type of configuration. every messaging library has its own convention.   function   getConfig ( uint16  _version ,   uint16  _chainId ,   address  _userApplication ,   uint  _configType )   external   view   returns   ( bytes   memory );    // @notice get the send() LayerZero messaging library version   // @param _userApplication - the contract address of the user application   function   getSendVersion ( address  _userApplication )   external   view   returns   ( uint16 );    // @notice get the lzReceive() LayerZero messaging library version   // @param _userApplication - the contract address of the user application   function   getReceiveVersion ( address  _userApplication )   external   view   returns   ( uint16 ); }  Previous ILayerZeroReceiver Next ILayerZeroMessagingLibrary Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "ILayerZeroMessagingLibrary", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/interfaces/evm-solidity-interfaces/ilayerzeromessaginglibrary", "body": "ILayerZeroMessagingLibrary // SPDX-License-Identifier: BUSL-1.1  pragma   solidity   >= 0.7.0 ;  import   \"./ILayerZeroUserApplicationConfig.sol\" ;  interface   ILayerZeroMessagingLibrary   {   // send(), messages will be inflight.   function   send ( address  _userApplication ,   uint64  _lastNonce ,   uint16  _chainId ,   bytes   calldata  _destination ,   bytes   calldata  _payload ,   address   payable  refundAddress ,   address  _zroPaymentAddress ,   bytes   calldata  _adapterParams )   external   payable ;    // estimate native fee at the send side   function   estimateFees ( uint16  _chainId ,   address  _userApplication ,   bytes   calldata  _payload ,   bool  _payInZRO ,   bytes   calldata  _adapterParam )   external   view   returns   ( uint  nativeFee ,   uint  zroFee );    //---------------------------------------------------------------------------   // setConfig / getConfig are User Application (UA) functions to specify Oracle, Relayer, blockConfirmations, libraryVersion   function   setConfig ( uint16  _chainId ,   address  _userApplication ,   uint  _configType ,   bytes   calldata  _config )   external ;    function   getConfig ( uint16  _chainId ,   address  _userApplication ,   uint  _configType )   external   view   returns   ( bytes   memory ); }  Previous ILayerZeroEndpoint Next ILayerZeroUserApplicationConfig Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "ILayerZeroOracle.sol", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/interfaces/evm-solidity-interfaces/ilayerzerooracle.sol", "body": "ILayerZeroOracle.sol // SPDX-License-Identifier: BUSL-1.1  pragma   solidity   >= 0.7.0 ;  interface   ILayerZeroOracle   {   // @notice query the oracle price for relaying block information to the destination chain   // @param _dstChainId the destination endpoint identifier   // @param _outboundProofType the proof type identifier to specify the data to be relayed   function   getPrice ( uint16  _dstChainId ,   uint16  _outboundProofType )   external   view   returns   ( uint  price );    // @notice Ultra-Light Node notifies the Oracle of a new block information relaying request   // @param _dstChainId the destination endpoint identifier   // @param _outboundProofType the proof type identifier to specify the data to be relayed   // @param _outboundBlockConfirmations the number of source chain block confirmation needed   function   notifyOracle ( uint16  _dstChainId ,   uint16  _outboundProofType ,   uint64  _outboundBlockConfirmations )   external ;    // @notice query if the address is an approved actor for privileges like data submission and fee withdrawal etc.   // @param _address the address to be checked   function   isApproved ( address  _address )   external   view   returns   ( bool  approved ); }  Previous ILayerZeroUserApplicationConfig Next ILayerZeroRelayer.sol Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "ILayerZeroReceiver", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/interfaces/evm-solidity-interfaces/ilayerzeroreceiver", "body": "ILayerZeroReceiver For User Application contracts to receive messages! // SPDX-License-Identifier: BUSL-1.1  pragma   solidity   >= 0.5.0 ;  interface   ILayerZeroReceiver   {   // @notice LayerZero endpoint will invoke this function to deliver the message on the destination   // @param _srcChainId - the source endpoint identifier   // @param _srcAddress - the source sending contract address from the source chain   // @param _nonce - the ordered message nonce   // @param _payload - the signed payload is the UA bytes has encoded to be sent   function   lzReceive ( uint16  _srcChainId ,   bytes   calldata  _srcAddress ,   uint64  _nonce ,   bytes   calldata  _payload )   external ; } This is a core interface for contract to implement so they can receive LayerZero messages! See the  CounterMock  example for usage Previous EVM (Solidity) Interfaces Next ILayerZeroEndpoint Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "ILayerZeroRelayer.sol", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/interfaces/evm-solidity-interfaces/ilayerzerorelayer.sol", "body": "ILayerZeroRelayer.sol // SPDX-License-Identifier: BUSL-1.1  pragma   solidity   >= 0.7.0 ;  interface   ILayerZeroRelayer   {   // @notice query the relayer price for relaying the payload and its proof to the destination chain   // @param _dstChainId - the destination endpoint identifier   // @param _outboundProofType - the proof type identifier to specify proof to be relayed   // @param _userApplication - the source sending contract address. relayers may apply price discrimination to user apps   // @param _payloadSize - the length of the payload. it is an indicator of gas usage for relaying cross-chain messages   // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain   function   getPrice ( uint16  _dstChainId ,   uint16  _outboundProofType ,   address  _userApplication ,   uint  _payloadSize ,   bytes   calldata  _adapterParams )   external   view   returns   ( uint  price );    // @notice Ultra-Light Node notifies the Oracle of a new block information relaying request   // @param _dstChainId - the destination endpoint identifier   // @param _outboundProofType - the proof type identifier to specify the data to be relayed   // @param _adapterParams - optional parameters for extra service plugins, e.g. sending dust tokens at the destination chain   function   notifyRelayer ( uint16  _dstChainId ,   uint16  _outboundProofType ,   bytes   calldata  _adapterParams )   external ;    // @notice query if the address is an approved actor for privileges like data submission and fee withdrawal etc.   // @param _address - the address to be checked   function   isApproved ( address  _address )   external   view   returns   ( bool  approved ); }  Previous ILayerZeroOracle.sol Next  - EVM Guides Error Messages Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "ILayerZeroUserApplicationConfig", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/interfaces/evm-solidity-interfaces/ilayerzerouserapplicationconfig", "body": "ILayerZeroUserApplicationConfig ILayerZeroUserApplicationConfig.sol  // SPDX-License-Identifier: BUSL-1.1  pragma   solidity   >= 0.5.0 ;  interface   ILayerZeroUserApplicationConfig   {   // @notice set the configuration of the LayerZero messaging library of the specified version   // @param _version - messaging library version   // @param _chainId - the chainId for the pending config change   // @param _configType - type of configuration. every messaging library has its own convention.   // @param _config - configuration in the bytes. can encode arbitrary content.   function   setConfig ( uint16  _version ,   uint16  _chainId ,   uint  _configType ,   bytes   calldata  _config )   external ;    // @notice set the send() LayerZero messaging library version to _version   // @param _version - new messaging library version   function   setSendVersion ( uint16  _version )   external ;    // @notice set the lzReceive() LayerZero messaging library version to _version   // @param _version - new messaging library version   function   setReceiveVersion ( uint16  _version )   external ;    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload   // @param _srcChainId - the chainId of the source chain   // @param _srcAddress - the contract address of the source contract at the source chain   function   forceResumeReceive ( uint16  _srcChainId ,   bytes   calldata  _srcAddress )   external ; }  Previous ILayerZeroMessagingLibrary Next ILayerZeroOracle.sol Last modified  3mo ago", "labels": ["Documentation"]}, {"title": "IERC165 OFT Interface Ids", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/layerzero-omnichain-contracts/oft/ierc165-oft-interface-ids", "body": "IERC165 OFT Interface Ids Use these interface ids to determine which version of OFT is deployed. OFT(v1):  0x14e4ceea OFTV2:  0x1f7ecdf7 OFTWithFee:  0x6984a9e8 interface ERC165 {     /// @notice Query if a contract implements an interface     /// @param interfaceID The interface identifier, as specified in ERC-165     /// @dev Interface identification is specified in ERC-165. This function     ///  uses less than 30,000 gas.     /// @return `true` if the contract implements `interfaceID` and     ///  `interfaceID` is not 0xffffffff, `false` otherwise     function supportsInterface(bytes4 interfaceID) external view returns (bool); } Example Hardhat Task module . exports   =   async   function   ( taskArgs )   {   const  OFTInterfaceId  =   0x14e4ceea ;   const  OFTV2InterfaceId  =   0x1f7ecdf7 ;   const  OFTWithFeeInterfaceId  =   0x6984a9e8 ;    const   ERC165ABI   =   [   \"function supportsInterface(bytes4) public view returns (bool)\"   ];    try   {   const  contract  =   await  ethers . getContractAt ( ERC165ABI ,  taskArgs . address );   const  isOFT  =   await  contract . supportsInterface ( OFTInterfaceId );   const  isOFTV2  =   await  contract . supportsInterface ( OFTV2InterfaceId );   const  isOFTWithFee  =   await  contract . supportsInterface ( OFTWithFeeInterfaceId );    if ( isOFT )   {             console . log ( ` address:  ${ taskArgs . address }  is OFT(v1) ` )   }   else   if ( isOFTV2 )   {             console . log ( ` address:  ${ taskArgs . address }  is OFTV2 ` )   }   else   if ( isOFTWithFee )   {             console . log ( ` address:  ${ taskArgs . address }  is OFTWithFee ` )   }   else   {             console . log ( ` address:  ${ taskArgs . address }  is not an OFT ` )   }   }   catch   ( e )   {         console . log ( \"supportsInterface not implemented\" )   } } Previous OFT Next OFT (V1) vs OFTV2 - Which should I use? Last modified  2mo ago", "labels": ["Documentation"]}, {"title": "OFT (V1)", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/layerzero-omnichain-contracts/oft/oft-v1", "body": "OFT (V1) Omnichain Fungible Token standard written to support EVM chains only. OFT.sol solidity-examples/OFT.sol at main  LayerZero-Labs/solidity-examples GitHub Extensions ProxyOFT.sol Use this extension when you want to turn an already deployed ERC20 into an OFT. You can then deploy OFT contracts on the LayerZero supported chains of your choosing. When you want to transfer your OFT from the source chain the OFT will lock in the ProxyOFT and mint on the destination chain. When you come back to the ProxyOFT chain the OFT burns on the source chain and unlocks on the destination chain. solidity-examples/ProxyOFT.sol at main  LayerZero-Labs/solidity-examples GitHub Previous OFT (V1) vs OFTV2 - Which should I use? Next OFTV2 Last modified  7mo ago", "labels": ["Documentation"]}, {"title": "OFT (V1) vs OFTV2 - Which should I use?", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/layerzero-omnichain-contracts/oft/oft-v1-vs-oftv2-which-should-i-use", "body": "OFT (V1) vs OFTV2 - Which should I use? This page explains the differences between OFT/OFTV2 and when to use each one. When to use OFT (v1) Our Omnichain Fungible Token (OFT) was our first implementation of our standard. This OFT was first used in projects such as Stargate's token. The standard was written to support EVM chains only. If you are looking to only support EVMs now and forever then OFT (V1) is for you. When to use OFTV2 What if you want to build an Omnichain Fungible Token that supports EVMs and non EVMs (eg. Aptos)?  In this case you should use our OFTV2 which supports both. This version has fees, shared decimals, and composability built in. This version of OFTV2 is currently being used in projects such as  BTCb . What are the differences between the two versions? The main difference between the two versions comes from the limitations of the Non EVMs. Non EVM chains such as Aptos/Solana use Uint64 to represent balance. To account for this, OFTV2 uses Shared Decimals for value transfers to normalize the data type difference. It is recommended to use a smaller shared decimal point on all chains so that your token can have a larger balance. For example, if the decimal point is 18, then you can not have more than approximately 18 * 10^18 tokens bounded by the uint64.max. OFTV2 is intended to be used with no more than 10 shared decimals Previous IERC165 OFT Interface Ids Next OFT (V1) Last modified  7mo ago", "labels": ["Documentation"]}, {"title": "OFTV2", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/layerzero-omnichain-contracts/oft/oftv2", "body": "OFTV2 Omnichain Fungible Token that supports both EVMs and non EVMs OFTV2.sol solidity-examples/OFTV2.sol at main  LayerZero-Labs/solidity-examples GitHub Extensions ProxyOFTV2.sol Use this extension when you want to turn an already deployed ERC20 into an OFTV2. You can then deploy OFTV2 contracts on the LayerZero supported chains of your choosing. When you want to transfer your OFT from the source chain the OFT will lock in the ProxyOFTV2 and mint on the destination chain. When you come back to the ProxyOFTV2 chain the OFT burns on the source chain and unlocks on the destination chain. solidity-examples/ProxyOFTV2.sol at main  LayerZero-Labs/solidity-examples GitHub Previous OFT (V1) Next ONFT Last modified  7mo ago", "labels": ["Documentation"]}, {"title": "1155", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/layerzero-omnichain-contracts/onft/1155", "body": "1155 Omnichain NonFungible Token (ONFT1155) ONFT1155.sol solidity-examples/ONFT1155.sol at main  LayerZero-Labs/solidity-examples GitHub Extensions ProxyONFT1155.sol Use this extension when you want to turn an already deployed ERC1155 into an ONFT1155. You can then deploy ONFT1155 contracts on the LayerZero supported chains of your choosing. When you want to transfer your ONFT1155 from the source chain the ONFT1155 will lock in the ProxyONFT1155 and mint on the destination chain. When you come back to the ProxyONFT1155 chain the ONFT1155 burns on the source chain and unlocks on the destination chain. solidity-examples/ProxyONFT1155.sol at main  LayerZero-Labs/solidity-examples GitHub Previous 721 Next  - EVM Guides LayerZero Integration Checklist Last modified  7mo ago", "labels": ["Documentation"]}, {"title": "721", "html_url": "https://layerzero.gitbook.io/docs/evm-guides/layerzero-omnichain-contracts/onft/721", "body": "721 Omnichain NonFungible Token (ONFT721) ONFT721.sol solidity-examples/ONFT721.sol at main  LayerZero-Labs/solidity-examples GitHub Extensions ProxyONFT721.sol Use this extension when you want to turn an already deployed ERC721 into an ONFT721. You can then deploy ONFT contracts on the LayerZero supported chains of your choosing. When you want to transfer your ONFT from the source chain the ONFT will lock in the ProxyONFT721 and mint on the destination chain. When you come back to the ProxyONFT721 chain the ONFT locks on the source chain and unlocks on the destination chain. solidity-examples/ProxyONFT721.sol at main  LayerZero-Labs/solidity-examples GitHub Previous ONFT Next 1155 Last modified  7mo ago", "labels": ["Documentation"]}, {"title": "Home", "html_url": "https://resources.curve.fi/", "body": "Curve Resources               CurveDocs/curve-resources                 Home           Home           Table of contents         Welcome to Curve Finance           Sections         Useful links                         Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Welcome to Curve Finance           Sections         Useful links                          Home   Welcome to Curve Finance    Resources and guides to get started with Curve and the Curve DAO       Curve's Logo, a colorized  Klein Bottle      Curve is DeFi's leading  AMM , (Automated Market Maker). Hundreds of liquidity pools have been launched through Curve's factory and incentivized by Curve's DAO. Users rely on Curve's proprietary formulas to provide high liquidity, low slippage, and low fee transactions among ERC-20 tokens.   Those resources aim to help new and existing users to become familiar with the  Curve protocol , the  Curve DAO , and the  $CRV token .   Sections      Getting Started with  Curve v1  and  Curve v2   $CRV Token : Tokenomics, Staking, Claiming Fees   Liquidity Providers : Curve Pools, MetaPools, Depositing   Reward Gauges : Boosting, Gauge Weights   Stablecoin : crvUSD, Soft Liquidation, Bands   Governance : Vote Locking, Voting, Snapshot, Proposals   Multichain : Bridging, Fantom, Polygon, etc.    Creating Pools : Factory Pools, Crypto Factory Pools    Troubleshooting : Cross-Asset Swaps, Wallets, Stuck Transactions     Useful links        Governance dashboard:   http://dao.curve.fi/        Governance forum:   https://gov.curve.fi/        Telegram:   https://t.me/curvefi        Twitter:   https://twitter.com/curvefinance        Discord:   https://discord.gg/rgrfS7W        Youtube Channel:   http://www.youtube.com/c/CurveFinance        Technical Docs:   https://curve.readthedocs.io             Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Understanding crypto pools", "html_url": "https://resources.curve.fi/base-features/understanding-crypto-pools/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve               Understanding crypto pools           Understanding crypto pools           Table of contents         Understanding Curve v2           Whitepaper         Liquidity Providers         Fees         Risks                               $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Understanding Curve v2           Whitepaper         Liquidity Providers         Fees         Risks                          Understanding crypto pools   Understanding Curve v2    Crypto pools are Curve pools holding assets with different prices. Curve core originally was pegged assets but a new type of AMM allows for extremely efficient trading and low risks of non-pegged assets.   Crypto pools use liquidity more effectively by concentrating it at current prices. As trades happen, the pool readjusts its internal price to the highest liquidity region without creating losses for the pool. Crypto pools also have variable fees which can range between 0.04% and 0.40%.   Tricrypto , the first and main base pool has the following coins: USDT/WBTC/WETH for Ethereum. On Polygon, the first pool has AAVE tokens and can handle swaps with the following tokens: DAI/USDC/USDT/ETH/WBTC.   Whitepaper    Read the v2 whitepaper by  clicking here .   Liquidity Providers    Becoming a liquidity provider in a Curve Crypto pool is in all ways similar to stable pools. You will gain exposure and risks to all assets in the pools. You can deposit one or all the coins in the pool. Always be sure to check the bonus/slippage warning box.   Fees    Fees on those pool range from 0.04% to 0.4%. The current fee varies based on how close the price is from the internal oracle. You can check a pool's current fee which changes every trade on the bottom of a pool page.   Risks    As with any liquidity providing in blockchain, there are some smart contract risks involved. Curve crypto pools have been audited by MixBytes and ChainSecurity but audits never eliminate risks completely.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Understanding curve", "html_url": "https://resources.curve.fi/base-features/understanding-curve/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started             Understanding curve           Understanding curve           Table of contents         Understanding Curve v1           What is Curve.fi?         What are liquidity pools?         What are those percentages next to each pool?         What is the CRV token?         Can I use Curve on sidechains?         How Can I Launch a Pool         Why has Curve grown so quickly?         Where can I find Curve smart contracts?                       Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Understanding Curve v1           What is Curve.fi?         What are liquidity pools?         What are those percentages next to each pool?         What is the CRV token?         Can I use Curve on sidechains?         How Can I Launch a Pool         Why has Curve grown so quickly?         Where can I find Curve smart contracts?                          Understanding curve   Understanding Curve v1      A short guide to understand the basics of becoming a liquidity provider on Curve.     Getting started with Curve isnt easy, there is a lot to grasp and the unique UI can be a lot to take in. This small guide is intended for Curve beginners with an understanding of DeFi and Crypto. It tries to answer recurring questions about how to get started with Curve and how it works or makes money for liquidity providers.   What is Curve.fi?    The easiest way to understand Curve is to see it as an exchange. Its main goal is to let users and other decentralised protocols  exchange ERC-20 tokens (DAI to USDC for example) through it with low fees and low slippage . Unlike exchanges that match a buyer and a seller, Curve uses liquidity pools. To achieve successful exchange volume, Curve needs a high volume of liquidity (tokens) and therefore offers rewards to  liquidity providers .   Curve is  non-custodial , meaning the Curve developers do not have access to your tokens. Curve pools are also non-upgradable, so you can have confidence that the logic protecting your funds can never change.   What are liquidity pools?    Liquidity pools are pools of tokens that sit in smart contracts and can be exchanged or withdrawn at rates set by the parameters of the smart contract. Adding liquidity to a liquidity pool gives you the opportunity to earn trading fees and possibly rewards. For more information, visit the following section:   Understanding Curve Pools   What are those percentages next to each pool?    Curve pools may have several different percentages shown next to them in the UI.     The first column, vAPY, refers to the annualized rate of trading fees earned by liquidity providers in the pool. Any activity on every Curve pool generates fees, a portion of which accrue to everybody who has a stake in the pool. Further information is in the  Liquidity Provider section .   The second column refers to the reward gauges. This entitles liquidity providers to earn bonus CRV emissions. More detail on these bonuses are in the  Reward Gauges section .   What is the CRV token?    CRV token is a governance and utility token for Curve.   Understanding $CRV   Understanding Governance   Can I use Curve on sidechains?    Yes. Curve has launched on several sidechains and will continue to do so. Visit our section on Multichain for more information.   How Can I Launch a Pool    All new Curve pools are deployed permissionlessly through the Curve Factory. This means anybody can deploy a pool anytime, anywhere. For a full guide, check our Factory Pools section.    Why has Curve grown so quickly?    When Curve launched it grew quickly by securing the underdeveloped stablecoin market. Stablecoins have become an inherent part of cryptocurrency for a long time but they now come in many different flavours (DAI, TUSD, sUSD, bUSD, USDC and so on) which means there is a much bigger need for crypto users to move from a stable coin to another. Centralised exchanges tend to have high fees which are problematic for those trying to move from a stable coin to another. As a result, Curve.fi has become the best place to exchange stable coins because of its low fees and low slippage.   The proprietary Curve StableSwap exchange was outlined in the founding whitepaper, and provides a superior formula for exchanging stablecoins than competing AMMs. Read through the  whitepaper  to learn more.   More recently, Curve launched v2 Crypto Pools to bring the same simplicity and efficiency of Curve's stablecoin pools to transactions between differentially priced assets (ie BTC and ETH). These pools are sufficiently different to justify their own section:    Where can I find Curve smart contracts?    Here:  https://www.curve.fi/contracts   The  Github repository  also open sources the bulk of Curve development activity.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Claiming trading fees", "html_url": "https://resources.curve.fi/crv-token/claiming-trading-fees/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv               Claiming trading fees           Claiming trading fees           Table of contents         Claiming Trading Fees           Swapping 3CRV for a stable coin         How does it all work?                               Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Claiming Trading Fees           Swapping 3CRV for a stable coin         How does it all work?                          Claiming trading fees   Claiming Trading Fees    Users who stake $CRV can claim trading fees as often as you'd like, but fees will only be converted into 3CRV once a week.   To claim your fees, visit  https://curve.fi/#/ethereum/dashboard  and click the blue \"Claim LP Rewards\" button. If you are using the classic UI please visit:  https://classic.curve.fi/  and look for the green \"Claim\" button in the box labeled \"veCRV 3pool LP claim\" at the bottom of the page.   Every time a trade takes place on Curve Finance, 50% of the trading fee is collected by the users who have vote locked their CRV. Every week, fees are collected from the pools, converted to 3CRV and distributed.   There is a delay before you can first claim your 3CRV after locking. It takes 8 days from the Thursday after which you lock before you can claim.   Understanding $CRV   Swapping 3CRV for a stable coin    If you would like to swap your 3CRV back into a stable coin, you can head to  https://curve.fi/#/ethereum/pools/3pool/withdraw , select the stable you would like to receive (optional) and click \" Withdraw \". After confirming your transaction, you will then receive 3CRV.   How does it all work?    When the burn is triggered, a contract collects all trading fees from all the swap pool contracts. Those fees come in dozen of different stable coins, tokenized Bitcoin and Ethereum flavours. The fee tokens are traded into USDC using Curve and Synthetix, which is then deposited to 3Pool. Finally, the burner creates a checkpoint which updates all the claimable balance of each veCRV holder.   Burning is an expensive process, as it involves many complex transactions, but anyone can trigger the process whenever they wish if they are willing to pay for it.   Fees may only be claimed for the week that has already passed, because the burner does not know how much everyone is entitled to before the end of the period. Fees will be available on a weekly basis within 24 hours after Thursday midnight UTC, as long as someone (usually the Curve team) has initiated the burn prior to that.   Technical users can review the burner contracts here:  https://github.com/curvefi/curve-dao-contracts/tree/master/contracts/burners    The following script may be used to initiate the burn process:  https://github.com/curvefi/curve-dao-contracts/blob/master/scripts/burners/claim_and_burn_fees.py         Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Crv basics", "html_url": "https://resources.curve.fi/crv-token/crv-basics/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv               Crv basics           Crv basics           Table of contents         $CRV Basics           What is the purpose of $CRV?         How to get $CRV?         Where can I find the release schedule?         What is the current circulating supply?         What is the utility of $CRV?         What is $CRV vote locking?                       Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         $CRV Basics           What is the purpose of $CRV?         How to get $CRV?         Where can I find the release schedule?         What is the current circulating supply?         What is the utility of $CRV?         What is $CRV vote locking?                          Crv basics   $CRV Basics    Basics about the CRV token.   What is the purpose of $CRV?    The main purposes of the Curve DAO token are to incentivise liquidity providers on the Curve Finance platform as well as getting as many users involved as possible in the governance of the protocol.   How to get $CRV?    Liquidity providers on the Curve platform receive $CRV for providing liquidity. This ensures the protocol continues offering low fees and extremely low slippage.   Where can I find the release schedule?    You can find the release schedule for the next six years at this address:  https://dao.curve.fi/inflation    What is the current circulating supply?    The current circulating supply can be found at this address:  https://dao.curve.fi/inflation    What is the utility of $CRV?    $CRV is a governance token with time-weighted voting and value accrual mechanisms.   You can find out what to do with $CRV by clicking below:   Understanding $CRV   What is $CRV vote locking?    One of the most important incentive to holding CRV is the vote locking boost. Each liquidity provider can increase their daily CRV rewards by vote locking CRV. You can vote lock your CRV at this address:  https://dao.curve.fi/locker           Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Crv tokenomics", "html_url": "https://resources.curve.fi/crv-token/crv-tokenomics/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics               Crv tokenomics           Crv tokenomics           Table of contents         $CRV Tokenomics           Supply                       Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         $CRV Tokenomics           Supply                          Crv tokenomics   $CRV Tokenomics    $CRV officially launched on the 13 th  of August 2020. The main purposes of the Curve DAO token are to incentivise liquidity providers on the Curve Finance platform as well as getting as many users involved as possible in the governance of the protocol.   Supply    The total supply of 3.03b is distributed as such:     62% to community liquidity providers   30% to shareholders (team and investors) with 2-4 years vesting   3% to employees with 2 years vesting   5% to the community reserve     The initial supply of around 1.3b (~43%) is distributed as such:     5% to pre-CRV liquidity providers with 1 year vesting   30% to shareholders (team and investors) with 2-4 years vesting   3% to employees with 2 years vesting   5% to the community reserve     The circulating supply will be 0 at launch and the initial release rate will be around 2m CRV per day. Full release schedule here:  https://dao.curve.fi/releaseschedule          Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Staking your crv", "html_url": "https://resources.curve.fi/crv-token/staking-your-crv/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics               Staking your crv           Staking your crv           Table of contents         Staking your $CRV           Locking your $CRV         Claiming your trading fees         How to calculate the APY for staking CRV?           Further Reading                             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Staking your $CRV           Locking your $CRV         Claiming your trading fees         How to calculate the APY for staking CRV?           Further Reading                                Staking your crv   Staking your $CRV    Starting on the 19 th  of September 2020,  50% of all trading fees are distributed to veCRV holders . This is the result of a community-led proposal to align incentives between liquidity providers and governance participants (veCRV holders).   Collected fees will be used to buy 3CRV (LP token for 3Pool) and distribute them to veCRV holders. This currently represents over $15M in trading fees per year. veCRV stands for vote escrowed $CRV, they are $CRV vote locked in the Curve DAO.   Vote Locking   You can also lock $CRV to obtain a boost on your provided liquidity.   Boosting your CRV Rewards   Video about how to stake $CRV:  https://www.youtube.com/watch?v=8GAI1lopEdU             Locking your $CRV    Once you know how much and how long you wish to lock for, visit the following page:  https://dao.curve.fi/locker      Enter the amount you want to lock and select your expiry. Remember locking is not reversible. The amount of veCRV received will depend on how much and how long you vote for.   You can extend a lock and add $CRV to it at any point but you cannot have $CRV with different expiry dates.   Claiming your trading fees    Claiming Trading Fees     How to calculate the APY for staking CRV?    The formula below can help you calculate the daily APY:   $$ \\frac{DailyTradingVolume * 0.0002 * 365}{TotalveCRV * CRVPrice} * 100 $$   Further Reading       https://www.stakingrewards.com/earn/curve-dao-token/           Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Understanding crv", "html_url": "https://resources.curve.fi/crv-token/understanding-crv/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token             Understanding crv           Understanding crv           Table of contents         Understanding $CRV           Staking (trading fees)         Boosting         Voting         The CRV Matrix                       Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Understanding $CRV           Staking (trading fees)         Boosting         Voting         The CRV Matrix                          Understanding crv   Understanding $CRV    The main purposes of the Curve DAO token are to incentivise liquidity providers on the Curve Finance platform as well as getting as many users involved as possible in the governance of the protocol.   Currently CRV has three main uses: voting, staking and boosting. Those three things will require you to vote lock your CRV and acquire veCRV.     veCRV stands for vote-escrowed CRV, it is simply CRV locked for a period of time. The longer you lock CRV for, the more veCRV you receive.     Staking (trading fees)    CRV can now be staked (locked) to receive trading fees from the Curve protocol. A community-lead proposal introduced a 50% admin fee on all trading fees. Those fees are collected and used to buy 3CRV, the LP token for the TriPool, which are then distributed to veCRV holders.   Staking your $CRV   Calculating Yield   Boosting    One of the main incentive for CRV is the ability to boost your rewards on provided liquidity. Vote locking CRV allows you to acquire voting power to participate in the DAO and earn a boost of up to 2.5x on the liquidity you are providing on Curve.   Boosting your CRV Rewards   Voting    Once CRV holders vote-lock their veCRV, they can start voting on various DAO proposals and pool parameters.   Proposals   The CRV Matrix    The table below can help you understand the value add of veCRV.          Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "FAQ", "html_url": "https://resources.curve.fi/crvusd/faq/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics               FAQ           FAQ           Table of contents         $crvUSD FAQ           General           What is $crvUSD and how does it work?         How does the $crvUSD liquidation process differ from other debt-based stablecoins?         How is $crvUSD pegged to a price of $1?         Can other types of collateral be proposed for crvUSD? How does that process work?               Liquidation Process           What is my liquidation price?         When depositing collateral, how do I adjust and select my collateral deposit price range?         What happens when the collateral price drops into my selected range?         What happens if the collateral price recovers?         Under what circumstances can I be liquidated?         How do I maintain my loan health if collateral price drops into my range?         What happens to the collateral in the event of hard liquidation?         What is a liquidation discount and how is the 'liquidation discount' calculated during a liquidation?               Peg Keepers           What are Peg Keepers?         Under what circumstances can the Peg Keepers mint or burn $crvUSD?         What is the relationship between a Peg Keeper's debt and the total debt in crvUSD?         What does it mean if the Peg Keeper's debt is zero?         How does Peg Keeper trade and distribute profits?               Borrow Rate           What is the Borrow Rate?         How is the $crvUSD Borrow Rate calculated?               Safety and Risks           What are the risks of using $crvUSD         How can I best manage my risks when providing liquidity or borrowing in crvUSD?         Has $crvUSD been audited?         Can I see the code?                                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         $crvUSD FAQ           General           What is $crvUSD and how does it work?         How does the $crvUSD liquidation process differ from other debt-based stablecoins?         How is $crvUSD pegged to a price of $1?         Can other types of collateral be proposed for crvUSD? How does that process work?               Liquidation Process           What is my liquidation price?         When depositing collateral, how do I adjust and select my collateral deposit price range?         What happens when the collateral price drops into my selected range?         What happens if the collateral price recovers?         Under what circumstances can I be liquidated?         How do I maintain my loan health if collateral price drops into my range?         What happens to the collateral in the event of hard liquidation?         What is a liquidation discount and how is the 'liquidation discount' calculated during a liquidation?               Peg Keepers           What are Peg Keepers?         Under what circumstances can the Peg Keepers mint or burn $crvUSD?         What is the relationship between a Peg Keeper's debt and the total debt in crvUSD?         What does it mean if the Peg Keeper's debt is zero?         How does Peg Keeper trade and distribute profits?               Borrow Rate           What is the Borrow Rate?         How is the $crvUSD Borrow Rate calculated?               Safety and Risks           What are the risks of using $crvUSD         How can I best manage my risks when providing liquidity or borrowing in crvUSD?         Has $crvUSD been audited?         Can I see the code?                                FAQ   $crvUSD FAQ    General    What is $crvUSD and how does it work?    $crvUSD refers to a dollar-pegged stablecoin, which may be minted by a decentralized protocol developed by Curve Finance. Users can mint $crvUSD by posting collateral and opening a loan within this protocol.   How does the $crvUSD liquidation process differ from other debt-based stablecoins?    $crvUSD uses an innovative mechanism to reduce the risk of liquidations. Instead of instantly triggering a liquidation at a specific price, a users collateral is converted into stablecoins across a smooth range of prices.   Simulations suggest most price drops would result in the loss of just a few percentage points worth of collateral value, instead of the instant and total loss implemented by the liquidation process common to most debt-based stablecoins.   How is $crvUSD pegged to a price of $1?    The $crvUSD peg is broadly protected by the fact that the protocol is always overcollateralized. The protocol employs a number of stabilization mechanisms to fine-tune this peg. One mechanism is to automatically adjust borrow rates based on supply and demand. The protocol also relies on Peg Keepers (see below section), which are authorized to burn or mint $crvUSD based on market conditions.    Can other types of collateral be proposed for crvUSD? How does that process work?    Yes, other collateral markets can be proposed for $crvUSD through governance. Contact the community support channels for additional information on the current process to propose new collateral types. Each approved collateral has its own $crvUSD market.   Liquidation Process    What is my liquidation price?    At the start of the $crvUSD loan process, collateral is deposited and equally distributed over a range of prices rather than one single liquidation price. When the price falls within this range, your collateral begins its conversion into $crvUSD, a process that helps maintain the health of your loan and, in most circumstances, prevents a liquidation. Thus, you do not have one specific liquidation price.   When depositing collateral, how do I adjust and select my collateral deposit price range?    This price range can optionally be adjusted and customized when initially creating a loan. In the UI, look for the advanced mode toggle which will provide more information on this range as well as an Adjust button that allows you to fine-tune this range.   What happens when the collateral price drops into my selected range?    Each $crvUSD market is attached to an AMM. When the collateral price drops into your selected range, this collateral can be traded in the AMM. When this happens, traders can purchase your collateral and replace it with $crvUSD. This has the effect of leaving your loan collateralized by stablecoins, which better hold value and maintain your loan health.   NOTE: This process was initially referred to as soft liquidation. This term is being phased out to avoid confusion with the harder liquidation process in which a loan is closed and collateral is sold off.   What happens if the collateral price recovers?    While collateral price rises, the above process happens in reverse. Your position is traded via the AMM from $crvUSD back into your original collateral. Due to AMM trading fees, you may find you have lost a few percentage points worth of your original collateral value once the collateral price is again above the top end of your selected liquidation range.   Under what circumstances can I be liquidated?    Should your loan health drop below 0%, you are eligible to for liquidation. In liquidation, your collateral is sold off and your position closes. While the $crvUSD collateral conversion AMM mechanism aims to protect against liquidations, it may be unable to keep pace with severe price swings. Borrowers are recommended to maintain loan health, particularly when prices drop within the selected liquidation range.   How do I maintain my loan health if collateral price drops into my range?    Once collateral price drops into your liquidation range, you are not permitted to add new collateral to protect your loan health. With collateral price inside your liquidation range, the only way to increase your loan health is to repay $crvUSD. Even small $crvUSD repayments while collateral price is within your liquidation range can be helpful in preventing a liquidation.   What happens to the collateral in the event of hard liquidation?    In the event of a hard liquidation, all available collateral is sold off by the AMM system, the debt is covered, and the loan is closed.   What is a liquidation discount and how is the 'liquidation discount' calculated during a liquidation?    The 'liquidation discount' is calculated based on the collateral's market value and is designed to incentivize liquidators to participate in the liquidation process. This factor is used to effectively discount the collateral valuation when calculating the health for liquidation purposes.   In other protocols, this may be referred to as a liquidation threshold and is often hard-coded instead of calculated dynamically.   Peg Keepers    What are Peg Keepers?    The Peg Keepers are contracts uniquely enabled to mint and absorb debt in $crvUSD for the purposes of trading near the peg.   Under what circumstances can the Peg Keepers mint or burn $crvUSD?    Each Peg Keeper targets a specific  Peg Keeper pool .  A Peg Keeper pool is a  Curve v1 pool  allowing trading between $crvUSD and a blue chip stablecoin. The Peg Keepers are responsible for trying to balance these pools by trading at a profit. The Peg Keepers can only mint $crvUSD to trade into their associated pools when its pool balance of $crvUSD is too low, or it can repurchase and burn the $crvUSD if its pool balance is too high.   What is the relationship between a Peg Keeper's debt and the total debt in crvUSD?    A Peg Keeper's debt is the amount of $crvUSD it has deposited into a specific pool. Total debt in $crvUSD includes all outstanding $crvUSD that has been borrowed across the system.   What does it mean if the Peg Keeper's debt is zero?    If a Peg Keeper's debt is zero, it means that the Peg Keeper has no outstanding debt in the $crvUSD system.   How does Peg Keeper trade and distribute profits?    Every Peg Keeper has a public  update  function. If the Peg Keeper has accumulated profits, then a portion of these profits are distributed at the behest of the user who calls the  update  function, in order to incentivize distributed trading in the pools.    To access this on Etherscan, you can visit  LLAMMA details  on the $crvUSD UI within any market. Click the Monetary Policy link to visit Etherscan. On Etherscan, click the Contract tab and the Read Contract tab underneath. Under function 6 (peg_keepers) type the index value of the market you are interested in. The index value ranges from 0 to n-1 where n is the number of $crvUSD markets. Click on the link returned, again click Contract and Read Contract to access the function 6 (estimate_caller_profit) to know the minimum tokens you would receive. To call the function, select the Write Contract tab, connect your wallet, and call function 1 (update)   Borrow Rate    What is the Borrow Rate?    The Borrow Rate is the variable interest rate charged on active loans within each collateral market.     How is the $crvUSD Borrow Rate calculated?    The Borrow Rate for each $crvUSD collateral market is calculated based on a series of parameters, including the Peg Keeper's debt, the total debt, and the market demand for borrowing.   Safety and Risks    What are the risks of using $crvUSD    As with all cryptocurrencies, $crvUSD carries several risks, including depeg risks and risk of liquidation of your collateral. Make sure to  read the disclaimer  and exercise caution when interacting with smart contracts.   How can I best manage my risks when providing liquidity or borrowing in crvUSD?    Best risk management practices include maintaining a safe collateralization ratio, understanding the potential for liquidation, and keeping an eye on market conditions.   Has $crvUSD been audited?    Yes, you may read the full $crvUSD  MixByte audit  and other audits for Curve  may be published to Github .   Can I see the code?    The code is publicly available on the  Curve Github .        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Loan creation", "html_url": "https://resources.curve.fi/crvusd/loan-creation/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets               Loan creation           Loan creation           Table of contents         Loan Creation         Leveraging Loans                 Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Loan Creation         Leveraging Loans                    Loan creation   Loan Creation      In standard mode, creating a loan using $crvUSD only requires setting how much of the collateral asset you would like to add, and how much $crvUSD you would like to borrow in return. After you have set your collateral amount, the UI will display the maximum amount you can borrow.   The UI includes a dropdown for additional loan parameters like the current Oracle Price and  Borrow Rate .     Loan Parameters     A:  The amplification parameter A defines the density of liquidity and band size.   Base Price:  The base price is the price of the band number 0.    Oracle Price:  The oracle price is the current price of the collateral as determined by the oracle. The oracle price is used to calculate the collateral's value and the loan's health.   Borrow Rate:  The borrow rate is the annual interest rate charged on the loan. This rate is variable and can change based on market conditions. The borrow rate is expressed as a percentage. For example, a borrow rate of 7.62% means that you will be charged 7.62% interest per year on the outstanding balance of your loan.     You can toggle advanced mode in the upper right-hand side of the screen.     The advanced mode adds a display with more information about the current distribution across all the  bands  within the entire  LLAMMA . It also enhances the loan creation interface by displaying the liquidation and band range, number of bands, borrow rate, and Loan to Value ratio (LTV).        Additionally, users can manually select the number of bands for the loan by pressing the \"adjust\" button and using the slider to increase or decrease the number of bands.     Leveraging Loans    The UI provides the option to leverage your loan.   You can leverage your collateral up to 9x. This has the effect of repeat trading crvUSD to collateral and depositing to maximize your collateral position.  Here  explains how leveraging works well.   Be careful: if the collateral price dips, you must repay the entire amount to reclaim your initial position.    WARNING:  The corresponding deleverage button is also not yet available.     Toggling the advanced mode expands the display to show additional information about the loan, including the price impact and trade route.          Last update:  2023-09-20                  Back to top", "labels": ["Documentation"]}, {"title": "Loan details", "html_url": "https://resources.curve.fi/crvusd/loan-details/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation               Loan details           Loan details           Table of contents         Loan Management         Loan Details                 Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Loan Management         Loan Details                    Loan details   The Loan Details page shows you information about your loan as well as features to manage your loan.     Loan Management              Everything you may need to manage your loan is in the dark blue box on the left side of the page. These features include:       Loan:     Borrow more   Repay   Self-Liquidate         Collateral:     Add   Remove         During soft-liquidation, users are unable to add or withdraw collateral. They can choose to either partially or fully repay their crvUSD debt to improve their health ratio or decide to self-liquidate their loan if their collateral composition contains sufficient crvUSD to cover the outstanding debt. If they opt for self-liquidation, the user's debt is fully repaid and the loan will be closed. Any residual amounts are then returned to the user.   Loan Details    When you take out a loan with $crvUSD your collateral is spread over a range of liquidation prices. If the asset price drops within this range, you will enter soft liquidation mode. In soft liquidation mode you cannot add more collateral, your only available actions are to repay your loan with $crvUSD or to self-liquidate yourself.     Additional displays show information about the entire  LLAMMA , including the amount of total debt, as well as your wallet balance.   In the upper righthand side of the screen you can toggle advanced mode to get additional information on your loan.     In advanced mode the UI changes to show more information about your  collateral bands .     Advanced mode also adds a tab with more info about the entire  LLAMMA .          Last update:  2023-09-12                  Back to top", "labels": ["Documentation"]}, {"title": "Markets", "html_url": "https://resources.curve.fi/crvusd/markets/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd               Markets           Markets           Table of contents         Markets           Collateral Choices                       Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Markets           Collateral Choices                          Markets   Markets    On the Markets page you can view all the available collateral types.   The page shows the current  borrow rate , total amount of $crvUSD borrowed, and total amount of collateral backing it.     If you do not have a position, you can click on any market to  create a loan .   If you already have a position it will show a dollar sign overlay on the left, and clicking on the market will take you to a page to  manage your loan .   Collateral Choices    While testing $crvUSD, the team created a market for $sfrxETH with a small market cap ($10MM) because it had a compatible oracle. Additional forms of collateral are expected to be approved by the DAO.        Last update:  2023-09-12                  Back to top", "labels": ["Documentation"]}, {"title": "Understanding crvusd", "html_url": "https://resources.curve.fi/crvusd/understanding-crvusd/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD             Understanding crvusd           Understanding crvusd           Table of contents         Understanding $crvUSD           Risks                       Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Understanding $crvUSD           Risks                          Understanding crvusd   Understanding $crvUSD    Curve Stablecoin infrastructure enables users to mint crvUSD using a selection of crypto-tokenized collaterals. Positions are managed passively: if the collateral's price decreases, the system automatically sells off collateral in a soft liquidation mode. If the collateral's price increases, the system recovers the collateral. This process could lead to some losses due to liquidation and de-liquidation.   Manage crvUSD positions at  https://crvusd.curve.fi/   User guide of crvUSD and introduction of rate & LLAMMA, by 0xreviews   Risks    Please consider the following risk disclaimers when using the Curve Stablecoin infrastructure:     If your collateral enters soft-liquidation mode, you can't withdraw it or add more collateral to your position. Should the price of the collateral drop sharply over a short time interval, your position will get hard-liquidated, with no option of de-liquidation. Please choose your leverage wisely, as you would with any collateralized debt position.   If your collateral enters soft-liquidation mode, you can't withdraw it or add more collateral to your position.   Should the price of the collateral change drop sharply over a short time interval, it can result in large losses that may reduce your loan's health.   If you are in soft-liquidation mode and the price of the collateral goes up sharply, this can result in de-liquidation losses on the way up. If your loan's health is low, value of collateral going up could potentially reduce your underwater loan's health.   If the health of your loan drops to zero or below, your position will get hard-liquidated with no option of de-liquidation. Please choose your leverage wisely, as you would with any collateralized debt position.       The crvUSD stablecoin and its infrastructure are currently in beta testing. As a result, investing in crvUSD carries high risk and could lead to partial or complete loss of your investment due to its experimental nature. You are responsible for understanding the associated risks of buying, selling, and using crvUSD and its infrastructure.   The value of crvUSD can fluctuate due to stablecoin market volatility or rapid changes in the liquidity of the stablecoin.   crvUSD is exclusively issued by smart contracts, without an intermediary. However, the parameters that ensure the proper operation of the crvUSD infrastructure are subject to updates approved by Curve DAO. Users must stay informed about any parameter changes in the stablecoin infrastructure.     Understanding Curve v2        Last update:  2023-09-12                  Back to top", "labels": ["Documentation"]}, {"title": "Understanding tokenomics", "html_url": "https://resources.curve.fi/crvusd/understanding-tokenomics/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details               Understanding tokenomics           Understanding tokenomics           Table of contents         $crvUSD Concepts           Bands         Borrow Rate         Liquidation         LLAMMA         Loan Health                       FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         $crvUSD Concepts           Bands         Borrow Rate         Liquidation         LLAMMA         Loan Health                          Understanding tokenomics   $crvUSD Concepts    Bands      When loans are created, collateral is spread among several bands. Each band has a range of prices for the asset. If the  price oracle  is inside this range of prices, that particular band of collateral is likely to be liquidated.   In the example above, the collateral has been spread into 10 different bands of collateral. The darker grey represents collateral which has been converted into $crvUSD, lighter grey is the original collateral type. Mousing over any bar will give you details about your position within the band, as well as the asset prices corresponding to this band. If you are in soft liquidation, the band may have a blend of $crvUSD and the collateral.     Borrow Rate    The borrow rate is variable basd on conditions in the pool. For instance, when collateral price is down and some positions are in soft liquidation, the rate can fall. A decreasing rate creates incentive to borrow and dump, while an increasing rate creates incentives to buy $crvUSD and repay.   The formula for calculating Borrow Rate is:   rate = rate0 * exp(-(p - 1) / sigma) * exp(-peg_keeper_debt / (total_debt * peg_keeper_target_fraction))   Liquidation    In soft liquidation, the collateral within a band is at risk of being converted into crvUSD. If the price goes back, it will be rehypothecated into collateral, although it will likely be lower than the initial amount. While in soft liquidation mode, users cannot modify their collateral. The only options available are to either partially or fully repay the debt or opt to self-liquidate the position.   If your health continues to weaken, you may find yourself subject to \"hard liquidation,\" which functions more like a usual liquidation, where your position is erased.   LLAMMA    LLAMA (Lending Liquidation AMM Algorithm) is a fully functional AMM with all the functions you would expect. For more detail  please check the source code .     Loan Health    Based on your collateral and borrow amount, the UI will display the Health score. Low health scores are more at risk of entering liquidation mode in the event the asset price drops.          Last update:  2023-09-12                  Back to top", "labels": ["Documentation"]}, {"title": "Creating a cryptoswap pool", "html_url": "https://resources.curve.fi/factory-pools/creating-a-cryptoswap-pool/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool               Creating a cryptoswap pool           Creating a cryptoswap pool           Table of contents         Creating a Cryptoswap Pool           Creating a Pool         Tokens in Pool         Pool Presets         Parameters                       Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Creating a Cryptoswap Pool           Creating a Pool         Tokens in Pool         Pool Presets         Parameters                          Creating a cryptoswap pool   Creating a Cryptoswap Pool    The v2 Curve Factory supports pools of assets with volatile prices, with no expectation of price stability.   Understanding Curve v2   Creating a Pool    The factory can be used to create a pool between any two or three ERC20 tokens. Based on trading activity in the pool, the v2 pools update an internal price oracle that the pool uses to rebalance itself.   If the pool is using  wrapped Ethereum  as one of the two assets, the pool will also support depositing either raw ETH or wrapped Ethereum.   Tokens in Pool    The token selection tab can be used to select up to three tokens.             The order of the tokens can matter for the performance of the AMM. Make sure to select the token with the higher price is first. If the tokens are supported by CoinGecko, you can see the \"Initial Price\" under the  Pool Setup  panel, choose the token order to maximize this value.   On Ethereum at the top of the token selection popup you can see any Curve basepools suggested up top. These allow you to create a  metapool , where the other asset can trade with any of the underlying basepool assets.     You can search by name for any token already added to Curve, or paste a token address   Pool Presets                The \"Pool Presets\" tab provides scenarios that prepopulate appropriate parameters for users who are unfamiliar with advanced aspects of Curve pools. Some examples:       Crypto:  Used volatile pairings for tokens which are likely to deviate heavily in price       Forex:  Pairings that have low volatility       Liquid Staking Derivatives:  Similar to  $cbETH  and  $rETH  which handle Ethereum LSDs       Tricrypto:  Suitable for pools containing a USD stablecoin, BTC stablecoin and ETH.       Three Coin Volatile:  Suitable for pools containing a volatile token which is paired against ETH and USD stablecoins.       Parameters    On the parameters tab you can review and adjust the defaults populated by your selection on the \"pool presets\" tab. Crypto v2 pools contain a lot of parameters. If you are uncertain of which parameters to use, you may want to ask for help in any Curve channel before deploying. Some parameters can be tuned after the fact.             The basic parameters include the fees charged to users who interact with the pool. This is divided dynamically into a \"Mid fee\" and \"Out fee\" parameter, which represent the minimum and maximum fee during periods of low and high volatility.     Mid Fee:  [.005% to 1%] Percentage. Fee when the pool is maximally balanced. This is the minimum fee. The fee is calculated as  mid_fee * f + out_fee * (10^18 - f)   Out Fee:  [Mid Fee to 1%] Fee when the pool is imbalanced. Must be larger than the Mid Fee and represents the maximum fee.     The initial prices fetch current prices from Coingecko to set the initial liquidity concentration. If your tokens do not exist on Coingecko you will need to populate these values manually, otherwise they will be filled automatically.   The Advanced toggle allows you to adjust several of the other parameters under the hood.     Amplification Parameter (A):  [4,000 to 4,000,000,000] Larger values of A make the curve better resemble a straight line in the center (when pool is near balance). Highly volatile assets should use a lower value, while assets that are closer together may be best with a higher value.   Gamma:  [.00000001 to .02] The gamma parameter can further adjust the shape of the curve. Default values recommend .000145 for volatile assets and .0001 for less volatile assets.   Allowed Extra Profit:  [0 to .01] As the pool takes profit, the allowed extra profit parameter allows for greater values. Recommended 0.000002 for volatile assets and 0.00000001 for less volatile assets.   Fee Gamma:  [0 to 1] Adjusts how fast the fee increases from Mid Fee to Out Fee. Lower values cause fees to increase faster with imbalance. Recommended value of .0023 for volatile assets and .005 for less volatile assets.   Adjustment Step:  [0 to 1] As the pool rebalances, it will must do so in units larger than the adjustment step size. Volatile assets are suggested to use larger values (0.000146), while less volatile assets do not move as frequently and may use smaller step sizes (default 0.0000055)   Moving Average Time:  [0 to 604,800] In seconds -- the price oracle uses an exponential moving average to dampen the effect of changes. This parameter adjusts the half life used.     A more thorough reader on the parameters  can be found here . You can  use this interactive tool  to see how some of the parameters interact.   After deployment, make sure to seed initial liquidity and  create a gauge  just like  regular factory pools .   Creating a Pool Gauge        Last update:  2023-08-25                  Back to top", "labels": ["Documentation"]}, {"title": "Creating a stableswap pool", "html_url": "https://resources.curve.fi/factory-pools/creating-a-stableswap-pool/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory               Creating a stableswap pool           Creating a stableswap pool           Table of contents         Creating a Stableswap Pool           Token Selection         Pool Presets         Parameters         Pool Info                       Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Creating a Stableswap Pool           Token Selection         Pool Presets         Parameters         Pool Info                          Creating a stableswap pool   Creating a Stableswap Pool    The Stableswap pool creation is appropriate for assets expected to hold a price peg very close to each other, like a pair of dollarcoins. The creation wizard will guide you through the process of creating a pool, but if you have questions throughout you are encouraged to speak with a member of the Curve team in the  Telegram  or  Discord .   Token Selection    The token selection tab can be used to select between two to four tokens.     You can select a token by searching for the symbol of any token that is already being used on Curve, or by pasting the pools address.   On Ethereum you might observe a handful of popular assets (ie Tether, USDC, Frax) are not available in the token selection dropdown. Some of these assets have been added to \"base pools,\" which can be used in the creation of other \"metapools.\"   Base & MetaPools     Base pools are suggested at the top of the token selection modal. As of April 2023, Curve supported two stablecoin basepools (3CRV/FraxBP) and a BTC basepool (sbTC2Crv).   If you want to include a token that is part of a base pool, you must use it as part of a corresponding base pool. Base pools can only be paired with one other token.   If you are using raw ether as a token, it must be added as \"Token A.\" WETH may be added as either Token A or Token B.   If your pool contains rebasing tokens (a token that adjusts its total supply to control its price), make sure to select the appropriate box:     The UI will not check to see if a pool containing your token pairs already exists. Some protocols have seen opportunities to create two pools containing the same assets but using different parameters (c/f  stETH concentrated ). In most cases you should take care to make sure your pool does not already exist.   Pool Presets      The \"Pool Presets\" tab contains a few scenarios that prepopulate appropriate parameters for users unfamiliar with advanced aspects of Curve pools. The presets include an explanation of their use case.   The Advanced options toggle includes a variety of options which may not apply to your case.     Parameters      The parameters tab allows you to adjust pool parameters. The pool's fee is applied to all transactions within the pool, half of which accrues to pool LPs, the other half is distributed to veCRV stakers. The fee for StableSwap pools may be set between .04% and 1%.   The Advanced tab allows you to adjust the pool's \"A Parameter.\"     The A Parameter is set by default based on your selection on the prior tab. A higher value for A concentrates liquidity better. If the assets are likely to fluctuate heavily you may want to lower the value below the default of 100.   After the pool launches, the DAO has the capability of adjusting the A parameter.   Understanding Curve Pools   Pool Info      Finally, you may adjust factors used for displaying the pool on the Curve site. These cannot be adjusted after launching so be careful when selecting these parameters.   On the Curve UI the pools are grouped by the \"Asset Type Tag.\" This only affects its display on the Curve website, it has no effect on the pool's performance.     USD:  For pools only containing dollarcoins   ETH:  For pools only containing ETH   BTC:  For pools only containing BTC   Other:  All other assets     Your pool is ready to launch! It will now appear on the Curve page, but it's not yet eligible to earn $CRV rewards. For next steps you will typically want to seed initial liquidity and  create a pool gauge .   Creating a Pool Gauge        Last update:  2023-09-07                  Back to top", "labels": ["Documentation"]}, {"title": "Pool factory", "html_url": "https://resources.curve.fi/factory-pools/pool-factory/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools             Pool factory           Pool factory           Table of contents         Understanding Factory Pools                 Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Understanding Factory Pools                    Pool factory   Understanding Factory Pools    The Curve pool creation factory allows any user to permissionlessly deploy a Curve pool. These pools can contain a variety of assets, including pegged tokens, unpegged tokens, and metapools built off of other  base pools .   Base & MetaPools   Keep in mind a few points about all pools:     Destroying Curve pools once deployed is not possible   Curve is not responsible for any of the assets going in there so you must do your own research when trading in the pool factory. The Curve team and DAO also have no control over the tokens added in the factory which means you must verify the token addresses you trade on there.   The only admin change that can be made by the Curve DAO is ramping the A (amplification) parameter   Tokens with more than 18 decimals are not supported   After deploying a pool, you must seed initial liquidity if you want users to interact with it.   Pools will only display on the homepage by default if their TVL is not below the threshold of what is considered \"small.\"          https://curve.fi/#/ethereum/create-pool      To get started, visit the \" Pool Creation \" tab at the top of the Curve homepage, and select whether you would like to create a \"Stableswap Pool\" (a pool with pegged assets) or a \"Cryptoswap Pool\" (containing assets whose prices may be volatile).   Creating a Stableswap Pool   Creating a Cryptoswap Pool   Note some sidechains may not yet support a stableswap or cryptoswap pool factory.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Understanding oracles", "html_url": "https://resources.curve.fi/factory-pools/understanding-oracles/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool               Understanding oracles           Understanding oracles           Table of contents         Understanding Oracles           Purpose         Exponential Moving Average         Updates           Price Oracle         Profits and Liquidity Balances               Manipulation         v1 Pools         LLAMMA                               Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Understanding Oracles           Purpose         Exponential Moving Average         Updates           Price Oracle         Profits and Liquidity Balances               Manipulation         v1 Pools         LLAMMA                          Understanding oracles   Understanding Oracles    This article primarily covers the role of internal price oracles within Curve Finance v2 pools, with a brief note at the end of  LLAMMA price oracles .   Please note that Curve v1 and v2 pools do not rely on external price oracles.  Misuse of external price oracles is a contributing factor to several major DeFi hacks.  If you are looking to use Curves price oracle functions, or any price oracle, to provide on-chain pricing data in a decentralized application you are building, we recommend extreme caution.   Purpose     Curve v2 pools , which consist of assets with volatile prices, require a means of tracking prices. Instead of relying on external oracles, the pool instead calculates the price of these assets internally based on the trading activity within the pool.   This is tracked by two similar but distinct parameters:     Price Oracle:  The pools expectation of the assets price   Price Scale:  The price based on the pools actual concentration of liquidity     Pools keep track of recent trades within the pool as a variable called  last_prices . The  price_oracle  is calculated as an  exponential moving average  of recent trade prices. The  price_oracle  represents what the pool believes is the fair price of the asset .   In contrast,  price_scale  is a snapshot of how the liquidity in the pool is  actually  distributed. For this reason,  price_scale  lags  price_oracle . As users make trades, the pool calculates how to  profitably readjust liquidity , and the  price_scale  moves in the direction of the  price_oracle .     Price Oracle and Price Scale shown in the Curve UI   Exponential Moving Average     As discussed above , the  price_oracle  variable is calculated as an exponential moving average of  last_prices .   For comparison, traders commonly rely on a simple moving average as a technical analysis indicator, which calculates the average of a certain number points (ie, a 200-day moving average computes the average of the trailing 200 days of data).   The exponential moving average\" is similar, except it applies a weighting to emphasize newer data over older data. This weighting falls off exponentially as it looks further back in time, so it can react quicker to recent trends.     Updates    An internal function  tweak_price  is called every time prices might need to be updated by an operation which might adjust balances within a pool (hereafter referred to as a  liquidity operation ):     add_liquidity   remove_liquidity_one_coin   exchange   exchange_underlying     The  tweak_price  function is a gas expensive function which can execute several state changing operations to state variables_._   Price Oracle    The  price_oracle  is updated only once per block. If the current timestamp is greater than the timestamp of the last update, then  price_oracle  is updated using the previous  price_oracle value  and data from  last_prices .   The updated  price_oracle  is then used to calculate the vector distance from the  price_scale , which is used to determine the amount of adjustment required for the  price_scale .   Profits and Liquidity Balances    Curve v2 pools operate on profits. That is, liquidity is rebalanced when the pool has earned sufficient profits to do so. Every time a  liquidity operation  occurs, the pool chooses whether it should spend profits on rebalancing. The pools actions may be considered as an attempt to rebalance liquidity close to market prices.   Pools perform all such operations strictly with profits, never with user funds. Profits are occasionally claimed by administrators, otherwise funds remain in the pool. In other words, profits can be calculated from the following function:   profits == erc20.balanceOf(i) - pool.balances(i)   Internally, every time the  tweak_price  function is called during a  liquidity operation , the pool tracks profits. It then uses the updated profit values to consider if it should rebalance liquidity.   Specifically, pools carry a public parameter called  allowed_extra_profit  which works like a buffer. If the pools virtual price has grown by more than a function of profits and the  allowed_extra_profit  buffer value, then the pool is considered profitable enough to rebalance liquidity.   From here, the pool further checks that the  price_scale  is sufficiently different from  price_oracle , to avoid rebalancing liquidity when prices are pegged. Finally, the pool computes the updates to the  price_scale  and how this affects other pool parameters. If profits still allow, then the liquidity is rebalanced and prices are adjusted.   Manipulation    We do not recommend using Curve pools by themselves as canonical price oracles. It is possible, particularly with low liquidity pools, for outside users to manipulate the price.   Curve pools nonetheless include protections against some forms of manipulation. The logic of the Curve  price_oracle  variable only updates once per block, which makes it more resistant to manipulation from malicious trading activity within a single block.   Due to the fact that changes to  price_oracle  are dampened by an exponential  moving average , attempts to manipulate the price may succeed but would require a prolonged attack over several blocks.     Actual $CVX price versus CVX-ETH Pool Price Oracle and Price Scale during rapid volatility   These safeguards all help to prevent various forms of manipulation. However, for pools with low liquidity, it is not difficult for whales to manipulate the price over the course of several transactions. When relying on oracles on-chain, it is safest to compare results among several oracles and revert if any is behaving unusually.   v1 Pools    Newer v1 Pools also contain a price oracle function, which also displays a moving average of recent prices. If the moving average price was written to the contract in the same block it will return this value, otherwise it will calculate on the fly any changes to the moving average since it was last written.   Curve v1 pools do not have a concept of price scale, so no endpoint exists for retreiving this value. Older v1 pools will also not have a price oracle, so use caution if you are attempting to retrieve this value on-chain.   LLAMMA    The LLAMMA use of oracles is quite different than Curve v2 pools in that it can utilize external price oracles. In LLAMMA, the  price_oracle  function refers to the collateral price (which can be thought of as the current market price) as determined by an external contract.   For example, LLAMMA uses  price_oracle  to convert $ETH to $crvUSD at a specific collateral price. When the external price is higher than the upper price (internally:  P_UP ), all assets in the band range are converted to $ETH. When the price is lower than the lower price (internally:  P_DOWN ), all assets are converted to $crvUSD. When the oracle price is in the middle, the current band is partially converted, with the exact proportion determined by price changes.     When the external price changes, an arbitrage opportunity exists. External arbitrageurs can deposit $ETH or $crvUSD to balance the pool, until the pool price reaches parity with the external price. LLAMMA applies an  exponential moving average  to the  price_oracle  to prevent users from absorbing losses due to drastic fluctuations.   More information on price oracles and other LLAMMA dynamics are  available at this article .        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Glossary", "html_url": "https://resources.curve.fi/faq/glossary/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix             Glossary           Glossary           Table of contents         Glossary           3CRV         Admin fee         Boosting (also boosties)         CRV         DeFi (Decentralized Finance)         Metamask         Metapool         Llamas         LP (Liquidity provider)         LP tokens (Liquidity provider token)         Yearn         yCRV         yUSD (also yyCRV)                       Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Glossary           3CRV         Admin fee         Boosting (also boosties)         CRV         DeFi (Decentralized Finance)         Metamask         Metapool         Llamas         LP (Liquidity provider)         LP tokens (Liquidity provider token)         Yearn         yCRV         yUSD (also yyCRV)                          Glossary   Glossary    3CRV    3CRV is the LP token for the 3Pool (sometimes referred to as TriPool). Trading fees are distributed in 3CRV.   Admin fee    Admin fee is the share of trading fees that are received by governance participants who have locked their CRV (see veCRV).   Boosting (also boosties)    The act of locking your CRV to earn more CRV on your provided liquidity.   Boosting your CRV Rewards   CRV    Governance and utility token for the Curve DAO.   DeFi (Decentralized Finance)    Decentralized finance (commonly referred to as DeFi) is an experimental form of finance that does not rely on financial intermediaries such as brokerages, exchanges, or banks, and instead utilizes blockchains, most commonly the Ethereum blockchain.   Metamask    Metamask is an Ethereum wallet that allows you to interact with Curve and other dapps. You can also use it with Ledger and Trezor hardware wallets. It's the most popular Ethereum web wallet and is available as an add-on for most browsers.   Metapool    Metapools are a type of pool on Curve composed of one asset as well as as LP tokens from another pool.   Base & MetaPools   Llamas    Llamas are wonderful and magical creatures. Each Curve team member must own at least one llama as part of their contract with Curve Finance.   LP (Liquidity provider)    Users providing liquidity (funds/assets) on the Curve or other DeFi protocols.   LP tokens (Liquidity provider token)    When you deposit into a Curve pool, you receive a counter party token which represents your share of the pool.   veCRV   Stands for vote-escrowed CRV. They are CRV locked for the purpose of voting and earning fees.   Understanding $CRV   Yearn    Yearn Protocol is a set of Ethereum Smart Contracts focused on creating a simple way to generate high risk-adjusted returns for depositors of various assets via best-in-class lending protocols, liquidity pools, and community-made yield farming strategies on Ethereum. It was founded by Andre Cronje who has been a long term collaborator of Curve Finance.   yCRV    yCRV is not wrapped CRV, it's a wrapped representation of ownership of yUSDC+yUSDT+yDAI+yTUSD deposits in the Curve Y pool (i.e. your share of the pool). Each pool on Curve has an LP token with a different name.   yUSD (also yyCRV)    Yearn token wrapper that represents shares of the Y pool inside the Yearn Y Pool vault. It is a wrapped version of yCRV.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Proposals", "html_url": "https://resources.curve.fi/governance/proposals/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals             Proposals           Proposals           Table of contents         Proposals           Creating a proposal         Type of votes                       Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Proposals           Creating a proposal         Type of votes                          Proposals   Proposals    Once CRV holders vote-lock their veCRV, they can start voting on various proposals.   Creating a proposal    Anybody can create proposals but users need to follow the structure of a proposal which can be found by creating a new topic on the governance forum:  https://gov.curve.fi/    Users who create proposals also need to create a corresponding CIP proposal at  http://signal.curve.fi/    Using the signalling tool is completely free (no transaction fees) and you only need 1veCRV to create a proposal there.   Assuming you have at least 2,500 veCRV, you can also create an official DAO vote as long as it also comes with its topic presenting it on the governance forum.   Voting   Type of votes    Currently there are two type of votes:     Signalling votes which are non-official votes only used to gauge interest from community ( https://signal.curve.fi/#/ )   Official DAO votes are the only way to enact changes on the Curve protocol ( https://dao.curve.fi/ )          Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Snapshot", "html_url": "https://resources.curve.fi/governance/snapshot/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting               Snapshot           Snapshot           Table of contents         Snapshot           Voting                         Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Snapshot           Voting                          Snapshot   Snapshot    Snapshot is a signalling tool that allows governance participants to signal for free.   As gas fees are here to stay on the Ethereum blockchain, Curve governance is now using a tool called Snapshot to allow governance users to signal their preferences on Curve proposals.   Whilst this tool doesn't replace governance and will only be used to signal, it's a great way for holders of all sizes to make their voices heard as  voting is completely free.   Voting    Head over to the signalling tool:  https://signal.curve.fi/#/curve  and connect your Metamask wallet. It should be the one where you hold your veCRV (vote locked CRV).   Simply review your proposal, select your preferred option and click Vote:     You will be prompted by Metamask to sign a transaction which is completely free and your voting vote will be counted according to your voting weight at the moment of the proposal creation.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Understanding governance", "html_url": "https://resources.curve.fi/governance/understanding-governance/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance             Understanding governance           Understanding governance           Table of contents         Understanding Governance           Voting on the Curve DAO         Voting Power         The DAO Dashboard         Submitting proposals         Emergency DAO                       Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Understanding Governance           Voting on the Curve DAO         Voting Power         The DAO Dashboard         Submitting proposals         Emergency DAO                          Understanding governance   Understanding Governance    Voting on the Curve DAO    To vote on the Curve DAO, users need to lock vote lock their CRV. By doing so, participants can earn a boost on their provided liquidity and vote on all DAO proposals. Users who reach a voting power of 2500 veCRV can also create new proposals. There is no minimum voting power required to vote.   Voting Power    veCRV stands for vote escrowed CRV, it's a locker where users can lock their CRV for different lengths of time to gain voting power. Users can lock their CRV for a minimum of week and a maximum of four years. As users with long voting escrow have more stake, they receive more voting power.   The DAO Dashboard    You can visit the Curve DAO dashboard at this address:  https://dao.curve.fi/dao    On this page, you can find all current and closed votes. All proposals should have a topic on the Curve governance forum at this address:  https://gov.curve.fi/    Submitting proposals    If you wish to create a new official proposal, you should draft a proposal and post it on the governance forum. You must also research that it's possible and gauge interest of the community via the Curve Discord, Telegram or Governance forum.   If you're not sure about the technical details of submitting your proposal to the Ethereum blockchain, you can ask a member of the team to help.   Emergency DAO    The emergency DAO multisig may kill non-factory pools up to 2 months old. It may also kill reward gauges at any time, setting its rate of CRV emissions to 0. Pools that have been killed will only allow users to  remove_liquidity .   See the members of the emergency DAO in the technical docs:  https://docs.curve.fi/curve_dao/ownership-proxy/Agents/#agents   The Curve DAO may override the emergency DAO decision of killing a pool, making it alive again.        Last update:  2023-09-12                  Back to top", "labels": ["Documentation"]}, {"title": "Vote locking boost", "html_url": "https://resources.curve.fi/governance/vote-locking-boost/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance               Vote locking boost           Vote locking boost           Table of contents         Vote Locking           What is vote locking?         What is the vote locking boost?         When does the boost start?         What are veCRV?         How is your boost calculated?         What if I provide liquidity in multiple pools?         What happens if more people vote lock?         How often does my boost records voting power changes?         How can I apply my boost?         How to know my boost is active?                       Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Vote Locking           What is vote locking?         What is the vote locking boost?         When does the boost start?         What are veCRV?         How is your boost calculated?         What if I provide liquidity in multiple pools?         What happens if more people vote lock?         How often does my boost records voting power changes?         How can I apply my boost?         How to know my boost is active?                          Vote locking boost   Vote Locking    Answering all your burning questions about the vote locking boost   What is vote locking?    CRV holders can vote lock their CRV into the Curve DAO to receive veCRV. The longer they lock for, the more veCRV they receive. Vote locking allows you to vote in governance, boost your CRV rewards and receive trading fees.   What is the vote locking boost?    When vote locking CRV, you will also earn a boost on your provided liquidity of up to 2.5x. The goal is to incentivise users to participate in governance by rewarding them with a bigger share of the daily CRV inflation.   When does the boost start?    The boost will start on the 26 th  of August 2020 around 11pm UTC.   What are veCRV?    veCRV stands for voting escrow CRV. They are your CRV locked for voting. The longer you lock your CRV for, the more voting power you have (and the bigger boost you can reach). You can vote lock 1,000 CRV for a year to have a 250 veCRV weight. Each CRV locked for four years is equal to 1 veCRV.   The number of veCRV you will receive depends on how long you lock your CRV for. The minimum locking time is one week and the maximum locking time is four years.   Your veCRV weight gradually decreases as your escrowed tokens approach their lock expiry. A graph illustrating the decrease can be found at this address:  https://dao.curve.fi/locker    How is your boost calculated?    To reach your maximum boost of 2.5x, there are several parameters to take into consideration.   You can find the current DAO voting power at this address:  https://dao.curve.fi/locker    You can find a calculator at this address:   https://dao.curve.fi/minter/calc    What if I provide liquidity in multiple pools?    Your voting power applies to all gauges but may produce different boosts based on how much liquidity you are providing and how much total liquidity the pool has.   What happens if more people vote lock?    If other liquidity providers vote lock more CRV, your boost will stay what it was when you applied it. If you abuse this, another user can kick and force a boost update to take you down to your real boost.   How often does my boost records voting power changes?    Your voting weight decreases over time but your boost will take notice of your decreasing voting power at certain checkpoints like withdrawing, depositing into a gauge or minting CRV.   For example if you start at 1000 veCRV and your voting power decreases to 800 veCRV, your boost will still use your original voting power of 1000 veCRV until a user checkpoint.   How can I apply my boost?    After creating or adding to your lock, you need to click the apply boost button to update your boost on each of the gauge you're providing liquidity in. Your boost can also be updated by depositing or withdrawing from a gauge.   Click below for a guide on how locking and boosting your CRV rewards   Boosting your CRV Rewards   How to know my boost is active?    If your boost is showing then it is active.   If you have locked but your boost isn't showing then you need to apply it.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Voting", "html_url": "https://resources.curve.fi/governance/voting/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost               Voting           Voting           Table of contents         Voting           How to participate in governance?         What are veCRV?         Can I start voting right away?         How to vote?                       Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Voting           How to participate in governance?         What are veCRV?         Can I start voting right away?         How to vote?                          Voting   Voting    How to participate in governance?    To participate in governance, Curve Finance users need to lock their CRV into a voting escrow.   You can do so at this address:  https://dao.curve.fi/locker    What are veCRV?    veCRV stands for voting escrow CRV. They are your CRV locked for voting. The longer you lock your CRV for, the more voting power you have (and the bigger boost you can reach). You can vote lock 1,000 CRV for a year to have a 250 veCRV weight.   Your veCRV weight gradually decreases as your escrowed tokens approach their lock expiry. A graph illustrating the decrease can be found at this address:  https://dao.curve.fi/locker    Get more voting power by locking your CRV for a longer period of time.   Can I start voting right away?    You can only vote using your voting weight at the block where a proposal was created.   How to vote?    Simply visit the proposal of your choice, click your vote option and confirm your transaction. You can find DAO proposals at this address:  https://dao.curve.fi/dao      Where can I find out about governance?   You can visit the Curve Finance governance forum at this address  http://gov.curve.fi/         Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Community fund", "html_url": "https://resources.curve.fi/governance/proposals/community-fund/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals               Community fund           Community fund           Table of contents         Community Fund                 Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Community Fund                    Community fund   Community Fund    CRV initial distribution allowed for a community fund of around $151M to be used in cases of emergencies or awarded to community-lead initiatives.   The Curve DAO can decide to award part of this fund through a proposal.   Creating a DAO proposal   If you have a project you feel is deserving a grant, please create a proposal or come discuss it with a team member on Discord or Telegram.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Creating a dao proposal", "html_url": "https://resources.curve.fi/governance/proposals/creating-a-dao-proposal/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund               Creating a dao proposal           Creating a dao proposal           Table of contents         Creating a DAO proposal           Creating your vote         Creating your proposal                                     Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Creating a DAO proposal           Creating your vote         Creating your proposal                          Creating a dao proposal   Creating a DAO proposal    Official DAO proposals are the only way to create enforceable change on the Curve protocol. There are currently two type of votes: parameter and text.   Parameter votes are automatically committed to the DAO three days after they are enacted at the end of the vote. Text proposals are different as they will often necessitate development. For those, it is recommended to discuss with the Curve team to understand feasibility and create a signalling proposal.   To create a new DAO proposal,  you need at least 2,500 veCRV  (2,500 CRV locked for four years or 10,000 CRV locked for one year).   Creating your vote    Visit the Curve DAO:  https://dao.curve.fi/dao , select your type of vote and submit it.     Creating your proposal    Every DAO proposal must be accompanied with a proposal on the Curve governance forum. Visit the proposal section:  https://gov.curve.fi/c/proposals/8  and click  \"New Topic\" .   You will then be presented with a template to help you present your proposed choices to the community.     After that's done, be sure to engage with members of the community who have questions about your proposal.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Base and metapools", "html_url": "https://resources.curve.fi/lp/base-and-metapools/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools               Base and metapools           Base and metapools           Table of contents         Base & MetaPools           Plain v1 Pools         Lending Pools         MetaPools                       Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Base & MetaPools           Plain v1 Pools         Lending Pools         MetaPools                          Base and metapools   Base & MetaPools    Plain v1 Pools    A plain pool is the simplest and earliest implementation of Curve, where all assets in the pool are ordinary ERC-20 tokens pegged to the same price.   One of the  largest is TriPool , holding only the three biggest stable coins (USDC/USDT/DAI). It's a non-lending gas optimised pool similar to the sUSD one.   Depositing into the Tri-Pool   In plain pools, your risks are as follow:     Smart contract issues with Curve   Systemic issues with the stable coins in those pools   Systemic issues with Synthetix (for sUSD)     As you can see, risks are different which might make this pool a better choice for you depending on what your concerns in the cryptosphere are.   Lending Pools    A small number of v1 pools are lending pools, which means you earn interest from lending as well as trading fees.   The  Compound pool  is the first and oldest. The  you see above stands for cTokens which are Compound native tokens. This means your stable coins in the Compound pool would only be lent on the Compound protocol.   Another pool is  yPool  which are tokens for Yearn Finance, a yield aggregator. You might think that Compound doesnt always have the best lending rates and you would be right and thus the yToken balances automatically rebalance your stable coin to the protocol(s) with the better rates (Compound, Aave and dYdX). Its free and non-custodial (as is Curve) but it is also why the yPools are considered more risky as you use a series of protocols that could themselves have critical vulnerabilities.   Pools like  AAVE  and  sAAVE  also lend on AAVE v2. Lending pools are generally more expensive to interact with.   In those pools, your risks are as follow:     Smart contract issues with lending protocols   Smart contract issues with Curve   Smart contract issues with iEarn   Systemic issues with the stable coins in those pools     Whilst its important to not underplay risks associated with providing liquidity on Curve or DeFi in general, its worth noting that all the protocols mentioned above have existed for several months (or more for Compound or iEarn) meaning they have been extensively time tested and exploit attempts have been numerous.   MetaPools    Metapools allow for one token to seemingly trade with another underlying base pool. This means we could create, for example, the  Gemini USD metapool : [GUSD, [3Pool]].   In this example users could seamlessly trade GUSD between the three coins in the 3Pool (DAI/USDC/USDT). This is helpful in multiple ways:     Prevents diluting existing pools   Allows Curve to list less liquid assets   More volume and more trading fees for the DAO     The Metapool in question would take GUSD and 3Pool LP tokens. This means that liquidity providers of the 3Pool  who do not provide liquidity in the GUSD Metapool are shielded from systemic risks from the Metapool.   Metapools  in the UI will have a  deposit wrapped  option to deposit the 3pool token.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Calculating yield", "html_url": "https://resources.curve.fi/lp/calculating-yield/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs               Calculating yield           Calculating yield           Table of contents         Calculating Yield           Types of Yield           Base vAPY                 Incentives tAPR                               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Calculating Yield           Types of Yield           Base vAPY                 Incentives tAPR                                Calculating yield   Calculating Yield    Explanation of how the Curve UI displays yield calculations   Like all documentation within this guide, this article is intended to be detailed but non-technical, outside of a few light mathematical formulas. While we highlight specific smart contract function names that the Curve UI may reference for convenience, no knowledge of coding is otherwise necessary to understand this article.   Developers seeking a more in-depth explanation of these concepts should consult the technical documentation at   https://curve.readthedocs.io/    Types of Yield      Curve UI displaying different types of displayed Curve yield (tAPY and tAPR).   In the above screenshot you can see a Curve pool has the potential to offer many different types of yield. The documentation provides an overview of the different types of yield here:   Understanding $CRV   Its important to remember that these numbers are a projections of historical pool performance. The user would get this rate if the pool performance stays exactly the same for one year.   These yield types are:     Base vAPY:  Shown on the first line, this number represents the fees that accrue to holders of the LP token based on trading volume.  More Info    $CRV Rewards tAPR:  Shown on the second line, the rewards tAPR represents the rate of $CRV token emissions one would have earned if the pool has a rewards gauge and the user stakes into this rewards gauge. The number is listed as a range of possible rewards, based on the users locked veCRV the size of this boost can vary.  More Info    Incentives Rewards tAPR:  Some pools also choose to stream rewards in the form of a different token  this is represented on the third line if applicable.     vAPY  stands for  variable annual percentage yield , this value calculates an annualized estimate of the trading fee yield based on the past days trading activity, inclusive of any effect of compounding.   The rewards  tAPR  stands for  token annual percentage rate   token rewards must be claimed manually and therefore do not automatically compound, so rate is the more proper term.   Base vAPY    When Curve pools are launched, they receive a value for both the  fee  (the overall fee applied to trades) and the  admin_fee  (the percentage of this fee that goes to the Curve DAO as opposed to pool LPs). These parameters are directly viewable on the smart contract through the corresponding function names.   These fees are displayed on the Curve UI pool page:     These parameters may also be updated in the future by the Curve DAO by calling the  commit_new_fee  method. If the fees are in the process of being changed, these are readable in the smart contract via the  future_fee  and  future_admin_fee  methods.   The fees are specifically earned or charged every time a user interacts with a pool contract through a transaction which may affect the pool balances. For example, directly calling the  exchange  function would rebalance the pool, so a fee clearly applies. If you add or remove liquidity in an imbalanced fashion, this would also adjust the ratios of tokens within the pool and thus be subject to fees. No fees are charged if a user adds coin in a balanced proportion or on removal.   When you call methods to preview how many tokens you might receive for interacting with a pool (ie  get_dy  or  calc_token_amount ) the values they return are usually but not always inclusive of any fees  the UI calculations are intended to make any corrections where appropriate, but be sure to ask the support team if you have questions.   Theoretically, one could calculate the base vAPY for any period by calculating the fees for every transaction and summing over the entire range. However, the Curve UI utilizes a simpler methodology to calculate the base vAPY, where  t  is the time in days:   $$ \\left[ \\frac{virtual\\_price({t=0})}{virtual\\_price({t=-1})} \\right] ^{365} - 1 $$   In other words, the vAPY measures the change in the pools  \"virtual price\"  between today and yesterday, then annualizes this rate. The  \"virtual price\"  is a measure of the pool growth over time, and is viewable directly on the UI.     The UI receives this value directly by calling the  get_virtual_price  method on the pool contract.   Every time a transaction occurs that charges a fee, the virtual price is incremented accordingly. Thus, when a pool launches with a virtual price of exactly 1, if the pools virtual price is 1.01 at some future time, an LP holding a token has seen the tokens value increase by 1%.   $$ \\frac{1.01}{1.00} - 1 = 0.01 = 1\\% $$   A virtual price of 1.01 means an LP will get 1% more value back on removing liquidity. Similarly, new users adding liquidity will receive 1% fewer LP tokens on deposit.   For pegged stablecoin pools, virtual price can easily be utilized to calculate vAPY of the pool since inception with no further calculations necessary. For v2 pools, one must also consider the fluctuating prices of underlying assets.   For developers, here are more details about trade fees from the technical documentation:      About Trade Fees     Claiming Admin Fees     Fee Distribution         $CRV Rewards tAPR   The Curve DAO also authorizes some pools to receive bonus rewards from $CRV token emission, as described in the  Understanding Gauges  section of the documentation. If the pool has an eligible gauge, then the UI displays the range of possible tAPR values users are earning at present, subject to change in the future.   The formula used here to calculate rewards tAPR:   $$ tAPR = \\frac{(crv\\_price * inflation\\_rate * relative\\_weight * 12614400)}{working\\_supply * asset\\_price * virtual\\_price} $$   These parameters are obtained from various data sources, mostly on-chain:     crv_price:  The current price of the $CRV token in USD. This could be extrapolated from on-chain data, but the UI relies on the CoinGecko API to fetch this value.   inflation_rate:  The inflation rate of the $CRV token, accessed from the  rate  function of the $CRV token.   relative_weight:  Based on weekly voting, each Curve pool rewards gauge has a weighting relative to all other Curve gauges. This value can be calculated by calling the same function on the Curve  gauge controller contract .        https://dao.curve.fi/      working_supply:  Accessed by calling the same function on the specific Curve gauge contract for the pool.   asset_price:  The price of the asset  that is, if the pool contains only bitcoin, you would use the current price of $BTC. For v2 pools, this must be calculated by averaging over the specific assets within the pool.   virtual_price:  The measure of the pool growth over time, as described above.     The magic number  12614400  is number of seconds in a year  (60 * 60 * 24 * 365 = 31536000)  times 0.4. In this case the 0.4 is due to the effect of boosts (minimum boost of 1 / maximum boost of 2.5 = 0.4).   As shown in the UI, all tAPR values are displayed as a range, with the base rate on the left of the arrow representing the default rate one would receive if the user has no boost, and the value on the right of the arrow representing the maximum value a user could receive if the user has the maximum boost, which is 2.5 times higher than the minimum boost. Further details about calculating boosts  are provided here .   For developers, here are relevant links to the technical documentation:      About Liquidity Gauges     Gauge Controller     Gauges for EVM Sidechains     Gauge Proxy      Incentives tAPR    All pools may permissionlessly stream other token rewards without approval from the Curve DAO. The UI displays these bonus rewards only when applicable. In the example of stETH below, note how the pool is streaming $LDO tokens in addition to $CRV rewards.      Pool Overview Page       stETH Pool Page    Further information on these extra incentives is available in the developer documentation.   The Curve DAO: Liquidity Gauges and Minting CRV  Curve 1.0.0 documentation        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Deposit faqs", "html_url": "https://resources.curve.fi/lp/deposit-faqs/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools               Deposit faqs           Deposit faqs           Table of contents         Deposit FAQs           What is the y in the y pools (also what is Yearn)?         What is the deposit wrapped option?         What happens when you provide liquidity on Curve?         Does the coin I deposit matter?         Understanding deposit bonuses         But does that mean I can still withdraw in my favorite stable coin?         How quickly does interest accrue/compound?         What is arbitrage?         What are incentivized pools?         What makes the incentives APR move?                       Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Deposit FAQs           What is the y in the y pools (also what is Yearn)?         What is the deposit wrapped option?         What happens when you provide liquidity on Curve?         Does the coin I deposit matter?         Understanding deposit bonuses         But does that mean I can still withdraw in my favorite stable coin?         How quickly does interest accrue/compound?         What is arbitrage?         What are incentivized pools?         What makes the incentives APR move?                          Deposit faqs   Deposit FAQs    What is the y in the y pools (also what is Yearn)?    Yearn  is a yield aggregator. You might think that Compound doesnt always have the best lending rates and you would be right thus the yToken balances automatically your stablecoin to the protocol(s) with the better rates (Compound, Aave and dYdX). Its free and non-custodial (as is Curve) but it is also why the yPools are considered more risky as you use a series of protocols that could themselves have critical vulnerabilities.   What is the deposit wrapped option?    (This applies to metapools or pools with tokens with c tokens or y tokens). If you deposit a stablecoin to one of the pools with lending, Curve will automatically wrap your token to a cToken (for Compound) or a yToken(for yearn). The option is simply there if you have already previously wrapped your tokens on yearn or lent them on Compound. If your stablecoin is in its original form, you can ignore this option.   What happens when you provide liquidity on Curve?    When you go to the deposit page and deposit one stablecoin, it then gets split between each token in the pool. Thats something you have to keep in mind because if you were to deposit 1000 DAI in the yPool, a per the screenshot below, your balance would be roughly equal to 158.9 DAI, 142.4 USDC, 582.4 USDT and 121.6 TUSD. Those values change constantly as people trade and arb the price of stable coins.     Does the coin I deposit matter?    Besides the deposit bonus explained below, it doesnt matter. Your tokens will get split into the pool and it doesnt affect your returns so you can deposit one, some or all the coins into the pool without worrying about it affecting your returns.   Understanding deposit bonuses    On the screenshot above, you can see TUSD is quite low on the pool so if your plan was to join the yPool, you would ideally deposit TUSD into it. As you can see on the screenshot, you would get an instant 0.2% bonus for depositing TUSD into the pool.   The main reason for this is that TUSD is currently slightly more expensive so if you went to a centralized exchange you might sell it for $1.007 instead of $1. The deposit bonus reflects that.   The other reason behind this is that the pools are always trying to balance themselves and go back to equal parts (in this case 25% TUSD) so depositing the coin with the lowest share will get you a deposit bonus.     But does that mean I can still withdraw in my favorite stable coin?    When you withdraw, the same principle applies (but reversed). If you withdraw the stable coin with the biggest share, you would get a bonus but you still choose what stable coin you want to withdraw.   How quickly does interest accrue/compound?    Interests for pools using lending protocols compound every block or 15 seconds or immediately after fees are paid. Its also compounded automatically.   What is arbitrage?    Arbitrage is the simultaneous buying and selling of, in our case, a token to make a profit. Because cryptocurrency markets can often lack liquidity, there are often opportunities for traders to take advantage of price discrepancies to make a profit which can be helped by protocols like Curve.   An example of that below:    https://etherscan.io/tx/0x259b7ac1f50554fe5ddcfeea7b4fa90ad70356ddfbbd341289db0dfbf99447f9    In this transaction, someone used Curve and OasisDex and made around $200. This goes back to what was discussed earlier with liquidity pools. The idea is that is you incentivize traders to take advantage of price discrepancies which we all get rewarded for.   What are incentivized pools?    Liquidity pools (particularly one without an opportunity cost) are a great way to help stable coins keep their pegs. It makes easy for traders to arb (see question above) when the price slips off the peg which is very important for all the companies and foundations developing stable coins as having a $0.98 stablecoin is never a good look.   As a result, some pools on Curve are incentivized. That means that on top of trading fees and lending fees, the companies will give rewards to people providing liquidity to the pools with their coins.     What makes the incentives APR move?    The steth pool in this screenshot earns another 2.69% of LDO per year and there are three variables that can make this change:     The LDO distributed is based on the number of people staking their LP tokens, which means your share of rewards gets lower if more people start staking   The price of LDO (price of LDO going up would make the yearly bonus go up)   The size of weekly rewards (48,000 SNX as of today) could also be lowered as Lido reevaluates its partnership with Curve          Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Depositing", "html_url": "https://resources.curve.fi/lp/depositing/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing             Depositing           Depositing           Table of contents         Depositing           Before depositing...         Choosing the right pool                       Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Depositing           Before depositing...         Choosing the right pool                          Depositing   Depositing    Before depositing...    Before depositing into a Curve pool, it is highly recommended to familiarise yourself with how Curve works, how it makes money and its basic mechanisms.   You can do so by visiting the page below:   Understanding Curve v1   Choosing the right pool    Curve has many pools to choose from currently accepting stable coins and tokenised Bitcoin (Bitcoin on Ethereum). If you are not sure which pool is right for you, click the link below:   Understanding Curve Pools        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Understanding curve pools", "html_url": "https://resources.curve.fi/lp/understanding-curve-pools/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers             Understanding curve pools           Understanding curve pools           Table of contents         Understanding Curve Pools           What are liquidity pools?         Base vAPY         What are Curve fees?                       Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Understanding Curve Pools           What are liquidity pools?         Base vAPY         What are Curve fees?                          Understanding curve pools   Understanding Curve Pools    As you should know, providing liquidity has its fair share of risks so in this article, we review the different Curve pools to help you find one that matches your risk tolerance while explaining the risks involved with being a liquidity provider on Curve.   There are currently several Curve pools with new pools added all the time.     Its important to understand that when you provide liquidity to a pool, no matter what coin you deposit, you essentially gain exposure to all the coins in the pool which means you want to find a pool with coins you are comfortable holding.   Before we continue, we assume you have familiarized yourself with the basics of Curve:   Understanding Curve v1   All Curve liquidity gauges receive CRV based on how much the DAO allocates to it.   What are liquidity pools?    If you are new to Ethereum or DeFi, liquidity pools are a seemingly complicated concept to understand.   Liquidity pools are pools of tokens that sit in smart contracts. If you were to create a pool of DAI and USDC where 1 DAI = 1 USDC. You would have the same amount of tokens, lets say 1,000 tokens (1,000 DAI and 1,000 USDC) in the pool.   If trader 1 comes and exchange 100 DAI for 100 USDC, you would then have 1,100 DAI and 900 USDC in the pool so the price would tilt slightly lower for USDC to encourage another trader to exchange USDC for DAI and average the pool back.   You can see those details for each pool and it is something you can take advantage of when depositing.     On the screenshot above for the  TriCrypto v2 Pool , the three volatilely priced tokens are held in proportions similar to their price. If the coins are out of proportion traders are incentivized to take advantage of the arbitrage, which will push the balances in the pool back towards proportion     Base vAPY    To understand what the different pools do, its also important to understand how Curve makes money for liquidity providers. Curve interests come from trading fees. Every time someone uses Curve to exchange tokens, through the Curve website, 1inch, Paraswap or another dex aggregator, a small fee is distributed to liquidity providers. This is why base vAPY increases with volume on Curve.   Some pools (Compound, PAX, Y, BUSD) also earn interest from lending protocols. Behind the scenes, those four pools also use lending protocols (like Compound or AAVE) to help generate more interest for liquidity providers. Whilst it means those pools can be better performers when lending rates are high, its also worth noting it also adds more layers of risks.   All pools earn interest from trading fees. Some pools also earn interest from lending and there are also some pools with incentives. You can also receive CRV when you provide liquidity on Curve Finance. Each liquidity gauge receives a different amount of CRV based on how much the DAO allocates to it.   Every time someone makes a trade on Curve.fi, liquidity providers (people who have deposited funds onto Curve) get a  small fee  split evenly between all providers, this is why you will see high vAPYs on days with high volume and high volatility. Its important to note that because fees are dependent on volume, daily vAPYs can often be quite low just like they can be very high.   What are Curve fees?    Swap fees are typically around 0.04% which is thought to be the most efficient when exchange stable coins on Ethereum.   Deposit and withdrawals have fees between 0% and 0.02% depending if depositing and withdrawing in imbalance or not. If fees were 0%, users could, for example, deposit in USDC and withdraw in USDT for free. Balanced deposits or withdrawals are free.        Last update:  2023-09-04                  Back to top", "labels": ["Documentation"]}, {"title": "Depositing into a metapool", "html_url": "https://resources.curve.fi/lp/depositing/depositing-into-a-metapool/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing               Depositing into a metapool           Depositing into a metapool           Table of contents         Depositing into a Metapool           Depositing         Confirming and staking                       Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Depositing into a Metapool           Depositing         Confirming and staking                          Depositing into a metapool   Depositing into a Metapool    Metapools is a new concept to Curve Finance, it allows a single coin to be pooled with all the coins in another (base) pool without diluting its liquidity. Currently, the most common base pool is the 3Pool. It uses the three most liquid stable coins (USDT-USDC-DAI).   Base & MetaPools   Depositing    Metapools offer several options for deposits. For example, in the [GUSD,[3Pool]] Metapool you can deposit the following:     GUSD   Any of the 3Pool (DAI-USDC-USDT)   3Pool LP token (3crv)     When becoming a liquidity provider, you don't have to deposit all the coins, you can deposit one or several of the coins in the pool and it won't affect your returns. Depositing the coin with the smallest share in the pool will result in a small deposit bonus.   Second, once you deposit one stable coin,  it gets split over the four different coins in the pool which means you now have exposure to all of them . The first checkbox (Add all coins in a balanced proportion) allows you to deposit all four coins in the same proportion they currently are in the pool.   The  deposit wrapped  option lets you deposit the base pool token (usually 3Pool).   If you don't want to add all your stable coins, just click the \"Use maximum amount of coins available\" checkbox and enter the number of coins you wish to deposit and click \"Deposit and Stake\".   If you deposit 3Pool LP token into a Metapool, you will be earning at the rate of the Metapool gauge but you earn trading fees from both the base and meta pool.   Confirming and staking    You will then be asked to approve the Curve Finance contract, follow by a deposit transaction which will wrap your stable coins and deposit them into the pool. This transaction can be expensive so you ideally want to wait for gas to be fairly cheap if this will impact the size of your deposit.   After depositing in the pool, you receive liquidity provider (LP) tokens. They represent your share of ownership in the pool and you will need them to stake for CRV.   After depositing, you will be prompted with a new transaction that will deposit your LP tokens in the DAO liquidity gauge. Confirming the transaction  will let you mine CRV.   Once that's done, you're providing liquidity and staking so all that's left to do is wait for your trading fees to accrue.   You can click the link below to learn how to boost your CRV rewards by locking CRV on the Curve DAO.   Boosting your CRV Rewards   Staking your $CRV        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Depositing into the susd pool", "html_url": "https://resources.curve.fi/lp/depositing/depositing-into-the-susd-pool/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool               Depositing into the susd pool           Depositing into the susd pool           Table of contents         Depositing into the sUSD Pool           Depositing into the pool         Confirming and staking                       Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Depositing into the sUSD Pool           Depositing into the pool         Confirming and staking                          Depositing into the susd pool   Depositing into the sUSD Pool    If youre wanting to figure out Curve, please  read the starter guide . After reading this, you should have an understanding of how Curve works, how it makes money for liquidity providers and its risks which is ideally what you want before providing liquidity.   Understanding Curve v1   Curve Finance sUSD pool has quickly become the biggest pool thanks to its SNX incentives which guarantee continuous returns to liquidity providers.   The sUSD pool was born out of a partnership between Curve and Synthetix who sought to help bring stability to their stablecoin sUSD. The pool is not a lending pool which means your main APY only comes from trading fees. The pool has sUSD, DAI, USDC and USDT. Unlike Y pool, the sUSD pool is quite cheap to deposit in making it a good choice if you want to try Curve with a small amount.   The current rewards have no expiry date but can be adjusted by a vote from Synthetix governance.   Depositing into the pool    Visit the deposit page ( https://www.curve.fi/susdv2/deposit ). You will need one or multiple stablecoins to deposit. The sUSD pool takes DAI, USDC, USDT and sUSD.     First, it's important to understand that you don't have to deposit all coins, you can deposit one or several of the coins in the pool and it won't affect your returns. Depositing the coin with the smallest share in the pool will result in a small deposit bonus.   Second, once you deposit one stable coin,  it gets split over the four different coins in the pool which means you now have exposure to all of them . The first checkbox (Add all coins in a balanced proportion) allows you to deposit all four coins in the same proportion they currently are in the pool.   If you don't want to add all your stablecoins, just click the \"Use maximum amount of coins available\" checkbox and enter the number of coins you wish to deposit and click \"Deposit and Stake\".   Confirming and staking    You will then be asked to approve the Curve Finance contract, follow by a deposit transaction which will wrap your stablecoins and deposit them into the pool. This transaction can be expensive so you ideally want to wait for gas to be fairly cheap if this will impact the size of your deposit.   After depositing in the pool, you receive liquidity provider (LP) tokens. They represent your share of ownership in the pool and you will need them to stake for CRV.   After depositing, you will be prompted with a new transaction that will deposit your LP tokens in the DAO liquidity gauge. Confirming the transaction  will let you mine CRV and SNX .   You can claim both those tokens from the minter gauge.   Once that's done, you're providing liquidity and staking so all that's left to do is wait for your trading fees to accrue.   You can click the link below to learn how to boost your CRV rewards.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Depositing into the tri pool", "html_url": "https://resources.curve.fi/lp/depositing/depositing-into-the-tri-pool/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool               Depositing into the tri pool           Depositing into the tri pool           Table of contents         Depositing into the Tri-Pool           Depositing into the pool         Confirming and staking                       Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Depositing into the Tri-Pool           Depositing into the pool         Confirming and staking                          Depositing into the tri pool   Depositing into the Tri-Pool    The Tri-Pool is a classic Curve pool and improved upon earlier offerings in many ways.   Here are some of the major improvements this pool:     A new rampable A parameter (like on BTC pools) which can adjust liquidity density without causing losses to the virtual price (and to LPs)   Gas optimised   Will be used as a base pool for meta pools (which would essentially allow some pools to seemingly trade against underlying base pools without diluting liquidity)   By only having the three most liquid stable coins in crypto, this pool should grow to become the most liquid and offer the best prices     This pool is expected to become the most liquid and the cheapest to interact with making it a good place to start for newcomers wanting to try Curve with small amounts of capital. Because this pool is likely to offer the best prices, it will also likely be one of the Curve pools getting the most volume.   See how to deposit and stake into the 3Pool:  https://www.youtube.com/watch?v=OsRrGij9Ou8             Depositing into the pool    Visit the deposit page ( https://www.curve.fi/3pool/deposit ). You will need one or multiple stable coins to deposit. The Tri-Pool takes DAI, USDC and USDT.     First, it's important to understand that you don't have to deposit all coins, you can deposit one or several of the coins in the pool and it won't affect your returns. Depositing the coin with the smallest share in the pool will result in a small deposit bonus.   Second, once you deposit one stable coin,  it gets split over the three different coins in the pool which means you now have exposure to all of them . The first checkbox (Add all coins in a balanced proportion) allows you to deposit all four coins in the same proportion they currently are in the pool.   If you don't want to add all your stable coins, just click the \"Use maximum amount of coins available\" checkbox and enter the number of coins you wish to deposit and click \"Deposit and Stake\".   Confirming and staking    You will then be asked to approve the Curve Finance contract, follow by a deposit transaction which will wrap your stable coins and deposit them into the pool. This transaction can be expensive so you ideally want to wait for gas to be fairly cheap if this will impact the size of your deposit.   After depositing in the pool, you receive liquidity provider (LP) tokens. They represent your share of ownership in the pool and you will need them to stake for CRV.   After depositing, you will be prompted with a new transaction that will deposit your LP tokens in the DAO liquidity gauge. Confirming the transaction  will let you mine CRV.   Once that's done, you're providing liquidity and staking so all that's left to do is wait for your trading fees to accrue.   You can click the link below to learn how to boost your CRV rewards by locking CRV on the Curve DAO.   Boosting your CRV Rewards           Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Depositing into the y pool", "html_url": "https://resources.curve.fi/lp/depositing/depositing-into-the-y-pool/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool               Depositing into the y pool           Depositing into the y pool           Table of contents         Depositing into the Y Pool (deprecated)           Depositing into the pool         Confirming and staking                                     Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Depositing into the Y Pool (deprecated)           Depositing into the pool         Confirming and staking                          Depositing into the y pool   Depositing into the Y Pool (deprecated)      Warning   The content of this page is deprecated but it was maintained here to preserve history.     If youre wanting to figure out Curve, please  read the starter guide   at this address . After reading this, you should have an understanding of how Curve works, how it makes money for liquidity providers and its risks which is ideally what you want before providing liquidity.   Curve Finance Y pool has long been one of the most popular pools on Curve Finance due to its strong returns from trading fees supplemented by iEarn which also lends your stablecoin in the background to the lending protocol with the best lending rates out of dYdX and AAVE.   Y pool also receives CRV rewards since its launch in early August. Now you know how the Y pool makes money for liquidity providers and you're ready to start providing liquidity.   Depositing into the pool    Visit the deposit page ( https://www.curve.fi/iearn/deposit ). You will need one or multiple stablecoins to deposit. The Y pool takes DAI, USDC, USDT and TUSD.     First, it's important to understand that you don't have to deposit all coins, you can deposit one or several of the coins in the pool and it won't affect your returns. Depositing the coin with the smallest share in the pool will result in a small deposit bonus like seen on the screenshot above.   Second, once you deposit one stable coin,  it gets split over the four different coins in the pool which means you now have exposure to all of them . The first checkbox (Add all coins in a balanced proportion) allows you to deposit all four coins in the same proportion they currently are in the pool.   The \"Deposit wrapped\" option allows you to directly deposit Y tokens that have been previously wrapped (on yEarn Finance website). If you are depositing a normal stable coin, you can ignore this option.   If you don't want to add all your stablecoins, just click the \"Use maximum amount of coins available\" checkbox and enter the number of coins you wish to deposit and click  \"Deposit and Stake\" . You will then be prompted to confirm multiple transactions.   Confirming and staking    You will then be asked to approve the Curve Finance contract, follow by a deposit transaction which will wrap your stable coins and deposit them into the pool. This transaction can be expensive so you ideally want to wait for gas to be fairly cheap if this will impact the size of your deposit.   After depositing in the pool, you receive liquidity provider (LP) tokens. They represent your share of ownership in the pool and you will need them to stake for CRV.   After depositing, you will be prompted with a new transaction that will deposit your LP tokens in the DAO liquidity gauge. Confirming the transaction will let you mine CRV.   You can claim them from the minter gauge.   Once that's done, you're providing liquidity and staking so all that's left to do is wait for your trading fees to accrue.   You can click the link below to learn how to boost your CRV rewards.   Boosting your CRV Rewards        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Bridging funds", "html_url": "https://resources.curve.fi/multichain/bridging-funds/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain               Bridging funds           Bridging funds           Table of contents         Bridging Funds           $CRV Cross-Chain         Important Bridges                       Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Bridging Funds           $CRV Cross-Chain         Important Bridges                          Bridging funds   Bridging Funds    In order to use Curve on chains other than Ethereum, you will need to  bridge  funds to the sidechain. Curve operates on several chains, documented here:   Understanding Multichain   Bridges are not operated by Curve, so Curve cannot offer support for using bridges. The following issues may affect users of bridges, so make sure to do research and exercise caution.     Liquidity issues:  Sometimes bridges do not have enough liquidity to process transactions. Usually the bridge will wait to refill liquidity before it permits funds getting processed.   Stuck funds:  Occasionally funds will get moved off one chain, but fail to appear on the new chain in a timely manner. Sometimes this gets resolved by simply waiting. In extreme cases, you should contact the support channels for the bridge in question.   Hacking:  Cross-chain communication can be complex, and the bridge is     $CRV Cross-Chain    The Curve token can be bridged across some chains, but does not always have full functionality. Staking of $CRV for veCRV must be done on Ethereum. Rewards voting for cross-chain gauges occurs on Ethereum.   Important Bridges      Arbitrum:   https://bridge.arbitrum.io/    Fantom:    Spookyswap:   https://spookyswap.finance/bridge        Polygon:   https://wallet.polygon.technology/bridge/    xDai   xDai Bridge:   https://bridge.xdaichain.com/    Omni Bridge:   https://omni.xdaichain.com/bridge               Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Understanding multichain", "html_url": "https://resources.curve.fi/multichain/understanding-multichain/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain             Understanding multichain           Understanding multichain           Table of contents         Understanding Multichain           Connecting your Wallet         Curve Forks           Avalanche         Arbitrum         Binance Smart Chain         Fantom         Harmony         Optimis         Polygon         xDai                             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Understanding Multichain           Connecting your Wallet         Curve Forks           Avalanche         Arbitrum         Binance Smart Chain         Fantom         Harmony         Optimis         Polygon         xDai                                Understanding multichain   Understanding Multichain    Curve exists across several chains, with several more planned. Curve's primary chain will always be Ethereum, but other sidechains have advantages including speed and cost. In order to use Curve on other chains, you must typically send your funds from Ethereum to the sidechain using the chain's bridge.   All of Curve's active chains can be found in the \"Networks\" menu on the Curve homepage.       Supported Sidechains as of 11/14/2022     Connecting your Wallet    When you move to new chains, you will need to connect your wallet with the chain's RPC and chain ID. Generally Curve sidechain pages have a button you can press to automatically switch networks and populate this information for you.     A common issue with sidechains is RPC networks that are temporarily or permanently unavailable. If you are having trouble connecting with RPC networks you may need to visit the chain's support networks to find a new RPC network.   Curve Forks    Curve forks include the following:   Avalanche    Avalanche is a sidechain that bills itself as \"blazingly fast, low-cost and eco-friendly.\" Curve's Avalanche site is hosted at  https://avax.curve.fi/    Arbitrum    Arbitrum is an Optimistic Ethereum L2. Arbitrum validators  optimistically  assume nodes will be operating in good faith, which allows for faster transactions. However, to retroactively allow opportunity to challenge malicious behavior, settlement time can be slower. In some cases this could mean it takes up to one week to bridge funds off-chain, so plan accordingly.   Useful Links:     Curve:   https://arbitrum.curve.fi/    Bridge:   https://bridge.arbitrum.io/    Block Explorer:   https://arbiscan.io/      Binance Smart Chain    Curve does not operate on Binance Smart Chain. The team at Ellipsis ( https://ellipsis.finance/ ) launched a fork of Curve that provides similar functionality. The Curve team authorized this fork, but does not actively maintain this fund.   Fantom    Using Curve on Fantom   Harmony    Harmony is a proof-of-stake sidechain promising two seconds of transaction speed and a hundred times lower gas fee. Curve's Harmony offerings are at  https://harmony.curve.fi/    Optimis    Optimism is verified by a series of smart contracts on the Ethereum mainnet and thus not considered a real sidechain. Curve's Optimism branch is located at  https://optimism.curve.fi/    Polygon    Using Curve on Polygon   xDai    The xDai chain is a stable payments EVM (Ethereum Virtual Machine) blockchain designed for fast and inexpensive transactions.   Useful Links:     Curve :  https://xdai.curve.fi/    Bridges:   xDai Bridge:   https://bridge.xdaichain.com/    Omni Bridge:   https://omni.xdaichain.com/bridge        Block Explorer:   https://blockscout.com/xdai/mainnet/           Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Using curve on fantom", "html_url": "https://resources.curve.fi/multichain/using-curve-on-fantom/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds               Using curve on fantom           Using curve on fantom           Table of contents         Using Curve on Fantom           Changing your MetaMask network         Acquiring FTM         Head to Curve                       Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Using Curve on Fantom           Changing your MetaMask network         Acquiring FTM         Head to Curve                          Using curve on fantom   Using Curve on Fantom    Changing your MetaMask network    Fantom is an EVM-compatible chain meaning it can easily run with MetaMask. The first step of this tutorial is to set up a different the Fantom network on Metamask. Click on Settings and Networks and add. Fill details as below:     RPC:  https://rpcapi.fantom.network    Chain Id: 250   Symbol: FTM   Explorer:  https://ftmscan.com        Acquiring FTM    Now that you're set up in MetaMask, you can browse any Fantom dapps with ease. Each account on Ethereum also exists on Fantom which means you can use the same addresses without issues on Ethereum and Fantom.  Please note Fantom does not yet support MetaMask via Ledger.   To get started you'll need to get Fantom native currency FTM, you can acquire it on SushiSwap or most centralised exchanges. For the latter, you can transfer directly to your Fantom address via the Fantom blockchain. If you purchase FTM on the Ethereum blockchain, you can cross to Fantom using bridges.   This will let you transfer FTM from Ethereum to Fantom and start transacting.   Head to Curve    Once that's done you can also bridge USDC/DAI and deposit and swap on Curve Fantom website making sure you're connected to the Fantom network in your MetaMask settings:   Curve.fi     Experience Curve like it's January 2020        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Using curve on polygon", "html_url": "https://resources.curve.fi/multichain/using-curve-on-polygon/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom               Using curve on polygon           Using curve on polygon           Table of contents         Using Curve on Polygon           Changing your MetaMask network         Acquiring Matic to pay for transaction fees         Head to Curve                               Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Using Curve on Polygon           Changing your MetaMask network         Acquiring Matic to pay for transaction fees         Head to Curve                          Using curve on polygon   Using Curve on Polygon    Changing your MetaMask network    Upon visiting  https://polygon.curve.fi/ , you will be prompted to change your network on Metamask:     Acquiring Matic to pay for transaction fees    Transaction fees on Matic are very cheap usually costing less than $0.0001 but you'll still need Matic to pay for gas. You can bridge some from Ethereum using the link below:   Polygon   Head to Curve    Once that's done you can also bridge USDC/DAI and deposit and swap on Curve Polygon website making sure you're connected to the Polygon network in your MetaMask settings:   Curve.fi   If you haven't used Curve below you can check out the tutorial below:   Depositing        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Boosting your crv rewards", "html_url": "https://resources.curve.fi/reward-gauges/boosting-your-crv-rewards/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge               Boosting your crv rewards           Boosting your crv rewards           Table of contents         Boosting your CRV Rewards           Figuring out your required boost         Locking your CRV         Applying your boost         Formula         FAQ                       Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Boosting your CRV Rewards           Figuring out your required boost         Locking your CRV         Applying your boost         Formula         FAQ                          Boosting your crv rewards   Boosting your CRV Rewards    This guide is assuming you have already provided liquidity and that you are currently staking your LP tokens on the DAO gauge.   One of the main incentive for CRV is the ability to boost your rewards on provided liquidity. Vote locking CRV allows you to acquire voting power to participate in the DAO and earn a boost of up to 2.5x on the liquidity you are providing on Curve.   Click below if you have questions about how the vote locking boost works:   Vote Locking   Boosting your rewards video guide:  https://www.youtube.com/watch?v=blZTCWu-DQg             Figuring out your required boost    The first step to getting your rewards boosted is to figure out how much CRV you'll need to lock. All gauges have different requirements meaning some pools are easier to boost than others. It depends on how much others have locked and how much the liquidity gauge has.   You can find the calculator at this address:  https://dao.curve.fi/minter/calc    Locking your CRV    Once you know how much and how long you wish to lock for, visit the following page:  https://dao.curve.fi/locker      Enter the amount you want to lock and select your expiry. Remember locking is not reversible. The amount of veCRV received will depend on how much and how long you vote for.   You can extend a lock and add CRV to it at any point but you cannot have CRV with different expiry dates.   After creating your lock, you will need to apply your boost.   Applying your boost    Head over to the minter page:  https://dao.curve.fi/minter/gauges    If you see your new boost after Current boost: then you do not need to do anything else.   If your current boost hasn't moved, you will need to claim CRV from each of the gauge you're providing liquidity in to update your boost. After doing so, your boost should be showing.     Your boost will not be updated until you withdraw, deposit or claim from a liquidity gauge.   Formula    The boost mechanism will calculate your  earning weight  by taking the smaller amount of two values. The first value is simple, it's the amount of liquidity you are providing which in this example is $10,000. This amount is your maximum earning weight.     FAQ    Vote Locking        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Creating a pool gauge", "html_url": "https://resources.curve.fi/reward-gauges/creating-a-pool-gauge/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges               Creating a pool gauge           Creating a pool gauge           Table of contents         Creating a Pool Gauge           Deploy a Gauge         Submit a DAO Vote                       Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Creating a Pool Gauge           Deploy a Gauge         Submit a DAO Vote                          Creating a pool gauge   Creating a Pool Gauge    Deploy a Gauge    You can deploy the gauge directly through the UI simply by posting the address:  https://classic.curve.fi/factory/create_gauge     Submit a DAO Vote    Once you've created your gauge, you need to submit it to the DAO for a vote.  https://classic.curve.fi/factory/create_vote    The address that submits must have 2500 veCRV in order to create a vote.     Once the gauge has been submitted, politics take over. You may want to visit the governance forum and explain why your pool should be made eligible for rewards.   Governance Forum        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Gauge weights", "html_url": "https://resources.curve.fi/reward-gauges/gauge-weights/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards               Gauge weights           Gauge weights           Table of contents         Gauge Weights           What are gauge weights?         Why are gauge weights so important?         Who can vote for gauge weights?         How can I vote?         How often can I move my voting weight?                               Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Gauge Weights           What are gauge weights?         Why are gauge weights so important?         Who can vote for gauge weights?         How can I vote?         How often can I move my voting weight?                          Gauge weights   Gauge Weights    What are gauge weights?    Simply put, a gauge weight translates into how much of the daily CRV inflation it receives.   For example on the below chart, the Y pool is currently receiving around 72% of the daily CRV inflation. This means that all liquidity providers in the Y pool share 72% of the daily CRV.     You can find each liquidity gauge relative weight on this page:  https://dao.curve.fi/minter/gauges    Why are gauge weights so important?    Because those weights decide where the CRV inflation goes, it allows the DAO to control where most of the liquidity should go and balance liquidity. It's a powerful tool for voters that must be used responsibly.   The gauge weight is updated once a week on Thursdays.   Who can vote for gauge weights?    Anybody who has vote  locked CRV  can vote to direct its voting power towards one or multiple Curve pools.   How can I vote?    Visit this link:  https://dao.curve.fi/gaugeweight    Select the gauge you would like to put your voting weight towards, enter an amount in BPS (10,000 = 100% the maximum) and confirm your transaction.   How often can I move my voting weight?    You can change your voting weight once every 10 days.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Understanding gauges", "html_url": "https://resources.curve.fi/reward-gauges/understanding-gauges/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges             Understanding gauges           Understanding gauges           Table of contents         Understanding Gauges           The gauge system         The weight system         The DAO                       Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Understanding Gauges           The gauge system         The weight system         The DAO                          Understanding gauges   Understanding Gauges    Reviewing the gauge system, one of the Curve DAO base feature.   The gauge system    On Curve Finance, the inflation is going to users who provide liquidity. This usage is measured with gauges. The liquidity gauge measures how much a user is providing in liquidity.   The liquidity gauge measures how many dollars you have provided in a Curve pool. Each Curve pool has its own liquidity gauge where you can stake your liquidity provider tokens   The weight system    Each gauge also has a weight and a type. Those weights represent how much of the daily CRV inflation will be received by the liquidity gauge.   The DAO    The weight systems allow the Curve DAO to dictate where the CRV inflation should go. You can vote at this address:  https://dao.curve.fi/gaugeweight    By doing so, you can put your voting power towards the liquidity gauge (or pool) you think should receive the most CRV.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Cross asset swaps", "html_url": "https://resources.curve.fi/troubleshooting/cross-asset-swaps/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support               Cross asset swaps           Cross asset swaps           Table of contents         Cross-Asset Swaps           Settlement and completing your trade         Technical Docs                       Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Cross-Asset Swaps           Settlement and completing your trade         Technical Docs                          Cross asset swaps   Cross-Asset Swaps    Cross-asset swaps are a new type of swaps on Curve using Synthetix as a bridge. There are a few things to know about them before getting started:     They have very little slippage, they can handle seven and eight-figure trades with no slippage   They take six minutes due to the Synthetix settlement period and prices can move during that period   You can trade any asset as it shares a pool with a synth (sUSD/sETH/sBTC)   They are in beta   They are expensive (~$80 at 50 gwei) and therefore best suited for large trades   They have two parts and thus two transactions     Initiating the trade   After selecting the two assets you would like to trade, click sell and confirm the first part of your transaction.   For the route below, we will go from DAI to sUSD to sBTC to renBTC. The first part of the trade takes you to sBTC.     Upon confirmation you will receive an NFT which represents your trade. The trade will immediately enter a settlement period of six minutes. It is best not to close your browser during that period.   Settlement and completing your trade      After Synthetix settlement period, you will then be able to complete your trade by clicking the Complete trade button. This second part will then take you from sBTC to renBTC.     After confirming this transaction, you then receive your renBTC.   Technical Docs    Read technical docs here:  https://curve.readthedocs.io/cross-asset-swaps.html         Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Disabling crypto wallets in brave", "html_url": "https://resources.curve.fi/troubleshooting/disabling-crypto-wallets-in-brave/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Disabling Crypto Wallets in Brave           Pointing Brave to Metamask                          Disabling crypto wallets in brave   Disabling Crypto Wallets in Brave    The native \"Crypto Wallets\" app in your Brave browser can often interfere with your web3 provider. When using Metamask, it is important to make sure Brave is pointing to it and not its native implementation.   Pointing Brave to Metamask    Open your web browser, and paste the following in your URL bar:  brave://settings/extensions     Click the dropdown and switch to Metamask. You can also disable Crypto Wallets on startup.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Dropping and replacing a stuck transaction", "html_url": "https://resources.curve.fi/troubleshooting/dropping-and-replacing-a-stuck-transaction/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps             Recovering a cross asset swap               Dropping and replacing a stuck transaction           Dropping and replacing a stuck transaction           Table of contents         Dropping and replacing a stuck transaction           Enable custom nonce in Metamask         Finding your pending transaction nonce         Replacing your transaction                       None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Dropping and replacing a stuck transaction           Enable custom nonce in Metamask         Finding your pending transaction nonce         Replacing your transaction                          Dropping and replacing a stuck transaction   Dropping and replacing a stuck transaction    A short tutorial on dropping and replacing a stuck Ethereum transaction.   You've submitted a transaction in Metamask and it just won't come through. Those gas estimates betrayed you and you're stuck looking at your pending transaction on Etherscan. It's happened to everyone and it's not pleasant but there's a fairly simple solution which most people will come to learn about.   This guide isn't Curve Finance specific but as gas prices are reaching new highs, stuck transactions are getting more common and knowing how to drop and replace is thus become more and more useful.   First and foremost, it's important to understand you can only do this if your transaction is pending. If it isn't your transaction cannot be cancelled anymore.   If you want to understand how this works, you should know that Ethereum transactions must be submitted with an incremental nonce. Each transaction has a nonce (a number) assigned to it and a number cannot be skipped. The way to replace and drop is to submit a new transaction with a higher gas price and the same nonce. This will tell the miners this more expensive transaction is the one that should be mined and your stuck transaction will be discarded.   Enable custom nonce in Metamask    Visit Metamask and select \"Settings\", then \"Advanced\" and scroll down to find and enable \"Customize transaction nonce\".     Finding your pending transaction nonce    Visit your address on Etherscan and click on your pending transaction. If you scroll down you will find \"Nonce\":     Write down this nonce and return to Metamask.   Replacing your transaction    Now that you have your nonce, go back to Ethereum and send yourself 0 Ethereum, on the confirmation screen, type the nonce you got from Etherscan.   Make sure your gas price is suitable this time by checking  https://ethgasstation.info/  for example.     Confirm your transaction and that's it. Your 0 Ethereum transaction should be mined which will drop and replace your stuck transaction which you can confirm on Etherscan.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Recovering a cross asset swap", "html_url": "https://resources.curve.fi/troubleshooting/recovering-a-cross-asset-swap/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting           Support             Cross asset swaps               Recovering a cross asset swap           Recovering a cross asset swap           Table of contents         Recovering a cross-asset swap           Finding the token id         Initiate recovery                       Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Recovering a cross-asset swap           Finding the token id         Initiate recovery                          Recovering a cross asset swap   Recovering a cross-asset swap    If Curve has lost transaction of your cross asset swap, do not panic, there is a simple way to recover it.   Finding the token id    Visit your address on Etherscan and click on ERC721:     And then click on your latest cross-asset swap, you should find a long string of numbers like below:     Initiate recovery    Visit:  https://www.curve.fi/recover    Enter your token id found on Etherscan, enter your the token you would like to receive (if your token has sBTC then it must be a Bitcoin token that shares a pool with sBTC, if your token is sUSD, it should be a token that shares a pool with sUSD) and then click recover.   Confirm your transaction and you're done.        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}, {"title": "Support", "html_url": "https://resources.curve.fi/troubleshooting/support/", "body": "Curve Resources               CurveDocs/curve-resources               Home               Getting Started             Getting Started           Understanding curve             Understanding crypto pools                     $crvUSD             $crvUSD           Understanding crvusd             Markets             Loan creation             Loan details             Understanding tokenomics             FAQ                     $CRV Token             $CRV Token           Understanding crv             Crv basics             Crv tokenomics             Staking your crv             Claiming trading fees                     Liquidity Providers             Liquidity Providers           Understanding curve pools             Base and metapools             Deposit faqs             Calculating yield               Depositing             Depositing           Depositing             Depositing into a metapool             Depositing into the susd pool             Depositing into the tri pool             Depositing into the y pool                           Reward Gauges             Reward Gauges           Understanding gauges             Creating a pool gauge             Boosting your crv rewards             Gauge weights                     Governance             Governance           Understanding governance             Vote locking boost             Voting             Snapshot               Proposals             Proposals           Proposals             Community fund             Creating a dao proposal                           Multichain             Multichain           Understanding multichain             Bridging funds             Using curve on fantom             Using curve on polygon                     Factory Pools             Factory Pools           Pool factory             Creating a stableswap pool             Creating a cryptoswap pool             Understanding oracles                     Troubleshooting             Troubleshooting             Support           Support           Table of contents         Understanding Technical Support                 Cross asset swaps             Recovering a cross asset swap             Dropping and replacing a stuck transaction             None                     Appendix             Appendix           Glossary             Security                     Links             Links           Curve.fi             Curve DAO             Github             Governance Forum             Technical Docs             Twitter             Techincal Documentation                                   Table of contents         Understanding Technical Support                    Support   Understanding Technical Support    Curve is to be used entirely at your own risk. Admins have no special keys and cannot recover funds if sent improperly.   However, a wide variety of resources are still available to help you avoid issues. If you have questions, please make sure to check with the following sources:     This section contains common troubleshooting questions, as does the entirety of this documentation.   The  technical documentation  is a comprehensive resource for coders.   The  Telegram channel  is an active place to seek support.   The  Discord also has an active support  channel.     Most users use Curve without issue, however we understand it can be complicated so make sure to ask first and save yourself any possible trouble later!        Last update:  2023-08-15                  Back to top", "labels": ["Documentation"]}]