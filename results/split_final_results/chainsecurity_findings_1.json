[{"title": "6.1   Missing Sanity Check of Chainlink Oracle", "body": " Price  Options smart contract calculates the required ETH price by querying a YFi/ETH ChainLink oracle and the curve oracle. Apart from the price of the YFi tokens, the oracle returns information about the point in time when its price was updated. However, this information is ignored by the current implementation. The stale prices might be used for estimations.    A check that the update time of the price oracle complies with the ChainLink heartbeat parameter for the YFI/ETH pool (24 hours or 86400 seconds) was added.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Not Initialized Variables", "body": "  On multiple occasions, some state variables are used which are never set and there are no functions that can update them. In particular:  In  Options.exercise,  ETH  is  sent  to  self.payee.  However,  this  variable  is  never  set. Hence, ETH will be sent to 0x0 address.  In  Gauge._getReward,  the  recipients  mapping  is  read.  However,  this  mapping  is  never written, thus the recipient[account] will always be 0x0. This means, that no other recipient than the owner of the Gauge tokens can receive the rewards.  Yearn - oYfi -   11  CriticalHighMediumCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedDesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                  \f   The  Options.payee  is  set  to  the  owner  in  the  constructor.  In  addition,  set_payee  function,  restricted to the owner, was added. It can change this field.   The Gauge.setRecipient function was added. It allows users to set the recipients mapping.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Divisions Before Multiplications", "body": "  In  the  implementation  in  the  scope,  there  are  multiple  instances  where  divisions  happen  before multiplications.  Such  sequences  of  operations  yield  less  precise  results.  In  particular,  the  following expressions can be rearranged:  In Options._eth_required,  amount * eth_per_yfi / PRICE_DENOMINATOR * discount / DISCOUNT_NUMERATOR  In Gauge._boostedBalanceOf,  ((_realBalance * BOOSTING_FACTOR) +     (((totalSupply() * IVotingYFI(VEYFI).balanceOf(_account)) /         veTotalSupply) *         (BOOST_DENOMINATOR - BOOSTING_FACTOR))) /     BOOST_DENOMINATOR,  Code partially corrected:   The Options._eth_required does the multiplications first and only then the divisions.   The  Gauge._boostedBalanceOf  is  left  unchanged.  This  numerical  imprecision  won't  affect  the functionality of the contract. No \"dust\" will be accumulated due to this because the penalty is defined in a way, that will sweep the leftover dust.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Sweeping Non-ERC20-Compatible Tokens", "body": "  Options.sweep allows any user to transfer any ERC20 compatible tokens owned by the contract to its owner. However, this call will fail for tokens that are not compliant with the ERC20 standard. The most prominent example is the USDT. USDT's transfer does not return any value in contrast to the ERC20 standard.  This  means  that  transfer  call  will  fail.  In  Solidity,  this  issue  is  tackled  with  the safeTransfer call (see Openzeppelin's safeERC20).    The default_return_value=True parameter was added in the Options.sweep token transfer call, that enables safeTransfer functionality in Vyper smart contracts.  Yearn - oYfi -   12  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   EIP-4626 Event Field Names", "body": "  Event  Deposit  and  event  Withdrawal  in  IERC4626  are  defined  with  address  indexed  caller. According  to  the  https://eips.ethereum.org/EIPS/eip-4626#events,  these  fields  should  be  named  as sender.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Full YFI Locked Discount Reverts", "body": "  In  the  case  of  the  quite  improbable  event,  when  the  total  supply  of  Yfi  is  locked  in  veYfi,  the  discount cannot be computed.  DISCOUNT_TABLE[total_locked * DISCOUNT_GRANULARITY / total_supply]  The DISCOUNT_TABLE has 500 elements. However, the max index is 499. This index access during the computation will revert, if total_locked == total_supply, because the element with index 500 is not present in the DISCOUNT_TABLE.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Incorrect Documentation", "body": "  In OYfiRewardPool.burn, the documentation reads as follows:  @notice Receive YFI into the contract and trigger a token checkpoint  The documentation is incorrect as OYFI is transferred instead of YFI.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Missing Indices in Events", "body": "  For some events, some arguments are not indexed even if this would make sense. In particular:  In Options.Sweep, the token argument could be indexed.  In Gauge.BoostedBalanceUpdated, the account argument could be indexed.  Yearn - oYfi -   13  InformationalVersion1InformationalVersion1InformationalVersion1InformationalVersion1                  \f7.5   Non-informative Error Message  BaseGauge.queueNewRewards  checks  whether  the  _amount  argument  is  non  0.  Should  this  check fail,  the  non-informative  ==0  message  will  be  returned.  Note  that  Solidity  0.8  allows  for  error  values instead of just strings to be returned upon check failure.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   Redundant Function Modifiers", "body": "  Multiple functions are defined using a public modifier, while they are not called within the contract. These functions could be set as external instead:   Gauge.convertToShares   Gauge.convertToAssets   Gauge.maxDeposit   Gauge.previewDeposit   Gauge.maxMint   Gauge.previewMint   Gauge.kick  Solidity  compiler  needs  to  perform  extra  routines  for  public  functions,  which  can  result  in  higher  gas usage.  Yearn - oYfi -   14  InformationalVersion1InformationalVersion1      \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Gauge Assumed Decimals", "body": "  The  Gauge  contract  uses  default  18  decimals.  However,  the  asset  can  have  a  different  number  of decimals. While the Yearn vault tokens have 18 decimals, this might not be true for any asset that might be used in Gauge. If an asset with a different number of decimals is introduced, the respective Gauge will misbehave.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Manipulation of Curve Oracle", "body": "  Options  calculates  the  price  of  YFI/ETH  by  querying  the  price  oracle  of  the  respective  Curve-pool. Curve  uses  a  time  weighted  price  oracle  or  (TWAP-oracle).  TWAP  oracles  have  been  shown  to  be manipulatable to an extent. Users should be aware that the system in scope does not perform any further sanity checks on the correctness of the reported price.  Yearn - oYfi -   15  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Outdated Interfaces", "body": "  The  zkSync  interfaces  for  L2Log  and  L2Message  have  been  updated  and  the  ones  used  in  the  DAI bridge current codebase are deprecated. The malformed L2 logs or messages would block any attempt of withdrawal or claim of a failed deposit.    The structs used correspond now to the most recent version of the zkSync 2.0 structs.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Refund Recipient Is Not Aliased", "body": "  On ZkSync the contract addresses are aliased using the AddressAliasHelper.applyL1ToL2Alias function,  to  distinguish  between  L1  and  L2  initiated  transactions.  However,  the  refund  recipient  in  the Mailbox.requestL2Transaction  call  in  the  L1DAITokenBridge  contract  doesn't  alias  the msg.sender address, even if it is a contract address.    Refund recipient address is aliased if the msg.sender is a contract.  MakerDAO - zkSync DAI Bridge -   12  CriticalCodeCorrectedHighMediumCodeCorrectedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCorrectnessCriticalVersion1CodeCorrectedDesignMediumVersion5CodeCorrected                 \f6.3   Critical Tests Missing  Some critical tests are missing in the test suite, for example, the e2e test for claiming a failed deposit is incomplete.    After  Matter  Labs  provided  the  necessary  sdk  functions  to  generate  the  proof  required  by claimFailedDeposit a test case was added.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Inconsistent Use of Interfaces", "body": "  When L1DAITokenBridge calls finalizeDeposit, it uses the L2DAITokenBridgeLike interface. The L2DAITokenBridge implements IL2Bridge, but IL2Bridge and L2DAITokenBridgeLike are not connected.    MakerDAO  uses  the  IL2Bridge  interface  now  and  has  removed  the  L2DAITokenBridgeLike interface.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Lack of Documentation", "body": "  The  main  functionality  is  sufficiently  documented.  However,  the  interaction  with  zkSync  2.0  remains undocumented.  This  is  of  high  importance  as  zkSync  2.0's  documentation  is  incomplete.  Furthermore, the emergency shutdown process remains undocumented.  Specification changed:  Natspec documentation was added.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Remaining TODO in the Source Code", "body": "  There is a leftover TODO comment in the code of L1DAITokenBridge.    The TODO was removed.  MakerDAO - zkSync DAI Bridge -   13  DesignMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                                \f6.7   Unused enum  There is an unused QueueType enum in the file L1GovernanceRelay.sol.    MakerDAO has removed the unused enum.  MakerDAO - zkSync DAI Bridge -   14  DesignLowVersion1CodeCorrected        \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   zksolc Not Up-To-Date", "body": "  The version of the compiler that currently used is 1.3.3, at the time of writing the latest compiler version is 1.3.5.  MakerDAO - zkSync DAI Bridge -   15  InformationalVersion1  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Contract Address Aliasing Maps to", "body": " Non-Operational Addresses  The contract deployment processes are different on zkSync and Ethereum mainnet, this discrepancy has as an effect that two similar contracts deployed by the account will not have the same address on L1 and L2, even considering address aliasing.  The  L1DAITokenBridge  specifies  the  msg.sender  (or  it's  alias  for  smart  contracts)  as  the  refund recipient.  The contracts that plan to use the L1DAITokenBridge need to be able to access the refunded funds. While the refunded funds will be credited on L2, the L1 contracts should be able to call zkSync bridges to spend those funds.  MakerDAO - zkSync DAI Bridge -   16  NoteVersion6  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Slashing Can Be Avoided", "body": "  CS-SUL12-002  The smart contract layer does not immediately know when a slashing event on the Consensus Layer has happened. Offchain, however, it is easy to immediately know when a validator has been slashed.  A user of an enzyme vault that uses one of the staking external positions could monitor for slashings and immediately  withdraw  from  the  vault  when  such  an  event  happens.  By  doing  this,  they  will  be  able  to redeem their assets (up to the available liquidity) at the pre-slashing price.  Once the slashing is accounted for in the vault (after about 12 hours in Stakewise), the slashing loss of the users that withdrew previously will instead be taken by those users that are still deposited in the vault.  Also,  note  that  the  same  behaviour  is  present  in  Stakewise's  vaults.  There,  any  user  can  withdraw immediately  up  to  the  available  liquidity  and  also  dodge  slashing.  However,  it  is  expected  that  the available  liquidity  in  Stakewise  vaults  should  never  be  more  than  32  ETH,  as  otherwise,  it  would  have been possible to stake them with an additional validator.  Risk accepted:  Avantgarde Finance acknowledged the issue and replied:  Since consensus layer slashing is not readable directly from the execution layer, slashing can only be made known by posting to the execution layer, and there will always be an opportunity to front-run posting (the same goes for Chainlink aggregators).  Fund managers must be aware of this risk and take any necessary precautions to mitigate the risk where needed, e.g., via policies and/or queued redemptions.  Avantgarde Finance - Sulu Extensions XII -   9  DesignCriticalHighMediumRiskAcceptedLowRiskAcceptedDesignMediumVersion1RiskAccepted           \f5.2   StakeWise Deposit May Revert  The following is an excerpt from the StakeWise documentation:  When keeper.canHarvest(<vault address>) returns false, the user can stake ETH to the vault without a state update. Otherwise, the updateStateAndDeposit function must be used.  The  enzyme  external  position  only  uses  deposit(),  not  updateStateAndDeposit().  If  a  state update is required, the manager currently needs to call updateState() from a separate address and then deposit() through the vault. Otherwise, deposit() reverts.  The same issue also applies to redeem().  CS-SUL12-003  Risk accepted:  Avantgarde Finance replied:  For now, managers can wait until a non-harvestable (i.e., depositable) moment. At a later time, we may update this or include a link/button to call `updateState()` directly.  Avantgarde Finance - Sulu Extensions XII -   10  DesignLowVersion1RiskAccepted        \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   StakeWise V3 Position Ticket Valuation   0  0  0  1  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   StakeWise V3 Position Ticket Valuation", "body": "  CS-SUL12-001  The  StakeWise  position's  value  is  the  sum  of  the  value  of  the  vault  tokens  held  and  the  value  of  the position tickets.  A  position  ticket's  withdrawal  value  is  determined  in  Stakewise's  calculateExitedAssets  function. This function does not use the current share price, it uses a checkpointed price which is set when the update happens that lets the contract know that a withdrawal is completed.  The external position uses the current exchange rate instead of the fixed exchange rate at the relevant state update.  As a result, a fund could be under- or overvalued.    The code has been changed. Tickets not exited yet are evaluated as previously. However, exited tickets are evaluated based on calculateExitedAssets() which returns the claimed amount.  Avantgarde Finance - Sulu Extensions XII -   11  CriticalHighMediumLowCodeCorrectedDesignLowVersion1CodeCorrected        \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Assessement of Finalized After Authed Action", "body": "  CS-CSC-001  In  ScribeOptimistic,  _afterAuthedAction()  will  be  called  after  every  change  to  the  parameters  to drop opPokeData if it's not yet finalized. The evaluation whether the optimistic poke is finalized is done using the possibly new value for opChallengePeriod however.  This has the following consequences:  In case the new challenge period is bigger, _afterAuthedAction will evaluate the finality based on  the  increased  challenge  period.  Consequently  an  already  finalized  opPokeData  becomes challengeable again and may be dropped.  In case the new challenge period is smaller, _afterAuthedAction will evaluate the finality based on  the  decreased  challenge  period.  Consequently  an  previously  un-finalized  opPokeData  will  be regarded finalized immediately.  Risk accepted:  Chronicle has accepted the risk of finality reevaluation and states:  The \"reevaluation of finality\" based on a possibly updated opChallengePeriod is accepted. We plan to update the challenge period in the beginning a few times to find \"the best\" reasonable value. Afterwards, we don't intend to update the challenge period anymore following a \"never stop a running system\" approach.  Chronicle - Scribe -   13  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedLowRiskAcceptedRiskAcceptedRiskAcceptedCorrectnessMediumVersion1RiskAccepted             \fFurthermore, the code has been adjusted that in case a finalized opPokeData is more recent than the _pokeData,  it  will  also  be  pushed  into  _pokeData  and  deleted.  This  avoids  resetting  the  challenge period for a finalized opPokeData. Chronicle states:  _afterAuthedAction has been updated to ensure the challenge period of an opPoke is not reset, which would decrease the possible update frequency via opPoke (). This is achieved via either moving _opPokeData to _pokeData storage if _opPokeData is finalized and newer than _pokeData, or deleting opPokeData otherwise.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Drop of opPoke if Authed Action Does Not", "body": " Update Anything  setOpChallengePeriod(),  setMaxChallengeReward(),  and  setBar()  will  always  call _afterAuthedAction() to drop unfinalized opPokeData, even if the updated parameter is the same as the old parameter.  CS-CSC-002  Risk accepted:  Chronicle states:  Skipping the afterAuthedAction in special cases changes the definition of the action, which is defined to be called after every authe'd configuration change.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   Lift Does Not Drop Unfinalized opPoke", "body": "  ScribeOptimistic generally drops unfinalized optimistic poke data after the update of parameters to avoid any issues connected to an unexpected change of the verification result.  _lift()  is  not  overridden  in  ScribeOptimistic  to  call  _afterAuthedAction()  which  drops  the unfinalized opPokeData. This may allow not yet but soon to be feeds to sign the price update.  CS-CSC-003  Assume Alice is not a member of the current feeds at t   and t   < t   < t  .  2 , Alice signs a price with other bar-1 feeds, and opPoke() it.  1  0  0   At t 0  At t 1  At t  2  , wards add Alice to the feeds.  pokeData becomes valid.  , one comes to challenge the opPokeData, the challenge fails (verification succeeds) and the  In  this  example,  Alice's  signed  data  successfully  passes  the  verification,  though  Alice  has  not  been authorized at t  , the time the price data was aggregated.  0  Risk accepted:  Chronicle states:  Chronicle - Scribe -   14  DesignLowVersion1RiskAcceptedCorrectnessLowVersion1RiskAccepted                \fThis is a valid issue from a theoretical point of view. However, practically we don't see any problems arising through this.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.4   Race of Feeds", "body": "  Given  the  gas  and  runtime  limitation,  bar  shouldn't  be  too  large,  whereas  there  could  be  254 (maxFeeds) feeds at most. In case feeds' amount is larger than bar, feeds may form different subsets and sign with different views of the current price. As the price update frequency is at most once per block (limited by the freshness check of the pokeData.age), there could be a race case among the feeds.  CS-CSC-004  Risk accepted:  Chronicle states:  The bar-to-feed ratio will be set conservatively, i.e. \"far more\" feeds than bar. While the relationship will always be that bar > #feeds/2 to ensure that only a consensus of >50% can advance the oracle to a new price, we want to have more feeds than bar to not risk downtime due to feeds being dropped.  The current configuration is: 22 feeds with a bar of 13.  Chronicle - Scribe -   15  SecurityLowVersion1RiskAccepted          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Update Using Stale PokeData   -Severity Findings   Unreset opPokeData After Unsuccessful Challenge   -Severity Findings  Incorrect Formula in Docs   Indexed Fields of Event Poked   0  1  1  2  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Update Using Stale PokeData", "body": "  In  ScribeOptimistic  an  optimistic  poke  is  considered  finalized  after  the  challenge  period  elapsed.  If  the optimistic  poke  (opPokeData.age)  is  finalized  and  more  recent  than  the  last  stored  poke  data (pokeData.age), the pricefeed returns the optimistic value:  CS-CSC-011  function _currentPokeData() internal view returns (PokeData memory) {     // Load pokeData slots from storage.     PokeData memory pokeData = _pokeData;     PokeData memory opPokeData = _opPokeData;      // Decide whether _opPokeData is finalized.     bool opPokeDataFinalized =         opPokeData.age + opChallengePeriod <= uint32(block.timestamp);      // Decide and return current pokeData.     if (opPokeDataFinalized && opPokeData.age > pokeData.age) {         return opPokeData;     } else {         return pokeData;     } }  Scribe.poke(), the function to update the pricefeeds _pokeData, only checks whether the new value is more recent than the stored data. It does not check whether there is a more recent finalized optimistic poke:  // Revert if pokeData stale.  if (pokeData.age <= _pokeData.age) {  Chronicle - Scribe -   16  CriticalHighCodeCorrectedMediumCodeCorrectedLowSpeci\ufb01cationChangedCodeCorrectedCorrectnessHighVersion1CodeCorrected          \f     revert StaleMessage(pokeData.age, _pokeData.age);  }  This update is then stored with the current block.timestamp as age:  // Store pokeData's val in _pokeData storage and set its age to now. _pokeData.val = pokeData.val; _pokeData.age = uint32(block.timestamp);  Resulting a stale pokeData could be used to update the pricefeed.  This issue arises in the state (_opPokeDate: finalized, _pokeData: set-older or uninitialized)    _poke() has been marked as virtual in Scribe and overridden in ScribeOptimistic, where it checks the stored  _pokeData  and  the  recent  finalized  optimistic  poke  to  determine  the  most  recent  age.  Thus  it prevents a stale pokeData to update the pricefeed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Unreset opPokeData After Unsuccessful", "body": " Challenge  In  ScribeOptimistic,  in  an  unsuccessful  challenge  (successful  signature  verification),  opPokeData  is finalized  and  pushed  to  _pokeData.  _opPokeData  remains  unchanged  however.  This  will  block opPoke() even though the current opPokeData has been finalized until the challenge period is over.  CS-CSC-009  if (ok) {         // Decide whether _opPokeData stale already.         bool opPokeDataStale = opPokeData.age <= _pokeData.age;          // If _opPokeData not stale, finalize it by moving it to the         // _pokeData storage.         if (!opPokeDataStale) {             _pokeData = _opPokeData;         }          emit OpPokeChallengedUnsuccessfully(msg.sender); }    _opPokeData will be deleted in case it is verified successfully and is more fresh than the _pokeData. Thus, this finalized _opPokeData will not block a new opPoke() anymore.  Chronicle - Scribe -   17  DesignMediumVersion1CodeCorrected          \f6.3   Incorrect Formula in Docs  In docs/Schnorr.md, the formula of re-computing challenge in signature verification is incorrect compared to the ones in signing and in code implementation. The order of the last two parameters is wrong.  e = H(Px || Pp || Re || m) mod Q  CS-CSC-012  Specification changed:  The  signature  verification  formula  in  docs/Schnorr.md  has  been  corrected  to  align  with  the  signing formula and the code implementation.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Indexed Fields of Event Poked", "body": "  CS-CSC-008  /// @notice Emitted when oracle was successfully poked. /// @param caller The caller's address. /// @param val The value poked. /// @param age The age of the value poked. event Poked(address indexed caller, uint128 val, uint32 age);  Indexing fields in events allows to easily search for certain events. The val and age of the event above are not indexed. Indexing e.g. the age field would allow off chain observers to easily search for prices in the past.    The val and age of the event have been marked as indexed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Gas Optimizations", "body": "   getSignerIndexLength() could load the length by assembly.  In _verifySchnorrSignature(), lift(), and drop() the counter i inside of the for loop can be increased in an unchecked scope, as it is always bounded.  CS-CSC-010   There  is  no  amount  limitation  of  inputs  for  abi.encodePacked(),  thus  one  invocation  should and  constructPokeMessage()   parameters   pack   the   all   in   suffice  _constructOpPokeMessage().  to   In _verifySchnorrSignature(), loading a public key at an index can be abstracted into another internal function to decrease code duplication.  In _lift(), the require statement index <= maxFeeds can be moved into the if branch, as we only need to check the number of feeds when a new public key is added.  Chronicle - Scribe -   18  CorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrectedInformationalVersion1CodeCorrected                       \f The first condition check (opPokeDataFinalized) can be removed in _opPoke(), as the function  would already revert if it is false.  if (!opPokeDataFinalized) {     revert InChallengePeriod(); }  uint32 age = opPokeDataFinalized && opPokeData.age > _pokeData.age         ? opPokeData.age : _pokeData.age;  In LibSchnorr, the following line can be wrapped in an unchecked scope.  uint s = LibSecp256k1.Q() - mulmod(challenge, pubKey.x, LibSecp256k1.Q());  In addAffinePoint(), some intermediate results can be cached to avoid computing repeatedly. For example:  uint left = mulmod(addmod(z1, h, _P), addmod(z1, h, _P), _P);  uint v = mulmod(x1, mulmod(4, mulmod(h, h, _P), _P), _P);  uint j = mulmod(4, mulmod(h, mulmod(h, h, _P), _P), _P);  In  addition,  the  following  optimizations  only  work  if  the  external  view  functions  are  called  by  a  smart contract.  In feeds(), the for loop counter i can start from 1 as the public key at index 0 is an zero point. And i can be increased in an unchecked scope.  In feeds(uint index), the input index can be checked towards 0 for early revert. And the public key at a specific index is not loaded by assembly as before.    Code has been corrected to adopt some of the optimizations.  Chronicle - Scribe -   19      \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Authed and Tolled May Return Array With", "body": " Duplicates  authed() will return the existing wards addresses as an array. Upon rely() the address is inserted into the mapping and the array. Upon deny() the address is only reset in the mapping and not removed from  the  array.  Consequently,  in  case  an  address  is  added,  then  removed,  and  later  added  back, authed() will return an array that contains a duplicate of this address. The same applies to tolled().  CS-CSC-005  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Timestamp of PokeData Aggregation Equal to", "body": " Block.Timestamp  Scribe._poke()  rejects  PokeData  with  timestamps  in  the  future  but  accepts  PokeData  with block.timestamp.  CS-CSC-006  // Revert if pokeData from the future. if (pokeData.age > uint32(block.timestamp)) {     revert FutureMessage(pokeData.age, uint32(block.timestamp)); }  It's a theoretical observation only with no impact in practice, but aggregating the price data and updating the  data  on  chain  seems  infeasible.  In  practice  when  _poke()  is  executed  it  should  hold block.timestamp > pokeData.age or the aggregation of the price data off chain likely happened for a timestamp (slightly) in the future.  Acknowledged:  Chronicle has acknowledged this theoretical observation with no impact in practice.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Undropped schnorrData Commitment and", "body": " opFeedIndex  CS-CSC-007  Chronicle - Scribe -   20  InformationalVersion1InformationalVersion1AcknowledgedInformationalVersion1Acknowledged              \f_schnorrDataCommitment stores the schnorr data digest of an optimistically poked data, ensuring it will  be  challenged  by  the  same  schnorr  signature  later.  opFeedIndex  stores  the  feed  who  signs  to endorse  the  opPokeData  and  the  schnorr  signature.  Upon  a  successful  challenge,  these  variables  are not deleted consistently with the _opPokeData. However, as opPokeDataFinalized is computed by the following statement and opChallengePeriod is at most max(uint16), it would always be true after _opPokeData  is  deleted.  Consequently  double  challenging  an  already  dropped  _opPokeData  is  not possible.  bool opPokeDataFinalized =         opPokeData.age + opChallengePeriod <= uint32(block.timestamp);  Acknowledged:  Chronicle states:  You  are  correct  in  that  we  could  drop  the  schnorrDataCommitment  and  opFeed  Index.  However, doing  so  will  increase  the  costs  of  the  subsequent  opPoke  as  writing  to  zero-storage  is  more expensive than overwriting non-zero storage. Note furthermore, that the gas-stipend for emptying the storage is attributed to the opChallenge caller, i.e. a searcher.  Therefore, cleaning the storage would practically give external entities a gas stipend that relays have to pay during the next opPoke().  Chronicle - Scribe -   21  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Considerations of pokeData.age", "body": "  pokeData.age is interpreted differently at different stages.   User submitted pokeData.age: it refers to the time it is generated offchain for freshness check and  signature verification.   Onchain stored pokeData.age: it refers to the time the offchain generated data is poked or opPoked  onchain.  In ScribeOptimistic, there could be a potential delay to read the most recent valid opPokeData.age, as it only takes effect after being finalized.  In addition, systems integrate the ScribeOptimistic should aware that an old pokeData could be carried over to the current time (by updating the age to current block.timestamp) in following cases:   A  successful  challenge  (a  failed  verification)  will  drop  the  current  opPokeData  and  advance  the  existing _pokeData.age to current block.timestamp.   An  update  of  the  oracle  parameters  (setBar(),  setOpChallengePeriod(),  drop())  by  the  wards will always advance the valid most fresh pokeData.age to current block.timestamp.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Decimals of Price Feed", "body": "  Scribe oracles use 18 decimals for price values. Besides implementing own interfaces to read the price, the  Chainlink  interface  is  implemented  to  serve  potential  customer  already  integrating  with  Chainlink. Note  that  Chainlink  usually  uses  18  decimals  for  ETH  denominated  assets  but  8  decimals  for  USD denominated assets. Hence projects need to be careful especially when switching from Chainlink USD based pricefeeds to Scribe.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.3   Implications Regarding the Value of Bar", "body": "  setBar()  incorporates  a  check  to  restrict  the  bar  value  from  being  set  to  zero.  However,  the  upper boundary is only limited by the uint8 datatype, which is 255.   The  system  can  accommodate  a  maximum  of  254  feeds  (assuming  no  feed  is  ever  removed).  Therefore, if the bar is set to 255, the processing of any poke becomes unfeasible.   Once the bar value crosses a certain threshold, verifying the aggregated signature may surpass the  block gas limit, thereby rendering on-chain verification impossible.   Dropping  feeds  (e.g.  directly  or  in  ScribeOptimistic  after  a  successful  challenge)  may  result  in  the  number of feeds remaining being insufficient to cover bar.  The privileged role is expected to set the value for bar correctly.  Chronicle - Scribe -   22  NoteVersion1NoteVersion1NoteVersion1          \f8.4   Max 254 Feeds Over the Contracts Lifetime  By design, a Scribe Pricefeed can have a maximum of 254 feeds added: Adding a new pricefeed pushes the public key into the _pubKeys array. Removing a price feed resets the pricefeeds public key entry to the  zero  point,  however  this  does  not  free  up  the  space.  Feeds  IDs  are  hence  never  reused  but  the tradeoff is the maximum number of possible feeds that can be added.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.5   Penalty to Rogue Feeds", "body": "  If  a  feed  endorses  an  invalid  schnorrData  /  pokeData  combination  in  ScribeOptimistic,  the  feed  will  be dropped when challenged. In addition to dropping the feed, there is no more penalty to the feeds on the contract level.  Chronicle states:  Any kind of penalty regarding misbehaving feeds will be handled on the social layer.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.6   Price Change", "body": "  Systems  that  integrate  with  Scribe  or  ScribeOptimistic  should  be  aware  of  the  possible  ways  that  can change the price (pokeData.val).  Below we list occasions where the price can change immediately as well as some potential ways how this could be leveraged (i.e. bundled):   Authenticated (in Scribe and ScribeOptimistic): _poke() invoked with a valid new pokeData and  schnorr signature from feeds. The current price will advance to a new price.   Wards  (only  in  ScribeOptimistic):  _afterAuthedAction()  invoked  by  the  wards  which  drops  a previously  finalized  opPokeData  according  to  the  new  challenge  period.  In  case  this  dropped opPokeData is the freshest one, the current price will rollback to the _pokeData.   Permissionless  (only   in  ScribeOptimistic):  onChallenge()  which   fresh opPokeData  and  pushes  it  to  _pokeData.  The  current  price  will  advance  to  the  new  price (opPokeData). Similarly, after an optimistic poke, anyone could execute poke() using this signed data to advance the price immediately.  finalizes  a  valid   When  integrating  with  ScribeOptimistic  projects  must  be  aware  that  an  optimistic  price  update  is generally but not always subject to the challenge period delay: anyone may finalize it at any point during the challenge period.  Chronicle - Scribe -   23  NoteVersion1NoteVersion1NoteVersion1            \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Expired Domains Look Valid for the", "body": " Subdomains  The  desired  invariant  that  fuses  can  be  inspected  individually  and  care  only  needs  to  be  taken  when domains expire, can be broken. This is because an expired domain can be rewrapped with new fuses and  wrapped  subdomains  are  not  aware  of  the  expiry  of  higher-level  domains.  Please  consider  the following scenario:  1. User U controls example.eth, wraps it and burns the CANNOT_REPLACE_SUBDOMAIN fuse.  2. The domain expires and user V takes control of it and makes sure it will not expire any time soon.  3. User V assigns control to W over sub.example.org.  4. User W wraps sub.example.org:  1. W also decides to burn the CANNOT_UNWRAP fuse.  2. During   the  execution   the  parent  node   (example.eth)   is  checked  where   the  CANNOT_REPLACE_SUBDOMAIN fuse has been burnt.  3. Hence, the wrapping succeeds.  5. Now  third  parties  check  the  wrapped  state  of  sub.example.org:  According  to  the  invariant  it cannot be unwrapped as it will not expire any time soon and as the CANNOT_UNWRAP fuse has been burnt.  6. User  V  can  freely  reassign  sub.example.org  (independently  of  the  NameWrapper).  Hence,  the permission  system  has  been  bypassed  as  a  non-wrapped  and  a  wrapped  version  exists  for sub.example.org.  ENS - NameWrapper -   10  CriticalHighMediumCodeCorrectedSpeci\ufb01cationChangedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCorrectnessMediumVersion1CodeCorrected         \fHence,  fuses  are  indifferent  to  the  expiry  of  domains  and  they  enforce  the  corresponding  permissions only for never-expired domains.    The code was rewritten so that it checks the hierarchy of a name for safety.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Old State From Expired Domains Can Block", "body": " Legitimate Actions  In case a domain is wrapped, then expires and is later controlled by another user and wrapped again, the following problem can arise, which blocks the new legitimate owner from performing an action they would have been allowed to.  Please consider the following sequence:  1. User U controls example.eth and wraps it.  2. User U creates a subnode sub.example.org and sets themselves as owner.  3. The domain expires and user V takes control of it.  4. User V wraps example.eth again and burns the CANNOT_REPLACE_SUBDOMAIN fuse.  5. Now, user V tries to create sub.example.org:  1. The function canCallSetSubnodeOwner is evaluated, it should return true as V has the  permission to create new subdomains.  2. The owner of sub.example.org is queried and it returns U.  3. As the owner is non-zero, the CANNOT_REPLACE_SUBDOMAIN fuse is checked.  4. Finally,  canCallSetSubnodeOwner  returns  false  and  hence  the  legitimate  creation  of  the subnode fails.  Specification corrected:  The specification has been made more explicit so that it covers the case above.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Variable node Assigned but Never Used in", "body": " wrapETH2LD  the   In  _makeNode(ETH_NODE, labelhash). However, this value is never used.  wrapETH2LD   functions,   node   new   the   is   calculated   using    The redundant variable was removed.  ENS - NameWrapper -   11  CorrectnessMediumVersion1Speci\ufb01cationChangedDesignLowVersion2CodeCorrected                \f6.4   Incorrect Specification for Unwrapping Functions  The README says about unwrapping:  Wrapped  names  can  be  unwrapped  by  calling  either  unwrapETH2LD(label,  newRegistrant, newController)  or  unwrap(parentNode,  label,  newController)  as  appropriate.  label  and  parentNode have meanings as described under \"Wrapping a name\"  Furthermore, the docstring says:   @param label label as a string of the .eth domain to wrap e.g. vitalik.xyz would be 'vitalik'  However, the implementation works differently. Instead of passing a label, a labelhash should be passed to the unwrapping functions, as seen for unwrapETH2LD below:  function unwrapETH2LD(     bytes32 label,     address newRegistrant,     address newController ) public override onlyTokenOwner(_makeNode(ETH_NODE, label)) {     _unwrap(_makeNode(ETH_NODE, label), newController);  Specification changed:  The documentation has been updated.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Repetitive Code", "body": "  There are multiple instances of repetitive code that could be avoided. These instances include:   Within the function wrapETH2LD, two calls are made to registrar.ownerOf(tokenId).   Within  the  functions  unwrapETH2LD,  unwrap,  and  burnFuses,  two  calls  are  made  to  _makeNode(parentNode, labelhash).   Within the function burnFuses, getData is called multiple times in different spots.  The cost impact of these repetitions has been lowered by the recently introduced EIP-2929, however gas optimizations remain possible.    The  superfluous  call  to  registrar.ownerOf(tokenId)  has  been  removed  as  well  as  the  duplicate calle to getData in burnFuses.  ENS - NameWrapper -   12  CorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                  \f6.6   Specification Unclear for setSubnode* Functions  The docstring for the setSubnodeRecord function says:   @notice Sets records for the subdomain in the ENS Registry   @param node namehash of the name  However, the node parameter should contain the namehash for the parent node. This is not entirely clear from the description. Especially, in comparison with the setSubnodeRecordAndWrap function, where the docstring says:   @notice Sets the subdomain owner in the registry with records and then wraps the subdomain   @param parentNode parent namehash of the subdomain  A consistent naming of node versus parentNode for these very similar functions would be beneficial to avoid  confusion.  This  also  extends  to  the  setSubnodeOwner  and  setSubnodeOwnerAndWrap functions. Furthermore, the label parameter is missing from the setSubnodeRecord description.    The parameter names were changed to reflect their status.  ENS - NameWrapper -   13  CorrectnessLowVersion1CodeCorrected      \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Dirty Bits in Return Value of getData", "body": "  The  getData  function  is  one  of  the  most  important  functions  of  the  NameWrapper  as  it  retrieves information about the different nodes.  function getData(uint256 tokenId)     public     view     returns (address owner, uint96 fuses) {     uint256 t = _tokens[tokenId];     owner = address(uint160(t));     fuses = uint96(t >> 160); }  Functions calling getData need to be aware that the owner return value will contain \"dirty bits\". This is dangerous  if  assembly  is  being  used,  because  assembly  will  access  the  raw  data.  Writing  normal solidity code should be fine.  Hence, we recommend to avoid assembly in connection with getData. We have attached an example file for this behaviour.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Note to Integrators: onERC1155Received", "body": " Hook  This  note  is  meant  for  any  developers  wanting  to  build  upon  the  NameWrapper.  Similarly  to  ERC223, ERC721, ERC777, and others the implementation of ERC1155 invokes the onERC1155Received hook at the end of safeTransferFrom. Developers building services which interact with the NameWrapper should  be  aware  of  that  and  implement  the  hook,  as  these  hooks  have  historically  led  to  reentrancy attacks.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Restrictions on Custom Permissions", "body": "  The README documents that additional fuses might be designated to additional permissions. While this generally can be implemented with the current contract, not all types of permissions will be feasible this way.  Any permissions, requiring checks \"up the chain\" of custody would not work without modifications to the contract  or  without  breaking  the  invariant  that  fuses  can  be  inspected  individually.  As  a  somewhat  ENS - NameWrapper -   14  NoteVersion1NoteVersion1NoteVersion1          \fcontrived example, a permission enforcing that TTL values of subnodes must be strictly larger than TTL values of parent nodes, currently could not be enforced.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   The Transitive Permission Structure", "body": "  Users  should  be  aware  of  the  transitive  permission  structure  of  the  system.  This  permission  structure involves the NameWrapper, Registry and Registrar. Given a typical user setup, setting an operator O using NameWrapper.setApprovalForAll does not only pass control over all wrapped domains but O also controls all non-wrapped domains. Furthermore, domains that are acquired in the future, can be controlled by O.  In  short  becoming  an  operator  for  a  particular  account  on  the  NameWrapper  is  more  powerful  than becoming  an  operator  for  the  same  account  on  the  Registrar  or  the  Registry.  Hence,  operator permissions should be given out with great care.  ENS - NameWrapper -   15  NoteVersion1    \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Staking Does Not Prevent Misbehavior", "body": "  Resolvers have to join a whitelist which is governed by the staking of 1inch tokens.  The documentation states:  The stake determines a resolver\u2019s ability to get orders and ensures that a resolver follow the protocol rules (like in proof of stake model).  On the smart contract level the implementation of the staking does not allow to seize stake of bad actors. Their stake is not at risk and can simply be withdrawn at the end of the lock period hence this staking does not ensure that a resolver follows the protocol rules.  Risk accepted:  1inch states:  They'll need only follow what is required to be able to settle the order batch. Staking is only used as a threshold entry requirement.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Missing Events", "body": "  Events  are  used  to  be  informed  of  or  to  keep  track  of  transactions  changing  the  state  of  a  contract. Generally, any important state change should emit an event.  1inch - Limit Order Settlement -   15  SecurityDesignCriticalHighMediumRiskAcceptedLowAcknowledgedDesignMediumVersion1RiskAcceptedDesignLowVersion1Acknowledged                  \fThe functions used for deposits and withdrawals in FeeBank do not emit an event, hence it's hard for an observer to track deposits and withdrawals  Acknowledged:  1inch acknowledged the issue and decided to leave the code as it is.  1inch - Limit Order Settlement -   16    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   St1inch Can Be Locked Indefinitely   -Severity Findings   Resolver Can Set Arbitrary Callback   0  0  1  1  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   St1inch Can Be Locked Indefinitely", "body": "  It is possible for an attacker to lock the staked amount of 1inch token of any staker by using one of the St1inch.depositFor  functions  for  the  target  address.  By  depositing  a  small  amount  of  tokens  and specifying the duration, one can force a target staker to see its stake locked for more time, preventing the staker to withdraw. The only way to break that attack would be to activate the emergency exit to allow the target staker to withdraw.    The functions St1inch.depositFor and St1inch.depositForWithPermit have been updated so the duration cannot be specified and is hardcoded to be 0. This will only increase the deposited amount and not the timelock duration.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Resolver Can Set Arbitrary Callback", "body": "  can   Resolvers  in Settlement._settleOrder()  and  execute  arbitrary  code  which  may  severely  interfere  with  the process.  (interactionTarget   address)   callback   address   called   the   set     The Settlement contract now ensures that the address is the settlement contract itself:  let target := shr(96, calldataload(add(data.offset, interactionOffset))) if iszero(eq(target, address())) {     mstore(0, errorSelector)  1inch - Limit Order Settlement -   17  CriticalHighMediumCodeCorrectedLowCodeCorrectedSecurityMediumVersion1CodeCorrectedSecurityLowVersion1CodeCorrected                \f    revert(0, 4) }  1inch - Limit Order Settlement -   18  \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Competing Resolvers May Result in Failing", "body": " Transactions  Since resolvers are competing against each other, it may happen that more than one resolver submits the same order in their respective batch, in the same block. In such cases, only the first batch including the order will not revert and all the other resolvers will suffer from pure loss of gas.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Gas Optimization", "body": "  Some operations can be in an unchecked block to save gas, examples are:   update of i and addition in FeeBank.gatherFees()   addition in FeeBank._depositFor()   addition in FeeBankCharger.increaseAvailableCredit()   for loop in WhitelistRegistry.register()   WhitelistRegistry._shrinkPoorest()  Intermediary memory variable can save storage reads. Example is:   St1inch._deposit()  does  two  SLOAD  for  deposits[account],  storing  the  updated  deposit  amount in memory will save gas.  Code partially corrected:  The function St1inch._deposit() has been updated to do only one SLOAD for the depositor.  Other gas optimizations have been addressed in future commits.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Preview Functions Accept Invalid Durations", "body": "  functions  (previewBalance,  previewPowerOf,previewPowerOfAtTime)  may The  preview  accept  a  duration  parameter  that  may  exceed  the  maximum  locking  period  and  make  the  transaction revert if applied in the St1inch contract.  1inch - Limit Order Settlement -   19  InformationalVersion1InformationalVersion1InformationalVersion1          \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Allowed Sender of Orders", "body": "  Makers wishing to benefit from the protections of the limit settlement protocol must ensure the order they sign has the settlement contract set as allowed sender.  Technically  the  settlement  contract  allows  resolvers  to  batch  any  orders  which  gives  them  greater freedom  to  aggregate  transactions.  While  execution  of  orders  without  the  allowed  sender  restricted works,  such  orders  can  also  be  executed  through  the  limit  order  protocol  directly  and  hence  lack  the protection limit settlement order offers.  It's vital to understand that this field has to be set correctly or that the protections offered by limit order settlement don't apply. Although this might be obvious there should be documentation emphasizing this. Even the tests within the limit-settlement-order repository use public orders (since allowed sender is not set and hence anyone, not just the settlement contract, can call limitOrderProtocol.fillOrder() for this order).  This is an easy source of errors, hence it`s important to be explicit and not assume users/integrators will understand and do this correctly.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   User Responsibility for Setting Trusted", "body": " Resolvers  Nothing  enforces  the WhitelistRegistry.  It  is  the  user's  responsibility  to  ensure  that  the  resolvers  addresses  they  sign over are trusted.  to  be  actually  part  of   in  Order.interaction   the  resolvers   listed   1inch stated:  That\u2019s also the responsibility of the frontend to provide correct whitelists to the user. And also responsibility of the backend to filter out maliciously created orders without the proper whitelist.  1inch - Limit Order Settlement -   20  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Pool and Configurator May Not Match", "body": "  Nothing  enforces  the  pool  address  to  be  the  one  set  in  the  configurator.  If  the  pool  address  and  the poolConfigurator  pool  were  to  differ,  the  SparkLendFreezerMom  contract  may  not  work  as expected.  CS-SPRKFRZR-001  Acknowledged:  Client states:  Acknowledged, no change. Will ensure configuration is correct with adequate end to end testing.  MakerDAO - SparkLend Freezer -   10  DesignCriticalHighMediumLowAcknowledgedDesignLowVersion1Acknowledged         \f6   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Events Emission Inconsistency", "body": "  In  the  functions  rely  and  deny,  the  event  is  emitted  after  the  storage  update,  but  in  the  functions setAuthority and setOwner the event is emitted before. A consistent codebase is easier to maintain and understand.  CS-SPRKFRZR-002  Risk accepted:  Client states:  Acknowledged, no change. This pattern was done on purpose to efficiently emit the previous and new values of the setters for setAuthority and setOwner before the value is updated in storage.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Gas Optimizations", "body": "  CS-SPRKFRZR-003  1. In   the   and SparkLendFreezerMom.pauseAllMarkets, the length of reserves can be cached before the loop to save gas.  SparkLendFreezerMom.freezeAllMarkets   functions   2. The  incrementation  of  the  index  in  the  function  SparkLendFreezerMom.freezeAllMarkets  and SparkLendFreezerMom.pauseAllMarkets can be unchecked.  Acknowledged:  Client chose to not implement gas optimizations.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Unused Code", "body": "  1. The function SparkLendFreezerMom.isAuthorized has a branch src == address(this)  that cannot be reached.  CS-SPRKFRZR-004  MakerDAO - SparkLend Freezer -   11  InformationalVersion1RiskAcceptedInformationalVersion1AcknowledgedInformationalVersion1Acknowledged                \fAcknowledged:  Client  acknowledged  the  code  is  unused,  isAuthorized()  is  a  common  function  present  in  multiple contracts and intentionally not modified.  MakerDAO - SparkLend Freezer -   12  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Locked Assets After Repay", "body": "  A manager could try to repay an amount bigger than what they owe to Aave. In such cases, the leftover amount will not be transferred back to the vault. Consider the following case:  1. A manager owes 100 DAI  2. The manager tries to repay 110 DAI  3. 110 DAI will be transferred from the vault to the external position  4. The  call  to  Aave  will  only  consume  100  DAI.  The  remaining  amount  will  remain  in  the  external  position    After the debt owed to Aave is repaid, the remaining balance of the repayment token is sent back to the vault proxy. Since the repayment token is an underlying and not an aToken, the transfer will not affect the health factor of the positions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Rebasing aToken Balance", "body": "  ATokens are rebasing tokens. This means that the balance an account holds changes in time and, thus, between the time a transaction is submitted and mined. In the current implementation, there is no way to remove  the  full  amount  of  the  collateral  by  querying  the  balance  the  external  position  holds  during  the execution of the transaction. This could result in dust remaining in the external position.  Avantgarde Finance - Extensions III -   11  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedDesignMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f  By specifying the maximum integer as the amount, the full aToken balance will be withdrawn:  uint256 collateralBalance = ERC20(aTokens[i]).balanceOf(address(this));  if (amounts[i] == type(uint256).max) {     amounts[i] = collateralBalance; }  // If the full collateral of an asset is removed, it can be removed from collateral assets if (amounts[i] == collateralBalance) {     collateralAssets.removeStorageItem(aTokens[i]);     emit CollateralAssetRemoved(aTokens[i]); }  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Redundant Call", "body": "  __addCollateralAsset  call  the  lending  pool  function  setUseReserveAsCollateral  which enables  an  asset  to  be  used  as  a  collateral.  However,  the  implementation  of  regular  transfers  will automatically  use  the  underlying  of  the  transferred  aToken  as  collateral  if  a  zero-balance  is  increased (see AToken code and lending pool\u2019s finalizeTransfer). Hence, the call may be redundant.    The call has been removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Sanity Check Missing", "body": "  compatible  with   An added collateral token is never sanitized. Assume a malicious manager to create an evil token which a  method is  UNDERLYING_ASSET_ADDRESS()  which  returns  a  token  used  by  Aave.  Since  this  token  is  never sanitized, it could be added as collateral since the call  the  AToken,   interface   exposes   the   i.e.   of   it   (lendingPoolAddress).setUserUseReserveAsCollateral(AaveAToken(aTokens[i]).UNDERLYING_ASSET_ADDRESS(), true);  will  succeed.  Adding  such  a  token,  however,  could  block  the  function  ControllerLib.calcGaV() which calculates the external position value. During the calculation, the managed assets are queried with getManagedAssets in order to be priced but no price feed for the evil token exists.    The AaveDebtPositionParser will now validate that the token added as collateral is a whitelisted token. Ultimately supported non-aTokens could be deposited. However, that does not block execution nor could it lock tokens.  Avantgarde Finance - Extensions III -   12  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Aave Paused", "body": "  The  lending  pool  of  Aave  could  be  paused  and,  hence,  actions  on  the  vault  will  not  be  possible  to execute. Ultimately, positions could be not modifiable, and funds could be stuck.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Sandwiching Transactions for Liquidation", "body": "  It is known that the behavior of the managers is monitored. However, we would like to point out that there are sequences of actions from which the manager can benefit. In particular, a malicious fund manager, who  sees  a  price  drop  in  the  Aave  oracle  of  a  collateral  asset,  could  create  a  malicious  sequence  of transactions  through  MEV  capabilities  to  borrow  with  user  funds  while  liquidating  the  position immediately. Consider the following sequence of transactions:  1. Move aDai to the Aave external position proxy and borrow WETH such that the health factor is 1.  2. The sandwiched oracle price changes: Dai price drops compared to WETH.  3. The fund manager liquidates the position and profits.  Avantgarde Finance - Extensions III -   13  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Locked Refunded Provision", "body": "  When  a  maker  submits  an  order  to  the  Mangrove  orderbook,  they  need  to  provide  some  ETH,  also known as the provision, to compensate the takers in case the makerExecute hook reverts. A maker can update their offer by calling Forwarder.updateOffer. Note that at this point a maker can update most of the parameters of the order including gasreq, i.e. the gas required for the makerExecute hook to execute. A maker could reduce the gas requirements meaning that some provision will be refunded to them. Forwarder.updateOffer does not handle this refunding (the ownerData.weiBalance is not updated) and Mangrove system only sees MangroveOrder as a maker. This means that the refunded amount is essentially lost for the end-user of the MangroveOrder. Note that if the provision needs to be increased again, the end-user must provide extra ETH.  Code Corrected:  In the current implementation, the provision can only be increased therefore no funds are locked.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Wrong Calculation of Locked Provision", "body": "  Giry SAS - MangroveOrder -   11  CriticalHighCodeCorrectedCodeCorrectedMediumCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrectedCorrectnessHighVersion1CodeCorrected                 \fWhen a user updates their offer through Forwarder.updateOffer, MangroveOrder tries to calculate the new gas price by calling deriveGasprice. The gas price depends on the total provision available for  this  order.  That  is  the  sum  of  the  extra  provision  attached  which  is  stored  in  args.fund  and  the already locked provision. Currently, the locked amount is calculated with the following snippet:  vars.offerDetail.gasprice() * 10 ** 9 * args.gasreq + vars.local.offer_gasbase()  This formula is wrong for two reasons:  1. It depends on args.gasreq which is the updated gas requirement of the order as passed by  the user.  2. There are parentheses missing around args.gasreq + vars.local.offer_gasbase(),  as this entire term should be multiplied by the gas price.  This miscalculation can have multiple consequences:  1. Can allow users to steal funds (see relevant issue).  2. An  order  can  be  submitted  with  smaller  gasprice  since  the  calculated  total  provision  is  too  small.  Code Corrected:  Forwarder.updateOffer has been updated. Currently, users can only increase the provision for an order.  Users  cannot  determine  args.gasreq  as  it  is  set  to  be  equal  to  the  offerGasreq().  It  is important  to  notice  that  offerGasreq()  is  not  constant  but  depends  on  the  configuration  of  the MangroveOrder and in particular the gas requirements of the router.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Expiration Date Cannot Be Updated", "body": "  A  user  can  update  most  of  the  offer  details  by  calling  Forwarder.updateOffer.  However,  the expiration date cannot be changed. In order to change the expiration date of an order, one must retract it and submit a new one.  Code Corrected:  MangroveOrder.setExpiry has been added to allow users to update the expiration date of the order.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Underflow in postRestingOrder", "body": "  Once the market order part of GTC order has been filled as much as possible, the remaining amount the user  wants  to  trade  is  put  into  a  resting  order.  Note  that  if  fillWants  ==  true,  then  the  Mangrove engine will have stopped matching the order either when it is fully filled, there are no more orders on the books, or when the total average price of the order would fall below the threshold of the ratio between the order's initial wants and gives. Hence, if the matching stops before the order's wants are fully filled, we are  guaranteed  not  to  have  given  away  more  than  the  order  initially  had  (else  the  total  average  price would be below what we initially wanted).  Giry SAS - MangroveOrder -   12  DesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1Speci\ufb01cationChanged                \fHowever,  if  fillWants  ==  false,  this  condition  no  longer  holds.  The  order  can  receive  arbitrarily many tokens before giving away all the tokens it has to give away. As the price of a trade is defined by the  maker,  there  could  be  orders  on  the  books  which  give  away  arbitrarily  many  tokens  for  a  very  low price.  Hence,  the  user  can  receive  more  tokens  in  the  market  order  part  of  the  trade  than  they  were expecting to. As such, res.takerGot + res.fee can exceed tko.takerWants despite only having partially filled the order.  When we go to post a resting order, the following code is executed:  res.offerId = _newOffer(   OfferArgs({     outbound_tkn: outbound_tkn,     inbound_tkn: inbound_tkn,     wants: tko.makerWants - (res.takerGot + res.fee), // tko.makerWants is before slippage     gives: tko.makerGives - res.takerGave,     gasreq: offerGasreq() + additionalGasreq, // using default gasreq of the strat + potential admin defined increase     gasprice: 0, // ignored     pivotId: tko.pivotId,     fund: fund,     noRevert: true, // returns 0 when MGV reverts     owner: msg.sender   }) );  When  the  wants  for  the  resting  order  are  calculated,  an  underflow  can  occur  in  the  case  described above, as the market order part of the GTC order could have received arbitrarily many tokens. As Solidity ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "0.8.10  is  used,  this  will  simply  revert  the  transaction,  but  will  unnecessarily  prevent  the  user  from", "body": " completing their trade.  Specification Changed:  Currently,  the  order  is  posted  with  the  same  price  as  the  taker  originally  wanted.  Thus,  the  issue  has been mitigated.  Giry SAS replied:  this  problem  made  use  reevaluate  our  specification:  requiring  the  (instant)  market  order  and  the (asynchronous) maker order to respect a limit average price is not well defined. In some cases this would lead the maker order to be posted for a 0 price. We decided to change the specification and post the maker order at the price initially set by the taker for the market order (irrespectively of the obtained price).  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Users Can Steal Funds From MangroveOrder", "body": "  The core Mangrove system maintains the balanceOf mapping which stores how much ETH is available for each maker to be used as a provision for their orders. Importantly, the MangroveOrder contract is seen  as  one  single  maker  by  the  system,  even  though  there  might  be  many  end  users  creating  their orders through it. Let us assume that at some point the balance of MangroveOrder is positive and an attacker has already submitted an order. It is possible as we show in another issue that there might be some non-claimable balance since updateOrder does not handle refunds. An attacker can steal money from mangrove by employing any of the following two vectors:  1. Updating an order without sending funds:   The attacker calls Forwarder.updateOrder for their order with msg.value == 0 and  they increase the gas requirement of their order.   This means that args.fund == 0 so gas price will remain the same, however, the total  provision needed has been increased as the gas requirements have been increased!   At this point MGV.updateOffer is called with msg.value == 0.  Giry SAS - MangroveOrder -   13  SecurityMediumVersion1CodeCorrected        \f Mangrove core does not perform any check if there are enough funds attached to the call  since it relies on the balanceOf mapping by calling debitWei.   Mangrove core uses the amount stored in balanceOf for the extra provision.   The  attacker  now  retracts  the  order  and  withdraws  the  provision  of  the  order  which  includes the stolen amount.  2. Updating an order by attaching funds:   The attacker calls Forwarder.updateOrder for their order with msg.value != 0 and  they increase the gas requirement of their order.   Since funds have been attached to the transaction, the gas price will be recalculated.   The  new  provision  at  this  point  is  calculated  wrongly  since  the  provision  parameter passed  to  derivePrice  depends  on  args.gasreq  which  represents  the  updated  gas requirements  of  that args.gasreq can be freely set by the users so arbitrarily large value could be passed. As a result, the new gas price is greater than it should be but the extra funds passed are not enough to cover for the extra provision needed by the offer.  the  offer  and  not  vars.offerDetail.gasreq().  Note    Mangrove core uses the amount stored in balanceOf for the extra provision.   The  attacker  now  retracts  the  order  and  withdraws  the  provision  of  the  order  which  includes the stolen amount.  A  similar  attack  can  be  performed  when  some  of  the  global  parameters  change,  which  could  result  in inaccurate accounting of provisions. If the gasbase of the token pair related to an order changes in the core  mangrove  system,  calling  updateOffer  can  result  in  an  increased  (or  decreased)  provision without  providing  any  additional  funds.  This  will  credit  (or  debit)  funds  to  the  MangroveOrder  contract which  aren't  attributed  to  any  user.  In  particular,  if  the  global  gas  price  is  increased,  calling updateOffer  of  Mangrove  core  with  an  unchanged  gasprice  which  is  lower  than  the  new  global  gas price,  the  mangrove  core  system  will  set  the  gas  price  higher  without  receiving  any  funds.  This  again changes the balance of the MangroveOrder contract, without attributing it to any individual user. While _newOffer and _updateOffer in Forwarder have checks to make sure the offer's gas price is higher than the global gas price, __posthookSuccess__ in MangroveOffer does not. Hence, if the global gas price changes, then an order is partially filled and attempts to repost, its provision will be increased with no additional submitted funds. While the amounts of funds are small, it is conceivable that a malicious user could be able to exploit a change in the global gas price or the gasbase in order to steal funds.  It  is  important  to  note  that  this  issue  cannot  result  in  users  losing  funds  since  the  excessive  provision which can be stolen cannot be claimed by any specific user. In the normal case, no excessive provision should  be  available.  Therefore,  it  is  expected  the  amount  that  can  be  stolen  to  be  low.  Hence,  we consider the issue as medium severity.  Code partially corrected:  The issue has been addressed in multiple different ways:  1. In the current implementation there shouldn't be unallocated users' funds in Mangrove core.  2. Users can only increase the provision of an order using MangroveOrder.updateOrder, not decrease  it.  Hence,  they  must  provide  additional  provision  and  can  not  submit  orders  which could make use of funds that are already stored in the Mangrove core.  3. The __posthookSuccess__ uses Forwarder._updateOffer.  Giry SAS - MangroveOrder -   14    \f6.6   Inaccurate Comment  In MangroveOrder.checkCompleteness, the following is mentioned:  // when fillWants is true, the market order stops when takerWants units of outbound_tkn have been obtained;  However, this comment is inaccurate since part of the takerWants goes to cover the fees, so not the full takerWants amount can be obtained.  In AbstractRouter.push, the return value is described as follows:  ///@return pushed fraction of amount that was successfully pushed to reserve.  However,  for  tokens  with  fees,  provided  the  TransferLib  is  used,  the  whole  amount  will  always  be reported.  Code Corrected:  The comments have been updated.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Missing Natspec", "body": "  The Natspec is missing in the following cases:   For AbstractRouter.bind, the maker parameter.   For AbstractRouter.unbind, the maker parameter.   For SimpleRouter.__pull__, the strict parameter.   For IOfferLogic.OfferArgs, the gasprice field.  Code Corrected:  The Natspec has been added to the respective functions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Redundant pragma abicoder v2", "body": "  Many contracts include the pragma abicoder v2 directive. However, for solidity 0.8 the abicode v2 is the default one, so the pragma is redundant.  Code Corrected:  The pragma has been removed from most of the contracts.  Giry SAS - MangroveOrder -   15  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f6.9   Setting Expiration Date  A user can define the time-to-live of a resting order submitted through MangroveOrder by specifying the TakeOrder.timeToLiveForRestingOrder.  It  is  important  to  note  that  an  order  can  remain  in  the mempool  for  a  long  time  before  it's  executed.  Specifying  an  explicit  expiration  date  instead  of  the time-to-live might be more convenient for users since it's independent of the time it takes for a transaction to be included in a block.  Code Corrected:  The  expiration  date  is  now  absolute  and  no  longer  relative  to  the  time  the  transaction  is  added  to  the blockchain.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.10   Forwarder.provisionOf Calculation Is", "body": " Wrong  As its natspec suggests Forwarder.provisionOf computes the amount of native tokens that can be redeemed  when  In MgvOfferMaking.retractOffer, the provision is calculated as follows:  offer.  However,   deprovisioning   given   true.   this   not   is   a   provision = 10 ** 9 * offerDetail.gasprice() //gasprice is 0 if offer was deprovisioned   * (offerDetail.gasreq() + offerDetail.offer_gasbase());  The important part to notice is that provision depends on offerDetail.offer_gasbase().  This is not the same for Forwarder.provisionOf where the provision is calculated as follows:  provision = offerDetail.gasprice() * 10 ** 9 * (local.offer_gasbase() + offerDetail.gasreq());  Here,  offerDetail.offer_gasbase().  provision   the   depends   on   local.offer_gasbase()   instead   of  Code Corrected:  The provision is now calculated using the offerDetail.offer_gasbase().  Giry SAS - MangroveOrder -   16  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected              \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Updating Approvals on Order Update", "body": "  A  user  can  update  their  orders  by  using  Forwarder.updateOffer.  It  is  important  for  users  to remember  that,  in  case  the  makerExecute  hook  to  their  order  fails,  they  will  have  to  reimburse  the taker. A reason for an order to fail is that there is not enough allowance given to the router to transfer funds from the maker's reserve to MangroveOrder contract. This is highly likely to happen after a user updates their offer by having it give more funds to the taker.  Giry SAS - MangroveOrder -   17  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Gas Optimizations", "body": "  1. In the _mint function, the update of totalSupply can be done in the unchecked block to save gas.  The  total  supply  of  shares  is  bound  to  be  <=  total  supply  of  DAI,  which  is  bound  to type(uin256).max.  2. The internal function _rpow always take RAY as base, replacing base by RAY in the code will save  a bit of gas at runtime.  ISSUEIDPREFIX-001    1. The update of totalSupply has been moved in the unchecked block.  2. The base parameter of the function _rpow has been removed, and replaced by RAY everywhere.  Oazo Apps Limited - Savings Dai -   10  InformationalVersion1  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Known Attack Vector on approve()", "body": "  Users should be aware of the well known attack vector on approve() (front running changes to existing approvals, spending more tokens than intended by the owner). If needed, they should use the provided increaseAllowance() / decreaseAllowance() to mitigate this risk.  Oazo Apps Limited - Savings Dai -   11  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Manipulable Price Calculation in", "body": " AggregateStablePrice Method  0  0  1  0  The price() function in the AggregateStablePrice contract calculates the price of the stablecoin based on the total supply of stableswap pools.  CS-CRVUSD-004  pool_supply: uint256 = price_pair.pool.totalSupply()  It is possible to manipulate this value, as a malicious actor could significantly change the total supply of pools by using a large amount of capital (obtained for example with a flashloan). This manipulation could alter the computed stablecoin price between the range of the stableswap pool with the lowest price to the stableswap  pool  with  the  greatest  price.  Given  the  function's  role  in  determining  the  price  used  by  the main price oracle, the pegkeepers, and the monetary policies, this may represent a risk.  Code partially corrected:  The new AggregateStablePrice2 contract implements an exponential moving average over the total supplies  of  the  pools.  Note  that  the  first  time  the  price  is  calculated  in  a  block  is  then  valid  for  the remainder  of  that  block.  This  means  that  the  price  is  still  manipulable  to  some  extent  (e.g.  using  a flashloan), although due to the moving average the effect will be reduced. An solution such as using the last price from the previous block may be a more suitable alternative, however it would require moving the totalSupply EMA oracle from an external contract to the StableSwap contract.  Curve - Curve Stablecoin -   10  SecurityDesignCorrectnessCriticalHighMediumCodePartiallyCorrectedLowSecurityMediumVersion1CodePartiallyCorrected             \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  3  6  20  -Severity Findings  -Severity Findings   Checks-effects-interactions Pattern and Reentrancy Locks   Incorrect Verification of Health Limit    Oracle Price Updates Can Be Sandwiched   -Severity Findings   PegKeeper Can Be Drained if Redeemable Stablecoin Permanently Depegs   Incorrect Max Band   Interest Rate Does Not Compound    Manipulation of Active Band    Non-Tradable Funds    Potential Denial of Service (DoS) Attack on Peg Keeper   -Severity Findings   A User's Liquidation Discount Can Be Updated by Anyone at Any Time    ApplyNewAdmin Event Emitted With Wrong Argument in PegKeeper    Draining Funds   Inaccurate _p_oracle_up(n) for High/Low Values of n   Incorrect Array Length   Incorrect Calculations in health_calculator   Incorrect Comments    Meaningful Revert Reasons    Missing Sanity Checks    Multiple Calls to the AMM    No Events    Non-Indexed Events    Potential Optimization With Immutable PriceOracle    Potentially Incorrect Admin Fees    Simpler Calculations Possible    Superfluous Check    Superfluous Interface Definitions    Superfluous Variable Assignment for Number of Bands    Unnecessary Subtraction   Curve - Curve Stablecoin -   11  CriticalHighCodeCorrectedCodeCorrectedCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrected       \f Unused Variables   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Checks-effects-interactions Pattern and", "body": " Reentrancy Locks  CS-CRVUSD-015  Some  external  calls  to  the  collateral  token  deviate  from  the  checks-effects-interactions  pattern.  If  no reentrancy  lock  is  present,  these  calls  might  introduce  reentrancy  possibilities  (especially  read reentrancies)  before  the  state  is  fully  updated.  We  could  not  find  a  case  where  the  non-updated  state the relevant  might  be  checks-effects-interactions pattern.  it  might  be  worth  considering   information.  Still,   fully  adhering   to   For example,  in AMM.exchange(), the transfer is done before the bands are updated;  in AMM.withdraw(), the old rate information would still be returned;  in Controller.create_loan(), the intermediate stable coin balance is returned.  The Reentrancy locks appear to be set inconsistently. We at least cannot see the underlying logic of how they are added. Some admin setters have a nonreentrant decorator and some do not.  For important functions like exchange the decorator seems to be forgotten after a code change. For this reason, the issue was rated higher.  Code corrected  The  missing  reentrancy  lock  on  exchange()  has  been  added.  Some  missing  reentrancy  locks  have been  explained.  All  but  one  of  the  remaining  external  functions  without  locks  seem  to  be  safe  even without a lock.  The  Controller's  total_debt()  function  will  return  outdated  /  inconsistent  values  compared  to  the AMM's  state  if  called  during  the  callback  of  repay_extended  and  _liquidate.  More  precisely,  the AMM's  state  will  already  reflect  the  withdrawal  /  liquidation,  whereas  the  Controller's  state  has  not  yet been updated. It should be carefully considered if this might pose problems for integrators or third-party contracts interacting with the Controller.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Incorrect Verification of Health Limit", "body": "  The _liquidate function checks whether the user's health is below a certain health limit. This health limit is passed as the user's liquidation discount by liquidate (and 0 by self_liquidate). But the health  function  already  accounts  for  the  user's  liquidation  discount  and  is  supposed  to  return  a  value below 0 when the liquidation can start.  CS-CRVUSD-019  Code corrected  Curve fixed and identified this issue while the audit was ongoing.  Curve - Curve Stablecoin -   12  CodeCorrectedDesignHighVersion1CodeCorrectedCorrectnessHighVersion1CodeCorrected                     \f6.3   Oracle Price Updates Can Be Sandwiched  The  AMM  price  range  in  a  band  (p_cd,  p_cu)  depends  cubically  on  the  oracle  price  p_o (p_cd  =  \\frac{p_o^3}{p_\\uparrow^2},  p_cu  =  \\frac{p_o^3}{p_\\downarrow^2}).  Since trading can happen out of band, AMM price changes because of changes in p_o are greatly amplified for bands far from the current oracle price. The previous consideration makes it profitable for an attacker to leverage small oracle price increases by accessing the liquidity of low price bands. The attack scenario is like this:  1. Stablecoin is exchanged for collateral, in a large amount such that the active band is shifted toward  CS-CRVUSD-031  lower prices bands  2. The oracle price is increased  3. part  of  the  collateral  obtained  in  step  1  is  exchanged  back  at  a  higher  price,  recouping  the  stablecoin and allowing the attacker to keep part of the collateral.  Since after a price update the AMM price will move the most for bands which have a low price compared to  the  current  oracle  price  (high  collateral  ratio),  overcollateralized  borrowers  are  most  affected  by  this issue.  Positions  that  should  be  the  safest  might  suffer  the  most  losses  from  sandwiching,  more  than supposedly \"riskier\" positions.  Code corrected  A new dynamic fee has been introduced, such that the fee scales in the same amount as the theoretical profit from sandwiching an oracle update.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   PegKeeper Can Be Drained if Redeemable", "body": " Stablecoin Permanently Depegs  If  one  of  the  reference  stablecoins  depegs,  for  example  USDC  falls  to  p  =  $0.95,  the  price  in  the corresponding  StableSwap  (crvUSD/USDC)  will  follow  the  external  market  price  and  also  fall  to  $0.95. The PegKeeper will then try to raise the price, by supplying crvUSD to the StableSwap pool. Essentially the PegKeeper will try to keep USDC from depegging. This opens up the following arbitrage opportunity, where p is the current market price of USDC:  CS-CRVUSD-001  The arbitrage profit depends on the liquidity available in all the pools. If the following (for the purpose of a worst-case analysis) we assume no slippage for the arbitrageur. Assuming all pools have fee f, then the arbitrage becomes profitable if the price p of the depegged stablecoin is:  Curve - Curve Stablecoin -   13  SecurityHighVersion1CodeCorrectedSecurityMediumVersion5CodeCorrected              \fp < \u2212  (f \u2212 1)3 4f 3 \u2212 12f 2 + 12f + 1  Currently, f = 0.0001 meaning that the arbitrage would become profitable for:  p < 0.998502  Assuming that the market price of the depegged stablecoin permanently falls to p, this arbitrage would happen repeatedly until the PegKeeper has been drained. In this case the PegKeeper would suffer a loss trying to prop up the price of the depegging stablecoin.  Furthermore, the PegKeeper would try to keep crvUSD pegged to a depegging stablecoin, which would put the crvUSD price under pressure, but (assuming reasonably distributed liquidity) should not result in a depegging.  Lastly, please note that as part of the arbitrage crvUSD would accumulate in the crvUSD/USDT pool, but the PegKeeper of crvUSD/USDT pool would not be able to withdraw, due to the  assert p_agg <= 10**18  check, as p_agg would presumably be bigger than 10**18 due to the depegging stablecoin.  If  the  depegging  is  only  temporary,  meaning  that  the  price  recovers,  then  the  PegKeeper  was temporarily drained, but should have made a profit in the process.  Theoretically,  this  issue  could  also  exist  in  the  opposite  direction,  with  a  stablecoin  gaining  value. However, this seems less likely except for DAI in Maker endgame scenarios.    In PegKeeperV2 at commit 5a46bb9c1f43b7d4062127b9919e3c2ed366ad34, which is object of a  separate  ChainSecurity  audit,  the  pegkeepers  for  different  redeemable  stablecoins  interact  and communicate to each other limits on how much crvUSD can be supplied to a pool. In the case of a single redeemable stablecoin depegging, the pegkeeping action on its pool will be limited.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Incorrect Max Band", "body": "  The  AMM  contract  tracks  the  max_band  variable.  Bands  above  this  band  are  empty.  In  the  withdraw function the max_band is potentially updated:  CS-CRVUSD-034  if self.max_band <= ns[1]:     self.max_band = max_band  If  this  withdrawal  emptied  all  the  touched  bands,  then  this  update  would  set  the  max_band  to  0.  This might be incorrect, as other non-empty bands might still exist inbetween.  As the max_band variable is used in calc_swap_out exchanges on the AMM might work incorrectly because of this.  Code corrected  max_band is now set to the last known band with non-empty coins in the withdrawing loop.  Curve - Curve Stablecoin -   14  CorrectnessMediumVersion1CodeCorrected          \f6.6   Interest Rate Does Not Compound  The AMM contract has a function _rate_mul to compute the rate multiplier. The function simply adds the rate multiplied by the time difference to the previous rate multiplier:  CS-CRVUSD-002  return self.rate_mul + self.rate * (block.timestamp - self.rate_time)  This  approach,  however,  does  not  account  for  the  compounding  of  interest  over  time.  Linearly  adding interest could lead to significant underestimation of the accrued interest over time.  The code should be modified to include interest compounding in line with common financial practice.    The calculation was updated in order to compound each time the _rate_mul function is called (though the rate increases linearly over the time periods between these calls):  return unsafe_div(self.rate_mul * (10**18 + self.rate * (block.timestamp - self.rate_time)), 10**18)  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Manipulation of Active Band", "body": "  CS-CRVUSD-020  It is possible to manipulate the active band. The lower the market liquidity the easier the manipulation is. Multiple  other  parameters  are  depending  on  the  active  band  and,  hence,  are  also  manipulated.  The manipulation  is  possible  when  liquidity  which  is  in  a  band  far  above  the  current  band,  is  reachable through trading. And is done by manipulated deposits, paybacks and trades.  The consequences of this manipulation might be manifold. E.g.:   Deposits  which  should  still  be  possible  are  impossible  because  they  would  be  below  the  manipulated active band.   The health ratio would be affected as it depends on the active band  It  could  result  in  an  active  band  that  is  more  than  1024  +  50  away  from  the  \"true\"  active  band. \"True\" if the external price oracle is assumed to be the truth.  Code corrected  It is now impossible to increase the distance between the active band and the oracle price further than 50 ticks. The active band is otherwise used as a reference point of the AMM, but its value does not affect where loans are created or the value of their health ratio.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Non-Tradable Funds", "body": "  CS-CRVUSD-026  Curve - Curve Stablecoin -   15  CorrectnessMediumVersion1CodeCorrectedSecurityMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                       \fIn case of a very small trade in a band far away from the active band, the funds might be inaccessible through normal trading. It is caused by the new code in_amount_done == 0 change which fixes the issue Draining funds but blocks the reversal trade now.    Input amounts are now rounded up.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.9   Potential Denial of Service (DoS) Attack on", "body": " Peg Keeper  The  PegKeeper  contract  contains  a  update  function  that  imposes  a  delay  of  15  minutes  between actions.  CS-CRVUSD-005  if self.last_change + ACTION_DELAY > block.timestamp:     return 0  This design makes it susceptible to a potential Denial of Service (DoS) attack. A malicious actor could effectively  keep  the  PegKeeper  occupied  by  directly  rebalancing  the  stableswap  pools,  calling update(), and then unbalancing the pools again within a single transaction. The PegKeeper would be locked  for  the  next  15  minutes,  without  having  provided  or  withdrawn  any  amount  of  stablecoin.  This strategy could be performed by an actor seeking to destabilize the peg.    PegKeeperV2, included at commit 5a46bb9c1f43b7d4062127b9919e3c2ed366ad34, which is in the scope of a separate ChainSecurity audit, addresses this issue by preventing a pegkeeper update when  the  spot  price  of  the  underlying  pool  is  in  disagreement  with  the  oracle  price  of  the  pool  by more than 5 basis points.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.10   A User's Liquidation Discount Can Be", "body": " Updated by Anyone at Any Time  The repay function allows anyone to repay any loan \u2014 even just partially. This function will also update the liquidation discount of the user who has taken the loan to the current liquidation discount. This implies that someone can repay a tiny amount for another user's loan just to change their liquidation discount. In the case where the liquidation discount has increased significantly since the loan was taken, this will be disadvantageous to the borrower. Conversely, borrowers can update their liquidation discounts to their advantage. The liquidation discount can also be updated by adding collateral.  CS-CRVUSD-006    Curve - Curve Stablecoin -   16  SecurityMediumVersion1CodeCorrectedSecurityLowVersion1CodeCorrected                \fOnly the debt owner can repay in such a way that their position becomes or stays unhealthy. Moreover, the liquidation_discount of a position is only updated if the debt owner is the message sender.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.11   ApplyNewAdmin Event Emitted With Wrong", "body": " Argument in PegKeeper  The  __init__  constructor  function  of  a  PegKeeper  emits  a  ApplyNewAdmin(msg.sender)  event. However  msg.sender  is  not  necessarily  the  contract  admin,  which  is  specified  as  the  _admin constructor argument.  CS-CRVUSD-007    The _admin constructor argument is now emitted in the event.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.12   Draining Funds", "body": "  It is possible to drain 1 WEI per trade from the exchange when a loan is present. Simply by trading back and  forth  with  a  very  small  amount.  On  Ethereum,  the  transaction  cost  should  always  outweigh  the drained WEI.  CS-CRVUSD-016  Code corrected  in amounts are now rounded up.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.13   Inaccurate _p_oracle_up(n) for High/Low", "body": " Values of n  CS-CRVUSD-008  The  AMM  contract  implements  the  _p_oracle_up  function,  which  performs  numerical  computations  to determine its return value. The maximum and minimum values of the power variable (which is derived from the parameter n) are constrained by assert statements.  However,  these  bounds  are  too  permissive,  allowing  extreme  values  of  n  to  pass  through,  leading  to potential  issues.  When  the  value  of  n  is  excessively  high  or  low,  the  output  of  the  _p_oracle_up function can result in collisions (identical results for different n) or return a value of 0.  For example, when n = 4124, the function returns 0. It does not revert until n = 4193.  The AMM expects non-zero prices, and non-overlapping bands. The bounds on the possible input values for _p_oracle_up should therefore be narrowed.  Curve - Curve Stablecoin -   17  CorrectnessLowVersion1CodeCorrectedSecurityLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f  The result of the exponential is asserted to be more than 1000, corresponding to a maximum value of n = 3436.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.14   Incorrect Array Length", "body": "  The  Stableswap  contract  needs  to  be  initialized  with  a  _coins  array  of  length  4.  However,  only  two values are needed (and can be used), as the maximum number of coins is two.  CS-CRVUSD-017  Specification changed  Curve explained this is intentional to keep compatibility with the factory.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.15   Incorrect Calculations in ", "body": " health_calculator  When  calculating  the  health  factor  in  Controller.health_calculator,  the  collateral  value  for  a non-converted deposit is calculated as follows:  CS-CRVUSD-018  collateral = convert(xy[1], int256) + d_collateral n1 = self._calculate_debt_n1(xy[1], convert(debt, uint256), N)  As the function wants to predict the health ratio after the collateral change, n1 should be calculated with d_collateral  included  and  not  on  the  present  value  xy[1].  Later,  p0  is  calculated  to  convert  the collateral into stablecoins. But this is only needed if ns[0] > active_band. The following code block might be written into the first condition checking ns[0] > active_band:  Code corrected  The calculation of n1 has been corrected.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.16   Incorrect Comments", "body": "  The following comments contain inaccuracies:   The  NatSpec  of  function  withdraw  says:  Withdraw  all  liquidity  for  the  user.  However, partial withdrawals are also possible.   The  NatSpec  of  function  _get_dxdy  says  that  parameter  amount  is  an  amount  of  input  coin.  In fact,  amount  could  specify  either  an  input  or  an  output  amount,  depending  on  the  function parameter is_in.  CS-CRVUSD-009  Curve - Curve Stablecoin -   18  CorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \fFixed:  The NatSpec have been edited to reflect the actual behavior of the functions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.17   Meaningful Revert Reasons", "body": "  CS-CRVUSD-021  Multiple asserts do not throw a revert reason, making it hard to determine where the code failed while E.g., debugging.  assert  xy[0]  >=  min_x,  \"Sandwich\".  It  might  be  clear  to  developers  but  might  cause  some confusion for anyone else reading the message (e.g., just \"Sandwich\") as a revert reason. Technically, the error is also not necessarily caused by a sandwich attack.  Additionally,   messages   revert   short.   many   quite   are   Specification changed  The \"Sandwich\" revert message was renamed to \"Slippage\". Curve explained that the contract is close to the bytecode limit. The chosen revert messages are the trade-off between bytecode limit and meaningful reverts.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.18   Missing Sanity Checks", "body": "  The  following  functions  set  important  parameters  but  have  no  sanity  checks  for  the  arguments.  Even though some are permissioned and called by a trusted account, sanity checks might prevent accidents. E.g.:  CS-CRVUSD-022  In ControllerFactory:   __init__   add_market performs no checks for debt_ceiling.   set_admin   set_debt_ceiling  In AggMonetaryPolicy:   __init__ .. corrected   setRate .. corrected   setAdmin   ConstantMonetaryPolicy has no checks in the setters.  In CryptoWithStablePrice   __init__ for ma_exp_time .. corrected  In PegKeeper:   __init__ the _receiver and _caller_share  Curve - Curve Stablecoin -   19  DesignLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                \fIn the AMM contract:   __init__   set_rate might be a problem when no check in the policy was done.   create_loan might fail earlier for no amounts.  In Stableswap   exchange could perform checks to fail early.  Some sanity checks might be a trade-off between security and performance.  Code corrected  Some of the missing sanity checks were fixed by Curve independently while the audit was ongoing. We assume the issue raised awareness and the sanity checks were added as intended by Curve.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.19   Multiple Calls to the AMM", "body": "  In Controller repay and health_calculator, there is the following loop:  CS-CRVUSD-023  for i in range(MAX_SKIP_TICKS):     if AMM.bands_x(active_band) != 0:         break     active_band -= 1  This loop might be executed inside of the AMM contract to avoid an external call in each iteration.  Code corrected  The loop execution was moved from the Controller to the AMM.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.20   No Events", "body": "  The following functions perform an important state change but don't emit an event.  In  ControllerFactory:  set_admin,  set_implementations,  set_debt_ceiling, rug_debt_ceiling   ConstantMonetaryPolicy: Does not emit any events at all.   PegKeeper:  Functions  that  apply  and  commit  admin,  commit  and  apply  new  receiver  and  set_new_caller_share .. corrected  CS-CRVUSD-024  Code corrected  Curve - Curve Stablecoin -   20  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                 \fWhile  the  audit  was  ongoing  some  events  have  been  added.  Without  specification,  it  is  unclear  which events  are  intended.  We  assume  the  issue  raised  awareness  and  all  events  have  been  added  as intended.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.21   Non-Indexed Events", "body": "  Multiple events allow no filtering for a specific address as they miss indexing. This includes the following examples:  CS-CRVUSD-025   All events in ControllerFactory   SetPriceOracle in AMM   Multiple events in the AggMonetaryPolicy   AddPricePair in AggregateStablePrice   Multiple events in PegKeeper   SetMonetaryPolicy in Controller  Code corrected  Curve indexed multiple events. We assume that after reviewing the events, the current event indexing is the intended indexing as no specification is provided.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.22   Potential Optimization With Immutable", "body": " PriceOracle  The  AMM  contract  declares  price_oracle_contract  as  a  public  storage  variable.  This  address  is accessed frequently and cannot be replaced in the current implementation.  However, this public declaration results in a storage access each time the price_oracle_contract is accessed.  Since  this  is  a  frequent  operation  and  price_oracle_contract  cannot  be  overwritten, typing it as an immutable variable could have significant effects on overall gas usage.  CS-CRVUSD-013    The price_oracle_contract variable is now declared immutable.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.23   Potentially Incorrect Admin Fees", "body": "  In AMM.exchange the following check is done before the in and out amounts are transferred:  CS-CRVUSD-027  Curve - Curve Stablecoin -   21  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fif out_amount_done == 0:     return 0  If the trade does not return any tokens, the function returns 0 but does not revert. Before that point, the state variables admin_fees_x and admin_fees_y are incremented.  When  testing,  we  could  not  get  the  system  into  the  desired  state.  Therefore,  we  list  this  as  a  more theoretical low-severity issue.  Code corrected  The admin fees are updated after the potential zero return.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.24   Simpler Calculations Possible", "body": "  In the AMM's get_xy_up function, some calculations can be simplified to save gas:  1. The calculation for p_current_mid:  p_current_mid: uint256 = unsafe_div(unsafe_div(p_o**2 / p_o_down * p_o, p_o_down) * Aminus1, A)  CS-CRVUSD-014  This is equivalent to the simpler formula:  pmid =  3  po p \u2193 p \u2191  2. The calculations for y_o and x_o in the general case:  y_o = unsafe_sub(max(self.sqrt_int(unsafe_div(Inv * 10**18, p_o)), g), g) x_o = unsafe_sub(max(Inv / (g + y_o), f), f)  These equations can be simplified to the following expressions:  yo = Ay0(1 \u2212  p \u2193 po  )  xo = Ay0po(1 \u2212  po p \u2191  )    Both suggestions have been implemented.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.25   Superfluous Check", "body": "  Under  the  assumption  that  the  AMM  is  always  called  by  the  controller,  the  following  checks  in AMM.deposit_range are not needed because the controller will pass them in ascending order:  CS-CRVUSD-029  Curve - Curve Stablecoin -   22  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fband: int256 = max(n1, n2) lower: int256 = min(n1, n2)  Code corrected  The checks have been removed as the controller passes sorted values to the AMM.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.26   Superfluous Interface Definitions", "body": "  CS-CRVUSD-028  In Stableswap Factory.convert_fees  The following interface definitions were not needed and removed:  In Controller LLAMMA.get_y_up is unused.  In Stablecoin the Controller.admin interface is unused.  In AMM the ERC20's balanceOf function is unused.   The  AggMonetaryPolicy  and  AggregateStablePrice  contracts  implement  the  ERC20  interface but do not use it.   AggregateStablePrice does not use the balances definition of Stableswap   PegKeeper  does  not  use  StableAggregator.stablecoin  and  CurvePool.lp_token  an  ERC20.balanceOf  In Controller LLAMMA.get_base_price and ERC20.totaSupply  In ControllerFactory ERC20.transferFrom  Code corrected  Curve removed most of the unused definitions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.27   Superfluous Variable Assignment for", "body": " Number of Bands  In AMM.deposit_range() the variable n_bands is defined as:  i: uint256 = convert(unsafe_sub(band, lower), uint256) n_bands: uint256 = unsafe_add(i, 1)  The variable dist is defined as  dist: uint256 = convert(unsafe_sub(upper, lower), uint256) + 1  CS-CRVUSD-030  Curve - Curve Stablecoin -   23  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \fand upper: int256 = band.  Code corrected  The redundant calculation was removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.28   Unnecessary Subtraction", "body": "  In Controller.__init__, the variable Aminus1 is set to _A - 1. Later in the code Aminus1 is not used but recalculated as _A - 1.  CS-CRVUSD-032  Code corrected  The calculation is now done once in __init__ and the variable Aminus1 is reused in the code.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.29   Unused Variables", "body": "  In Stableswap we found EXP_PRECISION which is not used in the contract anymore.  CS-CRVUSD-033  Code correct  The unused variable EXP_PRECISION has been removed.  Curve - Curve Stablecoin -   24  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Dirty Wipe", "body": "  The state variable AMM.user_shares is never completely cleared. Only the first values are emptied to indicate the user has no shares anymore. The other values are not accessible but remain in storage until they are overwritten. This is more gas efficient if the user wants to deposit again, and we could not find a way  to  access  the  outdated  values.  Still,  this  might  be  worth  keeping  in  mind  as  future  code  changes might make the values accessible.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Exchange Does Not Revert if It Did Not", "body": " Succeed  When exchanging on an empty LLAMMA or the desired token has no balance, there is no error message for the exchange transaction.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Liquidate Callback Passes Address of the", "body": " Liquidated User  In the Controller's _liquidate function, the execute_callback function is called with the user set as the address being liquidated, not the liquidator (msg.sender). Special care has to be taken by callback contracts to know the initiator of the liquidation.  CS-CRVUSD-003  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Lost Dust Balance on Exchange", "body": "  In  the  presence  of  dust  balances  in  an  AMM  band,  the  _get_y0()  calculation  can  return  0.  The consequence is that the band content is not traded because f == 0 if dumping and g == 0 if pumping, which causes the exchange code for the band in calc_swap_in and calc_swap_out to be skipped even if some balance is present. When the DetailedTrade struct is inspected in _exchange(), it is assumed  no  amount  of  out  token  is  left  in  the  bands  between  the  trade  start  and  the  last  band.  This means that the dust balance that was in the bands where _get_y0() == 0 is forgotten, and its value becomes untransferable.  CS-CRVUSD-011  An  to  _get_y0(1, 1, int(1000e18), int(1000e18*1.01**1)) == 0.  _get_y0()   example   state   for   equal   0   is  Curve - Curve Stablecoin -   25  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \fAs the client states, this doesn't prevent from trading over that band. The small amount of dust lost does not affect the operation otherwise.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Magic Numbers and Constants", "body": "  Some \"magic numbers\" are used in the code. For example, in ControllerFactory.vy, the collaterals index is updated as follows:  for i in range(1000):     if self.collaterals_index[token][i] == 0:         self.collaterals_index[token][i] = 2**128 + N         break  We recommend defining all such numbers as constants with clear names.  Ideally, how these constants are picked should also be described. For example, it was not clear how a MAX_RATE of 43959106799 corresponds to 400% APY (as commented), or why MAX_TICKS = 50 and MAX_SKIP_TICKS = 1024 are appropriate values.  Also, the number of decimals (10**18) is often hardcoded.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   Max Band Over-Estimates the Actual Maximal", "body": " Band  The max_band variable which tracks the maximum band of the AMM might not be decreased to the actual maximum band with liquidity when liquidity is withdrawn. max_band only provides an upper bound on the bands which could currently hold liquidity, but could overstate it. This has no visible effect except making swaps that exhaust all the available liquidity more gas expensive.  CS-CRVUSD-012  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.7   Min Band Update", "body": "  The min and max band indicate in which range liquidity is provided. Everything above and below should be  empty.  In  withdraw  the  min  and  max  bands  are  updated.  In  case  a  user  who  has  liquidity  in  the lowest  ticks  withdraws  their  liquidity,  the  min  band  is  set  to  the  former  max  band  n[1]  of  this  user. Hence, min band guarantees that there is no liquidity below it but it's not the lowest band with liquidity.  Similarly, the max band will not be decreased if a single user owns all the liquidity in all of their bands, and max_band == n[1]. In this case, max_band will not be changed when they withdraw their funds.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.8   Peg Keeper Assumptions", "body": "  The Peg Keeper actions will always balance a pool. This implies a constant 1:1 target ratio, assuming that no token loses its peg. Events have shown, however, that stablecoins can lose their peg and even  Curve - Curve Stablecoin -   26  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                \fbecome quite volatile. It might be beneficial to have additional security mechanisms in place to monitor and pause the actions of a peg keeper.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.9   Sandwiching Peg Keeper Actions", "body": "  The Peg Keeper acts on the simple condition of an unbalance pool combined with some sanity checks on the  post-price  changes.  As  the  pool  balances  can  easily  be  manipulated  with  flash  loans  and  the  Peg Keeper acts in a deterministic way without slippage protection, this action is prone to be sandwiched in an attack. Yet, we could not think of a scenario that would directly hurt the audited system itself. In all scenarios,  the  Peg  Keeper  will  balance  the  pool  in  the  \"correct\"  direction  (balancing  the  pool).  This  is usually beneficial and not harmful to the system.  Even  though  the  actions  of  the  Peg  Keeper  should  be  monitored  closely,  it  might  be  beneficial  to  add security  mechanisms  to  pause  the  Peg  Keeper's  actions  and  absolute  investment  limits  instead  of relative ones.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.10   Use of LLAMMA Price", "body": "  The  LLAMMA  price  is  easy  to  manipulate.  The  price  and  the  functions  AMM.get_p()  and Controller.amm_price (that return the price) should not \u2014 or very carefully \u2014 be used in any critical operation. Especially, in third party contracts querying this information.  Curve - Curve Stablecoin -   27  NoteVersion1NoteVersion1        \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Code With No Effect", "body": "  In  UniswapV3LiquidityPositionLib.__mint,  token0  and  token1  are  overwritten  by  their  own value, hence this code has no effect.   The related assignments have been removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Missing Sanity Check", "body": "  NonfungiblePositionManager   Upon  UniswapV3  LP  external  position  creation,  sorting  of  token0  and  token1  is  not  enforced. UniswapV3  sorted (address(token0)  <  address(token1)),  otherwise  the  transaction  will  revert.  This  means  that  a non-functional  external  position  can  be  instantiated.  For  example,  passing  non-sorted  tokens  to NonfungiblePositionManager.mint will revert on PoolAddress.computeAddress which requires the tokens to be sorted.  tokens   needs   the   be   to     Ordering of the tokens is now enforced on the external position initialization.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Redundant Deadline", "body": "  Avantgarde Finance - Sulu Extensions -   10  CriticalHighMediumLowCodeCorrectedCodeCorrectedCodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fWhen  UniswapV3LiquidityPositionLib._removeLiquidity  is  called,  the  deadline  is  set  to block.timestamp + 1. This is not needed since the call to the NonfungiblePositionManager is part of an already executing transaction.    +1 has been removed.  Avantgarde Finance - Sulu Extensions -   11  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   PoolTogether V4 Early Exit Fee", "body": "  Upon redeem, PoolTogetherV4 is assumed to have no penalty fee for early withdraws as described in https://docs.pooltogether.com/faq/v3-to-v4-differences.  An  exit  fee  like  in  V3  could  prevent  the  fund manager  to  withdraw  from  PoolTogetherV4.  More  specifically,  pools  that  make  use  of  PrizePool  are assumed get the full amount requested on withdrawal. When the PrizePool.withdrawFrom is called, the  amount  to  be  redeemed  is  calculated  using  _redeem  internal  function.  In  the  case  of PrizePool._redeem, this function calls one of the yield sources implementations which determines the actual amount to be redeemed. Should such a yield source return a redeemed amount that is less than the amount initially requested, the call on integration will fail.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Price Oracle Discrepancies", "body": "  In order to calculate the value of a position the actual price between the two tokens is required. For this, the default oracles for the two tokens are used. We assume that there are no big discrepancies between the actual price of the Uniswap pool for the specific pair and the price calculated by the system.  Avantgarde Finance - Sulu Extensions -   12  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   ZkBobPool Withdrawal Sandwich Attack", "body": "  When the withdrawal with native_amount is submitted to the ZkBobPool, the sale of tokens for ETH happens using the UniswapV3Seller contract. However, the amountOutMinimum parameter of this swap is 0. A potential attacker can place orders that would manipulate the price, forcing the sellForETH trade  to  be  executed  with  a  bad  price.  Thus,  due  to  the  lack  of  spread  control,  any  use  of UniswapV3Seller can result in a bad trade, allowing price manipulators to pocket the profit from this trade.  Risk accepted:  BOB Protocol responded:  This  feature  is  only  intended  to  swap  small  amounts  of  tokens,  purely  for  funding  wallets  with  gas tokens. UI will strongly dissuade users for doing swaps that are larger than e.g. 100$ in value. Added a warning comment to the sellForETH function.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   BaseERC20 Overflow", "body": "  BOB Protocol - zkBob -   10  SecurityDesignCorrectnessTrustCriticalHighMediumRiskAcceptedLowRiskAcceptedRiskAcceptedRiskAcceptedDesignMediumVersion1RiskAcceptedCorrectnessLowVersion1RiskAccepted                    \fThe _increaseBalance function of the BaseERC20 contract can overflow. While it is checked that the account  is  not  frozen  (i.e.  the  first  bit  of  the  balance  is  zero),  it  is  not  guaranteed  that  the  addition  will result in a number smaller than 2^255. Hence, an account could become frozen by increasing its balance above this value.  Risk accepted:  Assuming  a  reasonable  total  supply  of  the  token  (less  than  2^255),  it  is  impossible  for  any  individual account  to  have  a  balance  large  enough  to  cause  this  overflow  to  happen.  Thus,  the  overflow  cannot occur under normal circumstances.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   Daily Limits Can Be Avoided", "body": "  If the MutableOperatorManager is used and the operator variable is set to 0, then effectively every user becomes an operator / relayer. This means that any user could spread funds between multiple addresses and easily avoid the daily limits imposed by the ZkBobAccounting contract.  Risk accepted:  BOB Protocol accepts the risk regarding users avoiding daily limits and states:  Allowing  users  to  submit  transactions  themselves  introduces  multiple  potential  problems,  including the one described with the limits. For now, it can be assumed that deposit transactions might only go through  the  chosen  relayer,  which  is  also  responsible  for  detecting  abnormal  limit  usage.  Even though we cannot assume that one address is equal to one user, we think that making per-address limits in the contract can still be useful in certain use-cases.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.4   ERC20Permit.receiveWithPermit Signature", "body": " Can Be Front-Run  Similar  to  issue  ERC20Permit.receiveWithSaltedPermit  signature  can  be  front-run,  the  signatures between  ERC20Permit.permit  and  ERC20Permit.receiveWithPermit  are  interchangeable  as well.  Thus, the attacker can front-run the signatures and use them in unintended functions to cause a user's transactions  to  fail.  However,  this  does  not  render  the  ZkBob  system  unsecure  itself  but  might  cause problems for 3rd party integrations. Thus, the severity of this issue is low.  Risk accepted:  BOB Protocol accepted the risk and stated:  Third  party  integrations  relying  on  permit/receiveWithPermit  are  advised  to  implement  necessary fallbacks for failing permit/receiveWithPermit calls, avoiding entire transaction failures.  BOB Protocol - zkBob -   11  TrustLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                  \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   ZkBobPool Fees Can Drain the Deposits of the User   -Severity Findings   ERC20Permit.receiveWithSaltedPermit Signature Can Be Front-Run   -Severity Findings   Admin Reentrancy in ERC20Recovery    Avoiding Recovery by Admin    BobVault Uint Conversions    Missing Sanity Checks    No Events on State Changes   0  1  1  5  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   ZkBobPool Fees Can Drain the Deposits of the", "body": " User  When depositing using the transact function, the caller can specify a negative token amount. Normally, this would revert as it is checked that the deposit amount is positive. However, if the user also specifies the  fee  to  be  greater  than  the  absolute  value  of  the  deposit  amount,  the  total  token_amount  will  be positive, hence passing the check. Thus, the deposit will go through. This can be exploited by a malicious operator in the following scenario:  1. Operator (msg.sender) specifies txType = 0 (deposit), _transfer_token_amount = -400,  fee = 500.  2. Computed token_amount will be 100.  3. 100 * TOKEN_DENOMINATOR will be transferred to the ZkBobPool from the user address.  4. accumulatedFee[msg.sender] will be increased by 500.  5. Operator withdraws 500 * TOKEN_DENOMINATOR of fees.  Thus, by depositing only 100 tokens malicious operator was able to withdraw 500 tokens as fees. The malicious operator can drain the contract via the fees.  Note  that  the  transact  function  is  only  callable  by  the  privileged  Operator  role.  However,  the OperatorManager contracts can be configured such that every user would be an operator.    BOB Protocol - zkBob -   12  CriticalHighCodeCorrectedMediumCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedSecurityHighVersion1CodeCorrected        \fBOB Protocol confirmed that the case of asset drain was prevented by the verifier and the snark circuits which  are  out  of  scope  for  this  engagement.  However,  the  deposit  of  a  negative  value  still  could  have been  used  as  an  undesired  withdrawal.  Stronger  checks  were  introduced,  namely  a  requirement  that _transfer_token_amount  must  be  positive  for  deposits.  The  check  during  the  withdrawal  correctly constrains  the  token_amount,  since  otherwise  the  same  issue  would  occur  in  the  other  direction  -  a small negative _transfer_token_amount + big positive fee can be positive, causing a withdrawal to count as a deposit.  The full response of BOB Protocol team:  This confusing case is handled correctly by the verifier and snark circuits.  During usual deposit, the following happens:  1. User deposit amount is 400 (_transfer_token_amount is 400)  2. Relayer adds a 100 fee on top  3. Pool contract executes transferFrom for 500 (400 + 100) tokens  4. User shielded balance is increased by _transfer_token_amount (400), which is verified by the  circuit verifier  5. Relayer receives a 100 fee  6. So 500 transferred tokens were divided between user (+400) and relayer (+100)  During the suggested negative deposit, the following happens:  1. User deposit amount is -400 (_transfer_token_amount is -400, better to think of it as a balance  delta, rather than deposit amount)  2. Relayer adds a 500 fee on top  3. Pool contract executes transferFrom for 100 (-400 + 500) tokens  4. User shielded balance is increased by _transfer_token_amount (-400), which is verified by the circuit verifier. As the balance delta is negative, the balance is actually being decreased by 400.  5. Relayer receives a 500 fee.  6. In  the  end,  relayer  receives  500  tokens,  comprised  of  user  shielded  balance  decrease  (400)  and external token transfer (100)  7. Essentially, this turned a deposit into a very strange version of withdrawal  Although balance accounting works correctly here, this situation is indeed very confusing. It cannot be triggered via the UI or SDK, as it just does not make sense for users to do something like that. To get  rid  of  this  unnecessary  source  of  confusion,  we  will  introduce  a  bit  stricter  validation  on  the deposit amounts, so that negative _transfer_token_amount are not allowed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   ERC20Permit.receiveWithSaltedPermit", "body": " Signature Can Be Front-Run  The  ZkBobPool  permittable  deposit  relies  on  the  ERC20Permit.receiveWithSaltedPermit function.  However,  the in  ERC20Permit.saltedPermit  function  as  well.  An  attacker  can  intercept  the  deposit  transaction, extract the signature and use it in the call to saltedPermit. As a result of this action, the permittable deposit  will  fail  due  to  the  nonce  already  having  been  used.  Thus,  the  attacker  can  front-run  the signatures and use them in unintended functions to cause a user's transactions to fail.  signature   function   used   used   can   this   the   be   in   BOB Protocol - zkBob -   13  DesignMediumVersion1CodeCorrected        \f  The  saltedPermit  function  was  removed.  Hence,  a  permittable  transaction  can't  be  front-run  with  a call that uses the same signature for another function.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Admin Reentrancy in ERC20Recovery", "body": "  The  executeRecovery  function  in  ERC20Recovery  can  only  be  called  by  the  owner  or  the  recovery admin. When recovering the tokens, they are transferred to the recoveredFundsReceiver address. If this address is a contract, the onTokenTransfer function is called. This call could be used to reenter the  executeRecovery  function  in  order  to  double-claim  the  funds  to  recover.  This  would  allow  the recovery admin or the owner to exceed the intended recoveryLimit.  As  the  recoveredFundsReceiver  can  only  be  set  by  the  owner,  and  both  the  owner  and  recovery admin are trusted addresses, the impact of this issue is limited.    The recoveryRequestExecutionTimestamp and recoveryRequestHash are now deleted before any external calls are made. Hence, if a reentrant call later calls executeRecovery again, there will be no stored timestamp or hash, so the funds can't be double-claimed anymore.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Avoiding Recovery by Admin", "body": "  a   that   user   sees   (using account  If  ERC20Recovery.requestRecovery()),  they  can  simply  transfer  funds  to  another  account  to  stop them from being recovered. It may also make sense from the perspective of trustworthiness to only allow recovery  of  funds  e.g.  if  the  account  is  already  frozen,  or  at  least  enforcing  that  an  account  must  be frozen in order to recover its funds.  recovery   marked   their   for   is   Specification corrected:  BOB Protocol responded:  Recovery  functionality  is  intended  to  be  used  only  on  dormant  or  non-existing  users,  if  the  user  is able  to  move  his  funds  to  a  different  address,  his  token  should  not  be  allowed  for  recovery. Recovering  frozen  is  a  different  use-case,  although  it  can  be  also  executed  through  the  same functionality.  With  the  assumption,  that  the  proper  checks  will  be  performed  before  account  recovery,  this  issue  is resolved.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   BobVault Uint Conversions", "body": "  BOB Protocol - zkBob -   14  SecurityLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                        \fTo track the token.balance the BobVault contract uses uint128 values. Theoretically, it is possible to provide a value that is great than type(uint128).max. This case will not be handled correctly by the code due to the unsafe conversion to uint128, which truncates the value. As a result, internal accounting will be broken. This happens in multiple functions such as: buy, sell, swap, give.  token.balance += uint128(sellAmount);  The amount before conversion in most cases is used as an argument for token transfer. However, the practical safety of this conversion depends on the external contract, which is not optimal.    BOB Protocol responded:  Although  such  extremely  high  amounts  won\u2019t  be  seen  in  practice,  we  added  additional  overflow checks where necessary.  The checks were introduced in buy, swap, give. Check performed in sell is sufficient to prevent the overflow.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Missing Sanity Checks", "body": "  Many  state-changing  operations  do  not  include  sanity  checks  to  ensure  incorrect  values  are  not  set. Consider adding checks to ensure these values aren't accidentally set incorrectly. This can happen e.g. due to a bug in a front-end application resulting in empty values in calldata.  These operations include:  ERC20Blocklist:   updateBlocklister() does not check that _newBlocklister is not address(0).  ERC20Recovery:   setRecoveryAdmin() does not check that _recoveryAdmin is not address(0).   setRecoveredFundsReceiver()  does  not  check  that  _recoveredFundsReceiver  is  not  address(0).  Claimable:   setClaimingAdmin does not check that _claimingAdmin is not address(0).  ZkBobPool:   constructor() does not check any of the provided addresses.   initialize() does not check that _root is not 0.   setTokenSeller() does not check that _seller is not address(0).   setOperatorManager() does not check that _operatorManager is not address(0).  BobVault:   constructor() does not check that _bobToken is not address(0).   setYieldAdmin() does not check that _yieldAdmin is not address(0).   setInvestAdmin() does not check that _investAdmin is not address(0).  BOB Protocol - zkBob -   15  DesignLowVersion1CodeCorrected        \f  Checks  were  added  where  necessary.  Explanation  was  added  why  certain  cases  do  not  need  sanity checks.  BOB Protocol responded:  We added a few sanity checks in places there we think they might be important:   ZkBobPool: constructor(), initialize(), setOperatorManager()   BobVault: constructor()  In other places, zero addresses are used for unsetting the specific privileges and rights:   ERC20Blocklist:  updateBlocklister()  \u2013  zero  address  is  used  to  limit  the  ability  to  block/unblock  accounts only by the governance.   ERC20Recovery: setRecoveryAdmin() \u2013 zero address is used to limit the ability to recover funds only  by  that recoveredFundsReceiver  is  not  zero  in  _remainingRecoveryLimit  (link)  so  it  is  safe  to  not introduce additional checks  the  governance.  setRecoveredFundsReceiver()  \u2013   is  a  check   there    Claimable: setClaimingAdmin() \u2013 zero address is used to limit the ability to claim tokens only by  the governance.   ZkBobPool: setTokenSeller() \u2013 zero address is used to disable the ability for users to swap small  amount of BOB tokens to MATIC during the withdrawal process.   BobVault: setYieldAdmin() - zero address is used to limit the ability to collect generated yield by the governance; setInvestAdmin() \u2013 zero address is used to limit the ability invests tokens into the yield provider only by the governance.  Moreover,  these  functions  should  only  be  called  by  the  admin  via  governance  process  (e.g.  from Safe UI), making real UI typos very unlikely to happen.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   No Events on State Changes", "body": "  Many  state-changing  operations  do  not  emit  events.  Consider  emitting  events  for  important  state changes.  These operations include:  ZkBobPool:   initialize()   setTokenSeller()   setOperatorManager()  ZkBobAccounting:   _setLimits()   _resetDailyLimits()   _setUsersTier()  BobVault:   setYieldAdmin()  BOB Protocol - zkBob -   16  DesignLowVersion1CodeCorrected        \f setInvestAdmin()  MutableOperatorManager:   _setOperator()  ERC20Recovery:   setRecoveryAdmin()   setRecoveredFundsReceiver()   setRecoveryLimitPercent()   setRecoveryRequestTimelockPeriod()  Claimable:   setClaimingAdmin()    Events were added to the following functions:  ZkBobPool:   setTokenSeller()   setOperatorManager()   withdrawFee()  ZkBobAccounting:   _setLimits()  MutableOperatorManager:   _setOperator()  The remaining functions are either not expected to be called regularly, or it was deemed unimportant for the functions to emit events.  BOB Protocol - zkBob -   17  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   BobVault.disableCollateralYield Potential", "body": " Reentrancy  The  token  buffer,  dust  and  yield  fields  are  updated  after  the  external  call.  If  the  yield  contract  has  a reentrancy point, where BobVault can be called again - this update can happen in an invalid state. The external calls should happen after all the state variable updates.    Statements were reordered to make the reentrancy impossible.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   ERC20Permit Deletes Existing Approvals", "body": "  Using any of the public functions in ERC20Permit will zero out any pre-existing approval a user may have had  from  the  signer.  Hence,  a  user  should  use  any  existing  approval  from  the  signer  before  calling permit or its variations.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Incorrect Comment", "body": "  In the CustomABIDecoder contract, the _memo_fixed_size function features the following comment:  else if (t == 2) {     // fee + recipient + native amount     // 8 + 20 + 8     r = 36; }  in   However,  is  actually ... | fee | native_amount | receiver | .... The given sizes for the fields are correct (but also in the wrong order).  the  case  of  a  Withdraw  operation   in  calldata   the  order     The comment was fixed.  BOB Protocol - zkBob -   18  NoteVersion1NoteVersion1NoteVersion1            \f7.4   Reentrant Tokens  The BobVault contract should not use any tokens with reentrant transfers, such as an ERC777 token, as collateral.  This  could  lead  to  inconsistent  event  orderings  or  potentially  more  severe  issues.  This  audit was performed with the assumption that any tokens used as collateral do not have reentrant functionality.  Similarly,  the  ZkBobPool  contract  should  not  use  an  underlying  token  with  reentrant  calls,  as  it  would open  up  critical  vulnerabilities  such  as  draining  the  contract's  balance  through  the  withdrawFee function.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Unused Constant", "body": "  In CustomABIDecoder.sol, the sign_r_vs_size constant is defined but never used.  BOB Protocol responded:  We  won\u2019t  delete  the  constant,  as  keeping  it  does  not  impact  the  size/gas  cost  of  the  produced bytecode (most likely it is being pruned by the optimizer), but it might become useful in the future, for adding more extra fields.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   Unused Return Data in YieldConnector", "body": "  The  YieldConnector's  _delegateFarmExtra  function  does  not  return  anything,  even  though  the farmExtra function of the IYieldImplementation interface returns a bytes type.  Similarly,  the  claimTokens  function  of  the  Claimable  contract  does  not  check  the  return  value  of IERC20(_token).transfer(_to,  balance).  Hence,  false  could  be  returned  (meaning  the transfer did not actually take place).    BOB Protocol responded:  Acknowledged  and  added  missing  function.  The _delegateFarmExtra()  function  is  unused  in  the  context  of  existing  AAVE  deployments,  however,  it to might  be  used  IERC20(_token).transfer(_to,  balance)  in  the  Claimable  contract  are  only  intended  to  be  executed within the manual governance process, thus actual transfer result does not imply any considerable impact on the system.  (e.g.  Compound).  Calls   return  statement   lending  markets   integrations   farmExtra()   for  other   from   BOB Protocol - zkBob -   19  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   extract32's Input Is Not Cached", "body": "  The  input  b  of  the  built-in  extract32  is  not  cached  but  instead,  only  its  location  and  length  are.  This means that if the evaluation of the argument start's side effect leads to the modification of b, the result of extract32 could be inconsistent and access memory out of bounds.  CS-VYPER_DECEMBER_2023-001  Vyper - Vyper Compiler -   11  DesignCorrectnessCriticalHighMediumLowCorrectnessMediumVersion1              \fexample,   foo  For  b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'  function   calling   the   of   the   following   contract   returns  var:Bytes[96]  @internal def bar() -> uint256:     self.var = b'uuuuuuuuuuuuuuuuuuuuuuuuuuuuuu'     self.var = b''     return 3  @external def foo() -> bytes32:     self.var = b'abcdefghijklmnopqrstuvwxyz123456789'     return extract32(self.var, self.bar(), output_type=bytes32)     # returns b'uuuuuuuuuuuuuuuuuuuuuuuuuuu\\x00\\x00789'  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Assertion Error _abi_encode With Invalid", "body": " Method ID  If _abi_encode is given a literal method ID that is not 4 bytes long, the compiler will fail on an assertion in  _parse_method_id  during  code  generation  instead  of  failing  at  type-checking  time  with  some meaningful error message.  The following contract would fail to compile with an AssertionError:  CS-VYPER_DECEMBER_2023-002  @external def foo():     a:Bytes[68] = _abi_encode(b'', method_id=b'')  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   Buffer Too Large in ", "body": " create_minimal_proxy_to  In  CreateMinimalProxyTo._build_create_IR(),  the  buffer  buf  uses  128  bytes  of  memory, however, MSTORE is performed at buf, buf + 19 and buf + 39. This means that a buffer of length 96 would be sufficient to store the whole creation bytecode.  Note  that  although  the  bytecode  stored  in  the  buffer  is  only  54  bytes  long,  a  buffer  of  64  bytes  is  not sufficient because the last MSTORE is unaligned and would write to the next 32-byte word.  CS-VYPER_DECEMBER_2023-003  Vyper - Vyper Compiler -   12  DesignLowVersion1DesignLowVersion1              \f5.4   Builtins Fail to Compile With Empty  ByteStringT  In  general,  BytesT  and  StringT  IR  nodes  are  assumed  to  be  locations  to  values  of  the  mentioned types. However, the special value empty(...) is not and is treated as a special case by the compiler.  The  compiler  fails  compilation  when  the  given  builtins  are  given  empty  ByteString:  concat, extract32 and slice.  The compilation of the following three contracts respectively fails with the following errors:  CS-VYPER_DECEMBER_2023-004   CompilerPanic: tried to modify non-pointer type   AssertionError: ~empty <empty(Bytes[32])>   AttributeError: 'NoneType' object has no attribute 'load_op'  @external def baz() :     a:String[32] = concat(empty(String[31]), \"a\")  @external def foo() :     a:Bytes[32] = slice(empty(Bytes[32]), 0, 1)  @external def bar() :     a:uint256 = extract32(empty(Bytes[32]), 0, output_type = uint256)  Note that for both extract32 and slice, if it wasn't for this issue, either the compilation would fail, or the execution would revert as slicing/extracting 32 bytes from an empty byte array is not possible.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.5   Condition Always True in raw_call", "body": "  In RawCall.fetch_call_return(), the following if block is always evaluated since if outsize is None or 0, the function is returning earlier.  CS-VYPER_DECEMBER_2023-005  if outsize.value:     return_type = BytesT()     return_type.set_min_length(outsize.value)      if revert_on_failure:         return return_type     return TupleT([BoolT(), return_type])  Vyper - Vyper Compiler -   13  DesignLowVersion1DesignLowVersion1            \f5.6   Delegate or Static raw_call With Value  Although both EVM's delegatecall and staticcall opcode cannot be given some value to be sent with  the  call,  raw_call  does  not  prevent  having  a  non-null  value  when  is_delegate_call  or is_static_call is set to true. Note that the value is then ignored when generating IR/bytecode for the call.  CS-VYPER_DECEMBER_2023-006  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.7   Expression Builtins Are Treated as", "body": " Statements  The following builtins are in STMT_DISPATCH_TABLE although they cannot be used as statements since they return a value:  CS-VYPER_DECEMBER_2023-007   create_minimal_proxy_to   create_forwarder_to   create_copy_of   create_from_blueprint  Although using them as statements will currently raise a StructureException, it would be better to remove them from STMT_DISPATCH_TABLE altogether.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.8   Imprecise Out-Of-Bounds Check for slice", "body": "  In the function Slice.fetch_call_return, when is_adhoc_slice is false and start_literal is not None, the following check is performed:  CS-VYPER_DECEMBER_2023-008  if start_literal > arg_type.length:     raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)  To be more precise, one could also raise if start_literal == arg_type.length.  The following contract currently compiles (but calling foo() reverts) although the slice can be inferred to be out of bounds at compile time:  @external def foo():     a:String[3] = \"foo\"     l: uint256 = 1     b:String[3] = slice(a,3,l)  Vyper - Vyper Compiler -   14  DesignLowVersion1DesignLowVersion1DesignLowVersion1                  \f5.9   Inconsistent Folding of keccak256  Although the built-in keccak256 function should only accept StringT, bytes32 and BytesT types, it also accepts bytesN where N!=32 provided that the node is folded. In other words, the semantics of the built-in differ when it is folded or not.  CS-VYPER_DECEMBER_2023-009  @external def foo():     v:bytes1 = 0x12      a:bytes32 = keccak256(0x12) # compiles     b:bytes32 = keccak256(v) # does not compiles     c:bytes32 = keccak256(0x1111111111111111111111111111111111111111111111111111111111111111111111) # compiles  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.10   Inconsistent Folding of len", "body": "  The built-in len can be folded when given some literal Hex node but the compilation fails if given some non-literal bytesN as the type is not accepted.  CS-VYPER_DECEMBER_2023-010  @external def foo():     a:uint256 = len(0x12) # compiles     x:bytes1 = 0x12     b:uint256 = len(x) # does not compile  Moreover,  no  restriction  is  enforced  on  the  length  of  such  literal  Hex  nodes  when  used  in  len,  which could mean that there is a Hex value for which no Vyper type can be inferred (The program would not compile if it wasn't for folding).  @external def foo():     # length of 35 is not allowed for bytesN     a:uint256 = len(0x1111111111111111111111111111111111111111111111111111111111111111111111)  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.11   Inconsistent Folding of shift", "body": "  The  built-in  shift  only  accepts  non-negative  values  x  when  folding  is  performed  but  in  the  case  the operation is done at runtime, any (negative) int256 value is accepted.  CS-VYPER_DECEMBER_2023-011  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.12   Incorrect Error Message", "body": "  CS-VYPER_DECEMBER_2023-012  Vyper - Vyper Compiler -   15  DesignLowVersion1DesignLowVersion1DesignLowVersion1DesignLowVersion1                      \fExtract32.infer_kwarg_types()  may  raise  an  InvalidType  exception  if  output_type  is  not valid,  says the  \"Output  type  must  be  one  of  integer,  bytes32  or  address\"  although  any  bytesX  is valid.  however,   message   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.13   Incorrect Type Checking for slice", "body": "  CS-VYPER_DECEMBER_2023-013  When providing to the builtin slice a byte array which is an Attribute AST node whose attribute is code (for example a struct field access), the function Slice.fetch_call_return will misunderstand the  byte  array  as  msg.code  (is_adhoc_slice  evaluates  to  true),  leading  to  several  checks  being missed.  In  the  current  state  of  the  compiler,  this  is  not  an  issue  because  of  #3521_  as  the  compilation  would revert  with  a  TypeCheckFailure.  However,  if  the  issue  is  fixed  with  PR3527,  the  issue  described above would arise.  For example in the following contract, assuming that PR3527 is merged, the declaration of b will compile, but the declaration of c will not.  struct A: code: String[4] not_code: String[4]  @external def foo() -> uint256:     a:A = A({code: \"abc\",not_code: \"abc\"})     b:String[4] = slice(a.code, 1,0) # compiles     c:String[4] = slice(a.not_code, 1,0) # does not compile     return b  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.14   Redundant Validation _abi_decode", "body": "  CS-VYPER_DECEMBER_2023-014  In  ABIDecode.infer_arg_types(),  self._validate_arg_types()) is called just before and performs the same validation  to  validate_call_args()   the  call   is  redundant  as  validate_call_args(node, expect_num_args, list(self._kwargs.keys()))  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.15   Unused Allocated Memory in raw_call", "body": "  In  the  case  raw_call  is  given  max_outsize=0,  the  function  RawCall.build_IR  still  allocates  32 bytes for output_node. This is not necessary and could be avoided.  CS-VYPER_DECEMBER_2023-015  Vyper - Vyper Compiler -   16  CorrectnessLowVersion1DesignLowVersion1DesignLowVersion1                    \f5.16   extract32 and slice With Transient Storage  In the builtins extract32 and slice, given that storage is addressed in words, some custom logic is implemented  when  the  given  buffer  lives  in  the  storage  as  opposed  to  other  locations  that  are  byte addressable.  Since  transient  storage  will  also  be  addressed  in  words,  a  similar  logic  should  be implemented for buffer in transient storage.  CS-VYPER_DECEMBER_2023-016  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.17   shift's Incorrect Return Type", "body": "  The  class  Shift  defines  _return_type  as  UINT256_T  but  is  never  used  since BuiltinFunctionT.fetch_call_return()  is  overridden  by  Shift  to  return  the  type  of  the argument x which can differ from UINT256_T.  it   CS-VYPER_DECEMBER_2023-017  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.18   sqrt Colliding Fresh Variables", "body": "  The built-in sqrt calls generate_inline_function to compile some piece of Vyper code to IR using a  new  context.  As  the  context  is  new,  the  fresh_varname  counter  is  reset  and  does  not  follow  the counter  of  the  initial  context.  This  can  lead  to  the  collision  of  variables,  as  shown  in  the  following examples where the loop iterators are colliding and leading to the compiler panicking:  CS-VYPER_DECEMBER_2023-018  @external def foo() : # the loop iterator variable of each sqrt's loop collide a:decimal = sqrt(sqrt(100.0))  @external def foo() : # The loop iterator of sqrt collides with the range iterator for i in range(10):     a:decimal = sqrt(100.0)  Vyper - Vyper Compiler -   17  DesignLowVersion1DesignLowVersion1DesignLowVersion1                \f6   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   EIP1167 Bytecode Sanity Checks", "body": "  CS-VYPER_DECEMBER_2023-019  The  function  eip1167_bytecode  returns  the  EIP1167  bytecode  as  well  as  a  \"loader\"  used  to  deploy the bytecode. As the resulting bytecode is known and should be constant across Vyper versions, having sanity checks comparing the different outputs of assembly_to_evm with hardcoded bytecode could be a good failsafe.  Moreover,  the  length  of  different  bytecode  sections  is  used  (e.g  0x2D,  the  sum  of  the  lengths  of  the forwarder_pre_asm, the address and the forwarder_post_asm), having sanity check that makes sure that such literal integer is indeed equal to the length of the given bytecode section would increase both readability and maintainability of the code.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   extract32 Unnecessarily Complex", "body": "  the  built-in  Extract32.buildIR  seems  unnecessarily  complex  and  could  probably  be  simplified similarly to the slice slice. In particular, for locations that are byte-addressable when start is not word aligned,  the  use  of  a  helper  like  copy_bytes  could  avoid  the  need  for  loading  two  words  and  then masking and shifting.  CS-VYPER_DECEMBER_2023-020  Vyper - Vyper Compiler -   18  InformationalVersion1InformationalVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Missing Input Sanitization", "body": "  1. The addresses in the constructor of GovernorV3 are not sanitized.  CS-GEARGOV-002  2. The   addresses   and GovernorV3.updateVetoAdmin()  are  not  sanitized.  Even  though  the  veto  admins  are expected to prevent setting addresses wrong, the contract logic should also prevent it.  GovernorV3.addQueueAdmin()   given   to   3. The eta parameter of the GovernorV3.queueTransaction is only sanitized by the Timelock contract as to whether the execution time is beyond some minimum required delay. Moreover, an action can be executed within a time window. However, there's no check on whether all the batched actions can be executed within the same window. Thus, a batch could be submitted but not be able to be executed.    In version 2, the eta is defined on a per-batch basis. All transactions in the batch should have the same eta.  Gearbox - Gearbox V3 Governance -   11  CriticalHighMediumLowCodeCorrectedDesignLowVersion1CodeCorrected        \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Veto Admin Can Veto Its Own Update", "body": "  In  the  GovernorV3  (Governor  in  V2)  contract,  with  the  assumption  that  vetoAdmin  is  a  multisig requiring fewer signatures than the queueAdmins, it is theoretically easier to compromise vetoAdmin rather  one  of  the  queueAdmin.  If  some  keys  of  the  vetoAdmin  multisig  are  compromised,  all  the queued  transactions  could  be  vetoed  including  a  veto  admin  update.  This  issue  is  only  relevant  if  the multisig does not allow the rest of the signers to replace the compromised keys.  CS-GEARGOV-001  Gearbox - Gearbox V3 Governance -   12  InformationalVersion1  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Missing Sanity Checks", "body": "  When  opening  a  short  position  in  the  Gearbox  system  by  calling  shortOpenUniV2,  the  user  must provide  multiple  parameters.  These  parameters  are  not  sanitized,  thus  arbitrary  behavior  may  occur. More  specifically  it  is  never  checked  that  path[path.length  -  1]  ==  collateral  and collateral == longParams.path[0].  The  lpInterface  and  lpContract  in  the  struct  LongParameters  used  in  _openLong  are  not checked  to  match.  Similarly,  an  arbitrary  router  can  be  passed  as  shortSwapContract  as  long  as there is an adapter for it. Note that this is currently not an issue since different adapters/routers do not share the same interface and the transaction would revert. However, the addition of more adapters in the future might require some kind of sanity check.  Code partially corrected:  shortOpenUniV2 now features an additional check ensuring that the token out of the exchange using shortSwapContract  is  the  collateral.  Similar  checks  have  been  added  to  openShortUniV3  and openShortCurve.  Gearbox Protocol - Gearbox -   11  SecurityDesignCorrectnessCriticalHighMediumLowCodePartiallyCorrectedDesignLowVersion4CodePartiallyCorrected             \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  3  8  12  -Severity Findings  -Severity Findings  Incorrect Arguments in checkCollateralChange    Non-Accessible Credit Accounts    Retain Ownership of Credit Account   -Severity Findings   DoS of LeverageActions   Incorrect params.amountOutMinimum    Contracts Implement Proxy Pattern    Trust Model of External Adapters    Users Can Avoid Paying Fees On Closure    Wrong Approval To Pool    maxAmount Can Be Circumvented   takeOut May Break the Account List   -Severity Findings   Discrepancy Between openShortUniV2 and openShortUniV3    Use of transfer    Rounding Errors    Head Cannot Be Taken Out    Pointers Not Updated On takeOut    Redundant Multiplication    Storage Optimizations    Taking Out the First-Ever Created Account    allowToken Can Be Blocked    cancelAllowance Cannot Be Called    connectCreditManager Access Control    rayMul and rayDiv Are Used With No Ray Values   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Incorrect Arguments in ", "body": " checkCollateralChange  Gearbox Protocol - Gearbox -   12  CriticalHighCodeCorrectedCodeCorrectedCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion2CodeCorrected             \fIn  YearnV2.withdraw(uint256,  address,  uint256),  the  checkCollateralChange  is  called with wrong arguments. Particularly, the following snippet is used:  creditFilter.checkCollateralChange(     creditAccount,     token,     yVault,     balanceInBefore.sub(IERC20(yVault).balanceOf(creditAccount)),     balanceOutBefore.add(IERC20(token).balanceOf(creditAccount)) );  Note that token is the tokenOut in this particular case, we convert yVault tokens to the underlyings and yVault is the tokenIn. This error later results in querying the oracles with wrong balances.  Code Corrected:  The arguments are now passed correctly to checkCollateralChange.  *While the final round of the review was ongoing Gearbox Protocol informed us of an issue in the new implementations  of  the  adapters.  The  adapters  were  calculating  the  delta  of  the  incorrectly  and  hence were passing wrong parameters to `checkCollateralChange`. The issue has been fixed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Non-Accessible Credit Accounts", "body": "  The transferAccountOwnership function of a CreditManager contract allows the owner of a credit account to transfer it onwards to a new owner. Per CreditManager an address is only allowed to hold one credit  account.  trasferAccountOwnerhip().  However,  there  is  no  check  on  whether  the  recipient already  holds  a  credit  account  at  this  CreditManager  contract  and  simply  overwrites  the  entry  for  the credit  account  of  the  recipient.  Hence  a  credit  account  which  holds  funds  can  become  non-accessible and its funds will be trapped.    In the updated code the transferAccountOwnership function no longer overwrites an existing credit account entry of the recipient, hence the issue no longer exists.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Retain Ownership of Credit Account", "body": "  In Gearbox, Credit Accounts are reused after they have been returned to the factory. Due to a reentrancy issue, account ownership can be retained and after the next user got this credit account assigned, the previous owner may access its funds belonging to the new owner.  Function transferAccountOwnership does not feature the non nonReentrant modifier and hence can be executed during another operation. Consider the follwowing scenario:  Alice owns a healthy credit account 0xA which holds some WETH balance.  1. Alice prepares a contract that allows her to execute all necessary actions. As a first step, the credit  account ownership is transferred to this contract.  Gearbox Protocol - Gearbox -   13  SecurityHighVersion1CodeCorrectedSecurityHighVersion1CodeCorrected                \f2. The credit account is repaid using repayCreditAccount specifying the contract as to address. This  transfers  all  assets  to  the  provided  to  address.  Notably  the  WETH  asset  is  unwraped  into Ether, the Ether is transferred in a call to the reciepient's address to. This call executes code at the contract.  3. At  the  specified  to  address  a  contract  exists.  This  contract  transfers  the  ownership  of  the  credit that  (newAddress)  Alice  controls.  This  means   to  another  address  account  onwards  creditAccounts[newAddress] will point to the credit account  4. The closure of the credit account continues as normal. All assets are transferred to address to, the  debt is repaid to the pool and the credit account is returned to the AccountFactory.  5. Next delete creditAccounts[borrower]; is executed, this should delete the assignment of this  credit  account  to  the  borrower.  However,  as  we  already  transferred  the  ownership  from borrower which is the contract address back to Alice, creditAccounts[borrower] contains no entry at this point and deleting it has no effect.  At the end of this sequence, the credit account has been returned to the AccountFactory but the entry creditAccounts[newAddress] in this CreditManager still points to this account.  The  next  time  this  CreditAccount  is  reused  at  the  same  CreditManager  by  a  new  user,  due  to  the entry  in  creditAccounts  Alice  will  still  have  access  to  this  account  and  can  collect  its  funds  by  e.g. closing or repaying the account.    transferAccountOwnership()  now  features  the  nonReentrant  modifier.  Hence,  the  reentrancy issue described is no longer possible.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   DoS of LeverageActions", "body": "  LeveragedActions can be blocked completely or for specific collaterals only in different ways:  1. When  opening  an  account  the  credit  manager  will  check  if  onBehalfOf  already  has  an account. In case a malicious user has already transferred the ownership of a credit account to the LeverageActions contract then the CreditManager will fail to open a new one:  function openCreditAccount(     ...     require(         !hasOpenedCreditAccount(onBehalfOf) && onBehalfOf != address(0),         Errors.CM_ZERO_ADDRESS_OR_USER_HAVE_ALREADY_OPEN_CREDIT_ACCOUNT     ); // T:[CM-3]     ...  2. Although this is more a theoretical attack, assume a credit manager which prohibits the user to invest more that A amount of tokens. A malicious user sends to the the contract A + 1 tokens. When the contract will try to open a leveraged position it will do so using the total balance of the token  it  holds.  If  this  amount  is  greater  than  the  allowed  one  the  account  opening  will  block. The snippets which dictate the above behavior are the following:  LeverageActions:  function _openLong(LongParameters calldata longParams, uint256 referralCode){  Gearbox Protocol - Gearbox -   14  DesignMediumVersion4CodeCorrected        \f    ...     uint256 amount = IERC20(collateral).balanceOf(address(this)); // M:[LA-1]     ... }  CreditManager:  function openCreditAccount(     ...     require(         amount >= minAmount &&             amount <= maxAmount &&             leverageFactor > 0 &&             leverageFactor <= maxLeverageFactor,         Errors.CM_INCORRECT_PARAMS     ); // T:[CM-2]     ... }    For the case #1, an allowance system was implemented for the transfer of credit account. In order to get a credit account transferred, the receiver needs to pre-approve the sender of the credit account. Hence one  can  no  longer  transfer  a  credit  account  to  the  LeveragedAction  contract  and  the  issue  no  longer exists.  To mitigate case #2 the LeveragedActions contract now uses the actual balance difference.  *Moreover, Gearbox Protocol pointed out a third way to use the attack described above. Specifically, a user  can  open  an  account  on  behalf  of  the  LeverageAccount  contract  which  would  result  in  a Denial-of-Service  for  the  LeverageAction  contract.  The  issue  has  been  resolved  by  also  restricting  the address on behalf of which the credit account is opened.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Incorrect params.amountOutMinimum", "body": "  The  parameter  params.amountOutMinimum  passed  to  the  call  to  the  UniswapV3  adapter  in _openLong() is calculated incorrectly and does not include the leverage.  _openLong  executes  a  swap  using  the  funds  of  the  opened  leveraged  account  given  the  swap parameters in longParams. The relevant parameters for the swap are in bytes swapCalldata which are  first  extracted  and  prepared  for  the  call  to  the  swap  contract.  Note  however  the  parameters representing  amountIn  and  amountOutMinimum  extracted  from  swapCalldata  do  not  include  the leverage, hence the actual values for the swap have to be calculated:  else if (longParams.swapInterface == Constants.UNISWAP_V3) {     ISwapRouter.ExactInputParams memory params = abi.decode(         longParams.swapCalldata,         (ISwapRouter.ExactInputParams)     );      params.amountIn = leveragedAmount;     params.amountOutMinimum = params     .amountOutMinimum  Gearbox Protocol - Gearbox -   15  CorrectnessMediumVersion4CodeCorrected        \f    .mul(leveragedAmount)     .div(params.amountIn);     ISwapRouter(adapter).exactInput(params);     (, asset) = _extractTokensUniV3(params.path); }  First params.amountIn is overwritten with leveragedAmount. Next params.amountOutMinimum is calculated, this calculation uses params.amountIn which is equal to leveragedAmount at this point.  Hence  the  params.amountOutMinimum.mul(leveragedAmount).div(params.amountIn);  actually  params.amountOutMinimum.mul(leveragedAmount).div(leveragedAmount);  simplifies to params.amountOutMinimum.  calculation: is which  The leverage is not included in params.amountOutMinimum.    The calculation of the leveraged value for params.amountOutMinimum is now done correctly using the unchanged  value  of  to leveragedAmount afterwards.  the  decoded  params.amountIn.  params.amountIn   is  only  set   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Contracts Implement Proxy Pattern", "body": "  All adapters and the YearnPriceFeed contract inherit from OpenZeppelin's abstract Proxy contract and implement an _implementation function pointing to the address of the 3rd party system contract the adapter connects to. However, this proxy functionality is not needed nor used. The intended functionality of the adapter is implemented in functions inside the adapter contract itself.  Inheriting the proxy contract, however, has serious consequences. Calls to non-existing functions in the contract  execute  the  fallback  function,  which  is  implemented  by  the  inherited  proxy.  This  function forwards the call by delegate-calling into the implementation contract. During a delegate-call, the code at the target is executed in the context of the caller. Notably, it is read from and written to the storage of the caller,  the  adapter  contract.  This  can  have  an  adverse  effect  on  the  stored  variables  of  the  adapter contract. For example the stored values for the creditManager or the creditFilter.    The adapter contracts were rewritten and the proxy pattern was removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Trust Model of External Adapters", "body": "  The  trust  model  for  the  external  adapters  has  not  been  properly  specified.  Moreover,  all  four  available adapters behave differently and the assumptions these adapters rely on have not been documented.  After the action on the external system which is invoked by an adapter, there is a check on the collateral of the credit account. All currently available adapters use the following function which takes the following parameters:  Gearbox Protocol - Gearbox -   16  SecurityMediumVersion1CodeCorrectedDesignMediumVersion1Speci\ufb01cationChangedCodeCorrected                  \ffunction checkCollateralChange(     address creditAccount,     address tokenIn,     address tokenOut,     uint256 amountIn,     uint256 amountOut )  The  concern  is  about  what  is  passed  as  amount  especially  for  the  spent  asset.  It  is  vital  that  these amounts represent the actual state of the credit accounts holding or the check may be circumvented.  Some adapters rely on the values returned by the 3rd party system, some query the actual balance.  While  querying  the  actual  balance  for  the  assets  involved  in  the  action  is  the  safest  option,  it  may  be expensive  in  terms  of  gas.  However  note  that  in  the  current  implementation  of  the  EVM  (London hardfork), repeated access to the same contract/storage location got significantly cheaper the overhead in terms of gas may not be that big.  Using values returned by the call to the third-party contract may be an option if the third-party contract is fully  trusted  to  do  so  correctly.  Similarly,  this  holds  for  input  parameters.  This  critical  part  should  be documented  and  assessed  thoroughly.  In  case  of  doubts/uncertainties,  it  may  be  safer  to  query  the balances and calculate the delta of the balances and use this.  Regarding  the  YearnAdapter,  it  can  be  inspected  and  documented:  Querying  the  balances  could  be Vault.withdraw avoided  [https://github.com/yearn/yearn-vaults/blob/main/contracts/Vault.vy]  return  the  change  in  the  balance  of the tokens of interest. However, the current YearnAdapter does not do this but queries the balance and calculates the delta.  Vault.deposit   since   both   and   The  UniswapV3  Adapter  relies  on  the  returned  values  by  the  3rd  party  system.  However,  there  is  no documentation why this assumption holds.  Specification changed and code corrected:  A pattern of how all adapters should be built has been created. All existing adapters have been rewritten to adhere to this pattern: The balance is queried before and after the action and the difference is used for the check of the collateral change.  Note that due to the existing token allowances for the adapters from the credit accounts these checks are not 100% failsafe. It is vital that the 3rd party system is fully trusted to not transfer any other tokens of the credit  account.  The  system  performs  the  fast  check  only  for  the  tokens  passed  as  arguments  to  the check. Any other change in balance will be ignored.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Users Can Avoid Paying Fees On Closure", "body": "  On  account  closure,  all  the  assets  held  by  the  account  are  converted  to  the  underlying  token  through defaultSwapContract which is set to be UniswapV2. For this conversion, the user defines a path of tokens to the underlying. This path can contain arbitrary tokens, tokens even controlled by the user. A check  in  _closeCreditAccountImpl  assures  that  the  closure  of  a  credit  account  will  not  lead  to losses for the protocol i.e., require(loss <= 1). On the closure of an account users are supposed to return to pool the amount they borrowed, the interest accrued for that amount and an extra amount for fees  namely,  feeSuccess  and  feeInterest.  It  is  important  to  note  that  if  the  funds  do  not  suffice totalFunds < amountToPool then only the borrowed amount with the interest accrued is returned and no fees are required to be paid. This means that draining a credit account to the point that does not make losses can allow a user to avoid paying fees to the protocol.  Gearbox Protocol - Gearbox -   17  DesignMediumVersion1CodeCorrected        \fCode Corrected:  A new check has been introduced which requires that remainingFunds > 0. This way it is guaranteed that the user has paid their fees. Due to this requirement, a closure that does not result in fee payout will be reverted. Hence, the only option for the users will be to repay.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.9   Wrong Approval To Pool", "body": "  *While the review was ongoing Gearbox Protocol informed us about this issue independently in parallel.  In the WETHGateway.repayCreditAccountETH an approval is given to the pool:  _checkAllowance(pool, amount); // T: [WG-11]  However, this approval is wrong and should be given to the credit manager who performs the transfer from the WETHGateway to the pool.    The code has been corrected in a further commit and the allowance is now given to the CreditManager instead of the pool in order for the credit manager to be able to transfer the tokens from the user to the pool.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.10   maxAmount Can Be Circumvented", "body": "  When opening a credit account, a check of the amount invested is performed:  require(     amount >= minAmount && amount <= maxAmount,     Errors.CM_INCORRECT_AMOUNT );  By limiting the amount originally invested, one can limit the amount of leverage that can be borrowed by the pool. However, this limitation can be circumvented as follows:  1. The user opens an account with an allowed account.  2. She calls CreditManager.addCollateral.  3. She calls increaseBorrowedAmount.  Note, that addCollateral does not perform any checks and increaseBorrowedAmount only checks that the borrowed amount does not turn the account unhealthy.  Code Corrected:  The  implementation  has  been  extended  to  prevent  increasing  the  borrowed  amount  more  than  the predetermined maximum:  Gearbox Protocol - Gearbox -   18  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \frequire(      borrowedAmount.add(amount) <          maxAmount.mul(maxLeverageFactor).div(              Constants.LEVERAGE_DECIMALS          ),      Errors.CM_INCORRECT_AMOUNT  );  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.11   takeOut May Break the Account List", "body": "  The  configurator  can  take  out  an  account  by  calling  AccountFactory.takeOut().  During  account removal, there is no check whether this is the tail nor is the tail updated in case this account is taken out. Should the tail account be taken out this is problematic:  New  accounts  added  will  not  be  connected  to  the  original  list,  hence  they  cannot  be  taken  using takeCreditAccount() which takes the head of the original list.  Similarly,  returned  accounts  will  be  added  to  the  list  after  the  removed  tail  account  which  no  longer exists  in  the  list.  Again,  the  connection  to  the  original  list  starting  at  head  is  interrupted  and  these accounts cannot be used anymore.  Code Corrected:  The implementation has been extended to correctly update tail when the last account is taken out.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.12   Discrepancy Between openShortUniV2 and", "body": " openShortUniV3  LeverageAction.openShortUniV2  sets  the  deadline  for  the  short  swap  to  the  current  block timestamp:  bytes memory data = abi.encodeWithSelector(     bytes4(0x38ed1739), // \"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",     amountIn,     amountOutMin,     path,     address(this),     block.timestamp ); // M:[LA-5]  the  call  cannot   This  way  the  other  hand, LeverageAction.openShortUniV3  lets  users  define  the  deadline  themselves.  This  means  that  a transaction that takes long to be included into a block might fail.  to  a  passed  deadline.  On   fail  due     Gearbox Protocol - Gearbox -   19  DesignMediumVersion1CodeCorrectedDesignLowVersion4CodeCorrected                \fThe  code  of  openShortUniV2  was  changed  and  now  uses  the  user-specified  parameter  deadline instead  of  block.timestamp.  It's  the  caller's  responsibility  to  specify  a  proper  deadline.  With  this change, the behavior of the functions for UniV2 and V3 are now consistent.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.13   Use of transfer", "body": "  _returnTokenOrUnwrapWETH uses transfer instead of safeTransfer for transferring tokens. This call will fail for tokens which do not adhere to the ERC20 interface e.g., USDT.    The code was changed to use safeTransfer.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.14   Rounding Errors", "body": "  In CreditManager.increaseBorrowedAmount the following check is performed:  require(     borrowedAmount.add(amount) <         maxAmount.mul(maxLeverageFactor).div(             Constants.LEVERAGE_DECIMALS         ),     Errors.CM_INCORRECT_AMOUNT );  This check includes a division with Constants.LEVERAGE_DECIMALS which results in a rounding error. This error can be avoided, if one multiplies the left side of the inequality with the same value instead.  In  the  following  snippet  of  PoolService.expectedLiquidity  a  division  before  multiplication  takes place:  uint256 interestAccrued = totalBorrowed .mul(borrowAPY_RAY) .div(Constants.RAY) .mul(timeDifference) .div(Constants.SECONDS_PER_YEAR);  Division  before  multiplication  can  interestAccrued will be smaller.  result   in   rounding  errors.   In   this  particular  case,   the  Code Corrected:  Regarding the first issue, the division has been replaced with a multiplication. Regarding the second one, the order of operations has changed and the multiplications take place first.  Gearbox Protocol - Gearbox -   20  DesignLowVersion4CodeCorrectedDesignLowVersion2CodeCorrected                  \f6.15   Head Cannot Be Taken Out  Calling  AccountFactory.takeOut  requires  to  pass  the  previous  account  of  the  one  to  be  deleted (prev). This means that the head credit account of the list cannot be taken out since there is no prev defined for it.  Code Corrected:  The implementation has been extended to handle the removal of the head.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.16   Pointers Not Updated On takeOut", "body": "  A  credit  account  can  be  function AccountFactory.takeOut.  Under  normal  circumstances  this  account  cannot  be  accessed  again  by the function. However, consider the following scenario:  the  configurator  using   the  system  by   taken  out  of   1. The  controller  removes  the  head  account  (A1).  In  this  case,  the  head  is  just  updated  to  the second account (A2). Note that at the removal of the head, the pointers of the head account _nextCreditAccount[head] is not reset.  2. Later A2, the current head is also removed.  3. This  means  that  the  controller  can  take  out  A2  again  by  calling  takeOut(A1,  A2)  and  connect it to a new to address.  The  reason  for  the  above  is  that  _nextCreditAccount[A1]  is  not  updated  upon  removal  and  still points to A2 which has also been removed. The check  require(             _nextCreditAccount[prev] == creditAccount,             Errors.AF_CREDIT_ACCOUNT_NOT_IN_STOCK         );  is still satisfied despite the accounts being no longer part of the system.  Code Corrected:  The pointers are now updated correctly.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.17   Redundant Multiplication", "body": "  In PoolService.removeLiquidity a part of the amount requested by the user is sent back to them determined by withdrawMultiplier and an amount determined by the withdrawFee is sent to the treasury.  that withdrawMultiplier + withdrawFee == PERCENTAGE_FACTOR. These two amounts should add up to underlyingTokensAmount. Hence, there is no need to perform two safe multiplications with both withdrawFee and withdrawMultiplier and the following multiplication is redundant:  construction   know   we   By   Gearbox Protocol - Gearbox -   21  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \fIERC20(underlyingToken).safeTransfer(     ...     underlyingTokensAmount.percentMul(withdrawFee) ); // T:[PS-3, 34]  Code Corrected:  The  issue  has  been  resolved.  In  the  current  implementation,  only  one  multiplication  takes  place.  The amount  from underlyingTokensAmount.  subtracting  amountSent   calculated  by   is  now   treasury   sent   the   to   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.18   Storage Optimizations", "body": "  There are various small optimizations that can be applied to the contracts of the system to improve gas efficiency:  1. Storage variable can be declared as constants: In GearToken contract totalSupply can be  declared as constant.  2. Some functions can be declared as external:   AccountFactory.countCreditAccountsInStock()   CreditFilter.checkCollateralChange(address,address,address,uint256,uint256)   CreditFilter.allowedContractsCount()   CreditFilter.allowedContracts(uint256)   GearToken.delegate(address)   GearToken.delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)   GearToken.getPriorVotes(address,uint256)  3. Dead code which can be removed:   BytesLib.slice(bytes,uint256,uint256)   BytesLib.toUint24(bytes,uint256)  Code Corrected:  Issues 1. and 2. have been resolved. Regarding 3., the client states:  BytesLib functions are used in support contracts which are not in the scope  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.19   Taking Out the First-Ever Created Account", "body": "  The configurator can call AccountFactory.takeOut to remove an account completely and connect it to an address of their choice. To do so, they provide the address of the account to be removed and the address of the previous account in the list of the available accounts. Let us consider the addition of the  Gearbox Protocol - Gearbox -   22  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \ffirst-ever  created  account.  The  account  is  added  during  the  deployment  of  the  AccountFactory  i.e., when the constructor is invoked. At this point, both the head and the tail are 0. This means that in the following snippet, it holds _nextCreditAccount[0] == clonedAccount.  function addCreditAccount() public {     ...      _nextCreditAccount[tail] = clonedAccount; // T:[AF-2]      ...  first-ever  created  account.   Note that _nextCreditAccount[0] is never updated. This means that there is always a pointer at 0 to the  configurator  calls  takeOut  with  prev  ==  0x0  and the  creditAccount the first ever created account they can control it even though the account might be in use at the time of the call. In other words, there is always a pointer to the first ever created account even if the account is not in stock. The case above makes the following check in AccountFactory.takeOut and the error message emitted imprecise:  If   require(     _nextCreditAccount[prev] == creditAccount,     Errors.AF_CREDIT_ACCOUNT_NOT_IN_STOCK ); // T:[AF-15]  The check whether the account is in stock doesn't work as expected in the scenario described above.  Code Correct:  The  pointer  of  _nextCreditAccount[0]  now  points  to  address(0)  and  not  the  first-ever  created account.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.20   allowToken Can Be Blocked", "body": "  The purpose of creditFilter.allowToken is twofold. On one hand, it allows the system to use new tokens. On the other hand, in the case of an already registered token, it allows updating the liquidation threshold for this token.  Due to the bitmask optimization used, the following check assures that no more than 256 different tokens can be tracked by the system.  require(allowedTokens.length < 256, ...);  However,  in  the  unlikely  case  of  256  registered  tokens,  the  liquidation  threshold  cannot  be  updated anymore since the above check will fail, leading the transaction to revert.  Code Corrected:  The code has been corrected. The requirement will be satisfied when the function is called with a token for which tokenMasksMap[token] > 0 as shown in the following in snippet:  Gearbox Protocol - Gearbox -   23  DesignLowVersion1CodeCorrected        \frequire(     tokenMasksMap[token] > 0 || allowedTokens.length < 256, ... );  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.21   cancelAllowance Cannot Be Called", "body": "  When  an  account  is  closed,  it  is  returned  to  the  factory.  It  is  important  to  note,  however,  that  the allowances the account has given to other addresses remain in place. This can be dangerous in case of malfunctioning approved contracts. In order to mitigate this risk, the configurator is allowed to reduce or remove the allowances. This functionality is implemented by CreditManager.cancelAllowance. This function is supposed to be called by the factory. However, no function that calls cancelAllowance is implemented, thus the allowance cannot be revoked.  Code Corrected:  the  current  The  code  has  been  corrected.  AccountFactory.cancelAllowance which then calls CreditAccount.cancelAllowance.  implementation   the  configurator  can  call  In   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.22   connectCreditManager Access Control", "body": "  The  CreditFilter.connectCreditManager  function  does  not  implement  proper  access  control. The  first  caller  to  this  function  can  set  CreditManager  to  his  address.  This  does  not  pose  threat  to  the system but could lead to wasted deployments of the Credit Filter.  Code Corrected:  The code has been fixed, now only the configurator is allowed to set the creditManager for the filter.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.23   rayMul and rayDiv Are Used With No Ray", "body": " Values  PoolService.expectedLiquidity()  performs  a  multiplication  using  rayMul  passing totalBorrowed  as  a  parameter.  However  totalBorrowed  is  not  in  RAY  but  in  the  decimals  of  the underlying token.  uint256 interestAccrued = totalBorrowed.rayMul(     borrowAPY_RAY.mul(timeDifference).div(Constants.SECONDS_PER_YEAR) ); // T:[GM-1]  This contradicts the specification for rayMul which states the following:  * @dev Multiplies two ray, rounding half up to the nearest ray  Gearbox Protocol - Gearbox -   24  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \fSimilarly this applies for fromDiesel(). Additionally getDieselRate_RAY() uses and toDiesel() use rayDiv which is annotated with:  * @dev Divides two ray, rounding half up to the nearest ray    rayMul and rayDiv are now correctly used.  Gearbox Protocol - Gearbox -   25  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Blocking updateContributors", "body": "  block.   TokenDistributor.updateContributors  of can  TokenDistributor.updateVesting for each holder. Consider the following scenario: A receiver RA of  the  Vesting  contract  calls  setReceiver  to  an  address  RB  which  is  a  receiver  of  another  contract. Then for updateVesting(RA), it holds vestingContracts[RB].contractAddress != 0 which makes the transaction revert. This leads the execution of updateContributors to revert as well. Note that users do not have an incentive to change the receiver address to another's receiver address. Moreover, the  new  receiver  can  change  again  the  address  to  another  public  address  they  control.  This  would unblock the execution of TokenDistributor.updateContributors. However, it is up to the specific user to address the issue.  function  makes   The   use   This  just  affects  the  updateContributors  function  which  attempts  to  update  all  holders.  The unaffected holders can always be updated individually through updateVesting().  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Handling Of Reward Tokens", "body": "  Users  of  the  Gearbox  system  are  allowed  to  trade  through  specific  adapters.  Moreover,  the  credit accounts  are  only  enabled  to  access  the  balance  of  the  enabled  tokens  which  are  specified  by  the governance.  However,  there  might  be  the  case  where  one  of  the  allowed  tokens  accrues  rewards  in another token which is not part of the enabled tokens. Currently, users can only collect their rewards by repaying their accounts and receive the tokens which accrue the rewards.  Furthermore, rewards may be accrued by the credit account address e.g., due to a user interacting with a certain third-party system. Such a reward may be only claimable in the future, notably e.g., after a credit account user returned his account to the factory. Such a reward may be claimable by the next user of this credit account.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Liquidity Removal Not Always Possible", "body": "  Users can remove liquidity they have offered to the pool by calling PoolService.removeLiquidity. During this call, a transfer is performed from the pool to the msg.sender with the requested amount. It is important  to  be  aware  that  in  case  of  high  utilization  of  the  pool,  the  amount  requested  might  not  be available since it is used as leverage in some positions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Oracles Do Not Handle Stale Prices", "body": "  Gearbox Protocol - Gearbox -   26  NoteVersion7NoteVersion1NoteVersion1NoteVersion1              \fThe Gearbox system relies on chainlink oracles to derive the value of the assets a credit account holds. The chainlink interface allows the consumers of the data to know whether a price returned is stale or not timestamps  https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata. based  on  However, Gearbox does not take advantage of these timestamps meaning that stale data could be used by the system.  the   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Price Feeds Cannot Be Updated", "body": "  A price feed can be added by the configurator of the system by calling PriceOracle.addPriceFeed. The logic of the addition is implemented inside an if statement with the following condition:  if (priceFeeds[token] == address(0)) {  This  means  that  if  the  price  feed  for  a  token  T  is  already  defined  i.e.,  priceFeeds[T]  !=  0  then  it cannot be updated. This becomes important especially when it comes to custom price feed such as the yearn price feed which might require an upgrade at some point.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   Special ERC-20 Token Behavior May Be", "body": " Problematic  Some ERC-20 tokens have transfer fees. Supporting such tokens may lead to accounting errors as the actual amount received after a transfer may not match the expected amount, e.g. when funds are repaid to the pool.  Furthermore, note that the _convertAllAssetsToUnderlying() used during the closure of a credit account uses UniswapV2's swapExactTokensForTokens function which does not support token with transfer fees.  In general, when adding tokens to the system they should be carefully inspected for any special behavior such  as  hooks.  If  any  special  behavior  is  detected,  the  impact  on  the  system  should  be  evaluated carefully.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.7   Users Can Turn Their Account Liquidatable", "body": " Inadvertently  Gearbox uses fast check and health factor in order to prevent users from draining funds that should be returned back to the pool.  However  an  unaware  user  may  turn  his  account  into  a  liquidatable  state  inadvertently.  Consider  the following scenario:  Assume  that  a  healthy  account  holds  only  token  A  with  value  V_A  (in  the  underlying  token)  and  owes amount B. The health factor of the account is H_f = V_A * LT_A / B.  Now, this user trades the balance of A to token C, which is worth slightly when evaluated in the underlying asset.  After  the  trade  through  the  adapter  is  completed,  the  check  on  the  collateral  takes  place.  Let's assume  we're  eligible  for  the  fast  check  and  this  passes  as  the  value  in  terms  of  the  underlying  has increased.  Gearbox Protocol - Gearbox -   27  NoteVersion1NoteVersion1NoteVersion1            \fHowever,  it  could  be  that  the  liquidation  threshold  of  token  A  and  token  C  are  different,  e.g. LT_C << LT_A. This means that the health factor H_f' = V_C * LT_C / B may become less than 1 after the trade even though the value of the holdings has not been decreased.  Gearbox Protocol - Gearbox -   28  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   CurrentSupply Can Be Underestimated", "body": "  CapAutomator  computes  the  new  SupplyCap  based  on  the  current  supply,  the  gap,  and  the  max.  The current supply is estimated based on the scaled aToken total supply, the cached amount that should be accrued to treasury, and the last updated liquidity index.  CS-SPRKCAP-001  uint256 currentSupply = (             IScaledBalanceToken(reserveData.aTokenAddress).scaledTotalSupply()             + uint256(reserveData.accruedToTreasury)         ).rayMul(reserveData.liquidityIndex)         / 10 ** ERC20(reserveData.aTokenAddress).decimals();  The  liquidityIndex  could  be  underestimated  if  it  hasn't  been  updated  up  to  now  (interest  has  not been accrued for the period between reserveLastUpdateTimestamp and block.timestamp).  In  addition,  decimals  have  been  removed  for  currentSupply  to  align  with  gap  and  cap,  while  this rounds currentSupply down.  As  a  result,  currentSupply  could  be  underestimated  and  influence  the  new  cap  computation (_calculateNewCap()).  Risk accepted:  MakerDAO states:  We acknowledge and accept the fact that the current total value of the pool can be assumed slightly inaccurately.  MakerDAO - Sparklend Cap Automator -   9  SecurityDesignCorrectnessCriticalHighMediumLowRiskAcceptedRiskAcceptedDesignLowVersion1RiskAccepted           \f5.2   DoS Cap Increase  CapAutomator  allows  any  user  to  increase  the  supply  cap  by  gap  if  the  increaseCooldown  has passed.  // Cap cannot be increased before cooldown passes, but can be decreased if (newCap > currentCap     && block.timestamp < (capConfig.lastIncreaseTime + capConfig.increaseCooldown)) {         return currentCap;  CS-SPRKCAP-002  Furthermore,  the  computation  of  the  new  cap  relies  on  the  current  amount  of  liquidity  supplied  or borrowed:  uint256 newCap = _min(currentValue + capConfig.gap, max);  A malicious user supplying or borrowing funds can frontrun a call to execSupply(), execBorrow() or exec() to remove supply or repay his loan in order to manipulate currentValue.  More precisely, it is possible to manipulate currentValue to increase the supply or borrow cap by 1 instead of gap. It is then not possible to increase the cap again before increaseCooldown expires.  Selecting the values of increaseCooldown and gap with care is crucial, as poor choices can worsen the problem, although even carefully selected values cannot fully eliminate this issue.  Risk accepted:  MakerDAO states:  The same vector is present in other Maker modules and it was never proved to be used. In case of users abusing this possibility, we will upgrade to a more robust solution.  MakerDAO - Sparklend Cap Automator -   10  SecurityLowVersion1RiskAccepted          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   Cap of 0 Ignores Increase Cooldown   0  0  0  1  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Cap of 0 Ignores Increase Cooldown", "body": "  CapAutomator intends to prevent the supply and borrow cap to be increased for increaseCooldown seconds after an increase.  if (newCap > currentCap &&     block.timestamp < (capConfig.lastIncreaseTime + capConfig.increaseCooldown)) {     return currentCap;  CS-SPRKCAP-008  In SparkLend, a cap of 0 means no cap at all (see SparkLend Caps Specifications). In other words, the cap becomes infinity.  In CapAutomator, a newCap equal to 0 is considered as a cap decrease instead of an increase from the condition (newCap > currentCap). As a result, the increaseCooldown period will not be taken into account when the newCap is 0.  The aforementioned behavior could happen in case the gap is set to 0 and there is no supply or borrows (currentValue==0).  uint256 newCap = _min(currentValue + capConfig.gap, max);  In summary:  1. The code does not eliminate the possibility of setting gap to 0, which implies the risk of lifting the  cap by setting cap to 0.  2. The increaseCooldown period will not be respected per specification in case the cap becomes  infinity (cap==0).    An extra check has been added in setSupplyCapConfig() and setBorrowCapConfig() to ensure the gap is greater than 0.  MakerDAO - Sparklend Cap Automator -   11  CriticalHighMediumLowCodeCorrectedCorrectnessLowVersion1CodeCorrected          \f6.2   Event Emission Before State Change  In  functions  _updateSupplyCap  and  _updateBorrowCap,  events  are  emitted  before  the  configs (state variables) are updated. The emission of an event should indicate that changes have been made to state variables, whereas by the time the event is emitted, state changes haven't been made yet.  CS-SPRKCAP-006    Emission  of  the  event  UpdateSupplyCap  and  UpdateBorrowCap  has  been  moved  to  the  end  of _updateSupplyCap() and _updateBorrowCap() respectively.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Remove Non-Existing Config Is Possible", "body": "  The owner of CapAutomator can remove the supply or borrow caps via removeSupplyCapConfig() and removeBorrowCapConfig() respectively. Both of them do not check if the config has been set in the first place. As a result, removing non-existing config will succeed and an event will be emitted even though there is no state changes.  CS-SPRKCAP-007    removeSupplyCapConfig()  and  removeBorrowCapConfig()  have  been  updated  to  ensure  the config exists by checking if config.max>0. As config.max can only be set to a positive value for valid configs, this check effectively prevents removing a non-existing config.  MakerDAO - Sparklend Cap Automator -   12  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected          \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Cap Can Be Updated in the Flashloan", "body": " Callback  CS-SPRKCAP-004  SparkLend  supports  the  end  of  which,  a  debt  position (executeBorrow()) will be opened for the user if one does not repay the flashloan. In case the borrow limit has been reached, executeBorrow() will fail and the whole flashloan will revert.  (flashLoan()),  at   flashloan   With the deployment of CapAutomator, the user can increase the borrow cap in the flashloan callback via execBorrow() in case the borrow limit has been reached. Note that updating the borrow cap first and then doing the flashloan implies the same execution result, nevertheless, the ability to change of a key pool parameter may not be expected to happen in a flashloan callback.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Cap May Decrease Fast and Recover Slowly", "body": "  CS-SPRKCAP-005  Situations  may  arise  where  a  cap  can  be  reduced  significantly.  E.g.  a  whale  or  many  borrower  repay significant amounts or significant amounts of supply are withdrawn at the same time.  Should  the  CapAutomator  be  activated  it  will  significantly  reduce  the  respective  cap,  leaving  only  gap amount available for use.  Bringing the respective cap back up to its original limit could take a considerable amount of time due to the increaseCooldown feature.  This is especially likely to happen in case a reserve is frozen, no more supply and borrow is possible, but users can withdraw and repay. This means it is possible that the current supply and borrow will decrease to a small value, hence the cap could be decreased significantly. Arguably a significant reduction in the cap coupled with a slow increase over a period of time may not be unwarranted. Special care needs to be taken in this scenario.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Gas Optimizations", "body": "  When  updating  the calculation of the new cap (_calculateNewCap()) will return early if the configuration is unset or the cap has already been updated in the current block.  the  supply/borrow  cap  (_updateSupplyCap(),  _updateBorrowCap()),   CS-SPRKCAP-003  if (max == 0 || capConfig.lastUpdateBlock == block.number) return currentCap;  MakerDAO - Sparklend Cap Automator -   13  InformationalVersion1AcknowledgedInformationalVersion1AcknowledgedInformationalVersion1              \fThis check could be brought forward in _updateSupplyCap() and _updateBorrowCap() to enable an early return, which would occur before the external call to pool.getReserveData() is executed, saving gas.  MakerDAO - Sparklend Cap Automator -   14  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Supply and Borrow Are Subject to", "body": " Front-Running  When  the  current  available  volume  (to  be  supplied  /  borrowed)  is  above  the  gap,  a  user's  action  to consume  the  available  volume  can  be  front-run  by  an  update  of  the  cap,  which  may  leave  insufficient volume to be consumed in case the cap is lowered. In the former case, users can only supply / borrow up to the current cap and wait at least cooldown period to increase the cap for the consecutive operations. For instance:   Assume the current borrow cap = 15, current total borrow = 3, gap = 5.   Alice send tx1 to borrow 10.   Bob front-runs tx1 to update the cap to 8.   Now tx1 will fail due to exceeding the cap.  In addition, it is obvious that user's operation (supply / borrow) can also be front-run by others' (supply / borrow) which may leave insufficient volume afterwards.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Token Unit, Decimals and Integer Division", "body": "  In CapAutomator, the new cap is determined by currentValue, gap and max. These value are in \"full tokens\", token amounts without decimals.  uint256 newCap = _min(currentValue + capConfig.gap, max);  The currentValue is computed as currentSupply in _updateSupplyCap():  uint256 currentSupply = (             IScaledBalanceToken(reserveData.aTokenAddress).scaledTotalSupply() +             uint256(reserveData.accruedToTreasury)         ).rayMul(reserveData.liquidityIndex)         / 10 ** ERC20(reserveData.aTokenAddress).decimals();  and it is computed as currentBorrow in _updateBorrowCap():  uint256 currentBorrow = ERC20(reserveData.variableDebtTokenAddress).totalSupply()         / 10 ** ERC20(reserveData.variableDebtTokenAddress).decimals();  In both cases currentValue is rounded down when removing the decimals.  Due  to  this,  the  difference  between  the  new  cap  and  the  actual  current  value  could  be  below  the  gap even though the max has not been reached.  MakerDAO - Sparklend Cap Automator -   15  NoteVersion1NoteVersion1      \fIn  practice,  these  minor  rounding  effects  are  typically  negligible.  Nonetheless,  they  can  result  in  the following consequences:  If gap is 0, the new cap could be set lower than the current amount. For instance, if gap is 0, cap is 10, and the actual current supply is 9.99. The calculation of currentSupply would result in 9 due to integer division. Consequently, the update would set the cap to 9, which is less than the actual current supply.   Users should not expect to fully utilize the gap amount (expanded to its decimal representation) after  triggering exec(). There may be less space due to rounding and hence this action might fail.  MakerDAO - Sparklend Cap Automator -   16   \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Cancel Order Authorization Differs From", "body": " Match  Function validate of OrderValidator contract permits matches in cases when the message sender is not the order maker. This can be done when the order maker is an ERC1271 implementation or when the sender provides a valid signature. During the cancellation the only check that is done is:  require(_msgSender() == order.maker, \"not a maker\");  This  check  is  more  strict  than  the  matchOrders  authorization  rules  and  limits  the  possible  pool  of parties that can use this entry-point, for example, ERC1271 contracts cannot cancel their orders.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Dependency on EIP712Upgradeable", "body": "  Contract  OrderValidator  uses  EIP712Upgradeable  contract  from  openzeppelin  library,  which  is currently  in  a  draft  stage.  That  increases  the  risk  of  bugs  and  errors  in  all  contracts  that  use  this dependency. In addition draft library contracts tend to be inefficient. For example in current version, every call  (_EIP712NameHash(), two  _EIP712VersionHash()) which together cost 4200. That is fairly unnecessary.  _hashTypedDataV4   lookups   storage   triggers   to   import \"@openzeppelin/contracts-upgradeable/drafts/EIP712Upgradeable.sol\";  Rarible Inc. - Exchange V2 -   8  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedLowRiskAcceptedRiskAcceptedDesignMediumVersion1RiskAcceptedSecurityLowVersion1RiskAccepted                   \f5.3   Missing Indexes In Events  In ExchangeV2Core the events Cancel and Match contain no indexed fields. Indexing order hashes will help to avoid performance issues on node clients.  Rarible Inc. - Exchange V2 -   9  DesignLowVersion1RiskAccepted          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   doTransfers Does Not Hanlde LibFeeSide.FeeSide.NONE   -Severity Findings   Function safeGetPartialAmountFloor Precision Problems    Order Salt Problems    Orders With Salt 0 Can Be Canceled   -Severity Findings   Compiler Version Not Fixed    Contracts Can Be Order Makers    Precision Check in calculateRemaining Problem   0  1  3  3  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   doTransfers Does Not Hanlde", "body": " LibFeeSide.FeeSide.NONE  doTransfers  performs  the  transfer  of  assets  after  choosing  which  is  the  feeable  side.  However, getFeeSide can return the value LibFeeSide.FeeSide.NONE in the case none of the assets are ETH or  ERC20  or  ERC1155.  This  value  is  not  handled  by  the  function  doTransfers  which  results  to  the transfer not being performed.    doTransfers was changed to handle LibFeeSide.FeeSide.NONE.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Function safeGetPartialAmountFloor", "body": " Precision Problems  target)   The function safeGetPartialAmountFloor( uint256 numerator, uint256 denominator,  uint256  LibMath  the numerator * target / denominator and reverts on too much divergence from the correct value. Due to the different nature of tokens ( ETH, ERC20, ERC721, etc.) and different decimals on them, the actual values sent to this function can be of different orders. In cases when the denominator is greater  effectively   computes   contract   defined   in   Rarible Inc. - Exchange V2 -   10  CriticalHighCodeCorrectedMediumSpeci\ufb01cationChangedSpeci\ufb01cationChangedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedDesignHighVersion1CodeCorrectedCorrectnessMediumVersion1Speci\ufb01cationChanged                \fthan  the  numerator  *  target  the  0  will  be  returned.  This  can  lead  to  situations  when  the  orders cannot be matched. For example order \"Buy 30 for 600X\" cannot be matched with order \"Sell X for 10\", because  the  fillRight  function  that  relies  on  safeGetPartialAmountFloor  will  return  (10,  0) value that later will fail the check in matchAndTransfer function.  The safeGetPartialAmountFloor function is used in following places:   Function fillLeft in LibFill contract.   Function fillRight in LibFill contract.   Function calculateRemaining in LibOrder contract. In this case, big, close to filling values may  fail.  Specification corrected:  Now the specification correctly communicates the behavior of the contract.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Order Salt Problems", "body": "  The  salt  is  effectively  a  field  of  an  order  that  allows  different  orders  of  the  same  asset  types  from  the same maker to be distinguishable from each other. This field is also part of the hashKey of the order that is  used  to  track  the  filling  of  the  order.  However,  due  to  the  lack  of  Asset  values  in  the  hashKey,  the same value for salt can be resubmitted with higher-order take value, and thus lead to multiple full filling of the  same  order.  For  example,  an  order  that  makes  20  take  X  after  filling  can  be  resubmitted  with  the same salt and higher take limit: make 30 take 2X. Note that after cancellation the salt becomes unusable for the maker. From a specification point of view, it the order with same hashKey shouldn't be fully filled multiple times.  function hashKey(Order memory order) internal pure returns (bytes32) {     return keccak256(abi.encode(             order.maker,             LibAsset.hash(order.makeAsset.assetType),             LibAsset.hash(order.takeAsset.assetType),             order.salt         )); }  Specification corrected:  The behavior was documented and properly described in exchange-v2/readme.md.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Orders With Salt 0 Can Be Canceled", "body": "  The  filling  degree  of  orders  with  salt  0  is  not  tracked  in  the  matchOrders  function.  But  the calculateRemaining function will use the value from fills map to compute the remaining value that needs  to  be  filled.  The  cancel  function  effectively  sets  the  fills  map  value  to  the  UINT256_MAX value. Users can also cancel orders with salt 0, effectively making the asset pair not longer usable with salt 0.  Rarible Inc. - Exchange V2 -   11  DesignMediumVersion1Speci\ufb01cationChangedDesignMediumVersion1CodeCorrected                \f  A check that prevents 0 salt order cancellation was added.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Compiler Version Not Fixed", "body": "  The  solidity  compiler  is  not  fixed  in  the  code.  In  addition,  different  files  define  different  pragmas.  The version, however, is defined in the truffle-config.js to be 0.7.6. In the code the following pragma directives are used:  pragma solidity >=0.6.2 <0.8.0; pragma solidity >=0.6.9 <0.8.0;    The pragma was fixed to 0.7.6 for all contracts.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Contracts Can Be Order Makers", "body": "  Maker  and  Taker  of  orders  can  be  contracts  with  the  help  of  the  ERC1271  standard.  In  addition,  fee receiving parties can be contracts too. If native ether is used as an asset during the match, the transfers can  fail  if  the  contracts  do  not  implement  a  payable  fallback  function.  The  system  specification  should clearly communicate this requirement to the users.  Specification corrected:  The expectations from contracts were documented and described in exchange-v2/readme.md.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Precision Check in calculateRemaining", "body": " Problem  Due  to  a  precision  check  in  function  calculateRemaining  orders  with  different  magnitudes  of  take and make values can become unfillable even with a small filling degree. For example, Order with make 10 take 100 cannot be filled if fill amount of take is 15. In calculateRemaining the remaining make value for that order will be approximated with value 8. Because the true value of 8.5 cannot be expressed with integer numbers, the error of 0.5 will exceed 0.1% limit that is built-in in calculateRemaining due to utilization of LibMath.safeGetPartialAmountFloor function.    precision   The  commit 839710b1bd7ed11fc22fa2093f408934b92ccf35.  This  fix  prevents  premature  order  freeze.  With  the  fix,  in  calculateRemaining   function  was   removed   check   in   Rarible Inc. - Exchange V2 -   12  DesignLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                        \fonly  the  last  make  item  of  the  order  can  be  unsellable.  For  example,  an  order  with  make  10  take  100 cannot  be  fully  filled  if  the  fill  amount  of  take  is  95,  as  the  0.5  make  value  will  be  estimated  by calculateRemaining  function  as  0.  With  help  of  order  extension  functionality,  such  orders  can  be fixed  via  signature  resubmission  with  greater  values.  The  precision  check  for  price  computation  is  still used.  Rarible Inc. - Exchange V2 -   13  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Accumulation of Rounding Errors", "body": "  The  fullfilment  of  an  order  is  tracked  by  the  fills  mapping.  The  remaining  part  comes  from  the subtraction of the value the fills mapping holds for a particular order from the total take value of the order.  if (orderLeft.salt != 0) {      fills[leftOrderKeyHash] = leftOrderFill.add(newFill.takeValue); } if (orderRight.salt != 0) {     fills[rightOrderKeyHash] = rightOrderFill.add(newFill.makeValue); }  the  value  added   However,  in LibOrder.calculateRemaining.  Division  might  introduce  some  rounding  erros  which  gradually accumulate  if  an  order  is  partially  filled  multiple  times.  Notice  that  the  implemenation  tolerates  a  0.1% rounding error.  is  a  result  of  a  division  occuring   the  fills  mapping   to   function calculateRemaining(Order memory order, uint fill) internal pure returns (uint makeValue, uint takeValue) {     takeValue = order.takeAsset.value.sub(fill);     makeValue = LibMath.safeGetPartialAmountFloor(order.makeAsset.value, order.takeAsset.value, takeValue); }  function safeGetPartialAmountFloor(     uint256 numerator,     uint256 denominator,     uint256 target ) internal pure returns (uint256 partialAmount) {     if (isRoundingErrorFloor(numerator, denominator, target)) {         revert(\"rounding error\");     }     partialAmount = numerator.mul(target).div(denominator); }  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   AssetMatcher Gas Efficiency", "body": "  The matchAssetOneSide function in AssetMatcher contract effectively decides if two assets types can be matched. It also contains logic for matching assets that are not yet known to the systems:  if (classLeft == classRight) {     bytes32 leftHash = keccak256(leftAssetType.data);     bytes32 rightHash = keccak256(rightAssetType.data);     if (leftHash == rightHash) {         return leftAssetType;     } }  Rarible Inc. - Exchange V2 -   14  NoteVersion1NoteVersion1      \fThis piece of code works for all known asset types as well. In addition, it is more efficient than the current matchAssetOneSide for most of the known asset types.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Incentives for Front-Running", "body": "  In  case  when  2  assets  that  can  pay  fees  are  exchanged,  the  order  of  arguments  in  matchOrders function might matter. Moreover it determines the price and thus the amounts exchanged between the two  parties.  There  might  be  third  parties  that  are  incentivised  to  front-run  the  transactions  in  order  to determine the position of the orders for their own interest. The users should be aware of such events. In addition,  once  the  transactions  are  visible  in  the  mining  pool,  any  other  parties  can  try  to  frontrun  the match, to profit from matching with lower fees or good price.  Illustration of order importance:  Let  A  and  B  be  an  ERC20  and  ERC1157  token  respectively.  Accoring  to  the  contract  logic  currently implemented,  the  feeable  token  is  A.  Assume  two  orders  O1:(10A,  20B)  and  O2:(50B,11A)  Executing matchOrder(O1, O2) yields fillResult(10A, 20B) (fillLeft will be called). On the other hand, executing  matchOrder(O2,  O1)  yields  fillResult(20B,  220/50A)  (fillRight  will  be  called). Assuming a fee of 10% then in the first case we have 0.1 * 10A and the second 0.1* 220/50 A  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Orders Can Pay No Fees", "body": "  Before transfering the assets to the corresponding parties the fee side is chosen. The side is chosen to be the one that offers ETH or ERC20 or ERC1155. If there is no such types in make and take assets of the order, the fees won't be deducted.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Reentrancy Risk", "body": "  In  the  matchOrders  can  occur  calls  to  other  contacts  and  addresses.  For  example,  during  the  native ether transfer or during the transfer of tokens that allow user hooks e.g. ERC777 (extension of ERC20). While we haven't identified a direct way, how this can be abused. But risk of reentrancy is nullified when a non-reentrant lock is used, for a price of small gas cost increase.  In addition, following transfers of ether will send all the gas to the callee, allowing it to execute any other contract with no restrains.  (bool success,) = to.call{ value: value }(\"\");  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   The Order of Orders Determines The Price", "body": "  In centralized order book-based exchanges, the price of matchable orders with different prices is usually determined  by  the  order  with  the  earliest  submission  time.  In  the  current  implementation,  the  price  is determined by the left order. While the centralized method is not applicable to this system, the current behavior should be documented in specification, as the users should be aware of the price formation.  Rarible Inc. - Exchange V2 -   15  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                \f7.7   Use of SafeMath  There are many instance where the SafeMath is not used. Such calculations can lead to overflows and, thus, unexpected behavior. No dangerous overflows have been found during the overflow, however, the use  of  SafeMath  is  recommended.  For  example  such  calculations  happen  in  transferPayouts function on sumBps accumulator.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.8   Validate Gas Efficiency", "body": "  Function  validate  in  OrderValidator  contract  can  be  restructured  for  a  lower  gas  cost.  The isContract check is performed in all cases when the message sender is not the maker. Assuming that the most popular cases are when the maker is not a contract, the signature check can be performed first, before the isContract check.  Rarible Inc. - Exchange V2 -   16  NoteVersion1NoteVersion1        \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Inefficient _validate", "body": "  0  0  0  3  _validate  may  be  refactored  to  be  more  efficient.  The  amount  of  external  calls  executed  may  be reduced.  By checking whether a check of the credit line or the peace is even required first, the call to the Vat and the calculation of the tab could be skipped in case it's not needed. The current code however calls the Vat  initially  and  then  calculates  the  tab,  before  determining  whether  a  credit  line  or  peace  check  is needed.  Acknowledged:  Maker acknowledged the issue.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Skip Calls When No Additional Debt Is Needed", "body": "  DssProxyActionsCharter.draw() generates the debt required before exiting the DAI amount to the user's wallet:  // Generates debt in the CDP _frob(charter, ilk, 0, _getDrawDart(charter, vat, jug, ilk, wad)); ... // Exits DAI to the user's wallet as a token DaiJoinLike(daiJoin).exit(msg.sender, wad);  MakerDAO - DSS-Charter -   10  DesignCriticalHighMediumLowAcknowledgedAcknowledgedAcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                  \f_getDrawDart() may return 0 if no additional debt is required to exit the specified amount of DAI. The calls  to  CdpManager.frob()  and  Vat.frob()  will  execute  nevertheless  in  this  case,  despite  not being required.  Acknowledged:  Maker acknowledged the issue.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   getOrCreateProxy() or", "body": " proxy[msg.sender]  The CharterManager implementation has a function getOrCreateProxy() which returns the address of  an  urn  managed  by  the  CharterManager  for  a  user,  or  creates  a  new  urn  if  it  does  not  exist  yet. Although, the Charter Manager features a public mapping proxy which stores the list of urns and their respective  users,  multiple  functions  in  the  DssProxyActionsCharter  use  getOrCreateProxy  function even when not necessary, i.e., there is no need to create a new urn if it does not exist already. Examples of such functions are wipe(), wipeAll(), cashETH(), or cashGem.  Similarly this also applies to CharterManager.quit().  The CharterManager features functions exit and flux. Both operate on the collateral of the user in the Vat. While flux transfers the collateral in the accounting of the Vat to another address, exit exits the collateral to the user.  From  an  users  perspective,  for  the  account  which  is  the  source  of  the  collateral  these  should  behave similarly.  Exit()  however  uses  proxy[msg.sender]  to  load  the  address  of  the  Urnproxy,  while flux() uses getOrCreateProxy(src).  Acknowledged:  Maker acknowledged the issue.  MakerDAO - DSS-Charter -   11  DesignLowVersion1Acknowledged          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Possible Revert Due to Underflow   -Severity Findings  Inconsistent Retrieval of Ilk Parameter    Possible Optimization on Getting vat Address    Unused Function _toRad()   0  0  1  3  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Possible Revert Due to Underflow", "body": "  Should  the  recorded  DAI  balance  of  the  DSProxy  at  the  Vat  exceed  the  amount  required  to  repay  the debt,  the  subtraction  in  DssProxyActionsCharter._getWipeAllWad()  will  underflow  causing  the transaction to revert.    _getWipeAllWad() now returns 0 when enough DAI is available to cover the debt.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Inconsistent Retrieval of Ilk Parameter", "body": "  The function cashETH in the DssProxyActionsCharter contract takes as parameters ethJoin and ilk among  others.  However,  in  other  functions,  e.g.,  freeETH(),  wipeAllAndFreeETH(),  etc.  only ethJoin  the  adapter: bytes32 ilk = GemJoinLike(ethJoin).ilk().  is  passed  as  parameter,  while   the  ilk  value   retrieved   from   is     cashEth() and cashGem() now retrieve the ilk from the adapter as the other functions do.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Possible Optimization on Getting vat Address", "body": "  MakerDAO - DSS-Charter -   12  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedDesignMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                         \fMultiple functions in the DssProxyActionsCharter and DssProxyActionsEndCharter contracts receive the vat address as follows: address vat = CharterLike(charter).vat(). Considering that the vat contract is already deployed and its address is not expected to change, the contracts can store this value as immutable or constant to optimise gas costs.    Both  the  address  of  the  VAT  and  the  CharterManager  (which  was  previously  passed  as  function argument) are now stored as immutables.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Unused Function _toRad()", "body": "  The function _toRad() is implemented in DssProxyActionsCharter but it is not used.    The unused function has been removed.  MakerDAO - DSS-Charter -   13  DesignLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Overflow When Drawing More Than 100", "body": " Trillion Debt  Theoretically, the function _getDrawDart() can overflow when computing dart: dart = _toInt256( _mul(netToDraw,  WAD)  /  _sub(_mul(rate,  WAD),  _mul(rate,  nib))).  netToDraw  is  in rad  (45  decimals)  and  wad  has  18  decimals,  therefore  for  large  netToDraw  (greater  than  10**14)  the computation overflows.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Possible Overflow in exit()", "body": "  The  function  exit()  in  ManagedGemJoin  contract  converts  uint256  wad  into  a  negative  value: -int256(wad).  Before  the  conversion,  the  following  check  is  performed  to  prevent  overflows: require(wad <= 2 ** 255). Theoretically, if wad == 2 ** 255 the overflow will happen twice, but the result matches the expected value in this case.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Unaware Users and Permissioned Ilks", "body": "  Unaware users may deposit collateral for a permissioned ilk. Only when a user attempts to draw debt for such a permissioned ilk the transaction will revert.  The reason is that for a permissioned ilk an unpermissioned user has a credit line of 0, hence cannot take on  debt.  The  error  message  CharterManager/user-line-exceeded  and  the  place  where  the transaction reverts may be confusing for an unaware user.  MakerDAO - DSS-Charter -   14  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Fees May Block Slow Path", "body": "  The  slow  path  goes  through  L1DAIWormholeBridge.finalizeRegisterWormhole()  which  calls requestMint with maxFee = 0.  When the vat is live, the computed fee in _withdraw function of WormholeJoin may be > 0 and the transaction would revert due to:  require(fee <= maxFee, \"WormholeJoin/max-fee-exceed\");  This essentially prevents users who are censored by the oracle to redeem using the slow path.    The only fee currently present, the WormholeConstantFee, now features a ttl after which the fee returned for this WormholeGUID is 0.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   L2 Addresses", "body": "  MakerDAO - DAI Wormhole -   13  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedLowCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignHighVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                  \fThe address format can differ across L2 systems / different domains the DAI wormhole connects. While the majority work with address of 20 bytes, compatible with the solidity address type, other systems can use other address format. One example of those is StarkNet where addresses of are of type felt which are larger than 20 bytes.    The  receiver  and  operator  fields  of  the  WormholeGUID  struct  have  been  replaced  by  bytes32 types to accommodate for address formats up to 32 bytes.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Minting Pending DAI Incurs Additional Fees", "body": "  Using the DAI Wormhole may take a fee from the user. This fee is taken on L1 and transferred to the VOW.  The  fee  is  accounted  for  inside  _withdraw()  and  calculated  using  an  external  Fee  adapter contract based on the wormholeGUID which contains all information about the transfer, the current debt and the line, the debt ceiling according to the source domain.  The amount of the fee taken is calculated before determination of the amount that is withdrawn.  uint256 fee = vatLive ? FeesLike(fees[wormholeGUID.sourceDomain]).getFees(wormholeGUID, line_, debt_) : 0; require(fee <= maxFee, \"WormholeJoin/max-fee-exceed\");  uint256 amtToTake = _min(                         pending,                         uint256(int256(line_) - debt_)                     );  The fee is based on the full amount of the wormholeGUID being processed, not on the actual amount withdrawn in this transaction. The actual amount withdrawn is limited by the maximum debt that can be created without exceeding the ceiling. The remaining amount can be retrieved later when more debt can be  accrued  using  mintPending().  This  however  again  uses  function  _withdraw  which  again calculates the fee based on the full amount of the wormholeGUID, the current debt and debt ceiling. The pending amount is not taken into account for the calculation of the fee.  Hence, should the amount to be withdrawn be limited by the remaining space between the debt ceiling (line) and the current debt, the user pays fees based on the full amount, not the amount being withdrawn. Later,  when  the  remaining  pending  amount  is  withdrawn,  the  user  again  pays  fees  based  on  the  full amount of the wormholeGUID, effectively paying again for the same transfer.    The fee computation function getFee takes more parameters (pending, amtToTake) into account. This allows  more  versatile  ways  to  compute  the  fee.  For  example,  WormholeConstantFee  can  now compute the fee relative to the amount being withdrawn instead of the full fee every time the full amount is partially withdrawn.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Missing or Incomplete Natspec", "body": "   requestMint,  _mint  and  mintPending  are  missing  the  natspec  for  their  second  return  value  totalFee.  MakerDAO - DAI Wormhole -   14  DesignMediumVersion1CodeCorrectedDesignLowVersion2CodeCorrected                \fthe cure and getFee functions specification should specify the unit of its return value.  the isValid function specification should describe the return value.  the v, r and s parameters of BasicRelay.relay should be described in the specification    The issues raised above have been addressed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Specification Mismatch", "body": "  The  specification  of  the  mintPending  function  says  that  it  is  only  callable  by  the  operator,  but  the receiver is also allowed to call the function.  Specification changed:  The description of the mintPending function has been fixed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   Code Inefficiency", "body": "   signers mapping in WormholeOracleAuth is address => bool, it would be more gas efficient  to have a address => uint256.  in  WormholeOracleAuth,  threshold  is  passed  as  a  function  parameter  in  isValid. threshold is a storage variable in the contract and thus can be accessed directly from isValid function and does not need to be passed as a parameter, this would save gas.  in  _withdraw  function  of  WormholeJoin,  the  overflow  check  for  _line  happens  every  time. Checking for overflow only once in the file function where the line for a domain is set would save gas.    the signers mapping has been changed to a mapping(address => uint256).   MakerDAO  wants  the  isValid  function  to  be  used  by  anyone  who  wants  to  verify  an  oracle  attestation.  the  file  function  checks  for  _line  validity  and  the  check  has  been  removed  from  _mint  (new version of _withdraw).  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.7   Interface Mismatch", "body": "  MakerDAO - DAI Wormhole -   15  CorrectnessLowVersion2Speci\ufb01cationChangedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                               \f The   of   signature   is function approve(address, uint256) external returns(bool);, but WormholeJoin as and  function  approve(address,  uint256)  external;  in  the  interface  they  define  for TokenLike.  L1DAIWormholeBridge   approve   token's   have   DAI   the   it   Version 2:   The interface signature of requestMint in WormholeRouter exposes only one return value out of two. The interface signature of requestMint in L1DAIWormholeBridge exposes no return value at all.  The  compiler  will  just  drop  the  unused  return  values  without  causing  an  error,  but  this  design choice does not reflect the correct signatures and should be documented.     WormholeJoin  and  L1DAIWormholeBridge  have  the  correct  interface  for  the  DAI  token's  approve function.   The interface signature of requestMint() in WormholeRouter has been fixed in   .   L1DAIWormholeBridge  is  now  called  L1DAIWormholeGateway.  The  interface  is  now  defined  correctly in the imported WormholeInterface.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.8   Missing Index", "body": "   domain fields are indexed in WormholeJoin events. It could be useful to index the domain field of  WormholeRouter's File event to make it more easily searchable.   targetDomain  field  in  Flushed  event  of  L2DAIWormholeBridge  can  be  indexed  to  ease  its  search.    the domain fields in the File events are indexed.  the targetDomain field in the Flushed event is indexed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.9   file() Casting Bytes32 to Uint256", "body": "  Contrary to the other contracts which have multiple file functions with the data parameter of the actual type of the data passed, the WormholeOracleAuth has a file function taking a bytes32 argument as data which is then casted to uint256.    The  file  function  responsible  for  the  threshold  parameter  now  takes  directly  a  uint256  data  to avoid an unnecessary conversion.  MakerDAO - DAI Wormhole -   16  Version3DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Breaking Changes of the Solidity Compiler", "body": "  The new compiler version behaves differently on code related to integer conversion/negation when the value is exactly 2**255.  The core DSS system which has been compiled with compiler version 0.6.12 first ensures that the value of the uint is below or equal to 2**255 before converting it to a (negative) integer.  An example of this pattern can be found in e.g. GemJoin.exit():  require(wad <= 2 ** 255, \"GemJoin/overflow\");        vat.slip(ilk, msg.sender, -int(wad));  This  project,  DSS-Wormhole  uses  a  more  recent  compiler  version  0.8.9.  Negating  2**255  is  no  longer possible and will result in the transaction reverting.  In DSS-Wormhole, WormholeJoin.settle() features such a pattern:  function settle(bytes32 sourceDomain, uint256 batchedDaiToFlush) external {     require(batchedDaiToFlush <= 2 ** 255, \"WormholeJoin/overflow\");     daiJoin.join(address(this), batchedDaiToFlush);     if (vat.live() == 1) {         (, uint256 art) = vat.urns(ilk, address(this)); // rate == RAY => normalized debt == actual debt         uint256 amtToPayBack = _min(batchedDaiToFlush, art);         vat.frob(ilk, address(this), address(this), address(this), -int256(amtToPayBack), -int256(amtToPayBack));  Note  that  in  this  case  the  check  is  superflous:  The  multiplication  in  daiJoin.join()  will  revert  due  to  an overflow on even lower values.  Nevertheless  it's  important  to  be  aware  of  this  behavior,  the  same  code  pattern  behaves  differently depending on the compiler version. This requires careful attention especially when such contracts, which have been compiled with different compiler versions, e.g. DSS-Wormhole and the VAT interact.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Finality and State Change on L2", "body": "  The notion of finality of transactions and the resulting state change differs across the L2 solutions. The Wormhole  system,  especially  the  Maker  Oracle  Feeds  must  be  aware  of  that  and  take  each  finality definition into account. Ideally this is properly assessed and documented for each Domain the Wormhole connects to.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.3   Slow Path Requires Zero Fee", "body": "  The  slow  path  successful redemption of the wormhole with no fee due to:  through  L1DAIWormholeBridge.finalizeRegisterWormhole()   requires  MakerDAO - DAI Wormhole -   17  NoteVersion1NoteVersion1NoteVersion1          \ffunction finalizeRegisterWormhole(WormholeGUID calldata wormhole)     external     onlyFromCrossDomainAccount(l2DAIWormholeBridge) {     wormholeRouter.requestMint(wormhole, 0, 0); }  The interface definition of WormholeFees emphasizes this:  It should return 0 for wormholes that are being slow withdrawn.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.4   Surplus DAI for WormholeJoin in the VAT", "body": "  Function  settle()  of  the  WormholeJoin  contract  is  permissionless  and  given  enough  DAI  token balance  of  the  WormholeJoin  contract  (e.g.,  provided  by  the  caller)  can  be  executed  by  anyone. DaiJoin.join() returns the DAI tokens into the system and the contract's balance tracked by the DAI mapping  of  the  VAT  increases  accordingly.  This  increased  balance  however  is  stuck  when  everything has been settled.  Note  that  the  sourceDomain  can  be  chosen  arbitrarily  by  the  untrusted  caller.  Listeners  of  the  event Settle  must  be  aware  that  this  event  may  be  triggered  by  anyone  and  may  not  represent  a  debt repayment coming from the bridges.  MakerDAO - DAI Wormhole -   18  NoteVersion1    \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Slashing Can Be Avoided", "body": "  For Kiln, the smart contract layer does not immediately know when a slashing event on the Consensus Layer  has  happened.  Offchain,  however,  it  is  easy  to  immediately  know  when  a  validator  has  been slashed.  A user of an enzyme vault that uses one of the staking external positions could monitor for slashings and immediately  withdraw  from  the  vault  when  such  an  event  happens.  By  doing  this,  they  will  be  able  to redeem their assets (up to the available liquidity) at the pre-slashing price.  Once the slashing is accounted for in the vault (after about 36+ days for Kiln), the slashing loss of the users that withdrew previously will instead be taken by those users that are still deposited in the vault.  CS-SUL11-001  Risk accepted:  Avantgarde Finance acknowledged the issue and replied:  Since consensus layer slashing is not readable directly from the execution layer, slashing can only be made known by posting to the execution layer, and there will always be an opportunity to front-run posting (the same goes for Chainlink aggregators).  Fund managers must be aware of this risk and take any necessary precautions to mitigate the risk where needed, e.g., via policies and/or queued redemptions.  Avantgarde Finance - Sulu Extensions XI -   10  DesignCorrectnessCriticalHighMediumRiskAcceptedLowRiskAcceptedRiskAcceptedDesignMediumVersion1RiskAccepted            \f5.2   Pricing ERC4626  The pricing of ERC-4626 tokens could be off. Namely, convertToAssets() does not include:  fees   variations among callers (no price per user but rather an average among users)  CS-SUL11-002   slippage or other on-chain conditions  Ultimately, the fund could be under-/overvalued.  Risk accepted:  Avantgarde Finance replied:  The Enzyme Council will need to review each new class of erc4626 asset to determine whether convertToAssets() is potentially significantly deviant from actual redemption  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   Unclaimed Staking Rewards Are Not Valued", "body": "  In KilnStakingPositionLib, getManagedAssets simply returns validatorCount * 32ETH.  However, there may be a significant amount of staking rewards that are owed to the vault, if they haven't been  claimed  recently.  Rewards  are  only  accounted  for  in  the  vault's  valuation  once  they  are  claimed, which only the vault manager can do using the claimFeesAction. This action is very gas-intensive, so it will likely not be called often.  The  actual  value  of  the  external  position  will  be  under-represented,  which  may  lead  to  share  price arbitrage.  CS-SUL11-005  Risk accepted:  Avantgarde Finance replied:  Since accrued rewards live in distinct execution layer and consensus layer contracts per validator, it is too gas-intensive to query balances across all validators on every position value query.  Fund managers must be aware of this risk and take any necessary precautions to mitigate the risk where needed, e.g., claiming rewards with reasonable frequency, policies, and/or queued deposits and redemptions.  Avantgarde Finance - Sulu Extensions XI -   11  CorrectnessLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted               \f6   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Convex and Aura removeToken Clarification", "body": "  The  Convex  and  Aura  staking  wrappers  implement  the  function  removeExtraRewardToken()  to remove certain extra tokens. The function intends to remove extra reward tokens that led to errors in the previous  implementation  so  that  they  can  be  readded  later  on  in  a  correct  way  using  the  logic  for  the stash tokens. Its intention is not to remove extra reward tokens forever (since all reward tokens will be added automatically even if they had been removed).  The  wrappers  wrap  the  addition  of  extra  reward  tokens  in  a  try/catch  block.  When  adding  multiple tokens, if the addition of any of the extra reward tokens would fail, none of the reward tokens would be added. This is the intended behaviour that enzyme expects.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   ERC4626 Considerations", "body": "  No extra steps needed to deposit or redeem (besides ERC-20 approval) should be present. Otherwise, the adapter will not work as intended. Any additional logic on top of what is specified in the ERC should be carefully evaluated.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   ERC4626 minIncomingShares Must Be Used", "body": "  ERC4626 vaults can be affected by rounding issues when depositing.  This is mitigated in the ERC4626Adapter by letting managers specify a minIncomingSharesAmount.  It is important that managers specify a reasonable amount, to limit the impact of rounding errors.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Kiln Bad Accounting", "body": "  In Kiln, the admin of the staking contract can withdraw from the CL fee recipient contract. If that occurs after an exit, and the vault manager performs an action that sweeps ETH from the external position (e.g. claim  fees,  sweep  ETH),  then  the  accounting  will  be  off.  Namely,  the  exited  validator  will  be  still accounted for (32 ETH) while the exited ETH will be in the vault proxy. Ultimately, double-counting assets could be possible. Hence, the share price will be too high.  Further,  donations  could  be  made  to  the  CL  fee  recipient  contract  so  that  the  threshold  is  reached. Ultimately,  when  claiming  CL  fees,  the  validator  count  would  be  reduced  even  though  there  was  no validator exit. The value of the fund could be reduced.  Avantgarde Finance - Sulu Extensions XI -   12  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \fSlashed validators will not be removed in the case of a mass slashing event, where the slashed amount is  larger  than  32  ETH  -  EXITED_VALIDATOR_THRESHOLD.  The  value  of  the  fund  would  be overestimated in this case.  Note that the threshold should be very carefully chosen so that the system works properly all of the time while not allowing arbitrage opportunities. Fund managers and asset managers are expected to actively monitor for bad scenarios so that they can pause the external position's valuation. Once paused, they are expected to reconcile with Avantgarde Finance so that a contract upgrade can be released that fixes the issue.  Further, note that Avantgarde Finance is aware of this but decided to implement more complex logic for these rather unlikely corner cases only if necessary.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Kiln Fees on Slashing", "body": "  Note the following documented behaviour in Kiln:  In case of slashing, the exit is not requested we don't exempt anything [from fees]. This is in case of slashing,  the  staker  will  be  rebated  manually.  A  slashed  validator  may  have  accumulated  enough skimmed  rewards  to  still  have  a  balance  >  32  ETH.  All  of  this  will  be  taken  into  account  and  the staker will be compensated for the commission taken. on its principal and the loss according to the SLA described in the Terms&Conditions.  Kiln takes a fee on the total leftover ETH balance if a slashing event leaves a position under 31 ETH. As this amount must be manually returned by Kiln, it will not be considered in the valuation of the enzyme vault  until  that  process  is  completed.  This  may  lead  to  undervaluing  the  vault.  If  Kiln  returns  the  owed amount to the external position rather than the vault directly, the amount will only be counted once the vault manager calls the sweepETH action.  Avantgarde Finance - Sulu Extensions XI -   13  NoteVersion1    \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   ERC-20 Missing Return Value", "body": "  ArrangerConduit handles ERC-20 transfers in the following way:  require(     ERC20Like(asset).transfer(destination, amount),     \"ArrangerConduit/transfer-failed\" );  0  0  0  2  CS-MDAC-001  This assumes that all ERC-20 contracts that can be called return a boolean value in their transfer() and  transferFrom()  functions.  This  is  however  not  the  case.  Popular  tokens  like  USDT  are  not returning any value in the mentioned functions. If it were to happen that the arranger sends such tokens to the contract, the tokens would be locked and require an update of the contract.  Specification changed:  Transfers  are  now  performed  without  checking  the  return  values  of  ERC20  tokens  at  all.  MakerDAO assures that only tokens that revert on failure are used as assets in the contract.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Floating Pragma", "body": "  The ArrangerConduit contract is not set to a fixed solidity version - neither in the contract nor in the Foundry  configuration.  This  can  lead  to  unintended  side-effects  when  the  contract  is  compiled  with different compiler versions.  CS-MDAC-002    MakerDAO - ArrangerConduit -   10  CriticalHighMediumLowSpeci\ufb01cationChangedCodeCorrectedDesignLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                \fThe compiler version 0.8.16 has been added to the Foundry configuration.  MakerDAO - ArrangerConduit -   11  \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Incorrect maxDeposit() Return Value", "body": "  ArrangerConduit.maxDeposit()  always  returns  type(uint256).max.  This  value  is,  however, only  correct  if  the  contract  does  not  hold  any  tokens  of  the  given  asset  at  the  time  of  the  call. Furthermore, some tokens have a lower maximum (e.g., type(uint96).max in the COMP token).  CS-MDAC-003  MakerDAO - ArrangerConduit -   12  InformationalVersion1  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Outdated Compiler Version", "body": "  The project uses an outdated version of the Solidity compiler.  pragma solidity 0.6.6;  in  Known  https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json#L1416  version   bugs   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "0.6.6 ", "body": "  0  0  0  2  are:  More information about these bugs can be found here: https://docs.soliditylang.org/en/latest/bugs.html  At  the  time  of  writing  the  most  recent  Solidity  release  is  version  0.6.12.  For  version  0.6.x  the  most recent release is 0.6.12 which contains some bugfixes but no breaking changes.  The compiler was not changed as the client responded:  We will address this later for an overall code review.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   _weth Could Be a Constant", "body": "  The  constant  _weth  which  represents  the  same  address  across  all  Enzyme  Bridges  could  be  set  as constant. This would reduce unnessesary storage operations.  Acknowledged:  Avantgarde Finance - Unslashed-Enzyme Bridge -   8  DesignCorrectnessCriticalHighMediumLowRiskAcceptedAcknowledgedDesignLowVersion1RiskAcceptedDesignLowVersion1Acknowledged                  \fAvantgarde Finance is aware of this and commented that it does have a significant impact as the variable will be accessed a few times only.  Avantgarde Finance - Unslashed-Enzyme Bridge -   9    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   Denomination Asset Check on Initialization    Redeem Shares Return Value Not Used    withdrawEthToInvestor Specification Discrepancy   0  0  0  3  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Denomination Asset Check on Initialization", "body": "  For the correct operation of the bridge, it is critical that the denomination asset of the vault is correctly set to WETH during initialization. Such a check is not present in the code.  Code Changed:  A check has been introduced in the initialize function  require(IComptrollerProxy(controllerProxy).getDenominationAsset() == weth, \"EnzymeBridge: wrong fund asset\");  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Redeem Shares Return Value Not Used", "body": "  The return values of  IComptrollerProxy(_controllerProxy).redeemShares()  and  IComptrollerProxy(_controllerProxy).redeemSharesDetailed(...)  are  not  used.  Both  functions  return  the  payout  assets  and  amounts.  Instead,  the  resulting  amount  of tokens  is  checked  using  balanceOf(...),  incurring  additional  gas  costs.  The  benefit  of  the  current implementation  is  the  fact  that  one  can  withdraw  tokens  that  were  already  in  the  vault  before  the redemption. However, this choice is inconsistent with the later choice to only send the ether which was recently unwrapped.  Avantgarde Finance - Unslashed-Enzyme Bridge -   10  CriticalHighMediumLowCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fuint256 result = IWETH9(_weth).balanceOf(address(this)); IWETH9(_weth).withdraw(result); // returns eth to us IInvestable(_investor).receiveEthFromFund{value: result}();  Code Corrected:  return  value  of  redeemShares  and The  code  has  been  changed  so  redeemSharesDetailed. Moreover, the returned result is used to ensure that only one returned asset is used. Finally, the code now withdraws a consistent amount of WETH and ETH. of  it  uses   the   (, payoutAmounts) = IComptrollerProxy(_comptrollerProxy).redeemShares();  ....  (, payoutAmounts) = IComptrollerProxy(_comptrollerProxy).redeemSharesDetailed(sharesQuantity, empty, empty); ...  require(payoutAmounts.length == 1, \"EnzymeBridge: fund not converted\"); ...  uint256 result = payoutAmounts[0]; IWETH9(_weth).withdraw(result); // returns eth to us IInvestable(_investor).receiveEthFromFund{value: result}();  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   withdrawEthToInvestor Specification", "body": " Discrepancy  The comment for withdrawEthToInvestor reads as follows: Note that due to possible sha re value rounding the resulting amount may be slightly greater than requested .  Another rounding error may happen when the shares' quantity required is calculated:  uint256 sharesQuantity = amount.mul(PRECISION_18E).div(shareValue18ePrecision);  Consider  the  case  when  the  share  value  is  not  affected  by  rounding  errors.  Due  to  possible  rounding errors  when  the  shares'  quantity  is  calculated,  the  shares'  quantity  required  to  receive  the  amount  in WETH may be underestimated. Hence the Ether amount withdrawn might be slightly smaller and thus the comment does not hold.  Specification Changed:  The documentation correctly now states:  /// Note that due to possible share value or division rounding /// the resulting amount may be slightly greater or smaller than requested.  Avantgarde Finance - Unslashed-Enzyme Bridge -   11  CorrectnessLowVersion1Speci\ufb01cationChanged        \f7   Notes  We leverage this section to highlight further findings that are not necessarily issues. The bridge contract in  scope  for  this  review  connects  Unslashed  to  Enzyme  which  consists  of  many  interacting  contracts. Hence, the mentioned topics serve to clarify or support the report, but do not require a modification inside the project. Instead, they should raise awareness in order to improve the overall understanding for users and developers  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Illiquid Lending Providers", "body": "  The  basket  can  only  withdraw  when  all  assets  of  the  fund  have  been  exchanged  into  WETH.  Illiquid liquidity protocols may be unable to redeem a large amount of tokens at times. Hence a fund manager may be unable to redeem all assets into their underlying.  E.g. a large amount of WETH has been lent into the Aave liquidity pool. When the fund manager wants to redeem this large amount of derivative tokens back into the underlying WETH, it could be the case that the liquidity may be insufficient as currently a large amount of WETH is lent out.  During this period Ether withdrawal is blocked.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Migration to New Enzyme Release Is Not", "body": " Supported  This  Enzyme  Bridge  in  connection  with  the  current  implementation  of  the  Basket  contract  does  not support the migration of a fund to a new release of Enzyme.  When a fund is upgraded in Enzyme, the ComptrollerProxy is replaced by a new one while the old one is selfdestructed. The VaultProxy holding the funds remains.  After such a migration all calls from the bridge to the comptroller will fail as the contract no longer exists. This affects all three functions ( deposit / withdraw / getBalance ).  Note that function setFund() of the basket contract cannot be used to recover from this situation: This function  requires  the  fund's  balance  to  be  0.  The  call  to  the  non-existing  comptroller  will  revert  the transaction.  All shares should be redeemed before a migration is initiated. Shares remaining after a migration might be stuck with the current code.  After looking at the migration scripts present, we understand that the EnzymeBridge is to be used via a Proxy. This would allow to upgrade the implementation and recover the shares.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   No Fees", "body": "  Funds of Enzyme can configure fees investors have to pay in order to participate in a fund. These fees are paid to the fund manager in the form of shares. Note that the implementation of the Enzyme Bridge relies  on  the  fact  that  the  basket  is  the  only  shareholder  of  the  fund  and  no  other  address  holds  such shares. Hence enabled fees for the fund are not compatible with the bridge, funds of the bridge must not have fees configured.  Avantgarde Finance - Unslashed-Enzyme Bridge -   12  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Pull DAI From Vow All at Once", "body": "  During  a  kick()  call,  two  operations  (a  swap  and  a  mint)  on  the  UniswapV2  pair  are  executed consecutively. For each operation, an external call to the vat and daiJoin are invoked beforehand to pull the  required  DAI.  However,  the  pool  state  after  the  swap  can  be  precomputed,  which  means  the  total amount of DAI needed can be precomputed as well. It might be worth to do this to reduce the gas used and hence make the transactions slightly cheaper.  CS-MUF-003    The amount of DAI is now precomputed and pulled once.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Incorrect Comment", "body": "  The comment 997 is the Uniswap LP fee in _getAmountOut() is incorrect. 99.7% represents the amount after deducting the fee, and the fee is 0.3%.  CS-MUF-002  function _getAmountOut(uint256 amtIn, uint256 reserveIn, uint256 reserveOut) internal pure returns (uint256 amtOut) {     uint256 _amtInFee = amtIn * 997; // 997 is the Uniswap LP fee     amtOut = _amtInFee * reserveOut / (reserveIn * 1000 + _amtInFee); }  Specification changed:  The incorrect comment has been removed.  MakerDAO - FlapperUniV2 -   12  CriticalHighMediumLowCodeCorrectedDesignLowVersion1CodeCorrectedInformationalVersion1Speci\ufb01cationChanged              \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Revert Reason When FlapperMom Stops", "body": " Flapper  FlapperMom can inhibit FlapperUniV2 in an emergency. It does so by setting the minimum time between two  executions  of  kick()  to  type.max(uint256).  kick()  will  then  revert  due  to  the  addition overflow:  CS-MUF-001  require(block.timestamp >= zzz + hop, \"FlapperUniV2/kicked-too-soon\");  Except when kick() has never been executed before and zzz is still equal to 0, the require statement will cause the revert and emit the error MessageChannel.  MakerDAO - FlapperUniV2 -   13  InformationalVersion1  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   More Than bump Amount of DAI Used", "body": "  The Vow contract has been designed and documented with the original Flapper auctioning surplus DAI for MKR tokens in mind.  // Surplus auction function flap() external returns (uint id) {     require(vat.dai(address(this)) >= add(add(vat.sin(address(this)), bump), hump), \"Vow/insufficient-surplus\");     require(sub(sub(vat.sin(address(this)), Sin), Ash) == 0, \"Vow/debt-not-zero\");     id = flapper.kick(bump, 0); }  By design, the new FlapperUniV2 may utilize up to 2.2 times the bump amount. The Vow contract may not anticipate the Flapper using more than the bump amount of DAI.  Depending  on  the  values  set  for  bump  and  hump,  this  could  result  in  the  Vow  contract  unexpectedly holding  less  than  hump  (surplus  buffer)  amount  of  DAI  after  a  call  to  kick(),  or  a  call  to  kick() unexpectedly reverting if the required amount of DAI is not available.  This behavior is now described in the README.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Unexpected Pair State", "body": "  Generally  it  is  assumed  that  the  free  market  ensures  the  pair  represents  the  current  market  rate. However this can not be relied on as the state of the pair might be changed just before calling kick(). There  are  various  possibilities  why  the  pair  could  be  in  a  state  not  matching  the  current  market  rate. Notably e.g. in case there is an unaccounted donation of tokens in the Uniswap pool (balance > reserve), the flapper will first call sync() on the pair and swap on the updated balances afterwards. This state can also be reached by an attacker donating and calling sync directly. Furthermore the state may be changed by trading.  Generally the possible manipulation is bounded by the following checks:  In case the swapping ratio deviates too much from the reference price feed, kick() will revert.  In case the liquidity of the pool is too shallow and the amount of surplus deposited back goes over 120% of swapped, kick() will also revert.  In theory, the following manipulations by donations are possible:   One can donate within the price tolerance want to make the flapper trade at a bad price.   One  can  intentionally  donate  to  revert  a  kick()  by  pushing  the  price  out  of  the  price  tolerance  want.   One  can  also  donate  to  increase  the  liquidity  and  make  a  kick()  which  was  going  to  revert  (deposited larger than 120% of swapped) succeed.  MakerDAO - FlapperUniV2 -   14  NoteVersion1NoteVersion1        \fMakerDAO is aware and adds the following considerations:  * One can donate within the price tolerance want to make the flapper trade at a bad price - the assumption is that any trade above `want` is viable. It is of course possible for anyone to move the price with a swap, which is probably even more economical than a donation. As long as `want` and `lot` are set correctly both type of attempts should not be economical and are of course known limitations of a permissionless system.  * One can intentionally donate to revert a kick() by pushing the price out of the price tolerance want - same as above, this can happen with a swap and is a known given. Keepers can use flashbots to avoid it.  * One can also donate to increase the liquidity and make a kick() which was going to revert (deposited larger than 120% of swapped) succeed - if the kick succeeds it is intended behavior.  MakerDAO - FlapperUniV2 -   15  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Weights in Balancer Managed Pools Can", "body": " Change  The Balancer V2 price feed reads the weights of the Balancer pool during deployment and stores them as  immutable.  The  oracle  also  supports  managed  pools,  with  getActualSupply(),  but  from  the Balancer documentation (https://web.archive.org/web/20230928124529/https://docs.balancer.fi/concepts /pools/managed.html#weights) the weights can be changed by the pool owner. Changing the weights of the pool will break the oracle as the price of the respective lp tokens depends on these weights.  CS-GEARV3ORACLES-004  Spec changed:  Gearbox Protocol responded that they do not intend to support Balancer-managed pools.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Missing Duplicate Signer Check", "body": "  In the constructor of the RedstonePriceFeed contract, there is no check for duplicate signer address in the _signers array. If the number of unique signers does not exceed the required threshold, the oracle will not be able to update its price and will become unusable.  CS-GEARV3ORACLES-005    Gearbox Protocol - Gearbox V3 Oracles -   12  CriticalHighMediumSpeci\ufb01cationChangedLowCodeCorrectedCodeCorrectedCodeCorrectedDesignMediumVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                \fA  check  for  duplicates  has  been  added  to  the  constructor.  The  deployment  will  revert  if  there  are duplicates or if the number of signers does not reach the required threshold.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Gas Optimizations", "body": "   The  function  latestRoundData  of  contracts  ZeroPriceFeed  and  RedstonePriceFeed  unnecessarily define the variables answer and updatedAt.  CS-GEARV3ORACLES-002    The unnecessary variables have been removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Permissionless Updating Bounds", "body": "  LPPriceFeed.updateBounds() allows everyone to update the bounds of an LP price oracle should updateBoundsAllowed  be  set  to  true.  The  bounds  depend  on  the  current  LP  price  reported  by  the reserve oracle and the prices of the underlying assets. It is important to note that if the price of the LP protocol  can  be  manipulated,  then  the  bounds  will  also  be  wrongly  updated.  Hence,  enabling  the permissionless update of the bound should be carefully considered by the governance of the protocol.  CS-GEARV3ORACLES-003    The buffer size has been increased from 0.2% to 1%, allowing a lower lower-bound.  The function LPPriceFeed.setUpdateBoundsAllowed() has been split into two functions:   LPPriceFeed.allowBoundsUpdate(): only the configurator can enable permissionless updates   LPPriceFeed.forbidBoundsUpdate():   the  configurator  and   the  controller  can  disable  permissionless updates  The function LPPriceFeed.updateBounds() has been modified in the following ways:   a cooldown of 1 day between to permissionless updates is enforced  the current LPPriceFeed explicitly cannot be its own reserve price feed  the reserve exchange rate must be within the bounds  Gearbox Protocol - Gearbox V3 Oracles -   13  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected              \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Pricefeed Addresses Order", "body": "  CS-GEARV3ORACLES-001  In  the  contracts  BPTStablePriceFeed  and  CurveStableLPPriceFeed,  the  number  of  assets  is derived from the content of the priceFeeds array. The number of assets will be the number of non-zero addresses  before  the  first  zero  address  in  the  array.  It  means  that  if  an  array  of  the  form [priceFeed0,  priceFeed1,  address(0),  priceFeed2]  the  construction arguments, the oracle will only consider 2 assets.  is  passed   in   Acknowledged:  Gearbox Protocol is aware of this special case.  Gearbox Protocol - Gearbox V3 Oracles -   14  InformationalVersion1Acknowledged    \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Implementation of the Integrated ERC4626", "body": "  The  implementation  of  the  ERC4626  that  are  whitelisted  for  use  within  Gearbox  Protocol  V3  must  be carefully  reviewed.  As  the  standard  makes  very  few  assumptions  about  the  implementation  of  a tokenized vault, many issues might arise such as the possibility of read-only reentrancy.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Read-only Reentrancy on Curve and Balancer", "body": " Pools  to  possible   Some of the ETH Curve pools send ETH to the LP before the other tokens when removing liquidity, this leads  returned  by get_virtual_price() is over-evaluated. An attacker could use this to do bad trades or increase its leverage, but it will become liquidatable right after the transaction.  reentrancy.  During  such   reentrancy,   the  value   read-only   This is also valid for Balancer V2 and the function getRate() and getActualSupply (see https://web .archive.org/web/20230928133723/https://docs.balancer.fi/reference/contracts/apis/managed.html#getac tualsupply).  The prices of all LP price feeds are bounded. This means an attack-based read-only reentrancy can have very limited if any benefit for the attacker. Of course, this is based on the assumption that the bounds are set to reasonable values the prevent such attacks.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.3   RedStone Price Update Frequency", "body": "  The  use  of  RedStone  price  oracle  in  the  system  allows  for  high-frequency  price  updates  compared  to more  traditional  price  oracles  like  ChainLink.  This  means,  in  case  of  rapid  price  fluctuations,  credit accounts  may  become  liquidatable  or  seem  like  they  hold  a  higher  value  allowing  them  to  borrow  or withdraw more assets.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.4   Use of Stored Exchange Rate for Compound", "body": " V2  In  CompoundV2PriceFeed  the  price  of  the  lp  tokens  is  computed  using  exchangeRateStored(). The  alternative  is  exchangeRateCurrent()  which  returns  a  more  recent  price  as  it  iternally  calls accrueInterest(). It is important to note that exchangeRateStored() is called from within a view  Gearbox Protocol - Gearbox V3 Oracles -   15  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \ffunction and thus it's a view function itself. exchangeRateCurrent() cannot be used as it is not a view function.  Gearbox Protocol - Gearbox V3 Oracles -   16  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Some CryptoSwap Pools Do Not Implement", "body": " the lp_price() Function  Not every CryptoSwap pool of the Curve protocol implements the lp_price() function that is used in the CurveNPAPTokensPriceProvider. The only exception that was added is the tricrypto2.  Acknowledged:  Silo Finance replied:  We will implement them if we need it. For now we need only tricrypto2.  Silo Finance - Curve & Convex Feature -   11  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedCorrectnessLowVersion1Acknowledged             \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings   Curve LP Oracle Is Vulnerable to Read-Only Reentrancy Attacks    CurvePriveProvider Uses the Spot Price   -Severity Findings   Collateral Token Transfers Are Not Taken Into Account   -Severity Findings   Missing Shutdown Logic   -Severity Findings   A Metapool Could Have More Than One Nested LP Token    Metapool Setup Recursion Lacks Sanity Check    Metapools With Two LP Underlying    Missing Events for State Modifying Actions    The Reward Integral Computation Can Overflow   IWrapperDepositor Not Implemented   2  1  1  6  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Curve LP Oracle Is Vulnerable to Read-Only", "body": " Reentrancy Attacks  The Curve LP oracle smart contracts can be manipulated by using the read-only reentrancy vulnerability. This is because no checks are done regarding the reentrant state of the curve pool. For further details please see our blog post: https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/.    A protection mechanism has been implemented.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   CurvePriveProvider Uses the Spot Price", "body": "  The  CurvePriceProvider  smart  contract  uses  the  spot  price  of  the  curve  pool  to  get  the  price  of assets. This is done by calling the get_dy() function on the curve pool.  Silo Finance - Curve & Convex Feature -   12  CriticalCodeCorrectedCodeCorrectedHighCodeCorrectedMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignCriticalVersion1CodeCorrectedSecurityCriticalVersion1CodeCorrected                 \fHence, an attacker could easily manipulate the price with a flash loan or a lot of liquidity. If this oracle is used  as  a  source  of  truth  for  a  borrowing  or  liquidation  mechanism,  funds  could  be  stolen  from  the protocol.  Further note, that also the IPriceProvider's NatSpec is not accurate in that case as it specifies that the TWAP is calculated.  Code removed:  All related code has been removed. Curve is not used as a price provider anymore.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Collateral Token Transfers Are Not Taken Into", "body": " Account  The balance used for payouts is the sum of the ERC-20 balance and the user's Silo collateral-only shares (converted to the ERC-20). Hence, each change in one of these balances must ensure the correctness of payouts. While the ConvexStakingWrapperSilo contract performs reward checkpointing for each ERC-20 balance change, the integration with the Silo fails to integrate such checkpoint fully, thus allowing both theft and loss of rewards.  A lack of checkpointing is present   When  a  user  transfers  the  collateral  tokens:  Transferring  collateral  tokens  does  not  trigger  any  checkpointing.   When a user uses the depositFor() function in the silo: The checkpointing will be done for the  transfer, however, minting collateral tokens will not checkpoint for the recipient.   When a user is being liquidated: The liquidated user will not be involved in checkpointing and loses  his rewards. The liquidator does not receive the rewards as a liquidation bonus.   When a user uses the router to withdraw the collateral: The router will be checkpointed. The user will  temporarily get a smaller balance accounted which will lead to unfair checkpointing for the user.  Most  notably,  the  collateral  token  transfers  would  allow  for  a  simple  attack  by  transferring  collateral tokens from address to address to claim rewards with each.  Further,  note  that  the  function  syncSilo()  could  change  the  silo  which  is  used  for  additional accounting. However, that could break the contract and unfairly distribute rewards.  To summarize, collateral token transfers do not checkpoint and transfers of tokens between the silo and a user, who was not the prior owner of these tokens, update the rewards only for the receiver.    Silo  Finance  has  added  a  Silo  type  called  SiloConvex  which  updates  reward  for  concerned  users before  any  actions.  Router,  current  silo  and  deprecated  silos  cannot  be  checkpointed  for  rewards anymore.  Further,  ShareCollateralTokenConvex  has  been  introduced  that  checkpoints  before  any  direct transfer between users.  Note that when the collateralVault variable is updated through syncSilo(), some rewards could still be lost, but this is now part of the specification.  Silo Finance - Curve & Convex Feature -   13  CorrectnessHighVersion1CodeCorrected          \f6.4   Missing Shutdown Logic  Each ConvexStakingWrapper smart contract can be shut down by the owner so that accounting of the rewards  stops  and  users  are  only  able  to  withdraw  their  shares  of  the  pool.  Rewards  will  not  be accounted  for  anymore  when  moving  wrapped  tokens  around  because  the  _checkpoint()  function does not apply any logic when the isShutdown flag is set to true.  However, the _checkpointAndClaim() function does not have any such check for the flag, meaning that  users  are  still  able  to  claim  their  rewards  after  the  shutdown.  Users  could  also  still  transfer  the wrapped tokens without the wrapper checkpointing it so an attacker could manipulate its balance to steal some rewards.    Both functions now implement the shutdown logic.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   A Metapool Could Have More Than One", "body": " Nested LP Token  The CurvePAPTokensPriceProvider retrieves all the underlying tokens for the LP token. For meta pools, the underlying LP token's coins are retrieved.  However, when the nested depth is equal to or greater than 2, it directly tries to fetch the price of the last lp token instead of continuing to fetch the underlying tokens.    Code  now  correctly  fetches  all  nested  tokens  recursively.  Note  that  if  the  total  amount  of  underlying tokens exceeds eight, the code will revert which is expected.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Metapool Setup Recursion Lacks Sanity", "body": " Check  Metapools are StableSwap pools where at least one underlying is a Curve LP token. To set up such a metapool LP token, setupAsset() in CurvePAPTokensPriceProvider recursively sets up all underlying LP tokens. However, the recursive iterations of _setUp() lack the _MIN_COINS sanity check and the LPTokenEnabled event emission.  Code Corrected:  The  check  and  the  event  emission  are  now  in  the  _setUp()  function  which  is  used  for  recursively iterating over the potentially nested LP tokens.  Silo Finance - Curve & Convex Feature -   14  DesignMediumVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f6.7   Metapools With Two LP Underlying  Note that Metapools can have only one LP underlying. However, the current design would allow for bad pools with two LP tokens as underlyings - one as a regular coin and one as the base asset.    The code now reverts if there are two lp underlyings.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Missing Events for State Modifying Actions", "body": "  In ConvexStakingWrapper, some important state-modifying actions do not trigger events:   Shutting down a staking wrapper   Adding a reward token   Setting the hook   Checkpointing users  Emitting events could ease following the state of the contract.    Events have been added for all of the above.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.9   The Reward Integral Computation Can", "body": " Overflow  ConvexStakingWrapper  uses  solidity  0.6.12  which  can  overflow  on  arithmetic  operations.  The staking wrapper uses a variable called reward_integral to track each token reward by increasing it proportionally to the received rewards. Note that this variable should only be able to increase.  At line 275, it computes it in such a way:  reward.reward_integral = reward.reward_integral + uint128(bal.sub(reward.reward_remaining).mul(1e20).div(_supply));  The  addition  here  can  overflow  to  a  decrease  of reward_integral. A decrease in the variable would mean that some users would have their rewards locked forever in the smart contract.  in  some  conditions,  which  would   lead   Also  note  that  the  truncation  to  a  uint128  in  the  second  part  of  the  code  line  can  also  lead  to  a truncation overflow, which would miscompute the received rewards.  While the supply is low, the overflow can be triggered very easily. Using this capability, an attacker could grieve users from receiving rewards by pushing the users' reward integrals to the maximum so that the global reward integral cannot exceed the users' reward integral.  Silo Finance - Curve & Convex Feature -   15  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                      \f  The reward variables are now stored as uint256.  Silo Finance noted:  Contract is updated to store the rewards integral in 256 bits variables. This fix makes the integral overflow improbable for regular reward tokens, even if the total supply of the wrapped token is 1 wei.  Here  reward_integral  could  still  overflow  but  as  stated  by  Silo  Finance,  it  is  much  less  probable given that reward tokens should not be of very low value or with unusually high decimals.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.10   IWrapperDepositor Not Implemented", "body": "  Most  of  the  contracts  interact  with  each  other  based  on  the  interface  definitions.  However,  the ConvexStakingWrapperSilo contract itself does not implement the IWrapperDepositor. Without this,  there  are  no  compile-time  guarantees  that  the  contract  will  be  compatible  with  the  calls  to  the functions that the interface defines. This can lead to potential runtime errors and exceptions that are hard to debug. Explicitly defining that a contract implements an interface could minimize such errors.    ConvexSiloWrapper now implements IConvexSiloWrapper.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.11   A Collateral-Only Silo Can Have Its ", "body": " siloAsset Borrowed  During the audit, we uncovered that a silo with a collateral-only asset could still have this asset borrowed. More specifically, this can happen when tokens are sent directly to the silo. The collateral-only funds are not affected but the specification is violated.  /// @notice Modification of the Silo where a siloAsset can be deposited /// only as collateral only asset and can't be borrowed.    if (_isSiloAsset(_asset)) revert(); has been added to borrow() and borrowFor() in the specialized Silos for Curve and Convex. However, note that the exact mechanics are out of scope, and if there is alternative way to borrow, the issue could still persist.  Silo Finance - Curve & Convex Feature -   16  DesignLowVersion1CodeCorrectedInformationalVersion1CodeCorrected                \f6.12   Missing NatSpec  Most functions are provided with documentation. However, CurvePriceProviderETH does not have any  NatSpec  for ICurvePriceProvider's  getAssetPool()  and  isAssetPoolUint256()  functions.  Also, _getDy() in the CurvePriceProvider is not fully documented.  for  NULL_ADDRESS,  WETH  and  _getCoin().  Further,  NatSpec   lacks     The files have been removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.13   Usage of registryId", "body": "  Pool.registryId is never used.    Silo Finance removed the registryId as it was unused.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.14   Variables Visibility", "body": "  In  CurveLPTokenDetailsBaseCache,  coins  is  public  and  has  hence  an  automatic  getter. However, getCoins() has the same behavior as the automatic getter and thus there is a double getter for the elements.  In CurvePriceProvider, NOT_FOUND_INDEX is public. However, it is only used for protocol internal logic.    getCoins() was removed. Hence, coins() remains the only public getter.  CurvePriceProvider has been removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.15   isMeta for Crypto Pools", "body": "  The isMeta flag is present for Curve crypto pools. However, note that these pools are not meta pools. The CurveCryptoSwapRegistryFetcher can set it to true. However, it has no effect.    Client added a sanity check to ensure the validity of the pools data returned by fetchers.  Silo Finance - Curve & Convex Feature -   17  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                      \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Balancer Oracles Are Deprecated", "body": "  During  the  audit  we  discovered  that  the  protocol  uses  the  Balancer  V2  oracles.  However,  note  that their  oracles  here:  https://docs.balancer.fi/products/oracles Balancer  discourages  (snapshot).  the  usage  of   Acknowledged:  Silo Finance replied:  The Silo team is aware of this  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Code With No Effects", "body": "  The ConvexStakingWrapper smart contract contains code without any real effects.  On line 215:  if(registeredRewards[_token] == 0){         ... }else{         uint256 index = registeredRewards[_token];         if(index > 0){...} }  The second if will always be executed as index will always be greater than 0.  On lines 167, 169, 210: Token transfers to self has no effect.  Acknowledged:  Silo Finance replied:  We decided to make minimal changes in external contracts that we inherit. Refactoring is out of scope of this feature.  Silo Finance - Curve & Convex Feature -   18  InformationalVersion1AcknowledgedInformationalVersion1Acknowledged            \f7.3   Commented Code  The following comment contains a line of commented-out code.  // collateralVault = _vault;  Removing the line could improve readability.  Acknowledged:  Silo Finance replied:  We decided to make minimal changes in external contracts that we inherit. Refactoring is out of scope of this feature.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Gas Inefficiencies", "body": "  The staking wrapper for convex contains several gas inefficiencies. The following is an incomplete list of examples:   More state variables could be constants and immutables.   \"Double-initialization\" performs some storage writes twice (e.g. setting the owner)   When adding rewards, the rewards length is always read from storage.   registeredRewards is read twice in the else branch of addTokenReward().   _calcRewardIntegral reads variables multiple times from storage (e.g. reward_remaining)  Acknowledged:  Silo Finance replied:  We decided to make minimal changes in external contracts that we inherit. Gas optimization in external contracts is out of scope of this feature.  Silo Finance - Curve & Convex Feature -   19  InformationalVersion1AcknowledgedInformationalVersion1Acknowledged          \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Collateral-only Assets", "body": "  Neither  the  Curve  LP  tokens  nor  the  wrapped  Convex  tokens  are  suitable  for  borrowing  due  to  their prices  being  easily  but  legitimately  pushed  upwards.  Hence,  the  tokens  are  only  suitable  as  collateral assets.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Convex DOS Potential", "body": "  In the convex staking wrapper contract, checkpointing could iterate over many tokens. If Convex adds too many reward tokens, the checkpointing could be DOSed. While Convex is trusted in that sense, users should be aware of such a possibility.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.3   Duplicate Tokens Undervalue Estimation of", "body": " Rewards  In  the  ConvexStakingWrapper  smart  contract,  extra  reward  tokens  are  queried  from  the  convex reward pool and can also be added manually by the owner.  If there is a case of a pool that receives rewards of the same token from two different reward pools, then only  one  of  these  will  be  queried  with  the  earned()  to  estimate  the  rewards  for  this  token  in  the earnedView() function of the staking wrapper, leading to low reward estimations.  Further  note  that  any  reward  token  that  has  no  reward_pool  associated  will  have  its  rewards undervalued in the view functions. However, note that Convex is not expected to behave in such a way.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.4   Function Interface Is Not Validated", "body": "  In  CurvePriceProvider,  the  manager  must  provide  a  GET_DY_INTERFACE  enum  due  to  the interfaces of the get_dy() function being different across curve pools. However, this enum is not sanity checked while most other set-up arguments are and a pool with the wrong interface could be saved to storage.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.5   Oracle Manipulation", "body": "  Silo Finance - Curve & Convex Feature -   20  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion1                  \fNote  that  any  on-chain  oracle  is  manipulatable  to  some  degree.  Hence,  the  prices  of  assets  could  be manipulable to some extent.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.6   Read-only Reentrancy Protection", "body": "  Users and Silo Finance should be careful when the gas costs of opcodes change in new hardforks as this could lead to breaking changes. Hence, this should be monitored. Further, the selection of parameters should be carried out with gas measurements on the pools since different Vyper versions and pools may need to different parameters.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.7   The Curve LP Oracles Fetch the Minimum", "body": " Price  The  Curve  lp  oracles  will  fetch  a  price  that  is  a  lower  bound  on  the  LP  token  price.  When  used  as  a collateral, users should know that this is the case and be extra careful to avoid unnecessary liquidations.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.8   Unsupported Reward Tokens", "body": "  Users  should  be  aware  that  reward  tokens  that  can  change  the  amount  differently  from  the  amount transferred could unfairly distribute rewards and could break the contract.  Especially,  rebasing  tokens  could  break  the  contract  if  a  rebase  downwards  occurs.  Further,  reward tokens with transfer fees could create problems.  Silo Finance - Curve & Convex Feature -   21  NoteVersion1NoteVersion1NoteVersion1            \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   setMaxAnswer Missing Sanity Check", "body": "  The  function  MCAGAggregator.setMaxAnswer  simply  sets  the  storage  variable  _maxAnswer  to  the input argument. As the input argument is defined as signed-integer, mistakenly setting _maxAnswer to a negative value, blocks any further calls with positive arguments to MCAGAggregator.transmit().  CS-MCAG-004    Checks to prevent setting negative values have been added to setMaxAnswer() and in the constructor:  if (maxAnswer_ < 0) {     revert Errors.MAX_ANSWER_TOO_LOW(maxAnswer_, MIN_MAX_ANSWER); }  and MCAGAggregator.setMaxAnswer():  if (newMaxAnswer < 0) {     revert Errors.MAX_ANSWER_TOO_LOW(newMaxAnswer, MIN_MAX_ANSWER); }  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Mcag accessController Uses Undocumented", "body": " Roles  The following two roles are used in AccessController of mcag, but not documented in the README:  CS-MCAG-002  1. MCAG_SET_TNC_ROLE  2. MCAG_SET_MAX_COUPON_ROLE  Mimo Capital AG - MCAG Contracts -   11  CriticalHighMediumLowCodeCorrectedCorrectnessLowVersion1CodeCorrectedInformationalVersion1Speci\ufb01cationChanged              \fSpecification changed:  Mimo Capital AG has added the definition of the two aforementioned roles to the README, as well as functions callable by these two roles.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Unused Constant MIN_TERM", "body": "  The defined constant MIN_TERM in the contract KIBTAggregator is defined but not used.  CS-MCAG-003    Mimo Capital AG has removed the definition of this unused constant.  Mimo Capital AG - MCAG Contracts -   12  InformationalVersion1CodeCorrected      \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Define Relevant Fields in the Events as", "body": " Indexed  Although some event fields are already defined as indexed, it might make sense to define further ones as indexed as well. Defining event fields as indexed makes searching for specific addresses/values easier.  CS-MCAG-001  Mimo Capital AG - MCAG Contracts -   13  InformationalVersion1  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   KIB Price Determination & Volatility", "body": "  It  may  be  obvious  that  one  KIB  token  should  be  priced  at  one  unit  of  the  underlying  principal  token. However  due  to  low  liquidity,  constraints  around  the  redemption  of  KIB  tokens  (accruing  sufficient  KIB tokens, buying the bond of the protocol, off-chain redemption) the price may fluctuate. Furthermore, low liquidity in e.g. Uniswap pools results in notable price volatility / slippage when trading as well as potential price manipulation.  KIBTAggregator  serves  as  a  price  feed  for  KIB  tokens.  This  pricefeed  returns  a  value  that  is  manually updated. Its price might deviate from the tokens actual valuation across the DeFi system and must be used with care.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Updating Terms and Conditions", "body": "  KUMABondToken  allows  to  update  the  terms  and  conditions  URL  for  an  already  existing  Bond  NFT. Although being callable only by holder of MCAG_SET_TNC_ROLE role, it might bring legal complexities, as users  buy  a  bond  token  given  the  terms  and  conditions  during  the  purchase.  Changing  terms  and conditions for a sold bond token should be treated with extra caution.  Mimo Capital AG - MCAG Contracts -   14  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Proxy Wallet DoS", "body": "  0  0  2  0  As  can  be  seen  in  RelayHub  account  can  be  drained,  all  the  funds  of  the  ProxyWalletFactory account  on  the  GSN  RelayHub  can  be  completely  drained.  Since  Polymarket  currently  executes signatures  with  a  gasPrice  set  to  1,  the  calls  can  only  be  successfully  relayed  as  long  as  there  are funds  available.  If  an  attacker  were  to  completely  drain  the  account,  no  new  transactions  can  be performed until either:  CS-PMPWF-002   The process is changed to create signatures with a gasPrice of 0.   The RelayHub balance is replenished.  Specification changed:  Relayer clients will now use a gas price of 0.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   RelayHub Account Can Be Drained", "body": "  CS-PMPWF-001  calls   Relayed  calling the  ProxyWalletFactory.acceptRelayedCall() to determine, whether a call is paid for by the funds deposited to the RelayHub by Polymarket. Using the GSNModule01 always accepts any call that targets the factory's proxy() function.  RelayHub   executed   GSN   over   are   Since  neither  the  relayer  nor  the  transactionFee  are  verified,  any  account  can  perform  a transaction on the RelayHub with a transactionFee set to an amount that completely drains the balance of the ProxyWalletFactory. This fee is then credited to the relayer's balance and can be withdrawn.  Specification changed:  Polymarket - Proxy Wallet Factories -   11  CriticalHighMediumSpeci\ufb01cationChangedSpeci\ufb01cationChangedLowSecurityMediumVersion1Speci\ufb01cationChangedSecurityMediumVersion1Speci\ufb01cationChanged                \fPolymarket  now  publishes  signatures  with  a  gas  price  of  0,  allowing  them  to  execute  the  transactions without  any  balance  changes  in  the  RelayHub.  The  balance  in  the  RelayHub  can  therefore  be withdrawn completely, mitigating any possible draining.  Polymarket - Proxy Wallet Factories -   12  \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Ambiguous Naming", "body": "  The name of the function ProxyWalletFactory.deployImplementation() does not start with an underscore although all other internal functions do so.  CS-PMPWF-003  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Code Copies", "body": "  ProxyWalletLib  computeCreationCode()). The libraries could be merged into one.  FactoryLib   contain   and   overlapping   CS-PMPWF-004  code   parts   (e.g.,  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Gas Optimizations", "body": "  The following gas inefficiencies can be improved:   The  implementation  address  in  ProxyWalletFactory  could  be  replaced  by  an  immutable  CS-PMPWF-005  variable.   The whitelistedRelayer in GSNModule03 can be immutable.   The storage variables of SafeProxyFactory can be immutable.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Irregular Rejection Code", "body": "  All GSN modules return 1 when rejecting a call. According to the GSN specification, however, the correct code for rejection is at least 11 as codes 1 - 10 are reserved.  CS-PMPWF-008  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Lost Revert Errors", "body": "  RevertCaptureLib can not handle custom error messages. Instead, a default error is returned which removes information in the output.  CS-PMPWF-006  Polymarket - Proxy Wallet Factories -   13  InformationalVersion1RiskAcceptedInformationalVersion1RiskAcceptedInformationalVersion1RiskAcceptedInformationalVersion1RiskAcceptedInformationalVersion1RiskAccepted                            \f7.6   Missing Event  ProxyWalletFactory.makeWallet() does not emit an event on successful proxy wallet creation.  CS-PMPWF-007  Polymarket - Proxy Wallet Factories -   14  InformationalVersion1RiskAccepted      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Rogue Strategy Can Override Storage", "body": "  Core accounting logic is done by the code of TokenizedStrategy which is executed as Delegatecall inside the context of the strategy.  The documentation states the following:  In order to limit the strategists need to think about their storage variables all TokenizedStrategy specific variables are held within and controlled by the TokenizedStrategy. A BaseStrategyData struct is help at a custom storage location that is high enough that no normal implementation should be worried about hitting.  CS-YTS-004  This means all high risk storage updates will always be handled by the TokenizedStrategy, can not be overriden by a rogue or reckless strategist and will be entirely standardized across every strategy deployed, no matter the chain or specific implementation.  A  rogue  or  reckless  strategist  can  overwrite  any  storage  slot,  including  those  at  the  address keccak256(\"yearn.base.strategy.storage\") - 1 and subsequent addresses.  While a genuine strategy wouldn't do this and the concept to separate the storage ensures that with high probability a specific implementation is unlikely do to so by accident, a rogue or reckless strategies can do so intentionally.  Specification changed:  Yearn acknowledged this risk and corrected the specification.  Yearn - Tokenized Strategy -   12  CriticalHighMediumSpeci\ufb01cationChangedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedRiskAcceptedSpeci\ufb01cationChangedCorrectnessMediumVersion1Speci\ufb01cationChanged           \f6.2   Initializing TokenizedStrategy  The deployed instance of TokenizedStrategy is only intended to be used via Delegatecall by the custom strategies.  However  the  functions  of  the  contract  are  also  directly  callable.  For  example  the  first  caller  of TokenizedStrategy.init() can initialize the contract. While this doesn't break it's intended use as base for the delegatecalls, it's not desirable.  It's worth noting that after initialization, deposits will still fail due to the callback to the invest() function.  Other functions may execute successfully, such as approvals, role assignments, and parameter updates.  CS-YTS-008    A  constructor  has  been  added  to  TokenizedStrategy  which  initializes  the  implementation  with _strategyStorage().asset=address(1).  As  a  result,  further  direct  calls  to  initialize()  will revert.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Non ERC-4626 Compliant Functions", "body": "  maxMint  may  revert  due  to  an  overflow  in  a  calculation,  however  according  to  the  specification  this function  must  not  revert.  This  may  happen  in  an  edge  case  the  availableDepositLimit  returns  a large number and pps<1, convertToShares may overflow.  CS-YTS-007  function maxMint(address _owner) public view returns (uint256 _maxMint) {     _maxMint = IBaseTokenizedStrategy(address(this)).availableDepositLimit(         _owner     );     if (_maxMint != type(uint256).max) {         _maxMint = convertToShares(_maxMint);     } }  In  case  the  strategy  is  in  shutdown  mode,  no  further  deposit  can  be  made.  However,  maxDeposit() may not return 0 when the strategy is shutdown.  The ERC-4626 specification however requires the function to return 0 in this case:  ... if deposits are entirely disabled (even temporarily) it MUST return 0.  More  informational,  the  ERC-4626  specification  is  loosely  defined  in  these  corner  cases  for  these functions. Nevertheless we want to highlight the potentially unexpected amounts returned:  previewRedeem(): In case totalAssets is zero, the conversion is done at a 1:1 ratio. At this point either no shares exist (I) or the value of the existing shares has been dilluted to 0 (II). For (I) the returned value  of  0  is  appropriate.  For  (II)  previewRedeem()  does  not  revert  while  redeem()  reverts;  the specification reads:  Yearn - Tokenized Strategy -   13  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \fMAY revert due to other conditions that would also cause redeem to revert.  previewWithdraw()  returns  the  amount  in  a  1:1  exchange  rate  when  assets==0  but  shares!=0. Again for non-zero values the amount returned may be misleading.  Strictly  speaking  the  value  returned  is  not  breaking  the  specification  but  might  be  unexpected  by  the caller.  The  caller  should  be  aware  of  this  and  any  external  system  should  exercise  caution  when integrating with these functions.    A  comment  has  been  added  to  availableDepositLimit  to  alert  the  strategist  of  the  potential overflow of maxMint() if the deposit limit is too large. In addition, maxDeposit() and maxRedeem() have  been  updated  to  return  0  when  the  strategy  is  shutdown.  previewWithdraw()  and convertToShares()  have  been  adjusted  to  return  0  instead  of  pps=1  in  case  assets==0  but supply>0.  Yearn  also  acknowledged  return  value  of previewRedeem()  if  all  shares  are  diluted  to  0.  Strategists  and  external  systems  are  expected  to  be aware of these behaviors.  the  potential  misleading  non-zero   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Payable Fallback Functions", "body": "  The fallback function of `BaseTokenizedStrategy` is marked as payable. However, the code of the delegatecalled  TokenizedStrategy  contract  doesn't  feature  any  functionality  able  to  receive  Ether.  Any such call with a non zero msg.value will revert.  Furthermore, there is a receive() function:  CS-YTS-006  /**  * We are forced to have a receive function do to  * implementing a fallback function.  *  * NOTE: ETH should not be sent to the strategy unless  * designed for within the Strategy. There is no defualt  * way to remove eth incorrectly sent to a strategy.  */ receive() external payable {}  There  is  no  requirement  to  implement  a  receive  function  when  incorporating  a  fallback  function.  In  the absence of a receive function, plain Ether transfers would be handled by the fallback function, which then delegatecalls into the TokenizedStrategy. However, this would cause the call to revert since the contract does not support Ether reception. By including a receive function, the strategy can be enabled to accept Ether. As the comment states, Ether shouldn't be sent to the strategy unless the strategy is design for it.  For  https://docs.soliditylang.org/en/v0.8.18/contracts.html#receive-ether-function  information   please   more   refer   the   to   Solidity   documentation:    The payable modifier and the receive function have been removed to avoid unintentional Ether reception.  Yearn - Tokenized Strategy -   14  DesignLowVersion1CodeCorrected          \f6.5   Problematic Self-Minting When Fee Recipient Is the Contract Itself  CS-YTS-005  Transferring  shares  of  the  strategy  to  itself  is  prevented  since  it  can  interfere  with  the  locked  shares mechanism  which  guards  against  abrupt  price  per  share  increases.  Unlike  _transfer(),  _mint() does  not  feature  this  restriction  since  it  is  intended  to  mint  shares  for  this  contract  as  part  of  the  profit locking mechanism. An explicit check must be done in the function calling _mint(). While this is done in _deposit(), such a check isn't done on the fee recipients.  When  the  performanceFeeRecipient  is  set  as  the  strategy  itself,  it  becomes  possible  to  mint additional shares to the strategy, which are not intended to be locked shares.  Once  enough  time  passes  and  the  fullProfitUnlockDate  is  reached,  _unlockedShares()  will treat the entire balance of this contract, including these additional shares, as unlocked shares.  if (_fullProfitUnlockDate > block.timestamp) {     unchecked {         unlockedShares =             (S.profitUnlockingRate * (block.timestamp - S.lastReport)) /             MAX_BPS_EXTENDED;     } } else if (_fullProfitUnlockDate != 0) {     // All shares have been unlocked.     unlockedShares = S.balances[address(this)]; }  Due  to  the  presence  of  extra  shares,  there  may  be  a  sudden  increase  when  querying  the unlockedShares just before and right after the fullProfitUnlockDate.  This effect may have an impact whenever _totalSupply() is called and may influence the the price per share.  Additionally process_report() is affected. In case the fullProfitUnlockDate has already been reached these shares would simply get burned in _burnUnlockedShares(). Otherwise these shares will be considered as part of the previouslyLockedShares and are locked in the new locking period. Note as this is an increase of the previouslyLockedShares it will impact the calculation of and reduce the newProfitLockingPeriod:  // new_profit_locking_period is a weighted average between the remaining     // time of the previously locked shares and the PROFIT_MAX_UNLOCK_TIME     uint256 newProfitLockingPeriod = (previouslyLockedShares *         remainingTime +         sharesToLock *         _profitMaxUnlockTime) / totalLockedShares;  The issue description focuses on the performanceFeeRecipient as fee recipient, in theory the same situation could arise if the protocolFeesRecipient is set as the strategy contract.    An  extra  check  has  been  added  in  setPerformanceFeeRecipient()  as  well  as  in  init()  which prevents setting the fee recipient to address(this).  Risk accepted:  Yearn - Tokenized Strategy -   15  CorrectnessLowVersion1CodeCorrectedRiskAccepted        \fThe protocolFeeRecipient is set once for all strategies by Yearn Governance and should not be an issue.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Staticcall", "body": "  CS-YTS-009   * Using address(this) will mean any calls using this variable will lead  * to a static call to itself. Which will hit the fallback function and  * delegateCall that to the actual TokenizedStrategy.  ITokenizedStrategy internal TokenizedStrategy;  The comment says that using address(this) will result in a static call to itself, but the term \"static call\" might be misleading. In Ethereum, a \"static call\" typically refers to a STATICCALL, which is a read-only call that cannot modify the contract state. However, in this case, the comment seems to be referring to the fact that the call will simply be to the contract itself. Such calls can lead to state changes.  Specification changed:  Yearn has rephrased the comment to avoid misunderstandings. A legitimate strategist should not use this variable for state-changing calls.  Yearn - Tokenized Strategy -   16  CorrectnessLowVersion1Speci\ufb01cationChanged        \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Uncovered Loss Not Visible in Reported Event", "body": "  An event Reported will be emitted after report() is called. If an uncovered loss has been realized, this crucial information won't be visible in the event. In case a net loss occurs, price per share decrease (pps) instantly. Revealing this in the event may be useful.  event Reported(uint256 profit,uint256 loss,uint256 performanceFees,uint256 protocolFees)  CS-YTS-001  Yearn states:  The event is meant to match the Vaults event as close as possible and only reveal the amounts determined within the report call. It should be expected that most reports in strategies will be done after all shares have been unlocked since the previous reports, and therefore any loss will cause a PPS decrease. Specific strategies can use this functionalities if desired to offset losses but is not normal behavior, simply extra functionality. PPS is not tracked on chain.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Use ADDRESS Instead of SLOAD", "body": "  BaseTokenizedStrategy.initialize()  sets  the  storage  variable  TokenizedStrategy  to  the address of the executing context:  CS-YTS-002  // Set instance of the implementation for internal use. TokenizedStrategy = ITokenizedStrategy(address(this));  To call itself, the code of the BaseTokenizedStrategy and the custom strategy implementation would use this  variable  which  results  in  an  SLOAD  operation.  Note  that  opcode  ADDRESS  (in  solidity address(this))  would  return  the  same  address  (the  address  of  the  executing  account)  and  is significantly cheaper.  Yearn states:  The setting of the `TokenizedStrategy` variable in initialization is meant to make it as simple as possible for a strategist to access readable data from the StrategyData struct so having an extra SLOAD is  Yearn - Tokenized Strategy -   17  InformationalVersion1InformationalVersion1      \fworth the reduced complexity of not having to understand what is being called, just that the variable will work.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   tendTrigger", "body": "  The description of TokenizedStrategy.tend() reads:  * @dev Both 'tendTrigger' and '_tend' will need to be overridden * for this to be used.  However this is not enforced in the code, where tendTrigger() has no effect on tend(), e.g. it could return false and tend() may still execute successfully.  CS-YTS-003  Yearn states:  `tendtrigger` is only to be used off chain, by a keeper bot or management to easily determine if tend should be called, not a requirement for it to be. Tend is able to be called at any point even if the trigger does not say it should.  Yearn - Tokenized Strategy -   18  InformationalVersion1    \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Withdraw With Unrealized Loss", "body": "  In case there is an unrealized loss, the most vigilant users will come to withdraw funds directly from the idle to avoid the loss. As a result, the tardy users will take the unrealized loss. Besides, tardy users may take an unrealized loss in different ways depending on the actual implementation of _freeFunds().  If custom strategy implementation simply tries to free the funds from the yield source as closer to the requested amount as possible or simply reverts due to insufficient funds, the remaining funds will be withdrawn in a FCFS way where the last users will take all of the unrealized loss and get nothing back.  If  custom  strategy  implementation  distributes  the  unrealized  loss  according  to  the  accounting variables in StrategyData, then all tardy user will share the unrealized loss proportionally.  Different  strategists  may  take  different  choices,  whereas  the  vigilant  users  can  always  drain  the  idle regardless of the unrealized loss in both cases.  Yearn states:  So for the most part those types of decisions are to be left to the strategist to determine what to do in _freeFunds(). The majority of strategies will likely simply withdraw the amount requested, since its 1. not applicable and 2. would require a lot more gas and code to check the actual current state and calculate the full unrealized loss etc. Though if a strategy expects to have this be a common case (like with an options strategy) that specific strategist can add whatever they wish to _freeFunds. It is recommended that _freeFunds revert if losses would be realized by temporary situations. Such as liquidity constraints, that are not expected to last, rather than count it as a loss.  While its possible there are unrealized losses, normal behavior is to not account for those in between reports, but rather losses are handled withdraw by withdraw. Though that can lead to disproportionate amounts depending on when funds are withdrawn its much cheaper and simpler considering its a non-issue for the majority of strategies and the ones it is can choose how to deal with it.  Yearn - Tokenized Strategy -   19  NoteVersion1    \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Code Duplication Balance Getters", "body": "  The engine contract implements two functions: balanceRisky() and balanceStable() which return the balance of the engine for the respective token. These two functions implement the same functionality and have the same logic, therefore can be merged into a single function that takes the token address (for stable or risky) as an input parameter.  Acknowledged  The client prefers two separate functions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Event Optimization", "body": "  The  swap()  function  emits  two  events:  UpdatedTimestamp()  and  Swap()  which  can  be  integrated into one event to reduce the gas consumption.  Acknowledged  This behavior is desired by Primitive.  Primitive Finance - Core Engine -   9  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedAcknowledgedCodePartiallyCorrectedAcknowledgedAcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                   \f5.3   Sanity Checks  When  depositing,  withdrawing,  allocating,  and  swapping  (VERSION4)  the  receiving  account  can  be chosen. No basic sanity check if it is accidentally address zero is performed. Additionally, the strike price could be validated if it is not zero in create.  Code partially corrected  A sanity check for the strike price in create is implemented but no checks for address zero are added.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.4   Unused Function getRiskyGivenStable", "body": "  The function getRiskyGivenStable is declared internal but not used in the code.  Acknowledged  Primitive Finance acknowledged the issue but communicated that the function is kept as it is for now.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.5   Unused Storage Fields", "body": "  The PrimitiveEngine contract is deployed by the PrimitiveFactory contract. The engine stores the  factory  address  as  state  variable  address  public  immutable  override  factory;  and  an owner but these variables are not used.  Acknowledged  Primtive acknowledged the behavior and informed us that this is intended.  Primitive Finance - Core Engine -   10  DesignLowVersion1CodePartiallyCorrectedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  7  7  9  -Severity Findings  -Severity Findings   Low Decimal Token Issues    Anyone Can Call the Repay Function After Pool's Maturity    Borrower Locks Liquidity in the Pool    Disable Unnecessary Functionalities After Expiry    Flawed Fee and Premium Structure    No Slippage Protection    Violation of Maximum Ratio of Float Liquidity   -Severity Findings   Token Decimal Validation    Explicitly Handling Positive Invariant Restriction   Incorrect Tracking of Cumulative Values for Pool Reserves    Liquidity Providers Get Rewards Without Supplying Float Liquidity    Possible Overflows    Possible to Frontrun on Claim Request    Redundant and Improper Revert Condition   -Severity Findings  Inconsistency of Input Parameters    Unused Error Definition    Redundant Storage Read    Code Duplication    Duplicated Calculation of Invariant   Implementation of getStableGivenRisky Function    Possible Gas Optimization in the Deposit Function    Return Value in safeTransfer    MANTISSA_INT Constant   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Low Decimal Token Issues", "body": "  Primitive Finance - Core Engine -   11  CriticalHighCodeCorrectedSpeci\ufb01cationChangedSpeci\ufb01cationChangedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedSpeci\ufb01cationChangedMediumCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedLowCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignHighVersion3CodeCorrected           \fThe  lower  the  decimals  of  a  token  are  and  the  higher  the  value,  the  more  severe  rounding  issues  will become. Simultaneously, the liquidity position accounting with 18 decimals will cause issues.  Examples issues are:  Burning one unit of a low decimal but high value token (in create) might be a huge loss for the user.  There  is  a  dependency  between  the  delta  when  creating  a  pool  and  the  decimals  of  a  token.  delta cannot be chosen freely because of this dependency (1e18 - delta) - 1e(18-decimals) needs to  be  bigger  than  1,  else  the  create  will  revert.  This  basically  eliminates  the  support  of  zero  decimal tokens (as the only viable option is delta = 0). Low decimals limit the range of delta and the step accuracy  with  which  the  risky  token  amount  is  calculated.  E.g.  the  maximum  value  of  delta  can  be 9e17  (should  be  1e18)  for  1  decimals,  99e16  for  2  decimals  and  so  on.  The  step  size  should  be accordingly high to increase the resulting delRisky one unit.  With decreasing decimals this calculation will lose precision if the token decimals are not dividable by the fraction delLiquidity / PRECISION with modulo zero.  delRisky = (delRisky * delLiquidity) / PRECISION; // liquidity has 1e18 precision, delRisky has native precision delStable = (delStable * delLiquidity) / PRECISION;  The  function  getAmounts  has  a  similar  problem  and  will  losing  precision.  This  can  be  exploited  in allocate  to  receive  more  liquidity  tokens  than  the  user  would  be  entitled  to  as  the  rounding  in allocate is in the user's favor.  Code corrected  The  issues  above  have  been  tackled  by  only  accepting  token  decimals  between  six  and  18.  Six  was chosen to support famous stable coins and did not lead to issues in tests. However, tests and fuzzing does not cover all possible states and due to the complex math, there might be a state that still results in issues regarding to the decimals.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Anyone Can Call the Repay Function After", "body": " Pool's Maturity  After the pool's maturity has passed, i.e., the pool has expired, anyone can call the function repay() for any borrower and receive their premiums in case the borrower's possition yields profit. The first three lines of the function repay() allow any msg.sender to receive the premiums for any borrower:  Since the borrower is incentivized to call the function repay() only when there is profit, the function allows any attacker to collect the unclaimed profit of any borrower after the pool's maturity. Furthermore, if the legitimate borrwers calls the function repay() at the maturity of the pool, the attacker has still a possibility to frontrun the legitimate transaction.   Specification changed  This  version  of  the  code  introduces  a  grace  period,  around  24h,  to  permit  only  borrowers  calling  the function repay() after pool's maturity. In case a borrower does not call the function during this period, anyone can call the function repay() and exit the borrowers' positions, therefore releasing the locked liquidity.   Specification changed  The respective code has been removed according to the new specifications of   .  Primitive Finance - Core Engine -   12  DesignHighVersion1Speci\ufb01cationChangedVersion2Version3Version3        \f6.3   Borrower Locks Liquidity in the Pool  the  function  borrow()  with  a  given  delLiquidity   call Calling  reserve.borrowFloat() which decreases the amount of available float in the pool and increases the debt  of  the  pool  reserve  accordingly.  This  way,  the  borrower  locks  delLiquidity  from  the  available float in the pool reserve. Below is the borrowFloat function.  triggers   the   function borrowFloat(Data storage reserve, uint256 delLiquidity) internal {         reserve.float -= delLiquidity.toUint128();         reserve.debt += delLiquidity.toUint128(); }  A liquidity provider that has supplied its liquidity as float needs to first call the function claim() which converts the float into liquidity before removing the liquidity from the pool. However, the only way for all liquidity providers to claim all their float liquidities is if all borrowers call the function repay() which triggers a call to reserve.repayFloat():      function repayFloat(Data storage reserve, uint256 delLiquidity) internal {     reserve.float += delLiquidity.toUint128();     reserve.debt -= delLiquidity.toUint128(); }  But,  if  the  price  of  the  risky  token  is  below  the  strike  price,  the  borrower  has  no  incentive  to  call  the function  repay(),  therefore  potentially  keeping  locked  the  float  liquidity.  Moreover,  the  function repay() does not impose any time restriction to borrowers when they can exercise their option, i.e., the borrower  can  potentially  call  the  repay()  function  at  an  arbitrary  time  after  the  maturity.  This  puts pressure on the liquidity providers to call it themselves which is possible because in the current version of the  PrimitiveEngine  contract,  anyone  can  call  the  function  repay()  after  the  maturity  of  the pool. If liquidity provider have the burden to call the functions, they also bear the costs.   Specification changed  This  version  of  the  code  introduces  a  grace  period,  around  24h,  to  permit  only  borrowers  calling  the function repay() after pool's maturity. In case a borrower does not call the function during this period, anyone can call the function repay() and exit the borrowers' positions, therefore releasing the locked liquidity. Still, the additional costs need to be payed by the caller / LP if they call it to relase their funds.   Specification changed  The respective code has been removed according to the new specifications of   .  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Disable Unnecessary Functionalities After", "body": " Expiry  In the current version of the PrimitiveEngine contract all functions, except function swap(), can be called after the pool has expired. For example, a liquidity provider could close the opened positions of borrowers,  claim  its  share  of  the  float  liquidity,  and  then  call  function  borrow()  for  the  remaining amount of float.  Primitive Finance - Core Engine -   13  DesignHighVersion1Speci\ufb01cationChangedVersion2Version3Version3DesignHighVersion1CodeCorrected                \fCode corrected  The updated version of the contract has new checks if the pool is still valid in the respective functions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Flawed Fee and Premium Structure", "body": "  When swapping, a fee is charged and borrows pay a premium on their position. Both amounts end up in the  pool  without  separate  accounting.  This  has  various  implication.  All  arising  from  the  fact  that  the underlying  calculation  are  based  on  the  pool's  reserve,  which  includes  the  fees  and  premiums.  All operations  that  pay  out  a  proportion  of  the  reserve  amounts  -  also  pay  out  parts  of  the  fees  and premiums. Hence, each time remove, repay, swap or borrow is called, fees and premiums are payed out. Regardless of the callee is entitled to receive these fees.  The  most  severe  issue  is  the  swap  function.  Swapping  on  the  pool's  reserve,  which  includes  the collected fees, will nullify all previous fees and prevent fee accumulation. Hence, liquidity providers will not earn fees collected during the lifetime of the pool, but only the fee from the last swap.  Other examples for issues are shared (even with non-eligible users) premiums and fees, participating on fees and premiums repeatedly. E.g. a liquidity provider that does not take the risk of lending their token gets  a  share  of  the  premium.  A  borrower  gets  part  of  the  premium  and  fees  of  others.  All  this  can  be leveraged through repeating the operation.   Specification changed  This version of the code introduces a novel fee structure.   Specification changed  The  respective  code  has  been  updated  according  to  the  new  specifications  of  fees only during swaps.    which  assume  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   No Slippage Protection", "body": "  All transactions have a lag between the time they are sent and the time they are executed as they remain in  the  mem  pool  for  some  time  prior  to  being  executed.  Between  sending  and  execution,  other transaction might change the contract's state. This is critical for all transaction where the user receives or  all action function in the Engine contract except for supply and claim do has to pay funds. In  not  offer  any  protection  against  slippage.  In  VERSION4  this  affects  allocate,  remove,  and  swap. Without  checking  if  the  transaction  is  still  executed  under  the  desired  conditions,  the  user  may  suffer losses.  This issue can be maliciously exploited by front running certain transactions. However, as the system is designed to interact with smart contracts, the slippage protection could be implemented on their side.  Code corrected  The user is now able to define the delta in and delta out when swapping. Hence, the user either gets the defined values or the swap will revert due to a violation of the invariant check. The check verifies that the invariant can only increase.  Primitive Finance - Core Engine -   14  DesignHighVersion1Speci\ufb01cationChangedVersion2Version3Version3DesignHighVersion1CodeCorrectedVersion1                \f6.7   Violation of Maximum Ratio of Float Liquidity  The amount of liquidity supplied as float should be less than a threshold value, hard coded to 80% in the current version of the contract. This restriction is enforced in the function addFloat() as follows:  function addFloat(Data storage reserve, uint256 delLiquidity) internal {         reserve.float += delLiquidity.toUint128();         if ((reserve.float * 1000) / reserve.liquidity > 800) revert LiquidityError();     }  This restriction is enforced only when a liquidity provider supplies its liquidity as float, but it does not hold always as any liquidity provider can freely remove available liquidity from the pool. For example, if the float  the function remove() to remove the 20% of the remaining liquidity, thus putting the pool reserve in a state with 100% of its liquidity as float.  liquidity  provider  could  call   (i.e.,  80%),  one   its  maximum   liquidity   is  at   level   function remove(         Data storage reserve,         uint256 delRisky,         uint256 delStable,         uint256 delLiquidity,         uint32 blockTimestamp     ) internal {         reserve.reserveRisky -= delRisky.toUint128();         reserve.reserveStable -= delStable.toUint128();         reserve.liquidity -= delLiquidity.toUint128();         update(reserve, blockTimestamp);     }   Code corrected  The Reserve library now defines a function checkUtilization() which checks if the invariant holds whenever float is added, float is payed, or the liquidity is removed.  :  Specification  changed  The  respective  code  has  been  removed  according  to  the  new  specifications of   .  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Token Decimal Validation", "body": "  The engine contract supports tokens with different decimals. However, tokens with very few decimals and more than 18 decimals cause severe issues but are allowed to be deployed by the factory.  Code corrected  The  factory  now  validates  decimals  for  both  tokens  before  deploying  an  engine.  Tokens  with  6  to  18 decimals are supported.  Primitive Finance - Core Engine -   15  SecurityHighVersion1Speci\ufb01cationChangedVersion2Version3Version3DesignMediumVersion3CodeCorrected                  \f6.9   Explicitly Handling Positive Invariant Restriction  The current implementation checks that the invariant grows assuming it is negative and, when updated by a swap, grows closer to zero: if (invariant > nextInvariant && nextInvariant.sub(in variant) >= Units.MANTISSA_INT).  A  zero  invariant  implies  a  balanced  pool  at  the  time  of  the  swap.  Typically,  the  invariant  should  not become  positive  but  could  happen  in  specific  scenarios  such  as  high  trading  frequency  and  high  fee accumulation. If this is the case, besides major other problems, the pool cannot recover as the invariant needs to decrease back to zero to be in balance again. This is because of the check, that the invariant is only allowed to grow after a trade. However, in case of a positive invariant, it should not become more positive.  : Code changed  The updated version of the code checks explicitly if the invariant is positive and prevents the invariant to grow in the wrong direction.  :  Specification  and  code  changed  The  issue  theoretically  exists  in  version  3.  However, according to Primitive Finance, a positive invariant is not an undisired state any more and a swap should not lead to a decreasing invariant - even if it is positive.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.10   Incorrect Tracking of Cumulative Values for", "body": " Pool Reserves  Primitive  Finance  pointed  out  this  issues  while  the  audit  was  ongoing.  They  are  aware  that  calling  the function update() after the pool reserve values are updated, results in incorrect cumulative values.  Code corrected  The function update() is called before the new amounts have been applied to the pool reserves.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.11   Liquidity Providers Get Rewards Without", "body": " Supplying Float Liquidity  In order for users to borrow liquidity from the pools, liquidity providers should allocate liquidity to a pool and then supply it as float which can be borrowed. Users pay a premium when borrowing liquidity and the float liquidity of the pool reserve is deducted. After the borrowers pay their debt, the liquidity providers should claim at first their share of liquidity as float, and then remove it from the reserve.  Since the liquidity providers do not get tokens for their supplied liquidity, the premiums paid by borrowers go to the pool reserve. This way, all liquidity provider get tokens out according to their share of liquidity and independently if they have supplied float liquidity to the pool. Hence, a liquidity provider that supplies  Primitive Finance - Core Engine -   16  DesignMediumVersion1Speci\ufb01cationChangedVersion2Version3DesignMediumVersion1CodeCorrectedDesignMediumVersion1Speci\ufb01cationChanged                      \ffloat liquidity and is more exposed (cannot remove liquidity unless borrowers repay it, or the maturity has passed) do not get any additional reward.   Specification and code changed  Version  2  introduces  a  novel  fee  structure  that  collects  fees  when  borrow()  function  is  called  and distributes the collected fees to liquidity providers that have supplied float. In case of a positive invariant, swap fees are also distributed to float providers.   Specification changed  The respective code has been removed according to the new specifications of   .  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.12   Possible Overflows", "body": "  Primitive Finance pointed out these issues while the audit was ongoing. They are aware that the following expressions could overflow:  res.cumulativeRisky += res.reserveRisky * deltaTime; uint256 reserveRisky = (res.reserveRisky * 1e18) / res.liquidity;  Code corrected  The overflow is avoided by casting the variables to uint256 as follows:  res.cumulativeRisky += uint256(res.reserveRisky) * deltaTime; delRisky  =  (delLiquidity  *  reserve.reserveRisky)  /  reserve.liquidity;,  where delLiquidity is of type uint256.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.13   Possible to Frontrun on Claim Request", "body": "  In  some  situations,  e.g.,  the  price  of  the  underlying  token  changes  significantly,  one  (or  more)  liquidity providers might want to exit their positions and call function claim() to remove their liquidity from float. However, an attacker might frontrun this transaction and call function borrow() and prevent the liquidity provider from exiting their position.   Specification changed  The respective code has been removed according to the new specifications of   .  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.14   Redundant and Improper Revert Condition", "body": "  The  two  functions  balanceRisky()  and  balanceStable()  verify  if  the  call  returns  the  balance correctly by checking: if(!success && data.length < 32) and revert if the condition is true. This makes sense if success is false or the call did not return a value (data.length < 32). With using &&  instead  of  or  the  condition  would  not  revert  for  the  combination  of  success  =  false  and data.length > 32 (which is possible). As the function needs the balance to work properly, we do not see  a  case  where  this  should  not  revert  if  data.length  <  32.  The  data.length  check  is  also  Primitive Finance - Core Engine -   17  Version2Version3Version3SecurityMediumVersion1CodeCorrectedDesignMediumVersion1Speci\ufb01cationChangedVersion3Version3DesignMediumVersion1CodeCorrected                        \fredundant  because  it  is  also  performed  in  abi.decode(data,  (uint256)).  Additionally,  it  might make sense to reevaluate if the less than condition makes sense or an equal condition would be more suitable.  Code corrected  The client has updated the check as follows: if (!success || data.length < 32).  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.15   Inconsistency of Input Parameters", "body": "  The engine contract is not consistent on the number of decimals an input value should have when called externally.  More  precisely,  the  function  create()  expects  the  strike  price  to  have  18  decimals, independently from the decimals of the stable token. However, the function swap() expect the deltaIn to  have  the  same  decimals  as  the  token  being  swapped  in.  A  similar  format  is  expected  by  functions deposit() and withdraw().  Code corrected  The  function  create()  expects  the  strike  price  to  have  the  same  number  of  decimals  as  the  stable token. Also, the specification has been updated accordingly.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.16   Unused Error Definition", "body": "  The error ZeroLiquidityError is defined in IPrimitiveEngineErrors but not used.  Code corrected  The ZeroLiquidityError error is now used in remove and allocate.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.17   Redundant Storage Read", "body": "  Reading from state storage consumes more gas than reading from memory. The compiler often handles redundant  storage  reads.  To  avoid  paying  multiple  times  for  storage  reads,  storage  variables  can  be buffered  in  memory  if  used  more  than  once.  This  is  tha  case  for  precisionStable  and precisionRisky in create and swap as they are accessed more than once from storage.  Specification changed  The decimal accounting was changed in   . This issue does not exist anymore.  Primitive Finance - Core Engine -   18  DesignLowVersion3CodeCorrectedDesignLowVersion3CodeCorrectedDesignLowVersion2Speci\ufb01cationChangedVersion3                          \f6.18   Code Duplication  The following functions share the same code which could be reused:  In borrow, repay, remove and allocate:  delRisky = (delLiquidity * reserve.reserveRisky) / reserve.liquidity; // amount of risky from removing delStable = (delLiquidity * reserve.reserveStable) / reserve.liquidity; // amount of stable from removing  Code corrected  The duplicated statements are moved into a function getAmounts() in the Reserve library.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.19   Duplicated Calculation of Invariant", "body": "  The  function  swap()  after  updating  the  timestamp  of  the  pool,  calculates  the  invariant  for  the  new time  until  expiry  (tau):  int128  invariant  =  invariantOf(details.poolId);.  Afterwards, calls  either depending  on  getStableGivenRisky()  getRiskyGivenStable().  call function  invariantOf(),  which  recalculates  the  invariant  for  the  same  pool  and  the  same timestamp.  Although  recalculating  the  invariant  is  reasonable  for  external  calls,  it  increases  the  gas consumption for calls from the swap function.  value  of  riskyForStable  parameter,   functions   function   these   Both   the   the   or   Code corrected  The  updated  function  swap()  calls  the  getRiskyGivenStable()  and  getStableGivenRisky() functions  from  the  ReplicationMath  library  which  take  the  invariant  as  an  argument  and  do  not recalculate it.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.20   Implementation of getStableGivenRisky", "body": " Function  The function specification for calculating the stablePerLiquidity do not include the value of the last invariant. However, the function implementation adds the last invariant in the computed stables, therefore resulting in this formula: stablePerLiquidity = K*CDF(CDF^-1(1 - riskyPerLiquidity) -  sigma*sqrt(tau)) + invariantLastX64.  Code corrected  The code comment has been updated correctly.  Primitive Finance - Core Engine -   19  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f6.21   Possible Gas Optimization in the Deposit Function  The function deposit() in the engine contract allows users to deposit a single token to their margin account, therefore the function calls the balanceof() function only for the token with a positive delta. However,  after  the  callback  function  for  the  transfer  executes,  the  function  checks  the  balance  of  both tokens  (performs  two  balanceOf()  calls).  The  function  can  optimize  the  gas  consumption  again  by calling the balanceOf() only for the token added.  Code corrected  The updated version of the function deposit() now checks if the delta value is greater than 0 before reading the balance (before and after the transfer) for the stable and the risky tokens.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.22   Return Value in safeTransfer", "body": "  The function safeTransfer() in the library Transfers checks if an ERC20 token transfer completed successfully, otherwise the function reverts. Currently, the function returns a boolean value but it is never checked in the caller functions.  Code corrected  The return value in safeTransfer() has been removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.23   MANTISSA_INT Constant", "body": "  MANTISSA_INT is a constant defined in units library and its value in 64x64 format corresponds to 10x the value of the constant variable Mantissa in units library.  Code corrected  The unused MANTISSA_INT has been removed.  Primitive Finance - Core Engine -   20  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Engine Shall Not Have Privileges in Other", "body": " Smart Contracts  With  the  current  setup,  for  security  reasons,  the  engine  contract  must  not  have  privileges  in  any  other smart contracts. The main reason is that the engine contract supports several callbacks which potentially could have the same function signature as a sensitive function in the contract being called.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Limited Supported Token Pairs", "body": "  PrimitiveFactory  contract  deploys  a  unique  PrimitiveEngine  contract  for  a  pair  of  ERC20  tokens.  The function deploy() takes as arguments the addresses of the two ERC20 tokens and assumes that they  are  implemented  correctly  and  behave  as  expected.  The  function  deploy  checks  only  if  the provided  addresses  of  the  risky  token  and  the  stable  one  are  not  the  same  and  that  they  are  different from address(0).  Technically,  it  is  possible  to  deploy  a  PrimitiveEngine  with  any  arbitrary  pair  of  tokens,  such  as: compromised/malicious tokens, two risky tokens, two stable tokens, or with switched addresses for the risky and stable tokens. Therefore, the filtering of the bad or malicious engines and their respective pools should  happen  on  the  application  level  (outside  the  audited  smart  contracts)  in  order  to  protect  users from interacting with incorrect engines.  We explicitly mention that the contract ONLY works with standard ERC20 tokens that do not have any unusual  behavior  like  inflation,  deflation,  locking,  fees,  two  addresses  etc.  Users  needs  to  carefully evaluate if the pool's token fulfill the requirements!  A check in the factory before deploying the engine might at least prevent accidentally adding a token with unsupported decimals.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   More Testing for CDF", "body": "  The correctness of the cumulative normal distribution function and its inverse function are important for the whole protocol. The functions getCDF() and getInverseCDF() ensure that the pool maintains the correct values of stable and risky tokens at any time. Both functions compute approximate values and the current  testing  shows  that  the  error  falls  below  a  chosen  threshold.  However,  the  code  calls  these (refer  functions  to getRiskyGivenStable()  and  getStableGivenRisky()  is  highly recommended to expand the testing for checking how the combine error changes when the functions are called as in the above example.  getCDF(getInverseCDF(x)   volatility)   functions),   therefore   pattern   the   +   in   it   Primitive Finance - Core Engine -   21  NoteVersion1NoteVersion1NoteVersion1            \f7.4   Oracle Usage  In case any project uses the current marginal prices as oracles, the oracle price would be an easy target to price manipulation.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Stuck Funds", "body": "  When the PrimitiveEngine contract calls callbacks from other contracts to make a token transfer, the engine  only  checks  that  its  token  balance  increased  by  a  value  equal  or  greater  than  an  expected amount. Afterwards, the engine updates the reserve balances with the expected amount. However, if the external  contract  transfers  more  token  than  expected,  the  difference  (tokens  transferred  -  expected tokens)  are  locked  in  the  engine  contract  and  neither  pools,  nor  liquidity  providers  can  access  them. Below is a code example from the function create():  if (balanceRisky() < delRisky + balRisky) revert RiskyBalanceError(delRisky + balRisky, balanceRisky()); if (balanceStable() < delStable + balStable) revert StableBalanceError(delStable + balStable, balanceStable());  Funds can also be locked during liquidity allocation if either delRisky or delStable does not match the delLiquidity that the user intents to allocate. The function allocate() computes the respective delta liquidities for both tokens (risky and stable) and rewards the smallest delta liquidity to the user. The code is shown below:  uint256 liquidity0 = (delRisky * reserve.liquidity) / uint256(reserve.reserveRisky); uint256 liquidity1 = (delStable * reserve.liquidity) / uint256(reserve.reserveStable); delLiquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1; ... liquidity[recipient][poolId] += delLiquidity; // increase position liquidity  The same is true for all other funds that are accidentally send to the contract or intentionally forced into the contract.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   Timestamp Conversion Limit", "body": "  The  _blockTimestamp  function  converts  the  block.timestamp  from  a  uint256  to  a  uint32. Hence, limiting the maximum value for the timestamp to Sunday, February 7, 2106. This is in 84 years. The contract will have issues in case it is used this long at that point in time.  Primitive Finance - Core Engine -   22  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Arbitrage Opportunities", "body": "  0  0  1  2  CS-SWAAP-EARN-013  Arbitrage opportunities due to price update could arise if the default implementation of Fund (Fund.sol) was  deployed  with  deposit/withdraw  fees  that  are  low.  In  this  case,  an  attacker  could  deposit  funds, observe  a  price  change  transaction,  and  withdraw  the  funds  to  profit  from  the  price  change.  This  can happen  if  an  arbitrageur  observes  a  price  change  transaction  and  sandwich  it  with  a  deposit  and  a withdraw transaction.  Note that such opportunities might be discouraged by the application of enter and exit fees on deposit and withdraw.  Finally,  it  is  important  to  highlight  that  the  Fund  variants  FundWithShareLockPeriod.sol  and FundWithShareLockFlashLoansWhitelisting.sol  offer  have  an  additional  layer  of  protection against this attack vector. The shares of the fund are locked for a certain period of time after a deposit. This prevents the attacker from withdrawing the funds immediately after a deposit.  Acknowledged:  The  FundWithShareLockFlashLoansWhitelisting.sol variation.  acknowledged.   Swaap   issue   is   will   only   use   the  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Call to applyFeesBeforeJoinExit Can Burn", "body": " All Gas  Swaap Labs - Swaap Earn Protocol -   15  SecurityDesignCriticalHighMediumAcknowledgedLowRiskAcceptedAcknowledgedSecurityMediumVersion1AcknowledgedDesignLowVersion1RiskAccepted                  \fThe call to FEES_MANAGER.applyFeesBeforeJoinExit is done using try catch, so if the call fails, the flow with continue without fees. However, in some case the call can cause EVM-level panic and burn all gas, so there will be no gas left to continue the flow.  CS-SWAAP-EARN-002  Risk accepted:  Swaap Labs has acknowledged the issue and has decided to keep the code unchanged in  . In case the FeeManager panics, the Fund can be shut down, allowing LPs to withdraw without calling the FeesManager.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   Donation Can Break Performance Fees", "body": "  Just  after  the  deployment,  by  default  Fund  is  required  to  have  at  least  10^4  of  assets  and 10^4  *  10^  (_FUND_DECIMALS  -  _ASSET_DECIMALS)  of  shares.  The  FeeManager  stores  the highWaterMarkPrice as type(uint72) with 18 decimals precision ~ 4.72e21. When the first deposit is made,  the  highWaterMarkPrice  is  set  to  the  new  value.  However,  an  attacker  can  donate  a  small amount  of  assets  to  the  fund  via  token  transfer  and  make  the  highWaterMarkPrice  more  than type(uint72).max.  This  way  the  performance  fee  will  be  broken  and  the  Fund  will  keep  operating without  fees.  Inflating  initial  10^4  of  shares  for  18  decimal  asset  won't  require  a  lot  of  value  for  some tokens.  CS-SWAAP-EARN-003  . Swaap Labs has acknowledged the issues and has decided to keep the code unchanged in  However, to tackle any possible risk, Swaap Labs will initiate the Fund with at least 1$ worth of assets such that the attack would be expensive to perform.  Swaap Labs - Swaap Earn Protocol -   16  Version2SecurityLowVersion1AcknowledgedVersion2          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Fees Calculation Discrepance   -Severity Findings   Deployer Cannot Accept Ether    resetHighWaterMark() Ignores Pending Fees   Informational Findings   Specifications Problems    Events    A Fund Cannot Take Flashloans From Both Balancer and Swaap    Gas Efficiency   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Fees Calculation Discrepance", "body": "  0  0  1  2  4  The enter and exit fees are computed in a way that introduces discrepancies in the system.  1. maxDeposit returns an incorrect amount compared to the maximum amount that will be possible  to actually withdraw using withdraw.  2. When depositing, mint will be a cheaper option compared to deposit.  CS-SWAAP-EARN-001  Example of 1.  Assume that the Fund that has 1000 shares and 1000 assets. Also, it has 1100 shares cap and a 20% fee. No fee shares pending to be minted.  When user calls maxDeposit(), the function will return:  100 shares * 1000 assets / 1000 shares * (100% + 20%) / 100% = 120 assets  When user calls deposit() with 120 assets, the function will mint:  120 assets * 1000 shares / 1000 assets * (100% - 20%) / 100% = 96 shares  The  difference  is  4  shares.  Calling  deposit  with  125  assets  will  mint  100  shares,  which  is  what maxDeposit()  in _applyEnterOrExitFees() function. In one case, (100% + fee)/100% is used, and in the other, (100% - fee)/100% is used. But the one is not the inverse of the other.  value.  The  discrepancy   calculated   to  how   is  due   fee   the   is   Example of 2.  Swaap Labs - Swaap Earn Protocol -   17  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignMediumVersion1CodeCorrected        \fA 50% entrance fee will increase the number of assets needed by mint by 1.5 times, while decrease the number of minted shares by 2 in deposit. Thus mint() will effectively be cheaper.  Code  corrected:  Swaap  Labs  has  corrected  the  code  in    by  changing  the  way  the  fees  are applied. Now, when entering the fund, the number of assets is virtually increased by the fee, and when exiting, the number of assets is decreased by the fee. This way the discrepancy is removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Deployer Cannot Accept Ether", "body": "  Deployer  has  deployContract()  function  that  deploys  a  contract  using  CREATE3  library.  This function  accepts  a  value  parameter  that  is  supposed  to  be  transferred  to  the  deployed  contract.  The library  function  CREATE3.deploy(salt,  createCode,  value)  will  try  to  transfer  value  of  ether together with the deployment transaction. However, deployContract() function does not accept Ether and Deployer contract does not have any other way to receive Ether. This limits the functionality of the deployContract() function and complicates the deployment process if ether transfer is required.  CS-SWAAP-EARN-004  Code  corrected:  Swaap  Labs  has  corrected  the  code  by  making  the  function  deployContract payable and by passing msg.value to the CREATE3 library.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   resetHighWaterMark() Ignores Pending", "body": " Fees  The resetHighWaterMark() function can be called by Registry owner to reset the high-water mark. However,  the  function  does  not  take  into  account  the  fees  that  would  have  been  minted  if collectFees() was called before computing the new mark. When mark is reset and fees are minted afterward, the high water mark will be higher than the new price of shares.  CS-SWAAP-EARN-005    Swaap Labs has corrected the code in  collectFees(), before resetting the high-watermark price.   by collecting the management and performance fees via  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   A Fund Cannot Take Flashloans From Both", "body": " Balancer and Swaap  A  fund  can  request  a  flash  loan  from  Balancer  or  Swaap  thanks  to  the  SwaapV2Adaptor  and BalancerFlashLoanAdaptor adaptors.  CS-SWAAP-EARN-012  Swaap Labs - Swaap Earn Protocol -   18  Version2DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedVersion2InformationalVersion1CodeCorrected                      \fit   is   However,  in FundWithBalancerFlashLoans  will  only  be  callable  by  the  immutable  address  balancerVault. Therefore,  the  contract  FundWithBalancerFlashLoans  will  have  to  be  configured  at  deployment  to either receive flash loans from Balancer OR from Swaap.  receiveFlashLoan()   function   noting   worth   that   the     Registry   approvedFlashLoanSource. The  FundWithBalancerFlashLoans  verifies  that  msg.sender  is  the  approved  flash  loan  source  before executing receiveFlashLoan().  mapping   contract   holds   now   a   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Events", "body": "  CS-SWAAP-EARN-007  The following events could be improved:   Deployer.ContractDeployed(name,  contractAddress,  creationCodeHash)  name  could be indexed.   Registry.DepositorOnBehalfChanged(depositor, state) depositor could be indexed.   Registry.TargetPaused(target)  and  Registry.TargetUnpaused(target)  target  could  be indexed.   Fund.AdaptorCalled(adaptor, data) could have adaptor indexed.    Swaap Labs has corrected the code in   .  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Gas Efficiency", "body": "  CS-SWAAP-EARN-008  The following code could be optimized to consume less gas:  Fund  1. cachePriceRouter:  computing  assetsAfter  does  not  serve  any  purpose  unless  checkTotalAssets is enabled.  2. maxdeposit: sharesupplycap is read twice from storage and assigned to _cap.  PriceRouter  1. completeTransition: the requirement that pendingOwner != 0 is redundant.  2. getValue,  _getValues,  getExchangeRate  and  getExchangeRates:  all  redundantly  check  that the derivative is non-zero; the check is already performed in _getPriceInUSD.  Registry  1. completeTransition:  the  requirement  that  pendingOwner  !=  0  is  redundant,  since  msg.sender == pendingOwner.  Swaap Labs - Swaap Earn Protocol -   19  InformationalVersion1CodeCorrectedVersion2InformationalVersion1CodeCorrected            \f2. setMaxAllowedAdaptorVolumeParams: some of the variables in the event could be replaced  with equivalent stack variables.  AaveV3ATokenManagerAdaptor  1. depositToAave:  when  revoking  approval,  the  conversion  of  _revokeExternalApproval  to  ERC20 is redundant.    Swaap Labs has corrected the code in   .  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Specifications Problems", "body": "  The specifications of the codebase present some issues:  Fund  1. deposit and redeem have outdated comment \"Check for rounding error since we round down in  CS-SWAAP-EARN-010  previewDeposit.\".  2. _MAX_POSITIONS has a typo in the natspec.  3. _DELAY_UNTIL_END_PAUSE has a typo in the natspec.  4. cachePriceRouter has a typo in the natspec.  5. Swaap  Governance  and  Swaap  Strategist  used  interchangeably  when  onlyOwner  modifier  is  used.  PriceRouter  1. _updateAsset has a missing parameter in the natspec.  Registry  1. setMaxAllowedAdaptorVolumeParams  has  an   incorrect  natspec   for   the  parameter  resetVolume.  2. checkAndUpdateFundTradeVolume has incorrect natspec.  BaseAdaptor #. _verifyConstructorMinimumHealthFactor has incorrect natspec.  AaveV3DebtManagerAdaptor #. Contract natspec \"Adaptor Data Specification\" is incorrect.  AaveV3ATokenManagerAdaptor #. In the contract natspec, the statement \"Funds with multiple aToken positions MUST only specify minimum health factor on ONE of the positions\" is outdated.    Swaap Labs has corrected all the issues mentioned above in   .  Swaap Labs - Swaap Earn Protocol -   20  Version2InformationalVersion1CodeCorrectedVersion2      \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Circular Dependencies", "body": "  It is possible for a Swaap fund to have a position in another Swaap fund. This means that funds might be configured  such  that  a  circular  dependency  is  created.  This  might  break  the  price  evaluation,  due  to  a loop.  Circular dependencies should be avoided, however, when adding a new position into a fund, there are no mechanisms in place to prevent this issue.  CS-SWAAP-EARN-006  Acknowledged:  Swaap  Labs  has  acknowledged  the  potential  risks  and  has  decided  to  leave  the  code  unchanged  in  .  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Output Token From Swaap Fund Positions", "body": "  A fund can have a position in another Swaap Fund. Let's call the fund with the position fund1 and the fund as asset - fund2.  However,  when  withdrawing,  the  function  SwaapFundAdaptor.withdraw()  does  not  check  that  the assets the fund2 can transfer to fund1 are tracked. This might might cause big slippage of share prices of fund1.  CS-SWAAP-EARN-009  Acknowledged:  Swaap  Labs  has  acknowledged  this  limitation  and  will  pay  additional  attention  when  adding  such positions.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Withdrawal Priority", "body": "  The  Fund  stores  withdrawable  assets  in  creditAssets  array.  During  withdrawal,  the  assets  are withdrawn  from  the  creditAssets  array  in  the  order  of  their  list  index,  until  the  needed  amount  is withdrawn. This makes that assets with higher indices less likely to be withdrawn. Fund owners must be aware of this behavior and adjust the asset list when needed.  CS-SWAAP-EARN-011  Acknowledged:  Swaap Labs - Swaap Earn Protocol -   21  InformationalVersion1AcknowledgedVersion2InformationalVersion1AcknowledgedInformationalVersion1Acknowledged                \fSwaap Labs is aware of this behavior and intends to support Funds with properly arranged assets.  Swaap Labs - Swaap Earn Protocol -   22  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Manipulating the Price of", "body": " SwaapSafeguardPools  While  highly  unlikely,  it  is  possible  that  the  asset  composition  SwaapSafeguardPool  can  be manipulated  by  3rd  parties,  due  to  AMM  nature  of  the  pool  Thus,  the  price  returned  by  the  price extension SwaapSafeguardPools could be subject to manipulation  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Staking Reward Tokens", "body": "  Certain protocols like AAVE and COMP have a staking reward token that is not the same as the underlying token. Fund might need a special adapter to handle these rewards.  Swaap Labs - Swaap Earn Protocol -   23  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   No Documentation", "body": "  0  0  0  4  No  documentation  is  available  for  ERC20Pods.  This  abstract  contract  is  intended  to  be  used  by  third parties hence documentation is vital to avoid issues. For authors of pods it must be clearly documented what they have to take into account and what they can rely on, such as:   Failed calls to Pod.updateBalances() are ignored, consequently authors of pods must be aware  of the consequences for their pods   Amount of gas available   When  exactly  the  token  triggers  Pod.updateBalances():  Upon  non-zero  token  transfers  and when the pod is added/removed from an account having non-zero balance. Misunderstandings by a developer of a Pod may lead to correctness issues.  The trust model should be clearly specified, including:   How exactly pods are trusted / untrusted   Whether only trusted parties can add/remove pods to/from an account. If this holds, the docs should  clearly state that a developer extending ERC20Pods must adhere to this  Furthermore  not  all  token  holders,  e.g.  contracts  can  call  addPod()  themselves.  The  documentation may elaborate on this topic, e.g., what can be assumed / what the limitations are.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Consistency on Zero Amount Transfers", "body": "  1inch - ERC20 Pods -   10  SecurityDesignCriticalHighMediumLowAcknowledgedRiskAcceptedAcknowledgedSecurityLowVersion1DesignLowVersion1Acknowledged                \fThe ERC20 standard specifies Note Transfers of 0 values MUST be treated as normal t ransfers  and  fire  the  Transfer  event..  For  consistency,  it  may  make  sense  to  inform  the registered pods about 0 balance actions and 0 amount transfers. If this behavior is desired the way it is, it should be mentioned somewhere so that Pod developer are aware that 0 balance or 0 amount transfers are not notified to the Pod.  Acknowledged:  1inch acknowledged the issue and decided to leave the code as it is.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   Side Effects of _updateBalances()", "body": "  While  the  gas  check  prevents  direct  reentrancy  into  the  token  on  functions  changing  the  balance, 200_000 gas is enough to make some other state changes that could affect to-be-updated pods. Notably upon updating the first pod A, this contract may interact with another pod B which is to be updated later in the  sequence  and  hence  does  not  yet  know  about  these  balance  changes  pod  A  currently  executing already is aware of. While we have not uncovered any direct issue, a badly designed or adversarial pod could be problematic. No trust model nor specification covering this scenario is available.  Risk accepted:  1inch is aware of and accepts the risk.    introduced  a  reentrancy  guard.  Note  that  this  can  be  leveraged  by  a  pod  to  detect  such  a scenario  and  revert.  While  the  state  of  the  reentrancy  guard  itself  cannot  be  querried  direcly,  public functions  balanceOf  and  podBalanceOf  now  feature  the  nonReentrant(View)  modifier  and  will revert if called in such a situation. Hence in the scenario described above pod B could call balanceOf() and be protected.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.4   Zero Address Consistency in AddressArray", "body": "  When querying an index that is out-of-bounds with AddressArray.at, the function does not revert and returns  address(0).  Thus,  it  is  not  possible  to  distinguish  between  an  address(0)  that  would effectively be part of the array, and an out-of-bounds access.  Acknowledged:  1inch  is  aware  of  the  issue  and  states  that  in  the  current  use  case,  no  pod  with  address(0)  can  be added. While this is true in the case of ERC20Pods, it can still be an issue for other contracts using the library.  1inch - ERC20 Pods -   11  SecurityLowVersion1RiskAcceptedVersion2DesignLowVersion1Acknowledged                  \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   ERC20Pods podsLimit Sanitization    Missing Events    Operations Order on Pod Removal   0  0  0  3  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   ERC20Pods podsLimit Sanitization", "body": "  The  podsLimit  in  the  ERC20Pods's  constructor  is  never  sanitized.  If  podsLimit  is  zero,  the functionality  added  by  ERC20Pods  cannot  be  used,  so  it  would  not  make  sense  to  allow  setting podsLimit=0.    The constructor of the ERC20Pods contract now checks that podsLimit is not zero.  Note  that  in  sanitized. Unsuitable values could make the ERC20Pods unusable.    the  constructor  takes  a  second  parameter  podCallGasLimit_  which  is  not  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Missing Events", "body": "  Typically, events help track the state of the smart contract. To be able to reconstruct the state offchain, events should be emitted when users add and remove pods.    Two  events  PodAdded  and  PodRemoved  have  been  added  and  are  emitted  whenever  a  pod  is added/removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Operations Order on Pod Removal", "body": "  1inch - ERC20 Pods -   12  CriticalHighMediumLowCodeCorrectedCodeCorrectedCodeCorrectedDesignLowVersion1CodeCorrectedVersion2DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fWhen a pod is removed with removePod, it is first removed from the internal address set, and then the balances are updated. But when calling removeAllPods, the balances are updated before the pod is removed  from  the  address  set.  Thus,  there  are  two  different  behaviors  for  the  same  action  and  the potential for inconsistencies arises.    The function removeAllPods now follows the order of removePod by first removing the pod from the address set and then update the balances.  1inch - ERC20 Pods -   13  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Failed Call to Pod Is Silent", "body": "  ERC20Pods._updateBalances()  calls  the  pod  with  a  fixed  amount  of  gas.  If  this  call  fails,  the execution nonetheless continues normally in order to not block the ERC20. Users must be aware that a failed call to a pod is silent and will not emit any event.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Integrations May Break Due to Gas", "body": " Requirements  A  transfer  of  an  ERC20Pods  may  require  significantly  more  gas  than  the  transfer  of  a  normal  ERC20. This especially applies when sender and receiver are connected to multiple distinct pods. Moreover, the current abstract contract ERC20Pods allows an user to register any arbitrary pod for his address.  In the worst case each of the pods uses the full 200'000 gas available. When sender and receiver have distinct pods this amounts to 2 * podsLimit gas.  Integrations must take this into account in order to avoid running into problems such as, but not limited to:  An example could be a liquidation of a position where in an extreme case multiple different ERC20Pods where each sender/receiver is connected to several pods must be transferred. The liquidation may not be possible due to the gas requirement exceeding the block gas limit.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Not Exactly _POD_CALL_GAS_LIMIT", "body": " Available  A  Pod  cannot  rely  on  having  exactly  200'000  gas  available  upon  being  called.  While  it  is  taken  into account that a maximum of 63/64 of the remaining gas can be passed to the call, due to the overhead between the check and the call:  if lt(div(mul(gas(), 63), 64), _POD_CALL_GAS_LIMIT) {         mstore(0, exception)         revert(0, 4)     }         pop(call(_POD_CALL_GAS_LIMIT, pod, 0, ptr, 0x64, 0, 0))     }  in a corner case scenario the call may receive slightly less gas.  1inch - ERC20 Pods -   14  NoteVersion1NoteVersion1NoteVersion1            \f7.4   Order of Pods in AddressSet  Users msut be aware that upon pod removal, the order in the pods in the AddressSet may change, so two calls to podAt with index X, with a call to removePod in-between, may not yield the same result.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Unaffected Elements of the Output Memory", "body": " Array on AddressArray.get()  providing   function When  AddressArray.get(Data storage self, address[] memory output), users must be aware that if length(self) < output.length(), only the length(self) first elements of output will be overwritten, leaving the remaining elements of output untouched.  memory   output   array   the   an   to   1inch - ERC20 Pods -   15  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Complexity of Commands Effect Evaluation", "body": "  Due to the novelty and non-standard encoding of Weiroll, the end user will need to sign a transaction, without knowing full details about the execution consequences. Standard hardware and software wallets won't  be  able  to  decode  the  content  of  the  commands.  As  a  result,  users  will  need  to  perform blind-signing - signing without verifying the full transaction details. Phishing attacks can be performed on users  to  trick  them  to  sign  commands  that  will  impact  the  token  balances  in  an  undesired  way.  Users should be notified about this risk and only sign transactions from trusted sources and ideally after careful inspection.  Enso - Enso-Weiroll -   10  DesignCorrectnessCriticalHighMediumLowRiskAcceptedDesignLowVersion1RiskAccepted            \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Function writeOutputs Can Corrupt Memory   -Severity Findings   Assumptions on Output From Unsuccessful Call    Dynamic Variable Encoding Is Assumed to Be Correct    The Index Is Not Masked    Value for the Call Can Be Loaded From Wrong Memory Location   -Severity Findings  IDX_USE_STATE Case Not Handled Inside Tuples and Arrays    Non-terminated Indices Fail Silently    Unbalanced Tuple Starts and Ends Cause Silent Failure   0  1  4  3  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Function writeOutputs Can Corrupt Memory", "body": "  To store the pointer of the return data the writeOutputs function performs a write to memory at the index  state  +  32  +  (idx  &  IDX_VALUE_MASK)  *  32  .  However,  a  check  that  this  location  still belongs to the state array of pointers is not performed. This effectively permits writing to locations in memory  that  can  contain  other  variables,  including  data  of  other  state  elements.  The  command (maliciously or accidentally) can trigger such writing and cause unexpected results.    A check was introduced that verifies that idx & IDX_VALUE_MASK < state.length.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Assumptions on Output From Unsuccessful", "body": " Call  Unsuccessful calls are assumed to revert with no output data, with output data of the type Panic() (4 bytes  selector,  empty  payload),  or  with  output  data  of  the  type  Error(string)  (4  bytes  selector,  32 bytes pointer, 32 bytes string size, string content).  Errors can however have arbitrary signatures, which are up to the contract implementors to define.  Enso - Enso-Weiroll -   11  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                 \fFor example, an error of type Error(uint256,uint256) will have its second integer interpreted as a string length in the VM error handling, potentially causing a memory expansion that will consume all the gas, if the uint256 value is big enough.    Additional checks have been introduced to interpret the return data of the error as a string only when it is appropriate to do so.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Dynamic Variable Encoding Is Assumed to Be", "body": " Correct  When CommandBuilder builds inputs from the state, the variable length case for bytes and strings (not array, not tuple) does not verify that the state element at the given index is correct abi encoded data. The following consequences are possible:  The case when state[idx & IDX_VALUE_MASK].length == 0 is not handled correctly. During the encode  loop,  this  is  executed  free  +=  state[idx  &  IDX_VALUE_MASK].length  at  line  113,  or offset += state[idx & IDX_VALUE_MASK].length at line 320. However if the state element is the empty bytes sequence \"\", the free or offset/pointer pointer does not change. The encoding of such  a  state  element  will  write  a  pointer  to  unallocated  free  memory.  If  any  other  dynamic  variable  is allocated  afterward  the  pointer  of  the  empty  state  element  will  point  to  the  same  location.  The  checks performed  requires state[idx & IDX_VALUE_MASK].length % 32 == 0 - this does not prevent the empty state case.  setupDynamicVariable()   in     The following fix was done to address the issue:  A  constraint  was  added  for  the  dynamic  variable  case  in  the  setupDynamicVariable  function:  in addition to state[idx & IDX_VALUE_MASK].length % 32 == 0 check, a check that this lengths does not equal 0 was added. This resolves the issue.  Enso responded:  Added check to revert if argLen == 0 (weiroll.js already encodes 0x as a full bytes32 value, so the state generated with weiroll.js will be unaffected). Also, we now check the variable\u2019s encoded size is the same as the content size.  Note:  The weiroll.js library is out of scope for this assessment, however, encoding of an empty string as full  bytes32  value  does  not  fully  comply  with  abi  encoding.  Such  behavior  was  considered  a  bug  in solidity. Some contracts with strict decoding rules might not accept empty strings encoded this way.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   The Index Is Not Masked", "body": "  The IDX_VALUE_MASK is not applied to index values at certain places:  1. Mask is not applied on the index in VM smart contract at line 94.  Enso - Enso-Weiroll -   12  CorrectnessMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                \f2. Mask is not applied on the index in CommandBuilder smart contract at line 396.    The appropriate index masking has been applied.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Value for the Call Can Be Loaded From Wrong", "body": " Memory Location  When a call with value is performed in VM the first index is treated as an index for the state element. The read from this memory location is done via assembly instruction.  bytes memory v = state[uint8(bytes1(indices))]; assembly {     callEth := mload(add(v, 0x20)) }  This mload skips 1 word - the length of the state element. However, the state element can be empty. In this  case,  the  mload  will  read  memory  allocated  for  other  data.  Since  callEth  should  be  a  uint256 typed argument, it should be treated the same way as any other static variable.    Enso responded:  We now validate that the state element\u2019s length is 32 bytes and convert it into a uint256.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   IDX_USE_STATE Case Not Handled Inside", "body": " Tuples and Arrays  Indices with the value IDX_USE_STATE behave differently according to whether they belong to dynamic tuples or not. Inside dynamic tuples, the 0xfe == IDX_USE_STATE index is treated as variable length data (bytes or string). 0xfe value is masked and used as an index to 126 state bytes element. Outside of dynamic tuples, it causes the whole state to be ABI encoded at that position. This difference in behavior is not mentioned in the specification.    IDX_USE_STATE now explicitly reverts when used inside a dynamic tuple or array.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Non-terminated Indices Fail Silently", "body": "  Enso - Enso-Weiroll -   13  CorrectnessMediumVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fIf FLAG_EXTENDED_COMMAND is used, and no FF index is included in the indices list, an invalid input will be produced by CommandBuilder.buildInputs() instead of reverting, causing the external contract call to have invalid data.    A new variable, indicesLength, keeps track of the number of indices that needs to be considered by commandBuilder.buildInputs()  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Unbalanced Tuple Starts and Ends Cause", "body": " Silent Failure  In  CommandBuilder.buildInputs()  every  dynamic  array  or  tuple  start  should  be  matched  by  an index of value IDX_DYNAMIC_END. Failing to match opening and closing structures causes offsets not to  be  updated,  and  invalid  output  to  be  produced.  The  invalid  result  risks  being  passed  to  arbitrary external calls.  Since  functions  setupDymamicTuple  and  encodeDynamicTuple  need  to  encounter  an  index IDX_DYNAMIC_LENGTH  to  exit  correctly,  the  alternative  return  statements  at  lines  226  and  343  are superfluous and should never happen.    Function setupDynamicTuple now reverts if no terminating index is found for a dynamic tuple or array.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.9   DELEGATECALL and SELFDESTRUCT", "body": "  The VM abstract contract allows DELEGATECALL to the address specified in the command. Any contract that  will  inherit  this  functionality  must  not  perform  a  call  to  an  arbitrary  user-specified  address.  The delegate  call  to  an  address  that  has  a  bytecode  with  SELFDESTRUCT  opcode  will  cause  permanent destruction  of  the  smart  contract.  Thus,  it  is  important  to  allow  DELEGATECALL  only  to  trusted  smart contracts.    Enso responded:  We have removed delegate calls from the VM entirely as there was both risks to the contract via self destruct as well as the ability to change storage values of the importing contract, potentially bricking the contract.  Enso - Enso-Weiroll -   14  DesignLowVersion1CodeCorrectedInformationalVersion1CodeCorrected              \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Calls to Addresses With No Code", "body": "  The low-level delegatecall, call, and staticcall operations will succeed when used with addresses with no code,  however,  in  the  VM  there  seems  to  be  no  reason  to  use  them  on  addresses  with  no  code, excluding the precompiled contracts. Only VALUECALL has a reason for being used on an address with no code.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Floating Pragma", "body": "  Enso-Weiroll uses the floating pragma ^0.8.16. Several assumptions about the layout of memory are made in the code, which could potentially change without a major version upgrade. Any solidity compiler version needs to be carefully tested before the deployment of the code to ensure stable functionality.  Enso - Enso-Weiroll -   15  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Wrong Formula in Documentation", "body": "  0  0  2  3  the  documentation  of   In  previousEpochCumulativeYield is incorrect:  interest  bearing   the   logic   the   formula   for   the  calculation  of   the  CS-MKP-008  previousEpochCumulativeYield is calculated as follows:  newPreviousEpochCumulativeYield=oldPreviousEpochCumulativeYield*(1+yield)^ timeElapsedToEpoch  Here timeElapsedToEpoch refers to the time elapsed between the last cumulativeYield refresh and the previousEpochTimestamp.  It's not oldPreviousEpochCumulativeYield but _cumulativeYield, the value calculated at the last cumulative yield refresh. While the last refresh could be at the last epoch timestamp, this generally isn't the case.  Furthermore the in the Docs, yield is calculated as  yield = 1 + annualRate  1  31536000 \u00d7 1027  On the same page, the following is mentioned:  newCumulativeYield = oldCumulativeYield \u00d7 (1 + yield)elapsedTime  Hence, it is not totally clear for the reader if this yield and the variable _yield in the codebase is the exponential yield or 1 + exponential yield.  Specification changed:  Mimo Initiative lt - Kuma Protocol -   13  CriticalHighMediumSpeci\ufb01cationChangedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion1Speci\ufb01cationChanged         \fThe  oldPreviousEpochCumulativeYield has been replaced with oldCumulativeYield.  newPreviousEpochCumulativeYield   formula   been   has   for   corrected,  the   In  newPreviousEpochCumulativeYield, (1 + yield) has been corrected to yield.  calculation   formulas   newCumulativeYield   the   for   of   and  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   getRate() Blocks the System in Case of", "body": " Stale Data  CS-MKP-007  In MCAGRateFeed.getRate(), if for any reasons, the queried oracle fails to return a fresh, non-stale response, this function reverts. Consequently, all functions which eventually call into getRate() will fail as well. This includes any action where the yield is refreshed, including minting, burning and transfers of the KIB tokens.  Most notably this inhibits the following functions (incomplete list):  1. KUMASwap.expireBond()  -  As  long  as  the  oracle  data  is  stale  it  will  not  be  possible  to  mark  bonds as expired.  2. KUMASwap.enableDeprecationMode() - Deprecation mode cannot be enabled.  3. KIBToken.setEpochLength() - Epoch length cannot be changed.    Mimo Initiative lt addresses the issue in KIBToken._refreshYield through a try-catch statement. Should the rate feed fail for any reason the rate used is the current minimum coupon.  This resolves the issue for all functions that query the rate through _refreshYield(). Besides them, direct queries of the rate occur in initialize() and sellBond(). Successful calls to these functions are prevented if the call to the rate feed fails.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Initialize Implementation Contract", "body": "  The  first  caller  can  execute  KUMASwap.initialize()  directly  on  the  implementation  contract.  The protection  intended  to  prevent  this  is  ineffective.  Note  that  this  has  no  actual  implications  since  this implementation contract is intended to be used via the Proxy.  CS-MKP-006  The constructor of KUMASwap looks as follows:  constructor() initializer {}  The  initializer()  modifier  is  called  to  set  _initialized  to  1.  It  appears  that  this  is  done  to prevent execution of the initialize function on the implementation contract which is protected by the initializer modifier.  In  this  second  iteration  of  KUMASwap  the  initialize  function  is  protected  by  another  modifier: reinitiliazer(2).  Mimo Initiative lt - Kuma Protocol -   14  DesignMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fSince during deployment _initialized is set to 1 in the storage of the implementation, the first caller can pass the modifier reinitializer(2):  modifier reinitializer(uint8 version) {     require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");     _initialized = version;     _initializing = true;     _;     _initializing = false;     emit Initialized(version); }  OpenZeppelin  offers  a  function  to  disable  initializer:  _disableInitializers()  and  recommends  to not leave an implementation contract uninitialized.  It is recommended to use this to lock implementation contracts that are designed to be called through proxies.  See: https://docs.openzeppelin.com/contracts/4.x/api/proxy#Initializable    In the constructor of every implementation contract, _disableInitializers() is invoked to lock the (re)initialize function.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Setting _lastRefresh to the Next Epoch", "body": " Initially  When  KIBToken  gets  initialized,  if  block.timestamp  is  not  divisible  through  epochLength, _lastRefresh is set to the next epoch.  KIBToken.mint(),  which  is  executed  when  a  bond  is  sold  to  the  protocol  would  revert  in  case  of block.timestamp < _lastRefresh.  The intention of this is unclear. Anyone can advance _lastRefresh to the current block.timestamp by calling KIBToken.refreshYield().  CS-MKP-005    Mimo Initiative lt changed KIBToken.initialize() to set _lastRefresh to block.timestamp.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Unused Event", "body": "  The  event  IKUMASwap.MaxCouponsSet  is  defined  but  not  used.  In  the  current  implementation, MAX_COUPONS is defined as a constant.  CS-MKP-004    This event has been removed.  Mimo Initiative lt - Kuma Protocol -   15  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Define Relevant Fields in the Events as", "body": " Indexed  Although some event fields are already defined as indexed, it might make sense to define further ones as indexed as well. Defining event fields as indexed makes searching for specific addresses/values easier.  CS-MKP-001  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Epochs to Avoid Dust", "body": "  The documentation states:  CS-MKP-002  Avoid leftover residual dust amounts when transferring all of a user's balance, since most frontend wallets do not refresh a user's balance on a per second basis.  Working  with  epochs  helps  to  reduce  this  from  happening  but  it  still  happens  when  a  user  crafts  a transaction before an epoch has ended but this transaction is only included in a block in the next epoch.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Gas Optimizations", "body": "  Gas consumption may be reduced in many different parts of the code. Following is a non-exhaustive list of possible gas optimizations:   Corresponding KIBToken and KUMABondToken could be stored locally in KUMASwap, rather than  fetching them through 2 external calls every time   KIBToken._getPreviousEpochTimestamp()   can   be   simplified   to   return  (block.timestamp/epochLength)*epochLength  CS-MKP-003  In  KIBToken._calculatePreviousEpochCumulativeYield()  less-comparison (<) to less-or-equal and simplifying the rest of the function  KIBToken._calculateCumulativeYield()   ,  by  changing   and the  strict   The if-else-statement on _coupons.length() in KUMASwap.sellBond() can be reordered, as during  the  execution  life-cycle  of  the  smart  contract,  the  possibility  of  having  no  coupons  in  the reserve list is low   Adding  an  existing  element  to  a  Set  does  not  fail  but  returns  a  boolean.  Therefore,  it  is  not  necessary to check whether the element is already present in the set  Mimo Initiative lt - Kuma Protocol -   16  InformationalVersion1InformationalVersion1InformationalVersion1           \fIn  KUMAFeeCollector.changePayees():  _totalShares  after  clearing  the  already  existing payees, is zero. Therefore, KUMAFeeCollector.changePayees() does not need to set the local variable totalShares to zero explicitly  The following functions are executed once or rarely, nevertheless:   Parameter  newUri  in  KBCToken.setUri()  could  be  defined  as  calldata,  similarly  name  and  symbol in KIBToken.initialize()   KIBToken.initialize() the first if-statement (check on epochLenght) can be removed, as it is  a subset of the second if-statement  Not a gas optimization but code duplication could be avoided:   Calling  _updateMinCoupon()  in  KUMASwap.buyBond()  can  be  moved  out  of  if-else  to  avoid  duplication of code  Mimo Initiative lt - Kuma Protocol -   17   \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Bond Default", "body": "  If  a  bond  defaults  or  is  expected  to  default,  it  may  start  to  trade  at  a  sharply  reduced  price.  The  KIB tokens  are  still  backed  by  the  bonds  which  now  have  a  much  lower  value  than  anticipated.  Hence  the valuation  of  the  KIB  tokens  will  drop  accordingly.  buyBond()  /  sellBond()  continue  to  buy/sell KUMABond NFTs for the usual exchange rate - except that the actual value of a KIB token is now much lower.  It  is  unclear  if  the  market  price  of  the  KIB  tokens  reflect  this  or  whether  there  is  an  arbitrage opportunity.  If yield accrual is not halted, KIB tokens will devaluate further.  When  redeeming  such  a  KUMABond  NFT  through  MCAG  the  underlying  bond  will  be  sold  on  the secondary market.  Bonds of the same risk category can have a different expiry dates as they could be issued at different times.  Some  bonds  of  a  risk  category  might  expire  in  1  month,  some  in  6  months.  If  the  default  of  an issuer is foreseeable or expected within prolonged timeframe, KUMASwap might end up with the bonds expiring far in the future, while all bonds that expires soon have been bought from the protocol.  In rare cases, a bond might be restructured to avoid a default. The current smart contracts do not support this.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Bridges and Rebasing Tokens", "body": "  The  documentation  mentions  the  KIB  https://docs.kuma.bond/kuma-protocol/kuma-protocol/defi-integrations/bridges  tokens  are   intended   to  be  bridged   to  other  chains:  While technically possible, bridging rebasing tokens is tricky to be done correctly and requires extra care. Even  with  only  dust  amounts  of  KIB  tokens  remaining  locked  at  the  bridge,  eventually  the  deprecation mode will have to be used since insufficient KIB tokens to buy back all the bonds will be available.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.3   CloneBond Token Does Not Respect Blacklist", "body": "  Contrary  to  the  KUMABondNFT,  the  CloneBondToken  does  not  respect  the  blacklist.  The  following interesting behavior can be observed: If a blacklisted address calls buyBond() it succeeds when a clone bond is issued but fails if the KUMABondNFT is transferred.  Mimo Initiative lt states this behavior is intended and blacklisted users won't be able to redeem with Mimo Capital.  Mimo Initiative lt - Kuma Protocol -   18  NoteVersion1NoteVersion1NoteVersion1            \f8.4   Deprecation Mode Possibility  As mentioned in the Docs:  KIBT is minted and burned such that the total supply is always sufficient to buy out all of the KUMA Bonds NFTs held in the contract. However, in extreme cases, some of the KIBT supply may become inaccessible (e.g. if large amounts of KIBT are hacked or lost to unknown addresses).  It  is  worth  mentioning  that  the  likelihood  of  requiring  Deprecation  Mode  is  likely  higher  than  what  is outlined in the documentation. To buy a bond of the protocol one party must accrue sufficient KIB tokens. This  may  prove  to  be  hard  in  practice,  even  when  ignoring  that  some  of  the  KIBT  supply  may  be inaccessible. Especially, when the liquidity of the token is low compared to the bond value to be bought, acquiring  tokens  from  pools  like  Uniswap  might  be  prohibitively  expensive  as  their  price  increases especially if large quantities are bought.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.5   KIB Price Determination & Volatility", "body": "  It  may  be  obvious  that  one  KIB  token  should  be  priced  at  one  unit  of  the  underlying  principal  token. However due to low liquidity, constrains around redemption of KIB tokens (accruing sufficient KIB tokens, buying the bond of the protocol, off-chain redemption) the price may fluctuate. Furthermore, low liquidity in e.g. Uniswap pools result in notable price volatility / slippage when trading as well as potential price manipulation.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.6   KUMAAddresProvider:", "body": " KUMAAccessController Not Immutable  The KUMAAccessController contract is the sole contract that does not implement upgradability features. In  the  KUMAAddressProvider,  the  KUMAAccessControler  is  the  only  address  that  cannot  be  updated after it has been initialized.  Note that since the KUMAAddressProvider is upgradable, the implementation may change and allow to update the address of the KUMAAccessController.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.7   Risks of Low Liquidity", "body": "  Low liquidity of the KIB tokens may have negative effects when using the token in DeFi systems such as Uniswap,  Balancer,  Curve  and  more.  This  includes  price  volatility/manipulation,  slippage  and  arbitrage opportunities.  Furthermore low liquidity may have negative consequences when attempting to raise sufficient liquidity to buy a bond of KUMASwap. Notably this may delay the removal of expired bonds  Mimo Initiative lt - Kuma Protocol -   19  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                \f8.8   Stuck Stablecoins  Deprecation mode can be enabled if it is no longer possible to acquire sufficient KIB tokens to buy back bonds. In this mode, the KUMA_MANAGER_ROLE can buy back the bonds for the defined stablecoin. KIB token  holders  can  then  exchange  their  tokens  for  a  proportional  share  of  the  stablecoin  held  by  the contract. By design, if some KIB tokens are no longer accessible they cannot be redeemed for their share of the stablecoins, hence these stablecoins will then be locked at the KUMASwap contract.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.9   Use as Collateral", "body": "  The  upgradability  of  both  the  KIB  token  contracts  and  the  contracts  that  control  token  minting (KUMASwap)  and  to  a  smaller  extent  the  deprecation  mode  could  discourage  lending  protocols  from accepting the token as collateral.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.10   _couponTolerance Protection Mechanism", "body": "  When a bond is sold to the protocol, a check ensures that the bond's coupon is not considerably lower than the existing minCoupon rate. However, this check is only applicable to the coupon rate of the newly offered  bond.  Multiple  bond  sales  to  the  protocol,  potentially  in  quick  succession,  could  reduce  the minCoupon by a larger margin.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.11   balanceOf, totalSupply and", "body": " getUpdatedCumulativeYield Potentially Returning Virtual State  balanceOf and totalSupply are both view functions according to the ERC-20 standard, hence can't modify state.  To  determine  the  balance  /  totalSupply  the  last  _calculatePreviousEpochCumulativeYield() has to be evaluated. If refreshYield() has already been executed in this epoch, the value is simply read from storage and returned. Otherwise the new value is calculated and returned but not stored.  these   this  happens  after  an  execution  of internally,  Whenever  _refreshCumulativeYield()  and  _refreshYield()  hence  the  value  has  already  been  updated and is just returned from storage.  functions  are  used   External callers should be aware that when calling these functions they may get \"virtual\" balance and the contract state itself has not updated yet. The values will only be updated with the next state changing call to _refreshCumulativeYield().  Similarly, this applies to the external view function getUpdatedCumulativeYield() which is called by KUMASwap  in  buyBond()  and  sellBond()  before  a  state  changing  function  (e.g.  minting/burning) tokens are called which recalculates and this time stores the updated the value.  Mimo Initiative lt - Kuma Protocol -   20  NoteVersion1NoteVersion1NoteVersion1NoteVersion1              \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Traders Pay More Collateral Than Specified", "body": "  Users buying call or put options (spear or shield tokens) specify the amount of collateral they are willing to  pay  and  receive  as  many  options  as  possible.  Traders  also  pay  transaction  fees  on  top  of  option premiums. Fees are computed as follows:  CS-DPV1-005  step.feeAmount = FullMath.mulDiv(step.amountOut, fee.transactionFee, 1e6); ... state.transactionFee += step.feeAmount;  Note that step.amountOut refers to the amount of options that are bought in a trading step. However, fees are collected in the collateral asset:  cAmount = params.amountSpecified - state.amountSpecifiedRemaining     + state.transactionFee + state.protocolFee;  Tenet Technology Ltd - Divergence Protocol v1c -   13  SecurityDesignCorrectnessCriticalHighMediumAcknowledgedLowCodePartiallyCorrectedCodePartiallyCorrectedAcknowledgedCodePartiallyCorrectedAcknowledgedRiskAcceptedCodePartiallyCorrectedRiskAcceptedCorrectnessMediumVersion1Acknowledged           \fIf fees are set for a battle, cAmount will be larger than params.amountSpecified for a trade, hence the function reverts if traders do not have enough balance (cAmount) or they have not provided enough allowance to Manager.  Acknowledged:  Tenet  Technology  Ltd  is  aware  of  this  issue  but  has  decided  to  keep  the  smart  contracts  unchanged. Tenet  Technology  Ltd  will  inform  users  in  the  UI  for  the  fee  amount  that  should  be  paid  on  top  of  the premiums. However, users that interact directly with the smart contracts should be aware of this behavior and take the respective measures.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Unused Imports", "body": "  Several  contracts  in  the  codebase  import  libraries  or  contracts  that  remain  unused.  We  present  a non-exhaustive list below:  CS-DPV1-012  Manager.sol  import { IERC20 } from \"@oz/token/ERC20/IERC20.sol\"; import { SafeCast } from \"@oz/utils/math/SafeCast.sol\"; import { IManagerState } from \"./interfaces/IManagerState.sol\";  Arena.sol  import { IBattleActions, IBattleMintBurn } from     \"core/interfaces/battle/IBattleActions.sol\";  Battle.sol  import { IBattleBase } from \"core/interfaces/battle/IBattleActions.sol\"; import { IBattleState } from \"core/interfaces/battle/IBattleState.sol\"; import { IBattleInit } from \"core/interfaces/battle/IBattleInit.sol\"; import { IBattleMintBurn } from \"core/interfaces/battle/IBattleActions.sol\"; import { IArenaState } from \"core/interfaces/IArena.sol\"; import { DiverSqrtPriceMath } from \"core/libs/DiverSqrtPriceMath.sol\";  Code partially corrected:  Some of the unused imports have been removed, while other are still present. For example:  Manager.sol  import { IManagerState } from \"./interfaces/IManagerState.sol\";  Battle.sol  import { IBattleBase } from \"core/interfaces/battle/IBattleActions.sol\"; import { IBattleInit } from \"core/interfaces/battle/IBattleInit.sol\"; import { IBattleMintBurn } from \"core/interfaces/battle/IBattleActions.sol\";  Tenet Technology Ltd - Divergence Protocol v1c -   14  DesignLowVersion2CodePartiallyCorrected        \fimport { IArenaState } from \"core/interfaces/IArena.sol\"; import { DiverSqrtPriceMath } from \"core/libs/DiverSqrtPriceMath.sol\";  Please note that the aforementioned list is non-exhaustive and there might still exist some other unused imports in the codebase.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   LiquidityDelta Check in Position.update", "body": "  The  function  Position.update  performs  a  check  whether  liquidityDelta  ==  0.  Following  all callpaths suggests it can never be a case, as update() is called from Battle._updatePosition() which  is  called  from  Battle._modifyPosition().  The  latest  is  called  only  during  minting  and burning.  In  Battle.mint()  an  earlier  check  is  done  on  liquidity  being  non-zero.  Once  minted  with non-zero  liquidity,  calling  Manager.removeLiquidity()  assures  that  the  liquidity  of  this  position  is also non-zero.  CS-DPV1-001  Code partially corrected:  As mentioned above, when minting there already exists a check that the liquidity amount to be added to a position  is  non-zero,  hence  minting  on  the  battle-side  is  also  called  with  a  non-zero  liquidity.  When removing liquidity from a position, as upon adding liquidity, the liquidity is already non-zero. Hence, this check is redundant.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.4   Mismatch of Min/Max Ticks With the Edge", "body": " Prices  The whitepaper suggests that prices 0.01 and 0.99 are valid priced in the curve:  In implementation   ,    are bounded within [0.01, 0.99].  Library  TickMath  sets  the  minimum  tick  to  -45953  and  maximum  tick  to  45953,  which  correspond  to prices 0.0101 and 0.9899 respectively, hence prices 0.01 and 0.99 cannot be reached in the curve.  CS-DPV1-007  Acknowledged:  Tenet Technology Ltd has decided to keep the min/max ticks unchanged, and they provide the following reasoning:  The difference in prices computed from min/max ticks and the theoretical limits set in the whitepaper is so minuscule that it is deemed fit for production.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.5   Missing Sanity Checks", "body": "  Tenet Technology Ltd - Divergence Protocol v1c -   15  DesignLowVersion1CodePartiallyCorrectedCorrectnessLowVersion1AcknowledgedDesignLowVersion1CodePartiallyCorrected                        \fThe following functions set important state variables but do not implement any sanity check on the inputs:  CS-DPV1-009  1. _fee in Arena.setFeeForUnderlying().  2. fee in setUnderlyingWhitelist().  3. bk.strikeValue   in   createBattle(),   i.e.,   after   calling   getAdjustPrice(),  bk.strikeValue should not be rounded down to 0.  4. _oracleAddr and _battleImpl in Arena.constructor().  5. _manager in Arena.setManager().  6. _arena and _WETH9 in contract PeripheryImmutableState.  Code partially corrected:  The sanity checks reported in points 3-6 have been added.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.6   NFTs Are Never Burned in Manager", "body": "  The NFTs minted in Manager are not burned after an LP removes its liquidity and/or withdraws/redeems its  obligations.  Hence,  the  state  is  not  cleared  and  old  NFTs  remain  in  the  balance  of  users,  possibly degrading user experience.  CS-DPV1-010  Acknowledged:  Tenet Technology Ltd acknowledged this behavior and provided the following reasoning:  NFTs are kept in order to provide historical records to users, who may need reference for past trade.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.7   Possible to Frontrun Fee Updates in Arena", "body": "  The mapping fees in the contract Arena stores the fees for an underlying. On battle deployment, Arena sets battle's fees for the respective underlying. Fees in the battle cannot be changed after deployment even  if  they  are  updated  in  the  Arena.  Consider  the  scenario,  in  which  owner  of  Arena  decides  to increase fees for an underlying. In this case, users can front-run this transaction to deploy their battles with lower fees, hence making them more attractive for traders.  CS-DPV1-011  Risk accepted:  Tenet Technology Ltd is aware of this issue but has decided to keep the relevant codebase unchanged.  Tenet Technology Ltd - Divergence Protocol v1c -   16  DesignLowVersion1AcknowledgedSecurityLowVersion1RiskAccepted                  \f5.8   Unclear Specifications for the Format of Strike Price  CS-DPV1-015  should   specify  a   function Users  createAndInitializeBattle  field battleKey.strikeValue. This value is expected to be in 18 decimals, however the specifications do not clarify the format of the strike price and its quote token. Incomplete or missing specifications increase the likelihood of mistakes from users or third-party systems that interact with the system.  strike  price  when  deploying  a  new  battle.  The   struct  which   includes   takes   input   the   as   a   Code partially corrected:  In   , the following inline comment is added for function getAdjustPrice:  /// @param price price of underlying. price has decimal 18, eg. eth price 1500 will be 1500 * 10**18  However,  public  and  external  functions  such  as  createAndInitializeBattle()  that  are  called  by end users do not describe the expected format of inputs.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.9   Update of Oracle Addresses", "body": "  The  account  owner  in  the  contract  Oracle  can  update  the  address  of  an  oracle  for  an  underlying (symbol) via the function setExternalOracle. The address change of an external oracle effects only the  new  battles  that  are  deployed  afterwards,  while  the  ongoing  battles  do  not  reflect  the  change. Therefore,  ongoing  battles  cannot  settle  if  the  external  oracles  fail  to  publish  prices  as  expected.  The function getPriceByExternal that gets called by battles do not check that cOracleAddr is still the correct oracle for the respective symbol.  CS-DPV1-016  Rick accepted:  Tenet Technology Ltd is aware of this behavior and has decided to keep the code unchanged, providing the following motivation:  The update of oracle addresses during on-going battles is disabled as it is considered an attack vector, in which a malicious actor may update the oracle address to affect settlement results. In case of external oracles fail to publish prices as expected, the owner will be given the ability to address the issue an hour post expiry, only after all prior processes fail to settle a pool.  In   of the codebase, the severity of the issue presented above is limited as the oracle defaults to prices reported by owner in case the external oracle does not work as expected. However, this requires additional trust for owner to behave correctly.  Tenet Technology Ltd - Divergence Protocol v1c -   17  CorrectnessLowVersion1CodePartiallyCorrectedVersion2DesignLowVersion1RiskAcceptedVersion2                \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  Incorrect Iteration of Rounds From Chainlink Oracle    Missing Sanity Checks on Price From Oracle    Missing Slippage Protection When Providing Liquidity   -Severity Findings   Events Missing in Arena    Hardcoded Balances for Spear and Shield in getAllBattles   Intended Oracle Address for a Battle   Intended Use of Owed Values in Battle    Missing Natspec    Rounding Errors    Special Behavior of getAdjustPrice    Special Case in Function Pay    Storage Variable deploymentParameters in Arena    Unused Functions in PeripheryPayments    _safeMint Not Used in Manager   Informational Findings  Indistinguishable Spear and Shield Tokens    Redundant Import of Library    Commented Code and Remaining ToDos    Possible Event Reentrancy in addLiquidity    Unused Error NotNeedChange    NFT Approvals Not Considered in Manager   0  0  3  11  6  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Incorrect Iteration of Rounds From Chainlink", "body": " Oracle  CS-DPV1-002  Tenet Technology Ltd - Divergence Protocol v1c -   18  CriticalHighMediumCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion1CodeCorrected            \fThe internal function Oracle._getPrice iterates backward through the rounds reported by a Chainlink oracle as follows:  for (uint80 i = id; i > 0; i--) {     (, int256 answer, uint256 startedAt,,) = cOracle.getRoundData(i);     ... }  As described in the docs of oracles, there is no guarantee that round IDs are monotonically increasing. More  specifically,  when  the  aggregator  updates  the  implementation,  a  gap  in  the  between  two consequent  roundIDs  is  created.  If  such  an  update  happens  between  a  battle's  expiry  and  its settlement, the function _getPrice reverts as it queries prices for invalid roundID. Therefore, the battle cannot settle and neither liquidity providers, nor traders can claim their collateral tokens.    , the first round in the current phase is fetched and the code iterates backward from the latest In  ID to the starting ID in the current phase. Hence, all the round IDs are valid. Note, if there is an update of phase ID after the expiry of a battle, oracle returns the manually set prices by its owner.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Missing Sanity Checks on Price From Oracle", "body": "  The internal function Oracle._getPrice does not enforce a restriction on the maximum delay between the battle expiration and the first price reported by the Chainlink oracle after expiration:  CS-DPV1-003  for (uint80 i = id; i > 0; i--) {     (, int256 answer, uint256 startedAt,,) = cOracle.getRoundData(i);     if (startedAt < ts) {         break;     }     if (startedAt >= ts) {         p = decimalDiff * answer.toUint256();         actualTs = startedAt;     } } require(p != 0, \"price not exist\");  It might happen that the Chainlink publishes a price shortly before the expiration and the next overwritten with a significant delay which possibly deviates from the correct price at expiration, however it still gets used as the settlement price by the battle.  Specification changed:   and the specifications of the function _getPrice The contract Oracle has been refactored in  have  changed.  The  new  specifications  consider  prices  from  the  external  oracles  (i.e.,  Chainlink)  to  be valid  if  they  are  published  in  the  first  hour  after  the  expiration  of  a  battle,  otherwise  fallback  prices provided by the owner of the contract Oracle are used.  Tenet Technology Ltd - Divergence Protocol v1c -   19  Version2DesignMediumVersion1Speci\ufb01cationChangedVersion2          \f6.3   Missing Slippage Protection When Providing Liquidity  The function Manager.addLiquidity does not implement any slippage protection mechanism, hence leaving LPs susceptible to front-running attacks. In a scenario where an LP intends to provide liquidity into a slot that covers the current price, the transaction can be front-run to move the current price outside the slot such that less liquidity is minted for the victim transaction.  Similarly, a victim LP that deploys a new battle with a target initial price and adds liquidity to it can be attacked  by  front-runners  to  deploy  the  same  battle  (same  battle  key)  but  with  a  malicious  initial  price such that the honest LP receives less liquidity.  CS-DPV1-004    In  LiquidityManagement._addLiquidity():  protection   slippage   a   ,   in   the   following   form   has   been   added   to  if (sqrtPriceX96 < params.minSqrtPriceX96 || sqrtPriceX96 > params.maxSqrtPriceX96) {     revert Errors.Slippage(); }  Hence,  if  due  to  the  front-running,  the  current  price  on  the  battle-side  has  changed  unexpectedly,  the transaction reverts.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   Events Missing in Arena", "body": "  The  function  setFeeForUnderlying  modifies  the  state,  however  the  respective  event  FeeChanged declared  in  the  interface  IArena  is  not  emitted.  Similarly,  the  function  setManager  updates  an important state variable but does not emit an event.  CS-DPV1-006    In Arena for evey state changing function, a relevant event gets emitted.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Hardcoded Balances for Spear and Shield in", "body": " getAllBattles  The  function  getAllBattles  queries  the  state  of  all  battles,  except  for  spearBalance  and shieldBalance which are set to 0:  CS-DPV1-036  Tenet Technology Ltd - Divergence Protocol v1c -   20  SecurityMediumVersion1CodeCorrectedVersion2DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \finfos[i] = BattleInfo({     ...     spearBalance: 0,     shieldBalance: 0,     ... });  However,  as  the  balance  of  spear  and  shield  in  a  battle  is  not  defined,  holding  these  values  is meaningless.    Tenet Technology Ltd has removed these fields from the struct BattleInfo.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Intended Oracle Address for a Battle", "body": "  The  struct  CreateAndInitBattleParams  includes  a  field  named  oracle,  however  the  function createBattle  uses  the  address  in  the  state  variable  oracleAddr  when  setting  the  deployment parameters for a new battle.  CS-DPV1-033    Tenet Technology Ltd has removed the oracle field from the struct CreateAndInitBattleParams.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   Intended Use of Owed Values in Battle", "body": "  Struct PositionInfo has the field insideLast that accounts for the growth inside a position per unit of  liquidity,  and  another  field  owed  which  accounts  the  growth  inside  the  position.  However,  the  field owed  is  not  read  by  the  contracts  in  scope  and  appears  to  be  redundant  as  all  positions  in  battle contracts are held by the manager.  CS-DPV1-034    The unused field owed has been removed from the updated codebase.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   Missing Natspec", "body": "  A  large  number  of  functions  are  missing  proper  documentation  and  description.  Natspec  helps  to understand more quickly the intention of functions which improves code readability. Natspec of external  CS-DPV1-008  Tenet Technology Ltd - Divergence Protocol v1c -   21  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \ffunctions also helps third-parties that integrate with the system, e.g., by providing information regarding the format of input values.    The inline comments and specifications have been extended in the   .  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.9   Rounding Errors", "body": "  In Battle._modifyPosition(), in case of adding collateral liquidity to a position covering the current tick, spear and shield collaterals (csp and csh) are rounded down. When called from Battle.mint(), seed  =  csp  +  csh  is  used  as  the  amount  of  collateral  an  LP  has  to  pay.  Hence,  LP  pays  less collateral than expected.  CS-DPV1-013  Specification changed:  The function _modifyPosition has been refactored in  rounding errors has been removed.   and the computation that was prone to  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.10   Special Behavior of getAdjustPrice", "body": "  The function getAdjustPrice behaves differently depending on the value of the input price: i) values smaller than 10**11 are rounded down to 0; ii) values smaller than 10**12 are rounded down to one significant digit; ii) other values are rounded down to two significant digits.  The implementation of getAdjustPrice() does not match the formula in the Natspec of the function.  CS-DPV1-014    Tenet Technology Ltd has revised the function to require that input price is larger than 10**12, so for any allowed price, getAdjustPrice() returns the price with 2 decimals.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.11   Special Case in Function Pay", "body": "  The internal function pay in PeripheryPayments considers a case when payer == address(this).  else if (payer == address(this)) {     // pay with tokens already in the contract (for the exact input multihop case)     TransferHelper.safeTransfer(tokenAddr, recipient, value); } else {     // pull payment  CS-DPV1-035  Tenet Technology Ltd - Divergence Protocol v1c -   22  Version3CorrectnessLowVersion1Speci\ufb01cationChangedVersion2CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f    TransferHelper.safeTransferFrom(tokenAddr, payer, recipient, value); }  This case is redundant.    Tenet Technology Ltd has correctly removed this redundant case.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.12   Storage Variable deploymentParameters in", "body": " Arena  The  contract  Arena  defines  a  storage  variable  named  deploymentParameters.  It  is  set  during createBattle()  and  practically  stores  the  deployment  information  about  the  last  instance  of  battle being deployed. This increases gas costs on both deployment and runtime.  CS-DPV1-032    The  state  variable  deploymentParameters  has  been  removed  from  the  updated  codebase  in  .  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.13   Unused Functions in PeripheryPayments", "body": "  The abstract contract PeripheryPayments that is inherited by Manager implements several functions that are declared as payable, do not implement any access control, and transfer any token balance held by Manager to arbitrary addresses:  CS-DPV1-031   unwrapWETH9()   sweepToken()   refundETH    The functions listed above have been removed from the updated codebase.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.14   _safeMint Not Used in Manager", "body": "  CS-DPV1-017  Tenet Technology Ltd - Divergence Protocol v1c -   23  DesignLowVersion1CodeCorrectedVersion2DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fThe  function  Manager.addLiquidity  mints  new  NFTs  by  calling  the  internal  function  _mint  which does not perform any check on the recipient address. Therefore, if recipient is a smart contract that cannot handle NFTs, the newly minted NFT would be locked.  If  recipient  is  a  smart  contract,  then  the  function  _safeMint  checks  whether  it  implements  the interface IERC721Receiver. Note that _safeMint performs a call to untrusted address recipient.    In  recipient of the NFT is a smart contract that does not implement the interface IERC721Receiver.  ,  function  _safeMint  is  used  when  creating  a  new  NFT.  _safeMint()  reverts  if  the  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.15   Possible Event Reentrancy in addLiquidity", "body": "  The function addLiquidity calls ERC721._safeMint which triggers the onERC721Received hook on  the  recipient,  effectively  giving  control  to  an  untrusted  contract.  At  this  point,  the  external  contract could reenter the contract and call addLiquidity() again which mints a new NFT token. In this case, events  LiquidityAdded  would  not  be  ordered  sequentially,  therefore  potentially  complicating  the monitoring and reconstruction of contract state based on the events info.  CS-DPV1-030    The minting of the NFT has been moved into the end of the function addLiquidity.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.16   Commented Code and Remaining ToDos", "body": "  Commented  out  code  is  present  in  the  function  Battle.trade  and  in  the  contract  Manager.  Also,  a todo note is remaining in the Natspec of the function getSTokenDelta. Removing commented code and addressing remaining note could help improve the readability.  CS-DPV1-018    The commented code and remaining ToDos have been removed from the updated codebase.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.17   Indistinguishable Spear and Shield Tokens", "body": "  Arena  deploys  a  set  of  ERC20  tokens  named  spear  and  shield  for  each  battle  created.  These  ERC20 tokens  have  the  same  name  (Spear/Shield)  and  symbol  (SPEAR/SHIELD)  for  all  battles,  hence possibly confusing for users to distinguish them.  CS-DPV1-022  Tenet Technology Ltd - Divergence Protocol v1c -   24  Version2InformationalVersion2CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                  \f  The  function  Arena.createBattle  has  been  revised  to  deploy  STokens  with  distinguishable  name and symbol by appending the battle number after their name and symbol (Spear-X/Shield-X):  string memory indexString = Strings.toString(battleList.length); address spear = address(new SToken(string.concat(\"Spear\", indexString),      string.concat(\"SPEAR\", indexString), decimals, battle)); address shield = address(new SToken(string.concat(\"Shield\", indexString),      string.concat(\"SHIELD\", indexString), decimals, battle));  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.18   NFT Approvals Not Considered in Manager", "body": "  The ownership of LP positions in Manager is tracked with NFTs. The contract ERC721 allows holders of NFTs  to  provide  approvals  for  a  specific  NFT  or  all  NFTs  to  other  trusted  accounts.  However,  this functionality is not considered in Manager as only the owner of an NFT can call functions that modify the position of an NFT.  CS-DPV1-025    Functions  removeLiquidity(),  withdrawObligation()  and  redeemObligation  now  use  the following modifier to restrict the access:  modifier isAuthorizedForToken(uint256 tokenId) {     require(_isApprovedOrOwner(msg.sender, tokenId), \"Not approved\");     _; }  Hence, a user holding approvals of NFT, can withdraw the liquidity on behalf of the owner. The recipient of collateral is the onwer of the NFT.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.19   Redundant Import of Library", "body": "  Library FixedPoint128 is imported twice in the contract Manager.    The redundant import of this library is removed.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.20   Unused Error NotNeedChange", "body": "  CS-DPV1-027  CS-DPV1-029  Tenet Technology Ltd - Divergence Protocol v1c -   25  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                  \fLibrary Errors declares the error NotNeedChange which is unused in the codebase.    This error has been removed.  Tenet Technology Ltd - Divergence Protocol v1c -   26  \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Compiler Version", "body": "  following  The  https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json#L1834  compiler   (0.8.19)   version   used   has   the   CS-DPV1-019  known   bugs:  This is just a note as we do not see any issue applicable to the current code.  The contracts should be deployed using a compiler version they have been thoroughly tested with. Using a very recent version may not be recommend as it may not be considered battle-proof yet. At the time of writing the most recent version is 0.8.21.  For more information please refer to the release notes: https://github.com/ethereum/solidity/releases  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Dependency Versions", "body": "  The smart contract libraries used by the project are:  openzeppelin chainlink uniswap/v3-core uniswap/v3-periphery  CS-DPV1-020  These libraries are either not up-to-date (openzeppelin and chainlink), or do not refer to a tagged commit (v3-core and v3-periphery) in the third-party repository.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Gas Optimizations", "body": "  CS-DPV1-021  The codebase could be more efficient in terms of gas usage. Reducing the gas costs may improve user experience. Below is an incomplete list of potential gas inefficiencies:  1. The mapping Oracle.externalOracleOf is declared public, however a public getter function  getCOracle is redundantly implemented.  2. Function  Oracle.getPriceByExternal  could  exit  early  if  latestRoundData()  returns  a  price before the option's expiry.  3. Function  Arena.setPermissionless  performs  redundant  SLOADs  when  accessing  the  state variable  isPermissionless.  Instead  of  toggling  the  state  variable  isPermissionless  it  can take the intended value as input parameter.  Tenet Technology Ltd - Divergence Protocol v1c -   27  InformationalVersion1InformationalVersion1InformationalVersion1CodePartiallyCorrected            \f4. Function Arena.createBattle performs redundant SLOADs when accessing the state variable  managerAddr.  5. Functions  initState  and  init  in  the  Battle  could  be  merged  to  avoid  one  external  call  from  Manager contract to the Battle during deployment.  6. Function addLiquidity creates a new memory variable p1 with the field recipient overwritten,  however it's not used.  7. The external call spearAndShield() in function _addLiquidity can be avoided if collateral is  being deposited.  8. Function  Battle.mint  performs  external  calls  to  verify  that  the  intended  amount  of  tokens  has been  transferred  to  battle,  however,  as  the  function  can  be  called  only  by  manager, mintCallback ensures that the funds are transferred.  9. Contract  Arena  could  deploy  the  pair  of  SToken  contracts  as  proxies  to  reduce  the  gas  costs  of  battle deployment. However, note that this approach would increase gas costs on execution.  10. The code assigning the value of pmMemory.liquidityType to bp.liquidityType in function  removeLiquidity could be simplified.  11. The  modifier  lock  in  contract  Battle  could  be  more  gas  efficient  if  non-zero  values  are  used  to  record the state.  12. The calculation of state.protocolFee could be moved outside the while-loop.  13. The  check  params.amountRemaining  <  0  in  function  computeTradeStep  is  redundant  as  amountRemaining is of type uint256, hence cannot be negative.  14. Function  computeTradeStep  calculates  first  the  capacity  (cap),  then  in  the  else  branch computes again the same value for amountIn (except rounding). The computation of amountIn could be avoided if cap was rounded up.  15. Function  Manager.tradeCallback   implements   a   redundant   logic  with   function  verifyCallback.  16. Battle.maxLiquidityPerTick is set to Tick.tickSpacingToMaxLiquidityPerTick(1)  which has a predefined value. Hence, it can be changed to constant.  17. Battle._modifyPosition() calculates the seed using the same formula for Spear and Shield  liquidity. Hence, those two can be merge to a single else-statement.  18. TradeMath.computeTradeStep()  calculates  amountIn  and  amountOut  in  the  same  way, whether params.amountRemaining < cap or not. Therefore, those lines calculating amountIn and amountOut can be moved out of if-else-statement.  19. Input arguments of Oracle.setExternalOracle() can be defined as calldata.  20. sAmount input argument in Manager.tradeCallback() is not used and could be commented  out.  21. data input argument in Quoter.tradeCallback() is not used and could be commented out.  22. DiverSqrtPriceMath.getSTokenDelta(),  in  the  current  status  of  the  codebase,  is  always  called with non-negative liquidity. Hence, checking for negative liquidity is unnecessary.  :  23. The field DeploymentParams.arenaAddr is not used.  24. Function Battle.init() performs two checks to ensure that the battle has not been initialized  before.  25. Function  Battle.init()  performs  an  external  call  to  retrieve  decimals  of  the  collateral  token  which could be passed as function argument from Arena.  26. Function Battle.mint() declares a storage pointer positionInfo which remains unused.  Tenet Technology Ltd - Divergence Protocol v1c -   28  Version2\f27. Arena.createBattle() checks if params.bk.strikeValue == 0. This cannot happen, as params.bk.strikeValue is the return value of getAdjustPrice() which never returns 0.  28. Oracle.getPriceByExternal() can be defined as external.  29. Position.update()  needs  to  calculate  liquidityNext  if  liquidityDelta  !=  0.  Hence,  this calculation can be moved inside the if-statement.  30. Position.tokenId is a redundant field, as on the manager-side, the respective position is stored  in a mapping with the tokenId as key.  31. BattleInitializer.createAndInitializeBattle()  does  not  need  to  check  if  the  the  battle is already deployed in the Arena, as the same check is done in the Arena.  Code partially corrected:  The codebase has been updated to implement several gas savings reported above. However, points 3, 8, 11, 16, 19-27, 29 and 31 are still present.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Magic Values in Codebase", "body": "  Several  magic  values  are  used  in  the  codebase  that  could  be  declared  as  constant.  For  instance,  the function  Arena.createBattle  uses  values  28_800  and  86_400  that  could  be  replaced  with constants. Similarly, the contract Battle uses the value 1 for tick spacing which can be replaced with a constant variable to improve code readability.  CS-DPV1-023  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   Missing Functions in Interfaces", "body": "  The interface IBattleState does not include the getter function for the state variable fee. Similarly, the interface IQuoter does not include the function quoteExactInput among others.  CS-DPV1-024  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.6   Possible Packing of State Variables", "body": "  Several struct data types in the codebase could be optimized to use less storage by reordering or using smaller types. For instance, the field expiries stores timestamps which can be saved in less than 256 bits, hence its type can be changed so that both collateral and expiries fit into a single storage slot. Similarly, the struct Fee could be optimized by changing variable types given that values stored do not exceed 10**6, while struct Position could be optimized by reordering its fields.  CS-DPV1-026  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.7   Relaxed Condition on Collateral", "body": "  Tenet Technology Ltd - Divergence Protocol v1c -   29  CS-DPV1-037  InformationalVersion1InformationalVersion1InformationalVersion1InformationalVersion1                \fManager.getObligation() calculates the return value collateral in the following way:  collateral = pm.owed.collateralIn + pm.seed == obligation ?     0 : pm.owed.collateralIn + pm.seed - obligation - 1;  for  liquidity  type  of  collateral.  Relaxing  the  condition  by  changing  ==  to  <=  could  prevent  some  corner cases in which due to rounding errors, pm.owed.collateralIn + pm.seed is slightly rounded down. The same argument holds for other liquidity types.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.8   Rounding Errors on Computing sTokens", "body": "  The function getSTokenDelta in library DiverSqrtPriceMath takes as last input the flag roundUp. The function rounds up all intermediary values when the flag roundUp is set to true. Therefore, it is possible that the function returns an amount with a higher difference than 1 compared to the amount returned by the same function when called with roundUp set to false.  CS-DPV1-028  Tenet Technology Ltd - Divergence Protocol v1c -   30  InformationalVersion1    \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   Battles Should Be Settled After Expiration", "body": "  The  contract  Battle  implements  a  public  function  settle  that  can  be  called  by  anyone  to  decide  the winning token (spear/shield). However, there is no additional incentive to call this function, hence can be called with a delay.  Function settle triggers a call to Oracle._getPrice() which implements a for-loop that iterates through  historical  prices  reported  by  the  oracle  until  the  correct  one  (closest  to  and  after  the  battle's expiration) is found. The loop could run out-of-gas if settle() is called with a considerable delay and enough prices have been published by the oracle. In this case, for-loop will run out of gas to reach the desired price and will consequently fail.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Battles With Malicious Starting Prices", "body": "  The deployer of a battle can freely choose the initial price startSqrtPriceX96 as long as it falls in the range of allowed prices. Therefore, it is possible that for an attacker to initialize battles with a malicious price  (which  does  not  reflect  the  fair  price  of  options  at  the  time  of  deployment)  to  degrade  user experience  or  cause  denial-of-service  (DoS).  The  attacker  has  to  pay  for  the  gas  costs  to  deploy  new battles, while the process and cost to recover the battle (set a fair price) depends on the behavior of the attacker.  A  battle  initialized  with  a  malicious  starting  price  could  recover  more  easily  if  the  attacker  did  not  add liquidity into it. In this scenario, an honest LP should add collateral as liquidity around the fair price and then a trade should happen. However, the trade is limited on buying the option that was priced higher by the attacker on deployment which might be inconvenient for traders.  If an attacker initializes a battle with a malicious price and adds liquidity into it, the process of recovering becomes more costly. In this scenario, the attacker sets the starting price to one edge of the curve (e.g., around minimum tick where spear is very expensive), then adds collateral as liquidity into a range above the current tick where spear is still priced higher than the fair price. The only way for the battle to recover is  for  traders  to  consume  all  liquidity  provided  by  the  attacker  which  means  buying  options  for  a  price higher than the fair one. Hence, such battles could remain unused, which degrades the user experience.  An attacker can even cause temporary DoS for a pair of collateral and underlying assets. As described in Limited Entropy for Battle Keys, an attacker could deploy all possible battles for a target expiration date (e.g., end of month), and a price change range (\u00b110%) to render such battles useless.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.3   Fallback Prices in Oracle", "body": "  Oracle.getPriceByExternal()  gets  called  when  the  battle  is  to  be  settled  after  the  expiry.  Tenet Technology Ltd has informed us that they have an off-chain agreement with Chainlink to publish prices between 8 A.M. and 9 A.M. UTC (1 hour interval) for all collateral tokens used in battles. If for any reason  Tenet Technology Ltd - Divergence Protocol v1c -   31  NoteVersion1NoteVersion1NoteVersion2          \fChainlink  fails  to  publish  valid  prices  during  this  interval,  Oracle  contract  defaults  to  the  fixPrices which are manually set by the owner.  Furthermore, getPriceByExternal() queries Chainlink prices sequencially to find out the first price published after a battle expires. However, if it happens that the aggreggator implementation of the oracle is  updated  during  this  time,  getPriceByExternal()  fails  to  query  older  prices  (due  to  phaseId change). In this scenario also, the contract Oracle defaults to the fixPrices set by the owner.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.4   Function quoteExactInput Is Gas Inefficient", "body": "  The function Quoter.quoteExactInput is a helper function that allows traders to estimate how much collateral they should pay and how many option tokens they receive for a set of trading parameters. The function is implemented in such a way that it calls the actual Battle.trade function to find out spend (collateral) and get (options) amounts. This means that quoteExactInput() triggers all state changes that  a  normal  trade  would  do,  but  reverts  in  the  end.  Therefore,  the  gas  costs  of  calling  this  function on-chain are comparable with gas costs of Battle.trade.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.5   Limited Entropy for Battle Keys", "body": "  The battle key in Arena is computed as follows:  bytes32 battleKeyB32 = keccak256(abi.encode(bk.collateral, bk.underlying, bk.expiries, bk.strikeValue));  The entropy for battle keys comes from expiries and strikeValue for a given pair of collateral and underlying. However, both expiries and strikeValue can be values from discrete sets, and it is feasible for one to deploy all possible battles for a target expiry (e.g., end of month) and a price range (e.g., \u00b110%).  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.6   String Type Used as Key in Mappings", "body": "  The mappings externalOracleOf in Oracle, and fees and underlyingWhitelist in Arena use keys  of  type  string.  We  highlight  the  possibility  to  have  different  Unicode  characters  that  render similarly or using invisible Unicode characters, which could be misused by attackers to trick users.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.7   Users Should Validate Collateral Tokens", "body": "  If  Arena.isPermissionless  is  set,  users  can  deploy  battles  with  arbitrary  tokens  as  collateral. However, the smart contracts in scope of this review work as expected only with standard ERC20 tokens that  do  not  implement  special  features  such  as  transfer  hooks,  rebasing,  or  transfer  fees.  See  Section Roles and Trust Model for more details.  Tenet Technology Ltd - Divergence Protocol v1c -   32  NoteVersion1NoteVersion1NoteVersion1NoteVersion2                \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Decimals Mismatch in CappedOracle", "body": "  The  function  CappedOracle.decimals  returns  8  regardless  of  the  decimals  of  the  source,  that  is expected to be a Chainlink price oracle. This creates a decimals mismatch when the source is an ETH for  stETH/ETH  has  18  decimals pair.  For  example,  (https://etherscan.io/address/0x86392dc19c0b719886221c78ab11eb8cf5c52812#readContract#F3).  If the  price  of  an  ETH  pair  is  computed  with  the  decimals  of  the  CappedOracle,  the  price  will  be  either heavily  over-evaluated  if  maxPrice  has  18  decimals,  or  always  capped  to  maxPrice  if  it  has  8 decimals.  the  Chainlink  price  oracle   CS-SPRKADV-002    The oracle is designed to work with source oracles that have 8 decimals. An additional check has been added  to  the  constructor  to  enforce  this  8-decimal  precision  in  the  source  oracle,  preventing  possible misconfiguration and resulting decimal mismatch.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Gas Optimizations", "body": "  1. The  vars.totalDebt  =  params.totalStableDebt  +  params.totalVariableDebt;  computation can ignore the total stable debt, as it should always be 0.  CS-SPRKADV-001    totalDebt has been removed and instead params.totalVariableDebt is now used directly.  MakerDAO - SparkLend Advanced -   11  CriticalHighCodeCorrectedMediumLowCorrectnessHighVersion1CodeCorrectedInformationalVersion1CodeCorrected              \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   ETH Oracle Is Used for LST Pricing", "body": "  Users should be aware that the oracles for rETH and wstETH will not handle depeg scenarios by design.  More  specifically,  the  wstETH  oracle  and  the  rETH  oracle  both  use  the  ETH/USD  price  feed  for estimating  the  value  of  the  tokens.  However,  the  LSTs  could  depeg  so  that  the  market  may  offer  the LSTs at a discount (e.g. due to long waiting times for withdrawals).  Consequently, pricing the LSTs with a ETH/USD oracle may introduce a systematic risk. For example, some users may not be liquidated which could lead to protocol losses.  While  severe  depegs  are  rather  unlikely,  they  may  happen  under  extreme  conditions.  Ultimately,  the ETH/USD oracle could lead to inaccuracies.  MakerDAO - SparkLend Advanced -   12  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   weETH Oracle Manipulation", "body": "  The weETH oracle can be manipulated upwards by burning eETH. Ultimately, such manipulations may lead to draining the protocol.  Consider that EtherFi will compute the weETH/eETH rate as  CS-SPRKADV-001  function amountForShare(uint256 _share) public view returns (uint256) {     uint256 totalShares = eETH.totalShares();     if (totalShares == 0) {         return 0;     }     return (_share * getTotalPooledEther()) / totalShares; }  where  _share  is  10**18.  Note  that  totalShares()  can  be  reduced  by  arbitrary  users  by  burning eETH:  function burnShares(address _user, uint256 _share) external {     require(msg.sender == address(liquidityPool) || msg.sender == _user, \"Incorrect Caller\");     ...     totalShares -= _share;     ...  Consequently, the rate can be increased by decreasing the total shares.  Consider now a scenario where a user borrows 1M USD worth in weETH with 1.5M USD worth in ETH collateral. If the borrower managed to increase the rate by a factor of 2, his position would immediately become unhealthy. Ultimately, that would generate bad debt for Spark.  Note that such an attack requires a donation to EtherFi and could be made more profitable by leveraging high-value positions, especially those that are highly leveraged.  MakerDAO - SparkLend Advanced -   11  SecurityCorrectnessCriticalHighRiskAcceptedMediumLowSecurityHighVersion1RiskAccepted          \fRisk Accepted:  Spark  acknowledged  the  issue  but  deems  it  no  practical  risk  given  the  LTV  parameters  for  weETH Collateral on Sparklend Mainnet and borrowing being disabled. The oracle may be replaced in the future if deemed necessary for higher LTV configurations.  The intended configuration on Github.  MakerDAO - SparkLend Advanced -   12    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Decimals Mismatch in CappedOracle   -Severity Findings  -Severity Findings  0  1  0  0  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Decimals Mismatch in CappedOracle", "body": "  The  function  CappedOracle.decimals  returns  8  regardless  of  the  decimals  of  the  source,  that  is expected to be a Chainlink price oracle. This creates a decimals mismatch when the source is an ETH for  stETH/ETH  has  18  decimals pair.  For  example,  (https://etherscan.io/address/0x86392dc19c0b719886221c78ab11eb8cf5c52812#readContract#F3).  If the  price  of  an  ETH  pair  is  computed  with  the  decimals  of  the  CappedOracle,  the  price  will  be  either heavily  over-evaluated  if  maxPrice  has  18  decimals,  or  always  capped  to  maxPrice  if  it  has  8 decimals.  the  Chainlink  price  oracle   CS-SPRKADV-004    The oracle is designed to work with source oracles that have 8 decimals. An additional check has been added  to  the  constructor  to  enforce  this  8-decimal  precision  in  the  source  oracle,  preventing  possible misconfiguration and resulting decimal mismatch.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Gas Optimizations", "body": "  1. The  vars.totalDebt  =  params.totalStableDebt  +  params.totalVariableDebt;  computation can ignore the total stable debt, as it should always be 0.  CS-SPRKADV-003    totalDebt has been removed and instead params.totalVariableDebt is now used directly.  MakerDAO - SparkLend Advanced -   13  CriticalHighCodeCorrectedMediumLowCorrectnessHighVersion5CodeCorrectedInformationalVersion1CodeCorrected              \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Inconsistent setSource() Event Emission", "body": "  setSource()  emits  the  SourceChanged  event  before  performing  the  state  change  which  is inconsistent  with  the  constructor's  behavior  where  the  state  change  occurs  first.  Additionally, setSource()  emits  the  event  even  when  setting  the  source  to  its  current  address,  which  can  be confusing due to the event's name SourceChanged.  CS-SPRKADV-002  MakerDAO - SparkLend Advanced -   14  InformationalVersion5  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   ETH Oracle Is Used for LST Pricing", "body": "  Users should be aware that the oracles for LSTs (e.g. rETH and wstETH) and LRTs (e.g. weETH) will not handle depeg scenarios by design.  More  specifically,  the  oracles  use  the  ETH/USD  price  feed  for  estimating  the  value  of  the  tokens. However, the LSTs could depeg so that the market may offer the LSTs/LRTs at a discount (e.g. due to long waiting times for withdrawals).  Consequently, pricing the LSTs and LRTs with a ETH/USD oracle may introduce a systematic risk. For example, some users may not be liquidated which could lead to protocol losses.  While  severe  depegs  are  rather  unlikely,  they  may  happen  under  extreme  conditions.  Ultimately,  the ETH/USD oracle could lead to inaccuracies.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Morpho Upgradeable Oracle", "body": "  MorphoUpgradeableOracle  follows  the  assumptions  made  on  Chainlink  oracles  in  Morpho  (e.g.  no staleness).  Essentially,  no  checks  on  the  data  provided  by  Chainlink  are  made  which  may  introduce some  risk  to  the  managed  markets.  Governance  is  expected  to  be  able  to  react  quickly  on  Morpho markets.  Further,  the  only  meaningful  data  returned  by  latestRoundData  is  the  answer.  All  other  values  are not meaningful (zero values).  MakerDAO - SparkLend Advanced -   15  NoteVersion1NoteVersion5      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Missing Checks", "body": "  0  0  0  1  1  AllocatorInit.initIlk() does not check whether the uniV3Factory address is correctly set in the DepositorUniV3 contract. While the deployer can not use a different, random contract instead of the correct Uniswap factory contract, they can still deploy another factory with the same bytecode. This way, _getPool() can still correctly determine pool addresses. The deployer is now able to set themself as the owner of the factory which in turn allows them to set and collect the protocol fee.  Also, AllocatorInit.initIlk() does not check whether nstJoin in AllocatorVault has been set correctly. This is documented to be added later-on but currently not implemented.  CS-ALD-001    The correct uniV3Factory address in DepositorUniV3 is now checked in the initialization script.  Note that a check for nstJoin in AllocatorVault is still to be added when NstJoin has been added to the chainlog.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Dynamic Debt Ceiling Missing", "body": "  The specification for the Allocator system states that:  The  Allocator  Vaults  have  dynamic  Debt  Ceiling  modification  modules  (IAMs)  that  are  set  to  a medium \u201cttl\u201d and medium \u201cgap\u201d value resulting in a throttling effect on the amount of NewStable that can be generated at once. The IAM acts as a circuit breaker in case of technical problems with the AllocatorDAOs Deployment Layer, limiting the potential for damage.  AllocatorInit, however, only sets a static debt ceiling and never deploys the required modules.  CS-ALD-002  MakerDAO - Allocator -   11  CriticalHighMediumLowCodeCorrectedCodeCorrectedCorrectnessLowVersion1CodeCorrectedInformationalVersion1CodeCorrected              \f  The debt ceiling is now set to a gap value in the vat. Additionally, the DssAutoLine contract is setup for the new ilk by calling the setIlk() function with the given gap along with a ttl and a maximum debt  ceiling.  Calling  DssAutoLine.exec()  increases  the  line  of  the  ilk  by  gap  in  steps  of  ttl seconds.  MakerDAO - Allocator -   12  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Deployment Verification", "body": "  Since deployment of the contracts is not performed by the governance directly, special care has to be taken  that  all  contracts  have  been  deployed  correctly.  While  some  variables  can  be  checked  upon initialization through the PauseProxy, some things have to be checked beforehand.  We therefore assume that all mappings in the deployed contracts are checked for any unwanted entries (by  verifying  the  bytecode  of  the  contract  and  then  looking  at  the  emitted  events).  This  is  especially crucial for wards mappings, and for Approve events emitted in the AllocatorBuffer.  MakerDAO - Allocator -   13  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Loosely Restricted Account Type", "body": "  In  contract  evm  facts  registry,  function  get_account_field  and  get_account  accepts  an  input account (Ethereum address) as a felt252. As an Ethereum address is only 160-bit long, it is loosely restricted. Though the internal get_account() will eventually revert upon casting u256 into u64 if the input's upper 96 bits are not zeros.  CS-HRDS-001  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Floating Pragma and Dependency", "body": "  For the L1 Solidity contracts, the pragma is floating and no compiler version has been fixed.  Similarly  the  cairo_lib  dependency  is  not  fixed  in  Scarb.toml,  instead  the  most  recent  version  of master is used.  Contracts  should  be  deployed  using  dependencies  and  compiler  version  they  have  been  thoroughly tested with.  CS-HRDS-002  Code partially corrected:  The Solidity compiler version has been fixed to version 0.8.21. However, the cairo_lib dependency is still floating, now tracking the branch audit.  Herodotus - Herodotus on Starknet -   13  SecurityDesignCorrectnessCriticalHighMediumLowCodePartiallyCorrectedDesignLowVersion1DesignLowVersion1CodePartiallyCorrected                   \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Wrong Values for Non-Existing Accounts    Broken CairoLib Dependency    Empty/inexistent Storage Slots Can Not Be Proven    MMR: Verify Against an Intermediate Node Is Possible   -Severity Findings  Incorrect Expected Block Computation    Remapper Last_Timestamp Can Be Reset to 0    Unchecked Slot Length   -Severity Findings   End Block May Underflow if the Start Block Is 0    Missing OwnershipRenounced Event by Transferring to Zero Address   Informational Findings   Option<T> but Only Actual Element Supported    Unnecessary Retrieval of Header Store    Duplicated Peaks of Proof_Element    Unused FormatWords64 Library    Unused ProofElement.last_pos    Close to Ressource Limit in Starknet   0  4  3  2  6  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Wrong Values for Non-Existing Accounts", "body": "  Version  5  added  support  to  prove  non-inclusion  of  accounts  in  the  state  trie,  which  means  there  is  no valid path in the world state trie that matches the input key (keccak of account address). For accounts not present in the given world state trie, the following default values are returned:  CS-HRDS-006  const EMPTY_STORAGE_HASH: u256 =     0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421; const EMPTY_CODE_HASH: u256 =     0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;  Herodotus - Herodotus on Starknet -   14  CriticalHighCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion5CodeCorrected         \fconst EMPTY_BALANCE: u256 = 0x0; const EMPTY_NONCE: u256 = 0x0;  This is incorrect: For non-existing accounts at a given block, all fields are 0x0.  For  existing  accounts  without  code  or  storage  the  fields  are  set  to  EMPTY_CODE_HASH  or EMPTY_STORAGE_HASH respectively.    Code has been corrected to return 0x0 for fields of inexistent accounts.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Broken CairoLib Dependency", "body": "  CS-HRDS-017  The  smart  contracts  are  built  on  Herodotus  CairoLib  and  inherits  the  vulnerabilities  it  has.  Here  we provide a non-exhaustive list:   Keccak Discards Leading Zero Bytes In Last Little Endian Words64:  1. HeaderStore.process_batch()  will  revert  in  case  the  RLP-encoded  header  satisfies  the  condition.  2. EVMFactsRegistry's internal get_account() will compute account hash incorrectly in case the  account satisfies the condition.   MMR: Incorrect Root Update possible, Insufficient Peaks Validation:  1. All the calls to MMR.append() in HeaderStore and TimestampRemappers are subject to this  vulnerability.   Missing Length Validation In MPT Verify:  1. EVMFactsRegistry's get_storage() and internal get_account() may revert on some valid  proofs. And a forged key may succeed in verification.   reverse_endianness_u64() Discards Leading Zeros:  1. TimestampRemappers's  extract_header_block_number_and_timestamp()  may  return incorrect block number and timestamp if their little endian representations have leading zero bytes.  The  Herodotus  CairoLib  has  been  reviewed  in  a  separate  report,  please  refer  to  it  for  details  on  the underlying issues.    All issues have been resolved in the underlying CairoLib code. For details please refer to the separate report.  Herodotus - Herodotus on Starknet -   15  SecurityHighVersion1CodeCorrected          \f6.3   Empty/inexistent Storage Slots Can Not Be Proven  Unused  /  non-existing  storage  slots  of  an  account  default  to  a  value  of  0x0.  These  slots  cannot  be proven successfully as the mpt.verify() fails or starting from   of the code, mpt.verify() returns an empty list which cannot be successfully RLP-decoded.  This e.g. prevents proving zero balance of an ERC20 token.  CS-HRDS-007    Proving  unset  slots  /  slots  with  a  value  of  zero  is  now  possible.  The  change  introduced  in  related  trie. evm_facts_registry.get_storage()  has  been  updated  to  handle  the  case  of  a  successful  non inclusion verification.  to  prove  non-existence  of  a  key   inclusion  proofs  allows   to  non   in  a   Note  that  the  code  doesn't  allow  to  prove  any  storage  slot  for  non-existing  accounts.  Similarly  for accounts  without  storage  - 0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421.  No  storage slots can be proven for these accounts.  the  keccak  of  0x80   the  storage   initialized   root   to   is   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.4   MMR: Verify Against an Intermediate Node Is", "body": " Possible  CS-HRDS-018  From the perspective of mmr.verify_proof(), it cannot distinguish the value verifying against is a leaf or an intermediate node (a Poseidon hash of its two children). Thus theoretically you can verify against any  node  that  is  inside  the  MMR.  Herodotus  on  Starknet  uses  MMRs  in  both  Headers  Store  and Timestamp  Remappers.  It  is  unlikely  to  abuse  the  verification  of  an  intermediate  node  in  the  former, nevertheless, it is feasible in the latter.  In the following we denote a block header as h, Poseidon hash double operation as F and hash many as G, and Poseidon hash of a block header as ph=G(h).  Headers  Store:  the  MMRs  leaves  store  the  Poseidon  hashes  of  RLP-encoded  block  headers (leaf=G(h)). In case one wants to abuse an intermediate node (node=F(ph1, ph2)), it needs to find a fake block header(h3), so that the following equation holds:  F(ph1, ph2) = = G(h3)  Since hash double and hash many starts with different third states in the underlying hades permutation, it is unlikely to find a header (h3) that satisfies the equation above.  Timestamp  Remappers:  the  MMRs  leaves  store  the  block  timestamps  directly  without  hashing.  Upon querying  get_closest_l1_block_number(),  users  need  to  pass  the  MMR  inclusion  proofs  of  mid point leaf nodes against one mapper's MMR during the binary search.  It seems unlikely to replace a leaf node with an intermediate node as the leaf index is fixed with respect to the mid point. However, mmr.verify_proof() reconstructs the peak according to the length of the proofs instead of the tree height reflected by the index. Consequently, one can replace a leaf node (a block timestamp) with an intermediate node (a Poseidon hash) to manipulate the result of binary search.  Herodotus - Herodotus on Starknet -   16  CorrectnessHighVersion1CodeCorrectedVersion5Version5SecurityHighVersion1CodeCorrected              \f  This  has  been  fixed  in  the  underlying  library.  Verification  against  intermediate  nodes  is  no  longer possible.  issue ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.5 MMR Verify Proof: Different Nodes Can Us the Same Index of the CairoLib report.", "body": "  please   details   refer   For   to   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Incorrect Expected Block Computation", "body": "  In contract timestamp remapper's reindex_batch(), the expected_block will be computed based on the start block (start_block) and the element amount (elements_count) of this remapper:  CS-HRDS-009  let mut expected_block = 0; if (mapper.elements_count == 0) {     expected_block = mapper.start_block; } else {     expected_block = mapper.start_block + mapper.elements_count + 1; }  This calculation in the else branch is incorrect. For example, in case the start block number is 0 and the current elements count is 1, the expected next block should be block 1, nevertheless, the else branch will return 2.    The computation of expected_block has been simplified and corrected.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.6   Remapper Last_Timestamp Can Be Reset to 0", "body": "  In  contract  timestamp  remapper's  reindex_batch(),  the  corresponding  mapper.last_timestamp will be set to a local variable last_timestamp, which is 0 at the beginning, and gets updated according to the last element in the input block headers. However, if there is no element in the input batch, one can skip the loop and directly reset the mapper.last_timestamp to 0.  This  can  invalidate  all  the  consecutive  calls  to  get_closest_l1_block_number(),  since  all  valid block  timestamps  are  larger  than  0,  which  will  be  larger  than  mapper.last_timestamp  and  the function will revert.  CS-HRDS-010    The function now reverts if the input is an empty batch, this resolves the issue described above.  Herodotus - Herodotus on Starknet -   17  CorrectnessMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                  \f6.7   Unchecked Slot Length  CS-HRDS-012  In evm facts registry, function prove_storage accepts an input slot, whose name is misleading since what it actually expects is keccak256(slot) as per Ethereum MPT specification (see ref.1 and ref.2). Moreover, users have full control over the input slot_len, which indicates the length of the key in the MPT. This leads to the following consequences:   The legitimate keys of storage slots are keccak256 digest with a 64-nibble (32-byte) fixed length. Thus the slot values should be stored in leaf nodes. However, now a user can get the value stored in a branch node with a key less than 64-nibble long, which should not be a valid use case.  In prove_storage(), the storage value will be retrieved according to the slot_len (only partial of input slot), nevertheless, the whole slot (instead of the first slot_len nibbles) will be stored as the key for the retrieved value.  In summary, this enables the proving of values in branch node and storing values in branch node as slot values. This applies to get_storage() as well.    The input argument slot is now hashed inside the functions before being used as key. This guarantees that the keys length is always fixed to 64 nibbles. The name of the variable is no longer misleading since it now actually represents the slot.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   End Block May Underflow if the Start Block Is", "body": " 0  CS-HRDS-008  In contract headers store, users can append a batch of block hashes (process_batch()) to an MMR via two approaches:  1. First  block  received  from  the  inbox:  submit  a  reference  block  to  query  from  received_blocks.  And the start_block will be set to the reference_block-1  2. First block already included in an MMR: submit an inclusion proof of the first element towards the current  MMR.  In  case  the  reference_block  is  None,  the  start_block  will  be  read  directly from the first header.  The  function  parameters  with  data  for  both  approaches  (reference_block  and  mmmr_index  + mmr_proof) are of type Option<T>, since for normal usage only one of both should be supplied.  In  case  the  reference_block  is  not  None  in  the  second  approach  (passing  mmr_index  with mmr_proof), the start_block (initialized to 0) will not be updated, and the function may revert due to underflow when computing the block_end.    Passing a reference block alongside an MMR proof is now prevented.  Herodotus - Herodotus on Starknet -   18  DesignMediumVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                 \f6.9   Missing OwnershipRenounced Event by Transferring to Zero Address  CS-HRDS-011  inbox  contract,   the  commitments   in In  transfer_ownership().  Thus,  its  ownership  by  either  calling renounce_ownership()  or  transferring  ownership  to  zero  address  (transfer_ownership()). event However,  OwnershipTransferred instead of OwnershipRenounced.  there  the  owner  can   is  no  sanity  checks  of   transfer_ownership()   the  new_owner   renounce   second   option,   emits   only   the   an   in     If  the  ownership  is  transferred  to  the  zero  address  using  transfer_ownership(),  the  event OwnershipRenounced is now emitted instead of the event OwnershipTransferred.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.10   Close to Ressource Limit in Starknet", "body": "  As of October 2023 with Starknet v0.12.2 the current step limit per transaction is 3 million, and gas limit is 3 million per block.  The complexity of executing prove_account() and prove_storage() depend on the position of the account and the storage slot in the state trie. For most accounts and slots this is feasible to execute with less than 2.5 million steps.  It is anticipated that the step limit and gas efficiency in starknet will be increased in the near future.  CS-HRDS-020    The code was optimized significantly:   The  RLP  decoder  now  implements  rlp_decode_list_lazy  which  allows  to  decode  only  the  required elements.   The eth_mpt() implementation now makes use of lazyBranch helpers: Instead of having to load all elements within a branch node entirely, it only loads the designated element of a branch node.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.11   Duplicated Peaks of Proof_Element", "body": "  In mmr_binary_search() of Timestamp Remappers, each proof to be verified against a mid point has a  peaks  field  in  proof_element.  Given  the  fact  that  the  MMR  will  not  be  modified  during  the  binary search, it is redundant to duplicate the peaks within every proof element.  CS-HRDS-015    Herodotus - Herodotus on Starknet -   19  DesignLowVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                  \fHerodotus has removed the peaks entry from the individual proof element and only submit it once in the input.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.12   Option<T> but Only Actual Element", "body": " Supported  CS-HRDS-013  Struct  BinarySearchTree  of  field  left_neighbor  as Option<ProofElement>.  The  implementation  doesn't  support  an  option  of  this  element  /  None  and only works if there is a ProofElement.  remapper  defines   timestamp   the     Code  has  been  updated  to  only  verify  the  left_neighbor  in  case  it  has  not  been  verified  within  the binary search.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.13   Unnecessary Retrieval of Header Store", "body": "  In  the  Timestamp  Remappers  mmr_binary_search  function,  the  address  of  the  headers  store  is retrieved:  CS-HRDS-014  // Retrieve the header store address let headers_store_addr = self.headers_store.read();  The headers store however is not used in this function. The validity of the data in the MMR is verified in reindex_batch() when new elements are added. When doing the binary search in the MMR it is only ensured that the elements are indeed part of the MMR.    This has been removed from the code.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.14   Unused FormatWords64 Library", "body": "  FormatWords64 is implemented and imported in L1MessagesSender, whereas it is never used.  CS-HRDS-016    FormatWord64 has been removed from the codebase.  Herodotus - Herodotus on Starknet -   20  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                    \f6.15   Unused ProofElement.last_pos  Struct ProofElement of the timestamp remapper defines a field last_pos which is never used.  CS-HRDS-019    The unused element has been removed from the struct.  Herodotus - Herodotus on Starknet -   21  InformationalVersion1CodeCorrected    \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Front-running Process Batch, Verify Mmr,", "body": " Reindex Batch  CS-HRDS-003  If front-running is feasible (consider decentralized sequencers in the future), this could be leveraged to revert certain transactions:   Header_store.process_batch():  if  an  MMR  inclusion  proof  is  submitted,  it  will  be  verified against  the  current  MMR.  A  call  to  process_batch()  can  be  front-run  by  another  call  to process_batch() to update the peaks and revert the former call.   verify_mmr_inclusion(): a call to this function can be front-run by another call to update the  MMR and thus invalidate the previous proofs.   timestamp_remappers.reindex_batch():  a  call  to  reindex_batch  can  be  front-run  by  a  another call to it, which invalidates the previous call.  public   functions   and For  create_branch_single_element())  callers  now  additionally  supply  last_pos  in  addition  to  the mmr_id.  This  allows  to  verify  the  supplied  proof  against  the  historic  mmr  successfully  even  in  case  a preceding transaction updated the specific mmr.  (create_branch_from()   existing  mmr's   branching   from   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Merge128 Discards Higher 128 Bits of Upper", "body": " Input  merge128() accepts two uint256 inputs (lower and upper) and merges them into one uint256. It is expected that both inputs only use the lower 128 bits of u256. It checks the lower does not exceeds max(uint128),  whereas  the  upper  is  not  checked  and  its  higher  128  bits  will  be  discarded  if  they contain non zero bits.  CS-HRDS-004  Herodotus is aware and states this is not applicable to their codebase.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Unrestricted Aggregator ID and MMR Size", "body": "  CS-HRDS-005  Herodotus - Herodotus on Starknet -   22  InformationalVersion1InformationalVersion1InformationalVersion1          \fIn  L1MessagesSender,  the  aggregator  id  and  MMR  size  are  represented  as  uint256.  They  are  not checked and directly used as fields in the L1 -> L2 message payload. As a result, they may exceed the maximum usize, which is the expected type of inputs in Commitments Inbox.  Besides,  in  Starknet  the  basic  data  type  is  felt252.  As  the  aggregator  id  and  MMR  size  are  not restricted to fit in a felt252, in case they exceed max(felt252), the message will be stuck and never consumed on L2.  Herodotus - Herodotus on Starknet -   23  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   EIP-161", "body": "  In the early days of Ethereum, empty accounts could remain in the state trie. Empty in this context means the account has a nonce of zero, zero balance and no code but might have some storage entries.  EIP-161 introduced in the Spurious Dragon hardfork at Block 2'675'000 on mainnet prevents new empty accounts  and  enables  removal  of  existing  empty  accounts  out  of  the  state  trie  if  a  transaction  touches them.  Since these empty accounts are valid accounts of the state trie, these accounts and their storage can be proven with Herodotus.  As per block 14049881 all empty accounts are supposed to have been removed from the state trie.  For more information please refer to the EIP: https://eips.ethereum.org/EIPS/eip-161  This  https://eips.ethereum.org/EIPS/eip-4747  stagnant   EIP   contains  more   examples   and   lists   affected   addresses:  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Ethereum Block Header May Be Subject to", "body": " Future Updates  The fields included in an Ethereum block header may change in future upgrades. It is expected that new fields  will  only  be  appended  to  the  current  block  header,  which  shall  not  break  the  compatibility  with Herodotus.  upgrade: from  https://eips.ethereum.org/EIPS/eip-4895#new-field-in-the-execution-payload-header-withdrawals-root. Other  changes  of  the  block  header  (which  are  unlikely  and  not  expected  to  happen)  would  break Herodotus.  Shanghai   example   See   last   the   an   ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.3   None Block Header Exists in MMR", "body": "  In  the  constructor  of  header  store,  the  MMR  with  id  0  is  initialized  with  the  hash  of  an  initial  element \"brave new world\", which is not a legitimate block hash. This MMR can also be forked to another MMR with  a  different  integrate  with verify_mmr_inclusion()  or  verify_historical_mmr_inclusion()  should  execute  caution and enforce the target it verifies against is a legitimate block hash.  id  via  create_branch_from().  All  external  systems   that   Herodotus - Herodotus on Starknet -   24  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.1   Admin Set Too Early in ", "body": " LiquidityGaugeV4Strat  The  admin  is  transferred  via  a  commit-accept  scheme  in  LiquidityGaugeV4Strat.  However,  the scheme is bypassed by directly setting the new admin in commit_transfer_ownership:  @external def commit_transfer_ownership(addr: address):     \"\"\"  StakeDAO - LiquidLockers -   10  DesignCorrectnessCriticalHighMediumAcknowledgedAcknowledgedLowAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedCorrectnessMediumVersion1Acknowledged           \f    @notice Transfer ownership of Gauge to `addr`     @param addr Address to have ownership transferred to     \"\"\"     assert msg.sender == self.admin  # dev: admin only     assert addr != ZERO_ADDRESS  # dev: future admin cannot be the 0 address      self.future_admin = addr     self.admin = addr     log CommitOwnership(addr)  While this doesn't compromise the security of the contract, it causes the emitted event to be incorrect and is misleading to users who don't believe an immediate transfer of ownership is possible. Furthermore, the function accept_transfer_ownership is made redundant if this behavior is intended.  Acknowledged  StakeDAO  acknowledges  the  issue  and  noted  that  they  had  to  implement  this  function  for  the  factory contract so that it can transfer the admin of the contract in one transaction.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.2   Zero Address Reward Distributor", "body": "  The add_reward functions in all gauge contracts do not check that the _distributor address is not the  zero  address.  This  is  problematic  as  set_reward_distributor  asserts  that  the  distributor address  is  not  zero.  Therefore,  if  add_reward  is  called  with  the  zero  address  as  the  _distributor parameter, a reward distributor can never be set for this reward token entry.  Acknowledged  StakeDAO  acknowledges  the  issue  without  changes  as  they  rate  the  chances  as  very  low  that  the described issue happens. They state the issue only occurs when they add a reward distributor manually to the LiquidityGaugeV4.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.3   Functions Marked public Should Be", "body": " external  The following functions are public but not called from within the corresponding contract. Hence, they should be marked external.   AngleStrategy.deposit   AngleStrategy.withdraw   AngleVault.init   AngleVault.deposit   AngleVaultGUni.deposit   BalancerVault.init  StakeDAO - LiquidLockers -   11  CorrectnessMediumVersion1AcknowledgedDesignLowVersion1Acknowledged                \f BalancerVault.deposit   BalancerVault.provideLiquidityAndDeposit   BalancerVault.withdraw   CurveVault.init   CurveVault.deposit  Acknowledged  Client acknowledges the issue without changing the code.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.4   Inconsistent Limits on Fees", "body": "  The  constraints  for  which  fees  can  be  set  is  inconsistent  between  strategies.  For  example,  the AngleStrategy  contract  allows  each  individual  fee  to  be  as  high  as  BASE_FEE,  whereas  the BalancerStrategy contract only allows the sum of all fees for a gauge to be as high as BASE_FEE.  Acknowledged  StakeDAO is aware of the issue and acknowledges it.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.5   MANAGEFEE Enum Defined Multiple Times", "body": "  The  MANAGEFEE  enum  is  defined  once  in  each  Strategy  contract.  It  would  be  simpler  and  less error-prone to instead define it in the shared interface instead.  Acknowledged  StakeDAO is aware of the issues and acknowledges it. They might change it in future releases.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.6   Misleading Governance Addresses", "body": "  A Strategy contracts calls its respective Locker contract in its deposit, withdraw and claim functions. It  specifically  calls  the  Locker's  execute  function,  which  has  the  onlyGovernance  modifier.  Any reasonable user would assume that onlyGovernance modifier means that the execute function could only be called by the governance contract. However, the Locker's governance address is instead set to the Strategy contract's address in order to allow this functionality.  Acknowledged:  StakeDAO - LiquidLockers -   12  DesignLowVersion1AcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                        \fAccording  to  StakeDAO,  this  is  related  to  their  flow.  There  are  many  layers  of  governance.  The governance address of the Locker contract is the Strategy contract. The governance of the Strategy is the  voter  contract,  which  is  a  helper  contract  to  facilitate  on-chain  voting  and  admin  functionality.  The voter contract is owned by a multisig.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.7   Missing Check if withdrawFee Is Zero", "body": "  In  the  Angle  vault  contract's  withdraw  function  a  transfer  to  the  governance  contract  is  done  to  send potential fees. The transfer is also done if the fees are actually zero.  Acknowledged:  StakeDAO acknowledges this issue as it is only present in the AngleVault contract and has been fixed for other vault implementations.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.8   Missing Events", "body": "  Multiple  functions  perform  important  state  changes  without  emitting  an  event.  For  example,  the  setter functions in the vault and strategy contracts.  Acknowledged:  StakeDAO does not see the necessity to emit these events and acknowledges the issue.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.9   Missing Sanity Checks", "body": "  There are multiple setter functions missing the address zero sanity check.   toggleVault and all setter functions in AngleStrategy except for setVaultGaugeFactory   Multiple setter functions in the different vault contracts  Additionally, withdraw and deposit in LiquidityGaugeV4Strat can be called with _addr = 0.  There are no limits imposed when setting the keeperFee and withdrawalFee for a vault. This allows setting an arbitrarily high fee, even above 1.  Acknowledged  StakeDAO states that they do the checks on their side.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.10   NatSpec Missing", "body": "  StakeDAO - LiquidLockers -   13  DesignLowVersion1AcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                                \fMany contracts are missing NatSpec. Some only have partial or incomplete NatSpec.  Acknowledged:  StakeDAO is implementing NatSpec documentation in newer deployments.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.11   Non-indexed Events", "body": "  The  events  in  the  following  contracts  signal  important  state  updates  which  include  addresses.  The corresponding address is part of the event but not indexed.  In liquidityGaugeV4Strat:   UpdateLiquidityLimit   CommitOwnership   ApplyOwnership  All Events in AngleVault, AngleVaultGUni, BalancerVault, CurveVault and BaseStrategy.  Acknowledged:  As indexed events cost more gas, StakeDAO decided not to add them but handle fetching and filtering events on their side.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.12   State Variable Could Be Immutable", "body": "  The state variable token in the AngleVaultGUni contract could be made immutable to save gas.  Acknowledged:  StakeDAO will take this gas optimization into consideration in future implementations.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.13   Superfluous Variable Assignment", "body": "  The  BalancerVault  contract  writes  assets[i]  =  address(tokens[i])  in  a  loop.  This  variable assignment seems superfluous.  Acknowledged:  StakeDAO  has  decided  to  acknowledge  this  unnecessary  gas  consumption  as  it  does  not  have  any impacts on security.  StakeDAO - LiquidLockers -   14  DesignLowVersion1AcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                          \f5.14   Unnecessary External Call to approve  In  AngleVault.deposit,  BalancerVault.setLiquidityGauge  and  CurveVault.deposit  the corresponding contract's approve function is called with an external call when an internal call could have been performed.  Acknowledged:  StakeDAO  will  consider  changing  this  unnecessary  external  call  to  a  function  call  in  future implementations.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.15   Unused Imports", "body": "  Some contracts import code that is not used in the contract. E.g., AddressUpgradeable is imported in AngleVault  and  used  in  the  using  statement  without  ever  using  functionality  from  the  library. Removing all unused imports and library contracts enhances the code quality and readability.  Acknowledged:  StakeDAO acknowledged the issue.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "5.16   Wrong Event Emitted", "body": "  The Transfer event emitted at the end of the withdraw function in the LiquidityGaugeV4Strat contract has incorrect parameters. It emits msg.sender as the _from address instead of _addr.  Acknowledged:  StakeDAO acknowledges the issue. To track the correct event, they would track the vault's withdraw event.  StakeDAO - LiquidLockers -   15  DesignLowVersion1AcknowledgedDesignLowVersion1AcknowledgedCorrectnessLowVersion1Acknowledged                      \f6   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Inconsistent Withdraw Fees", "body": "  When withdrawing from a Vault it matters if the vault currently has accumulated a token balance due to deposits being made without using the earn option. If the withdrawn amount is smaller than the balance, the users end up in a race condition to save the withdraw fees.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Known Issues Before the Audit", "body": "  The following two issues were known before the audit:  In AngleVault:  > withdrawAll() wrongly defined. Since that every LP obtained will be staked directly into the related LGV4, for this reason the msg.sender's balance would be always 0.  In CurveStrategy:  > An edge case can happen within the harvest() for certain type of curve gauges, with more than one extra reward.  StakeDAO - LiquidLockers -   16  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Unnecessary Additional Transfers", "body": "  In  functions  exitGem,  wipeAndFreeGem,  wipeAllAndFreeGem  of  the  DssProxyActionsCropper  as well  as  in  function  freeGem  of  the  DssProxyActionsEndCropper  the  collateral  is  first  exited  to  the DSProxy  before  being  transferred  onward  to  msg.sender.  The  gems  may  be  exited  to  msg.sender directly.  Acknowledged:  MakerDAO replied:  This is intentional to keep the rewards in the ds-proxy account. This way the ds-proxy owner can choose when to withdraw them. This paradigm of leaving the rewards in the ds-proxy is used for all actions calling join and exit. It was preferred by some of the UI projects integrating with Maker.  MakerDAO - DSS Crop Join -   13  DesignCorrectnessCriticalHighMediumLowAcknowledgedDesignLowVersion3Acknowledged            \f7   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   Documentation Not up to Date    Event Fields Consistency   Incorrect Decimal Annotation    Urn Proxy Load Inefficiency    NewProxy Event Consistency   0  0  0  5  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Documentation Not up to Date", "body": "  README.md describes tack and the auction process:  The winner of a collateral auction claims their collateral via flip.deal  This  describes  the  old  liquidation  process  using  the  Cat.  The  ilks  of  CropJoin  however  will  use liquidations 2.0 with the Dog and a slightly altered auction contract. Flip.deal() is not part of this.  Other  recent  maker  projects  contained  a  \"Risk\"  section  in  their  documentation.  Different  than  the traditional GemJoin adapter which just locks the collateral, CropJoin stakes the collateral into a third party system. This introduces new risks which should be documented appropriately.  Specification changed:  The readme was updated and now describes the liquidation process using the Dog. Risk consideration have not been added.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   Event Fields Consistency", "body": "  1. In CropJoin, the Join and Exit events differ from the system's default ones in the sense that  they do not contain the indexed address field.  2. The  Flee  event  has  no  fields.  Emitting  this  event  will  cost  gas  and  will  not  give  any  useful  information off-chain.  MakerDAO - DSS Crop Join -   14  CriticalHighMediumLowSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                 \f  1. The events now include the addresses of the urn and the user.  2. The Flee event now features following fields: The addresses for the user and the urn, the amount.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.3   Incorrect Decimal Annotation", "body": "  The decimals of bonus and total could differ.  uint256     public share;  // crops per gem    [ray] uint256     public total;  // total gems       [wad] uint256     public stock;  // crop balance     [wad]  Share is calculated and updated in CropJoin.harvest():  function harvest(address from, address to) internal {     if (total > 0) share = add(share, rdiv(crop(), total));     uint256 last = crops[from];     uint256 curr = rmul(stake[from], share);     if (curr > last) require(bonus.transfer(to, curr - last));     stock = bonus.balanceOf(address(this)); }  share is in ray, crop() is decimals of bonus and total is wad. Note that rdiv() multiplies crop() with a ray. The resulting unit for share is bonus decimals * ray, bonus decimals may not be in 18 decimals.  rmul(stake[from],  share);  correctly  calculates  the  amount  in  bonus  token  unit.  The calculations are correct but the unit annotations are not accurate.    The annotations have been updated:  uint256     public share;  // crops per gem    [bonus decimals * ray / wad] uint256     public total;  // total gems       [wad] uint256     public stock;  // crop balance     [bonus decimals]  mapping (address => uint256) public crops; // crops per user  [bonus decimals]  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.4   Urn Proxy Load Inefficiency", "body": "  The flux function of Cropper calls getOrCreateProxy to load the source urn proxy. Here a check similar to the one in move would save gas, firstly by saving a function call, and secondly by reverting the transaction  earlier  in  case  the  urn  does  not  exist.  If  the  source  urn  does  not  exist,  tack  will  revert  on non-zero wad parameter.  MakerDAO - DSS Crop Join -   15  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f  Flux() now loads the source urn proxy directly from the proxy mapping and reverts if no entry exists.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.5   NewProxy Event Consistency", "body": "  The  event  NewProxy,  which  is  triggered  when  a  new  urn  proxy  is  deployed,  is  implemented  in  the Charter  contract  but  not  in  Cropper.  Since  the  two  contracts  are  meant  to  behave  similarly,  the NewProxy event should consistent.    The NewProxy event has been added to the UrnProxy contract in Cropper.sol.  MakerDAO - DSS Crop Join -   16  DesignLowVersion1CodeCorrected        \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.1   UrnProxy With Different ilk", "body": "  It is possible to send gem that do not correspond to any ilk managed by the Cropper to an urn proxy and generate debt from this collateral. Since the urn proxy is managed by the Cropper it is not possible to get this gem out of the urn proxy.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "8.2   Withdraw Value on Flee", "body": "  The internal accounting inside CropJoin is based on shares with 18 decimals:  Upon  join(),  the  amount  of  tokens  brought  is  converted  into  shares  by  expanding  the  value  to  an  18 decimals representation and a division through the net value per share:  The opposite is done during exit().  This amount of shares is used for all accounting purposes, namely to update the gem balance in the VAT, the stake[urn] and the total.  SynthetixJoin.flee() retrieves the value stored in the gem mapping at the VAT. This value is in the unit of shares. This value however is used as the amount of tokens to withdraw from the pool.  function flee(address urn, address usr) public override {     if (live == 1) {         uint256 val = vat.gem(ilk, urn);         if (val > 0) pool.withdraw(val);     }     super.flee(urn, usr); }  The  unit  mismatch  (shares  vs  tokens)  is  not  problematic  for  SynthetixJoin  under  the  condition  that  the gem  token  has  18  decimals.  Due  to  the  asset  valuation  in  SynthetixJoin  (nav())  the  exchange  rate between token and shares is 1:1.  In general, for an arbitrary CropJoin contract this may not hold. It's problematic when the exchange rate is  not  1:1  or  the  token  doesn't  have  18  decimals.  If  too  little  tokens  are  withdrawn  from  the  pool  the amount of tokens available at the Join adapter are insufficient to transfer the required amount to the user and the whole transaction fails blocking withdrawals. The other way, rounded surplus tokens will remain at the CropJoin contract.  MakerDAO - DSS Crop Join -   17  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Encumbered Balances Can Be Transferred", "body": "  transferFrom() allows a user to spend tokens encumbered to them from a given src address and then, if there are still more tokens to be transferred, spend additional allowance of the same src:  CS-COMPSPT-007  uint256 excessAmount = amount - encumberedToTaker;  _releaseEncumbrance(src, msg.sender, encumberedToTaker);  if (availableBalanceOf(src) < excessAmount) revert InsufficientAvailableBalance();  _spendAllowance(src, msg.sender, excessAmount);  In this case, the encumbrance is first released and then the available balance of the src is checked. This is  problematic  because  availableBalanceOf()  relies  on  the  encumberedBalanceOf  variable which  has  just  been  decreased  in  _releaseEncumbrance().  The  result  is  that  if  src  has  given encumbrance  to  more  than  one  address  (and  additional  allowance  to  the  msg.sender  that  is  greater than the available balance of src), the msg.sender is able to spend its allowance on an amount that is encumbered to someone else.  Note: This issue has been disclosed by Compound after the first intermediate report has been released.  Compound - SUPTB -   11  CriticalCodeCorrectedHighCodeCorrectedMediumLowCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessCriticalVersion1CodeCorrected          \f  The availableBalanceOf() check is now performed before the encumbrance of the msg.sender is released. The excessAmount can no longer be higher than the actual available balance.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Permission Can Be Bypassed in ", "body": " transferFrom()  transferFrom() checks the permissions of the src address only when there is nothing encumbered to the msg.sender:  CS-COMPSPT-008  uint256 encumberedToTaker = encumbrances[src][msg.sender]; if (encumberedToTaker == 0 && !permissionList.getPermission(src).isAllowed) {     revert InsufficientPermissions(); }  Users could encumber 1 wei of the token to themselves and would then still be able to transfer all of their balance to another (permissioned) address by approving it first and then using transferFrom(). This is possible because the check above does not make sure that the amount being transferred is less or equal to encumberedToTaker before disabling the permission check.    The  check  has  been  corrected  to  revert  in  case  the  encumbrance  is  insufficient  and  the  transfer permission check failed. As a result, bypassing the permission check with a small non-zero encumbrance is no longer possible.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Unpaused Approve", "body": "  In case the admin pauses the contract, permit() will also be paused so that users cannot update their allowance  by  signatures.  However,  users  can  still  use  approve(),  increaseAllowance(),  and decreaseAllowance()  to  update  the  allowance,  as  these  functions  are  not  overridden  with  the whenNotPaused modifier.  CS-COMPSPT-006    The modifier whenNotPaused has been removed from permit() since users will not be able to transfer in a paused contract anyways.  Compound - SUPTB -   12  CorrectnessHighVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f6.4   Gas Optimizations  The following code parts can be further optimized to improve gas efficiency:  1. In case of using allowance in transferFrom(), the check towards available funds and the call of _spendAllowance() can be conducted before the call to _releaseEncumbrance() to reduce gas waste for reverting transactions.  2. Some  subtractions  can  be  done  in  an  unchecked  scope  in  case  the  order  has  already  been  checked before. For example:  CS-COMPSPT-001  if (amount > encumberedToTaker) {     uint256 excessAmount = amount - encumberedToTaker;     ... }  3. DOMAIN_SEPARATOR  can  be  cached  as  an  immutable  and  only  recomputed  in  runtime  in  case  there is a fork.  4. Since  permissions  are  often  retrieved  for  two  different  addresses  in  one  call,  a  bulk  version  of  PermissionList.getPermission() could be implemented.    The code has been corrected to check available funds first, see the fix to Encumbered balances can be transferred.  The  computation  of  excessAmount  has  been  wrapped  into  an  unchecked  scope  since  the  order  is already checked before.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.5   Incorrect Specs", "body": "  A doc comment of the transfer() function states:  CS-COMPSPT-002  Includes extra functionality to burn tokens if ``dst`` is the contract address  This is not true as burning occurs when dst == address(0).  Furthermore, a doc comment of the function release() states:  Spends all of the encumbrance if ``amount`` is greater than ``owner``'s  This is also not true as the function reverts in that case.  Specifications changed:  The specifications have been changed to reflect the actual function behaviors.  Compound - SUPTB -   13  InformationalVersion1CodeCorrectedInformationalVersion1Speci\ufb01cationChanged            \f6.6   Irregular Naming  The function PermissionList.setPermissionAtIndex() is defined as internal but the function name  does  not  start  with  an  underscore.  This  is  in  contrast  to  other  functions  in  the  contract  such  as _requireAuthorized().  CS-COMPSPT-009    The function has been renamed to _setPermissionAtIndex().  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.7   No Caller in Burn Event", "body": "  The Burn event contains a burner address, while the Mint event contains a minter address. In case of the Mint event, the minter address is set to the address that performs the minting. In the Burn event however, burner is set to the address from which tokens are burned (equivalent to the dst address in the Mint event). The address that performs the burning is not emitted at all.  CS-COMPSPT-003    Burn event has been updated to contain a from address where tokens are burned, and the burner now represents the address that performs the burning.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.8   PausableUpgradeable Is Not Initialized", "body": "  __Pausable_init()  is  not  invoked  in  initialize().  Though  this  is  not  necessarily  required (because the function simply initializes a storage variable to the default value), it might be considered bad practice.  CS-COMPSPT-004    The function initialize() has been updated to explicitly initialize PausableUpgradeable by calling __Pausable_init().  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.9   Unreachable Branch", "body": "  permit() checks the returned boolean flag of isValidSignature() and reverts in case it is false. However, isValidSignature() always returns true in case it does not revert, thus the else branch in permit() can never be reached.  CS-COMPSPT-005  Compound - SUPTB -   14  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                      \f  The unreachable branch has been removed.  Compound - SUPTB -   15  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.1   Encumbrance Can Bypass permissionList and", "body": " Burning  PermissionList can only block transfers of idle (i.e., unencumbered) funds. The admin can also only burn idle funds of a user. If a user encumbers all the funds to itself (any address is possible as takers are not subject to permissions), future un-whitelisting and burning attempts will fail.  The  user  won't  be  able  to  encumber  any  funds  to  another  address  though  (contrary  to  the  issue permission can be bypassed in transferFrom()).  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "7.2   balanceOf() Semantics", "body": "  EIP-7246  changes  the  semantics  of  the  ERC-20  balanceOf()  function.  While  one  would  typically expect  from  an  ERC-20  token  that  the  return  value  of  the  balanceOf()  function  is  the  full  balance  a user is able to spend, this is no longer true for EIP-7246 tokens.  This  might  be  problematic  for  third-party  integrations  that  expect  the  token  to  behave  like  a  regular ERC-20 token.  Compound - SUPTB -   16  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.1   Cached Rate May Be Wrong", "body": "  0  0  3  5  OracleMulti  allows  to  read  rates  from  Chainlink  and  Uniswap  circuits  with  _readAll().  First  the Uniswap rate is computed. However, the Uniswap circuit may not be final, meaning that the last pair (e.g. WETH to USD) requires a Chainlink rate. Next the Chainlink rate is read from the circuit. The rate of the last Chainlink circuit pair is cached, to be used for further computations on the Uniswap rate.  However,  the  constructor  allows  for  the  last  Chainlink  and  Uniswap  pairs  to  be  different.  Thus,  the following scenario is possible:  1. OracleMulti  is  initialized  with  a  Chainlink  circuit  (UNI-WBTC,  WBTC-USD)  and  a  Uniswap  circuit (UNI-WETH). That means that the Uniswap is not final and a Chainlink rate has to be read for the rate WETH-USD.  2. The Chainlink rate is calculated and the WBTC-USD rate is cached.  3. The Uniswap UNI-WETH rate is computed. Inside the branch if (uniFinalCurrency > 0) the calculation  of  the  rate  is  finalized  using  the  cached  WBTC-USD  rate  which  leads  to  an  incorrect result, as the rate for WETH-USD should have been used instead.  Angle - Angle Protocol -   13  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedCodePartiallyCorrectedAcknowledgedCodePartiallyCorrectedLowRiskAcceptedAcknowledgedRiskAcceptedRiskAcceptedRiskAcceptedCorrectnessMediumVersion1RiskAccepted              \fRisk accepted:  Angle will make sure that the Uniswap and Chainlink circuits are compatible. A comment has been made in the code.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.2   Missing Slippage Protection for Users", "body": "  There  is  no  slippage  protection  for  users  interacting  with  the  mint(),  burn(),  deposit()  or withdraw()  functions  of  a  StableMaster  contract  nor  for  actors  interacting  with  certain  functions  of  a PerpetualManager contract which calculate the cash out amount of a perpetual.  A user can get caught unlucky, especially as fees depend on the current state of the system or as the cash out amount of a perpetual depends on the current rate returned by the Oracle. There is a risk of sandwich  attacks  on  user's  transaction:  A  user's  transaction  may  be  sandwiched  between  two  of  the attacker's transaction. The first transaction of the attacker may change the state of a system resulting in an  unfavorable  outcome  of  the  user's  transaction  while  the  attacker  profits  with  his  second  transaction just after the user's transaction.  Code partially corrected:  A slippage protection has been added for stable seekers minting and burning. Slippage protection has been introduced for hedging agents.  Acknowledged:  However,  it  was  concluded  that  not  further  slippage  protection  for  standard  liquidity  providers  is necessary.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}, {"title": "6.3   Problematic Revocation of a Collateral", "body": "  StableMaster  allows  for  revokeCollateral()  to  be  called  by  the  governance.  That  transfers  all  the funds of the pool manager to a settlement contract. Afterwards users can make claims for withdrawing from the settlement contract. However, some user may lose.  This issue attempts to highlight two key points:  (I).  While this function is part of the emergency shutdown process of a stablecoin, this function can also be called on a single collateral only. In both situation following scenario (simplified that no HAs exist) which is mentioned in the documentation may occur:  1. revokeCollateral() gets called on a pool with 1000 WETH. 1 WETH is worth 1000 USD. 100 WETH-SanTokens  are  minted  and  have  value  of  200  WETH.  The  pool  manager  transfers  his balance to the settlement contract.  2. CollateralSettler.triggerSettlement()  is  executed.  The  amount  to  redistribute  is  the  balance of the settlement contract. All the rates are frozen.  3. SLPs claim their collateral. totalLpClaims increases.  4. A day before the claiming period ends, the price of WETH doubles. 1 WETH is worth 2000 USD now  in the current markets.  5. Many users see the bargain and start claiming WETH for their AgUSD.  Angle - Angle Protocol -   14  SecurityMediumVersion1CodePartiallyCorrectedAcknowledgedDesignMediumVersion1CodePartiallyCorrected                  \f6. The  claiming  period  ends.  The  claim  of  stable  holders  is  1000  WETH.  The  claim  by  SLPs  is  200  WETH.  7. The WETH will be distributed only to stable holders. SLPs do not receive anything.  The documentation specifies this behaviour. However, it highly concerning for SLPs and HAs. Anybody with enough capital could take their investments into the protocol.  (II).  Furthermore,  SLPs  and  HAs  could  the funds  revokeCollateral() call. The pools balance could be moved to another pool using a flashloan and an external exchange. Then, the revokeCollateral() call will be executed but close to nothing would be transferred to the settlement contract and SLPs and HAs will not be able to receive their funds.  if  an  attacker  decides   frontrun   lose   to   Code partially corrected:  Different changes have been made:   As  stocksUser  now  tracks  the  amount  of  created  stable  coins  it  can  also  be  used  to  limit  the  claims.   The oracle value is queried at the end of the claim period to reduce issues due to price fluctuation.  Lastly, the front-running issue will be partially mitigated through pausing, but as in comparable systems cannot be entirely avoided.  ", "labels": ["ChainSecurity"], "html_url": "TODO"}]