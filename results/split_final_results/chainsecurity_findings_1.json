[{"title": "6.1   Conversion Errors When Computing", "body": " Underlying Graph Token Value  Each delegation contains two values relevant for the totally managed assets per indexer: the delegated amount denominated in shares and the locked amount denominated in The Graph tokens. To compute the  value  in  The  Graph  tokens  assigned  currently  to  an  indexer  pool,  getDelegationGrtValue() implements the following logic:  (uint256 delegationShares, uint256 tokensLocked, ) = GRAPH_STAKING_CONTRACT.getDelegation(     _indexer,     address(this) ); (, , , , uint256 poolShares, uint256 poolTokens) = GRAPH_STAKING_CONTRACT.delegationPools(     _indexer ); if (delegationShares > 0) {     return delegationShares.mul(poolTokens).div(poolShares).add(tokensLocked); } return tokensLocked;  Note, however, that the view function delegationPools returns the following struct:  struct DelegationPool {     uint32 cooldownBlocks; // Blocks to wait before updating parameters     uint32 indexingRewardCut; // in PPM     uint32 queryFeeCut; // in PPM     uint256 updatedAtBlock; // Block when the pool was last updated     uint256 tokens; // Total tokens as pool reserves  Avantgarde Finance - Sulu Extensions IV -   15  CriticalHighCodeCorrectedMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrected         \f    uint256 shares; // Total shares minted in the pool     mapping(address => Delegation) delegators; // Mapping of delegator => Delegation }  The poolShares return value corresponds to the tokens value in the struct (similar for poolTokens). Hence, the return values are not used correctly when delegationShares > 0 holds since the shares' value in GRT will be computed with the inverse of the actual exchange rate.  The  tests  leave  this  issue  undiscovered  since  for  the  delegation  pool  used  in  the  test  case  tokens equals shares which hides the issue.  Ultimately, getManagedAssets() will incorrectly estimate the position.    The  poolTokens  and  poolShares  values  are  now  delegationPools.  retrieved   in   the  correct  order   from  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-iv/"}, {"title": "6.2   Incorrect Argument Order for lowerHint and", "body": " upperHint  In  LiquityDebtPositionLib.sol,  the  order  in  which  the  lowerHint  and  upperHint  arguments are passed is incorrect in several locations.  This includes private calls (from receiveCallFromVault to the action in question), external calls (from the action to ILiquityBorrowerOperations). Furthermore, there are mix-ups in the tests as well.  Passing the hints in the wrong order generally does not result in the call to Liquity to fail. However, as the hint is unusable, the execution spends more gas to find the right location.  Below  is  a  summary  of  whether  these  function  calls  are  made  with  a  correct  argument  order  for  each action within the smart contract:   __openTrove:   Private call: Incorrect   External call: Incorrect   __addCollateral:   Private call: Correct   External call: Incorrect   __removeCollateral:   Private call: Correct   External call: Incorrect   __borrow:   Private call: Incorrect   External call: Correct   __repayBorrow:  Avantgarde Finance - Sulu Extensions IV -   16  CorrectnessMediumVersion1CodeCorrected        \f Private call: Incorrect   External call: Correct  The  convention  that  Liquity  seems  to  follow  is  to  pass  upperHint  before  lowerHint.  In  Liquity's SortedTroves.sol, a different naming (_prevId and __nextID) is used. Since troves are sorted in descending order, _prevId actually corresponds to upperHint. This is inconsistent with how hints are interpreted/named  in  LiquityDebtPosition.test.ts.  In  some  test  cases  hints  are  in  switched  as well.  One example is the implementation and the test case for repayBorrow: The arguments are switched in the smart contract code and in the corresponding test. Two wrongs make a right and the hints are passed correctly.  When an uneven number of such mistakes are made, the hints are useless and the gas consumption of the call increases.  After  switching  all  the  hints  arguments  in  the  tests,  the  gas  consumption  of  the  above  actions  is  as follows:   __openTrove: Higher (761598 vs. 748240)   __addCollateral: Higher (516155 vs. 417178)   __removeCollateral: Lower (549037 vs. 562395)   __borrow: Lower (1181526 vs. 1194884)   __repayBorrow: Higher (490531 vs. 391554)  Overall, the arguments upperHint and lowerHint should be rechecked and corrected everywhere to ensure useful hints are passed to Liquity and gas used is minimized.    Hints  are  now  always  passed  in  the  same  order,  i.e.,  upperHint,  lowerHint.  The  code  was  also improved to more explicitly identify these two arguments. Furthermore, the tests were updated to use a collateralization  ratio  that  will  avoid  placing  the  trove  at  an  extremity  of  the  sorted  list  to  validate  the correct passing of hints.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-iv/"}, {"title": "6.3   Lending Pools Array Read Twice From", "body": " Storage in getManagedAssets  In  MapleLiquidityPositionLib.getManagedAssets()  the  length  of  the  used  lending  pools  is queried by copying the full array from storage into memory. Next, the for loop iterates over the array and reads  the  elements  from  storage.  Hence,  gas  consumption  could  be  reduced  by  caching  the  array  in memory.    The pools are now cached into memory and no longer read from storage repeatedly.  Avantgarde Finance - Sulu Extensions IV -   17  DesignLowVersion1CodeCorrected          \f6.4   Pool Owner Could Change  To  prevent  the  manipulation  of  a  pool,  reentrancy  is  checked  through  the  withdraw_admin_fees function of the pool owner contract. However, the pool owner address could change and hence such calls on the pool could fail not due to reentrancy but due to access control. The price feed stores the address as  an  immutable  and,  thus,  could  become  unusable  in  the  aforementioned  scenario  of  changing ownerships.    The pool owner address is not immutable anymore. Now, it can be changed by governance.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-iv/"}, {"title": "6.5   LendAndStake Stakes the Full Balance", "body": "  LendAndStake  is  an  action  wrapping  the  lending  and  the  staking  action.  First,  it  lends  an  amount  of liquidity  assets  to  the  Maple  pool.  Next,  it  stakes  LP  tokens  to  the  rewards  contract  to  get  some  extra rewards:  function __lendAndStakeAction(bytes memory _actionArgs) private {     (         address pool,         address rewardsContract,         uint256 liquidityAssetAmount     ) = __decodeLendAndStakeActionArgs(_actionArgs);     __lend(IMaplePool(pool).liquidityAsset(), pool, liquidityAssetAmount);     __stake(rewardsContract, pool, ERC20(pool).balanceOf(address(this))); }  The argument passed to the internal __stake function is the full balance of the pool token. Note that it is also possible to lend the underlying without staking. Consider now the following scenario:  1. 100 tokens are lent into the pool. 100 LP tokens are received.  2. Later, lend and stake is used with 100 underlying tokens.  3. The full balance, namely 200 LP tokens, will be staked.  Such behavior could be unexpected for fund managers.    The code of __lendAndStakeAction() has been changed and now only stakes the amount of tokens received.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-iv/"}, {"title": "6.6   __curveGaugeV2GetRewardsTokensWithCrv", "body": "  Is Unused  Avantgarde Finance - Sulu Extensions IV -   18  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \fThe internal function __curveGaugeV2GetRewardsTokensWithCrv is unused and could be removed to reduce deployment cost.    The function has been removed.  Avantgarde Finance - Sulu Extensions IV -   19  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-iv/"}, {"title": "7.1   Derived Contracts Could By-Pass the", "body": " Invariant on the Sum of Shares  The  TreasurySplitterMixin  is  an  abstract  contract  that  allows  splitting  funds  at  constant  ratios  (which should  sum  up  to  100%)  among  users.  The  only  possibility  to  modify  the  split  ratio  in  a  more  derived contract is through the internal function __setSplitRatio.  function __setSplitRatio(address[] memory _users, uint256[] memory _splitPercentages)     internal {     uint256 totalSplitPercentage;     for (uint256 i; i < _users.length; i++) {         // ... duplicate and non-zero validation         userToSplitPercentage[_users[i]] = _splitPercentages[i];         totalSplitPercentage = totalSplitPercentage.add(_splitPercentages[i]);         emit SplitPercentageSet(_users[i], _splitPercentages[i]);     }     require(totalSplitPercentage == ONE_HUNDRED_PERCENT, \"__setSplitRatio: Split not 100%\"); }  This function is agnostic to the current storage of the contract. Hence, the following scenario could occur:  1. A  more  derived  contract  sets  the  split  ratio  with  __setSplitRatio  to  100%  for  user  A.  Hence,  userToSplitPercentage for A will be 100% while no invariants are violated.  2. In another step, the more derived contract tries to add user B to the sharing mechanism. It passes  only user B and 50% to the function.  3. Now, the userToSplitPercentage is set to 50% for B.  4. The sum of all user split percentages is 150% which violates the invariant.  Hence, the current implementation is only suited for one-time setting of split ratios.  With the current usage, this is not an issue as the shares splitter contract will set the ratio only once upon creation.  However,  future  contracts  inheriting  from  the  TreasurySplitterMixin  could  require  some additional logic to prevent the invariant violations described above.  Avantgarde Finance - Sulu Extensions IV -   20  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-iv/"}, {"title": "6.1   HoprChannels ERC777 Reentrancy", "body": "  An  attacker  can  leverage  the  ERC777  capability  of  the  wxHOPR  token  to  drain  the  funds  of HoprChannels contract.  CS-HPRNMM23-001  Attack vector:  Assume the attacker deploys the following pair of contracts at ALICE and BOB addresses respectively.  contract Bob {      function close() public {         HoprChannels channels = HoprChannels(0x...);  HOPRNet - Node Management Module -   12  CriticalCodeCorrectedCodeCorrectedHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSecurityCriticalVersion1CodeCorrected             \f        channels.closeIncomingChannel(ALICE);      } } contract Alice is IERC777Recipient {      bool once = false;      function tokensReceived(...) public {         if (once) {             return;         }         once = true;         HoprChannels channels = HoprChannels(0x...);         channels.fundChannel(BOB, 1);         Bob(BOB).close();     }      function hack() public {          _ERC1820_REGISTRY.setInterfaceImplementer(address(this),         TOKENS_RECIPIENT_INTERFACE_HASH, address(this));          HoprChannels channels = HoprChannels(0x...);         channels.fundChannel(BOB, 10);         Bob(BOB).close();     }  }  Exploit scenario:  When Alice.hack() is called, the following happens:  1. Alice's contract registers itself as its own ERC777TokensRecipient.  2. Alice funds outgoing channel to Bob with 10 wxHOPR.  3. Bob closes the incoming channel with Alice.  4. During  the  execution  of  closeIncomingChannel()  the  10  wxHOPR  tokens  are  transferred  to  Alice.  5. The tokensReceived() function of Alice is called. During this call:  1. Alice funds outgoing channel to Bob with 1 wxHOPR. Balance of the channel becomes  11 wxHOPR.  2. Bob  closes  the  incoming  channel  with  Alice  and  11  wxHOPR  tokens  are  transferred  to  Alice.  3. This  time  the  tokensReceived()  function  of  Alice  does  nothing.  The  balance  of  the  channel is set to 0.  6. The closeIncomingChannel() that started on step 4. sets the balance of channel to 0.  As  a  result,  attacker  using  10+1  token  can  withdraw  10+11  wxHOPR  tokens  from  the  channel.  The attacker can loop the reentrancy even more time for more profit.  Cause:  HOPRNet - Node Management Module -   13  \fThe  change  of  channel  balance  to  0  happens  after  the  reentrant  call  to  token.transfer()  in  the _closeIncomingChannelInternal()  is effectively violated. Similar violations happen in other functions of the HoprChannels contract:  function.  Thus,  checks-effects-interactions  pattern    _finalizeOutgoingChannelClosureInternal()  sets  the  channel  balance  to  0  after  the  reentrant call to token.transfer().   _redeemTicketInternal() calls indexEvent and emits events after token.tranfer() call in case when the earning channel is closed. This effectively can lead do the wrong order of events in the event log or a different snapshot root.    The  code  has  been  corrected  by  moving  the  token  transfer  to  the  end  of  the  function  in  all  relevant functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.2   Winning Ticker Can Be Redeemed Multiple", "body": " Times  CS-HPRNMM23-002  Assume Alice has outgoing channel to Bob with 1 as ticketIndex. Following scenario is possible:  1. Alice  provides  Bob  4  non-winning  tickets  with  ticketIndex  2,  3,  4,  5  and  a  winning  ticket  with  ticketIndex 6. All of those tickets are non-aggregated and thus their indexOffset is 1.  2. Bob redeems the winning ticket. In the _redeemTicketInternal function, the ticketIndex of the spending channel is updated as: spendingChannel.ticketIndex += indexOffset. The ticketIndex of the spending channel is now 2.  3. Bob  can  redeem  the  ticket  again,  because  the  only  requirement  on  ticketIndex  is  that  it  is  greater than the ticketIndex of the spending channel.  Thus, same winning ticket can be redeemed multiple times. The ticketHash signature from Alice does not prevent this, because it does not contain any nonce or other replay protection mechanism.    The  spendingChannel.ticketIndex = TicketIndex.wrap(baseIndex + baseIndexOffset).  ticketIndex   spending   updated   channel   been   has   the   of   as:  And  been  (baseIndexOffset >= 1) && (baseIndex >= currentIndex).  validity   check   ticket   has   the   of   adjusted   to   require:  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.3   EIP-712 Incompliant Signed Message", "body": "  The  EIP-712  compliant  message  should  start  with  a  two-byte  prefix  \"0x1901\"  followed  by  the domainSeparator and the message hash struct. Whereas two 32-bytes are used in the following cases for  the  prefix  because  of  abi.encode.  Consequently  the  signatures  generated  by  the  mainstream EIP-712 compliant libraries cannot be verified in these smart contracts:  CS-HPRNMM23-003  HOPRNet - Node Management Module -   14  SecurityCriticalVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                \f1. registerSafeWithNodeSig() in NodeSafeRegistry.  2. _getTicketHash() in Channels.    The abi.encodePacked has been used instead of abi.encode to generate the message hash struct.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.4   Incorrect indexEvent Input", "body": "  The channel will call indexEvent() when emitting a new event. In the following case, indexEvent() is incorrectly invoked with an extra channel.balance field compared to the emitted event. As a result, the snapshot will contain an incorrect event.  CS-HPRNMM23-021  indexEvent(abi.encodePacked(ChannelOpened.selector, self, account,     channel.balance)); emit ChannelOpened(self, account);    The redundant field channel.balance has been removed from the indexEvent input.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.5   Dependencies Between Source File Folders", "body": "  CS-HPRNMM23-004  The packages/ethereum/contracts foundry project have following problems   Some of the files in src folder depend on smart contracts from test folder.   Some of the files in src folder depend on smart contracts from script folder.  Such dependencies are considered as bad practice and should be avoided. Potential risks are:   Separation of concerns is not respected. Testing and setup code should not impact production code.   Risk of deploying test code to production is increased.   Maintenance  of  the  project  is  more  difficult.  Changes  in  test  or  script  folders  may  impact  production code.    HOPRNet responded:  The  placement  of  specific  library  files  and  contracts  have  been  reorganized  to  align  with  improved structuring and imports.  HOPRNet - Node Management Module -   15  CorrectnessLowVersion2CodeCorrectedDesignLowVersion1CodeCorrected                  \f6.6   DomainSeparator Is Not Recomputed After a Change of Chain ID  In contracts Channels and NodeSafeRegistry, the domainSeparator is defined as an immutable in the constructor and used in the signature verification. In case there is a fork, the contracts will still verify a signature based on the old domainSeparator, whereas the forked chain is associated with a different chain  ID.  Besides,  the  signature  targeted  to  the  original  chain  can  be  replayed  to  the  forked  chain.  In order to support the potential forked chains and avoid signature replay, the domainSeparator needs to be recomputed based on on-chain chain ID.  CS-HPRNMM23-005    Function updateDomainSeparator has been introduced in contracts Channels and NodeSafeRegistry to update the domainSeparator based on the on-chain chain ID.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.7   HoprNodeSafeRegistry Is Not an", "body": " INodeSafeRegistry  The contract does not inherit from INodeSafeRegistry, which means the compiler will not check that the contract implements all functions correctly.  CS-HPRNMM23-006    The INodeSafeRegistry contract has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.8   HoprNodeStakeFactory Can Clones Any", "body": " Module  The  clone()  function  of  the  HoprNodeStakeFactory  receives  moduleSingletonAddress  as  a parameter. However, no checks are performed to ensure that the address is a valid module. While this is not  immediately  a  problem,  since  it  concerns  only  the  msg.sender  itself.  However,  the  event NewHoprNodeStakeModule does not mention the address of the module. This complicates the process of verifying that the module is indeed a valid module.  CS-HPRNMM23-007    Description of Changes:  HOPRNet - Node Management Module -   16  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \fHOPRNet  has  adjusted  the  NewHoprNodeStakeModule  event  to  include  an  indexed  parameter, improving  event  clarity.  And  events  have  been  separated  from  \"HoprNodeStakeFactory\"  into  an abstract contract named \"HoprNodeStakeFactoryEvents.\"  Said changes allow inspection of the module address, and thus, verification of the module's validity.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.9   IHoprNodeSafeRegistry Is a Contract and Not", "body": " an Interface  The  I  prefix  is  usually  used  for  interfaces,  not  contracts.  IHoprNodeSafeRegistry  lies  inside  of interfaces folder whereas it is actually a contract.  CS-HPRNMM23-008    The INodeSafeRegistry contract has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.10   Incorrect Flag Position Upper Bound", "body": "  CS-HPRNMM23-009  flags   A customized type Target is an alias of uint256, which is used to store a target address associated In  contract with  12  one-byte  util/TargetUtils.sol,  getDefaultCapabilityPermissionAt()  will  return  the  capability permission flag at a certain index: position. However, the upper bound of position is 9 instead of 8. As a  result,  the  function  will  not  revert  upon  reading  the  out-of-bound  9th  permission  flag  and  will  always return 0 due to 256 left shifts.  flags  with  9  capability  permission   (3  general   flags).     The code has been corrected: a proper upper bound of 8 is checked before reading the permission flag.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.11   Incorrect Specifications and Comments", "body": "  CS-HPRNMM23-010  Several incorrect specifications and comments are identified:  1. checkMultisendTransaction()  will  disassemble  the  data  into  individual  transactions  for access  checks.  Each  transaction  consists  of  1  byte  operation,  20  bytes  target  address,  32  bytes value, and the actual transaction data. The inspected actual transaction data locates at an offset of 53 bytes instead of 85 bytes in the comments.  2. The  input  encoded  data  of  decodeFunctionSigsAndPermissions()  encodes  function signature  in  a  right-padded  way  and  permissions  in  a  left-padded  way.  The  index  of  permissions grows from right to left, while the specifications incorrectly state the other direction.  HOPRNet - Node Management Module -   17  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f  Both specifications and comments have been corrected.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.12   Missing Input Checks at tokensReceived", "body": "  Besides funding a channel by fundChannelSafe() or fundChannel(), a node can also directly send tokens to the Channel contract, which triggers the tokensReceived() callback and funds one channel or  a  bidirectional  channel  depending  on  the  userData.  fundChannelSafe()  and  fundChannel() enforce the balance and channel parties validations, nevertheless, tokensReceived() does not. As a result, a node can fund a channel with a balance out of restrictions or with same parties on both sides of a channel.  CS-HPRNMM23-011    Description of Changes:   Moved  validateBalance  and  validateChannelParties  from  external  functions  (fundChannelSafe and fundChannel) to the internal function _fundChannelInternal. This allows tokensReceived to perform checks on balance and channel parties.   Moved  _fundChannelInternal  before  token.transferFrom  in  fundChannelSafe  and  fundChannel  functions  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.13   Signatures Can Be Replayed", "body": "  The  signature  used  in  HoprNodeSafeRegistry.registerSafeWithNodeSig()  doesn't  have  a nonce, so it can be replayed.  Thus, any arbitrary msg.sender can register a node again using the same signature, even if the Safe has deregistered it. Effectively, only the node chain address that used registerSafeByNode() can be deregistered.  In  addition,  for  deregistration  the  node  should  be  a  member  of  a  Safe.  Otherwise,  the  node  cannot deregister itself from the registry.  CS-HPRNMM23-012  The correct deregister way is assumed to be:  1. Deregister at the registry.  2. Remove the node from the Safe NodeManagementModule.  If these actions are not performed in a single transaction, a malicious party can register the node again after step 1 and break this flow.    HOPRNet - Node Management Module -   18  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fA nonce has been added as a parameter in signed data. The nonce of the given chain address will be incremented on each registration.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.14   TargetUtils Incorrect Iterator Bound", "body": "  A customized type Target is an alias of uint256 to store a 20-byte target address associated with 12 one-byte flags (3 general flags and 9 capability permission flags). In contract util/TargetUtils.sol, decodeDefaultPermissions() will retrieve the address and individual flags from the packed target input. When decoding the capability permission flags, the iterator falsely starts from 0 and ends at 8 (176 +  8  *  i,  for  i  in  [0,8]).  As  a  result,  the  last  general  flag  with  the  first  8  capability  permission  flags  are returned as the 9 capability permission flags.  CS-HPRNMM23-013    The starting index has been fixed and is 184 now.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.15   Timestamp Is Not Updated With Snapshot", "body": "  CS-HPRNMM23-014  In an out-of-scope contract Ledger, indexEvent() will update the lastestRoot.rootHash when it is  called,  and  if  a snapshotInterval  has  elapsed.  However,  the  latestRoot.timestamp  is  not  updated  together with  the  latestSnapshotRoot.  Consequently  the  lastestSnapshotRoot  will  be  updated  every time.  the  lastestSnapshotRoot   the  lastestRoot   it  will  also  push   to     The latestRoot.timestamp is updated together with the latestSnapshotRoot.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.16   isNodeSafeRegistered Returns True for", "body": " Unregistered Pairs if safeAddress==0  In  NodeSafeRegistry,  isNodeSafeRegistered()  returns  if  the  input  chainkey  address  is  registered with  the  input  safe  address.  In  case  a  chainkey  is  not  registered  and  the  input  safeAddress  is  0,  this function will return true. This may be unexpected for the external systems.  CS-HPRNMM23-015    If node is not registered to any safe, isNodeSafeRegistered() will return false. Thus, the 0 address of safe will not be considered as a registered safe.  HOPRNet - Node Management Module -   19  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f6.17   ERC777 Reentrancy in fundChannel  fundChannelSafe()  and  fundChannel()  will  call  token.transferFrom()  to  pull  tokens,  which will trigger the callback to the token spender's registered hook. What happens before the transfer is:  CS-HPRNMM23-016  1. Validation of the safe.  2. Validation of the input balance.  3. Validation of the parties addresses.  The only thing that the token spender can do is to register or deregister at the SafeRegistry which tricks the first modifier. For example, assume a node A without registering a safe at the beginning:  1. A first calls fundChannel().  2. In the callback, A calls registerSafeByNode().  As a result, A successfully funds a channel through fundChannel() while it is already registered with a safe.  This  reentrancy  does  not  have  an  explicit  influence  to  the  contracts  though  it  could  break  the assumptions.    The  code  has  been  corrected  to  avoid  reentrancy.  The  token  transfer  is  now  done  at  the  end  of  the function, after all the state changes have been done.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "6.18   Order of Evaluation Can Be Enforced", "body": "  The Solidity documentation states:  https://docs.soliditylang.org/en/latest/ir-breaking-changes.html#semantic-only-changes  For  the  old  code  generator,  the  evaluation  order  of  expressions  is  unspecified.  For  the  new  code generator, we try to evaluate in source order (left to right), but do not guarantee it. This can lead to semantic differences.  CS-HPRNMM23-020  The new code generator is not yet the default. This means that the order of evaluation of expressions is not  guaranteed.  Explicit  brackets  can  be  used  in  e.g. decodeDefaultPermissions()  the  order  of  evaluation   to  enforce   targetPermission = TargetPermission(uint8(Target.unwrap(target) << 176 >> 248));  uint8(Target.unwrap(target) << (184 + 8 * i) >> 248)    HOPRNet has added explicit brackets to enforce the evaluation order.  HOPRNet - Node Management Module -   20  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected            \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "7.1   DomainSeparator Requires Manual", "body": " Recompute After a Fork  updateDomainSeparator()  is  a  public  function  that  recompute  and  update  the  domainSeparator  in case  of  a  fork.  It  requires  manual  invocation  upon  a  fork.  Signatures  on  the  forked  chain  are  still replayable  before  the  call  to  updateDomainSeparator().  In  case  of  supporting  a  forked  chain,  we assume this function will be invoked immediately.  CS-HPRNMM23-017  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "7.2   Users Can Flash Loan by Fund Channel", "body": " Reentrancy  CS-HPRNMM23-018  and   fundChannel()  will   fundChannelSafe()  in _fundChannelInternal() before calling token.transferFrom() to pull wxHOPR tokens. A user can implement and register a token sender callback, which will be invoked before the token transfer. In this callback, it can flashloan any amount of wxHOPR within the current liquidity of the channel contract by  calling  closeIncomingChannel().  At  the  end  of  the  callback,  the  flashloan  will  be  repaid  by  the real transfer of the tokens. Here is an example:  balance   internal   update   the   contract Bob {      function close() public {         // close the channel to get desiredAmount         HoprChannels channels = HoprChannels(0x...);         channels.closeIncomingChannel(ALICE);          // customized logic here     } }  contract Alice is IERC777Sender {      function tokensToSend(...) public {         Bob(BOB).close();     }      function flashloan(uint256 desiredAmount) public {         _ERC1820_REGISTRY.setInterfaceImplementer(address(this),         TOKENS_SENDER_INTERFACE_HASH, address(this));  HOPRNet - Node Management Module -   21  InformationalVersion2InformationalVersion2      \f        HoprChannels channels = HoprChannels(0x...);         channels.fundChannel(BOB, desiredAmount);     } }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "7.3   isContract Check Can Be Bypassed", "body": "  addNodeSafe()  has  a  check  nodeChainKeyAddress.isContract().  However,  if  this  node  is  a contract, and it calls the registry during its construction, the check will fail. Thus, node that is a contract can still be added to the registry.  CS-HPRNMM23-019  HOPRNet - Node Management Module -   22  InformationalVersion2    \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/hoprnet-node-management-module/"}, {"title": "5.1   Reentrancy to Circumvent Liquidation", "body": " Protection  When  a  borrow  is  no  longer  sufficiently  collateralized,  it  can  be  liquidated.  During  a  liquidation,  the function liquidateBorrowAllowed of the Comptroller is called to determine if the position can be liquidated.  This  check  basically  evaluates  whether  the  values  of  all  held  cTokens  times  their collateralRatio exceed the value of all borrowed assets. The function liquidateBorrowAllowed also determines whether the repaid amount does not exceed the closeFactor.  However, the following reentrancy attack is possible to circumvent the liquidation protection. We assume that the victim account V has two borrowed tokens A and B. Also, V has collateral deposits C and D and has just become liquidatable, due to a tiny shortfall. We call the respective cTokens cA, cB, cC, and cD. Lastly, A is contract with a callback, e.g. ERC777.  1. The  attacker  calls  liquidateBorrow  on  cA  with  collateral  cC.  liquidateBorrowAllowed  is evaluated by the comptroller and determines a small shortfall. Hence, the liquidation is allowed.  2. The token transferFrom of A is triggered and hence, the callback to the attacker is executed.  Compound - cToken -   10  SecurityDesignCorrectnessCriticalHighMediumAcknowledgedLowAcknowledgedAcknowledgedAcknowledgedRiskAcceptedAcknowledgedAcknowledgedSecurityMediumVersion1Acknowledged           \f1. As  part  of  the  callback,  the  attacker  calls  liquidateBorrow  on  cB  with  collateral  cD. liquidateBorrowAllowed is evaluated by the comptroller and determines a small shortfall (as no state changes have yet been performed). Hence, the liquidation is allowed.  2. The biggest possible amount of B tokens is repaid and cD tokens are received as reward. The  position of V is now safe again.  3. Despite the position being safe, the original liquidation continues and the biggest possible amount  of A tokens is liquidated to received cC as reward.  Please note that the attack also works against a single collateral, so if C == D. It also works with more than two borrowed tokens. In such cases more \"parallel\" liquidations are possible.  Acknowledged:  Compound has acknowledged the issue.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "5.2   Deprecation Insufficiently Documented", "body": "  The deprecation of a cToken and its effects are insufficiently documented. The documentation says:  A user who has negative account liquidity is subject to liquidation  However,  liquidation  can  also  occur  once  a  cToken  has  been  deprecated.  As  users  aim  to  avoid liquidation, they should be made aware of this.  Acknowledged:  The Compound team has acknowledged this issue.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "5.3   Extra Encoding and Decoding in", "body": " CErc20Delegator  The  CErc20Delegator  contract  will  be  used  as  a  proxy.  Hence,  it  generally  forwards  the  calls. However, it contains two ways of forwarding:  1. The generic forwarder using the fallback function  2. Explicit forwarders such as:  function borrow(uint borrowAmount) override external returns (uint) {     bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrow(uint256)\", borrowAmount));     return abi.decode(data, (uint)); }  The explicit forwarders are less gas efficient as they perform extra decoding and encoding for inputs as well as decoding and encoding for outputs, which is not performed by the generic forwarder.  Acknowledged:  Compound - cToken -   11  CorrectnessLowVersion2AcknowledgedDesignLowVersion1Acknowledged                \fCompound  acknowledges  the  issue  but  claims  that  the  gas  savings  are  small  enough  to  not  be  worth fixing.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "5.4   Extra Storage Operations", "body": "  Inside the function _acceptAdmin there is the following code:  // Store admin with value pendingAdmin admin = pendingAdmin;  // Clear the pending value pendingAdmin = address(0);  emit NewAdmin(oldAdmin, admin); emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);  To emit the events, admin and pendingAdmin will be queried from storage which is unnecessary here. Hence, there is a certain (even though small due to EIP-2929) gas overhead.  Acknowledged:  Compound  acknowledges  the  small  gas  savings  but  deems  the  readability  of  the  code  to  be  more important.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "5.5   No Dynamic Bounds on Liquidation Incentive", "body": "  It  is  important  that  the  liquidation  incentive  is  sufficiently  high  in  order  to  provide  a  safe  protocol. However, the product of liquidation incentive and collateral factor also should not exceed 1. Otherwise, the protocol is sure to lose funds on liquidations.  Risk accepted:  Compound accepts the risk of possibly misconfiguring a protocol.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "5.6   Reentrancy by Admin", "body": "  In  the  case  of  Compound,  the  admin  role  of  the  cTokens  is  held  by  the  governance.  Hence, admin-based  attacks  are  especially  unlikely.  However,  in  principle  the  admin  could  perform  certain reentrancy-based  or _setInterestModel. These functions do not have a reentrancy guard.  like  _setComptroller   functions   attacks   special   admin   using   In a general case, an admin could switch out the comptroller for the initial checks of a liquidation and then call _setComptroller while receiving a token-based callback. The corrected comptroller address would  satisfy  the  further  checks  during  seizing.  This  way  the  admin  of  one  market  could  attack  other markets.  Compound - cToken -   12  DesignLowVersion1AcknowledgedDesignLowVersion1RiskAcceptedSecurityLowVersion1Acknowledged                        \fAcknowledged:  This issue has been acknowledged.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "5.7   Unnecessary Memory Copies", "body": "  In  some  parts  of  the  code  there  are  unnecessary  copy  operations  to  and  from  memory.  Consider  the following example:  function balanceOfUnderlying(address owner) override external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     return mul_ScalarTruncate(exchangeRate, accountTokens[owner]); }  The  exchangeRate  is  stored  in  memory  and  then  directly  afterwards  copied  back  onto  the  stack. However, as the gas overhead of memory operations is tiny, this is minor.  Acknowledged:  Compound  has  acknowledged  the  issue  but  decided  not  to  fix  it  at  this  time,  as  it  is  only  a  small  gas saving.  Compound - cToken -   13  DesignLowVersion1Acknowledged          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings   Anyone Can Disable TUSD Market   -Severity Findings  -Severity Findings  Incorrect Exchange Rates Due to Incorrect Accounting   Incorrect Return Value for mintFresh   -Severity Findings   Liquidation Incentive Has Imprecise Documentation   Ignored Return Values    Special Case Not Clearly Specified    Unclear Specification    Unnecessary Overflow Checks   1  0  2  5  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "6.1   Anyone Can Disable TUSD Market", "body": "  The TrueUSD (TUSD) token has two addresses through which it can be called. Calling the transfer function on either address affects the balance of both addresses. Given that there is a Compound market for TUSD, it is important to note that anyone can disable this market by calling:  function sweepToken(EIP20NonStandardInterface token) override external {     require(address(token) != underlying, \"CErc20::sweepToken: can not sweep underlying token\");     uint256 balance = token.balanceOf(address(this));     token.transfer(admin, balance); }  Usually, this function is meant to collect stray tokens and send them back to the admin. However, in this case  anyone  can  call  this  with  the  second  address  of  TUSD  and  thereby  transfer  all  TUSD  inside  the market to the administrator.  The funds are not lost, as they reside with the administrator, but no more borrows or redemptions will be possible. However, this causes a sudden change in the exchange rate and the interest rate of the token, which are both calculated using the current balance of the contract.  The dropped exchange rate allows different attacks. Among other things, it allows:  liquidation of users who used cTUSD as collateral (if the collateral factor is bigger than 0)   borrowing TUSD, then executing the attack and paying back less TUSD   executing the attack, minting cTUSD, waiting for the exchange rate to be restored and redeeming  cTUSD for more TUSD than were used for minting  Compound - cToken -   14  CriticalCodeCorrectedHighMediumSpeci\ufb01cationChangedSpeci\ufb01cationChangedLowSpeci\ufb01cationChangedCodeCorrectedSpeci\ufb01cationChangedSpeci\ufb01cationChangedCodeCorrectedSecurityCriticalVersion1CodeCorrected            \f  The sweepToken function can now only be called by the admin.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "6.2   Incorrect Exchange Rates Due to Incorrect", "body": " Accounting  Due  to  the  design  of  the  cToken  non-liquidatable  borrows  can  exist.  These  borrows  are  incorrectly accounted  leading  to  overly  high  exchange  rates,  which  can  have  different  consequences.  Please consider  the  following  example.  For  simplicity  of  the  calculation,  we  assume  rates  and  the  liquidation incentive to be zero. We also assume that the exchange rate is 1 cETH = 1 ETH.  1. User A deposits 1 ETH, to obtain 1 cETH. At this time 1 ETH is worth 2000 DAI.  2. User A borrows 1000 DAI.  3. The price of ETH drops a lot until it is 500 DAI. During this time user A is not liquidated (e.g., due to  high gas prices).  4. Now user B liquidates the DAI-borrow of user A.   User B pays 500 DAI.   The amount of seized collateral is computed as 1 cETH.   1 cETH is seized from user A.  5. As a result, user A now has the following status:   0 balance in cETH   500 borrowed DAI  6. Thereby,  user  A  has  a  non-liquidatable  borrow  as  any  liquidation  fails  in  the  following  line  of  seizeInternal due to an underflow:  accountTokens[borrower] = accountTokens[borrower] - seizeTokens;  7. This results in an incorrect exchange rate for cDAI. The 500 DAI borrowed by user A will never be repaid. However, they are still part of the totalBorrows of the accounting within cDAI. Hence, the calculated exchange rate is too large.  The  incorrect  exchange  rate  can  have  different  consequences.  One  example  (assuming  no  reserves) would be:   All borrowers (except for A) are repaying their loans.   All suppliers try to redeem their deposits. However, each supplier is receiving too much DAI for their  cDAI as the exchange rate is too large.  In the end the last supplier finds that there are 0 DAI inside the contract and still 500 DAI borrowed. As the last borrow is non-liquidatable and will never be paid back, the last supplier cannot redeem their cDAI.  Compound - cToken -   15  DesignMediumVersion2Speci\ufb01cationChanged         \fSpecification changed:  The Compound team will update the documentation to correctly reflect this behaviour.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "6.3   Incorrect Return Value for mintFresh", "body": "  The  mintFresh  function  that  is  internally  responsible  of  minting  new  cTokens,  has  the  following specification regarding its return value:  * @return (uint) the actual mint amount.  At the end of the function, it says:  return actualMintAmount;  However, the actualMintAmount variable contains the amount of underlying tokens used for minting and not the amount of minted cTokens.  Specification changed:  The specification was changed to match the implementation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "6.4   Liquidation Incentive Has Imprecise", "body": " Documentation  The documentation for the liquidation incentive says:  The  additional  collateral  given  to  liquidators  as  an  incentive  to  perform  liquidation  of  underwater accounts.  For  example,  if  the  liquidation  incentive  is  1.1,  liquidators  receive  an  extra  10%  of  the borrowers collateral for every unit they close.  this   However,  function liquidateCalculateSeizeTokens will calculate this amount with the liquidation incentive included, but in the function seizeInternal the protocol's share is deducted:  not  match   functionality   code.   does   The   the   the   of   uint protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: protocolSeizeShareMantissa})); uint liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;  Hence, liquidators receive less than 10% extra.  Specification changed:  The Compound team will update the protocol documentation to describe this behaviour more precisely.  Compound - cToken -   16  CorrectnessMediumVersion1Speci\ufb01cationChangedCorrectnessLowVersion2Speci\ufb01cationChanged                  \f6.5   Ignored Return Values  The return values of \"Internal\" functions such as repayBorrowInternal or mintInternal are being ignored  in  all  of  their  calls.  Hence,  it  could  be  checked  if  a  return  value  is  really  necessary  for  these functions and if so, whether it should be checked by the callers.    The unused return values of the relevant functions were removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "6.6   Special Case Not Clearly Specified", "body": "  functions   repayBorrowBehalf, The  repayBorrowBehalfInternal,  repayBorrowFresh,  and  repayBorrowInternal  generally specify the input variable as:  repayBorrow,   concerning   repaying,   such   as   * @param repayAmount The amount to repay  However, this variable has a special meaning if it is -1 as then, the full amount is repaid. This should be documented more clearly in the code.  Specification changed:  The specification was changed for the relevant functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "6.7   Unclear Specification", "body": "  The transferTokens function is specified as follows:  /* ...  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {  However,  as  the  return  value  is  not  boolean  but  uint  it  would  be  beneficial  to  explicitly  state  which values indicate success and failure.  The exitMarket function in the comptroller has a similar specification:  /* ...  * @return Whether or not the account successfully exited the market  */ function exitMarket(address cTokenAddress) override external returns (uint) {  Again, it would be good to specify which return values indicate success and failure.  Compound - cToken -   17  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChangedCorrectnessLowVersion1Speci\ufb01cationChanged                      \fSpecification changed:  The specification was changed to indicate what happens in case of success and failure.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "6.8   Unnecessary Overflow Checks", "body": "  In the doTransferIn function of the CErc20 contract, the new balance is checked to be larger than the balance before the transfer.  require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERF|l|\"); return balanceAfter - balanceBefore;   // underflow already checked above, just subtract  However, this check is now unnecessary because of the updated compiler version, which automatically checks for under- / overflows. Therefore, gas can be saved by omitting this check.  Additionally, in the _addReservesFresh function, there is still an overflow check.  totalReservesNew = totalReserves + actualAddAmount;  /* Revert on overflow */ require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");  Because actualAddAmount is an unsigned integer, this condition can never occur, as any overflow will be caught by the automatic check by the solidity compiler.  Similarly, the _reduceReservesFresh function has an unnecessary check, since the subtraction would revert in case of an underflow.  totalReservesNew = totalReserves - reduceAmount; // We checked reduceAmount <= totalReserves above, so this should never revert. require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");    The unnecessary checks have been removed.  Compound - cToken -   18  DesignLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics serve to clarify or support the report.  As  the  scope  of  this  report  was  limited  to  the  cToken,  we  also  list  issues  outside  of  the  scope  in  this section.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "7.1   Compatibility With Different Tokens", "body": "  In the future, new tokens might be added. When markets for those are created, issues can appear. In this non-exhaustive list, we highlight some of those issues:   On-demand Balance Modification + Callback:  Different  token  types  (inflationary,  deflationary,  or  rebasing)  can  have  balances  which  change without a Transfer occurring. For some of these tokens there is a permissionless trigger to update everyone's balances. Tokens with such a permissionless trigger and a callback on transfer should not be added for the following reason. While receiving the callback of mint() the depositor could trigger  the  balance  adjustment  and  thereby  increase  the  ERC20  balance  of  the  market  without making a deposit.   Blacklist, Freezable, Seizable:  Tokens where some addresses can be blacklisted, certain funds can be frozen or some funds can be seized/burnt, need to be added with great consideration. A blacklisted market would stop working properly.  A  (partially)  frozen  market  would  not  function  correctly  (as  the  underlying  fungibility assumption is violated). Finally, seizing could lead to sudden drops in the exchange rate.   Transfer Fees:  In  principle  the  protocol  supports  tokens  with  transfer  fees.  However,  if  a  user  borrows  a  certain amount  of  tokens  with  transfer  fees,  it  will  be  almost  impossible  to  completely  repay  that  borrow. This is because the existing feature of providing -1 as the amount wouldn't work due to the transfer fees. Hence, a small borrow residue will most likely remain.  When  borrowing  tokens  with  transfer  fees,  the  requested  amount  will  not  be  received.  Similarly, when reducing the reserve of a token with transfer fees, there will be unexpected losses.   Tokens with potential for sudden increase in value:  If  a  token  whose  value  can  suddenly  increase  by  a  significant  amount,  can  be  borrowed,  then attacks  due  to  extremely  bad  positions  are  possible.  Such  tokens  include  UniswapV2  and  Curve pool  tokens,  but  also  DPI  tokens.  Extreme  care  has  to  be  taken,  when  adding  such  tokens  to  the protocol as they will most likely lead to an attack.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "7.2   Hindering Liquidation", "body": "  Borrowers  can  do  different  things  to  make  their  own  liquidation  less  likely.  During  a  liquidation  the liquidator  receives  a  liquidation  reward,  determined  by  the  liquidationIncentiveMantissa variable. If X is the amount of borrowed tokens, the liquidator receives at most:  X * (liquidationIncentiveMantissa - 1) * closeFactorMantissa / 10**36  Example: If the liquidation incentive is 108% and the close factor is 50%, the maximum liquidation reward is 4% * X.  Compound - cToken -   19  NoteVersion1NoteVersion1      \fThe  liquidator  needs  to  pay  the  transaction  costs  which  will  vary  over  time.  At  the  time  of  writing  the transaction  costs  for  a  liquidation  are  around  80  USD.  Hence,  the  liquidation  incentive  only  provides  a sufficient incentive for borrows above 2,000 USD.  As this computation is performed per borrowed token a user might decide to borrow 2,000 USD worth of tokens  from  ten  different  tokens,  hence  borrowing  20,000  USD  but  making  liquidation  by  a  simple liquidator unlikely.  Note that due to partial liquidation, caused by the close factor, such small borrows can also be generated over time.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "7.3   Impossible Event Orders", "body": "  In  case  that  one  of  the  underlying  tokens  has  a  callback  on  token  transfer,  the  doTransferIn  and doTransferOut  functions  can  lead  to  reentrancies.  This  can  lead  to  event  orders  that  would  not  be possible without reentrancies.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "7.4   Incomplete Compatibility Check", "body": "  When adding a new market, the Comptroller checks compatibility using:  cToken.isCToken(); // Sanity check to make sure its really a CToken  However, as isCToken returns true and to be consistent with the isComptroller checks, the return value should also be checked.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "7.5   Misplaced Comment", "body": "  The following comment can be found inside the seizeInternal function:  /* * We calculate the new borrower and liquidator token balances, failing on underflow/overflow: *  borrowerTokensNew = accountTokens[borrower] - seizeTokens *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens */  However,  this  comment  does  not  refer  to  the  code  where  it  is  located  but  to  the  code  further  down. Hence, it could be moved closer to the corresponding code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "7.6   Reentrancy Checks Are Necessary", "body": "  of   part   Forum As  (https://www.comp.xyz/t/punitive-accounting-for-borrow-and-redeem/2247), it was proposed that punitive accounting may allow to remove the reentrancy checks.  the  Compound  Community   published   recently   post   on   a   Compound - cToken -   20  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                \fWith  the  proposed  punitive  accounting  changes,  it  may  now  instead  be  possible  to  remove  the reentrancy  checks  altogether.  To  do  that,  the  community  should  prove  to  itself  that  the  protocol  is now safe to reentrancy attacks altogether. That can be done as an independent later step, after more thorough evaluation.  However, this would open up some reentrancy attacks. For example, the following sequence of actions could drain a CToken contract, assuming a token with a callback on transferFrom:  1. Provide collateral of some sort, then borrow some funds from the CToken.  2. Call  repayBorrow  to  pay  back  your  borrowed  funds.  Your  current  borrow  balance  is  stored  in  accountBorrowsPrev.  3. doTransferIn is called, which triggers the callback of transferFrom. In this callback function,  borrow more funds from the contract. This updates your borrow balance.  4. When   set  accountBorrowsPrev - actualRepayAmount, overwriting the updated borrow balance.  doTransferIn   balance   returns,   borrow   your   is   to  Therefore,  omitting  the  reentrancy  checks  could  lead  to  vulnerabilities  for  tokens  with  callbacks  on transferFrom.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "7.7   Underlying as Immutable Variable", "body": "  The CErc20 contracts have the following storage variable:  address public underlying;  As  it  is  not  expected  to  change,  it  could  become  an  immutable  variable  to  save  gas  costs  during execution.  Note  that  while  this  change  would  reduce  the  execution  costs  of  nearly  every  CErc20 invocation  by  roughly  2200  gas,  it  also  implies  that  the  storage  layout  would  be  modified  which  would require  close  inspection.  Furthermore,  it  would  mean  that  not  all  CErc20  proxies  could  reference  the same implementation contract, as the implementation contracts would contain the specific underlying address.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "7.8   Unused Comptroller Functions", "body": "  The  following  Comptroller  functions  are  no  longer  being  used  by  the  cTokens  and  could  hence  be removed to reduce the code size and thereby the deployment costs:   mintVerify   borrowVerify   repayBorrowVerify   liquidateBorrowVerify   seizeVerify   transferVerify  Compound - cToken -   21  NoteVersion1NoteVersion1          \f7.9   Vote Delegation  Token holders who deposit into a CToken have to be aware that, in the case of governance tokens, they are  also  giving  away  their  voting  rights.  On  tokens  such  as  COMP  or  UNI,  the  governance  can  pick  a delegatee for the voting power which is accumulated inside the CToken contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "7.10   closeFactor Bounds Not Checked", "body": "  The Comptroller contract has a minimum and maximum bound for the value of closeFactor.  // closeFactorMantissa must be strictly greater than this value uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05  // closeFactorMantissa must not exceed this value uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9  However, these bounds are never used. In fact, the closeFactor can be set to anything, as its value is not checked at all before setting it.  /**   * @notice Sets the closeFactor used when liquidating borrows   * @dev Admin function to set closeFactor   * @param newCloseFactorMantissa New close factor, scaled by 1e18   * @return uint 0=success, otherwise a failure   */ function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {     // Check caller is admin     require(msg.sender == admin, \"only admin can set close factor\");      uint oldCloseFactorMantissa = closeFactorMantissa;     closeFactorMantissa = newCloseFactorMantissa;     emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);      return uint(Error.NO_ERROR); }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "7.11   maxAssets Not Enforced", "body": "  According to the documentation, a user should only be able to participate in a limited number of markets, namely no more than maxAssets.  /**  * @notice Max number of assets a single account can participate in (borrow or use as collateral)  */ uint public maxAssets;  Compound - cToken -   22  NoteVersion1NoteVersion1NoteVersion1          \fHowever,  this  is  not  enforced.  In  fact,  the  value  of  maxAssets  is  never  set  or  used.  In  particular,  the function  addToMarketInternal  in  the  Comptroller  blindly  adds  a  user  to  a  new  market  without checking that the user does not exceed this bound.  /**  * @notice Add the market to the borrower's \"assets in\" for liquidity calculations  * @param cToken The market to enter  * @param borrower The address of the account to modify  * @return Success indicator for whether the market was entered  */ function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {     Market storage marketToJoin = markets[address(cToken)];      if (!marketToJoin.isListed) {         // market is not listed, cannot join         return Error.MARKET_NOT_LISTED;     }      if (marketToJoin.accountMembership[borrower] == true) {         // already joined         return Error.NO_ERROR;     }      // survived the gauntlet, add to list     // NOTE: we store these somewhat redundantly as a significant optimization     //  this avoids having to iterate through the list for the most common use cases     //  that is, only when we need to perform liquidity checks     //  and not whenever we want to check if an account is in a particular market     marketToJoin.accountMembership[borrower] = true;     accountAssets[borrower].push(cToken);      emit MarketEntered(cToken, borrower);      return Error.NO_ERROR; }  Compound - cToken -   23  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/compound-ctoken/"}, {"title": "5.1   Inefficient _validate", "body": "  0  0  0  3  _validate  may  be  refactored  to  be  more  efficient.  The  amount  of  external  calls  executed  may  be reduced.  By checking whether a check of the credit line or the peace is even required first, the call to the Vat and the calculation of the tab could be skipped in case it's not needed. The current code however calls the Vat  initially  and  then  calculates  the  tab,  before  determining  whether  a  credit  line  or  peace  check  is needed.  Acknowledged:  Maker acknowledged the issue.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-charter-smart-contracts/"}, {"title": "5.2   Skip Calls When No Additional Debt Is Needed", "body": "  DssProxyActionsCharter.draw() generates the debt required before exiting the DAI amount to the user's wallet:  // Generates debt in the CDP _frob(charter, ilk, 0, _getDrawDart(charter, vat, jug, ilk, wad)); ... // Exits DAI to the user's wallet as a token DaiJoinLike(daiJoin).exit(msg.sender, wad);  MakerDAO - DSS-Charter -   10  DesignCriticalHighMediumLowAcknowledgedAcknowledgedAcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                  \f_getDrawDart() may return 0 if no additional debt is required to exit the specified amount of DAI. The calls  to  CdpManager.frob()  and  Vat.frob()  will  execute  nevertheless  in  this  case,  despite  not being required.  Acknowledged:  Maker acknowledged the issue.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-charter-smart-contracts/"}, {"title": "5.3   getOrCreateProxy() or", "body": " proxy[msg.sender]  The CharterManager implementation has a function getOrCreateProxy() which returns the address of  an  urn  managed  by  the  CharterManager  for  a  user,  or  creates  a  new  urn  if  it  does  not  exist  yet. Although, the Charter Manager features a public mapping proxy which stores the list of urns and their respective  users,  multiple  functions  in  the  DssProxyActionsCharter  use  getOrCreateProxy  function even when not necessary, i.e., there is no need to create a new urn if it does not exist already. Examples of such functions are wipe(), wipeAll(), cashETH(), or cashGem.  Similarly this also applies to CharterManager.quit().  The CharterManager features functions exit and flux. Both operate on the collateral of the user in the Vat. While flux transfers the collateral in the accounting of the Vat to another address, exit exits the collateral to the user.  From  an  users  perspective,  for  the  account  which  is  the  source  of  the  collateral  these  should  behave similarly.  Exit()  however  uses  proxy[msg.sender]  to  load  the  address  of  the  Urnproxy,  while flux() uses getOrCreateProxy(src).  Acknowledged:  Maker acknowledged the issue.  MakerDAO - DSS-Charter -   11  DesignLowVersion1Acknowledged          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   Possible Revert Due to Underflow   -Severity Findings  Inconsistent Retrieval of Ilk Parameter    Possible Optimization on Getting vat Address    Unused Function _toRad()   0  0  1  3  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-charter-smart-contracts/"}, {"title": "6.1   Possible Revert Due to Underflow", "body": "  Should  the  recorded  DAI  balance  of  the  DSProxy  at  the  Vat  exceed  the  amount  required  to  repay  the debt,  the  subtraction  in  DssProxyActionsCharter._getWipeAllWad()  will  underflow  causing  the transaction to revert.    _getWipeAllWad() now returns 0 when enough DAI is available to cover the debt.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-charter-smart-contracts/"}, {"title": "6.2   Inconsistent Retrieval of Ilk Parameter", "body": "  The function cashETH in the DssProxyActionsCharter contract takes as parameters ethJoin and ilk among  others.  However,  in  other  functions,  e.g.,  freeETH(),  wipeAllAndFreeETH(),  etc.  only ethJoin  the  adapter: bytes32 ilk = GemJoinLike(ethJoin).ilk().  is  passed  as  parameter,  while   the  ilk  value   retrieved   from   is     cashEth() and cashGem() now retrieve the ilk from the adapter as the other functions do.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-charter-smart-contracts/"}, {"title": "6.3   Possible Optimization on Getting vat Address", "body": "  MakerDAO - DSS-Charter -   12  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedDesignMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                         \fMultiple functions in the DssProxyActionsCharter and DssProxyActionsEndCharter contracts receive the vat address as follows: address vat = CharterLike(charter).vat(). Considering that the vat contract is already deployed and its address is not expected to change, the contracts can store this value as immutable or constant to optimise gas costs.    Both  the  address  of  the  VAT  and  the  CharterManager  (which  was  previously  passed  as  function argument) are now stored as immutables.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-charter-smart-contracts/"}, {"title": "6.4   Unused Function _toRad()", "body": "  The function _toRad() is implemented in DssProxyActionsCharter but it is not used.    The unused function has been removed.  MakerDAO - DSS-Charter -   13  DesignLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-charter-smart-contracts/"}, {"title": "7.1   Overflow When Drawing More Than 100", "body": " Trillion Debt  Theoretically, the function _getDrawDart() can overflow when computing dart: dart = _toInt256( _mul(netToDraw,  WAD)  /  _sub(_mul(rate,  WAD),  _mul(rate,  nib))).  netToDraw  is  in rad  (45  decimals)  and  wad  has  18  decimals,  therefore  for  large  netToDraw  (greater  than  10**14)  the computation overflows.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-charter-smart-contracts/"}, {"title": "7.2   Possible Overflow in exit()", "body": "  The  function  exit()  in  ManagedGemJoin  contract  converts  uint256  wad  into  a  negative  value: -int256(wad).  Before  the  conversion,  the  following  check  is  performed  to  prevent  overflows: require(wad <= 2 ** 255). Theoretically, if wad == 2 ** 255 the overflow will happen twice, but the result matches the expected value in this case.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-charter-smart-contracts/"}, {"title": "7.3   Unaware Users and Permissioned Ilks", "body": "  Unaware users may deposit collateral for a permissioned ilk. Only when a user attempts to draw debt for such a permissioned ilk the transaction will revert.  The reason is that for a permissioned ilk an unpermissioned user has a credit line of 0, hence cannot take on  debt.  The  error  message  CharterManager/user-line-exceeded  and  the  place  where  the transaction reverts may be confusing for an unaware user.  MakerDAO - DSS-Charter -   14  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-charter-smart-contracts/"}, {"title": "5.1   Heap Data Structure Can Be Spammed", "body": "  The  users'  supply  and  borrow  information  is  stored  in  Heap  data  structures.  The  parameter _maxSortedUsers sets the maximum sorted user amount in order to limit the gas spent on updating the Heap.  The  data  structure  would  halve  the  length  of  the  Heap  when  maxSortedUsers  is  exceeded. However, this behavior would potentially put an incoming user to a higher priority than an existing one. This behavior can be abused by bad actors to fill the ordered portion of the Heap with dust:  Consider the following example:   maxSortedUsers is set to 4.   Step 1: User 1 and user 2 are legitimate users that supplied 400 and 300 tokens respectively.   Step 2: An attacker now supplies 600, 500 and 1 token with three different addresses.   Step 3: The attacker withdraws 599 and 499 tokens from accounts 3 and 4.  The described behavior is detailed in Figure 1. Blue boxes show accounts in the ordered portion of the Heap, green boxes show accounts in the non-ordered portion.  Morpho Labs - Morpho (Aave v3) -   11  DesignCorrectnessCriticalHighRiskAcceptedMediumRiskAcceptedLowCodePartiallyCorrectedCodePartiallyCorrectedCodePartiallyCorrectedRiskAcceptedRiskAcceptedCorrectnessHighVersion1RiskAccepted           \fFigure 1: Spam attack on the Heap  As a result, the supplied liquidity of users 1 and 2 is now only reachable after the dust of the attacker's accounts has been matched.  Risk accepted:  Morpho Labs accepts the risk with the following statement:  We know that the heap structure has still some drawbacks (even if it\u2019s better than the double linked list implemented on the compound contracts) and we acknowledge the manipulation of the heap. The spam attack is likely to be costly to conduct, moreover, if users come after with greater amounts the dust accounts will be pushed outside the heap.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "5.2   Interfaces Not Implemented / Available", "body": "  Morpho  does  not  extend  the  IMorpho  interface.  This  can  lead  to  errors  during  development  and integration  by  third  parties  as  the  interface  might  not  match  up  with  the  implementations.  Indeed,  the IMorpho interface lacks some public functions like setInterestRates or incentivesVault.  Risk accepted:  Morpho Labs accepts the risk and tries to maintain correct interfaces.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "5.3   Ambiguous Naming", "body": "  The  function  MorphoGovernance.setInterestRates  is  a  setter  for  the  InterestRateManager address, contrary to the function name which implies it sets interest rate values.  Code partially corrected:  MorphoGovernance.setInterestRates  to MorphoGovernance.setInterestRateManager  but  still  emits  an  event  InterestRatesSet  with ambiguous naming.  renamed   been   has   Morpho Labs - Morpho (Aave v3) -   12  CorrectnessMediumVersion1RiskAcceptedDesignLowVersion1CodePartiallyCorrected                \f5.4   Gas Inefficiencies  Gas efficiency can be improved in several places:   The  underlying   (e.g. EntryPositionsManager.supplyLogic).  The  addresses  could  be  cached  in  the  contract's storage instead to avoid unnecessary external calls.  token  of  AAVE's  aTokens   in  some   functions   fetched   is    Redundant storage reads are performed in some functions. The values could be cached in the stack  or in memory:   delta.p2pBorrowDelta   is   read   multiple   times   in  EntryPositionsManager.supplyLogic.   userMarkets[_user]   is   read   in   every   iteration   of   functions   that   call  MorphoUtils._isSupplyingOrBorrowing.   Many more examples can be found.   Redundant storage writes are performed in some functions. The values could be updated in a stack  or memory variable and written to storage at the end.   ExitPositionsManager._safeRepayLogic  updates  delta.p2pBorrowAmount  up  to  3  times.   ExitPositionsManager._safeRepayLogic  updates  delta.p2pSupplyAmount  up  to  2  times.   Redundant external calls are performed in some functions. The values could be cached in the stack  or memory and passed to other called functions:   IAToken.UNDERLYING_ASSET_ADDRESS   is   called   in  EntryPositionsManager.borrowLogic and in the sub-call to _borrowAllowed.   Calls  to  pool.getConfiguration  in  ExitPositionsManager.liquidateLogic  are  already performed by the sub-call to _liquidationAllowed.   MorphoGovernance.createMarket   calls   pool.getConfiguration   and   then  pool.getReserveData which also contains the configuration.  MorphoGovernance.createMarket,   from In  pool.getReserveNormalizedIncome  and pool.getReserveNormalizedVariableDebt could be computed from the already fetched reserve data.  retrieved   values   the    Rounding  errors  can  cause  matching  of  dust.  This  could  be  avoided  by  using  fractions  to  store principal  values:  Instead  of  dividing  token  amounts  by  an  index  and  later  multiplying  again  by  an index  (division  before  multiplication),  principal  values  could  be  stored  as  (uint128,  uint128) tuples  of  the  base  value  and  the  index  at  that  time.  This  change  requires  careful  handling  of uint128 casts though.   Some  checks  can  be  performed  earlier  in  the  code,  saving  callers  some  gas  on  reverting  transactions:   _borrowAllowed in EntryPositionsManager.borrowLogic.   Maximum number of markets check in MorphoGovernance.createMarket.   Unnecessary computations:   ExitPositionsManager.withdrawLogic does not have to check if the user is supplying.  Instead, it could revert on toWithdraw == 0.  Morpho Labs - Morpho (Aave v3) -   13  DesignLowVersion1CodePartiallyCorrected         \f ExitPositionsManager._safeWithdrawLogic potentially calls _updateSupplierInDS  2 times with no overlap.   Changes in the Heap data structures that result in one account being removed and another account  being updated could be performed with a replace action instead of pop + push.   Tighter packing of storage variables is possible (careful casting is necessary though).   p2pSupplyIndex  and  p2pBorrowIndex  could  be  packed  as  uint128  into  a  single  struct,  since most of the time, both values are read from the storage together.   The fields of the structs SupplyBalance and BorrowBalance could be reduced to uint128.   Many  variables  in  MorphoStorage  (e.g.  entryPositionsManager)  could  be  defined  as immutable. Since the Morpho contract is Upgradeable, the values can be changed by updating the proxy implementation.  In  ExitPositionsManager._getUserHealthFactor  functions  with  similar use-case), each asset price is individually fetched with oracle.getAssetPrice. Since the Aave oracle exposes a function to fetch multiple asset prices at once, some external calls can be saved by using oracle.getAssetsPrices.  (and  other   Code partially corrected:   Corrected: Underlying token addresses are now saved in the market storage variable.   Partially  corrected:  Redundant  storage  reads  have  been  improved  on  some  occasions  but  still  happen in various places.   Not corrected: The mentioned examples have not been updated to reduce storage writes.   Not corrected: The first example is obsolete because of another change, the other examples have  not been addressed.   Not corrected: The suggested change has not been implemented.   Partially  corrected:  createMarket  now  checks  for  the  maximum  number  of  markets  in  the  beginning of the function.   Corrected: The mentioned redundant computations have been removed.   Not corrected: pop + push is still used.   Not corrected: Variables are not packed more tightly.   Not corrected: No variables have been changed to immutable.   Not corrected: oracle.getAssetPrices is not used.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "5.5   Missing Sanity Checks", "body": "   Morpho.createMarket does not check if the _underlyingTokenAddress is the 0-address.   Multiple Governance setters do not check if address parameters are the 0-address.   The  initializer  of  MorphoGovernance  does  not  check  if  maxSortedUsers  is  zero.  However,  the  check is applied in setMaxSortedUsers.   The ExitPositionsManager.liquidateLogic can be called with an _amount of 0, while this  is not possible in other entry points.  Morpho Labs - Morpho (Aave v3) -   14  DesignLowVersion1CodePartiallyCorrected         \fCode partially corrected:   Corrected: Morpho.createMarket now checks if _underlyingToken is the 0-address.   Corrected: Setters now check for the 0-address except if the respective field can be intentionally set  to the 0-address.   Corrected: The MorphoGovernance initializer now checks if maxSortedUsers is zero.   Not corrected: ExitPositionsManager.liquidateLogic can still be called with an _amount  of 0.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "5.6   Rewards Can Be Withdrawn by Admins", "body": "  Morpho.claimRewards  transfers  accrued  rewards  of  Morpho  (Aave  v3)'s  whole  position  from  Aave when a user claims their share of the rewards. This means that some tokens may now be owned by the Morpho contract, which can later be claimed by other users.  If one of the reward tokens is however an active market on Morpho (Aave v3), the tokens are claimable by  the  contract  admin.  In  this  case,  both  fees  and  user  rewards  are  mixed  together  and  the  contract admin could accidentally mistake all of the tokens for fees and withdraw them.  This would result in rewards not being claimable by all users that are entitled to them.  Risk accepted:  Morpho Labs accepts the risk stating that the admin (or DAO) is not advised to withdraw fees when there is a running rewards program where the reward token is equal to one of the market tokens.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "5.7   Variable Shadowing", "body": "  In  InterestRateManager.updateIndexes  and  MorphoGovernance.createMarket,  the state variable poolIndexes is shadowed by a local variable.  MorphoUtils.isMarketCreatedAndNotPaused  and In  isMarketCreatedAndNotPausedNorPartiallyPaused,  the  state  variable  marketStatus  is shadowed by a local variable.  Risk accepted:  Morpho Labs accepts the risk. Furthermore, additional storage variables are shadowed in some functions now.  Morpho Labs - Morpho (Aave v3) -   15  DesignLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  0  1  14  -Severity Findings  -Severity Findings  -Severity Findings   Unadapted amountToLiquidate   -Severity Findings   Free Borrowing of Small Amounts Possible    Function Can Be Restricted to Pure   Incorrect and Missing Specs    Limited Liquidation Amount    MorphoToken Not Safely Transferred    P2pBorrowDelta Always Zero    Potentially Different RewardsController Address    Redundant Code    Similar Code Abstraction    Unused Imports / Errors    Use of Deprecated Function    Withdrawal Denial of Service    Withdrawals Do Not Check Oracle Health    Wrong Event Data   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.1   Unadapted amountToLiquidate", "body": "  In liquidateLogic, amountToLiquidate is computed before amountToSeize is capped. However, amountToLiquidate is not adapted to the capped amountToSeize, which may cause the liquidator to repay more than the value of the collateral they obtain.    If  amountToSeize  exceeds  the  amount  of  the  liquidated  user's  collateral  balance  of  the  requested token, amountToLiquidate is adjusted as follows:  Morpho Labs - Morpho (Aave v3) -   16  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignMediumVersion1CodeCorrected         \famountToLiquidate = ((collateralBalance * collateralPrice * vars.borrowedTokenUnit) /             (borrowedTokenPrice * vars.collateralTokenUnit))         .percentDiv(vars.liquidationBonus);  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.2   Free Borrowing of Small Amounts Possible", "body": "  Certain  circumstances  allow  for  the  borrowing  of  very  small  amounts  of  tokens  without  supplying collateral beforehand:  EntryPositionsManager._borrowAllowed  computes  the  values  of  the  supplied  and  borrowed tokens  in  a  base  currency  and  checks  whether  an  additional  borrowed  amount  would  result  in  the account being underwater.  For an account with 0 supplied and borrowed balances, the following computation determines if a borrow is allowed:  liquidityData.debtValue +=     (_borrowedAmount * assetData.underlyingPrice) /     assetData.tokenUnit;  Depending  on  the  price  oracle,  a  small _borrowedAmount  might  result  in  integer  division  that  rounds  to  0.  This  would  satisfy  the  final  check and allow the borrowing of the given amount:  the  decimals  of   the  decimals  of   token  and   the   liquidityData.debtValue <= liquidityData.maxLoanToValue  Morpho  (Aave  v3)  uses  the  oracles  of  the  underlying  AAVE  pool,  which  in  turn  uses  Chainlink  price feeds.  On  ETH  Mainnet,  AAVE  uses  Chainlink  price  feeds  in  ETH  base  currency,  which  have  18 decimals (this is true for AAVE v2. AAVE v3 is not yet live on Mainnet at the time of this writing). On other chains (e.g. Optimism), AAVE uses feeds with USD base currency, which only have 8 decimals. In this case, many tokens become susceptible to this problem.  Since the claimable amounts are significantly lower than the amount of gas that has to be paid, the bug is of very low severity.    The division by tokenUnit is now performed using the function Math.divUp. This function adds 1 wei to  the  debt  if  (_borrowedAmount  *  underlyingPrice)  %  tokenUnit  !=  0.  Therefore, borrowing small amounts of tokens without sufficient collateral is not possible anymore.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.3   Function Can Be Restricted to Pure", "body": "  The function RewardsManager._getRewards can be restricted to pure as it does not read from the storage.    Morpho Labs - Morpho (Aave v3) -   17  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f_getRewards is now marked as pure.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.4   Incorrect and Missing Specs", "body": "  In MorphoGovernance, doc comments wrongly specify a _poolTokenAddress parameter for the MarketCreated event.   Function comments in MatchingEngine.sol should mention Aave instead of Compound.   All fields of struct Types.Delta are expressed in underlying decimals instead of in WAD as claimed  in the specs.   Some parameters are missing in the specs of RewardsManager._updateRewardData.     Corrected: The MarketCreated event is now correctly documented.   Corrected: The correct protocol name has now been added to all comments in MatchingEngine.   Corrected: The correct decimal types are now documented for all Types.Delta fields.   Corrected: RewardsManager._updateRewardData parameters are now correctly documented.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.5   Limited Liquidation Amount", "body": "  Liquidations  in  Morpho  (Aave  v3)  are  only  allowed  up  to  a  maximum  of  50%  of  the  user's  borrowed assets.  This  is  true  even  when  the  health  factor  of  the  user  is  below  95%.  This  is  contrary  to  the implementation  of  the  underlying  Aave  pool,  which  allows  for  a  liquidation  of  the  whole  user  position when the user's health factor drops below 95%.  This  behavior  can  increase  the  risk  of  Morpho's  position  on  Aave  becoming  liquidatable  (for  example because liquidation bots on Morpho are not working efficiently).    User  positions  with  a  health  ExitPositionsManager._liquidationAllowed returns the respective liquidation close factor.  factor  below  95%  can  now  be   liquidated  completely.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.6   MorphoToken Not Safely Transferred", "body": "  IncentivesVault.tradeRewardTokensForMorphoTokens  transfers  MORPHO  tokens  without checking a possible return. It is advised to use SafeTransferLib.safeTransfer in this case.  This might not be necessary depending on the implementation of the MORPHO token. At the time of this writing, no such contract is known to us. Therefore, we are unable to verify if the use of transfer is safe in this case.  Morpho Labs - Morpho (Aave v3) -   18  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                         \f  tradeRewardTokensForMorphoTokens now uses safeTransfer to transfer MORPHO tokens.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.7   P2pBorrowDelta Always Zero", "body": "  When  repaying  the  fee  in  ExitPositionsManager._safeRepayLogic,  delta.p2pBorrowDelta has already been reduced to 0 at this point and could be safely removed from the equation.    _safeRepayLogic does not take delta.p2pBorrowDelta into account anymore.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.8   Potentially Different RewardsController", "body": " Address  The Morpho and RewardsManager contracts may have different RewardsController addresses as there is no synchronization between them at initialization.    RewardsManager does not store the RewardsController address anymore. Instead, the address is passed to its functions as an argument.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.9   Redundant Code", "body": "  In EntryPositionManager the second if check is redundant as shown below.  if (toWithdraw > 0) {     uint256 toAddInP2P = toWithdraw.rayDiv(p2pBorrowIndex[_poolTokenAddress]); // In peer-to-peer unit.      deltas[_poolTokenAddress].p2pBorrowAmount += toAddInP2P;     borrowBalanceInOf[_poolTokenAddress][msg.sender].inP2P += toAddInP2P;     emit P2PAmountsUpdated(_poolTokenAddress, delta.p2pSupplyAmount, delta.p2pBorrowAmount);      if (toWithdraw > 0) _withdrawFromPool(underlyingToken, _poolTokenAddress, toWithdraw); // Reverts on error. }  In  EntryPositionManager.sol,  the  function  _borrowAllowed  does  not  need  to  check  if _amount == 0, because this is already checked at the beginning of borrowLogic.  In  liquidateLogic,  the  check  _isBorrowingAny(_borrower)  is  redundant,  because  it  is already  by _isBorrowing(_borrower, _poolTokenBorrowedAddress).  beginning   checked   the   at   Morpho Labs - Morpho (Aave v3) -   19  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                           \f  The redundant code parts have been removed / are not relevant anymore.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.10   Similar Code Abstraction", "body": "  functions   The  and EntryPositionsManager._borrowAllowed  share  a  similar  code  base  that  should  be  abstracted away to avoid maintenance problems.  ExitPositionsManager._getUserHealthFactor     common   The  logic  EntryPositionsManager._borrowAllowed  MorphoUtils._liquidityData.  of   ExitPositionsManager._getUserHealthFactor   has   been   abstracted   into   the   and function  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.11   Unused Imports / Errors", "body": "  MorphoGovernance defines the AmountIsZero error, but it is never used in the inheritance hierarchy of the contract.    The AmountIsZero error has been removed from MorphoGovernance.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.12   Use of Deprecated Function", "body": "  PositionsManagerUtils.supplyToPool calls the pool.deposit function which is deprecated in Aave.    supplyToPool now calls pool.supply on Aave instead.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.13   Withdrawal Denial of Service", "body": "  ExitPositionsManager.withdrawLogic  calls  _getUserHealthFactor  if  the  user  is  borrowing any  tokens.  If  the  user's  borrow  balance  is  small  and  if  the  called  Aave  oracle  returns  a  number  with  Morpho Labs - Morpho (Aave v3) -   20  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                                \flower  decimals  than  the  token's,  then  _getUserHealthFactor  will  revert  on  division  by  zero, preventing any withdrawals by the user.  This issue is related to Free borrowing of small amounts possible.    The division by tokenUnit is now performed using the function Math.divUp. This function adds 1 wei to  the  debt  if  (_borrowedAmount  *  underlyingPrice)  %  tokenUnit  !=  0.  Therefore,  a division by zero even with small debts is not possible anymore.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.14   Withdrawals Do Not Check Oracle Health", "body": "  On  withdrawals,  Morpho  the PriceOracleSentinel of AAVE. While AAVE does this the same way, there are still risks associated. Consider the following example:  (Aave  v3)  does  not  check   for  oracle  health   through    A tokens and B tokens are both worth exactly 1 USD.   A user supplies 500 A tokens and borrows 200 B tokens.   The user can withdraw up to 200 A tokens and still maintain a good health factor.   Now  the  price  of  A  tokens  rapidly  changes  to  0.2  USD,  but  the  price  oracle  for  A  tokens  has  not  updated for a few days and still shows 1 USD / A token.   The  user  is  now  still  able  to  withdraw  200  A  tokens  while  in  reality,  his  position  is  already  under  water.  As the recent debacle with Chainlink price feeds of LUNA has shown, oracles that are not updating prices in a timely manner can become very problematic for lending protocols. It is therefore advised to check the health of such oracles.  Unfortunately,  at  the  time  of  this  writing,  AAVE  has  not  deployed  a  PriceOracleSentinel  so  the problem persists also for liquidations and borrowing until AAVE deploys these mechanisms.    ExitPositionsManager._withdrawAllowed  now  checks  priceOracleSentinel.isBorrowAllowed().  the  oracle  health  by  calling  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.15   Wrong Event Data", "body": "  The following events contain wrong data:   ExitPositionsManager._safeWithdrawLogic  emits  the  event  P2PBorrowDeltaUpdated  with delta.p2pBorrowAmount instead of delta.p2pBorrowDelta.   ExitPositionsManager._safeRepayLogic  emits  the  event  P2PSupplyDeltaUpdated  with  delta.p2pBorrowDelta instead of delta.p2pSupplyDelta.  Morpho Labs - Morpho (Aave v3) -   21  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \f  The mentioned events are now emitted using the correct parameters.  Morpho Labs - Morpho (Aave v3) -   22  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "7.1   Accidental Ownership Transfers", "body": "  Morpho  (Aave  v3)  contracts  use  OpenZeppelin's  Ownable  contract  to  store  ownership.  Ownable employs  a  single-step  ownership  transfer.  Accidental  transfers  to  the  wrong  address  will  lock  out  the owner  indefinitely.  For  this  reason,  special  care  has  to  be  taken  when  updating  the  ownership  of  the contracts.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "7.2   Delta Reduced When P2P Is Disabled", "body": "  If  p2pDisabled  is  set  to  true,  the  peer-to-peer  delta  is  reduced  instead  of  borrowers  /  suppliers unmatched.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "7.3   IncentivesVault Security Relies on Oracle", "body": " Implementation  The  Security  of  IncentivesVault.tradeRewardTokensForMorphoTokens  the implementation  of  the  oracle  that  is  set  to  calculate  the  value  of  the  given  rewards.  Since  there  is  no implementation available at the time of this writing, we cannot attest if the use of this function is secure.  relies  on   Morpho Labs aims to implement a TWAP oracle based on Uniswap v3 in the future.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "7.4   Lack of Balance Functions", "body": "  The Morpho contract does not expose view functions for user balances.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "7.5   Liquidation Risk on Aave", "body": "  If Morpho's position on Aave is liquidated, the unmatched accounting of Morpho and Aave would break Morpho's  availability  and  possibly  lock  users'  funds.  Besides,  fully  pausing  Morpho  would  increase  the liquidation  risk  on  Aave.  Efficient  arbitrage  bots  are  required  to  run  on  Morpho  so  that  the  underlying position on Aave does not become liquidatable.  Morpho Labs - Morpho (Aave v3) -   23  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion1                    \f7.6   Liquidations May Affect Rates of P2P Users  ExitPositionsManager.liquidateLogic calls repayLogic and withdrawLogic with 0 gas for matching. This can lead to worse rates for P2P users as supply / borrow delta can be increased by these operations.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "7.7   No Delay Mechanism for Parameter Updates", "body": "  There  is  no  delay  mechanism  for  the  updates  of  parameters  to  take  into  effect.  Users  who  are  not satisfied with the upcoming updates would not have time to leave the market.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "7.8   Potentially Exceeding maxGasForMatching", "body": "  As  shown  below,  the  matching  functions  potentially  use  slightly  more  gas  than  the  users'  given _maxGasForMatching.  while (         remainingToMatch > 0 &&         (firstPoolSupplier = suppliersOnPool[_poolTokenAddress].getHead()) != address(0) ) {     unchecked {         if (gasLeftAtTheBeginning - gasleft() >= _maxGasForMatching) break;     }     ... }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "7.9   Unsupported Tokens", "body": "  The following tokens can not be used in Morpho Markets without repercussions:   Aave siloed assets.   Aave isolated assets.   Tokens  with  high  decimals   (e.g.  27)  because   the  amountToSeize  calculation   in  EntryPositionsManager.liquidateLogic might overflow on realistic token amount values.   Tokens that charge a transfer fee (e.g. STA, PAXG).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "7.10   Year 2106 Problem for Uint32 Timestamps", "body": "  Timestamps are written to storage which could impose problems on the storage layout in the year 2106.  Morpho Labs - Morpho (Aave v3) -   24  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion1                    \f7.11   safeTransferFrom Does Not Revert on Calls to an EOA  Morpho (Aave v3) uses Rari Capital's SafeTransferLib to support tokens that revert on transfers as well as tokens that return a boolean value. The functions, especially safeTransferFrom, however do not revert if the called token is not a contract. In this case, Morpho (Aave v3) contracts could be tricked into thinking that a token transfer from a user was successful when in fact nothing happened.  As of now, Morpho (Aave v3) is not affected by this behavior since all token addresses are directly taken from Aave which correctly checks for contracts in its safeTransferFrom function.  Future changes of the code should take this into account.  Morpho Labs - Morpho (Aave v3) -   25  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/morpho-aave-v3/"}, {"title": "6.1   Cached Rate May Be Wrong", "body": "  0  0  3  5  OracleMulti  allows  to  read  rates  from  Chainlink  and  Uniswap  circuits  with  _readAll().  First  the Uniswap rate is computed. However, the Uniswap circuit may not be final, meaning that the last pair (e.g. WETH to USD) requires a Chainlink rate. Next the Chainlink rate is read from the circuit. The rate of the last Chainlink circuit pair is cached, to be used for further computations on the Uniswap rate.  However,  the  constructor  allows  for  the  last  Chainlink  and  Uniswap  pairs  to  be  different.  Thus,  the following scenario is possible:  1. OracleMulti  is  initialized  with  a  Chainlink  circuit  (UNI-WBTC,  WBTC-USD)  and  a  Uniswap  circuit (UNI-WETH). That means that the Uniswap is not final and a Chainlink rate has to be read for the rate WETH-USD.  2. The Chainlink rate is calculated and the WBTC-USD rate is cached.  3. The Uniswap UNI-WETH rate is computed. Inside the branch if (uniFinalCurrency > 0) the calculation  of  the  rate  is  finalized  using  the  cached  WBTC-USD  rate  which  leads  to  an  incorrect result, as the rate for WETH-USD should have been used instead.  Angle - Angle Protocol -   13  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedCodePartiallyCorrectedAcknowledgedCodePartiallyCorrectedLowRiskAcceptedAcknowledgedRiskAcceptedRiskAcceptedRiskAcceptedCorrectnessMediumVersion1RiskAccepted              \fRisk accepted:  Angle will make sure that the Uniswap and Chainlink circuits are compatible. A comment has been made in the code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "6.2   Missing Slippage Protection for Users", "body": "  There  is  no  slippage  protection  for  users  interacting  with  the  mint(),  burn(),  deposit()  or withdraw()  functions  of  a  StableMaster  contract  nor  for  actors  interacting  with  certain  functions  of  a PerpetualManager contract which calculate the cash out amount of a perpetual.  A user can get caught unlucky, especially as fees depend on the current state of the system or as the cash out amount of a perpetual depends on the current rate returned by the Oracle. There is a risk of sandwich  attacks  on  user's  transaction:  A  user's  transaction  may  be  sandwiched  between  two  of  the attacker's transaction. The first transaction of the attacker may change the state of a system resulting in an  unfavorable  outcome  of  the  user's  transaction  while  the  attacker  profits  with  his  second  transaction just after the user's transaction.  Code partially corrected:  A slippage protection has been added for stable seekers minting and burning. Slippage protection has been introduced for hedging agents.  Acknowledged:  However,  it  was  concluded  that  not  further  slippage  protection  for  standard  liquidity  providers  is necessary.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "6.3   Problematic Revocation of a Collateral", "body": "  StableMaster  allows  for  revokeCollateral()  to  be  called  by  the  governance.  That  transfers  all  the funds of the pool manager to a settlement contract. Afterwards users can make claims for withdrawing from the settlement contract. However, some user may lose.  This issue attempts to highlight two key points:  (I).  While this function is part of the emergency shutdown process of a stablecoin, this function can also be called on a single collateral only. In both situation following scenario (simplified that no HAs exist) which is mentioned in the documentation may occur:  1. revokeCollateral() gets called on a pool with 1000 WETH. 1 WETH is worth 1000 USD. 100 WETH-SanTokens  are  minted  and  have  value  of  200  WETH.  The  pool  manager  transfers  his balance to the settlement contract.  2. CollateralSettler.triggerSettlement()  is  executed.  The  amount  to  redistribute  is  the  balance of the settlement contract. All the rates are frozen.  3. SLPs claim their collateral. totalLpClaims increases.  4. A day before the claiming period ends, the price of WETH doubles. 1 WETH is worth 2000 USD now  in the current markets.  5. Many users see the bargain and start claiming WETH for their AgUSD.  Angle - Angle Protocol -   14  SecurityMediumVersion1CodePartiallyCorrectedAcknowledgedDesignMediumVersion1CodePartiallyCorrected                  \f6. The  claiming  period  ends.  The  claim  of  stable  holders  is  1000  WETH.  The  claim  by  SLPs  is  200  WETH.  7. The WETH will be distributed only to stable holders. SLPs do not receive anything.  The documentation specifies this behaviour. However, it highly concerning for SLPs and HAs. Anybody with enough capital could take their investments into the protocol.  (II).  Furthermore,  SLPs  and  HAs  could  the funds  revokeCollateral() call. The pools balance could be moved to another pool using a flashloan and an external exchange. Then, the revokeCollateral() call will be executed but close to nothing would be transferred to the settlement contract and SLPs and HAs will not be able to receive their funds.  if  an  attacker  decides   frontrun   lose   to   Code partially corrected:  Different changes have been made:   As  stocksUser  now  tracks  the  amount  of  created  stable  coins  it  can  also  be  used  to  limit  the  claims.   The oracle value is queried at the end of the claim period to reduce issues due to price fluctuation.  Lastly, the front-running issue will be partially mitigated through pausing, but as in comparable systems cannot be entirely avoided.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "6.4   Inputs for Triggering Settlement", "body": "  When the StableMaster contract triggers a settlement on the CollateralSettler contract it passes the current sanRate along. During this process any queued lockedInterests that were supposed to be added to the sanRate later are ignored. Hence, the sanRate is not entirely correct.  Risk Accepted:  Angle replied:  We decided to leave it as is. lockedInterests supposed to be added to the sanRate remain ignored. It could be a vector of attack to include these interests to SLPs. If trigger settlement was to be activated, then this means that governance failed to maintain the pool in a healthy way, and in this situation, interests should not be distributed to SLPs (we expect that there will also be fees aside)  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "6.5   Removing From Perpetual Potentially", "body": " Impossible  When a perpetual position develops well and its margin has significantly increased, users might decide to remove some of the margin through the removeFromCollateral function. However, if the amount of collateral to be removed exceeds the initially set margin, this removal is not allowed, even though it might not violate any of the system restrictions such as maximum leverage:  Angle - Angle Protocol -   15  CorrectnessLowVersion2RiskAcceptedDesignLowVersion2Acknowledged                \frequire(         ...         (amount < perpetual.margin) &&  Acknowledged:  Angle replied:  In fact the margin of a perpetual never increases if the perpetual develops well: the margin is the initial amount of collateral in the perpetual, and this does not evolve with price. If we allowed HAs to remove more than their margin in case of price increase, we would be back to the situation we had before your audit where we also update the oracle value, and what we called the cashOutAmount at each perpetual update. For the HA to get more collateral than the margin, position should be cashed out  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "6.6   Sandwich Attacks Against harvest", "body": " Invocations  The harvest functions of certain strategies, e.g., GenericAave, are susceptible to sandwich attacks. As these harvest functions can be called by anyone and perform a token sale, the following attack is possible:   An attacker contract manipulates the relevant Uniswap pools   That attacker contract calls the harvest function of one of the strategies, which triggers a Uniswap  trade   The attacker contract arbitrages the Uniswap pools to benefit from the previous trade  In the currently present strategies, such attacks are limited to the reward tokens.  Risk accepted:  Angle replied:  We forked these strategies from Yearn, we have hence decided to keep it as is, and we are aware of this risk. It is important to note that to mitigate such attacks, however costly it is, the harvest function needs to be called pretty regularly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "6.7   HA Fees May Exceed 100%", "body": "  There are no limitations for the values of haBonusMalusDeposit or haBonusMalusWithdraw. These can  be  set  arbitrarily  by  the  Guardian  /  Governor  in  the  FeeManager  and  are  later  propagated  to  the PerpetualManager.  Inside the PerpetualManager, the fee for HAWithdraw is calculated as follows:  haFeesWithdraw = (haFeesWithdraw * haBonusMalusWithdraw) / BASE; return (amount * (BASE - haFeesWithdraw)) / BASE;  Angle - Angle Protocol -   16  SecurityLowVersion2RiskAcceptedDesignLowVersion1RiskAccepted                \fIn case haFeesWithdraw exceeds BASE the transaction will revert and the withdrawal is blocked. The same applies for HADeposit accordingly.  Risk accepted:  Angle replied:  No specific change has been made for that, if this situation happens, then the transaction will fail anyway and there is no need to add a require for that.  We thought of adding a require in the setters of the fees to make sure that fees will never be able to be bigger than 100% (especially for users minting/burning fees), but we decided not to do it. The reason is that our fees are of the form f(x)g(y), with 0 <= f(x) <= 1.  Therefore it may happen that for some value of the y parameters, you have g(y) > 1, and for some couples (x,y), you have f(x)g(y)>1. We do not want to enforce that the product is always <1.  In our case, the evolution of the bonusMalus (depending on the collateral ratio for users) and the evolution of the fees computed using the coverage curve are different. It is possible that the product in the max element in the array yBonusMalusMint and in the array yFeeMint are superior to BASE but that this situation is never observed in practice because the evolution of the collateral ratio is not correlated to the evolution of the coverage curve.  Governance will still have to be wary and to make sure when setting these parameters that even though a situation where  f(x) g(y)>1 can happen in theory, it will never happen in practice.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "6.8   Small Perpetual Position, Too Low Keeper", "body": " Incentive  The system enforces no minimum amount for a perpetual position and corresponding minimum fee paid. The  reward  /  incentive  for  a  keeper  to  liquidate  a  perpetual  that  meets  the  condition  to  be  liquidated respectively to be forcefully cashed out is a part of fees paid by this perpetual.  The  incentive  for  keepers  must  at  least  cover  their  transaction  costs.  As  no  minimum  amount  for  a perpetual (hence keeper fee) is enforced, perpetuals bringing a small amount of collateral to the system and hence paying a small fee may not be liquidated as the reward exceeds the keeper's transaction fees.  Risk accepted:  Angle replied:  Although we slightly changed the keeper incentives (as a portion of the cashOutAmount at the time the perpetual is cashed out), we decided not to have a minimum position or a minimum incentive for keeper. If the incentives are too low, we will do it ourselves, even if it implies loosing money on it. Another thing we think about implementing is an off-chain reward mechanism based on on-chain verifiable data. This way we/our community could reward keepers which performed actions for which they did not make a profit but that were still helpful for the protocol. We could also upgrade our smart contracts to arrive to the solution you propose (minimum incentive for keeper coupled with a minimum position - you cannot do one without the other otherwise you may be subject to attacks).  Angle - Angle Protocol -   17  SecurityLowVersion1RiskAccepted          \f7   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  4  15  32  -Severity Findings  -Severity Findings   Burning AgTokens in BondingCurve Does Not Update stocksUsers    Collecting Keeper Fees, Closing Perpetuals   Incorrect Maximum Collateral Amount    Untracked Bad Debt / System Health   -Severity Findings   Everybody Can Pause Pools   Incorrect Check During removeFromPerpetual   Incorrect Handling of profitFactor    Potentially Incorrect Strategy Report    Reentrancy When Creating Perpetual Position    Adding to Unhealthy Perpetual Liquidates and Consumes New Collateral    Broken/Partial ERC165 Support    Conversion of Locked Interest to SanRate in the Same Block*    Governance Not Fully Propagated    Guardian Cannot Be Managed by Guardian   Incorrect Cash Out Amount    Non 18 Decimals Protocol Tokens    Unaccounted Collateral, Unrestricted updateStocksUsersGov()    Unit Errors for Tokens With Decimals Different Than 18    safeApprove Not Used, USDT Not Supported   -Severity Findings   BondingCurve Specification Mismatches    Gas-inefficient Strategies   Inefficiency in Binary Search    No Slippage Protection in BondingCurve    Reference Coin Changes May Affect the Bonding Curve    Specification Mismatch in Strategy    StableMaster Might Be Unnecessarily Paused    Cache Value Instead of Reading From Storage    Consistency Checks for Oracles Missing   Angle - Angle Protocol -   18  CriticalHighCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrected     \f Different Calculation of Cashout Fees    Double Getters    Enhance Check During Deployment of Collateral    Events Missing    Gas Inefficiencies When Removing From List    Gas Inefficiencies When Searching Lists    Governance Changes   Inconsistencies Between Staking Contract   Inconsistent Parameters in RewardsDistributor Possible   Incorrect Comment   Inefficient Structs    No Check if onERC721Received Is Implemented    No Checks Performed in Constructor    Outdated Compiler Version    Overhead Due to Loading Struct Into Memory    Possibly Failing Assert    Potential Confusing readLower(uint256 lower)    Reward Token Issues    Specification Mismatch in OracleMath    Unnecessary Double Checks    Updated SanRate When Converting to SLP    Wrong Incentive for Which Perpetuals to Forcefully Cash Out    capOnStablecoin May Be Violated by Guardians   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.1   Burning AgTokens in BondingCurve Does Not", "body": " Update stocksUsers  The BondingCurve contract allows users to buy tokens (most likely Angle tokens). To receive tokens from the  BondingCurve,  AgTokens  get  burned  according  to  the  bonding  curve  price.  This  may  significantly reduce  the  amount  of  AgTokens  minted  and  improve  the  protocol  health.  However,  no  stocksUsers variable  is  updated.  Several  issues  may  arise  regarding  such  accounting  issues.  For  example,  the coverage  ratio  of  the  protocol  may  be  much  higher  than  the  one  indicated  and  the  system  create  bad debt through that mismatch.  Note that regular burn operations also do not update the stocksUsers variable.    When  buying  tokens  the  AgTokens  are  transferred  to  the  bonding  curve  contract  and  not  burned. and Governance   BondingCurve.recoverERC20   functions   make   use   can   of   Angle - Angle Protocol -   19  CodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedAcknowledgedCodeCorrectedCorrectnessHighVersion2CodeCorrected              \fAgToken.burnNoRedeem which calls StableMaster.updateStocksUsers to transfer AgTokens to itself and burn them while updating the stocks users for a specified pool manager.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.2   Collecting Keeper Fees, Closing Perpetuals", "body": "  Should  the  maximum  covered  amount  of  collateral  be  exceeded,  anyone  can  forcefully  cash  out  any perpetual  in  order  to  bring  the  amount  of  covered  collateral  back  below  the  limit.  However  this  can  be abused as one can manipulate the amount of collateral to be covered.  Assume a working StableMaster issuing AgUSD with several collateral pools like USDC, DAI and WETH. There is a decent amount of liquidity provided by standard liquidity providers and the coverage ratio of the pools is around 80% with a limit at 90%. Many perpetuals of different sizes exist. An arbitrary attacker can now do the following:  1. Either the Attacker has funds available or borrows them using a flashloan  2. These funds are exchanged into AgUSD on a third party exchange  3. These AgUSD are now burned for the collateral under attack.  4. Burning  the  AgUSD  tokens  increases  the  collateralization  ratio  for  this  collateral  as  collateral  is  withdrawn. The attacker does this at least until the coverage limit is exceeded.  5. The attacker is now able to forcefully cash out perpetuals until the amount covered is below the limit.  While forcefully cashing out perpetuals the attacker collects the fees.  6. Pay back the flashloan using the collateral.  This  attack  is  profitable  when  the  transaction,  flashloan  and  burn  fees  are  below  the  keeper  reward collected for closed perpetuals. As keeper fees for each perpetual have to cover for the transaction base fees (as they may have to be closed individually by keepers due to reaching the cashout leverage) the collected  rewards  likely  exceed  the  fees  when  the  attacker  manages  to  forcefully  cash  out  multiple perpetuals during this action.    The  new  fee  structure  rewards  keepers  reaching  the  targeted  coverage  ratio.  Moreover,  the  keeper reward  is  capped  such  that  the  profit  of  the  keeper  is  lower  than  the  estimated  cost  of  the  flash  loan needed for such an attack. For more information see the description of System Accounting.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.3   Incorrect Maximum Collateral Amount", "body": "  The  function  _testMaxCAmount  computes  the  \"Maximum  amount  of  collateral  that  can  be  insured\". This is computed as follows:  1. The stocksUsers variable is queried from the StableMaster contract.  2. The amount of minted stable coins is queried from the StableMaster contract and converted into  a collateral amount using the current rate.  3. The smaller of the two values above is multiplied with maxALock (the maximum percentage to be  insured) and then returned.  Both of these values are sometimes incorrect and hence shouldn't be used for the calculation:  1. stocksUsers is defined as:  Angle - Angle Protocol -   20  SecurityHighVersion1CodeCorrectedCorrectnessHighVersion1CodeCorrected                \f// Amount of collateral in the reserves that comes from users // + capital losses from HAs - capital gains of HAs  Due to the capital losses and capital gains it might be bigger or smaller than needed for the present calculation. Consider the following example:  After  a  late  liquidation  stocksUsers  =  15  ETH,  with  a  rate  of  500,  but  previously  10,000  stable coins have been minted. The system needs to insure 20 ETH, but would return 15 ETH * maxALock.  2. The amount of minted stable coins can only be used for this calculation if only a single collateral is used for this stable coin. However, multiple collaterals might be available to mint this stable coin and hence the system would calculate an incorrect amount of insurable collateral.    Now,  the  stocksUsers  variable  represents  the  amount  of  stablecoins  minted  per  collateral  and  the system  separates  the  stable  coins  minted  against  different  collaterals.  For  more  information  see  the description of System Accounting.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.4   Untracked Bad Debt / System Health", "body": "  A  stablemarket  attempts  to  keep  the  equilibrium  between  the  positions  of  stable  seekers  and  hedging agents. At times the attempt to keep the equilibrium may not be successful:   Should they price of a collateral decrease too fast and keepers can't or don't forcefully cash out bad perpetuals in time, the situation arises where the collateral put up by the perpetual evaluated at the current rate can no longer cover its committed amount at the rate the perpetual has been created. In this case the perpetual is liquidated leaving bad debt to the system.  Should the collateral of the stablecoin not be fully covered at all times (This means the collateral brought by stable seekers equals the amount covered by the hedging agents), 2 kinds of bad debt can occur:   Coverage of the collateral is less than 100% and the price of the collateral decreases from x to y:  For the uncovered collateral stablecoins have been minted a the higher collateral price x. Now the value of the collateral dropped to y. The minted stablecoins are now only partially covered by the value of the collateral. Note that should a new Hedging Agent now enter the system and covers some more of the collateral, this is done at the current exchange rate, not the rate used to mint the stablecoin. At this point the virtual loss of the system is converted into actual bad debt of the system.  Vice versa, should the price of uncovered collateral increase the system makes a profit.   Coverage of the collateral is more than 100% and the price of a collateral increases.  (Note that this cannot happen if maxALock is set to less than 100%)  Here profits made by Hedging Agents would exceed the increase in value of the collateral held by the system to back the minted stablecoins. This loss is taken by the system.  Overall  bad  debt  is  neither  tracked  nor  handled  otherwise.  If  possible  it  could  be  accounted  for  and compared with what is currently called \"system surplus\" which includes the fees collected and other gains made by the system.  No  functionality  to  query  the  health  of  the  system  exist.  Such  information  however  is  vital  for  all  users investing funds into the system.  Angle - Angle Protocol -   21  DesignHighVersion1CodeCorrected        \f  The  new  stocksUsers  enables  to  keep  better  track  of  the  current  system  health  and  the  bad  debt. However, these computations need to be performed off-chain, e.g., in the front-end. For more information see the description of System Accounting.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.5   Everybody Can Pause Pools", "body": "  In the second version of the code, a pool will be paused, if during a user's burn, the amount of AgTokens to  be  burned  is  higher  than  the  stocks  users  of  the  collateral.  However,  there  is  no  check  whether  the user  actually  owns  the  necessary  amount  of  AgTokens.  Thus,  any  user  can  specify  a  high  amount  to burn  to  pause  the  contract.  The  pool  will  remain  paused  until  the  governance  unpauses  this  change. Malicious parties could act as follows:   Stableholders: In case of expected collateral price drop can pause to make HAs and SLPs lose.   SLPs: A SLP providing much liquidity in a state with much HA capital could pause the contract to  keep other SLPs from entering the protocol so that his profit is maximized.   HAs:  HAs  can  front-run  liquidations  and  force-cashouts  by  pausing  the  contract.  Ultimately,  that  could lead to a highly unbalanced state.  In  conclusion,  anybody  can  pause  the  protocol  at  any  time.  Such  actions  could  be  profitable  for  the parties and could throw the system into an unhealthy state if they are executed repeatedly.    When  the  amount  of  AgTokens  burned  exceeds  the  stocksUsers,  the  transaction  reverts  instead  of pausing the contracts.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.6   Incorrect Check During ", "body": " removeFromPerpetual  The function removeFromPerpetual contains the following check:  // Withdrawing collateral should not make the leverage of the perpetual too important perpetual.committedAmount * BASE_PARAMS <= (perpetual.margin - amount) * maxLeverage,  The  maxLeverage  check  is  performed  based  on  perpetual.margin  -  amount,  however,  in  case the  cashOutAmount  <  perpetual.margin  then  this  check  underestimates  the  actual  leverage. Hence, a perpetual above the leverage limit might go undetected.    Now, an additional check was added to ensure that the new cashout amount is not exceeded.  Angle - Angle Protocol -   22  DesignMediumVersion2CodeCorrectedDesignMediumVersion2CodeCorrected                  \f7.7   Incorrect Handling of profitFactor  The  profit  factor  serves  to  reduce  the  profit  keepers  can  make  from  calling  harvest.  Thus,  following condition occurs:  profitFactor * rewardAmount < want.balanceOf(address(this)) + profit  This condition needs to be fulfilled for a reward payment to be made and is hence quite important.  Incorrectly, the condition is unaware of the decimals of the tokens since profitFactor is initialized to be 100 for any pair. Moreover, it is unaware of the prices of the tokens.  The decimal unawareness may cause the following behaviour:   Assume  the  reward  token  is  USDC  (6  decimals)  and  the  want  token  is  DAI  (18  decimals).  The condition  will  almost  always  pass  since  profit  factor  does  not  account  for  the  base  differences between the tokens.   Assume the reward token is DAI (18 decimals) and the want token is USDC (6 decimals). Then, this condition  will  almost  never  pass  to  since  the  reward  amount  will  already  be  much  larger  than  the right-hand-side.  The price unawareness may cause the following behaviour:   Assume the reward token is AgEUR and one strategy's want token is DAI while for the second one the want token is WETH. If now both strategies have similar balances and profits (when converted to USD), they will still be treated very differently.  To  conclude,  inconsistencies  in  the  keeper  reward  payouts  between  strategies  could  occur  since  the above condition is unaware of the decimal representation and prices of the tokens.    profitFactor  has  been  removed.  Now,  a  minimum  amount  minimumAmountMoved  denotes  how much needs to be at least in the contract plus the profits. Also, this amount and the reward amount are set jointly now to prevent errors.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.8   Potentially Incorrect Strategy Report", "body": "  Calling the harvest function on a strategy contract may result in a bad report to the pool manager. If the reward  token  the  keepers  receive  is  equal  to  the  want  token  of  the  strategy,  then  the  transfer  to  the keeper can be successful even though no specific allocation of funds to the strategy for the rewards was made.  Incorrectly,  the  keeper's  fee  will  still  be  part  of  the  reported  profit  as  the  profit  is  computed beforehand and not adjusted.    In the constructor of the strategy it checked that want and reward token are not the same.  Angle - Angle Protocol -   23  CorrectnessMediumVersion2CodeCorrectedCorrectnessMediumVersion2CodeCorrected                \f7.9   Reentrancy When Creating Perpetual Position  When creating a new perpetual position there is a possibility for a reentrancy attack. During the mint() operation of the token a callback is triggered that can be used for a reentrancy attack.  Among other things, possible consequences of such an attack could be:  that the coverage exceeds the expected values  that a non-liquidatable perpetual exists  that a mismatch between NFTs and positions exists    The call to _mint() is done after all state changes.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.10   Adding to Unhealthy Perpetual Liquidates", "body": " and Consumes New Collateral  addToPerpetual() allows a hedging agent to increase the cash out amount of the perpetual. Should a hedging agent attempt to add collateral to an unhealthy perpetual, the perpetual is liquidated while the collateral  amount  intended  to  increase  the  position  is  transferred  to  the  pool  manager  contract  without being accounted for.  Unaware  users  are  at  risk,  especially  as  a  hedging  agent  may  attempt  to  increase  the  collateral  of  a position which is just short of being liquidated. Any oracle update now may change the situation and the perpetual can be liquidated while the hedging agent loses his added collateral to the pool manager.    Attempting to add collateral to an unhealthy perpetual results in the perpetual being liquidated, which is intended. In this case, the new collateral amount however is no longer transferred to the pool manager in the updated code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.11   Broken/Partial ERC165 Support", "body": "  Through inheritance, mostly when inheriting AccessControl or AccessControlUpgradable multiple contracts inherit ERC165.  This contract implements the ERC165 standard which defines a standard method to publish and detect what interfaces a smart contract implements.  function supportsInterface(bytes4 interfaceID) external view returns (bool);  The more derived contracts of Angle with the exception of the PerpetualManager contract, that does it partially,  do  not  expand  or  overwrite  this  function.  Hence,  their  functionality  is  not  included  and supportedInterface() will not return true for the public/external functions they implement.  Angle - Angle Protocol -   24  SecurityMediumVersion2CodeCorrectedDesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                         \fEither the more derived contracts should implement this function in order to make complete the ERC165 functionality  or  if  this  is  not  required,  overwrite  supportsInterface()  with  an  empty  function  which would even slightly reduce the contract's code size.    Angle  forked  the  code  of  AccessControl  and  AccessControlUpgradaeable  and  removed  the ERC165 support. The only contract which implements the ERC165 interface is the PerpetualManager as it emits the perpetual futures as ERC721-NFTs. The supportsInterface function will return true for all interfaces it implements.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.12   Conversion of Locked Interest to SanRate in", "body": " the Same Block*  *While the review was ongoing Angle informed us about this issue independently in parallel.  _updateSanRate() consists of two parts: In the first half the locked interest accrued in previous blocks are added to the sanRate while in the second part the new amount of tokens to be distributed are added to the locked interests. These should be distributed in the next block this function is executed.  lastBlockUpdated however is only updated if some of the locked interest where added to the sanRate in this block.  This leads to following corner case when _updateSanRate() is executed: In case there are no locked interest to distribute, lastBlockUpdated is not updated to the current block.timestamp but rewards to be distributed are added to lockedInterests. However a second call to _updateSanRate() will now convert these lockedInterests and add them to the sanRate before updating lastBlockUpdated blocking a future update in this same block.  The  sanRate  is  updated  upon  collection  of  profit  from  strategies  or  when  a  part  of  the  fees  for  stable seeker is distributed to standard liquidity provider.  The profit from strategies can be attacked as follows:  At a time where lockedInterests is equal to zero and a strategy has a significant amount of rewards to collect, the attacker executes the following steps:   Deposits  a  large  amount  of  collateral  (e.g.  acquired  through  a  flashloan)  for  San  Tokens.  While updateSanRate()  is  called,  this  currently  has  no  effect  as  lockedInterests  is  equal  to  zero and the amount to distribute is 0, so lockedInterests remains zero.   Call  harvest()  on  the  Strategy.  This  collects  the  profit  and  executes  _updateSanRate().  As currently  no  locked  interests  are  to  be  distributed,  the  first  part  is  skipped  and  lastBlockUpdated` remains unchanged. In the second part the  lockedInterests to be distributed in the future are updated.   Withdraw  the  collateral  by  burning  the  san  tokens.  _updateSanRate()  is  executed  once  again, this  times  with  lockedInterests  being  nonzero  the  sanRate  is  now  actually  updated  and lastBlockUpdated is set to the current block. Hence the user can withdraw more collateral than deposited.  This may be abused to drain the profit of the strategy.  Note that this is a rough description only and the actual execution of this attack is a bit more complicated: In order to extract most of the protocols interest more calls will be needed than described above. As the initial deposit() by the attacker will have significantly increased the amount of total assets available to  Angle - Angle Protocol -   25  SecurityMediumVersion1CodeCorrected        \fthe PoolManager, the PoolManager will push a lot of funds into the strategy during the call to report (in order  to  keep  the  planned  debtRatio).  Hence  the  withdraw()  cannot  really  withdraw  sufficient amounts. Multiple calls with carefully crafted arguments to withdraw() and harvest() are necessary to complete the attack successfully and repay the flashloan.    lastBlockUpdated is now updated each time updateSanRate() is executed, this prevents the issue described above.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.13   Governance Not Fully Propagated", "body": "  The documentation specifies the following:  The Core contract has the ability to add a new governor or remove a governor from the system and propagate this change across all underlying contracts of the protocol.  Similarly, the Core contract should propagate guardian changes. However, that is not the case for some contracts.  For  example,  the  changes  are  not  propagated  to  OracleMulti  or  RewardsDistributor.  That mismatches  the  specification.  Fortunately,  the  governance  can  use  functions  grantRole()  and revokeRole() to perform the changes jointly with the functions from Core.  Specification changed:  The documentation has been updated and now describes how the governance change propagates from the Stablemaster. Additionally the code of the core contract now contains following comment:  Keeps track of all the StableMaster contracts and facilitates governance by allowing the propagation include  oracle  contract, of  changes  across  most  contracts  of  RewardsDistributor, and some  the  protocol   (does  not   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.14   Guardian Cannot Be Managed by Guardian", "body": "  The documentation specifies the following:  The guardian is indeed able to transfer its power to another address or to revoke itself.  However,  that  is  not  possible.  Core  functions  setGuardian  and  revokeGuardian  call  the  inherited grantRole() and revokeRole(). The administrator of the guardian role is the governor role. Thus, the calls grantRole() and revokeRole() would fail since the guardian is not allowed to access these and the guardian cannot set or revoke guardians.    Access control has been reimplemented. In the new implementation the guardian can transfer its power to another address or revoke itself.  Angle - Angle Protocol -   26  CorrectnessMediumVersion1Speci\ufb01cationChangedCorrectnessMediumVersion1CodeCorrected                  \f7.15   Incorrect Cash Out Amount  Existing  perpetual  positions  can  be  updated.  Any  perpetual  position  that  is  modified  through addToPerpetual or removeFromPerpetual results in the wrong cashOutAmount. Please consider the following example in which all transactions happen shortly after each other. Hence, we assume that the oracle prices do not change and are 1000 and 1125 respectively. Please note that changing oracle prices can make the problem worse. We will also ignore fees in this example.  1. A new position is created and its cashOutAmount = 10 ETH, while committedAmount = 20 ETH.  The initialRate = 1125.  2. The  position  is  updated  through  addToPerpetual  and  1  ETH  is  added.  The  new  committed amount  is  calculated  as  20  ETH  *  1125  /  1000  =  22.5  ETH.  Hence  the  new  cashOutAmount  is calculated as 20 ETH + 10 ETH - 22.5 ETH + 1 ETH = 8.5 ETH. The initialRate remains 1125.  3. The  user  performs  a  cash  out  using  cashOutPerpetual.  The  newly  committed  amount  is calculated as 20 ETH * 1125 / 1000 = 22.5 ETH. Hence the new cashOutAmount is calculated as 20 ETH + 8.5 ETH - 22.5 ETH = 6 ETH. Therefore, the user receives 6 ETH, despite depositing 11 ETH.  In short, whenever the oracle rates significantly deviate from each other, users can lose significant value. This issue can grow in severity with fees, repetitive operations and price fluctuations.    This issue has been addressed by only storing the initial rate. Hence, errors can no longer accumulate with the number of actions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.16   Non 18 Decimals Protocol Tokens", "body": "  The documentation states:  Decimals  To be consistent with the BASE chosen when computing numbers, it has been decided that all the ERC20 tokens created by the Angle protocol would involve 18 decimals.  Although this is not specified anywhere in the code, this means that the base for agTokens and sanTokens is 18.  The  decimal  of  the  sanToken  however  is  set  equal  to  the  decimal  of  the  underlying  collateral.  For collaterals with decimals different than 18, the sanTokens decimal will not be equal to 18.  function initialize(     string memory name_,     string memory symbol_,     address poolManager ) public initializer {     __ERC20Permit_init(name_);     __ERC20_init(name_, symbol_);     stableMaster = IPoolManager(poolManager).stableMaster();     decimal = IERC20MetadataUpgradeable(IPoolManager(poolManager).token()).decimals(); }  Angle - Angle Protocol -   27  CorrectnessMediumVersion1CodeCorrectedCorrectnessMediumVersion1Speci\ufb01cationChanged              \fSpecification changed:  The developer documentation will be changed to accurately reflect this.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.17   Unaccounted Collateral, Unrestricted ", "body": " updateStocksUsersGov()  Function updateStocksUsersGov of a stablemaster contract allows the Guardian / the Governance to update col.stocksUsers arbitrarily. There are no checks at all, e.g. whether the update respects the actual amount of free collateral available.  This variable is described as:  // Amount of collateral in the reserves that comes from users // + capital losses from HAs - capital gains of HAs  While  col.stocksUsers  is  updated  as  described  during  the  actions  of  stable  seekers  and  hedging agents an additional function updateStocksUsersGov exists allowing the Guardian / the Governance to change this variable arbitrarily.  Amongst others, this function is annotated with  Updates the `stocksUsers` for a given collateral to allow or prevent HAs from coming in This function can typically be used if there is some surplus that can be put in `stocksUsers`.  The system surplus arises due to the fees collected by the system. When minting or burning stablecoin only a part of the fee collected is incorporated into the sanrate. The rest remains as surplus collateral in the  poolmaster  contract.  When  creating  or  cashing  out  a  perpetual  a  fee  is  taken.  This  fee  collected resides in form of unaccounted for collateral at the poolmaster. A part of the fee must be set aside while the perpetual is active as it may be needed to pay the keeper slashing this perpetual.  Note that not all balance of the collateral token held by the poolmaster is available to use freely. Some of this balance may belong to standard liquidity providers.  Overall  there  is  no  automatic  accounting  of  the  fees  collected,  the  system  rather  relies  on  a  manual update where the caller can freely specify the parameter. The description of the function hints that the function  may  be  used  to  steer  whether  to  allow/prevent  more  HAs  from  coming  in.  Note  this  can  also steer  whether  perpetual  can  be  cashed  out  forcefully.  Allowing  the  update  of  this  value  without  any checks may let the system reach an incorrect state.    The  function  name  was  changed  to  rebalanceStocksUsers.  It  reduces  the  stocksUsers  of  one collateral and adds it to another one. However, the cap for the maximum stocks users value cannot be exceeded with this operation. Hence, the number of stablecoins minted in total stays the same. For more information see the description of System Accounting.  Angle - Angle Protocol -   28  CorrectnessMediumVersion1CodeCorrected          \f7.18   Unit Errors for Tokens With Decimals Different Than 18  Perpetuals  earn  a  reward  in  form  of  governance  tokens.  Additionally  the  staking  contract  may  allow AgToken and SanToken to be staked in order to earn governance tokens. For both, the calculation of the reward does not work correctly for collaterals with decimals different than 18.  Using the example of the PerpetualManager, the reward per committed collateral token of the perpetual is calculated as follows:  function _rewardPerToken() internal view returns (uint256) {     if (totalCAmount == 0) {         return rewardPerTokenStored;     }     return         rewardPerTokenStored + ((_lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * BASE) / totalCAmount; }  and  function _earned(uint256 perpetualID) internal view returns (uint256) {     return         (perpetualData[perpetualID].committedAmount *             (_rewardPerToken() - perpetualRewardPerTokenPaid[perpetualID])) /         BASE +         rewards[perpetualID]; }  The  governance  token,  the  angle  token  has  18  decimals.  Hence  rewardPerTokenStored  and  the returned value of _rewardPerToken() should be in 18 decimals as well for the calculation in _earn() to work correctly.  In  both  calculations  however,  BASE  is  used  as  unit  instead  of  the  actual  base  of  the  collateral.  As  a consequence, the calculation breaks for tokens not having 18 decimals.    Now, the calculations are done correctly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.19   safeApprove Not Used, USDT Not", "body": " Supported  some   Since not all ERC-20 tokens adhere to the standard, it is recommended to use safeApprove such that interactions with a broader range of tokens are possible. Especially, this is important since interactions with  function _changeTokenApprovalAmount  in  PoolManagerInternal.sol  a  simple  approve  call  is  made  with regards to the underlying pool tokens. As this method is used during the deployment of some collateral to give  infinite  approval  to  the  perpetual  manager  and  the  stable  master,  this  means  that  USDT  pools cannot be deployed.  safeApprove.   However,   tokens,   require   USDT,   e.g.   in     Angle - Angle Protocol -   29  CorrectnessMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected              \fThe new version of the code now uses either safeApprove or safeIncreaseAllowance.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.20   BondingCurve Specification Mismatches", "body": "  There  are  several  mismatches  between  the  implementation  of  BondingCurve  and  its  documentation. Examples are:   The power parameter is fixed in the implementation. However, it is not stored anywhere but instead the  formulas  have  been  implemented  assuming  power  to  be  two.  In  contrast,  the  specification states only that power should be strictly greater than one.   The documentation specifies that the guardian should have the same powers as the governors with  the exception of recovering tokens.   Moreover, the code is divided in different sections. changeOracle() is in the guardian role section. Both documentation and code structuring imply that this function should be callable by the guardian. However, only governors can call this function.  The inconsistencies may confuse users.    The specification has changed for the power parameter while the code has been corrected to restrict the guardian's power.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.21   Gas-inefficient Strategies", "body": "  The gas consumption of the strategies could reduced by reducing the storage reads. Some examples of inefficiencies in the strategies are:   _estimateAdjustPosition: the element with the highest and the element with the lowest APR are searched. The code iterates through the lenders array twice and always reads from storage. Storage reads could be reduce by a factor of two.   _removeLender: lenders[i] is read first in the if condition and then in the first line of the if  body.   _withdrawSome: in the while loop the for loop reads always from storage, hence wasting gas.    Gas consumption has been reduced for the functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.22   Inefficiency in Binary Search", "body": "  The binary search within the _piecewiseLinear function works as follows:  Angle - Angle Protocol -   30  CorrectnessLowVersion2CodeCorrectedDesignLowVersion2CodeCorrectedDesignLowVersion2CodeCorrected                        \fuint256 lower; uint256 upper = xArray.length - 1; uint256 mid = (upper - lower) / 2; while (upper - lower > 1) {     if (xArray[mid] <= x) {         lower = mid;     } else {         upper = mid;     }     mid = lower + (upper - lower) / 2; }  Here the following improvements can be made:  1. The  initial  value  of  mid  is  computed  using  the  wrong  formula  as  the  computation  should  read upper  +  lower  rather  than  upper  -  lower.  However,  it  doesn't  matter  in  the  current  code version  as  lower  is  always  initialized  to  0.  Hence,  it  is  unclear  why  lower  is  part  of  this computation.  2. The value of mid is needlessly computed once at the end of the loop. This could be refactored to  save a computation of mid.  The  gas  savings  of  these  improvements  are  negligible,  however,  they  might  contribute  to  more maintainable code.    The code is now more gas-efficient.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.23   No Slippage Protection in BondingCurve", "body": "  The  BondingCurve  contract  allows  the  purchase  of  governance  tokens  (most  likely  Angle  tokens)  in exchange for other tokens. However, the function buySoldToken does not protect users from growing prices.  The  user  could  experience  an  unexpectedly  trade  result  if  they  have  given  a  high  or  infinite approval to the BondingCurve contract.    Users  can  now  specify  the  maximum  amount  of  AgTokens  they  are  willing  to  pay  for  the  specified amount of ANGLE tokens.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.24   Reference Coin Changes May Affect the", "body": " Bonding Curve  The BondingCurve contract contains a referenceCoin variable. This referenceCoin can be set to the zero-address by being revoked. This may affect the BondingCurve in several ways:   getCurrentPrice()  will  return  the  price  in  the  reference  coin.  However,  there  is  no  reference  coin.  Angle - Angle Protocol -   31  SecurityLowVersion2CodeCorrectedCorrectnessLowVersion2CodeCorrected                \f buySoldToken() will take the oracle value based on the previous stablecoin. However, having the  0-address suggests that the reference price is currently to be determined.  Similar issues may occur if the referenceCoin is set then to another token. Now, if the oracles are not updated,  the  price  will  differentiate  highly  from  what  governance  would  have  expected.  Also,  the startPrice  variable  is  in  the  currency  of  the  reference  token.  Thus,  it  could  be  possible  that  the bonding curve changes if the start price stays the same when the reference currency changes.    The contract will be paused to give the governance time to change the parameters.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.25   Specification Mismatch in Strategy", "body": "  The documentation of rewardAmount specifies in Strategy.sol:  /// @dev If this is null rewards will never be distributed  In contrast, the documentation of setRewardAmount in Strategy.sol specifies:  /// @dev A null reward amount corresponds to reward distribution being activated  However,  if  the  reward  amount  is  null,  then  the  rewards  can  be  eventually  distributed  if  the  reward amount  is  changed.  Moreover,  the  reward  amount  being  null  means  that  the  reward  distribution  is deactivated.  Specification changed:  The specification has been changed to correctly specify the reward amount.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.26   StableMaster Might Be Unnecessarily", "body": " Paused  When  the  signalLoss  function  registers  a  loss  exceeding  sanRate  *  sanMint  it  will  pause  the StableMaster contract. However, during this calculation it does not consider any lockedInterests that  were  queued  to  increase  the  sanRate.  Hence,  when  factoring  in  the  correct  sanRate  pausing might not be necessary.    The code has been corrected.  Angle - Angle Protocol -   32  CorrectnessLowVersion2Speci\ufb01cationChangedCorrectnessLowVersion2CodeCorrected                  \f7.27   Cache Value Instead of Reading From Storage  In function update of the PerpetualManager, perpetual.fees is first updated and later read from storage in order be emitted in the event.  Caching the value would result in lower gas used.    Function _update has been removed from the PerpetualManagerInternal contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.28   Consistency Checks for Oracles Missing", "body": "  ModuleChainlinkMulti  checks  whether  circuitChainlink  and  circuitChainlinkIsMultiplied have  the  same  length.  In  contrast,  ModuleUniswapMulti  does  not  check  this  property  for  Uniswap circuits.    The check was added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.29   Different Calculation of Cashout Fees", "body": "  Should the coverage of a collateral exceed the limit, the fees for withdrawal differ depending on whether the perpetual is cashed out using forceCashOutPerpetual() or cashOutPerpetual():  In forceCashOutPerpetual() the withdrawal fee is computed with a margin of 0 (representing the status before the cashout of this perpetual).  In  cashOutPerpetual()  the  withdrawal  fee  is  computed  based  on  the  new  margin  calculated after the perpetual has been cashed out.    The  structure  of  the  two  functions  has  been  changed.  Both  initially  cashout  the  perpetual  and  then compute the withdrawal fee.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.30   Double Getters", "body": "  Angle - Angle Protocol -   33  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                                \fIn  Core.sol,  governorList()  can  be  accessed  through  the  automatically  generated  governorList getter and through the manually implemented getGovernorList(). Having only one getter will reduce code size, gas consumption on deployment, and confusion.  In OracleAbstract.sol, inBase has two getters: the automatically generated one and getInBase().    governorList was made internal and getInBase() was removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.31   Enhance Check During Deployment of", "body": " Collateral  deployCollateral()  of  the  StableMaster  contract  checks  that  the  passed  arguments  are  non-zero address before the struct for the collateral is initialized.  Some of these checks may be made more thorough with low effort:  It may be checked whether the collateral token of the perpetual manager matches the collateral.  Furthermore, it is possible to create a shared SanToken for multiple pool managers which may lead to unwanted behaviour. Also the number of decimals of the SanToken is not checked when a new collateral is deployed.  Also the oracle is not checked for compatibility with the pool manager.    Checks were added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.32   Events Missing", "body": "  Even though many events are emitted by the protocol, not all important state changes emit events. For example,  guardians  are  allowed  to  set  a  new  fee  manager  with  function  setFeeManager()  in StableMaster. As this sets a new address as a fee manager, emitting an event could help users notice this  change.  Another  example  is  that  not  all  ERC-721  events  are  emitted.  For  example,  no  events  are emitted for approvals.    ERC-721  event  are  now  emitted.  For  setFeeManager(),  an  event  was  added  to  the  StableMaster contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.33   Gas Inefficiencies When Removing From List", "body": "  Angle - Angle Protocol -   34  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fCore  keeps  track  of  governors  and  stable  masters  with  governorList  and  stablecoinList. StableMaster  keeps  track  of  all  pool  managers  with  managerList.  PoolManager  records  all  active strategies in strategyList. Each strategy registers lenders in lenders and RewardsDistributor keeps all staking contracts in stakingContractList.  In all cases, elements from the arrays can be removed. Removing a list item is always done using the following scheme (code from removing a governor in Core).  for (uint256 i = 0; i < governorList.length - 1; i++) {     if (governorList[i] == _governor) {         indexMet = 1;     }     if (indexMet == 1) {         governorList[i] = governorList[i + 1];     } } require(indexMet == 1 || governorList[governorList.length - 1] == _governor, \"governor not in the list\"); governorList.pop();  Assume  the  element  to  be  removed  is  the  first  in  the  array.  That  shifts  all  elements  by  one  position creating many storage reads and writes. Since the order of the array is not system relevant, the item to be  removed  could  be,  if  found,  overwritten  with  the  value  of  the  last  element  in  the  array,  and  the  last entry could then be popped. That would reduce the number of storage reads and writes significantly for large arrays and, hence, reduce gas consumption.    Instead of moving all element, the value of the last entry is written to the position of the element to be removed. Then, the last entry is popped.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.34   Gas Inefficiencies When Searching Lists", "body": "  When pushing a new StableMaster to stablecoinList in deployStableMaster() of Core.sol, it is checked if the item to push is already in the array. However, once found the loop continues and does not early  quit.  The  overhead  in  storage  reads  could  be  avoided  in  a  similar  way  as  in  function addGovernor().  Also, the search in _piecewiseLinear() could be optimized. Since xArray is sorted, a binary search may reduce the total number of operations if the array is large enough.    Checking whether an element is pushable to an array is now implemented using a mapping to booleans, faciliating the search. For the piecewise linear interpolation, a binary search was implemented.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.35   Governance Changes", "body": "  The documentation specifies the following:  The way a governance change occurs is that it is notified by governance (or by the guardian) to the Core which then propagates this change to all the StableMaster contracts of the protocol. Each StableMaster then notifies the AgToken contract it relates to as well as all the PoolManager.  Angle - Angle Protocol -   35  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fChanges in governance should be propagated from Core to all other contracts.  However,  usage  of  access  control  functions  inherited  from  OpenZeppelin's  contracts  may  lead  to inconsistencies.  For example following scenarios could occur:  In function removeGovernor in Core.sol, the call reverts if there is only one governor. However, it is still possible to remove the last governor by calling one of the inherited methods renounceRole or revokeRole. Ultimately, the check in removeGovernor() can easily be circumvented.   A governor may change the Core role using grantRole() and revokeRole() for a StableMaster. This may lead to inconsistencies with the core state variable in StableMasterStorage.sol. Moreover, removing or adding a guardian or governor would always revert in such a scenario (if the change is not manually undone). Also, multiple core contracts could be allowed in StableMaster.   A governor could grant or revoke a governor or guardian role to someone in Core. These changes are not propagated and may lead to inconsistencies in governance between the different contracts.    The  core  does  not  inherit  any  access  control  functionality  anymore.  The  access  control  for  Core  was customly implemented. Thus, the issues cannot occur anymore.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.36   Inconsistencies Between Staking Contract", "body": "  There are two types of staking contracts. The StakingRewards and the perpetual managers. They have similar  functionality  and  their  staking  mechanism  should  be  similar.  However,  inconsistencies  in  their implementations can be found.  Some of the inconsistencies are:   Difference  in  setNewRewardsDistributor():  The  perpetual  manager  checks  whether  a  new reward distributor contract has the same reward token as itself. StakingRewards does not do that.   Difference in emitting events: In the above function the two contracts emit different events.   Recovered event is not emitted in recoverERC20() in PerpetualManager but in StakingRewards.    The  same  events  are  now  emitted  and  the  RewardsDistributor,  the  only  contract  allowed  to  call  the staking  contracts'  setNewRewardsDistributor(),  checks  whether  the  new  rewards  distributor  has the same reward token as itself.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.37   Inconsistent Parameters in", "body": " RewardsDistributor Possible  In  contract  RewardsDistributor  consistency  checks  are  missing  and  some  parameters  could  contradict each other. Examples are:  Angle - Angle Protocol -   36  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                 \f No   check   StakingParameters.updateFrequency  StakingParameters.duration in function setUpdateFrequency.  that   is   smaller   than   No   check   that   StakingParameters.updateFrequency   is   smaller   than  StakingParameters.duration in function setDuration.    Checks were added in the mentioned functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.38   Incorrect Comment", "body": "  In PerpetualManagerFront.forceCashOutPerpetual() there is a check whether a perpetual can forcefully be cashed out due to the maximal collateralization amount has been exceeded:  // Now checking if too much collateral is not covered by HAs (uint256 currentCAmount, uint256 maxCAmount) = _testMaxCAmount(0, rateUp); // If too much collateral is covered then the perpetual can be cashed out canBeCashedOut = currentCAmount > maxCAmount ? 1 : 0;  The \"not\" in the first comment is incorrect. The code is checking if too much collateral is currently covered by HAs.  Specification changed:  The comment has been corrected to suit the modified force cashout functionality.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.39   Inefficient Structs", "body": "  There are multiple structs with multiple uint256 fields. Each of these fields uses a full storage slot of 32 bytes. Storing data in Ethereum is expensive. A significant amount of gas is used when reading from or writing  to  storage.  For  example  struct  SLPData  stores  eight  uint256.  Given  the  nature  of  the  data stored in SLPData all of these variables would not need to be of type uint256. Using smaller datatypes would  allow  to  group  multiple  of  the  variables  into  one  storage  slots.  If  done  appropriately,  this  would reduce the total amount of storage reads/writes resulting in lower gas costs. The same applies for other structs which could be optimized similarly.    Smaller  datatypes  have  been  chosen  for  some  parameters  and,  hence,  gas  consumption  has  been reduced.  Angle - Angle Protocol -   37  CorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                  \f7.40   No Check if onERC721Received Is Implemented  Perpetuals are treated as NFTs and are implemented as ERC-721 tokens. Much code is adapted from OpenZeppelin's  ERC-721  implementation.  In  createPerpetual()  of  PerpetualManagerFront.sol, _mint() is is used to mint tokens. The documentation of _mint() specifies that using this method is unsafe  and  _safeMint()  should  be  used.  However,  the  _safeMint()  method  was  removed  when code  from  OpenZeppeling  was  adapted.  The  intention  behind  this  function  is  to  check  if  the  address receiving  the  NFT,  if  it  is  a  contract,  implements  onERC721Received().  Thus,  there  is  no  check whether  the  receiving  address  supports  ERC-721  tokens  and  perpetuals  could  be  not  transferrable  in some cases.    mint() checks if a receiving contract implements onERC721Received().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.41   No Checks Performed in Constructor", "body": "  Contrary  to  the  constructor  of  ModuleChainlinkMulti,  the  constructor  of  ModuleUniswapMulti  does  not perform sanity checks on the length of _circuitUniswap and _circuitUniIsMultiplied.    The check was added to the constructor of ModuleChainlinkMulti.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.42   Outdated Compiler Version", "body": "  The project uses an outdated version of the Solidity compiler.  pragma solidity 0.8.2;  Known bugs in version 0.8.2 are:  https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json#L1530  More information about these bugs can be found here: https://docs.soliditylang.org/en/latest/bugs.html  At the time of writing the most recent Solidity release is version 0.8.6 which contains some bugfixes but no breaking changes.    In  the  meantime,  the  compiler  version  has  been  updated  to  0.8.7  which  was  also  set  in  the  hardhat configuration file.  Angle - Angle Protocol -   38  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f7.43   Overhead Due to Loading Struct Into Memory  loaded   Inside the else branch in function removeFromPerpetual the whole perpetual struct of this perpetual that  only  perpetual.creationBlock  and is  perpetual.committedAmount  are  read  later  on,  loading  the  whole  struct  into  memory  is  an unnecessary overhead.  into  memory.  Given   from  storage     The  code  of  removeFromPerpetual  has  changed  significantly,  loading  from  storage  into  memory  is now more efficient.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.44   Possibly Failing Assert", "body": "  In  UniswapUtils.sol  in  function  _readUniswapPool()  an  assert  statement  checks  if  the  cast  of twapPeriod  from  uint32  to  int32  overflowed.  However,  this  may  fail  and,  thus,  consume  all remaining gas. The usage of require, in contrast, would refund the remaining gas to the user.  Actually, the value is checked in the constructor and could be checked in function changeTwapPeriod, removing the need for checking it in every execution of _readUniswapPool().    The  check  is  now  in  the  constructor  and  the  setter.  Moreover,  the  assert  has  been  replaced  with  a require statement.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.45   Potential Confusing ", "body": " readLower(uint256 lower)  Function readLower defined in OracleAbstract returns the lower rate if parameter lower is equal to 1 or else the higher rate returned by _readAll().  The  function  name  increases  the  risk  that  the  function  is  used  incorrectly  in  the  future.  It  could  be considered to split this functionality in two functions with distinct names.    readLower() always returns the lower rate. rateUpper() was introduced to get the upper rate and avoid confusion.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.46   Reward Token Issues", "body": "  Angle - Angle Protocol -   39  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                              \fThe  documentation  specifies  that  governance  could  decide  to  choose  a  reward  token  different  from ANGLE.  Thus,  RewardDistributor  must  be  generic  in  terms  of  tokens.  However,  some  inconsistencies can be found.   event  ANGLEWithdrawn  is  emitted  in  function  governorWithdrawRewardToken.  The  event  name is inconsistent with the possible use cases.  In  _incentivize(),  the  error  message  in  the  require  statement  specifies  that  an  ANGLE transfer failed. That does not have to be the case since it could be the COMP token.   Function _incentivize uses transfer(). Non ERC-20 compliant tokens may fail, e.g. USDT is unsupported  as  a  reward  token.  Generally  when  interacting  with  unknown  ERC-20  tokens  the safeXYZ  functions  may  be  used.  These  wrappers  allow  a  safe  interaction  with  non-compliant ERC-20 tokens.  Furthermore, since rewardToken cannot be modified, it can be made immutable.    The code, comments and the naming was generalized to fit the general purpose of this class as specified in the documentation. Furthermore, safeXYZ functions are used to support a broader ranger of reward tokens. Also, rewardToken is now immutable.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.47   Specification Mismatch in OracleMath", "body": "  The  OracleMath  contract  implements  functionality  for  retrieving  UniSwap  rates.  The  documentation specifies the following:  /// @return rate uint256 representing the ratio of the two assets `(token1/token0) * decimals(token1)`  However,  this  is  not  correct.  The  specification  should  specify  that  the  rate  is  multiplied  with  base 10**decimals instead of the number of decimals.  Specification changed:  The specification was changed to document the correct base.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.48   Unnecessary Double Checks", "body": "  The Angle Protocol uses the access control library of OpenZeppelin to restrict access to some functions. However,  some  functions  have  double  checks  whether  a  caller  can  execute  a  certain  function.  This occurs when rights are granted or revoked. For example, in StableMaster.sol in deploy(), the core sets the governors and guardian. First, the onlyRole modifier of deploy() checks whether the caller has the  appropriate  role  or  not.  Then,  for  each  governor  grantRole()  is  called  from  the  access  control library. grantRole() calls the onlyRole modifier. Thus, many redundant checks are executed due to the modifier of deploy() and the repetitive calls to onlyRole modifier in the grantRole() function. Similar inefficiencies occur in other contracts and function with grantRole() and revokeRole().  Angle - Angle Protocol -   40  CorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                 \f  OpenZeppelin's access control libraries have been forked and modified such that _grantRole() and _revokeRole()  are  now  internal.  Now,  these,  instead  of  the  public  methods,  are  used  to  avoid double checks.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.49   Updated SanRate When Converting to SLP", "body": "  Function convertToSLP of the StableMaster contains following commented out code:  // we could potentially add // _updateSanRate(0, col);  This function is used during the cash out of perpetuals should there be an insufficient amount of collateral available.  It  converts  an  amount  of  collateral  into  santokens,  hence  should  be  treated  equally  as depositing  this  amount  of  collateral.  The  san  rate  should  be  updated  indeed,  this  distributes  accrued interests which have been collected before the collateral of this HA is converted into san tokens.  Note that contrary to the deposit() function, there is no check whether the stablemaster is paused.    The  line  was  uncommented.  Now,  the  sanrate  is  updated  and  it  is  checked  if  the  contract  is  paused. Thus, the behaviour is consistent with deposit().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.50   Wrong Incentive for Which Perpetuals to", "body": " Forcefully Cash Out  Whenever the covered amount of collateral exceeds the maximum allowed amount, keepers can freely choose which perpetuals to liquidate.  The  incentive  for  how  the  perpetuals  to  be  liquidated  are  chosen  may  not  be  ideal.  Although  the maximum  fee  for  the  keeper  can  be  capped  (depending  on  the  parameter  set  by  the  governance),  in general the reward for the keeper depends on the fee the perpetual has paid.   Although fees are variable, generally larger perpetuals have paid more in fees and hence may be  more attractive for keepers  to forcefully cash out.   Using functions addToPerpetual() or removeFromPerpetual() increases the fees paid by the  perpetual and hence increases the  risk of the perpetual to be selected by keepers.  For the system however, it would be more beneficial if keepers choose to liquidate perpetuals which bring the covered amount just short of the limit for the maximum amount to be covered. E.g. the coverage limit may be 90%, however currently 91% is covered. Multiple perpetuals exist, one of them may cover 2% while another covers 20%. In case a keeper cashes out the perpetual that covered 20%, the system now only  has  roughly  70%  of  its  collateral  covered,  significantly  below  the  targeted  90%.  If  the  keeper however  had  chosen  to  cashout  the  smaller  perpetual,  the  resulting  new  covered  amount  would  have been just short of the target.  Angle - Angle Protocol -   41  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedAcknowledged                  \f  The system introduced changes on how fees are computed. Keepers are now earning more fees if they cashout/liquidate perpetuals so that the covered amount is close to the target amount.  Acknowledged:  Since  now  multiple  perpetuals  can  be  liquidated  at  the  same  time,  cashing  out  multiple  perpetuals  will cost more gas than one big one. Angle acknowledged that a commented:  In a future protocol upgrade, we could weight the amount of fees going to keepers by using another piecewise linear function that depends on the number of perpetuals cashed out: this would kill the incentive to only cash out in priority the biggest perpetuals.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "7.51   capOnStablecoin May Be Violated by", "body": " Guardians  capOnStableCoin is documented as follows:  /// @notice Maximum amount of stablecoin in circulation  Assume that currently 1000 AgUSD are minted. Then a guardian may call setCapOnStablecoin and set  capOnStablecoin  invariant AgUSD.totalSupply() <= capOnStablecoin could be violated in such a scenario.  though  no  new  stablecoins  can  minted   to  500.  Even   the     capOnStablecoin  was  removed.  However,  there  is  now  a  cap  on  the  issueable  stablecoins  per collateral for which it is checked that it is always higher than or equal to stocksUser.  Angle - Angle Protocol -   42  DesignLowVersion1CodeCorrected        \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  Hence,  the mentioned topics serve to clarify or support the report, but do not require a modification inside the project. Instead,  they  should  raise  awareness  in  order  to  improve  the  overall  understanding  for  users  and developers.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "8.1   Frontrunning Keepers", "body": "  Keepers  are  responsible  to  keep  the  system  in  balance.  As  an  incentive  they  collect  part  of  the  fees. However, another party could see the transactions coming from the keepers and front run them without much computational effort. The incentive for keepers may be lost.  Note that Angle is aware of this and it's documented in the code above the respective keeper functions:  As keepers may directly profit from this function, there may be front-running problems with miners bots, /// we may have to put an access control logic for this function to only allow white-listed addresses to act /// as keepers for the protocol  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "8.2   New BASEFEE Opcode", "body": "  The recent hardfork introduced EIP-1559 and EIP-1398. While the first EIP introduces a new fee system for  transaction,  the  later  introduces  a  new  opcode  BASEFEE  allowing  to  query  the  new  basefee parameter of the transaction.  Roughly speaking the previous gasprice now consist of the basefee + a tip. Overall transaction prices are now much more predictable.  Appropriate  Keeper  rewards  should  cover  their  transaction  costs  and  an  additional  incentive.  While previously  the  GASPRICE  opcode  could  not  really  be  used  as  this  opened  possibilities  for  abuse  for miners, the new BASEFEE opcode is now much more suitable. It may be considered to use it as base for the keeper reward calculation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "8.3   Oracle-related Issues", "body": "  The system uses two different oracles: Chainlink and Uniswap.  In principle these oracles provide reliable data sources, however, it is not impossible to manipulate them. For Uniswap the cost of manipulation depends on the liquidity and the activity within the affected pools.  As  volumes  increase  within  the  system  the  following  oracle-based  attacks  become  possible.  We  split them  between  attacks  that  require  manipulation  of  one  oracle  and  attacks  that  require  manipulation  of both oracles.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "8.3.1   Single-Oracle Manipulation", "body": "   Whenever there is a big mint or burn operation of agTokens, existing system participants have an incentive  to  attack  this  mint  or  burn  with  a  manipulated  oracle.  As  a  result  the  system  will accumulate a surplus. The value of the attack is limited by the value of the mint or burn.  Angle - Angle Protocol -   43  NoteVersion1NoteVersion1NoteVersion1          \f When there an innocent user cashes out a perpetual, existing system participants have an incentive to manipulate an oracle in order to increase the system surplus. The value of the attack is limited by the value of the perpetual position.   A  malicious  user  could  perform  an  oracle  attack  to  liquidate  a  large  percentage  of  the  perpetual positions to collect the keeper fees. The value of the attack is limited by the combined keepers fees of the perpetual positions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "8.3.2   Multi-Oracle Manipulation", "body": "   A  malicious  user  can  extract  large  amounts  of  collateral  by  manipulating  both  oracles  before performing  an  agToken  burn  operation.  The  value  of  the  attack  is  limited  by  the  total  collateral deposited of this type.   A  malicious  user  can  extract  large  amounts  of  collateral  by  manipulating  both  oracles  before performing a cashout of a perpetual position. The value of the attack is limited by the total collateral deposited of this type.  As seen from the list, some of these attacks increase in impact as the system accumulates more liquidity. Hence, the risk of such attacks grows with the rise of the system and hence needs to be monitored.  Please  note  that  some  of  the  mentioned  attacks  against  other  users  can  be  evaded  through  slippage protections as mentioned in the separate issue above.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "8.4   Perpetual NFTs May Not Be Composable With", "body": " Other Protocols  Perpetual  positions  are  represented  as  NFTs.  That  allows  them  to  be  transferrable.  Thus,  users  may want to sell the NFTs on secondary marketplaces. However, the design of the NFTs is not composable with other protocols.  1. A perpetual is opened and an NFT for it is issued.  2. The user wants to sell the NFT on a marketplace. The NFT is deposited on a marketplace contract.  3. The perpetual is force-closed by a keeper. The NFT is burned.  The  marketplace,  as  the  current  owner,  receives  the  underlying  funds  while  the  NFT  gets  burned. However, the marketplace is unaware of the NFT being burned and the funds being received. Thus, the underlying funds could be lost.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "8.5   SLPs Timing Their Entry", "body": "  Although the san rate is updated before a new standard liquidity provider enters the system, a new SLP may still profit from interest accrued previously:   Due to the maximum update of the san rate in one block there may be some locked interest  which are to be distributed in the next / over the next block.   An outsider may observe the performance of the strategies and may forsee that a call to  Strategy.harvest() will be profitable.  Angle - Angle Protocol -   44  NoteVersion1NoteVersion1        \fIn  both  scenarios  an  SLP  entering  at  the  right  time  may  benefit  from  interests  accrued  before  his participations at the cost of other participants.  To mitigate both, Strategy.harvest() should be called frequently in order to distribute the rewards accrued smoothly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "8.6   Setting Variables May Lead to Inconsistent", "body": " State  When  setting  a  new  core  from  the  old  core,  it  is  ensured  that  the  governors  and  the  guardian  of  both However, cores  deployedStableMasterMap  is  not  checked.  That  should  be  ensured  in  the  constructor  of  the  new core contract. Otherwise, stable masters could be redeployed.  stablecoinList   Similarly,   checked.   same.   are   the   the   is   Moreover,  a  guardian  can  set  a  new  fee  manager  through  the  stable  master  contract.  However,  it  is never checked whether this fee manager has the same governance structure. The governance structure must be setup in the constructor.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "8.7   Special ERC-20 Token Behavior May Be", "body": " Problematic  Tokens  with  fees  or  rebasing  tokens  may  be  errorneous  if  added  as  collateral.  Some  ERC-20  tokens have transfer fees. Supporting such tokens as collateral for a stablecoin may lead to accounting errors. When a user mints some AgToken in exchange for collateral, he specifies how many collateral tokens should  be  transferred  from  him  to  the  pool  manager.  This  amount  is  used  to  update  stocksUsers. However, the amount received by the pool manager may differ from the amount specified by the user due to transfer fees. Not only would accounting issues occur but also too many AgTokens would be minted. The amount of AgTokens the user would receive depends on the amount he sent but not on the amount the  pool  manager  received.  To  conclude,  the  current  system  will  not  work  as  intended  if  tokens  have fees.  Similarly this applies for rebalancing tokens where the balance of token holders changes.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "8.8   System Accounting", "body": "  Certain system states are not tracked by the smart contracts and need to be tracked by interested users and the operators separately in order to properly react.  1. Bad  debt  and  system  surplus  are  not  obviously  visible  in  the  system  but  can  be  computed  by retracing all the relevant system actions or by through a computation based on system variables and token balances.  2. The  amount  of  stablecoins  minted  against  a  particular  collateral  (which  is  newly  saved stocksUsers)  can,  for  different  reasons,  become  out-of-sync  with  the  actual  backing  collateral. The operators need to step in by adjusting parameters accordingly.  3. Certain stablecoin-collateral imbalances can be rebalanced using the system function, however, this  only works if there is a roughly matching positive and negative imbalance.  Angle - Angle Protocol -   45  NoteVersion1NoteVersion1NoteVersion2            \f4. Certain payments, such as the fees paid by hedging agents are not being accounted but generally support the system's health. Users hence need to query token balances to evaluate collateral value.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "8.9   The Devil Takes the Hindmost", "body": "  Contrary to other similar systems, the loss of the system is not evenly distributed across all participants. For  example,  such  loss  may  stem  from  uncovered  collateral  and  a  decreasing  price,  or  keepers  not liquidating  perpetuals  timely.  In  such  situations,  the  system  continues  to  operate  normally  as  long  as there are sufficient funds available. The first actors redeeming / withdrawing their assets get everything at market  prices  while  slow  users  are  left  behind  as  they  can  no  longer  burn  their  stable  tokens,  redeem their san tokens or cash out their perpetuals due to insufficient funds.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "8.10   Transferable Perpetuals and Reward", "body": "  Perpetual  positions  are  NFT  tokens  adhering  to  the  ERC-721  standard,  hence  perpetuals  are transferable. Note that Perpetuals are eligible to earn a reward. While such a reward is associated with the NFT, holders of the perpetual should be aware that it's to their advantage to claim their reward before transferring the perpetual.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "8.11   Unbounded Decrease of sanRate", "body": "  The sanRate which is the conversion rate of SanTokens cannot increase arbitrarily to limit economic attacks. However, it can decrease arbitrarily when a strategy reports losses. Such a change is harder to exploit by an economic attacker, however, it is still possible if there exists a platform when SanTokens can be borrowed. Through such a borrow operation the sanRate drop can be exploited.  Angle - Angle Protocol -   46  NoteVersion1NoteVersion1NoteVersion2            \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/angle-protocol/"}, {"title": "6.1   Tokens With More Than 18 Decimals Not", "body": " Caught in Constructor  The constructor querries and stores the tokens decimals:  dec = gem.decimals();  Recent  JOIN  adapters,  e.g.  GemJoin7  have  an  explicit  require  statement  preventing  tokens  with decimals > 18 to initialized. This is done as additional safety measure as some integrations, e.g. proxy actions  are  incompatible  with  /  break  for  token  with  >  18  decimals.  No  such  check  is  present  in GemJoin9.    Similar  to  other  recent  GemJoin  adapters,  the  code  in  the  constructor  of  GemJoin9  now  ensures  the token decimals do not exceed 18.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-gemjoin9-for-paxg/"}, {"title": "6.2   PAXG Token Used for Tests Does Not Match", "body": " Actual PAXG Contract  The PAXG token contract added to the repository and used for tests does not match the actual PAXG contract implementation. Testing hence is done with a different token implementation than the intended token the join adapter interacts with in production which is not ideal and might hide bugs.    Forked mainnet tests have been added in the gemjoins integration tests. This ensures the code is tested with the actual PAXG token on chain.  MakerDAO - GemJoin9 for PAXG -   10  CriticalHighMediumLowCodeCorrectedDesignLowVersion1CodeCorrectedInformationalVersion1CodeCorrected              \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-gemjoin9-for-paxg/"}, {"title": "7.1   PAXG Token Is Upgradable", "body": "  The PAXG Token is upgradable and an upgrade could break the integration with gemjoin9.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-gemjoin9-for-paxg/"}, {"title": "7.2   wad Amount in Join Event", "body": "  Function  function  join(address  usr,  uint256  wad)  will  from msg.sender.  However,  fees  are  going  to  be  deducted.  Hence,  the  actually  joined  amount  will  be  the amount that arrived at the join adapter. Since the return value of the internal function _join is ignored and,  hence,  the  event  is  emitted  using  the  wad  parameter,  the  emission  will  be  incorrect.  Also,  any excess tokens will be ignored for the emitted join amount.  transfer  wad   tokens   MakerDAO  responded  that  this  behavior  is  in  line  with  the  other  gemJoins  (e.g.  join-3  or  join-7).  It's always the input amount that is logged.  MakerDAO - GemJoin9 for PAXG -   11  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-gemjoin9-for-paxg/"}, {"title": "6.1   Missing Sanity Check of Chainlink Oracle", "body": " Price  Options smart contract calculates the required ETH price by querying a YFi/ETH ChainLink oracle and the curve oracle. Apart from the price of the YFi tokens, the oracle returns information about the point in time when its price was updated. However, this information is ignored by the current implementation. The stale prices might be used for estimations.    A check that the update time of the price oracle complies with the ChainLink heartbeat parameter for the YFI/ETH pool (24 hours or 86400 seconds) was added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-oyfi/"}, {"title": "6.2   Not Initialized Variables", "body": "  On multiple occasions, some state variables are used which are never set and there are no functions that can update them. In particular:  In  Options.exercise,  ETH  is  sent  to  self.payee.  However,  this  variable  is  never  set. Hence, ETH will be sent to 0x0 address.  In  Gauge._getReward,  the  recipients  mapping  is  read.  However,  this  mapping  is  never written, thus the recipient[account] will always be 0x0. This means, that no other recipient than the owner of the Gauge tokens can receive the rewards.  Yearn - oYfi -   11  CriticalHighMediumCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedDesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                  \f   The  Options.payee  is  set  to  the  owner  in  the  constructor.  In  addition,  set_payee  function,  restricted to the owner, was added. It can change this field.   The Gauge.setRecipient function was added. It allows users to set the recipients mapping.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-oyfi/"}, {"title": "6.3   Divisions Before Multiplications", "body": "  In  the  implementation  in  the  scope,  there  are  multiple  instances  where  divisions  happen  before multiplications.  Such  sequences  of  operations  yield  less  precise  results.  In  particular,  the  following expressions can be rearranged:  In Options._eth_required,  amount * eth_per_yfi / PRICE_DENOMINATOR * discount / DISCOUNT_NUMERATOR  In Gauge._boostedBalanceOf,  ((_realBalance * BOOSTING_FACTOR) +     (((totalSupply() * IVotingYFI(VEYFI).balanceOf(_account)) /         veTotalSupply) *         (BOOST_DENOMINATOR - BOOSTING_FACTOR))) /     BOOST_DENOMINATOR,  Code partially corrected:   The Options._eth_required does the multiplications first and only then the divisions.   The  Gauge._boostedBalanceOf  is  left  unchanged.  This  numerical  imprecision  won't  affect  the functionality of the contract. No \"dust\" will be accumulated due to this because the penalty is defined in a way, that will sweep the leftover dust.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-oyfi/"}, {"title": "6.4   Sweeping Non-ERC20-Compatible Tokens", "body": "  Options.sweep allows any user to transfer any ERC20 compatible tokens owned by the contract to its owner. However, this call will fail for tokens that are not compliant with the ERC20 standard. The most prominent example is the USDT. USDT's transfer does not return any value in contrast to the ERC20 standard.  This  means  that  transfer  call  will  fail.  In  Solidity,  this  issue  is  tackled  with  the safeTransfer call (see Openzeppelin's safeERC20).    The default_return_value=True parameter was added in the Options.sweep token transfer call, that enables safeTransfer functionality in Vyper smart contracts.  Yearn - oYfi -   12  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-oyfi/"}, {"title": "7.1   EIP-4626 Event Field Names", "body": "  Event  Deposit  and  event  Withdrawal  in  IERC4626  are  defined  with  address  indexed  caller. According  to  the  https://eips.ethereum.org/EIPS/eip-4626#events,  these  fields  should  be  named  as sender.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-oyfi/"}, {"title": "7.2   Full YFI Locked Discount Reverts", "body": "  In  the  case  of  the  quite  improbable  event,  when  the  total  supply  of  Yfi  is  locked  in  veYfi,  the  discount cannot be computed.  DISCOUNT_TABLE[total_locked * DISCOUNT_GRANULARITY / total_supply]  The DISCOUNT_TABLE has 500 elements. However, the max index is 499. This index access during the computation will revert, if total_locked == total_supply, because the element with index 500 is not present in the DISCOUNT_TABLE.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-oyfi/"}, {"title": "7.3   Incorrect Documentation", "body": "  In OYfiRewardPool.burn, the documentation reads as follows:  @notice Receive YFI into the contract and trigger a token checkpoint  The documentation is incorrect as OYFI is transferred instead of YFI.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-oyfi/"}, {"title": "7.4   Missing Indices in Events", "body": "  For some events, some arguments are not indexed even if this would make sense. In particular:  In Options.Sweep, the token argument could be indexed.  In Gauge.BoostedBalanceUpdated, the account argument could be indexed.  Yearn - oYfi -   13  InformationalVersion1InformationalVersion1InformationalVersion1InformationalVersion1                  \f7.5   Non-informative Error Message  BaseGauge.queueNewRewards  checks  whether  the  _amount  argument  is  non  0.  Should  this  check fail,  the  non-informative  ==0  message  will  be  returned.  Note  that  Solidity  0.8  allows  for  error  values instead of just strings to be returned upon check failure.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-oyfi/"}, {"title": "7.6   Redundant Function Modifiers", "body": "  Multiple functions are defined using a public modifier, while they are not called within the contract. These functions could be set as external instead:   Gauge.convertToShares   Gauge.convertToAssets   Gauge.maxDeposit   Gauge.previewDeposit   Gauge.maxMint   Gauge.previewMint   Gauge.kick  Solidity  compiler  needs  to  perform  extra  routines  for  public  functions,  which  can  result  in  higher  gas usage.  Yearn - oYfi -   14  InformationalVersion1InformationalVersion1      \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-oyfi/"}, {"title": "8.1   Gauge Assumed Decimals", "body": "  The  Gauge  contract  uses  default  18  decimals.  However,  the  asset  can  have  a  different  number  of decimals. While the Yearn vault tokens have 18 decimals, this might not be true for any asset that might be used in Gauge. If an asset with a different number of decimals is introduced, the respective Gauge will misbehave.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-oyfi/"}, {"title": "8.2   Manipulation of Curve Oracle", "body": "  Options  calculates  the  price  of  YFI/ETH  by  querying  the  price  oracle  of  the  respective  Curve-pool. Curve  uses  a  time  weighted  price  oracle  or  (TWAP-oracle).  TWAP  oracles  have  been  shown  to  be manipulatable to an extent. Users should be aware that the system in scope does not perform any further sanity checks on the correctness of the reported price.  Yearn - oYfi -   15  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/yearn-oyfi/"}, {"title": "5.1   Execution Data Is Not Validated", "body": "  0  0  2  5  The executors always provide some execution data for the execution of the trigger. However, this data should correspond to the trigger's intention, but is not validated for the most part. Note that it still is limited in its ability to act maliciously because of the post-execution checks.  CS-OazoAutomV2-001  Risk accepted:  Summer.fi accepts the risk.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "5.2   Execution Reentrancy May Be Possible", "body": "  Commands delegate calls to action smart contracts to act on the user's position. However, some of these action smart contracts can contain logic that would permit other external contracts.  CS-OazoAutomV2-002  Summer.fi - Automation V2 -   13  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedRiskAcceptedLowCodePartiallyCorrectedRiskAcceptedRiskAcceptedRiskAcceptedRiskAcceptedRiskAcceptedSecurityMediumVersion3RiskAcceptedSecurityMediumVersion3RiskAccepted                     \fIn  this  case,  external  contracts  could  contain  malicious  code  that  could  reenter  the  core  contracts  to add/remove triggers, or simply temper with the user's position.  Risk accepted:  Summer.fi accepts the risk.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "5.3   Future Debt Validation Does Not Take Bounds", "body": " Into Account  In  the  BasicSellCommand,  the  post-execution  debt  is  computed  in  isExecutionLegal()  to  validate that it will be bigger than the dust limit of the cdp's ilk:  CS-OazoAutomV2-003  uint256 futureDebt = (debt * nextCollRatio - debt * wad) /     (trigger.targetCollRatio.wad() - wad);  Note that in this computation the target collateralization ratio is accounted as is and used to predict future debt. However, the post-execution cdp's debt might not exactly correspond to this collateralization ratio, this is the reason behind the existence of the deviation parameter.  This makes it possible for the isExecutionLegal() function to return true even though execution will fail afterward because the debt is smaller than the dust limit.  Code partially corrected and risk accepted:  Now,  the  upper  bound  for  the  collateralization  ratio  is  used.  However,  this  will  yield  the  minimal  value futureDebt  could  reach.  Hence,  the  function  could  return  false  in  some  scenarios  where  the execution could be legal.  However, Summer.fi accepts the risk.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "5.4   Negative gasRefund Possible", "body": "  gasRefund should be used to decrease the necessary coverage according to the gas refunds. However, it is of type int and, hence could be negative so that the computation  CS-OazoAutomV2-004  uint256(int256(initialGasAvailable - finalGasAvailable) - gasRefund);  could increase the gas used instead of lowering it.  Note that with the current trust model, the executor providing this gas refund value should not be trusted.  Risk accepted:  Summer.fi - Automation V2 -   14  DesignLowVersion1CodePartiallyCorrectedRiskAcceptedCorrectnessLowVersion1RiskAccepted                  \fSummer.fi states that no changes were made since calls come from trusted callers. However, disallowing negative numbers (e.g. by using uint256) could help. Hence, Summer.fi accepts the risk.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "5.5   Overflow When Computing the Used Gas", "body": "  The cast from int256 to uint256 could overflow in the following code  uint256(int256(initialGasAvailable - finalGasAvailable) - gasRefund);  if gasRefund is greater than the computed gas used.  CS-OazoAutomV2-005  Risk accepted  The  gas  refund  is  limited  now  by  10**12.  However,  this  does  not  protect  against  bad  gasRefund argument since it could still be greater than (initialGasAvailable - finalGasAvailable).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "5.6   Too Low execCollRatio", "body": "  In BasicSell, the execCollRatio could be below the liquidation ratio. Hence, the trigger validity check could allow an unexecutable trigger to be added.  CS-OazoAutomV2-006  Risk accepted:  Summer.fi replied that the data is validated with the calldata creation on the front-end.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "5.7   Too Low slLevel", "body": "  In CloseCommand, the slLevel could be below the liquidation ratio. Hence, the trigger validity check could allow an unexecutable trigger to be added.  CS-OazoAutomV2-007  Risk accepted:  Summer.fi replied that the data is validated with the calldata creation on the front-end.  Summer.fi - Automation V2 -   15  CorrectnessLowVersion1RiskAcceptedDesignLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  2  3  2  14  -Severity Findings   Arbitrary Actions and Storage Manipulations    Executor Could Draw an Unbounded Amount of Coverage   -Severity Findings   Executing a DPM Command Reverts    Removing Arbitrary Triggers Possible    Upgrades Break AutomationBot   -Severity Findings   Possible Reentrancy Through Execution    addRecord() Does Not Unlock   -Severity Findings   Wrong Event Argument   Incorrect Argument for ApprovalGranted Event    Bad Trigger Ids Emitted    Command Validation Functions Can Revert    Contracts Do Not Extend the Interfaces    Group Counter Starts at 2    Left Comments    Missing Validation in AutoTakeProfitCommand    Redundant Approval    Removing Non-Callers Emits an Event    Specification Mismatches    Unequal Array Lengths    Unused Imports    Unused Parameter, Variable and Event   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.1   Arbitrary Actions and Storage Manipulations", "body": "  CS-OazoAutomV2-011  The  owner  of  the  ServiceRegistry  could  perform  arbitrary  storage  manipulations  and  actions  on  any (in  executePermit()  and position.  Namely,  executeCoverage()) allows them to execute arbitrary code in the context of the storage contract. In  the  storage  contract   the  delegatecalls   in   Summer.fi - Automation V2 -   16  CriticalCodeCorrectedCodeCorrectedHighCodeCorrectedCodeCorrectedCodeCorrectedMediumCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSecurityCriticalVersion3CodeCorrected         \faddition, a malicious command could be added along with its adapter so as to execute malicious actions on a user's position.  Let's consider different scenarios for understandability reasons:  Modifying storage in AutomationBotStorage:  1. Command X is added to the ServiceRegistry, it is a no-op command and is immediately executable.  2. Adapter X is also added.  3. The owner calls addRecord() to add a record for the command.  4. execute() happens. Arbitrary code is executed during the delegatecall made in adapter X.  Executing a malicious command:  1. Command X is added to the ServiceRegistry, it is a command that can, given a position, unwind all  funds to the owner's address and is immediately executable.  2. Adapter X is also added, its canCall() function always return true.  3. The owner calls addRecord() to add a record for the command and is allowed to do so.  4. execute() happens. Arbitrary code is executed during the execute made in AutomationBot and  funds are stolen.  Ultimately, the service registry owner may self-destruct the contract, change any storage locations, and execute any operations on any position that the AutomationBotStorage has allowance on.  Note that there are many possibilities when adding arbitrary commands and adapter, and the examples listed above are non-exhaustive.  ---    Summer.fi has changed the design. Users approve adapters which are callable by the automation bot.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.2   Executor Could Draw an Unbounded Amount", "body": " of Coverage  CS-OazoAutomV2-026  The typical execution flow of a trigger is  1. Pre-condition checks.  2. Getting the coverage with getCoverage() so that the user pays for the fees.  3. Execution.  4. Post-condition checks.  Note that getCoverage() will typically create additional debt which changes also the collateralization ratio, and that the coverage amount is not bounded upwards.  A  trigger  could  potentially  be  non-executable  before  the  execution  but  become  executable  once getCoverage() has been called.  This gives the executor an ability to execute some triggers on demand.  Further  note  that  there  can  be  other  unforseeable  consequences,  but  they  are  limited  by  the post-execution validation.  Summer.fi - Automation V2 -   17  SecurityCriticalVersion3CodeCorrected        \f created an alternative for getting arbitrary coverage that severly amplifies the The changes in  owners  possibilities.  With  this  new  version,  the  executable  adapters  alway  holds  permissions  for  the position  (if  set  up  correctly),  so  that  it  can  draw  coverage  when  needed.  Now  consider  the  following scenario, where the governance would want to draw excessive coverage on a target position:  1. Governance adds a malicious command along with a malicious security adapter assigned to it. The malicious adapter returns true on canCall calls and the command allows execution but does not perform any operation. They also assign to the command a legit executable adapter, the one that the target position permitted to.  2. Governance adds a trigger record with the trigger data pointing to the target position, and using the  malicious command.  3. Execution occurs (governance has control over the executors) and the excecution adapter is called to get coverage and can (nearly) drain the target position. The maxCoverage variable was passed along the malicious triggerData in step 2, so can be arbitrary.    A user-defined maximum and a payment token has been introduced. The executable adapter is now only granted permissions when getting the coverage.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.3   Executing a DPM Command Reverts", "body": "  A  typical  command  execution  flow  of  AutomationExecutor's  execute()  function  is  as  follows  (some steps are omitted for clarity):  CS-OazoAutomV2-016  1. Giving permissions to the command address  2. Calling the command to execute  3. Disallowing the command  Note  that  when  the  automation  bot  permits  the  command  address,  it  delegates  the  call  to  the  specific adapter.  This  should  work  because  the  automation  bot  was  already  permitted  when  the  trigger  was added.  In the case of the DPMAdapter, the permit() function starts with this line:  require(canCall(triggerData, msg.sender), \"dpm-adapter/not-allowed-to-call\");  This is executed in the context of the AutomationBot, so the msg.sender is still the AutomationExecutor, which has not been permitted by the owner of the proxy. The execution call will fail in all cases except when the owner of the proxy has manually permitted the AutomationExecutor.    Summer.fi changed msg.sender to address(this).  Summer.fi - Automation V2 -   18  Version4DesignHighVersion1CodeCorrected          \f6.4   Removing Arbitrary Triggers Possible  CS-OazoAutomV2-024  addRecord() adds a trigger and allows to replace a given trigger id and data with.  The following check is performed:  require(     replacedTriggerId == 0 || adapter.canCall(replacedTriggerData, msg.sender),     \"bot/no-permissions-replace\" );  However, following issues arise:  1. replacedTriggerData   is  not  validated   to  match   the  replacedTriggerId   (as   in  checkTriggersExistenceAndCorrectness()).  2. The  security  adapter  for  the  new  command  is  used.  However,  the  replaced  trigger  id  may  be  another command that has another adapter.  Users relying on the execution could be liquidated or miss out on profit scenarios.    replacedTriggerData is now checked against the hash of the replacedTriggerId since  . The original adapter is used since   .  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.5   Upgrades Break AutomationBot", "body": "  The split of the storage from the AutomationBot intends to  [...] enable the upgradeability of AutomationBot implementation without the need for migration for all of the triggers.  However, note that the AutomationBot contract is given permissions for the positions but changing the address does not transfer the permissions. Ultimately, no previous triggers can be executed.  CS-OazoAutomV2-030    Now,  the  AutomationBot  does  not  hold  any  permissions.  However,  permissions  are  granted  to  the storage  contract.  Thus,  the  AutomationBot  calls  functions  on  the  storage  contract  that  can  grant commands the necessary rights.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.6   Possible Reentrancy Through Execution", "body": "  CS-OazoAutomV2-015  Summer.fi - Automation V2 -   19  SecurityHighVersion1CodeCorrectedVersion2Version3CorrectnessHighVersion1CodeCorrectedSecurityMediumVersion1CodeCorrected                      \fWhen a caller executes a trigger, the automation bot permits the specific command to act on the target position/cdp  for  the  execution  call  and  removes  this  permission  after  it.  To  execute  a  trigger  the execute() function is called on the command. Note that none of the implementations of this function have access control or reentrancy protection. On execution, external smart contracts that belong to third parties will be called and it can lead to reentrancy possibilities. Entering again the execute() function would then be possible.    Now, the AutomationBot and the commands have reentrancy locks. Given that only a command at a time is granted permissions, this protects commands from being malicously executed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.7   addRecord() Does Not Unlock", "body": "  addRecord() adds new triggers. It calls lock() to ensure that emitGroupDetails() has the right calldata.  However,  note  that  emitGroupDetails(),  which  unlocks  the  lock  counter,  is  only  called  if addRecord() is used through addTriggers(). Note that this is not necessarily the case. Hence, the contract  could  temporarily  be  locked  by  direct  calls  to  addRecord()  (without  using  the  proxy  actions function addTriggers()). Calling addTriggers() would revert because of the inconsistency between the emit group details and the lockCount.  CS-OazoAutomV2-021    The  lock  is  always  cleared  using  the  new  function  clearLock()  in  addTriggers()  and removeTriggers().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.8   Wrong Event Argument", "body": "  In  the  AutomationBot  smart  contract,  both  events  ApprovalGranted  and  ApprovalRemoved  are emitted  with  the  AutomationBot  address  as  argument,  when  the  permission  is  actually  granted  to  or removed from adapters.  CS-OazoAutomV2-032    The correct argument is now used.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.9   Incorrect Argument for ApprovalGranted", "body": " Event  CS-OazoAutomV2-019  Summer.fi - Automation V2 -   20  CorrectnessMediumVersion1CodeCorrectedCorrectnessLowVersion4CodeCorrectedCorrectnessLowVersion2CodeCorrected                        \fThe  event  ApprovalGranted(bytes  indexed  triggerData,  address  approvedEntity) should pass the approved entity as second argument. In AddTriggers(), the approval is granted to the AutomationBotStorage but the argument specifies the automationBot.  Code corrected  The correct argument is now used.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.10   Bad Trigger Ids Emitted", "body": "  The addTrigger() function triggers a call to emitGroupDetails() with bad trigger ids.  CS-OazoAutomV2-013  Consider the following scenario:  1. addTriggers() is used.  2. firstTriggerId is 0 since no triggers have been added so far.  3. addRecord() is called.  4. appendTriggerRecord() is called. The trigger is added with id 1 and the trigger counter is set to  1. The call returns.  5. addRecord() emits an event with trigger id 1 and returns.  6. addTriggers() sets the local variable triggerIds[0] to 0.  7. An event is emitted with the wrong id.  Ultimately, events with errors are emitted.    The first trigger id is now computed correctly (triggers counter + one).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.11   Command Validation Functions Can Revert", "body": "  Command  smart  contracts  implement  3  different  data/execution  flow  validation  functions  that  return  a boolean:  CS-OazoAutomV2-031   isTriggerDataValid()   isExecutionLegal()   isExecutionCorrect()  All of those are wrapped in a require() in the automation bot so that the trigger data is valid and the pre and post-execution conditions also are.  However,  some  of  these  functions  in  AutoTakeProfitCommand  fail  on  some  conditions  instead  of  just returning false:  1. If the owner of the cdp is the address 0 in isExecutionLegal()  Summer.fi - Automation V2 -   21  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f2. If the trigger execution price is greater than the next price in isTriggerDataValid()    The functions return false now.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.12   Contracts Do Not Extend the Interfaces", "body": "  Most  of  the  contracts  interact  with  each  other  based  on  the  interface  definitions.  For  example,  the addTrigger()  call  BotLike.addRecord()  on  the  AutomationBot.  However,  the  AutomationBot contract  itself  does  not  explicitly  implement  the  BotLike  interface.  Similarly,  other  contracts  do  not implement interfaces.  Without this, there are no compile-time guarantees that the contract will be compatible with the calls to the functions that the interface defines. This can lead to potential runtime errors and exceptions that are hard  to  debug.  It  is  important  to  explicitly  define  that  the  contracts  implement  the  corresponding interfaces, to minimize such errors.  CS-OazoAutomV2-017    The usage of interfaces has been improved.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.13   Group Counter Starts at 2", "body": "  Why does the group counter start at 2 when AutomationBot emits the first TriggerGroupAdded event?  CS-OazoAutomV2-018    The group counter starts now at 1.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.14   Left Comments", "body": "  Several TODOs are left open. Additionally, other comments are left. For example,  or type ? do we allow execution of the same command with new contract - waht if contract rev X is broken ? Do we force migration (can we do it)?  CS-OazoAutomV2-020  Such comments can increase complexity.  Summer.fi - Automation V2 -   22  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f  The comments have been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.15   Missing Validation in", "body": " AutoTakeProfitCommand  The AutoTakeProfitCommand smart contract takes care of closing a cdp when its collateral has reached a certain price. This kind of trigger should not be continuous because of the way this command works.  However, isTriggerDataValid() does not check wether it is or not.  CS-OazoAutomV2-012    Now, only non-continous triggers are valid for AutoTakeProfitCommand.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.16   Redundant Approval", "body": "  The  AutomationExecutor  approves  Uniswap's  router  contract  twice  which  increases  gas  consumption and adds additional complexity.  CS-OazoAutomV2-022    The redundant approval was removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.17   Removing Non-Callers Emits an Event", "body": "  Removing non-callers emits a CallerRemoved event. In contrast, adding callers that are already callers skips the event emission.  CS-OazoAutomV2-023    Only callers can now be removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.18   Specification Mismatches", "body": "  Note that there are multiple specification mismatches:  CS-OazoAutomV2-025  Summer.fi - Automation V2 -   23  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                                \f1. BasicSellCommand  implies  trigger.execCollRatio.wad()  >=  nextCollRatio  which  contradicts the code in the equality case.  2. The documentation describes maxBuyPrice instead of minSellPrice.  3. The  documentation  states  that  Automation  Bot  is  a  stateless  contract.  However,  it  has  a  state  variable lockCount.  4. The  adapter  section  specifies  that  adapters  are  delegatecalled  in  the  AutomationBot  context. However,  the  functions  introduced  functions  executePermit()  and  executeCoverage() changed this behaviour since they are delegatecalled from the storage contract now.  Specification corrected  All 4 points were correct in the documentation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.19   Unequal Array Lengths", "body": "  In  addTriggers(),  the  array  parameters  could  have  distinct  lengths.  The  execution  in  such  cases  is unspecified. Similarly, this holds for removeTriggers().  CS-OazoAutomV2-027    All arrays are not checked against for length.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.20   Unused Imports", "body": "  Some smart contracts have some unused imports, some examples are:  CS-OazoAutomV2-028  In AutomationExecutor:  1. FullMath  2. IExchange  3. ICommand  In BaseMPACommand:  1. AutomationBot  In McdView:  1. ICommand  2. BotLike  Note that this is an incomplete list of examples.    Summer.fi - Automation V2 -   24  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fAll unused imports have been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.21   Unused Parameter, Variable and Event", "body": "  1. The function AutomationExecutor.execute() has an unused parameter cdpId.  2. AutomationExecutor stores the DAI address as an immutable which is unused.  3. The AutomationBot has an event ApprovalGranted that is not used.  4. AUTOMATION_BOT_STORAGE_KEY is unused in AutomationBot.  CS-OazoAutomV2-029    The event ApprovalGranted is now used and the others have been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.22   The CloseCommand Does Not Inherit", "body": " BaseMPACommand  The CloseCommand smart contract does not inherit the BaseMPACommand smart contract even though it executes through the MPA.  CS-OazoAutomV2-014    Inheritance was improved.  Summer.fi - Automation V2 -   25  DesignLowVersion1CodeCorrectedInformationalVersion1CodeCorrected              \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "7.1   Floating Dependencies Version", "body": "  The  versions  of  the  contract  libraries  in  package.json  are  not  fixed.  Please  consider  the  following examples:  CS-OazoAutomV2-009  \"@openzeppelin/contracts\": \"^4.5.0\"  The caret ^version will accept all future minor and patch versions while fixing the major version. With new versions being pushed to the dependency registry, the compiled smart contracts can change. This may lead to incompatibilities with older compiled contracts. If the imported and parent contracts change the  storage  slot  order  or  change  the  parameter  order,  the  child  contracts  might  have  different  storage slots or different interfaces due to inheritance.  In addition, this can lead to issues when trying to recreate the exact bytecode.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "7.2   Floating Pragma", "body": "  Summer.fi uses a floating pragma solidity ^0.8.13. Contracts should be deployed with the same compiler version and flags that have been used during testing and audit. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce  bugs  that  affect  the  contract  system  negatively,  see  https://swcregistry.io/docs/SWC-103 (snapshot).  CS-OazoAutomV2-010  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "7.3   Unecessary External Calls", "body": "  The  AutomationBot  smart  contract  must  sometimes  call  itself  because  of  the  delegate  logic,  however there are cases where this is not necessary:  CS-OazoAutomV2-008  1. In the emitGroupDetails() function  2. In the addRecord() function  Note that both of these function call automationBot like an external contract, but will not be called in a delegate context.  Summer.fi - Automation V2 -   26  InformationalVersion1InformationalVersion1InformationalVersion4          \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "8.1   AutomationBot Permission Handling", "body": "  It should be made clear to the user and in the documentation that the functions addTriggers() and removeTriggers() are only helper functions, and that data must be provided in certain ways so that the system works correctly.  For  example,  triggers  will  not  be  able  to  execute  if  a  user  adds  multiple  triggers  that  point  to  different positions/cdps through addTriggers() without manually granting permission to the AutomationBot for each of these (except the first one).  removing  multiple   Also,  through removeTriggers()  will  only  remove  the  allowance  for  the  first  position/cdp  pointed  by  the  trigger  at index 0.  the  removeAllowance   triggers  with   flag  set   true   to   Further,  a  user  could  have  cleared  all  of  their  triggers  but  still  have  some  active  permission  on  the AutomationBot for their positions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "8.2   Data for Execution", "body": "  The data for the execution can be freely selected by the callers. There are the following limitations:   Post-conditions of the command must hold.   Selectors are validated in commands.  However, users should be aware that the coverage token can be an arbitrary token (e.g. if Aave position is managed) and, hence, the execution could lead to unwanted risks (e.g. being exposed to very volatile tokens).  Further,  users  should  be  aware  that  the  execution  could  be  configured  so  that  re-executions could occur faster.  Ultimately,  users  should  always  consider  the  possibility  of  bad  execution  data.  However,  note  that  the callers are trusted addresses.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "8.3   Oracle Not Suitable for On-Chain Usage", "body": "  AutomationExecutor  implements  an  oracle  for  Uniswap  V3  TWAP  prices.  This  is  intended  to  be  used off-chain. Using the oracle on-chain could lead to issues.  First,  the  TWAP  is  hardcoded  to  60  seconds  which  would  allow  for  simple  manipulations.  Second,  the function iterates over a list of pools and tries to choose the biggest one. It does so by selecting the one with the highest WETH balance. However, this is not a safe value for estimating actual pool size. Note that there are some further discrepancies compared to Uniswap V3's reference implementation of price oracle. For example, AutomationExecutor adds one to the TWAP interval array values (which Uniswap  Summer.fi - Automation V2 -   27  NoteVersion1NoteVersion1NoteVersion1          \fdoes not), does not round down to negative infinity (which Uniswap does) and does not have a precision of computation as high as Uniswap in some scenarios.  Generally, the oracle-like getters are not suitable for on-chain usage. Also, the off-chain usage must be done carefully.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "8.4   getCoverage() Implications", "body": "  The typical execution flow of a trigger is  1. Pre-condition checks.  2. Getting the coverage with getCoverage() so that the user pays for the fees.  3. Execution.  4. Post-condition checks.  Note that getCoverage() will typically create additional debt which changes also the collateralization ratio.  Users should be aware that in the BasicBuy command, where a precondition is that the collateralization ratio must be above a certain threshold, could technically be violated after getCoverage(). Hence, the execute function could be executed on a vault where the collateralization ratio is below the threshold.  Further  note  that  there  can  be  other  unforeseeable  consequences.  Users  should  be  aware  that  the configuration requires consideration of the coverage.  In  aware of this and configure their positions accordingly.  ,  Summer.fi  repeats  the  precondition  checks  after  getting  the  coverage.  Users  should  be  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "8.5   getTick Computes the Square Root Price", "body": "  The naming of getTick() suggests that a tick is returned. However, it computes the square root price.  Summer.fi - Automation V2 -   28  NoteVersion1Version4NoteVersion1        \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/summer-fi-automation-v2-smart-contracts/"}, {"title": "6.1   No Protection for Keepers", "body": "  Generally, keepers may just be interested in collecting the penalty of failing offers. In Mangrove however, an  offer  could  always  succeed  unexpectedly  due  to  changing  on-chain  conditions.  In  this  case,  a keeper/taker may have executed an offer he did not actually intended to take and which may had a bad exchange rate. Note that offers may only fail when significant amounts of tokens are flashloaned to the maker up front but the very same offer may succeed for lower amounts.  Unaware keepers may be tricked by honeypot offers (offers that appear to fail but in reality don't fail) by malicious makers.  Keepers may protect themself by wrapping their call in a smart contract and checking for the expected outcome, but the code of Mangrove itself does not offer such a feature directly.  Risk Accepted:  Giry responded: Indeed all keepers should wrap their calls in a reverting contract. This protective wrapper does not need to be inside Mangrove. We plan to provide a standard wrapper at a separate address.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "6.2   ECDSA Signature Malleability", "body": "  Giry - Mangrove -   14  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedLowRiskAcceptedAcknowledgedAcknowledgedRiskAcceptedDesignMediumVersion1RiskAcceptedDesignLowVersion1RiskAccepted                   \fThe permit function utilizes the ECDSA scheme. However missing checks for the v, r and s arguments allow  attackers  to  craft  malleable  signatures.  According  to  Yellowpaper  Appendix  F,  the  signature  is considered valid only if v, r and s values meet certain conditions. The ecrecover for invalid values will return address 0x0 and verification will fail without informative error. The OpenZeppelin's ECDSA library performs such checks and reverts with informative messages.  Risk Accepted:  Giry responded: Code changes necessary for improved error messages would go past the contract size limit.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "6.3   No Minimum Value for gasreq", "body": "  Either to create a new offer or to update an existing one, the maker must provide a value for gasreq. In the current implementation, there is no minimum required value. The value for gasreq may even be set to 0, which means 0 gas requirements for the calls executed on the maker's side. Nevertheless, both calls are  executed,  the  first  call  to  makerExecute  with  all  gas  defined  in  gasreq  and  the  second  to makerPosthook with the \"leftover\" gas from gasreq. With 0 gas these low-level calls are started but immediately revert. The system could allow these calls to be skipped when the maker sets a zero / low amount for gasreq.  Acknowledged:  Giry  responded:  The  gas  saved  by  treating  0-gasreq  as  a  special  case  is  not  worth  the  added  code complexity.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "6.4   Redundant Check in writeOffer", "body": "  When writeOffer is called a check that ofp.gives > 0 is performed. However, the check presented below  is  also  performed  and  implies  the  same  since  both  density  and  gasbase  should  be  positive under normal circumstances.  ofp.gives >=   (ofp.gasreq + $$(local_offer_gasbase(\"ofp.local\"))) *     $$(local_density(\"ofp.local\")),  No Issue:  Giry responded: It is possible for governance to set values such that the second check does not imply the first. The first check maintains a critical invariant.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "6.5   Spamming the Offerbook", "body": "  Giry - Mangrove -   15  DesignLowVersion1AcknowledgedDesignLowVersion1AcknowledgedSecurityLowVersion1RiskAccepted                        \fAn  attacker  may  spam  the  offerbook  with  attractive  offers  reverting  immediately  upon  execution. Depending  on  the  parameters  chosen  by  the  governance  for  density  and  offer_gasbase  the resulting minimum penalty paid for the failing offer may be rather low.  Notably it is sufficient to have 85 such failing offers in the offer book (offering a very low price to ensure to be  on  top)  to  cause  a  revert  of  the  transaction  due  to  an  EVM  stack  too  deep  error.  Hence  any transaction to marketOrder() of this base/quote pair will revert leaving the state unchanged.  It's  still  possible  for  keepers  to  clean  the  offerbook  by  sniping  these  offers,  however  such  offers  may reinstantiate themself during the makerPosthook().  Risk Accepted:  Giry responded: Any self-reinserting spam is vulnerable to draining by any keeper.  Giry - Mangrove -   16    \f7   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings   Draining All Ether Provisions of Mangrove   -Severity Findings  -Severity Findings  If Condition Always True    Rounding Errors In Partial Filling   -Severity Findings   Call in makerPosthook Fails Silently    Fields of Events Not Indexed   Imprecise Comment    Maximize Penalty Collected    Misleading Variable Names in stitchOffers    Overrestrictive Check in deductSenderAllowance    Repetitive Code   1  0  2  7  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "7.1   Draining All Ether Provisions of Mangrove", "body": "  Makers can retract their offer by calling retractOffer(). This function accepts the boolean parameter deprovision which allows the maker to choose to either deprovision the offer or not.  Deprovisioning an offer credits back the provision to the maker. At the same time it must be ensured that this  offer  is  removed  from  the  offerbook  and  its  gasprice  must  be  set  to  0  as  the  offer  is  no  longer provisioned.  Not all possible cases are handled correctly inside function retractOffer(). For offers that are not live (this means they have a 0 amount for offer.gives) the provision can be credited back to the maker without the offer's gasprice being set to zero.  Hence  retractOffer()  with  deprovision  set  to  true  can  be  executed  successfully  repeatedly. Consequently a maker can reclaim more provision than he initially paid for the offer. This bug allows to eventually drain all Ether of Mangrove.  An offer can easily reach offers.gives = 0 which means it is considered to not be live:   By  calling  retractOffer()  with  bool  deprovision  set  to  false,  dirtyDeleteOffer()  is executed. This call sets offer.gives to zero however without setting offer.gasprice to zero due to deprovision being false.   After the offer has been consumed by an order offer.gives is 0.  Giry - Mangrove -   17  CriticalCodeCorrectedHighMediumCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSecurityCriticalVersion1CodeCorrected          \fCode Corrected:  The  call  to  dirtyDeleteOffer()  was  moved  out  of  the  isLive  scope.  Hence  whenever deprovision is set to true and the provision is credited back to the Maker, the order is deprovisioned. Calling the function repeatedly on the same offer no longer allows to drain Ether of Mangrove, the issue has been resolved.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "7.2   If Condition Always True", "body": "  During the execution of function execute the following check is performed:  if (statusCode != \"mgv/notExecuted\") {   dirtyDeleteOffer(     ...   ); }  However statusCode cannot have the value mgv/notExecuted at this point so the condition is always true.  Code Corrected:  The code now runs unconditionally.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "7.3   Rounding Errors In Partial Filling", "body": "  A maker's order can be partially filled according to the following snippet:  if (mor.fillWants) {    sor.gives = (offerWants * takerWants) / offerGives;  } else {    sor.wants = (offerGives * takerGives) / offerWants;  }  Note that the division can yield rounding errors. The rounding errors can be as extreme as giving funds to the maker without receiving anything in return or taking from the maker without giving anything back. For example,  consider  the  case  where  the  maker  offers  10  A  for  5  B  and  taker  wants  to  take  only  1  A (fillWants == true). Then, according to the formula she has to offer 5 * 1 / 10 = 0 B.  Code corrected  Prices are now always rounded in favor for the taker to avoid any maker draining. Hence, to calculate sor.gives when fillWants is true the code has been changed to:  Giry - Mangrove -   18  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \fuint product = offerWants * takerWants; sor.gives =   product /   offerGives +     (product % offerGives == 0 ? 0 : 1);  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "7.4   Call in makerPosthook Fails Silently", "body": "  The return value success2 in makerPosthook() is never handled. Thus a failed execution of the hook can go unnoticed and unlogged.  Code Corrected:  A log event is emitted on posthook revert.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "7.5   Fields of Events Not Indexed", "body": "  No parameter of the events defined in MgvEvents is marked as indexed. Indexing fields of events, e.g. addresses, allows to search for them easily.  /* Mangrove adds or removes wei from `maker`'s account */   /* * Credit event occurs when an offer is removed from the Mangrove or when the `fund` function is called*/   event Credit(address maker, uint amount);   /* * Debit event occurs when an offer is posted or when the `withdraw` function is called */   event Debit(address maker, uint amount);    /* * Mangrove reconfiguration */   event SetActive(address base, address quote, bool value);   event SetFee(address base, address quote, uint value);   event SetGasbase(     address base,     address quote,     uint overhead_gasbase,     uint offer_gasbase   );  Code Corrected:  The relevant arguments were indexed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "7.6   Imprecise Comment", "body": "  At  the  beginning  of  function  execute()  the  code  handles  whether  the  full  offer  is  to  be  consumed  or only a partial amount of the offer should be taken by the order.  Giry - Mangrove -   19  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \fif (   (mor.fillWants && offerGives < takerWants) ||   (!mor.fillWants && offerWants < takerGives) ||   offerWants == 0 ) {   sor.wants = offerGives;   sor.gives = offerWants;   /* If we are in neither of the above cases, then the offer will be partially consumed. */ } else {   /* If `fillWants` is true, we give `takerWants` to the taker and adjust how much they   give based on the offer's price. Note that we round down how much the taker will give. */   if (mor.fillWants) {     /* **Note**: We know statically that the offer is live (`offer.gives > 0`) since market      orders only traverse live offers and `internalSnipes` check for offer liveness before executing. */     sor.gives = (offerWants * takerWants) / offerGives;     /* If `fillWants` is false, we take `takerGives` from the taker and adjust how much they get      based on the offer's price. Note that we round down how much the taker will get.*/   } else {     /* **Note**: We know statically by outer `else` branch that `offerGives > 0`. */     sor.wants = (offerGives * takerGives) / offerWants;   } }  The last comment  Note: We know statically by outer else branch that offerGives > 0.  is not entirely correct: While it holds that offerGives is > 0 this is not due to being in the outer else branch but due to it having been ensured earlier that the offer is live, so offerGives is >0. Due to being in the outer else branch we know that offerWants is non-zero and hence we are sure there will be no division by zero which is the important consideration here.  Code Corrected:  The comment was changed to:  Note: We know statically by outer else branch that offerWants > 0.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "7.7   Maximize Penalty Collected", "body": "  Function  snipes()  allows  keepers  to  snipe  multiple  failing  offers  at  once  and  thereby  collect  the penalty. However, when multiple offers fail within one order, the base gas fee is split amongst all failing offers. This is done in order to distribute the base fees that applies once per transaction evenly across all affected offers.  In  order  to  maximize  their  profit,  professional  keepers  may  deploy  their  own  smart  contract  calling snipe() individually on each offer without increasing their expenses significantly, in order to ensure to always collect the maximum penalty possible.    The sniping mechanism has changed and, now, snipes() treats all snipes in isolation. With this change overhead_gasbase was removed and the scenario described above no longer applies.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "7.8   Misleading Variable Names in stitchOffers", "body": "  Giry - Mangrove -   20  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \fIn  stitchOffers  the  variable  names  worseId  and  betterId  are  used.  However,  the  betterId refers  to  the  offer  next  to  the  offer  under  consideration  and  worseId  refers  to  the  previous  one.  This seems to contradict the naming convention holding for the offerbook. According to this convention, for a given offer, its previous offer is a better one and its next offer a worse one.  Code Corrected:  The names of the variables were swapped.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "7.9   Overrestrictive Check in ", "body": " deductSenderAllowance  deductSenderAllowance checks if the amount used does for a trade does not exceed the allowance the use has set. However, it prevents the full allowed amount from being used since the equality is not checked.  require(allowed > amount, \"mgv/lowAllowance\");  Code Corrected:  > was replaced with >=.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "7.10   Repetitive Code", "body": "  In postExecute the following snippet is used right before the call to applyPenalty().  if (gasused > gasreq) {    gasused = gasreq;  }  Later, in applyPenalty the same snippet is repeated as follows:  if ($$(offerDetail_gasreq(\"sor.offerDetail\")) < gasused) {   gasused = $$(offerDetail_gasreq(\"sor.offerDetail\")); }  which is redundant.  Code Corrected:  The second check in postExecute was removed.  Giry - Mangrove -   21  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  Hence,  the mentioned topics serve to clarify or support the report, but do not require a modification inside the project. Instead,  they  should  raise  awareness  in  order  to  improve  the  overall  understanding  for  users  and developers.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "8.1   Bitwords Benefits", "body": "  In the implementation of Mangrove, structs to be stored in storage and handled as bitwords. This is done to  improve  gas  efficiency.  However,  given  that  equivalent  native  solidity  structs  could  fit  in  on  storage slot, the benefits from such a decision are questionable. The main downside of this decision is the extra layer  of  complexity,  introduced  in  the  form  of  solidity  code  preprocessing,  which  aims  to  facilitate  the handling of such bitwords.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "8.2   Choosing the Parameter gasreq", "body": "  When choosing the parameter gasreq, makers must be aware of certain things: As described in the code, the maker may receive only gasreq-63h/64 gas, where h is the overhead of (require + cost of CALL).  Nevertheless, should the call fail due to insufficient gas the maker is accountable for this and if the overall gas  remaining  in  the  transaction  is  sufficient,  the  transaction  penalizes  the  maker  and  completes successfully.  The comment states:  We let the maker pay for the overhead of checking remaining gas and making the call.  Albeit minor, the maker also pays for the overhead to handle the return data. All of this needs to be taken account when selecting the value for gasreq, especially in order to ensure enough gas will be available to the call to makerPosthook.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "8.3   Estimation of the Gas Limit for a ", "body": " marketOrder Transaction  Estimating  the  gas  limit  for  a  transaction  to  marketOrder  is  tricky.  Underestimating  it  leads  to  the transaction to revert, while overestimating it increases the risk of a high tx fee for a failing transaction.  Function  marketOrder  is  dependent  on  the  actual  status  of  the  offer  book  which  may  change significantly  between  when  the  transaction  is  generated  and  signed  and  when  it  is  executed  by  being included  inside  a  block.  Offers  may  be  added  or  removed  resulting  the  gas  requirement  for  the  offers being executed as part of the order may change significantly.  While marketOrder can skip failing offers and refund the taker, it can only do so successfully when the transaction has enough gas.  To avoid failing transactions users have to overestimate the gas required.  Giry - Mangrove -   22  NoteVersion1NoteVersion1NoteVersion1          \f8.4   Payable Fallback Functions For Taker Contracts  Takers may be contracts. When makers are penalised, provision is sent to the takers by a low level call msg.sender.call{value: amount}(\"\"). In this case, taker contracts must be able to handle the ether received by implementing fallback functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "8.5   Tokens With Transfer Fees", "body": "  Mangrove  is  supposed  to  handle  the  exchange  of  ERC20  tokens.  As  shown  in  the  snippet  below,  the system  expects  to  send  to  the  maker  the  same  amount  (sor.gives)  it  received  from  the  taker. However, in the case of the tokens with transfer fees this trade will fail since the amount received and forwarded by Mangrove will be different than the one requested due to the fees. By providing additional balance of this token to the contract ahead of the transaction, a party may make the transfer to succeed nevertheless.  This  may  be  done  by  either  the  maker  or  the  taker.  The  other  party  then  receives  less tokens then expected, as the transfer fee will be deducted.  if (transferTokenFrom(sor.quote, taker, address(this), sor.gives)) {    if (      transferToken(        sor.quote,        $$(offerDetail_maker(\"sor.offerDetail\")),        sor.gives      )    ) {     ...  Giry - Mangrove -   23  NoteVersion1NoteVersion1        \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove/"}, {"title": "6.1   No Protection for Keepers", "body": "  ISSUEIDPREFIX-001  Generally, keepers may just be interested in collecting the penalty of failing offers. In Mangrove however, an  offer  could  always  succeed  unexpectedly  due  to  changing  on-chain  conditions.  In  this  case,  a keeper/taker may have executed an offer he did not actually intended to take and which may had a bad exchange rate. Note that offers may only fail when significant amounts of tokens are flashloaned to the maker up front but the very same offer may succeed for lower amounts.  Unaware keepers may be tricked by honeypot offers (offers that appear to fail but in reality don't fail) by malicious makers.  Keepers may protect themself by wrapping their call in a smart contract and checking for the expected outcome, but the code of Mangrove itself does not offer such a feature directly.  Risk Accepted:  Mangrove  Association  (ADDMA)  responded:  Indeed  all  keepers  should  wrap  their  calls  in  a  reverting contract. This protective wrapper does not need to be inside Mangrove. We plan to provide a standard wrapper at a separate address.  Mangrove Association (ADDMA) - Mangrove -   14  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedLowRiskAcceptedAcknowledgedAcknowledgedRiskAcceptedDesignMediumVersion1RiskAccepted             \f6.2   ECDSA Signature Malleability  The permit function utilizes the ECDSA scheme. However missing checks for the v, r and s arguments allow  attackers  to  craft  malleable  signatures.  According  to  Yellowpaper  Appendix  F,  the  signature  is considered valid only if v, r and s values meet certain conditions. The ecrecover for invalid values will return address 0x0 and verification will fail without informative error. The OpenZeppelin's ECDSA library performs such checks and reverts with informative messages.  ISSUEIDPREFIX-002  Risk Accepted:  Mangrove  Association  (ADDMA)  responded:  Code  changes  necessary  for  improved  error  messages would go past the contract size limit.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "6.3   No Minimum Value for gasreq", "body": "  Either to create a new offer or to update an existing one, the maker must provide a value for gasreq. In the current implementation, there is no minimum required value. The value for gasreq may even be set to 0, which means 0 gas requirements for the calls executed on the maker's side. Nevertheless, both calls are  executed,  the  first  call  to  makerExecute  with  all  gas  defined  in  gasreq  and  the  second  to makerPosthook with the \"leftover\" gas from gasreq. With 0 gas these low-level calls are started but immediately revert. The system could allow these calls to be skipped when the maker sets a zero / low amount for gasreq.  ISSUEIDPREFIX-003  Acknowledged:  Mangrove Association (ADDMA) responded: The gas saved by treating 0-gasreq as a special case is not worth the added code complexity.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "6.4   Redundant Check in writeOffer", "body": "  When writeOffer is called a check that ofp.gives > 0 is performed. However, the check presented below  is  also  performed  and  implies  the  same  since  both  density  and  gasbase  should  be  positive under normal circumstances.  ISSUEIDPREFIX-004  ofp.gives >=   (ofp.gasreq + $$(local_offer_gasbase(\"ofp.local\"))) *     $$(local_density(\"ofp.local\")),  No Issue:  Mangrove Association (ADDMA) - Mangrove -   15  DesignLowVersion1RiskAcceptedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                      \fMangrove  Association  (ADDMA)  responded:  It  is  possible  for  governance  to  set  values  such  that  the second check does not imply the first. The first check maintains a critical invariant.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "6.5   Spamming the Offerbook", "body": "  ISSUEIDPREFIX-005  An  attacker  may  spam  the  offerbook  with  attractive  offers  reverting  immediately  upon  execution. Depending  on  the  parameters  chosen  by  the  governance  for  density  and  offer_gasbase  the resulting minimum penalty paid for the failing offer may be rather low.  Notably it is sufficient to have 85 such failing offers in the offer book (offering a very low price to ensure to be  on  top)  to  cause  a  revert  of  the  transaction  due  to  an  EVM  stack  too  deep  error.  Hence  any transaction to marketOrder() of this base/quote pair will revert leaving the state unchanged.  It's  still  possible  for  keepers  to  clean  the  offerbook  by  sniping  these  offers,  however  such  offers  may reinstantiate themself during the makerPosthook().  Risk Accepted:  Mangrove Association (ADDMA) responded: Any self-reinserting spam is vulnerable to draining by any keeper.  Mangrove Association (ADDMA) - Mangrove -   16  SecurityLowVersion1RiskAccepted          \f7   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings   Draining All Ether Provisions of Mangrove   -Severity Findings  -Severity Findings  If Condition Always True    Rounding Errors In Partial Filling   -Severity Findings   Wrong Comment    Call in makerPosthook Fails Silently    Fields of Events Not Indexed   Imprecise Comment    Maximize Penalty Collected    Misleading Variable Names in stitchOffers    Overrestrictive Check in deductSenderAllowance    Repetitive Code   1  0  2  8  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "7.1   Draining All Ether Provisions of Mangrove", "body": "  ISSUEIDPREFIX-014  Makers can retract their offer by calling retractOffer(). This function accepts the boolean parameter deprovision which allows the maker to choose to either deprovision the offer or not.  Deprovisioning an offer credits back the provision to the maker. At the same time it must be ensured that this  offer  is  removed  from  the  offerbook  and  its  gasprice  must  be  set  to  0  as  the  offer  is  no  longer provisioned.  Not all possible cases are handled correctly inside function retractOffer(). For offers that are not live (this means they have a 0 amount for offer.gives) the provision can be credited back to the maker without the offer's gasprice being set to zero.  Hence  retractOffer()  with  deprovision  set  to  true  can  be  executed  successfully  repeatedly. Consequently a maker can reclaim more provision than he initially paid for the offer. This bug allows to eventually drain all Ether of Mangrove.  An offer can easily reach offers.gives = 0 which means it is considered to not be live:   By  calling  retractOffer()  with  bool  deprovision  set  to  false,  dirtyDeleteOffer()  is executed. This call sets offer.gives to zero however without setting offer.gasprice to zero due to deprovision being false.  Mangrove Association (ADDMA) - Mangrove -   17  CriticalCodeCorrectedHighMediumCodeCorrectedCodeCorrectedLowSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSecurityCriticalVersion1CodeCorrected          \f After the offer has been consumed by an order offer.gives is 0.  Code Corrected:  The  call  to  dirtyDeleteOffer()  was  moved  out  of  the  isLive  scope.  Hence  whenever deprovision is set to true and the provision is credited back to the Maker, the order is deprovisioned. Calling the function repeatedly on the same offer no longer allows to drain Ether of Mangrove, the issue has been resolved.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "7.2   If Condition Always True", "body": "  During the execution of function execute the following check is performed:  ISSUEIDPREFIX-006  if (statusCode != \"mgv/notExecuted\") {   dirtyDeleteOffer(     ...   ); }  However statusCode cannot have the value mgv/notExecuted at this point so the condition is always true.  Code Corrected:  The code now runs unconditionally.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "7.3   Rounding Errors In Partial Filling", "body": "  A maker's order can be partially filled according to the following snippet:  if (mor.fillWants) {    sor.gives = (offerWants * takerWants) / offerGives;  } else {    sor.wants = (offerGives * takerGives) / offerWants;  }  ISSUEIDPREFIX-015  Note that the division can yield rounding errors. The rounding errors can be as extreme as giving funds to the maker without receiving anything in return or taking from the maker without giving anything back. For example,  consider  the  case  where  the  maker  offers  10  A  for  5  B  and  taker  wants  to  take  only  1  A (fillWants == true). Then, according to the formula she has to offer 5 * 1 / 10 = 0 B.  Code corrected  Mangrove Association (ADDMA) - Mangrove -   18  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \fPrices are now always rounded in favor for the taker to avoid any maker draining. Hence, to calculate sor.gives when fillWants is true the code has been changed to:  uint product = offerWants * takerWants; sor.gives =   product /   offerGives +     (product % offerGives == 0 ? 0 : 1);  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "7.4   Wrong Comment", "body": "  ISSUEIDPREFIX-016  the   In  comment In  case  of  failure,  `retdata`  encodes  the  gas  ...  is  present  in  the  block if(success), thus should be In case of success, ....  MgvOfferTaking.execute,   function   the   Specification changed:  The comment has been corrected.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "7.5   Call in makerPosthook Fails Silently", "body": "  The return value success2 in makerPosthook() is never handled. Thus a failed execution of the hook can go unnoticed and unlogged.  ISSUEIDPREFIX-008  Code Corrected:  A log event is emitted on posthook revert.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "7.6   Fields of Events Not Indexed", "body": "  No parameter of the events defined in MgvEvents is marked as indexed. Indexing fields of events, e.g. addresses, allows to search for them easily.  /* Mangrove adds or removes wei from `maker`'s account */   /* * Credit event occurs when an offer is removed from the Mangrove or when the `fund` function is called*/   event Credit(address maker, uint amount);   /* * Debit event occurs when an offer is posted or when the `withdraw` function is called */   event Debit(address maker, uint amount);    /* * Mangrove reconfiguration */  ISSUEIDPREFIX-011  Mangrove Association (ADDMA) - Mangrove -   19  CorrectnessLowVersion7Speci\ufb01cationChangedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f  event SetActive(address base, address quote, bool value);   event SetFee(address base, address quote, uint value);   event SetGasbase(     address base,     address quote,     uint overhead_gasbase,     uint offer_gasbase   );  Code Corrected:  The relevant arguments were indexed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "7.7   Imprecise Comment", "body": "  At  the  beginning  of  function  execute()  the  code  handles  whether  the  full  offer  is  to  be  consumed  or only a partial amount of the offer should be taken by the order.  ISSUEIDPREFIX-007  if (   (mor.fillWants && offerGives < takerWants) ||   (!mor.fillWants && offerWants < takerGives) ||   offerWants == 0 ) {   sor.wants = offerGives;   sor.gives = offerWants;   /* If we are in neither of the above cases, then the offer will be partially consumed. */ } else {   /* If `fillWants` is true, we give `takerWants` to the taker and adjust how much they   give based on the offer's price. Note that we round down how much the taker will give. */   if (mor.fillWants) {     /* **Note**: We know statically that the offer is live (`offer.gives > 0`) since market      orders only traverse live offers and `internalSnipes` check for offer liveness before executing. */     sor.gives = (offerWants * takerWants) / offerGives;     /* If `fillWants` is false, we take `takerGives` from the taker and adjust how much they get      based on the offer's price. Note that we round down how much the taker will get.*/   } else {     /* **Note**: We know statically by outer `else` branch that `offerGives > 0`. */     sor.wants = (offerGives * takerGives) / offerWants;   } }  The last comment  Note: We know statically by outer else branch that offerGives > 0.  is not entirely correct: While it holds that offerGives is > 0 this is not due to being in the outer else branch but due to it having been ensured earlier that the offer is live, so offerGives is >0. Due to being in the outer else branch we know that offerWants is non-zero and hence we are sure there will be no division by zero which is the important consideration here.  Code Corrected:  The comment was changed to:  Note: We know statically by outer else branch that offerWants > 0.  Mangrove Association (ADDMA) - Mangrove -   20  CorrectnessLowVersion1CodeCorrected        \f7.8   Maximize Penalty Collected  Function  snipes()  allows  keepers  to  snipe  multiple  failing  offers  at  once  and  thereby  collect  the penalty. However, when multiple offers fail within one order, the base gas fee is split amongst all failing offers. This is done in order to distribute the base fees that applies once per transaction evenly across all affected offers.  In  order  to  maximize  their  profit,  professional  keepers  may  deploy  their  own  smart  contract  calling snipe() individually on each offer without increasing their expenses significantly, in order to ensure to always collect the maximum penalty possible.  ISSUEIDPREFIX-009    The sniping mechanism has changed and, now, snipes() treats all snipes in isolation. With this change overhead_gasbase was removed and the scenario described above no longer applies.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "7.9   Misleading Variable Names in stitchOffers", "body": "  In  stitchOffers  the  variable  names  worseId  and  betterId  are  used.  However,  the  betterId refers  to  the  offer  next  to  the  offer  under  consideration  and  worseId  refers  to  the  previous  one.  This seems to contradict the naming convention holding for the offerbook. According to this convention, for a given offer, its previous offer is a better one and its next offer a worse one.  ISSUEIDPREFIX-010  Code Corrected:  The names of the variables were swapped.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "7.10   Overrestrictive Check in ", "body": " deductSenderAllowance  deductSenderAllowance checks if the amount used does for a trade does not exceed the allowance the use has set. However, it prevents the full allowed amount from being used since the equality is not checked.  ISSUEIDPREFIX-012  require(allowed > amount, \"mgv/lowAllowance\");  Code Corrected:  Mangrove Association (ADDMA) - Mangrove -   21  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \f> was replaced with >=.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "7.11   Repetitive Code", "body": "  In postExecute the following snippet is used right before the call to applyPenalty().  ISSUEIDPREFIX-013  if (gasused > gasreq) {    gasused = gasreq;  }  Later, in applyPenalty the same snippet is repeated as follows:  if ($$(offerDetail_gasreq(\"sor.offerDetail\")) < gasused) {   gasused = $$(offerDetail_gasreq(\"sor.offerDetail\")); }  which is redundant.  Code Corrected:  The second check in postExecute was removed.  Mangrove Association (ADDMA) - Mangrove -   22  DesignLowVersion1CodeCorrected        \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  Hence,  the mentioned topics serve to clarify or support the report, but do not require a modification inside the project. Instead,  they  should  raise  awareness  in  order  to  improve  the  overall  understanding  for  users  and developers.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "8.1   Bitwords Benefits", "body": "  In the implementation of Mangrove, structs to be stored in storage and handled as bitwords. This is done to  improve  gas  efficiency.  However,  given  that  equivalent  native  solidity  structs  could  fit  in  on  storage slot, the benefits from such a decision are questionable. The main downside of this decision is the extra layer  of  complexity,  introduced  in  the  form  of  solidity  code  preprocessing,  which  aims  to  facilitate  the handling of such bitwords.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "8.2   Choosing the Parameter gasreq", "body": "  When choosing the parameter gasreq, makers must be aware of certain things: As described in the code, the maker may receive only gasreq-63h/64 gas, where h is the overhead of (require + cost of CALL).  Nevertheless, should the call fail due to insufficient gas the maker is accountable for this and if the overall gas  remaining  in  the  transaction  is  sufficient,  the  transaction  penalizes  the  maker  and  completes successfully.  The comment states:  We let the maker pay for the overhead of checking remaining gas and making the call.  Albeit minor, the maker also pays for the overhead to handle the return data. All of this needs to be taken account when selecting the value for gasreq, especially in order to ensure enough gas will be available to the call to makerPosthook.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "8.3   Estimation of the Gas Limit for a ", "body": " marketOrder Transaction  Estimating  the  gas  limit  for  a  transaction  to  marketOrder  is  tricky.  Underestimating  it  leads  to  the transaction to revert, while overestimating it increases the risk of a high tx fee for a failing transaction.  Function  marketOrder  is  dependent  on  the  actual  status  of  the  offer  book  which  may  change significantly  between  when  the  transaction  is  generated  and  signed  and  when  it  is  executed  by  being included  inside  a  block.  Offers  may  be  added  or  removed  resulting  the  gas  requirement  for  the  offers being executed as part of the order may change significantly.  While marketOrder can skip failing offers and refund the taker, it can only do so successfully when the transaction has enough gas.  To avoid failing transactions users have to overestimate the gas required.  Mangrove Association (ADDMA) - Mangrove -   23  NoteVersion1NoteVersion1NoteVersion1          \f8.4   Payable Fallback Functions For Taker Contracts  Takers may be contracts. When makers are penalised, provision is sent to the takers by a low level call msg.sender.call{value: amount}(\"\"). In this case, taker contracts must be able to handle the ether received by implementing fallback functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "8.5   Tokens With Transfer Fees", "body": "  Mangrove  is  supposed  to  handle  the  exchange  of  ERC20  tokens.  As  shown  in  the  snippet  below,  the system  expects  to  send  to  the  maker  the  same  amount  (sor.gives)  it  received  from  the  taker. However, in the case of the tokens with transfer fees this trade will fail since the amount received and forwarded by Mangrove will be different than the one requested due to the fees. By providing additional balance of this token to the contract ahead of the transaction, a party may make the transfer to succeed nevertheless.  This  may  be  done  by  either  the  maker  or  the  taker.  The  other  party  then  receives  less tokens then expected, as the transfer fee will be deducted.  if (transferTokenFrom(sor.quote, taker, address(this), sor.gives)) {    if (      transferToken(        sor.quote,        $$(offerDetail_maker(\"sor.offerDetail\")),        sor.gives      )    ) {     ...  Mangrove Association (ADDMA) - Mangrove -   24  NoteVersion1NoteVersion1        \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-smart-contract/"}, {"title": "6.1   Unnecessary Additional Transfers", "body": "  In  functions  exitGem,  wipeAndFreeGem,  wipeAllAndFreeGem  of  the  DssProxyActionsCropper  as well  as  in  function  freeGem  of  the  DssProxyActionsEndCropper  the  collateral  is  first  exited  to  the DSProxy  before  being  transferred  onward  to  msg.sender.  The  gems  may  be  exited  to  msg.sender directly.  Acknowledged:  MakerDAO replied:  This is intentional to keep the rewards in the ds-proxy account. This way the ds-proxy owner can choose when to withdraw them. This paradigm of leaving the rewards in the ds-proxy is used for all actions calling join and exit. It was preferred by some of the UI projects integrating with Maker.  MakerDAO - DSS Crop Join -   13  DesignCorrectnessCriticalHighMediumLowAcknowledgedDesignLowVersion3Acknowledged            \f7   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   Documentation Not up to Date    Event Fields Consistency   Incorrect Decimal Annotation    Urn Proxy Load Inefficiency    NewProxy Event Consistency   0  0  0  5  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-crop-join/"}, {"title": "7.1   Documentation Not up to Date", "body": "  README.md describes tack and the auction process:  The winner of a collateral auction claims their collateral via flip.deal  This  describes  the  old  liquidation  process  using  the  Cat.  The  ilks  of  CropJoin  however  will  use liquidations 2.0 with the Dog and a slightly altered auction contract. Flip.deal() is not part of this.  Other  recent  maker  projects  contained  a  \"Risk\"  section  in  their  documentation.  Different  than  the traditional GemJoin adapter which just locks the collateral, CropJoin stakes the collateral into a third party system. This introduces new risks which should be documented appropriately.  Specification changed:  The readme was updated and now describes the liquidation process using the Dog. Risk consideration have not been added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-crop-join/"}, {"title": "7.2   Event Fields Consistency", "body": "  1. In CropJoin, the Join and Exit events differ from the system's default ones in the sense that  they do not contain the indexed address field.  2. The  Flee  event  has  no  fields.  Emitting  this  event  will  cost  gas  and  will  not  give  any  useful  information off-chain.  MakerDAO - DSS Crop Join -   14  CriticalHighMediumLowSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                 \f  1. The events now include the addresses of the urn and the user.  2. The Flee event now features following fields: The addresses for the user and the urn, the amount.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-crop-join/"}, {"title": "7.3   Incorrect Decimal Annotation", "body": "  The decimals of bonus and total could differ.  uint256     public share;  // crops per gem    [ray] uint256     public total;  // total gems       [wad] uint256     public stock;  // crop balance     [wad]  Share is calculated and updated in CropJoin.harvest():  function harvest(address from, address to) internal {     if (total > 0) share = add(share, rdiv(crop(), total));     uint256 last = crops[from];     uint256 curr = rmul(stake[from], share);     if (curr > last) require(bonus.transfer(to, curr - last));     stock = bonus.balanceOf(address(this)); }  share is in ray, crop() is decimals of bonus and total is wad. Note that rdiv() multiplies crop() with a ray. The resulting unit for share is bonus decimals * ray, bonus decimals may not be in 18 decimals.  rmul(stake[from],  share);  correctly  calculates  the  amount  in  bonus  token  unit.  The calculations are correct but the unit annotations are not accurate.    The annotations have been updated:  uint256     public share;  // crops per gem    [bonus decimals * ray / wad] uint256     public total;  // total gems       [wad] uint256     public stock;  // crop balance     [bonus decimals]  mapping (address => uint256) public crops; // crops per user  [bonus decimals]  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-crop-join/"}, {"title": "7.4   Urn Proxy Load Inefficiency", "body": "  The flux function of Cropper calls getOrCreateProxy to load the source urn proxy. Here a check similar to the one in move would save gas, firstly by saving a function call, and secondly by reverting the transaction  earlier  in  case  the  urn  does  not  exist.  If  the  source  urn  does  not  exist,  tack  will  revert  on non-zero wad parameter.  MakerDAO - DSS Crop Join -   15  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f  Flux() now loads the source urn proxy directly from the proxy mapping and reverts if no entry exists.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-crop-join/"}, {"title": "7.5   NewProxy Event Consistency", "body": "  The  event  NewProxy,  which  is  triggered  when  a  new  urn  proxy  is  deployed,  is  implemented  in  the Charter  contract  but  not  in  Cropper.  Since  the  two  contracts  are  meant  to  behave  similarly,  the NewProxy event should consistent.    The NewProxy event has been added to the UrnProxy contract in Cropper.sol.  MakerDAO - DSS Crop Join -   16  DesignLowVersion1CodeCorrected        \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-crop-join/"}, {"title": "8.1   UrnProxy With Different ilk", "body": "  It is possible to send gem that do not correspond to any ilk managed by the Cropper to an urn proxy and generate debt from this collateral. Since the urn proxy is managed by the Cropper it is not possible to get this gem out of the urn proxy.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-crop-join/"}, {"title": "8.2   Withdraw Value on Flee", "body": "  The internal accounting inside CropJoin is based on shares with 18 decimals:  Upon  join(),  the  amount  of  tokens  brought  is  converted  into  shares  by  expanding  the  value  to  an  18 decimals representation and a division through the net value per share:  The opposite is done during exit().  This amount of shares is used for all accounting purposes, namely to update the gem balance in the VAT, the stake[urn] and the total.  SynthetixJoin.flee() retrieves the value stored in the gem mapping at the VAT. This value is in the unit of shares. This value however is used as the amount of tokens to withdraw from the pool.  function flee(address urn, address usr) public override {     if (live == 1) {         uint256 val = vat.gem(ilk, urn);         if (val > 0) pool.withdraw(val);     }     super.flee(urn, usr); }  The  unit  mismatch  (shares  vs  tokens)  is  not  problematic  for  SynthetixJoin  under  the  condition  that  the gem  token  has  18  decimals.  Due  to  the  asset  valuation  in  SynthetixJoin  (nav())  the  exchange  rate between token and shares is 1:1.  In general, for an arbitrary CropJoin contract this may not hold. It's problematic when the exchange rate is  not  1:1  or  the  token  doesn't  have  18  decimals.  If  too  little  tokens  are  withdrawn  from  the  pool  the amount of tokens available at the Join adapter are insufficient to transfer the required amount to the user and the whole transaction fails blocking withdrawals. The other way, rounded surplus tokens will remain at the CropJoin contract.  MakerDAO - DSS Crop Join -   17  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dss-crop-join/"}, {"title": "7.1   ChainExitERC1155Predicate No Exit Event", "body": "  No  Exit  event  is  defined  in  ChainExitERC1155Predicate.  Hence,  upon  calling  exitTokens  no useful  and  informative  event  gets  emitted.  Furthermore  this  behavior  is  inconsistent  with  the  other predicates.  Specification changed:  Polygon has acknowledged lack of an exit event in ChainExitERC1155Predicate mentioning that:  \"Contract is deprecated and was never deployed.\"  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-pos-portal/"}, {"title": "7.2   ChildChainManager cleanMapToken Emits", "body": " Wrong Event  By  calling  cleanMapToken,  a  certain  bijection  mapping  between  root  and  child  tokens  gets  removed. However, the event emitted wrongly indicates a mapping has taken place.    Polygon defined a new event TokenUnmapped which gets emitted once a certain mapping between a root and a child token gets removed.  Polygon - PoS Portal -   13  CriticalHighMediumLowSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedDesignLowVersion1Speci\ufb01cationChangedCorrectnessLowVersion1CodeCorrected                  \f7.3   Unused ExitedERC721Batch Event  ERC721Predicate  defines  event  ExitedERC721Batch,  however;  exitTokens  does  not  support batch exiting of tokens and this event is not used at all.    Polygon has removed the definition of ExitedERC721Batch from their codebase.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-pos-portal/"}, {"title": "7.4   _processMessageFromChild Comment", "body": " Incorrect  The  comment  of  _processMessageFromChild()  in  BaseRootTunnel  says  that  is  called  from  the onStateReceive function. This is incorrect. It is actually called from receiveMessage().  Specification changed:  Polygon  has  corrected  the  comments  on  the  function  _processMessageFromChild  saying  that  it  is called from receiveMessage().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-pos-portal/"}, {"title": "7.5   MetaTransactionExecuted Event Has No", "body": " Indexed Arguments  The aforementioned event is defined as  event MetaTransactionExecuted(     address userAddress,     address payable relayerAddress,     bytes functionSignature );  None of its arguments are marked as indexed, which could degrade user experience. Indexing fields of events, e.g. addresses, allows to search for them easily.    Polygon  defined  userAddress  and  relayerAddress  as  MetaTransactionExecuted.  indexed   fields  of   the  event  event MetaTransactionExecuted(     address indexed userAddress,     address payable indexed relayerAddress,  Polygon - PoS Portal -   14  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                      \f    bytes functionSignature );  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-pos-portal/"}, {"title": "7.6   Gas Optimisation Issues Informational", "body": "  The  codebase  has  several  inefficiencies  in  terms  of  gas  costs  when  deploying  and  executing  smart contracts. Here, we report a list of non-exhaustive possible gas optimizations:  1. ChildMintableERC1155.deposit  performs  a  sanity  check  on  user  !=  address(0)  after decoding depositData. This check however has already been done by the RootChainManager.  2. NativeMetaTransaction.executeMetaTransaction  has  a  visibility  of  public.  As  this function in the current implementation gets called only externally, it ca be defined as external, which subsequently  lets  memory  location  of  functionSignature  be  calldata.  In  this  way,  gas consumption can be reduced.  3. UpgradableProxy.updateImplementation checks _newProxyTo is non-zero. However, the  exact same check is done when calling into isContract.  4. UpgradableProxy.updateAndCall  is  a  public  function.  Its  visibility  can  be  changed  to  external letting its argument data be defined as calldata.  5. RootChainManager.receive  calls  into  _depositEtherFor  with  _msgSender  as  the  input argument. However, given the fact that sending ETH does not happen through a meta transaction, simply using msg.sender can be used.  6. ITokenPredicate.exitTokens takes an address as its first argument (sender). However, this  argument is never used in any implementation of the token predicates.  7. exitTokens  function  for  tokens  with  multiple  transfer  signatures  is  implemented  as  an  if-else body, and in each branch same flow of subfield extractions is done. To reduce code footprint, these operations can be moved out of if-else and only logic be kept in each branch.  8. exitTokens  function  in  call  predicates  can  have  an  external  visibility  and  calldata  memory  location for it log argument.  9. In  mintable  version  of  each  token,  inside  an  if-else  statement,  it  checks  whether  an  excessive amount  should  be  minted  and  then  transfers  the  actual  amount  to  the  receiver.  Calling  transfer functions can be done outside of if-else to decrease code footprint and reduce deployment cost.  10. NativeMetaTransaction.getNonce,  which  returns  current  valid  nonce  of  each  user.  As  this  view function gets called only externally, its visibility can be changed to external.  11. ChainExitERC1155Predicate.exitTokens  checks  the  withdrawer  is  not  address  zero. However, as the log data fed to it comes from a valid burn event on the child chain, from cannot be zero.  12. BaseChildTunnel.onStateReceive can be defined as external with message having calldata  type.  13. BaseRootTunel.receiveMessage  is  never  called  internally.  Therefore,  it  can  be  define  as  external with inputData being calldata.    Polygon has addressed most of the gas optimisation issues. However, for those below they have decided to keep the code as-is:  Polygon - PoS Portal -   15  Version1CodeCorrected    \f1. \"That is correct but we are in favour of retaining this as an assertion.\"  5. \"some relayers support ETH metatxs, retaining for backwards compatibility.\"  7. No further explanations.  9. No further explanations.  11. \"That is correct but we are in favour of retaining this as an assertion.\"  Polygon - PoS Portal -   16       \f8   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-pos-portal/"}, {"title": "8.1   Enhance Documenation of Inline Assembly", "body": "  Code  forked  from  Biconomy  is  used  to  implement  support  for  Meta  Transactions.  The  assembly  in function msgSender() used to retrieve the sender of the message is not as trivial as it might look. The comment documenting the code section is not appropriately describing what's happening.  if (msg.sender == address(this)) {     bytes memory array = msg.data;     uint256 index = msg.data.length;     assembly {         // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.         sender := and(             mload(add(array, index)), //@okaudit-issue todo investigate calculation here, what data do we read?             0xffffffffffffffffffffffffffffffffffffffff         )     }  Intuitively the code seems to read 32 bytes past the end of msg.data. However, note that for variable length  data  in  memory  solidity  uses  the  first  32  bytes  to  store  the  length  of  the  data.  Hence, mload(add(array, index)) loads the last 32 bytes of msg.data and the code works correctly. Due to the delicate nature of assembly within Solidity, this might be documented appropriately.  Polygon - PoS Portal -   17  InformationalVersion1  \f9   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-pos-portal/"}, {"title": "9.1   ChildERC721 Static domainSeparator", "body": "  In  all  variants  of  ChildERC721,  once  and  only  once  upon  deployment,  domainSeparator  gets calculated using the name of token and chain ID:  domainSeperator = keccak256(     abi.encode(         EIP712_DOMAIN_TYPEHASH,         keccak256(bytes(name)),         keccak256(bytes(ERC712_VERSION)),         address(this),         bytes32(getChainId())     ) );  However, in RootChainManager and UChildERC20, a functionality is devised to let recomputation of domainSeparator,  e.g.  when  name  of  token  gets  updated.  Despite  the  fact,  that  forking  and  a consequent change of chain ID may not be very possible, implementing this functionality in derivations of ERC721Child could make the system more robust.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-pos-portal/"}, {"title": "9.2   Exiting MintableERC721", "body": "  MintableERC721Predicate offers several exit possibilities:   TRANSFER_EVENT_SIG   WITHDRAW_BATCH_EVENT_SIG   TRANSFER_WITH_METADATA_EVENT_SIG  Due to the uniqueness of an NFT (tokenID) a token can only exist once. However, please consider all withdrawal  options  emit  the  Transfer  event  on  the  child  chain  and  hence  all  can  be  exited  using  the TRANSFER_EVENT_SIG. This has the following consequences:  For an exit initiated using:   withdrawBatch: If one transfer has been exited using the TRANSFER_EVENT_SIG, all transfers of  the batch must be individually exited using their individual transfer event.   withdrawWithMetadata: If the TRANSFER_EVENT_SIG is used for the exit, the metadata is lost.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-pos-portal/"}, {"title": "9.3   Minting of ERC721 Tokens", "body": "  Polygon - PoS Portal -   18  NoteVersion1NoteVersion1NoteVersion1          \fWhen  using  ChildMintableERC721  and  MintableERC721Predicate,  it  is  important  that  only  the predicate has minting rights for the token on the root chain.  On the child chain ChildMintableERC721 allows addresses holding an admin role to mint tokens with arbitrary token ID's given they do not exist on the child chain and have not been withdrawn to the root chain yet.  This protection is only effective when no arbitrary token can be minted on the root chain.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-pos-portal/"}, {"title": "9.4   Recipient of Withdrawn Tokens", "body": "  None of the withdraw functions of the child tokens allows to specify the recipient on the root chain. The recipient address is the token owner on the child chain.  It is important to ensure one can access these tokens on the root chain before initiating the withdrawal. Although this generally is not an issue for EOAs, special care must be taken for contracts.  For ERC721/ERC1155 if the recipient is a contract, the contract must implement the appropriate interface or the tokens may be stuck in the bridge as they cannot be exited successfully.  Polygon - PoS Portal -   19  NoteVersion1    \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/polygon-pos-portal/"}, {"title": "5.1   Excessive Memory Allocations", "body": "  0  0  0  3  The  slice  function  of  the  BytesLib  library  is  used  in  many  places.  In  some  cases,  it  is  used  inside  a loop. This allocates new memory on every loop iteration, even if the memory is no longer needed after the iteration finishes. Hence, it results in a much larger allocation of memory than is actually needed.  For  example,  we  can  examine  the  following  loop  from  the  _addSigningKeys  function  of  the NodeOperatorsRegistry:  for (uint256 i = 0; i < _keysCount; ++i) {     bytes memory key = BytesLib.slice(_publicKeys, i * PUBKEY_LENGTH, PUBKEY_LENGTH);     require(!_isEmptySigningKey(key), \"EMPTY_KEY\");     bytes memory sig = BytesLib.slice(_signatures, i * SIGNATURE_LENGTH, SIGNATURE_LENGTH);      _storeSigningKey(_nodeOperatorId, totalSigningKeysCount, key, sig);     totalSigningKeysCount = totalSigningKeysCount.add(1);     emit SigningKeyAdded(_nodeOperatorId, key); }  Here,  the  memory  is  only  temporarily  needed,  it  holds  the  values  copied  from  the  _publicKeys  and _signatures  arrays.  As  soon  as  the  loop  iteration  finishes,  the  key  and  sig  arrays  are  no  longer needed. However, the memory they used remains allocated.  Instead, the arrays could be declared outside the loop, and the values copied into them on each iteration. This  would  cut  the  total  memory  usage  of  the  _addSigningKeys  function  in  half.  As  memory  has  a quadratic cost, this could significantly reduce transaction costs.  The  same  optimization  could  be  applied  to  the  _makeBeaconChainDeposits32ETH  function  of  the BeaconChainDepositor contract, which also uses BytesLib.slice in a loop.  Lido - Staking Router -   11  DesignCorrectnessCriticalHighMediumLowRiskAcceptedRiskAcceptedAcknowledgedDesignLowVersion1RiskAccepted          \fthe  getSigningKeys  and  _loadAllocatedSigningKeys   Similarly,  the NodeOperatorsRegistry call _loadSigningKey in a loop. This allocates new memory in each iteration, despite each value only being needed for the duration of a single iteration.  functions   in   Changes in   ,  The  declarations  of  the  bytes  arrays  in  _addSigningKeys,  getSigningKeys  and In  _loadAllocatedSigningKeys  were  moved  outside  the  loop.  However,  they  are  still  re-allocated  in every loop iteration. _makeBeaconChainDeposits32ETH was not changed.  _addSigningKeys   For  that BytesLib.slice allocates a new bytes array every time it's called. In the case of getSigningKeys and _loadAllocatedSigningKeys, the culprit is the call to _loadSigningKey, which also allocates a new bytes array. Hence, the memory allocations still occur and the transaction costs remain the same.  _makeBeaconChainDeposits32ETH,   issue   and   the   is   Risk accepted  Lido responded:  Will be fixed in the next major protocol upgrade.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "5.2   Rounding Errors", "body": "  1. In the _getKeysAllocation function, a number of _keysToAllocate is provided. However, it's not  guaranteed  that  all  the  keys  will  be  allocated,  as  rounding  errors  may  lead  to  an  incomplete allocation  of  the  keys.  For  example,  with  two  modules  each  with  a  targetShare  of  50%,  a _keysToAllocate  of  3  results  in  both  modules  being  allocated  just  one  key,  as  their targetKeys values will be rounded down to 1.  2. The  getRewardsDistribution  calculates  a  perValidatorReward  as  the  total  rewards divided by the total number of validators. Then it multiplies it by the number of validators per node operator. However, this leads to excessive rounding errors, as the division is performed before the multiplication. Instead, the multiplication should be performed first in order to reduce the amount of reward that is not distributed due to rounding errors.  Risk accepted:  Lido responded:  This is an expected behavior and impact is tolerable. Will be fixed in the next major protocol upgrade.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "5.3   Unnecessary Reduction of Vetted Key Count", "body": "  When  deleting  a  key  in  the  NodeOperatorsRegistry,  the  vettedKeysCount  is  set  to  the  index  of  the deleted key (if the deleted key is vetted). This is done because deleting a key actually swaps it with the last key, then deletes it. Hence, if the last key is swapped to a smaller index, it might otherwise become vetted.  However,  if  the  last  key  has  also  already  been  vetted,  this  could  be  unnecessary  -  instead  the vetted key count could simply be reduced by one.  Lido - Staking Router -   12  Version3Version3DesignLowVersion1RiskAcceptedDesignLowVersion1Acknowledged                \fAcknowledged  Lido acknowledges the issue and states the following:  Thank you for this finding. We won't fix this issue in current version but will address it later.  Lido - Staking Router -   13    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Staking Rewards Incorrect Trimming   -Severity Findings   Dummy Iterations Can Be Avoided    MemUtils.memcpy Mask Is Wrong   -Severity Findings   Code Redundancies   Incorrect Comments   Interface Issues   Issues With Events    Non-existent Modules Are Active by Default    Sanity Checks Missing    Visibility Can Be Reduced   0  1  2  7  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "6.1   Staking Rewards Incorrect Trimming", "body": "  In the StakingRouter, the getStakingRewardsDistribution assigns fees to recipient addresses. It then trims the resulting arrays so that there are no recipients that receive an amount of zero. However, this trimming does not work correctly.  The  recipients  and  moduleFees  arrays  are  filled  left-to-right,  using  the  same  index  as  the modulesCache.  This  means  that  the  \"empty\"  entries,  where  the  module  fees  are  zero,  occur non-deterministically throughout the array. Hence, when the last entries are trimmed, some modules that would  otherwise  receive  the rewardedModulesCount as an index for these arrays, so that modules which receive no fee would not increment the index.  fees  are  not  being  returned.  Likely,   intent  was   to  use   the   As  such,  the  results  returned  by  getStakingRewardsDistribution  have  the  potential  to  be  very incorrect,  distributing  far  less  fees  than  intended,  and  only  distributing  fees  to  the  recipients  \"lucky\" enough to be stored early in the modulesCache array.  Code corrected  The issue was fixed by using the rewardedModulesCount as an index for the resulting arrays, thereby ensuring that the modules receiving rewards are stored contiguously at the start of the returned arrays. Thus, the trimming is now done correctly.  Lido - Staking Router -   14  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrected           \f6.2   Dummy Iterations Can Be Avoided  The  MinFirstAllocationStrategy  features  an  algorithm  which  allocates  items  to  buckets  with  different capacities.  In  some  cases,  the  algorithm  may  do  many  unnecessary  dummy  iterations,  which  each allocate a single item to a bucket. For example:  1. Let's start with the scenario where we have 5 empty buckets, each with a very large capacity.  2. Now, call the allocate function, with an allocationSize of 24.  3. In the first five iterations, each bucket will be allocated 4 items, as 24 / 5 is rounded down to 4.  4. Now,  an  additional  four  \"dummy\"  iterations  have  to  be  performed,  which  allocate  an  additional  single item to the first four buckets.  These  dummy  iterations  could  be  avoided,  for  example,  by  rounding  up  instead  of  down  when  the allocationSize  is  not  divisible  by  the  number  of  best  candidates.  This  would  result  in  the  first  four iterations allocating 5 items each, with the last iteration having only four items left and allocating them all to the last bucket.  Note  that  when  a  deposit  occurs,  this  algorithm  is  run  once  for  each  staking  module.  Hence,  as  this algorithm  is  executed  many  times,  reducing  the  number  of  iterations  could  reduce  business  costs, especially when more staking modules are added in the future.    The allocation algorithm was updated. Now, when there are more than one best candidates, the ceil of the division of the allocationSize by bestCandidatesCount is used.  allocated = Math256.min(     bestCandidatesCount > 1 ? Math256.ceilDiv(allocationSize, bestCandidatesCount) : allocationSize,     Math256.min(allocationSizeUpperBound, capacities[bestCandidateIndex]) - bestCandidateAllocation );  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "6.3   MemUtils.memcpy Mask Is Wrong", "body": "  The memcpy function in MemUtils copies a segment of memory from one location to another. It does so in  32-byte  chunks.  However,  if  the  length  of  the  segment  to  copy  is  not  divisible  by  32,  it  does  an additional copy with a masked value so that no memory values are overwritten when they shouldn't be. However, this is done incorrectly.  function memcpy(uint256 _src, uint256 _dst, uint256 _len) internal pure {     assembly {         // while al least 32 bytes left, copy in 32-byte chunks         for { } gt(_len, 31) { } {             mstore(_dst, mload(_src))             _src := add(_src, 32)             _dst := add(_dst, 32)             _len := sub(_len, 32)         }         if gt(_len, 0) {  Lido - Staking Router -   15  DesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                \f            // read the next 32-byte chunk from _dst, replace the first N bytes             // with those left in the _src, and write the transformed chunk back             let mask := sub(shl(1, mul(8, sub(32, _len))), 1) // 2 ** (8 * (32 - _len)) - 1             let srcMasked := and(mload(_src), not(mask))             let dstMasked := and(mload(_dst), mask)             mstore(_dst, or(dstMasked, srcMasked))         }     } }  The mask value is calculated incorrectly. The shl instruction for Solidity assembly is specified as follows:  shl(x, y): Logical shift left of y by x bits.  Hence,  the  mask  is  not  shifting  1  to  the  left  by  some  amount.  Instead,  mul(8,  sub(32,  _len))  is being shifted to the left by 1 bit. As a result, the mask being calculated will always copy at least 30 bytes (since 2*8*(32-1)-1<512), with the remaining two bytes being partially or not at all copied, depending on the exact value of _len. In the case of _len % 32 == 16, exactly 31 bytes are copied, meaning an additional 15 bytes after the end of the memory segment are copied to the destination.  This  is  the  case  when  dealing  with  public  keys.  In  the  _loadAllocatedSigningKeys  and getSigningKeys functions of the NodeOperatorsRegistry, when the public keys are copied, the length will be 48 and hence not divisible by 32. So additional bytes are copied.  However, it happens to be the case the when _loadSigningKey is called, the allocated memory for the public key is directly followed by the signature. Hence, the 15 extra bytes which are copied are the first 15 bytes from the length field of the signature's bytes array. Because this length is always 3, these bytes are guaranteed to be zero.  Additionally, as the destination of the memory copy is filled left-to-right, for all but the last copy operation the  extra  bytes  that  are  written  are  immediately  overwritten  by  the  following  value.  Only  the  last  copy writes 15 bytes of zeroes past the end of the publicKeys bytes array. But again, due to the order of memory allocation, this array is followed in memory by the signatures bytes array. So, the extra bytes happen to overlap with the length field of the signatures array. As the length of this array is (hopefully) less than 2 ** (17 * 8), the extra bytes that are overwritten are already set to zero anyway.  All  in  all,  this  means  that  the  memcpy  function  works  correctly,  but  only  due  to  the  order  of  memory allocations,  which  happen  to  guarantee  that  the  extra  bytes  which  are  copied  to  and  from  are  always zero.  Code corrected  The argument order of the shl expression in the mask calculation was changed.  let mask := sub(shl(mul(8, sub(32, _len)), 1), 1)  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "6.4   Code Redundancies", "body": "  In the current implementation there are a few code redundancies which can be improved. In particular:  1. In   NodeOperatorsRegistry.activateNodeOperator,  the ACTIVE_OPERATORS_COUNT_POSITION  is  increased  using  SafeMath.  However,  it  is impossible for this value to overflow.  Lido - Staking Router -   16  DesignLowVersion1CodeCorrected        \f2. In  NodeOperatorsRegistry.distributeRewards,  recipients.length  is  guaranteed to equal shares.length as it constructed by getRewardsDistribution that way. Hence, the relevant assertion will always be true.  3. In   MinFirstAllocationStrategy.allocateToBestCandidate,   condition allocationSize  ==  0  is  checked  after  the  first  loop,  despite  not  being  affected  by  it. Instead,  this  condition  could  be  checked  at  the  start  of  the  function.  Alternatively,  as  the function is only ever called from allocate, it is actually guaranteed the allocationSize is never equal to zero. Hence, the check could also be omitted fully.  the   4. In  StakingRouter.deposit,  it  is  ensured  that  keysToDeposit  does  not  exceed maxDepositableKeys,  which  is  calculated  by  querying  the  Lido  contract  and  querying  its buffered  Ether  amount.  However,  it  is  already  guaranteed  that  _maxDepositsCount  fulfills this  condition,  as  only  the  Lido  contract  can  call  this  function,  and  it  performs  checks  before making this call.  5. The  StakingRouter  has   functions,  _getStorageStakingModulesMapping  and _getStorageStakingIndicesMapping,  which  are  always  called  with  the  same  constant arguments. Instead of passing these arguments to the functions, the functions could inline the values in order to reduce unnecessary complexity and allow for more optimal bytecode.  two   6. In the StakingRouter's deposit function, a StakingRouterETHDeposited event is emitted with  the  parameter  _getStakingModuleIdByIndex(stakingModuleIndex).  However, the staking module's ID was already passed as an argument to the function, so it doesn't need to be looked up. Instead, _stakingModuleId could be used as a parameter to this event.  7. NodeOperatorsRegistry.addNodeOperator  will  always  emit  a  NodeOperatorAdded event with 0 staking limit. As there are no occasions where the event is emitted with a non-zero staking limit, this field contains essentially no information and is redundant.  8. In   NodeOperatorsRegistry._getSigningKeysAllocationData,   of nodeOperatorIds  and  exitedSigningKeysCount  arrays  are  potentially  written to is  where  redundantly  vettedSigningKeysCount, as they may be overwritten in a following iteration.  depositedSigningKeys   equal   case   cells   the   the   in   9. In  NodeOperatorsRegistry.getRewardsDistribution,  a  non-empty  recipients array could be returned even though the shares array contains only 0s. This corner case can happen if all the node operators are active but all their validators have exited.  10. NodeOperatorsRegistry.getValidatorsKeysStats  makes   of SafeMath  desired exitedKeys <= depositedKeys <= vettedKeys invariant hold, the subtractions should never underflow.  redundant  the   though,   should   even   use     Most of the redundancies reported have been fixed.  1. SafeMath is not used any more.  2. The corresponding assertion has been removed.  3. The check was moved at the beginning.  5. Now, the two functions do not accept any argument.  6. _stakingModuleId is now used.  8. The   array   elements   are   now   written   after   the  depositedSigningKeysCount == vettedSigningKeysCount check.  10. SafeMath is no longer used in the getValidatorsKeysStats function.  Lido - Staking Router -   17  \fAcknowledged:  4. Lido acknowledges the additional cost associated with the redundant check.  7. This is intended behavior in order to keep backwards compatibility.  9. The returning of empty shares entries is intended behavior.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "6.5   Incorrect Comments", "body": "  The code contains some inaccurate comments:  1. The  doc  comment  for  the  _stakingModuleAddress  of  the  addModule  function  is  as  follows:  /**  * ...  * @param _stakingModuleAddress target percent of total keys in protocol, in BP  * ...  */  This is incorrect and describes a different parameter.  2. Point 4. in the comment in MinFirstAllocationStrategy.allocateToBestCandidate is not updated. In the current implementation, DivCeil(allocationSize, count) is used instead of integer division.  3. In  NodeOperatorsRegistry,  addSigningKeys  enforces  the  same  access  control  as addSigningKeysOperatorBH.  The  same  holds  for  removeSigningKeys  the  same  as removeSigningKeysOperatorBH.  This  implies  that  the  BH  versions  of  the  functions  are pointless and can be considered deprecated. However, they are not marked as such.    Comments 1. and 2. have been fixed. 3. is left as is, the functions exist for backwards compatibility and are hence not deprecated.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "6.6   Interface Issues", "body": "  The interfaces for certain contracts were defined multiple times, once for version ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "0.4.24 ", "body": "and once for version 0.8.9. However, some of the duplicate interfaces have outdated or clashing definitions:  1. The  0.8.9   ILido   interface  defines   the   functions  updateBufferedCounters  and  getLastReportTimestamp, which are not implemented by the Lido contract.  2. The   0.4.24   function getStakingModuleMaxDepositableKeys  which  takes  a  parameter  with  the  incorrect  name _stakingModuleId. The 0.8.9 interface was changed to take the _stakingModuleIndex as a parameter instead.  IStakingRouter   interface   defines   a   Moreover,  there  are  some  mismatches  between  the  functions  defined  in  the  interface  and  the  ones actually implemented. The 0.4.24/ILido interface defines the following function signatures:  Lido - Staking Router -   18  CorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \ffunction getFee() external view returns (uint16 feeBasisPoints); function getFeeDistribution() external view returns (uint16 modulesFeeBasisPoints, uint16 treasuryFeeBasisPoints);  However, the Lido contract implements these functions with different return types:  function getFee() public view returns (uint96 totalFee) {     // ... }  function getFeeDistribution() public view returns (uint96 modulesFee, uint96 treasuryFee) {     // ... }  Code corrected  Regarding mismatches between different versions:  1. The unimplemented functions were removed from the 0.8.9 ILido interface.  2. The  0.8.9  version  of  the  IStakingRouter  interface  was  changed,  the  parameter  for  the of  now  _stakingModuleId   instead   is   getStakingModuleMaxDepositableKeys  _stakingModuleIndex.  Regarding mismatch of the Lido contract between interface and implementation:  The interface was corrected to match the implementation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "6.7   Issues With Events", "body": "  In the implementation there are some issues with the events:  In  NodeOperatorsRegistry.addNodeOperator,  two  events  are  emitted.  Namely, NodeOperatorAdded(id)  and NodeOperatorAdded(id,  _name,  rewardAddress,  0).  The  second  event  contains strictly more information than the first one.  In  NodeOperatorsRegistry.activateNodeOperator,  the  NodeOperatorActiveSet event is not emitted even though it is defined.  In NodeOperatorsRegistry.deactivateNodeOperator, the NodeOperatorActiveSet event is not emitted.  In  NodeOperatorsRegistry.distributeRewards,  the  RewardsDistributed  event uses  idx  which  is  not  the  id  of  the  node  operator  but  the  index  of  the  operator  in  the recipients array. Note that this index can vary based on the status of the various operators. Moreover, the event is emitted even if shares[idx] is 0.  In  DepositSecurityModule._setGuardianQuorum,  event will be emitted even if the quorum has not changed.  the  GuardianQuorumChanged  In StakingRouter.setStakingModuleStatus, the StakingModuleStatusSet event will be emitted even if the status of the module has not changed.  Code corrected  The issues have been remedied in the following ways:  Lido - Staking Router -   19  DesignLowVersion1CodeCorrected              \f NodeOperatorsRegistry.addNodeOperator  only  emits  the  event  with  more  information.  The definition of the other event was removed from the IStakingModule interface.   NodeOperatorsRegistry.activateNodeOperator   now   emits   NodeOperatorActiveSet event.   NodeOperatorsRegistry.deactivateNodeOperator   now   emits   a  a  NodeOperatorActiveSet event.   The RewardsDistributed event was changed to take the rewards address as a parameter. NodeOperatorsRegistry.distributeRewards  emits  the  event  with  recipients[idx] as the address. Additionally, the transfer and event emission are omitted if the shares amount is 0.   DepositSecurityModule._setGuardianQuorum  no  longer  emits  an  event  if  the  quorum  has not changed.   StakingRouter.setStakingModuleStatus  now  reverts  if  the  new  status  is  the  same  as  the old one.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "6.8   Non-existent Modules Are Active by Default", "body": "  Should  StakingRouter.getStakingModuleByIndex  be  called  with  a  non-existent  index,  it  will return  an  empty  StakingModule.  the  StakingModule  struct  has  a  status  field  of  type IStakingRouter.StakingModuleStatus.  Since  the  default  value  of  the  enum  is  Active,  any uninitialized  staking  module  will  be  considered  active.  This  could  be  a  potential  problem  for  other contracts calling getStakingModuleByIndex.  Code corrected  The  StakingRouter.getStakingModuleByIndex  the StakingRouter.getStakingModuleMaxDepositableKeys function was modified to take an ID as an  argument  instead  of  an  index.  However,  it  is  worth  noting  that  the  default  value  of  the StakingModuleStatus is still Active.  removed.  Additionally,   function  was   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "6.9   Sanity Checks Missing", "body": "  In the current implementation, a few sanity checks are missing. More specifically:  In  NodeOperatorsRegistry.removeSigningKeys,  _fromIndex  and  _keysCount  are checked to be less than UINT64_MAX. However, these checks do not suffice, as it's important that the sum of the two inputs is also less than UINT64_MAX (and strictly greater than 0). Note that in any of these cases, SafeMath calculations taking place later will revert.  In  NodeOperatorsRegistry.removeSigningKeys,  _keysCount  is  not  checked  to  be non-zero.  This  is  not  symmetric  to  the  addSigningKeys  case  where  such  a  check  is performed.  Moreover,  should  _keysCount  equal  0  the  call  will  have  no  effect,  yet  the ValidatorsKeysNonce will increase.  In theory, the NodeOperatorsRegistry can hold up to UINT64_MAX different keys for each operator ranging from indices 0 up to UINT64_MAX - 1. This means that _index cannot be from  removeSigningKey  and equal   to  UINT64_MAX.  However,   is  allowed   this   Lido - Staking Router -   20  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                   \fremoveSigningKeyOperatorBH. The inequality of the sanity check in these cases should be strict.  In StakingRouter.addModule, the _stakingModuleAddress argument is not checked to be non-zero. As this address cannot be changed later, it may be important to sanity-check the value before setting it.  In StakingRouter.addModule, the _name argument is not sanitized to be at most 64 bytes while such a check exists for the name argument in the NodeOperatorsRegistry.  In  NodeOperatorsRegistry._addSigningKeys,  while  the  public  keys  are  checked  to  be non-empty, there is no such a check for the signatures.  Code corrected  NodeOperatorsRegistry.removeSigningKeys was changed in the following ways:   The sum of _fromIndex and _keysCount is checked to be less than UINT64_MAX. Note that the  check  for  _fromIndex  <  UINT64_MAX  is  now  redundant,  as  the  sum  of  two  unsigned integers is always greater or equal than both summands (assuming no overflow occurs). Note also that the conversion uint256(_fromIndex) is redundant.   _keysCount  is  checked  to  be  non-zero  in  the  _removeUnusedSigningKeys  function,  in  order to not emit redundant events.  The NodeOperatorsRegistry was modified so that all checks comparing the index to UINT64_MAX are now done with a strict inequality.  StakingRouter.addModule was modified as follows:  It was renamed to addStakingModule in   .   The _stakingModuleAddress is checked to be non-zero.   The _name parameter is checked to be between 1 and 32 bytes in length.  Acknowledged  Regarding the missing check for signatures, Lido states  Will be fixed in the next major protocol upgrade.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "6.10   Visibility Can Be Reduced", "body": "  Visibility  of  certain  functions  can  be  restricted  in  order  to  reduce  gas  costs.  The  following  functions' visibility could be changed from public to external:  Lido:  1. getCurrentStakeLimit  2. getBeaconStat  3. getFee  4. getFeeDistribution  StETH:  1. getTotalShares  2. sharesOf  Lido - Staking Router -   21  Version2DesignLowVersion1CodeCorrected            \f3. transferShares  StakingRouter:  1. getKeysAllocation  Lastly,  MinFirstAllocationStrategy library to private instead of internal.  it  may  make  sense   reduce   to   the  allocateToBestCandidate   function  of   the    The visibility of the functions was changed as suggested, except for the allocateToBestCandidate function.  Lido - Staking Router -   22  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "7.1   Discrepancy in Event Argument", "body": "  a   is   called,   Lido.submit   When  the _emitTransferAfterMintingShares function. This event contains a field which corresponds to the amount of ETH used to mint the respective amount of shares the user received. It is likely, however, that the  amount  is  not  exactly  the  same  as  the  one  sent  by  the  user  since  the  calculation  of  the  shares amount  to  be  minted  can  incur  some  rounding  errors.  For  example,  assume  that  a  user  submits  1234 wei,  the  total  number  of  shares  is  10  and  pooled  ether  amount  is  1000  wei.  Then  the  user  will  mint 1234*10/1000 = 12 shares and the argument in the Transfer event will be 1200.  Transfer   emitted   event   by   is   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "7.2   Misleading Calculation in ", "body": " _deleteSigningKey  The _deleteSigningKey function deletes a (key, signature) pair from storage by writing zeroes to the bytes where they were stored.  function _deleteSigningKey(uint256 _nodeOperatorId, uint256 _keyIndex) internal {     uint256 offset = _signingKeyOffset(_nodeOperatorId, _keyIndex);     for (uint256 i = 0; i < (PUBKEY_LENGTH + SIGNATURE_LENGTH) / 32 + 1; ++i) {         assembly {             sstore(add(offset, i), 0)         }     } }  of   number   The  expression (PUBKEY_LENGTH  +  SIGNATURE_LENGTH)  /  32  +  1.  However,  this  calculation  relies  on  the  fact that  PUBKEY_LENGTH  is  not  divisible  by  32,  and  that  SIGNATURE_LENGTH  is.  The  calculation  is misleading as it is not correct in the general case, where the lengths could assume any value.  calculated   zeroed   bytes   the   out   be   to   in   is   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "7.3   Staking Modules Can DOS", "body": "  The staking router makes external calls to the staking modules in several situations. For example, when making a deposit, it calls into all active staking modules to query their validator key stats. This means that a revert by any single module prevents the staking router from depositing to any other module.  While the modules are trusted in general, it should be ensured in their development that these calls do not propagate the potential denial of service attack one level deeper, e.g. to the users running validators in the case of some distributed validator technology.  Lido - Staking Router -   23  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/lido-staking-router/"}, {"title": "5.1   Performance Updates Can Be Sandwiched", "body": "  The  performance  safeguard  validates  that  the  performance  based  on  a  unit  of  pool  token  does  not deviate  too  much  from  the  old  performance  after  a  swap.  Updating  the  performance  is  permissionless when  a  perfUpdateInterval  (within  0.5  to  1.5  days)  has  elapsed.  If  the  allowed  performance deviation is x%, one can bundle a performance update within two swaps to achieve around 2x% deviation, that  performance  can  at  most  change  x%  within  one which  breaks  perfUpdateInterval.  the  assumption   CS-SLSGP-008  Swaap Labs - SafeguardPool -   12  SecurityDesignCorrectnessCriticalHighMediumLowRiskAcceptedCorrectnessLowVersion1RiskAccepted             \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Reentrancy via Vault   -Severity Findings  Incorrect Rounding Directions   Incorrect Target Deviation Computation    Missing Sanity Checks at Pool Initialization   -Severity Findings   Balance Based Penalty Can Be Manipulated    Price Feed Data Validity Checks   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-finance-safeguardpool/"}, {"title": "6.1   Reentrancy via Vault", "body": "  0  1  3  2  CS-SLSGP-012  The Balancer V2 Vault has a known vulnerability to read-only-reentrancy:  https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345.  The balances during onJoin/onExit are updated after new shares are minted/burned. And before balance update, the Vault performs a call to external address with the remaining ETH.  The following scenario is possible:   A large LP awaits the time when the updatePerformance() can be called.   LP exits in a balanced way(no updatePerformance triggered yet) and triggers the reentrancy from  the Vault.  In the reentrant call the pool.updatePerformance() is executed. The reentrancy guard on Pool won't be triggered, because it is the Vault that makes the reentrant call.   The   performance   but Vault.getPoolTokens() will return not yet updated balances. Thus the performance will be too high.  values.  PT  will   snapshots  wrong   burned,   already   be   This reentrancy is due to the way Vault contract deals with the ETH that is sent along with swap/join/exit call using _handleRemawiningEth function.  As  a  result,  wrong  performances  will  be  saved  for  a  given  performance  update  period.  This  will  cause DoS in case of exit (performances are too high), or disable the performance based checks for the whole period.  This applies to getPoolPerformance function as well.  Swaap Labs - SafeguardPool -   13  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedDesignHighVersion1CodeCorrected           \f  The reentrancy issue has been fixed in the Vault contract, where the update of the balances is now done before the token transfers.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-finance-safeguardpool/"}, {"title": "6.2   Incorrect Rounding Directions", "body": "  Most computations in SafeguardPool are based on 18 decimals for higher precision. However, rounding errors  are  not  properly  handled  in  some  cases,  where  it  may  round  towards  the  advantage  of  users instead of the pool.  In  calcJoinSwapAmounts(),  the  swapAmountIn  is  computed  using  divDown.  Then  the  rOpt  is computed from this value:  CS-SLSGP-002  uint256 swapAmountIn = num.divDown(denom); uint256 swapAmountOut = swapAmountIn.divDown(quoteAmountInPerOut);  function calcJoinSwapROpt(uint256 excessTokenBalance, uint256 excessTokenAmountIn,     uint256 swapAmountIn ) internal pure returns (uint256) {     uint256 num   = excessTokenAmountIn.sub(swapAmountIn);     uint256 denom = excessTokenBalance.add(swapAmountIn);     return num.divDown(denom); }  However, the num will be computed as excessTokenAmountIn.sub(swapAmountIn), thus it will be effectively rounded up. This might result in minting more shares than intended.  A similar case exits in calcExitSwapAmounts() though it is unclear which rOpt is larger.  In addition, in _exitBPTInForExactTokensOut() the bptAmountOut is rounded down. This lowers the amount of shares the user needs to burn. As a result, the pool tokens can lose value with time due to exit conditions that do not favor remaining pool token holders.  uint256 bptAmountOut = totalSupply().mulDown(rOpt);  In  another  note,  _getOnChainAmountInPerOut()  and  calcBalanceDeviation  round  down  the computations. This may make the fairPricingSafeguard and balance based checks slightly weaker. However, in other places, it is unclear if the computation should round up or down (e.g. computation of currentPerformance in _updatePerformance()).    The  calcJoinSwapROpt()  now  subs  1  wei  from  numerator  and  adds  1  wei  to  denominator.  This effectively  lowers  the  number  of  tokens  minted  during  the  deposit  by  a  small  amount,  that  always guarantees that the balances per PT values won't decrease during balanced join.  The  calcExitSwapROpt()  now  adds  1  wei  to  numerator  and  subs  1  wei  from  denominator.  This effectively increases the number of tokens burned during the withdrawal by a small amount, that always guarantees that the balances per PT values won't decrease during balanced exit.  The  _exitBPTInForExactTokensOut()  has  been  fixed  to  use  mulUp  instead  of  mulDown  to compute the amount of pool tokens burned upon a withdrawal.  Swaap Labs - SafeguardPool -   14  SecurityMediumVersion1CodeCorrected        \fThe  rounding  in  calcBalanceDeviation  can  effectively  be  accounted  by  the  quote  generating front-end.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-finance-safeguardpool/"}, {"title": "6.3   Incorrect Target Deviation Computation", "body": "  The  balance  safeguard  validates  that  the  HODL  balance  of  the  output  token  after  a  swap  does  not deviate  too  much  from  it  before  the  swap  (target  deviation).  This  is  computed  in  the  wrong  way  in _getPerfAndTargetDev(),  where  the  numerator  should  be  newBalanceOutPerPT  instead  of newBalanceOut. The target deviation should be in %, however, this wrongly computed value represents the amount of pool tokens.  CS-SLSGP-003    The  deviation  newBalancePerPTOut.divDown(hodlBalancePerPTOut).  target   now   is   correctly   computed   as  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-finance-safeguardpool/"}, {"title": "6.4   Missing Sanity Checks at Pool Initialization", "body": "  There  is  no  sanity  check  on  the  user's  input  token  amounts  amountsIn  as  well  as  the  initial  HODL balance at the pool initialization.  In case a user initializes the pool with 0 amountsIn, the pool becomes useless irreversibly:  CS-SLSGP-004   Anyone can mint any amount of pool tokens by depositing 0 liquidity.   No swap is possible as there is no liquidity.  A user can also disable swaps by initializing the pool with a small amountsIn, where the HODL balance rounds down to 0. Assuming there is a pool of two tokens with 18 decimals, due to the following behavior of the _onInitializePool:   User initializes with amountsIn = [1 wei, 1 wei].   After scaleUp, amountsIn = [1 wei, 1 wei] because the tokens already have 18 decimals.  the HODL balance is computed as 1 * 10^18 / (100 * 10^18), which rounds down to 0.  If both hold balances are 0, the _updatePerformace and _getPerfAndTargetDev will revert due to the division by 0.    A  check  was  added  in  the  _onInitializePool()  function,  that  requires  both  amountsIn[0]  and amountsIn[1]  to  be  at  least  _MIN_INITIAL_BALANCE  =  1e8.  This  way,  issues  due  to  division  by zero will be avoided.  Swaap Labs - SafeguardPool -   15  CorrectnessMediumVersion1CodeCorrectedSecurityMediumVersion1CodeCorrected                   \f6.5   Balance Based Penalty Can Be Manipulated  In  case  the  current  pool  balance  is  less  than  the  pool  balance  at  the  quote  time,  a  penalty  will  be enforced on the quote price during a swap. However, the balance of the pool can be easily manipulated by Join or Exit.  In case there is a balance based penalty, a user can bypass it by Just In Time (JIT) liquidity provision:  CS-SLSGP-001   Join the pool to push the balance back to quote time.   Swap without balance based penalty.   Exit after the swap.  By having a valid quote and doing join-swap-exit bundle, users can bring the state of the pool balances in a  state,  where  other  \"pending\"  quotes  are  blocked  by  the  balance  based  penalty.  Thus,  using join-swap-exit bundle user can:   Bypass paying the balance based penalty fees   Avoid the maxDeviation check.  However, in join-swap-exit the user will only get fraction of the maxSwapAmount total swap value, due to the need to provide out token as an asset during join.  A swap can also be front-run by a liquidity provider's exit, which aggravates the balance based penalty. This way an exit-swap-join, (swap is sandwiched by malicious LP) can:   Revert the swap   Enforce the higher balance penalties on the swap.  This  can  be  seen  as  a  DoS  attack,  however  it  requires  significant  gas  with  no  clear  benefit  for  the attacker.    Swaap Labs responded:  The new balance based penalty also takes into consideration the balance change per PT as well as the balance change: penalty = max(balanceChange, balanceChangePerPT) * slippage  Since  joins  and  exits  do  not  change  the  balances  per  PT,  this  check  will  not  be  bypassable  by join-swap-exit bundle. Thus, swaps with quoted balances that differ too much from the onchain conditions will not be executable.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-finance-safeguardpool/"}, {"title": "6.6   Price Feed Data Validity Checks", "body": "  SafeguardPool  uses  chainlink  oracle  to  retrieve  the  price  feed  for  tokens.  However  the  checks  in ChainlinkUtils.getLatestPrice are missing or not strong enough:  CS-SLSGP-005   _ORACLE_TIMEOUT  is  a  constant  of  1.5  days  which  could  be  too  large.  The  heartbeat  of  most datafeeds  smaller: https://docs.chain.link/data-feeds/price-feeds/addresses#Ethereum%20Mainnet. Any  round  that  is  older  than  the  Heartbeat  cannot  be  considered  fresh.  This  might  happen  due  to potential ChainLink failures.  much   is   Swaap Labs - SafeguardPool -   16  DesignLowVersion1CodeCorrectedSecurityLowVersion1CodeCorrected              \f ChainLink  getLatestRound  returns  roundId  and  answeredInRound.  However,  they  are  not inspected. In ChainLink OCR pricefeeds the roundId and answeredInRound are always equal. However, older versions of pricefeeds require validation, that the round data was not computed in an old  roundId): https://docs.chain.link/data-feeds/historical-data#getrounddata-return-values.  Please  be  aware  of this and check for each deployed pool what pricefeed version is used.  round(answeredInRound   should   than   less   not   be     Swaap Labs responded:  Each oracle in a pool has its own maximum timeout (=< 1.5 days) which is immutable and defined at deployment time. The roundId and answeredInRound are checked .  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-finance-safeguardpool/"}, {"title": "6.7   Events Indexed Params", "body": "  The quoteIndex in ISignatureSafeguard is not indexed. It functions as a random-order nonce for quote signatures. Querying on-chain information about which quote is exhausted is easier if this field is indexed.  CS-SLSGP-013  event SwapSignatureValidated(bytes32 digest, uint256 quoteIndex); event AllowlistJoinSignatureValidated(bytes32 digest);  Similarly, digest params in both events can be indexed.    quoteIndex as well as digest of both events has been marked as indexed in the updated code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-finance-safeguardpool/"}, {"title": "6.8   Outdated Dependency of Balancer Pool", "body": " Factory  CS-SLSGP-011  One of SafeguardPool's dependency Balancer's BasePoolFactory has been updated in March where create2()  found  here: https://github.com/balancer/balancer-v2-monorepo/pull/2362  instead  of  create().  The   request  can  be   full  merge   is  used     Balancer dependency is updated. CREATE2 opcode with an extra salt parameter is now used to deploy the pools.  Swaap Labs - SafeguardPool -   17  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected              \f6.9   Performance Safeguard Sensitivity  The  HODL  balances  are  set  on  initializing  pool,  and  during  the  updates  they  are  multiplied  by performance.  This  effectively  fixes  during  the  initialization  the  proportion  of  assets  that  are  used  for performance  safeguard.  If  the  price  of  assets  changes  significantly  over  time,  the  difference  between balance0/balance1 and hodlBalance0/hodlBalance1 can cause significant sensitivity to price changes. In addition, this imbalance can be caused intentionally during the initialization.  CS-SLSGP-007  For example:  1. Pool initialized with 1 Eth and 100k USD as assets. The hodlBalanceETH = 1, hodlBalanceUSD = 100k.  Assume  that  BPT  is  always  1.  At  this  time  1  ETH  ==  1000  USD.  TLV  =  101000  USD  == holdTVL  2. Over time, with help of swap the balance of pool becomes: 50 ETH and 1000 USD, with 2000 USD as  ETH  price.  TLV  =  101000  USD.  old  hodlTVL  =  1100  Since  TVL  does  not  change,  the holdBalanes will not change as well.  3. Without any balance changes, if price of ETH becomes 1900 USD == 5% drop: TLV = 96k USD.  hodlTVL = 101900. newTVL/hodlTVL = 0.942 > 5% drop  Thus, due to the initial proportion of hold balances the hodl performance of the pool was affected more than the asset price. Also, note that the balances of tokens itself did not change between 2 and 3. Just the change of the oracle price can be enough to make swaps fail due to the performance safeguard.    Swaap  Labs  have  updated  the  code  that  the  performance  safeguard  will  be  bypassed  if  a  swap  is rebalancing the current pool towards the hodl balance ratio.  if (newBalancePerPTOut < hodlBalancePerPTOut || newBalancePerPTIn > hodlBalancePerPTIn) {    _srequire(          _getPerfFromBalancesPerPT(newBalancePerPTIn,newBalancePerPTOut,             hodlBalancePerPTIn,hodlBalancePerPTOut,onChainAmountInPerOut          ) >= _getMaxPerfDev(packedPoolParams),          SwaapV2Errors.LOW_PERFORMANCE    ); }  Swaap Labs stated:  The idea is to allow the rebalancing of assets even if we do not have good performance in order not to find the pool stuck with undesired asset ratios.  Swaap Labs - SafeguardPool -   18  InformationalVersion1CodeCorrected    \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-finance-safeguardpool/"}, {"title": "7.1   Imbalanced Join Order", "body": "  User  can  call  _joinExactTokensInForBPTOut()  to  join  the  pool  in  an  imbalanced  way.  There  are two approaches to achieve the same imbalanced join:  1. excess tokens are swapped for limited tokens first, then a balanced join is executed.  2. a balanced join is executed first, then do a swap to achieve the same result.  SafeguardPool  takes  the  first  approach.  However,  as  the  pool  balance  at  swap  time  is  smaller  in approach  1  compared  to  approach  2,  it  could  induce  higher  balance  based  penalty  and  consequently prevent a transition that actually benefits the system.  CS-SLSGP-006  Acknowledged:  Swaap Labs responded:  We  chose  to  keep  this  approach  as  it  is  easier  to  produce  a  quote  for  this  kind  of  operation  &  it\u2019s more gas efficient and easier to check the post trade safeguards. In addition a user can separately swap and then join the pool even if we change the approach.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-finance-safeguardpool/"}, {"title": "7.2   Invalidation of Quotes", "body": "  The  signed  quotes  remain  valid  until  they  are  either  executed  or  reach  their  deadline.  No  functionality allows  a  specific  quote  to  be  invalidated.  However,  changing  the  signer  will  invalidate  all  previously signed quotes. In case the signer role holder is changed from Alice to Bob and then back to Alice, all the un-expired  quotes  Alice  signed  before  will  become  valid  again.  These  facts  must  be  considered throughout the contract's lifespan.  CS-SLSGP-009  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-finance-safeguardpool/"}, {"title": "7.3   Management Fees and Swap Safeguards", "body": " Relation  The  _claimManagementFees  is  called  before  any  swap  or  join,  but  not  during  the  swaps.  This  can affect the safeguard that rely on per PT values. E.g. if _claimManagementFees is called after a long period, the hodl balances per pt will drop, due to newly minted PT shares. Then, the safeguards can fail  CS-SLSGP-010  Swaap Labs - SafeguardPool -   19  InformationalVersion1AcknowledgedInformationalVersion1InformationalVersion1            \funtil next snapshot of the hodl balances. Due to the low rate of management yearly fees (5%), this should not be a problem.  Swaap Labs - SafeguardPool -   20  \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-finance-safeguardpool/"}, {"title": "8.1   Consistency of Input Arguments Scale", "body": "  Most of the computations work with values of 18 decimals. Input amounts for tokens that have less than 18 decimals will be first scaled up by a scaling factor to reach 18 decimals. In SafeguardPool, some of the input argument amounts are expected to be already scaled up, while the others (mostly coming from Vault) are not.  Examples of such differences:  In _onInitializePool(), amountsIn in userData needs to be not upscaled.  In _joinExactTokensInForBPTOut(), joinAmounts in userData needs to be already scaled up.  In _exitBPTInForExactTokensOut(), exitAmounts in userData needs to be already scaled up.  onSwap(),   In  quote.maxSwapAmount needs to be upscaled.  SwapRequest.amount   needs   to   be   not   upscaled,   however  Scaling  the  value  off-chain  is  gas-efficient,  but  requires  the  correct  input  data  generation.  If  directly submitting a transaction to the contract, users should be aware of which parameters should be scaled up and which should not.  Swaap Labs - SafeguardPool -   21  NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/swaap-finance-safeguardpool/"}, {"title": "5.1   Redundant External Calls", "body": "  The  function  calculateTargetSupply()  makes  redundant  calls  to  the  interest  strategy  contract  to get  the  variableRateSlope1  value.  It  would  be  more  efficient  if  the  return  value  of  the  first  call  is stored in memory, hence avoiding the second call.  Similarly,  the  function  exec()  makes  two  external  calls  to  get  the  total  debt  (from  stableDebt  and variableDebt),  and  then  calls  the  calculateTargetSupply()  which  makes  again  the  same external function calls.  Acknowledged:  Maker acknowledges:  This function is only called by a keeper bot, and likely infrequently enough to not overly worry about gas savings. Will re-assess if exec() starts getting called a lot.  MakerDAO - D3M -   9  DesignCorrectnessCriticalHighMediumLowAcknowledgedDesignLowVersion1Acknowledged            \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings  ink Used as daiDebt   0  0  0  1  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-module-d3m/"}, {"title": "6.1   ink Used as daiDebt", "body": "  Function _unwind() contains following comment:  // IMPORTANT: this function assumes Vat rate of this ilk will always be == 1 * RAY (no fees).  This means the debt in art equals the amount in DAI.  The value for daiDebt is queried as follows:  if (mode == Mode.NORMAL) {     // Normal mode or module just caged (no culled)     // debt is obtained from CDP ink (or art which is the same)     (daiDebt,) = vat.urns(ilk, address(this));  Note that the first return value is the ink while the second one is the art. Hence the ink and not the art is used as value for the debt in DAI. As documented, this requires that the rate for the collateral is 1. However, additionally it is required that the spot price of the collateral must always be 1. This is not fully documented.  In Function reap the daiDebt is the art:  (, uint256 daiDebt) = vat.urns(ilk, address(this));    The value for daiDebt in function _unwind is now based on the art of the CDP.  MakerDAO - D3M -   10  CriticalHighMediumLowCodeCorrectedCorrectnessLowVersion1CodeCorrected         \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-module-d3m/"}, {"title": "7.1   Possible Overflow for 2 ** 255", "body": "  The functions _unwind(), exit(), cull() and quit() check if a conversion of a uint256 value to  a  negative  int256  overflows:  require(value  <=  2  **  255).  Theoretically,  if value == 2 ** 255 the overflow will happen twice, but the result matches the expected value in such cases.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-module-d3m/"}, {"title": "7.2   Shutdown Vat and exit()", "body": "  exit() does not explicitly check whether the Vat is not live. Technically this seems to be unnecessary as during normal operation only this contract can have a non-zero entry for this special gem. However given that it's so unlikely that the exit function is used and the dire consequences if for any other reason an  account  has  a  non-zero  balance  of  this  gem,  it  is  worth  considering  adding  the  explicit  check  as  a precautionary measure.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-module-d3m/"}, {"title": "7.3   Shutdown of Vat", "body": "  In case of a shutdown of the Vat, the ideal scenario for this module is that all its debt can be unwound in the first phase of the shutdown.  Should  this  not  be  possible,  e.g.  because  there  was  no  sufficient  liquidity  in  the  Aave  pool  or  no  one called  exec  before  MCD_END.debt()  was  set,  the  settlement  of  the  remaining  DAI  holders  gets complicated:  In this phase of the settlement, users receive a share of all ilks. These shares are jointly worth one DAI for each DAI redeemed by the user. These shares will include the collateral share of this special ilk. For this ilk, special handling is necessary. However, after some steps, users have a Vat.gem balance which they can exit.  For this special ilk no join adapter exists and users will have to use the exit() function of this contract and receive aDAI.  Two scenarios can happen:   This aDAI is worthless as there is no liquidity in the aDAI pool and users are unable to redeem their aDAI for DAI. This could happen because free DAI have been submitted in the shutdown process. During  global  settlement,  however,  the  price  of  one  aDAI  was  taken  as  1  DAI.  The  overall consequence is that users receive less than one dollar worth of collaterals for 1 DAI \"cashed out\".   There  is  remaining  liquidity  in  the  Aave  pool  and  users  can  redeem  their  aDAI  for  DAI.  Having received this new DAI, the user can now redeem this DAI, again receiving a share of all collaterals including aDAI again. Note that, as many ilks exist, in practice this will be a very small percentage overall. Hence users may do following workaround:  MakerDAO - D3M -   11  NoteVersion1NoteVersion1NoteVersion1          \f1. Exit their share of the gem for this special ilk and receive aDAI first.  2. Convert this aDAI to DAI by withdrawing from the pool.  3. Redeeming this DAI. This increases the gem balance of the users for all ilks.  4. Only  now  exit  the  other  gems.  The  aDAI  received  at  this  step  may  be  forfeited  as  their value like is negligible and the user was able to redeem his DAI for collateral being worth close to 1 dollar.  MakerDAO - D3M -   12  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-direct-deposit-module-d3m/"}, {"title": "6.1   Skim in _Free()", "body": "  0  0  0  3  For  End.free()  to  be  successful,  the  proxy's  art  must  be  zero.  However,  the  following  code  of DssProxyActionsEnd._free() does not strictly enforce that.  function _free(     address end,     uint256 cdp ) internal returns (uint256 ink) {     bytes32 ilk = manager.ilks(cdp);     address urn = manager.urns(cdp);     uint256 art;     (ink, art) = vat.urns(ilk, urn);     // If CDP still has debt, it needs to be paid     if (art > 0) {         EndLike(end).skim(ilk, urn);         (ink,) = vat.urns(ilk, urn);     }     // Approves the manager to transfer the position to the proxy's address in the vat     if (vat.can(address(this), address(manager)) == 0) {         vat.hope(address(manager));     }     // Transfers position from CDP to the proxy address     manager.quit(cdp, address(this));     // Frees the position and recovers the collateral in the vat registry     EndLike(end).free(ilk); }  First,  in  case  that  art  is  non-zero,  end.skim()  is  executed  on  the  urnproxy.  Next,  the  position  is transferred  to  the  proxy.  Note  that  the  proxy  could  have  non-zero  art.  Hence,  the  call  end.free() which frees the collateral of its msg.sender and requires that art is zero could revert.    MakerDAO - DSSProxyActions -   12  CriticalHighMediumLowCodeCorrectedCodeCorrectedCodeCorrectedDesignLowVersion1CodeCorrected        \fNow,  skim()  is  called  for  the  proxy  and  after  the  CDP  has  been  transferred  from  the  urn.  Thus,  it  is enforced that art will be zero.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dssproxyactions/"}, {"title": "6.2   Unused Function _sub()", "body": "  The internal function _sub is never used.    The unused function was removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dssproxyactions/"}, {"title": "6.3   Use Defined Constant", "body": "  Contract Common defines:  uint256 constant RAY = 10 ** 27;  Instead of using the constant, function _toRad has this value hardcoded:  function _toRad(uint256 wad) internal pure returns (uint256 rad) {     rad = _mul(wad, 10 ** 27); }    This function has been removed in the final version of the code reviewed.  MakerDAO - DSSProxyActions -   13  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dssproxyactions/"}, {"title": "7.1   Dust Amount of DAI to Be Drawn Leads to", "body": " Revert  There is a known issue in functions that use _getDrawDart(): In case the additional amount of DAI to be drawn leads to a dusty urn, the transaction reverts. This is a known edge case.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dssproxyactions/"}, {"title": "7.2   dai Shadowed", "body": "  Contract Common defines the immutable dai. The internal functions _getDrawDart, _getWipeDart and _getWipeAllWad each define a local uint256 dai which consequently shadows the immutable.  In    the variables in the functions have been renamed.  MakerDAO - DSSProxyActions -   14  NoteVersion1NoteVersion1Version2      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/makerdao-dssproxyactions/"}, {"title": "5.1   Unhandled Alternative Flashloan Providers", "body": "  Currently the MultiplyProxyActions relies on the assumption that the lender will call onFlashLoan() and revert  if  the  flashloan  fails.  However,  EIP-3156  does  not  require  flashLoan()  to  revert  if  it  is unsuccessful.  In  any  scenario  where  the  flash  loan  fails  but  does  not  revert,  the  funds  sent  to  the MultiplyProxyActions could remain in the contract (since it is possible that onFlashLoan() is not called) and can be accessed by anyone via direct call to the onFlashLoan(). In addition, only relying on the bool return value of flashLoan() is insufficient since returning true is also allowed in case of failures.  The DssFlashmit contract reverts if onFlashLoan() fails. However, using another flashloan EIP-3156 lender contract can potentially lock the funds of the users.  Risk accepted:  Oazo Apps Limited plans on using FMM solely.  Oazo Apps Limited - Multiply FMM extension -   10  DesignCorrectnessCriticalHighMediumLowRiskAcceptedDesignLowVersion1RiskAccepted            \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  Incorrect Balance Check for Vault   Incorrect Conversion to 18 Decimals   -Severity Findings  0  0  2  0  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-fmm-extension/"}, {"title": "6.1   Incorrect Balance Check for Vault", "body": "  Checking whether the MultiplyProxyActions contract holds enough funds has been modified to:  require(   cdpData.requiredDebt.add(cdpData.depositDai) >= IERC20(DAI).balanceOf(address(this)),   \"requested and received amounts mismatch\" );  The check should ensure that the MultiplyProxyActions contract holds enough Dai for the operation on the vault. Thus, if less DAI than needed is available the code should revert while a surplus of DAI could be tolerated. However, the change proceeds with the execution if the balance is lower than the amount needed while it reverts if there is a surplus of DAI.    The condition has been changed to <=.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-fmm-extension/"}, {"title": "6.2   Incorrect Conversion to 18 Decimals", "body": "  An  additional  call  to  convertTo18()  has  been  added  compared  to  the  codebase  from  the  previous report.  In _closeWithdrawCollateralSkipFL(), the following code is executed:  cdpData.withdrawCollateral = convertTo18(cdpData.gemJoin, cdpData.withdrawCollateral);  wipeAndFreeGem(   addressRegistry.manager,   cdpData.gemJoin,  Oazo Apps Limited - Multiply FMM extension -   11  CriticalHighMediumCodeCorrectedCodeCorrectedLowCorrectnessMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                  \f  cdpData.cdpId,   cdpData.requiredDebt,   cdpData.withdrawCollateral );  wipeAndFreeGem()  contains  cdpData.withdrawCollateral:  the   following  code  where  collateralDraw   is  equal   to  uint256 wadC = convertTo18(cdpData.gemJoin, collateralDraw);  Thus,  withdrawCollateral*10**(18-gem.decimals())*10**(18-gem.decimals()).  that results in an incorrect amount.  wadC   will   be Ultimately,    The conversion to 18 decimals has been removed in _closeWithdrawCollateralSkipFL().  Oazo Apps Limited - Multiply FMM extension -   12  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-multiply-fmm-extension/"}, {"title": "5.1   Defaulted Loan Repayment", "body": "  CS-TFCarbon-001  Loans  can  be  marked  to  be  repayable  after  default.  In  the  case  of  a  defaulted  loan  being  repaid  later, new  investors  of  the  equity  tranche  gain  an  unfair  advantage  over  users  that  invested  in  the  tranche before the loan has been marked as defaulted.  This behavior can even be exploited by borrowers to regain some of the repaid loan by investing in the equity tranche after the default of their own loan. Consider the following example (assuming no fees and interest for simplification):   A portfolio consists of 3 tranches and is in Live status with no active loans.   Users have deposited 100 tokens to each tranche with no accrued interest (i.e., 1 share per token).   A new loan of 99 tokens is issued to a borrower.   After some time, the manager marks the loan as defaulted.   The value of the equity tranche is now 1 token with a total supply of 100 shares.   The borrower deposits 100 tokens into the equity tranche and receives 10,000 shares back.   The borrower repays the loan, raising the equity tranche's value to 200 tokens.   The borrower is now entitled to ~198 tokens in the tranche.  TrueFi - Carbon -   11  SecurityDesignCorrectnessCriticalHighAcknowledgedMediumRiskAcceptedRiskAcceptedLowRiskAcceptedRiskAcceptedDesignHighVersion1Acknowledged           \fIssue acknowledged:  TrueFi replied:  we are aware of this issue, but it's more of manager responsibility to pause deposits/withdrawals in case  of  risk  in  portfolio  (so  before  marking  loan  as  defaulted  manager  should  first  disable deposits/withdrawals)  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "5.2   DoS for Start", "body": "  The  manager  can  turn  the  system  Live  by  calling  StructuredPortfolio.start().  When  this  is done, the system checks if the ratios of the values stored in each tranche are appropriate. If it is not, the transaction  reverts.  This  means  that  depositing  or  withdrawing  an  amount  -  if  allowed  -  before  the manager  calls  start  can  block  the  system  from  turning  live  since  the  ratios  will  not  be  correct.  The depositController  and  withdrawController  enforce  a  ceiling  and  a  floor  respectively  but  the issue can still arise.  CS-TFCarbon-002  Risk accepted:  TrueFi accepted the risk giving the following statement:  Shouldn\u2019t occur, but in case managers want to be safe, withdrawals and deposits can be disabled before starting the portfolio.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "5.3   Loan Default Frontrunning", "body": "  In Live state, and if withdrawals are enabled, lenders in any tranche can withdraw the full amount even if there are open loans that are using some of the available funds. Consider the following example:  CS-TFCarbon-003   Each tranche has a value of 100 tokens.   A loan for 150 tokens has been issued.   Users of the junior tranche now withdraw all 100 tokens.   The loan defaults resulting in the value of the senior tranche being reduced to 50.  If the users in the junior tranche observe the call to StructuredPortfolio.markLoanAsDefaulted, they can frontrun it to redeem all of their tokens, while the other tranches suffer from the loss.  Risk accepted:  TrueFi accepted the risk giving the following statement:  Shouldn\u2019t occur, but in case managers want to be safe, withdrawals can be disabled before calling StructuredPortfolio.markLoanAsDefaulted.  TrueFi - Carbon -   12  DesignMediumVersion1RiskAcceptedSecurityMediumVersion1RiskAccepted                  \f5.4   Fee Transfer DoS  Fees are (as long as funds are available) transferred onto the protocol treasury and manager beneficiary address  on  every  interaction.  Since  the  manager  beneficiary  might  be  an  EOA  also  used  in  other activities,  and  since  some  tokens  implement  blacklisting  (e.g.,  USDC)  or  pausing  (e.g.,  BNB),  portfolios using such underlying tokens could be susceptible to a Denial of Service when the manager beneficiary address is used in an illicit activity or the token is set to a paused state.  CS-TFCarbon-004  Risk accepted:  TrueFi responded:  Both addresses are trusted and can be changed in case of emergency. Changes were introducing too  much  complexity  in  the  code.  There  was  a  code  change  in  setManagerFeeBeneficiary  to first change beneficiary and then pay the fee as otherwise function was reverting.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "5.5   Lost Repayments in Closed State", "body": "  If a portfolio is closed, users are encouraged to withdraw their assets as no interest accrues anymore but protocol fees are still accrued. If a tranche is completely emptied by withdrawals (i.e. there are no more shares) and a repayment occurs, the repaid value in that tranche is lost as no one is able to withdraw these assets (apart from the protocol admin that can update the implementation contract).  CS-TFCarbon-005  Risk accepted:  The client accepts the risk with the following statement:  By default there is protocol fee in closed state to encourage withdrawal of the assets as there always is  small  smart  contract  risk.  But  in  case  there  was  a  default  and  the  manager  is  in  process  of regaining the assets they should create a proposal to disable protocol fees on that portfolio. It\u2019s the matter of communication between manager and lenders. If they want to exit early they can, but then they won\u2019t be able to profit from recovered funds.  TrueFi - Carbon -   13  SecurityLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  1  3  12  -Severity Findings  -Severity Findings   Waterfall Miscalculation   -Severity Findings   Calling StructuredPortfolio.updateCheckpoints Increases Deficit    Fees in Deficit    No Deficit Update on Deposit / Withdrawal   -Severity Findings   Fee Accrual on Unpaid Fees    Unpaid Fee Calculation    Balance Underflow    Gas Optimizations   Imprecise Specifications    Missing Interface Functions    Missing Sanity Check    Shadowed Variable    Specification Nonconformity    Unused Function    Unused Return Value    configure Function Does Not Include TransferController   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "6.1   Waterfall Miscalculation", "body": "  CS-TFCarbon-013  The  can  StructuredPortfolio.updateCheckpoints. We expect the following property to hold:  updated   tranche   anyone   value   be   by   of   a   by   calling  Executing updateCheckpoints consecutively in one block (with no other transactions in between) should not change the checkpoints since no time has passed and the value of the portfolio has not been changed.  However,  this  property  does  not  hold.  To  showcase  that,  we  need  to  consider  how  the  waterfall  is calculated.  The waterfall is calculated by using each tranche's checkpoints and adding the deficit of a tranche to it. This  is  considered  the  total  assumed  value  of  the  tranche.  This  means  that  if  we  would  call  TrueFi - Carbon -   14  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrected         \fupdateCheckpoints  multiple  times,  the  deficit  of  a  tranche  would  be  added  up  again  on  every calculation of the waterfall.  Normally, however, this is not the case since the resulting waterfall values are bound by the total value of the  portfolio  (virtual  token  balance  +  loans  value)  that  hasn't  been  used  by  the  less  risky  tranches. Therefore, we assume the following property:  If a tranche has a deficit > 0, all riskier tranches (i.e., all tranches with a lower waterfall index) have a value of exactly 0.  In practice, this assumption does not hold as can be seen in the following example (assuming no fees and no compounding for simplification):   The senior tranche has a 1% interest.   The junior tranche has a 2% interest.   Each tranche holds a value of 100 tokens.   Two loans are issued:   Loan A: 102 tokens with 0% interest.   Loan B: 180 tokens with 10% interest.   Loan A defaults.   A deficit of 2 tokens is added to the junior tranche and the equity tranche now holds 0 value.   After one year, the total assets of the portfolio is 216 (18 tokens in balance + 180 tokens in principal  of open loans + 18 tokens in interest).   The Senior tranche should hold 101 tokens.   The Junior tranche should hold 102 tokens but still has a deficit of 2 tokens.   The equity tranche is assigned 13 tokens.  This violates the assumed property. We can now call StructuredPortfolio.updateCheckpoints multiple times and add up the deficit of 2 tokens, until the value of the junior tranche is 115 and the value of the equity tranche is 0. After 1 year, the junior tranche has now accrued 15% interest while it should have  accrued  2%.  In  other  words,  calling  the  StructuredPortfolio.updateCheckpoints consecutively changes the value of the tranches.    If some loan in a portfolio has defaulted, StructuredPortfolio.updateCheckpoints subtracts the delta of the previous and the updated value of a tranche from the tranche's deficit. This allows the deficit to be settled with accrued interest, fixing the described problem.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "6.2   Calling ", "body": " StructuredPortfolio.updateCheckpoints Increases Deficit  Given a portfolio where all 3 tranches have a value of 100 tokens each and the manager fee is set to 2% for all tranches, consider the following sequence:  CS-TFCarbon-007  TrueFi - Carbon -   15  CorrectnessMediumVersion3CodeCorrected        \f1. A loan is issued for 300 tokens, i.e., the full value held by the portfolio (with 1% interest).  2. The loan is marked as defaulted.  3. This means that the deficit for the senior and the junior tranches is 100 and the value held by  them is 0.  4. A year passes by.  5. A user calls StructuredPortfolio.updateCheckpoints. At this point the assumed value of the senior tranche is 103 i.e., 2 tokens manager fee plus the deficit which is 101 for each tranche. The real assets held are 0 thus the new deficit is set to 103 which gets checkpointed.  6. A  user  calls  StructuredPortfolio.updateCheckpoints  again.  At  this  point  the  assumed value is 105 (103 is the previous deficit plus 2 for the manager fees).  This means that the deficit increases with every call to updateCheckpoints while it shouldn't. Note that when the portfolio closes, the deficit is used to set the maxValueOnClose which determines the amount of assets expected to be filled into each tranche by possible loan repayments.    In the current implementation, the fees are properly deducted so that they are not counted multiple times.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "6.3   Fees in Deficit", "body": "  StructuredPortfolio._calculateLoansDeficit  updates  tranche  deficits  by  calculating  the current assumed value of the tranche and subtracting the accrued fees and current waterfall value of that tranche. The fees are calculated on the full assumed value (including the deficit generated by defaulted loans):  uint256 assumedPendingFees = tranches[i].totalPendingFeesForAssets(assumedTotalAssets);  CS-TFCarbon-010  actual   The  by the  TrancheVault.updateCheckpointFromPortfolio. It is calculating fees with the current waterfall value (which does not contain defaulted loans) of the tranche:  checkpoints   tranches   updated   are   in   uint256 pendingFee = _pendingProtocolFee(_totalAssetsBeforeFees); ... uint256 pendingFee = _pendingManagerFee(_totalAssetsBeforeFees);  Where _totalAssetsBeforeFees is calculated by this function:  function totalAssetsBeforeFees() public view returns (uint256) {     if (portfolio.status() == Status.Live) {         return portfolio.calculateWaterfallForTrancheWithoutFee(waterfallIndex);     }      return virtualTokenBalance; }  TrueFi - Carbon -   16  CorrectnessMediumVersion1CodeCorrected          \fIn  the  case  of  defaulted  loans,  these  2  calculations  diverge  as  the  assumed  value  will  be  higher  in tranches  with  a  deficit.  Therefore,  the  calculated  fees  will  be  higher  as  well,  reducing  the  deficits  over time while the (paid or unpaid) fees over that time frame are smaller. If at any point the defaulted loan is repaid, the difference will be awarded to the equity tranche.  Consider the following (extreme for demonstration) example:   Consider a portfolio with a really long duration (more than 50 years).   Then manager (and/or protocol) fee are 2%.   Junior tranche has 5% interest, senior tranche has 2% interest.   Each tranche has 100 value.   A loan of 300 value, 1 year runtime and 10% interest is issued.   1 year later, the loan defaults resulting in 0 value for all tranches and 105 / 103 deficit for junior /  senior tranche.   50 years later updateCheckpoints is called. The deficit of junior and senior tranches is now set to  0. Each tranche has ~2 tokens in unpaid fees.   The loan is repaid. Junior and senior tranche hold 0 tokens value, while the equity tranche holds 324  tokens value.    Fees  are  now  calculated  only  based  on  the  value  of  the  waterfall  calculation  and  they  are  propagated along  the  execution  of  the  StructuredPortfolio.updateCheckpoints  as  using  the  array pendingFees.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "6.4   No Deficit Update on Deposit / Withdrawal", "body": "  TrancheVault.deposit() / mint() and withdraw() / redeem() update their checkpoints locally but  never  call  StructuredPortfolio.updateCheckpoints().  Therefore,  the  deficit  in  the tranchesData struct is not updated to the latest value before a user deposit / withdrawal is processed. This means, that the period from the last checkpoint update up until the user action is not accounted for. Consider the following example:  CS-TFCarbon-015   The given vault accrues no fees.   The junior tranche accrues 5% interest per year.   The senior tranche accrues 3% interest per year.   All tranches hold a value of 100 tokens in the beginning.   300 tokens have been disbursed.   180 tokens have been marked as defaulted.   The junior tranche now has 20 totalAssets and 80 deficit.   1 year passes without any interaction on the protocol.   A new user deposits 100 tokens to the junior tranche.   The senior tranche now holds 103 tokens while the junior tranche holds 117 tokens and 80 tokens  deficit.   The manager updates the outstandigAssets back to 300 tokens.  TrueFi - Carbon -   17  CorrectnessMediumVersion1CodeCorrected        \f The junior tranche now holds a value of 201 tokens.  If we, instead, run updateCheckpoints right before the new deposit, the value of the junior tranche is 205  tokens  instead.  That  is,  because  the  call  updates  the  deficit  of  the  tranche  to  88  tokens  (80  +  3 tokens shifted to senior tranche + 5 tokens interest accrued), accounting for the accrued interest.    Deficits are now stored in the TrancheVault checkpoints instead of the StructuredPortfolio and updated every time, the checkpoints are updated.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "6.5   Fee Accrual on Unpaid Fees", "body": "  Fees are calculated by TrancheVault.totalPendingFeesForAssets on the current waterfall value of  the  tranche.  The  waterfall  value  is  calculated  by  _assumedTrancheValue  which  calculates totalAssets:  uint256 assumedTotalAssets = _withInterest(checkpoint.totalAssets, targetApy, timePassedSinceCheckpoint) +         checkpoint.unpaidFees;  CS-TFCarbon-006  totalPendingFeesForAssets calculates the _pendingProtocolFee:  _accruedFee(checkpoint.protocolFeeRate, _totalAssetsBeforeFees)  ... and the _pendingManagerFee:  _accruedFee(managerFeeRate, _totalAssetsBeforeFees)  ... based on the totalAssets value that includes the unpaid fee. That means fees are calculated on past fees if they cannot be paid out immediately.    Unpaid fees are now deducted from the waterfall value. This means that unpaid fees do not contribute to the value on which the fees accrue.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "6.6   Unpaid Fee Calculation", "body": "  If  the  protocol's  virtualTokenBalance  is  lower  than  the  amount  of  fees  that  have  to  be  paid  in  a checkpoint  update,  the  unpaid  amount  is  stored  to  be  paid  for  later  soon  as  the  system  has  some available tokens.  Unpaid  fees  are  also  added  to  each  tranche's  checkpoint.  If  unpaid  fees  have  been  added  to  a checkpoint and sometime later, the checkpoints are updated, the waterfall is calculated by applying the APY to the checkpoint (that contains the unpaid fee), effectively applying the APY to the fee. The saved unpaid  fee  is  then  subtracted  from  the  calculated  value.  This  waterfall  value,  in  turn,  is  stored  in  the checkpoint by adding the unpaid fees again.  CS-TFCarbon-020  TrueFi - Carbon -   18  DesignLowVersion7CodeCorrectedCorrectnessLowVersion5CodeCorrected                \fThe fee is multiplied by the APY, then the fee is subtracted and then added again. This means, there is a slight  gain  added  to  the  checkpoint  in  comparison  to  a  checkpoint  update  without  stored  unpaid  fees. This gain is ultimately taken from the equity tranche.  Code Corrected:  A new field (unpaidFees) was introduced in the checkpoint struct to store the fees. Thus fees do not contribute to interest accrual of the tranche.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "6.7   Balance Underflow", "body": "  StructuredPortfolio.fundLoan  calls  LoansManager._fundLoan  which  in  turn  checks  the contract's balance of the underlying token to determine how much principal is available for loan funding. An  error  message  is  returned  when  the  requested  principal  exceeds  the  balance  of  the  contract. However,  fundLoan  subtracts  the  amount  of  principal  from  the  virtualTokenBalance  afterward.  If any  amount  of  tokens  has  been  directly  transferred  to  the  contract  before,  the  first  check  could  pass, while the subtraction fails, resulting in a revert without the given error message.  CS-TFCarbon-021    The following check has been added which prints an informative message:  require(virtualTokenBalance >= principal, \"SP: Principal exceeds balance\");  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "6.8   Gas Optimizations", "body": "  The following parts of the code could potentially be optimized for gas efficiency:   The CustomFeeRate struct used in a mapping in ProtocolConfig requires two storage slots. As the feeRate does not require 256 bits, the struct field could be reduced to a smaller type in order to shrink  the  size  requirement  of  the  struct  to  1  storage  slot.  This  should,  however,  be  carefully handled.   Redundant storage loads are performed in various places. Some examples are:  CS-TFCarbon-012   StructuredPortfolio.initialize  loads  the  tranches  variable  to  emit  an  event  while it is already available in memory variables.   StructuredPortfolio.fundLoan  checks   that   the  status   is  Live,   then  calls  updateCheckpoints which performs the same check again.   Redundant external calls are performed in various places. Some examples are:   StructuredPortfolio.start  calls  checkTranchesRatios  which  gets   the totalAssets of each tranche. It then calls totalAssets, which, in a status other than Live, gets the totalAssets of each tranche again.  TrueFi - Carbon -   19  CorrectnessLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f StructuredPortfolio.calculateWaterfall   the calculateWaterfallWithoutFees,  then  proceeds  to  call  totalPendingFees  on calls each  StructuredPortfolio.calculateWaterfallForTrancheWithoutFee twice.  calculates   tranche   which   turn   in    Redundant storage writes are performed in various places. Some examples are:   The  loop  in  StructuredPortfolio.start  adds  values  from  each  tranche  to  the virtualTokenBalance storage variable, resulting in multiple storage writes to the same variable.   StructuredPortfolio.markLoanAsDefaulted  updates  tranches and then immediately overwrites these checkpoints.  the  checkpoints  of   the  In  LoanManager._tryToExcludeLoan,  in  case  the  last  loan  is  deleted  a  redundant performed: is  assignment  activeLoanIds[i] = activeLoanIds[loansLength - 1]   Complicated call paths are performed in various places. Some examples are:   StructuredPortfolio.checkTranchesRatios  calls  each  tranche's  totalAssets which  to StructuredPortfolio.calculateWaterfallForTrancheWithoutFee  which  then calls back to the tranche's getCheckpoint function.  status)   Live   back   call   (in    StructuredPortfolio._defaultedLoansDeficit computes interest even when the deficit of  the given checkpoint is 0.   Some  state  variables  are  never  updated  and  could  be  set   to  immutable   in  StructuredPortfolio:   trancheImplementation   portfolioImplementation   protocolConfig   Cheap  deployment  has  been  chosen  over  cheap  contract  interactions.  Gas  for  user  interactions could  be  greatly  reduced  by  sacrificing  deployment  costs  of  managers.  For  example,  in  a  full deployment  of  TrancheVault  (as  opposed  to  a  proxy  deployment  of  a  given  implementation contract),  4  state  variables  that  are  used  in  many  of  the  state-changing  functions  could  be  set  to immutable.   TrancheVault.checkpoint is declared public while a redundant getter getCheckpoint exists.  the   In Live state, each vault transfers a chunk of fees from the portfolio to the beneficiary's addresses. As  in StructuredPortfolio.updateCheckpoints  is  sufficient.  Even  then,  fee  transfers  on  every interaction are unnecessarily costly.  anyways,   portfolio   transfer   funds   held   one   are   the   in     choices.  The  gas   Most relevant code optimizations have either been implemented or chosen not to be implemented due to design  (e.g., StructuredPortfolio.start)  slightly  and  some  new  inefficiencies  have  been  introduced  (e.g., StructuredPortfolio.getTranchesData  with StructuredPortfolio.getTrancheData which is a copy of the existing automatic getter).  code  parts  has   consumption  of   increased   replaced   some   been   has   TrueFi - Carbon -   20      \f6.9   Imprecise Specifications  CS-TFCarbon-017  The following specifications are imprecise:   The field targetAPY of struct TrancheData is not documented to be in basis points.   The field targetAPY of struct TrancheInitData is not documented to be in basis points.   StructuredPortfolio.endDate  is  commented  to  return  the  actual  end  date  after  the  close.  This is not true if the portfolio has been closed prematurely.   StructuredPortfolio.close  is  commented  to  revert  if  any  loans  are  still  active.  However,  portfolios can always be closed after the end date.   StructuredPortfolio.calculateWaterfallForTranche   is  commented  executable by the tranche with the given ID. Such restriction is however not enforced.  to  be  only   TrancheVault.updateCheckpointFromPortfolio  is  commented  to  be  only  executable  in Live  state.  However,  there  is  no  restriction  preventing  it  from  being  executed  in  Closed  state. Nevertheless, StructuredPortfolio is calling the function in Live state only.  Moreover in the extra documentation provided to us:  It  is  mentioned  that  deposits  are  blocked  in  Closed  state  and  withdrawals  are  blocked  in CapitalFormation state. However, this is never enforced in the code.  Specification changed:  The specification has been updated to correctly describe the code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "6.10   Missing Interface Functions", "body": "  Some  interfaces  are  missing  public  functions  that  are  implemented  in  the  contracts.  Here  are  two examples:   ITrancheVault is missing the declaration for setTransferController.   ITrancheVault is missing the declaration for totalAssetsWithoutFees.  CS-TFCarbon-016    Both  functions  have  been  added  to  the  interface.  totalAssetsWithoutFees  was  renamed  to totalAssetsBeforeFees.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "6.11   Missing Sanity Check", "body": "  A sanity check is missing in TrancheVault.deposit. More specifically, the function does not prevent the parameter amount from being 0 while mint which implements similar functionality does.  CS-TFCarbon-008  TrueFi - Carbon -   21  DesignLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f  The missing sanity check has been added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "6.12   Shadowed Variable", "body": "  The variable fixedInterestOnlyLoans in StructuredPortfolio.initialize is shadowed by a storage variable with the same name. While this does not impact the functionality of the given code, it could create problems during code maintenance.  CS-TFCarbon-019    The name of the variable has been changed to _fixedInterestOnlyLoans.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "6.13   Specification Nonconformity", "body": "  The architecture specification states that  They  [vaults]  do  not  store  the  capital,  they  only  handle  interactions  between  the  investors  and  the portfolio.  This is in contrast to the fact that vaults store balances both in CapitalFormation and Closed states.  CS-TFCarbon-011  Specification changed:  The specification has been updated to the following:  They store the capital when the portfolio is NOT in the Live state (so in the Capital Formation state and in the Closed state).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "6.14   Unused Function", "body": "  The  internal  function  TrancheVault._requirePortfolioOrManager  is  never  used  inside  of TrancheVault.  CS-TFCarbon-014    The function has been removed.  TrueFi - Carbon -   22  DesignLowVersion1CodeCorrectedDesignLowVersion1Speci\ufb01cationChangedDesignLowVersion1CodeCorrected                          \f6.15   Unused Return Value  TrancheVault._payProtocolFee  and  TrancheVault._payManagerFee  return  the  protocol  fee and the manager fee paid respectively. However, this value is never used.  CS-TFCarbon-009    The return values have been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "6.16   configure Function Does Not Include", "body": " TransferController  The  function  TrancheVault.configure  can  be  used  to  simultaneously  set  multiple  variables configurable by the portfolio manager. While DepositController and WithdrawController can be set, TransferController is not included in the function.  CS-TFCarbon-018    The TransferController can now be set in the TrancheVault.configure function.  TrueFi - Carbon -   23  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected              \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "7.1   Ambiguous Deficit Data in Closed State", "body": "  Deficit  checkpoints  are  used  to  determine  the  potential  interest  of  tokens  that  have  been  lost  due  to defaulted  loans  (which  can  still  be  repaid  in  some  circumstances).  In  Closed  state,  no  interest  is accrued. Therefore, repayments of defaulted loans are not decreasing the deficit again. However, a call to  StructuredPortfolio.close  still  updates  the  deficit  checkpoints.  This  update  works  in  a non-intuitive  fashion  and  results  in  ambiguous  data:  If  a  portfolio  with  no  defaulted  loan  is  closed,  the deficit will be 0. If, on the other hand, a portfolio with at least one defaulted loan is closed, all loan values (including the loans that have not defaulted) are counted towards the deficit.  While this is not problematic for Carbon itself, other contracts integrating with it might rely on consistent data.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "7.2   Compounding Interest Computed in Arbitrary", "body": " Intervals  Every  time  the  checkpoints  are  updated  through  a  state-changing  function,  interest  is  compounded. Since  StructuredPortfolio.updateCheckpoints  can  be  called  at  any  time  during  Live  status, the results can be different. Consider the following example:   A user deposits 100 tokens on a tranche with 10% APY.   After 1 year of inactivity on the platform, they receive a yield of 10 tokens.  If the user calls updateCheckpoints after 6 months, they receive a yield of 10.25 tokens after 1 year.  If the user calls updateCheckpoints each month, they receive a yield of 10.47 tokens after one year.  The same situation produces different results based on how often the checkpoints are updated (without any other interactions).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "7.3   Fee Accrual in Closed State", "body": "  Fees  are  still  accrued  in  Closed  state.  TrueFi  claims  this  is  done  to  incentivize  fast  withdrawals. However, withdrawals in Closed state might still be delayed by late loan repayments.  TrueFi - Carbon -   24  NoteVersion3NoteVersion1NoteVersion1              \f7.4   Fee Accrual on Yield  Fees are accrued on the principal plus the yield on each tranche. This means that the same percentage of yield and fees on a tranche results in negative growth. For example, a tranche with 100 tokens value, 2% yield and 2% fees will have 99.96 value after one year.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "7.5   Manager Fee Accrual", "body": "  Manager fees are accrued on the virtualTokenBalance plus the value of the currently running loans. If a loan defaults and the manager marks the loan as defaulted on-chain, manager fees are no longer accrued  on  the  loan.  Therefore,  managers  are  incentivized  to  not  mark  loans  as  defaulted  until  the portfolio is closed, resulting in bigger fees than necessary for lenders.  The fee accrual for non-defaulted loans can even go beyond the runtime of the loan.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "7.6   Only the Recipient of a Loan Can Repay It", "body": "  The  system  allows  only  LoanManager._repayFixedInterestOnlyLoan by the following line:  recipients  of  a   repay   loan   the   to   it.  This   is  enforced   in   the  require(fixedInterestOnlyLoans.recipient(loanId) == msg.sender, \"LM: Not an instrument recipient\");  Users losing their private keys will not be able to repay their loans in any way.  TrueFi claims that only KYC addresses should be able to repay loans. However, there is no mechanism implemented that deals with the aforementioned problem.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "7.7   Skewed Interest Distribution", "body": "  Protocol and manager fees are calculated from the whole balances instead of the accrued interest. This potentially  results  in  skewed  interest  rate  distributions  depending  on  the  chosen  fee  rates  per  tranche. Consider the following example:   The protocol fee is 1% and the manager fee is 1% on every tranche.   The junior tranche has 5% interest and 100 tokens in value.   The senior tranche has 3% interest and 100 tokens in value.   Without fees (and disregarding compounding effects), the tranches will yield 5 and 3 tokens in yield  respectively.   With  fees  (and  disregarding  compounding  effects),  the  tranches  will  yield  2.9  and  0.94  tokens  respectively.  The ratio is now different after accounting for fees as 5 / 3 !== 2.9 / 0.94.  TrueFi - Carbon -   25  NoteVersion1NoteVersion1NoteVersion1NoteVersion1                \f7.8   Use of Non-standard ERC20 Tokens  Managers (and users) should be aware that using a non-standard ERC20 token as the underlying can be dangerous  for  the  system.  Non-standard  ERC20  tokens  include  but  are  not  limited  to  the  following behaviors:  Tokens With Reentrancies:  If a portfolio is set up with an underlying token that is reentrant (e.g., ERC-777), various possibilities of reentrancy attacks are enabled. Here is an example of one possible attack vector:   A portfolio consists of 3 tranches and is in Live status with no active loans.   Users have deposited 100 tokens to each tranche with no accrued interest (i.e. 1 share per token).   An attacker calls deposit on the junior tranche with 99 tokens.  In the safeTransferFrom call, the underlying token calls back to the attacker's contract.   At  this  point,  the  checkpoint  of  the  junior  tranche  has  already  been  updated,  while  the  virtualTokenBalance in the portfolio has not.   The attacker now reenters into the deposit function if the equity tranche with a deposit of 100 tokens.   10,000  shares  are  minted  to  the  attacker  as  the  virtualTokenBalance  is  still  300,  while  the checkpoints of senior and junior tranches return a sum of 299 tokens, leaving only 1 token for the equity tranche waterfall value.   After the call, the attacker now holds shares representing 99 tokens in the junior tranche and ~198  tokens in the equity tranche resulting in an instant profit of ~98 tokens.  Tokens With Fees:  When transferring tokens with fees, the receiver does not get the amount the sender sends but a part of it as  fees  are  deducted.  However,  updating  the  virtualTokenBalance  for  example  makes  the assumption  the  whole  amount  has  been  received.  Thus,  repetitive  transfers  will  create  a  discrepancy between the internal accounting of the portfolio which uses the virtualTokenBalance and the actual amount held by the portfolio.  Rebasing Tokens:  With  rebasing  tokens,  the  amount  of  tokens  each  account  holds  changes  over  time.  This  will  lead, similarly to tokens with fees, to internal accounting being wrong.  Pausable Tokens:  When a token is paused, it might revert on every call to functions like transfer. As Carbon extensively uses transfers in many functions, the system could become unusable on such occasions.  TrueFi - Carbon -   26  NoteVersion1   \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/truefi-carbon/"}, {"title": "5.1   No Sanity Check on _start_time", "body": "  There is no sanity check on _start_time in FeeDistributor.__init__.  Acknowledged  StakeDAO acknowledged the issue.  StakeDAO - StakeDAO-Frax-veSDT -   14  DesignCorrectnessCriticalHighMediumLowAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedCodePartiallyCorrectedCodePartiallyCorrectedAcknowledgedAcknowledgedCodePartiallyCorrectedCodePartiallyCorrectedAcknowledgedAcknowledgedAcknowledgedDesignLowVersion4Acknowledged              \f5.2   Broad Function Visibility: approveWallet  The visibility of the function SmartWalletWhitelist.approveWallet is public, however it is not called  internally.  For  functions  that  are  expected  to  be  called  from  other  contracts  only,  the  function visibility can be restricted to external instead of public. This allows to save gas costs, as public functions copy array function arguments to memory which can be expensive.  Acknowledged  StakeDAO acknowledged the issue.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "5.3   Inconsistent Checks When Depositing in ", "body": " veSDT  The function increase_amount requires that the msg.sender is either an externally owned contract or a whitelisted contract:  self.assert_not_contract(msg.sender)  However, the function deposit_for performs the same operation if addr is msg.sender and does not have the above restriction.  Acknowledged  StakeDAO acknowledged the issue. It is connected to a vyper bug which also affects another issue. The bug was resolved in version 0.3.1. More information: Fix allocation of unused storage slots  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "5.4   Inconsistent Procedure for Updating admin", "body": "  Multiple  contracts  have  an  admin  role  that  is  privileged  and  can  call  sensitive  functions.  However,  the procedure  to  update  such  privileged  roles  is  not  consistent  among  different  contracts.  Namely, SmartWalletWhiteList  uses  commit/apply  approach,  meaning  the  current  admin  initially  calls commitAdmin and then should call applyAdmin to set the new admin. While, LiquidityGaugeV4, FeeDistributor,  veBoostProxy  use  commit/accept  approach.  Differently  from  the  previous contracts, veSDT provides both procedures commit/accept and commit/apply to update the admin.  Acknowledged  StakeDAO acknowledged the issue.  StakeDAO - StakeDAO-Frax-veSDT -   15  DesignLowVersion3AcknowledgedCorrectnessLowVersion3AcknowledgedDesignLowVersion3Acknowledged                        \f5.5   Mismatch of Specification With the Function Modifier in AngleLocker  The  specification  of  the  AngleLocker's  function  createLock  states  that  it  can  only  be  called  by governance or proxy, however, the modifier onlyGovernance is used and the mentioned proxy is not declared anywhere.  Acknowledged  StakeDAO acknowledged the issue and replied:  The specification comment is wrong because it mentioned a proxy where it is not declared at the end.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "5.6   Missing Documentation for Parameter", "body": "  The function GaugeController.__init__ has no NatSpec description for the parameter admin.  Acknowledged  The NatSpec has not been updated.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "5.7   Missing Events for Sensitive Operations", "body": "  Multiple  contracts  do  not  emit  events  when  sensitive  operations  are  performed,  e.g.,  the  update  of  the admin for a contract.  We provide below some examples:   SmartWalletWhitelist.sol: applyAdmin and applySetChecker.   ClaimRewards.sol: setGovernance.   SdtDistributor.sol: initializeMasterchef, setDistribution and setTimePeriod.   LiquidityGaugeV4.vy: add_reward, set_reward_distributor and set_claimer.  Code partially corrected  StakeDAO added a new event for the function setGovernance of ClaimRewards.sol.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "5.8   Missing Sanity Checks", "body": "  Several setter functions in multiple contracts do not perform sanity checks for the new values that are set. We provide examples of such cases below:  StakeDAO - StakeDAO-Frax-veSDT -   16  CorrectnessLowVersion3AcknowledgedDesignLowVersion3AcknowledgedDesignLowVersion3CodePartiallyCorrectedDesignLowVersion3CodePartiallyCorrected                              \f SdtDistributor.sol:  _masterchef  parameter   in  initialize  and  _delegateGauge   in  setDelegateGauge.   LiquidityGaugeV4.vy: _distributor in add_reward.   veSDT.vy: token_addr in initialize and addr in commit_smart_wallet_checker.   FeeDistributor.vy: _start_time in the constructor.  Code partially corrected  StakeDAO added some checks but the following values still lack sanity checks:   SdtDistributor.sol: _delegateGauge in setDelegateGauge.   LiquidityGaugeV4.vy: _distributor in add_reward.   veSDT.vy: addr in commit_smart_wallet_checker.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "5.9   Missing Sanity Checks: AngleLocker", "body": "  The  setter  functions  take  an  address  as  a  parameter  and  assign  it  to  a  state  variable.  Given  the sensitivity  of  such  functions,  basic  sanity  checks  on  the  input  parameter  help  to  eliminate  the  risk  of setting address(0) to the state variable of the contract by accident (e.g. UI bugs).  Acknowledged  StakeDAO  decided  to  keep  the  function  as  it  is  and  explained  that  its  parameters  will  be  reviewed carefully and that it won't be managed through a user interface.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "5.10   Non-indexed Events", "body": "  Events  can  be  indexed  to  easily  filter  and  search  for  the  indexed  arguments.  This  is  used  in  most contracts.  Without  full  specification  about  what  needs  indexing  we  simply  highlight  that  the  following occasions are not indexed and the need of indexing should be revised by StakeDAO.   Completely no indexed events in BaseAccumulator   Completely no indexed events in ClaimRewards   Completely no indexed events in GaugeController   Multiple not indexed events in LiquidityGaugeV4   Multiple not indexed events in veBoostProxy   No indexed events in CommitAdmin and ApplyAdmin in FeeDistributor  Acknowledged  StakeDAO replied:  StakeDAO - StakeDAO-Frax-veSDT -   17  DesignLowVersion3AcknowledgedDesignLowVersion3Acknowledged                \fWe decided to not include indexed parameters within the events definition because they will increase the gas a little bit and also, we could fetch externally the same info using theGraph.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "5.11   Possible Gas Optimization in Mappings", "body": "  Multiple contracts of the system use mappings in the format: mapping(key_type => bool). Solidity uses a word (256 bits) for each stored value and performs some additional operations when operating bool values (due to masking). Therefore, using uint256 instead of bool is slightly more efficient.  We provide below the list of mappings that can be optimized:   SmartWalletWhitelist.sol: wallets.   ClaimRewards.sol: gauges.   SdtDistributor.sol: killedGauges, isInterfaceKnown and isGaugePaid.  Code partially corrected  StakeDAO changed the mapping gauges in ClaimRewards.sol from mapping(key_type => bool) to mapping(key_type => uint256) and modified all the functions using it accordingly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "5.12   Unused Events", "body": "  Several contracts declare events that remain unused in the existing code base. The StakeDAO should assess if such events should be removed or emit them accordingly. We provide a list of unused events:   ClaimRewards.sol:   DepositorDisabled,   RewardClaimedAndLocked   and  RewardClaimedAndSent.   SdtDistributorEvents.sol:   UpdateMiningParameters.   GaugeController.vy: KilledGauge.  DistributionsToggled,   RateUpdated,  Code partially corrected  StakeDAO  deleted  the  unused  events  in  ClaimRewards  but  not  in  SdtDitributorEvents  and GaugeController as they were already deployed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "5.13   Missing Sanity Checks: FraxLocker", "body": "  The  setter  functions  take  an  address  as  a  parameter  and  assign  it  to  a  state  variable.  Given  the sensitivity  of  such  functions,  basic  sanity  checks  on  the  input  parameter  help  to  eliminate  the  risk  of setting address(0) to the state variable of the contract by accident (e.g. UI bugs).  Acknowledged  StakeDAO - StakeDAO-Frax-veSDT -   18  DesignLowVersion3CodePartiallyCorrectedDesignLowVersion3CodePartiallyCorrectedDesignLowVersion1Acknowledged                        \fDue to efficiency reasons, StakeDAO decided to keep the function as it is.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "5.14   Missing Sanity Checks: FxsDepositor", "body": "  The  setter  functions  that  take  an  address  as  a  parameter  and  assign  it  to  a  state  variable  lack  basic sanity  checks  on  the  input  parameter.  Such  checks  would  help  to  eliminate  the  risk  of  setting address(0) to the state variable of the contract by accident (e.g. UI bugs).  Acknowledged  Due to efficiency reasons, StakeDAO decided to keep the function as it is.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "5.15   Missing Sanity Checks: sdFXSToken", "body": "  The  function  setOperator  takes  an  address  as  a  parameter  and  assigns  it  to  the  state  variable operator. Given the sensitivity of this function, basic sanity checks on the parameter _operator help to eliminate the risk of setting address(0) as the operator of the contract by accident (e.g. UI bugs).  Acknowledged  Due to efficiency reasons, StakeDAO decided to keep the function as it is.  StakeDAO - StakeDAO-Frax-veSDT -   19  DesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                  \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  1  3  12  -Severity Findings  -Severity Findings  Incorrect Index Used to Access depositorsIndex   -Severity Findings   Possible to Lock Users' Funds Into veSDT   Inconsistent Access Control    Update of unlockTime   -Severity Findings  Inconsistent Specification: deposit_for_from   Inconsistent Specification: initialize    Possible to Optimize the Check on Distributor of tokenReward    Broad Function Visibility    Commented Code    Mismatch of Specification With the Function Modifier    Revert Message on Modifier    Unused Event Voted    Unused Imports: FxsDepositor    Unused Imports: FxsLocker    Unused Imports: sdFXSToken    createLock Access Control   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.1   Incorrect Index Used to Access ", "body": " depositorsIndex  In  the  function  addDepositor  of  ClaimRewards  ,  values  of  depositorsIndex  are  set  using depositor addresses as indexes.  depositorsIndex[_depositor] = depositorsCount;  In claimAndLock this array is accessed twice using token addresses as indexes.  if (depositor != address(0) && lockStatus.locked[depositorsIndex[token]]) {         IERC20(token).approve(depositor, balance);  StakeDAO - StakeDAO-Frax-veSDT -   20  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion3CodeCorrected            \f        if (lockStatus.staked[depositorsIndex[token]]) {                 IDepositor(depositor).deposit(balance, false, true, msg.sender);         } else {                 IDepositor(depositor).deposit(balance, false, false, msg.sender); }  Given  that  there  are  no  contract  defining  both  a  token  and  a  depositor  in  the  codebase,  it  would  most likely  lead  depositorsIndex[token]  to  always  evaluate  to  0  and  hence  use  the  first  element  of lockStatus.staked and lockStatus.locked as decisions for each token.  Code corrected  The variable depositor is now used to address depositorsIndex in claimAndLock.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.2   Possible to Lock Users' Funds Into veSDT", "body": "  Users that lock their tokens into the voting escrow contract need to approve an allowance to veSDT and then call deposit_for or deposit_for_from to transfer the tokens. However, if a user approves to the veSDT an amount that is larger than the intended amount of tokens to be locked, or max uint for simplicity, the user's tokens are exposed to arbitrary locking. In such cases the function deposit_for allows anyone to lock more of user's tokens into the contract without their clear consent. This is possible because  the  function  deposit_for  calls  the  internal  function  _deposit_for  without  passing  the msg.sender as a parameter:  def deposit_for(_addr: address, _value: uint256):     ...     self._deposit_for(_addr, _value, 0, self.locked[_addr], DEPOSIT_FOR_TYPE)  The internal function transfers the tokens from _addr if enough allowance exists, while the caller only pays the gas costs:  def _deposit_for(_addr: address, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128):     ...     if _value != 0:         assert ERC20(self.token).transferFrom(_addr, self, _value)  Code corrected  StakeDAO  corrected  the  issue  by  adding  the  new  parameter  _from  to  _deposit_from  and  using  it instead of _addr for the ERC20 transfer. Whenever _deposit_from is called, msg.sender is passed as  an  argument  so  that  _from  is  always  equal  to  it.  Anyone  is  still  able  to  call  deposit_for  or deposit_for_from for someone else, but it is now the caller's tokens that are deposited.  def _deposit_for(_addr: address, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128, _from: address):     ...     if _value != 0:         assert ERC20(self.token).transferFrom(_from, self, _value)  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.3   Inconsistent Access Control", "body": "  StakeDAO - StakeDAO-Frax-veSDT -   21  DesignMediumVersion3CodeCorrectedDesignMediumVersion1CodeCorrected                \fto   allows   The  access  control  for  FraxLocker.execute  is  onlyGovernanceOrDepositor.  The  function basically  function FraxLocker.claimFXSRewards  has  the  following  access  control  onlyGovernanceOrAcc.  As execute can replicate the behavior of claimFXSRewards the access control is inconsistent because claimFXSRewards can be replicated by execute. Ultimately, giving the Depositor the same power as Acc in this case.  function.   arbitrary   contract   The   and   any   call   This is only a theoretical problem in the current implementation due to another issue.  Code corrected  The  updated  code  protects  the  function  execute  with  the  modifier  onlyGovernance,  which  restricts the access to only the governance address.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.4   Update of unlockTime", "body": "  We  do  not  have  sufficient  specification  about  the  intended  behavior,  but  the  following  seems  to  be  an issue. The internal function _lockFXS updates the unlockTime if the following condition is satisfied:  if (unlockInWeeks.sub(unlockTime) > 1) {         ILocker(locker).increaseUnlockTime(unlockAt);         unlockTime = unlockInWeeks; }  Given that both unlockInWeeks and unlockTime store the number of seconds passed until a given week, the comparison with 2 (sec) seems incorrect.  Specification changed  The  current  code  will  always  evaluate  the  if  condition  as  true  if  the  comparison  is  bigger  than  1. StakeDAO changed the specification from two weeks to one week. Additionally, the 2 was changed to 1 (which has no effect but makes it more explicit). The code works but we need to highlight, that this only works for one week check.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.5   Inconsistent Specification: ", "body": " deposit_for_from  The functions deposit_for and deposit_for_from have a similar behavior, however their NatSpec specification is inconsistent. The comment for deposit_for:  @dev Anyone (even a smart contract) can deposit for someone else, but      cannot extend their locktime and deposit for a brand new user  while the respective description for deposit_for_from is:  @dev Anyone (even a smart contract) can deposit for someone else from their account  StakeDAO - StakeDAO-Frax-veSDT -   22  DesignMediumVersion1Speci\ufb01cationChangedCorrectnessLowVersion3CodeCorrected                \fCode corrected  The NatSpec specification of deposit_for_from has been modified to reflect the function's behavior.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.6   Inconsistent Specification: initialize", "body": "  The NatSpec description of veSDT's initialize function describe token_addr as being the address of the ERC20ANGLE contract while the contract is a voting escrow for the SDT token.  Code corrected  StakeDAO corrected the NatSpec description by replacing ERC20ANGLE by ERC20SDT.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.7   Possible to Optimize the Check on Distributor", "body": " of tokenReward  The  function  BaseAccumulator._notifyReward  checks  if  the  distributor  of  _tokenReward  is  not address(0), then it performs the two external calls as shown below:  if (ILiquidityGauge(gauge).reward_data(_tokenReward).distributor != address(0)) {                     IERC20(_tokenReward).approve(gauge, _amount);                     ILiquidityGauge(gauge).deposit_reward_token(_tokenReward, _amount);         ...             }  The  function  call  deposit_reward_token  succeeds  only  if  the  accumulator  is  the  distributor  for  the _tokenReward, otherwise it reverts. Hence, the function could be optimized by directly checking if the distributor of the _tokenReward is the accumulator.  Code corrected  The condition checks immediately if the address is the accumulator.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.8   Broad Function Visibility", "body": "  The  function  depositFor  in  FxsDepositor  is  declared  as  public  but  it  is  never  called  internally. Following  the  best  practices,  functions  expected  to  be  called  only  externally  should  be  declared  as external.  Code corrected  StakeDAO - StakeDAO-Frax-veSDT -   23  CorrectnessLowVersion3CodeCorrectedDesignLowVersion3CodeCorrectedDesignLowVersion1CodeCorrected                        \fThe function depositFor has been removed from the contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.9   Commented Code", "body": "  The contract FraxLocker includes a function vote which is commented out. Please elaborate on the cause and if this functionality should be implemented or the code removed completely.  Code corrected  The commented function was removed from the code base.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.10   Mismatch of Specification With the Function", "body": " Modifier  The specification of the function createLock states that it can only be called by governance or proxy, however,  the  modifier  onlyGovernanceOrDepositor  is  used,  which  checks  if  the  msg.sender  is either the governance or fxsDepositor address. Additionally, the fxsDepositor contract does not implement any functionality which calls createLock currently.  Code corrected  The updated spec state that createLock can be called only by the governance. The respective modifier onlyGovernance is now used.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.11   Revert Message on Modifier", "body": "  The  modifier  onlyGovernanceOrDepositor  checks  if  the  msg.sender  is  either  governance  or fxsDepositor address as shown:  modifier onlyGovernanceOrDepositor() {         require(                 msg.sender == governance || msg.sender == fxsDepositor,                 \"!(gov||proxy||fxsDepositor)\"         );         _; }  The error message claims that msg.sender is not proxy address, which is not declared in the contract.  Code corrected  The error message has been updated accordingly.  StakeDAO - StakeDAO-Frax-veSDT -   24  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f6.12   Unused Event Voted  The contract FraxLocker declares the event Voted, however, it is not used in the current codebase.  Code corrected  The unused event Voted has been removed from the code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.13   Unused Imports: FxsDepositor", "body": "  The file FxsDepositor.sol (   Depositor contract) has the following unused import:  import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; import \"@openzeppelin/contracts/utils/Address.sol\"; import \"@openzeppelin/contracts/utils/Context.sol\";  Code corrected  The unused libraries listed above have been removed from the updated code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.14   Unused Imports: FxsLocker", "body": "  The contract FxsLocker has the following unused imports:  import \"@openzeppelin/contracts/math/SafeMath.sol\"; import \"@openzeppelin/contracts/utils/Address.sol\";  Code corrected  The unused libraries have been removed from the updated code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.15   Unused Imports: sdFXSToken", "body": "  The file sdFXSToken.sol (   sdToken) has the following unused imports:  import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; import \"@openzeppelin/contracts/utils/Address.sol\";  StakeDAO - StakeDAO-Frax-veSDT -   25  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedVersion2DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedVersion2                                \fimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\"; import \"@openzeppelin/contracts/utils/Context.sol\";  Code corrected  The unused libraries listed above have been removed from the updated code.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.16   createLock Access Control", "body": "  functions   The  modifier onlyGovernanceOrDepositor,  but  the  contract  FxsDepositor  never  calls  these  functions. Specifications covering use cases when these functions are called by the depositor are missing.  createLock,   execute   release   have   and   the   Code corrected  The modifier for the functions listed above has been updated to onlyGovernance.  StakeDAO - StakeDAO-Frax-veSDT -   26  DesignLowVersion1CodeCorrected        \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "7.1   Admin's Weight on a Gauge Can Be", "body": " Overwritten  The function change_gauge_weight in GaugeController allows the admin to set the weight of any gauge to an arbitrary value. This value can be altered by voters of the gauge. If users vote for the gauge, its weight is increased to a higher value than set by the admin. Furthermore, if users that previously voted the gauge (before the admin called change_gauge_weight) remove their votes, the weight of the gauge is decreased to a lower value than set by the admin.  StakeDAO replied:  The weight, for a gauge already included into the GaugeController won't likely change, if it would happen, we will take care of managing it.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "7.2   All Gauges Should Be Trusted", "body": "  The gauges are added into the system by the admin of the GaugeController and they are considered to be non-malicious. If an untrusted gauge is added, then it can exploit a reentrancy vulnerability in the function SdtDistributor._distributeReward which can drain all rewards:  ILiquidityGauge(gaugeAddr).deposit_reward_token(address(rewardToken), sdtDistributed);  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "7.3   Dust Amounts Not Accounted in veSDT", "body": "  function  veSDT._checkpoint   The  MAXTIME = 4 * 365 * 86400:  ignores   locked   tokens  with  an  amount  smaller   than  def _checkpoint(addr: address, old_locked: LockedBalance, new_locked: LockedBalance):     ...     u_old.slope = old_locked.amount / MAXTIME     ...     u_new.slope = new_locked.amount / MAXTIME     ...  If old_locked.amount or new_locked.amount is less than MAXTIME, the respective slope is set to 0.  StakeDAO - StakeDAO-Frax-veSDT -   27  NoteVersion3NoteVersion3NoteVersion3          \f7.4   Event Can Be Emitted Multiple Times  Several contracts follow the approach commit/accept to set a new admin for the contract. For such updates,  an  event  CommitOwnership/  CommitAdmin  is  emitted  on  the  commit  operation,  and ApplyOwnership / ApplyAdmin event is emitted when the new admin accepts the transfer. However, the accepting functions can be called multiple times, hence the respective events would be emitted for every call. We provide a list of such contracts here:   GaugeController   veSDT   FeeDistributor   LiquidityGaugeV4   veBoostProxy  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "7.5   Outdated Compiler Version", "body": "  The  compiler  version:  0.8.7  is  outdated  (https://swcregistry.io/docs/SWC-102).  The  compiler  version has the following known bugs.  This is just a note as we do not see any severe issue using this compiler with the current code. At the time of writing the most recent Solidity release is version 0.8.13.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "7.6   Possible Reentrancy in lockToken for Special", "body": " Tokens  The  function  Depositor.lockToken  performs  a  mint  operation  and  afterwards  emits  an  event  and updates the state variable incentiveToken:  if (incentiveToken > 0) {     ITokenMinter(minter).mint(msg.sender, incentiveToken);     emit IncentiveReceived(msg.sender, incentiveToken);     incentiveToken = 0; }  In the current code base, minter token is always the sdToken which extends the ERC20 standard and does  not  provide  any  callback  functionality  to  the  receiver,  hence  the  code  above  is  not  vulnerable  to reentrancy  attacks.  However,  if  in  the  future  versions  of  the  code  the  minter  token  is  supposed  to support callbacks, e.g., implement ERC777 standard and the mint operation provides an opportunity for reentrancy, the above function would be exploitable.  StakeDAO - StakeDAO-Frax-veSDT -   28  NoteVersion3NoteVersion1NoteVersion3              \f7.7   Reward Distribution Should Be Called Periodically for All Gauges  The  function  SdtDistributor.distributeMulti  works  correctly  only  if  it  is  called  periodically  (at least once a day) for all the gauges, otherwise the following two issues arise:  1. Failing to call distributeMulti for a gauge on a given day means that the gauge does not receive  its  share  of  rewards  for  the  respective  day  and  the  funds  are  locked  in  the  contract. Only the governance can recover these funds via recoverERC20 function.  2. On the time period that overlaps with the weekly event of updating votes for gauges, there is a time window for a malicious user to manipulate the rewards distributed to gauges. For example, if a gauge receives a higher weight for the following week, it is profitable for a malicious user to call  the  function  distributeMulti  when  the  new  weight  is  applied,  and  vice-versa.  This makes  the  accounting  of  rewards  in  SdtDistributor  incorrect  and  potentially  can  prevent legit gauges from receives any reward.  As  stated  in  the  System  Overview,  StakeDAO  should  run  a  bot  that  guarantees  the  function  is  called periodically and correctly for all gauges to prevent the issues above.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "7.8   Tautology in if Condition", "body": "  The function setFees in contracts Depositor and FxsDepositor verifies that _lockIncentive is greater than or equal to zero, however, as it is a unsigned integer, this condition will always hold.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "7.9   ClaimRewards Functions Should Be Called", "body": " Only With Enabled Gauges  The functions claimRewards and claimAndLock take a list of gauges as a parameter and check that each of them is enabled. If one of the gauges in _gauges is disabled by the governance, the functions revert.  Hence,  the  caller  should  always  guarantee  that  that  all  gauges  passed  into  the  functions  are enabled.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "7.10   safeApprove Usage", "body": "  The  contract  FxsDepositor  (Depositor  in  given to the gauge. As explained in the specifications of the function, safeApprove is deprecated.  )  uses  safeApprove  to  update  the  allowance  /**  * @dev Deprecated. This function has issues similar to the ones found in  * {IERC20-approve}, and its usage is discouraged.  *  * Whenever possible, use {safeIncreaseAllowance} and  StakeDAO - StakeDAO-Frax-veSDT -   29  NoteVersion3NoteVersion1NoteVersion3NoteVersion1Version2              \f * {safeDecreaseAllowance} instead.  */  StakeDAO - StakeDAO-Frax-veSDT -   30  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-frax-vesdt/"}, {"title": "6.1   Redundant Calculation in _yank", "body": "  When _yank is called, it determines how much reward can still be claimed by the recipient. If the new _end  of  the  vesting  plan  is  before  the  beginning  or  the  cliff  date  of  the  vesting  plan,  the  entire  reward amount is cancelled. Otherwise, the following calculation is done:  awards[_id].tot = toUint128(                     add(                         unpaid(_end, _award.bgn, _award.clf, _award.fin, _award.tot, _award.rxd),                         _award.rxd                     )                 );  unpaid calculates the following result:  function unpaid(uint256 _time, uint48 _bgn, uint48 _clf, uint48 _fin, uint128 _tot, uint128 _rxd) internal pure returns (uint256 amt) {     amt = _time < _clf ? 0 : sub(accrued(_time, _bgn, _fin, _tot), _rxd); }  As  we  know  that  _end  is  after  the  beginning  and  cliff  date  of  the  vesting  plan,  this  calculation  can  be simplified.  The  addition  of  _rxd  in  _yank  and  subtraction  of  _rxd  in  unpaid  cancel  out,  so  the  final result is simply: toUint128( accrued(_end, _bgn, _fin, _tot) ).  Acknowledged:  Giry chooses not to modify the code out of caution, as the original dss-vest code has been the subject of extensive formal checking and is battle-tested.  Giry - dss-vest -   9  DesignCriticalHighMediumLowAcknowledgedAcknowledgedAcknowledgedAcknowledgedAcknowledgedDesignLowVersion1Acknowledged           \f6.2   Redundant Overflow Checks  As  of  Solidity  version  0.8.0,  the  compiler  automatically  inserts  overflow  checks  when  doing  integer arithmetic. As such, the add, sub and mul functions are redundant.  Additionally, the following require statement in _create can also be considered redundant:  require(ids < type(uint256).max, \"DssVest/ids-overflow\");  This statement makes sure that the increase of the id (id = ++id) in the following line will not overflow.  Acknowledged:  Giry chooses not to modify the code out of caution, as the original dss-vest code has been the subject of extensive formal checking and is battle-tested.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-dss-vest/"}, {"title": "6.3   Redundant Storage Load in _yank", "body": "  The _yank function loads awards[_id] from storage multiple times:  function _yank(uint256 _id, uint256 _end) internal lock {     require(wards[msg.sender] == 1 || awards[_id].mgr == msg.sender, \"DssVest/not-authorized\");     Award memory _award = awards[_id];  It  is  important  to  note  that  since  the  Berlin  hardfork,  the  memory  slot  of  awards[_id]  is  considered warm, thus the benefit of such optimization is limited.  See more here https://eips.ethereum.org/EIPS/eip-2929.  Acknowledged:  Giry chooses not to modify the code out of caution, as the original dss-vest code has been the subject of extensive formal checking and is battle-tested.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-dss-vest/"}, {"title": "6.4   Reentrancy Lock Can Be Cheaper", "body": "  Using different values for the locked variable results in cheaper transactions overall. Setting a storage variable  from  0  to  1,  but  then  resetting  it  back  to  0  costs  ~20112  gas  but  causes  19900  gas  to  be refunded. However, the total refund amount a transaction is eligible for is limited to a fraction of the total gas expended by the transaction. Hence, for simple transactions it is likely that not the entire gas refund will be received.  Instead, one could initialize the locked variable with a value of 1 in the constructor. Then, at the start of a transaction set it to 0 for the reentrancy lock and setting it back to 1 at the end. This costs ~3012 gas, but refunds 2800. Assuming a complete refund, this costs the same amount of gas per transaction, but is more likely to be completely refunded as the total refund amount is smaller.  For completeness, we should note that a similar practice is utilized by the OpenZeppelin library. In this case, the values 1 and 2 are used instead of values 1 and 0. The efficiency of this approach is similar.  Giry - dss-vest -   10  DesignLowVersion1AcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                      \fFor  more  information  https://eips.ethereum.org/EIPS/eip-3529.  about   gas   refunds   and   the   exact   refund   amounts,   see  Acknowledged:  Giry chooses not to modify the code out of caution, as the original dss-vest code has been the subject of extensive formal checking and is battle-tested.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-dss-vest/"}, {"title": "6.5   Unnecessary Calculation in accrued", "body": "  In the accrued function, unnecessary calculations are performed in the case where _time == _bgn. In this case, the result will be 0. As such, the first if condition could be modified to be _time <= _bgn in order to save gas in this case.  function accrued(uint256 _time, uint48 _bgn, uint48 _fin, uint128 _tot) internal pure returns (uint256 amt) {     if (_time < _bgn) {         amt = 0;     } else if (_time >= _fin) {         amt = _tot;     } else {         amt = mul(_tot, sub(_time, _bgn)) / sub(_fin, _bgn); // 0 <= amt < _award.tot     } }  Acknowledged:  Giry chooses not to modify the code out of caution, as the original dss-vest code has been the subject of extensive formal checking and is battle-tested.  Giry - dss-vest -   11  DesignLowVersion1Acknowledged          \f7   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings  -Severity Findings   Code Duplication   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-dss-vest/"}, {"title": "7.1   Code Duplication", "body": "  0  0  0  1  The _bless and unbless functions check for the condition wards[msg.sender] == 1. This is the same  condition  as  is  enforced  by  the  auth  modifier.  In  order  to  reduce  code  duplication,  the  auth modifier could be applied to these functions instead.    The condition check was removed and replaced with the auth modifier.  Giry - dss-vest -   12  CriticalHighMediumLowCodeCorrectedDesignLowVersion1CodeCorrected        \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/mangrove-dss-vest/"}, {"title": "5.1   Solv's BUYER_PAY Fee Pay Type Is", "body": " Unsupported  When buying vouchers from the marketplace, fees are paid. Note that Solv has two fee pay types such that either the buyer or the seller pays fees. If the buyer pays, the fee is added to the amount transferred from  the  buyer.  Note  that  Solv's  internal  function  _buy()  will  transfer  transferInAmount  from  the buyer which is defined as amount_.add(fee_).  The  external  position  for  the  buyer  side  does  not  consider  that  which  leads  to  the  following consequences:  1. Action BuySaleByAmount is not supported if the fee type is BUYER_PAY as the approval made will  be insufficient.  2. Action BuySaleByUnits is not supported if the fee type is BUYER_PAY as the funds sent from the  vault will not be sufficient to perform the action.  with the exception that if some unreconcilled funds are available to the external position, the funds could be sufficient to perform the action.  Code partially corrected:  1. Not corrected: Note that buying by amount on Solv will not transfer in the passed in amount but the passed  in  amount  plus  fees.  However,  BuyByAmount  does  not  consider  fees.  See  the  code  of SolvConvertibleMarket.sol  here https://etherscan.io/address/0x29935f54a45f5955ad7bc9d5416f746c3d1b9d69 on line 502.  file   if (vars.feePayType == FeePayType.BUYER_PAY) {   vars.transferInAmount = amount_.add(fee_);   ...} ...  Avantgarde Finance - Sulu Extensions V -   15  DesignCorrectnessCriticalHighMediumLowCodePartiallyCorrectedRiskAcceptedCorrectnessLowVersion1CodePartiallyCorrectedRiskAccepted              \fERC20TransferHelper.doTransferIn(       sale_.currency,       buyer_,       vars.transferInAmount   );  Ultimately, insufficient funds could be moved and the approval given to Solv could be insufficient.  2.  The code has been adapted such that the fee is in included in the transferred in  amount.  Note  that  the  fee  computation  made  for  the  BuyByUnits  action  could  be  off.  There  is  a  special  case where  the  voucher's  underlying  could  be  also  the  currency.  In  such  situations  the  fee  is  computed differently and is based on repoFeeRate instead of the market's feeRate.  Risk accepted:  Avantgarde Finance states the following:  the Solv team says that they will upgrade to the version of `SolvConvertibleMarket` that is in their GitHub repo (b207d5e), which fixes this issue (buyer fee is deducted from `amount`, and there is no longer a `repoFeeRate`). The Enzyme Council will assure that the upgrade has occurred before adding the external position type. Even if no upgrade were to occur, the worst case is that `BuySaleByAmount` will revert when there is a buyer fee, which does not result in value loss for the fund.  Avantgarde Finance - Sulu Extensions V -   16    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings   Solv Issuer Double Accounting   -Severity Findings   Full Balance Is Pushed on Reconciliation    Offer ID and Voucher Mismatch    Solv Finance: No Support for Raw ETH as Currency    Solv Issuer Ignores Possibly Withdrawable Voucher Slots    getManagedAssets for Solv Buyer Side Reverts if Maturity Not Reached   -Severity Findings  Incomplete NatSpec for ManualValueOracleLib.init()    assetsToReceive Not Containing Assets   0  1  5  2  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-v/"}, {"title": "6.1   Solv Issuer Double Accounting", "body": "  The  Solv  Issuer  external  position  keeps  track  of  the  offered  vouchers  on  the  convertible  offering marketplace. To compute their values it sums up  1. The   token  amounts   that  could  be  withdrawn  by   the   issuer  with   internal   function  __getWithdrawableAssetAmounts.  2. The  token  amounts  that  could  be  claimed  in  case  some  units  are  still  held  with  internal  function  __getOffersUnderlyingBalance()  3. The unreconciled token amounts.  __getWithdrawableAssetAmounts() iterates over all offers and further iterates over all issuer slots of the external position. There is a possibility of accounting withdrawable amounts multiple times.  for (uint256 i; i < offersLength; i++) {     // ...     ISolvV2ConvertibleVoucher voucherContract = ISolvV2ConvertibleVoucher(         INITIAL_CONVERTIBLE_OFFERING_MARKET_CONTRACT.offerings(_offers[i].offerId).voucher     );     ISolvV2ConvertiblePool voucherPoolContract = ISolvV2ConvertiblePool(         voucherContract.convertiblePool()     );     uint256[] memory slots = voucherPoolContract.getIssuerSlots(address(this));     // ...  Avantgarde Finance - Sulu Extensions V -   17  CriticalHighCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedLowCodeCorrectedCodeCorrectedCorrectnessHighVersion1CodeCorrected         \f    for (uint256 j; j < slotsLength; j++) {         (uint256 withdrawCurrencyAmount, uint256 withdrawTokenAmount) = voucherPoolContract             .getWithdrawableAmount(slots[j]);         // logic for summing up         // ...  Consider the following example:  1. First offer is created with the voucher being X such that it has slot id 1.  2. Second offer is created with the voucher being X such that it has slot id 2.  3. The above code is executed.  4. The convertible pool of the voucher gives the slots 1 and 2.  5. The withdrawable amount is added twice since the inner loop for both offers will iterate over slot ids  1 and 2 and add the withdrawable amounts twice.  Ultimately, the withdrawable amounts may be added multiple times in the evaluation.    Now, not only offers are tracked but also issued voucher addresses. Hence, estimating the withdrawable amounts is done by iterating now over the issued voucher addresses which do not contain duplicates.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-v/"}, {"title": "6.2   Full Balance Is Pushed on Reconciliation", "body": "  To  handle  direct  token  transfers  to  the  loan  contract  as  repayments  (and  to  handle  arbitrary  tokens received),  Avantgarde  Finance  introduces  a  reconciliation  functionality  for  arbitrary  loans,  which  allows moving  arbitrary  tokens  received  (e.g.,  insurance  payments)  to  be  moved  to  the  vault.  Furthermore,  it considers all surplus balance (compared to the borrowable amount) of the loan token as a repayment. However, it always moves the full loan token balance to the vault. While this makes sense when closing the vault, it may break the loan's logic when action reconcile is executed (e.g., borrowable amount > 0 but borrows are impossible).    Reconciliation  for  the  Reconcile  action  and  reconciliation  for  the  Close  action  are  now  performed differently.  A  boolean  _close  argument  was  added  to  the  __reconcile  function  to  make  this distinction.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-v/"}, {"title": "6.3   Offer ID and Voucher Mismatch", "body": "  When  buying  an  offer  from  the  Solv  IVO,  the  fund  manager  can  specify  the  voucher  address  and  the offering  ID.  However,  the  voucher  address  could  mismatch  with  the  offer's  voucher  stored  in  the Offering struct.  Consider the following scenario:  1. Fund manager inputs an offer id such that Offer.voucher and the input voucher mismatch.  Avantgarde Finance - Sulu Extensions V -   18  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \f2. The  SolvV2ConvertibleBuyerPositionParser  specifies  Offer.currency  as  the  asset  to  transfer  while specifying the amount to transfer as  uint256 amount = uint256(units).mul(voucherPrice).div(10**uint256(market.decimals));  3. The  nextTokenId()  is  queried  on  the  wrong  voucher  and  the  contract  maximum  approval  is  given to the IVO market.  4. buy() is called on the IVO market. As long as the amount computed in step 2. is sufficient, buying  will succeed.  5. The approval is revoked.  6. The input voucher and the token id from step 3 are pushed on the position's offers array.  While it requires an error by the fund manager, it could have consequences such as  tracking of a wrong voucher and token id leading to wrong estimations of the total value,   stuck tokens due to high amounts being moved also leading to wrong fund evaluations,   being stuck with the wrong voucher and token id   potential of double tracking of voucher and token id  Ultimately, to buy an offering it could be sufficient to specify solely the units and the offering id.    The voucher address is not an action argument anymore for buying from IVOs but is retrieved from the offering. Hence, the position parser and the position logic have been adapted accordingly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-v/"}, {"title": "6.4   Solv Finance: No Support for Raw ETH as", "body": " Currency  Raw ETH is not supported as a currency for the Solv convertible vouchers. This is problematic because Solv supports ETH through the doTransferOut function in the ERC20TransferHelper library, which uses a special constant address ETH_ADDRESS for such raw currency transfers. Given the lack of sanity checks for the assets in a voucher, it could be possible that such a voucher becomes unredeemable (e.g. claim action while fund currency is ETH).    The function __validateNotNativeToken was added to verify that the asset's address is not equal to the special value NATIVE_TOKEN_ADDRESS.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-v/"}, {"title": "6.5   Solv Issuer Ignores Possibly Withdrawable", "body": " Voucher Slots  Avantgarde Finance - Sulu Extensions V -   19  DesignMediumVersion1CodeCorrectedCorrectnessMediumVersion1CodeCorrected                 \fWhen  creating  an  IVO  offer,  a  slot  is  created  for  the  issuer  and  the  offer  which  gives  it  a  uniqueness property  given  the  slot  details.  Action  Withdraw  allows  the  fund  manager  to  claim  assets  from  the voucher contract after maturity while action Remove removes the offer from the offering market such that the overhead underlying for the unsold units is refunded. Moreover, Remove removes the offer from the offers  array  such  that  it  becomes  untracked.  While  it  is  still  possible  to  call  Withdraw,  the  value  of getManagedAssets has dropped even though assets could still be withdrawn.  Consider the following scenario:  1. An offer is created. Some units were sold but not all.  2. The offer can be removed and there are withdrawable amounts. Assume the refund amount is 10 X  and the withdrawable amounts are 10 X and 10 Y.  3. getManagedAssets() return 20 X and 10 Y.  4. Remove is executed. 10 X are moved to the vault proxy.  5. getManagedAssets() returns 0.  6. Withdraw is executed. The fund's value rises suddenly.  In general, such behaviour could be introduced.    Now, not only offers are tracked but also issued voucher addresses. Removing an offer does not remove the issued voucher and, thus, the voucher's slots remain tracked.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-v/"}, {"title": "6.6   getManagedAssets for Solv Buyer Side", "body": " Reverts if Maturity Not Reached  getManagedAssets  evaluates  the  value  held  by  the  position.  To  do  so,  it  iterates  over  all  vouchers held,  currently  held  or  being  sold,  and  computes  internal  method __getClaimableAmount() which contains the following code:  their  value  with   uint128 settlePrice = poolContract.getSettlePrice(slotId); require(settlePrice > 0, \"Price not settled\");  Note that Solv's convertible pool contract implements getSettlePrice() such that it reverts if maturity has not been reached or if the price is negative. Ultimately, no voucher that has not reached its maturity can be evaluated and hence getManagedAssets() will revert which will block several operations in the Enzyme system. Even if getSettlePrice() did not fail, the second requirement may lead to reverts.  Specification changed:  Avantgarde Finance states:  This is an architectural decision to revert upon price lookup for all Solv vouchers (in both Buyer and Issuer features) that are issued or held prior to maturity, rather than estimate the value of an unsettled voucher. Price-dependent fund functions will revert while any such voucher is issued/held.  Avantgarde Finance - Sulu Extensions V -   20  DesignMediumVersion1Speci\ufb01cationChanged          \f6.7   Incomplete NatSpec for  ManualValueOracleLib.init()  The documentation of ManualValueOracleLib.init() is:  /// @notice Initializes the proxy /// @param _owner The owner of the oracle /// @param _updater The updater of the oracle value  Note that the _description parameter is not documented and, thus, the NatSpec is incomplete.    The description parameter has been added to the NatSpec.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-v/"}, {"title": "6.8   assetsToReceive Not Containing Assets", "body": "  Both the parsers for Solv V2 Buyer positions and Solv V2 Issuer positions could lead to untracked assets. The library used for adding items to memory arrays, creates a new memory array with the old and new items. However, in some occasions, the return value is not assigned to assetsToReceive after an item is added. Hence, it could be possible the assets remain untracked.  Note that Avantgarde Finance reported the issue.    The return values are assigned.  Avantgarde Finance - Sulu Extensions V -   21  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected              \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-v/"}, {"title": "7.1   Arbitrary Loan Powers", "body": "  While  all  addresses  involved  in  the  arbitrary  loan  mechanism  are  fully  trusted,  such  external  positions may give managers very high control about the fund. Some (incomplete) list examples:  1. Stealing funds very easily by giving the full balance as a loan to itself.  2. Manipulating the valuation of the fund to profit by specifying an accounting module that computes  the face value when queried as extremely high.  3. Increase the number of shares by using the loan to invest in the fund.  4. Reentrancy possibilities.  5. Blocking behaviour.  Avantgarde Finance - Sulu Extensions V -   22  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-sulu-extensions-v/"}, {"title": "5.1   Missing Sanity Checks", "body": "  When  opening  a  short  position  in  the  Gearbox  system  by  calling  shortOpenUniV2,  the  user  must provide  multiple  parameters.  These  parameters  are  not  sanitized,  thus  arbitrary  behavior  may  occur. More  specifically  it  is  never  checked  that  path[path.length  -  1]  ==  collateral  and collateral == longParams.path[0].  The  lpInterface  and  lpContract  in  the  struct  LongParameters  used  in  _openLong  are  not checked  to  match.  Similarly,  an  arbitrary  router  can  be  passed  as  shortSwapContract  as  long  as there is an adapter for it. Note that this is currently not an issue since different adapters/routers do not share the same interface and the transaction would revert. However, the addition of more adapters in the future might require some kind of sanity check.  Code partially corrected:  shortOpenUniV2 now features an additional check ensuring that the token out of the exchange using shortSwapContract  is  the  collateral.  Similar  checks  have  been  added  to  openShortUniV3  and openShortCurve.  Gearbox Protocol - Gearbox -   11  SecurityDesignCorrectnessCriticalHighMediumLowCodePartiallyCorrectedDesignLowVersion4CodePartiallyCorrected             \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  3  8  12  -Severity Findings  -Severity Findings  Incorrect Arguments in checkCollateralChange    Non-Accessible Credit Accounts    Retain Ownership of Credit Account   -Severity Findings   DoS of LeverageActions   Incorrect params.amountOutMinimum    Contracts Implement Proxy Pattern    Trust Model of External Adapters    Users Can Avoid Paying Fees On Closure    Wrong Approval To Pool    maxAmount Can Be Circumvented   takeOut May Break the Account List   -Severity Findings   Discrepancy Between openShortUniV2 and openShortUniV3    Use of transfer    Rounding Errors    Head Cannot Be Taken Out    Pointers Not Updated On takeOut    Redundant Multiplication    Storage Optimizations    Taking Out the First-Ever Created Account    allowToken Can Be Blocked    cancelAllowance Cannot Be Called    connectCreditManager Access Control    rayMul and rayDiv Are Used With No Ray Values   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.1   Incorrect Arguments in ", "body": " checkCollateralChange  Gearbox Protocol - Gearbox -   12  CriticalHighCodeCorrectedCodeCorrectedCodeCorrectedMediumCodeCorrectedCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessHighVersion2CodeCorrected             \fIn  YearnV2.withdraw(uint256,  address,  uint256),  the  checkCollateralChange  is  called with wrong arguments. Particularly, the following snippet is used:  creditFilter.checkCollateralChange(     creditAccount,     token,     yVault,     balanceInBefore.sub(IERC20(yVault).balanceOf(creditAccount)),     balanceOutBefore.add(IERC20(token).balanceOf(creditAccount)) );  Note that token is the tokenOut in this particular case, we convert yVault tokens to the underlyings and yVault is the tokenIn. This error later results in querying the oracles with wrong balances.  Code Corrected:  The arguments are now passed correctly to checkCollateralChange.  *While the final round of the review was ongoing Gearbox Protocol informed us of an issue in the new implementations  of  the  adapters.  The  adapters  were  calculating  the  delta  of  the  incorrectly  and  hence were passing wrong parameters to `checkCollateralChange`. The issue has been fixed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.2   Non-Accessible Credit Accounts", "body": "  The transferAccountOwnership function of a CreditManager contract allows the owner of a credit account to transfer it onwards to a new owner. Per CreditManager an address is only allowed to hold one credit  account.  trasferAccountOwnerhip().  However,  there  is  no  check  on  whether  the  recipient already  holds  a  credit  account  at  this  CreditManager  contract  and  simply  overwrites  the  entry  for  the credit  account  of  the  recipient.  Hence  a  credit  account  which  holds  funds  can  become  non-accessible and its funds will be trapped.    In the updated code the transferAccountOwnership function no longer overwrites an existing credit account entry of the recipient, hence the issue no longer exists.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.3   Retain Ownership of Credit Account", "body": "  In Gearbox, Credit Accounts are reused after they have been returned to the factory. Due to a reentrancy issue, account ownership can be retained and after the next user got this credit account assigned, the previous owner may access its funds belonging to the new owner.  Function transferAccountOwnership does not feature the non nonReentrant modifier and hence can be executed during another operation. Consider the follwowing scenario:  Alice owns a healthy credit account 0xA which holds some WETH balance.  1. Alice prepares a contract that allows her to execute all necessary actions. As a first step, the credit  account ownership is transferred to this contract.  Gearbox Protocol - Gearbox -   13  SecurityHighVersion1CodeCorrectedSecurityHighVersion1CodeCorrected                \f2. The credit account is repaid using repayCreditAccount specifying the contract as to address. This  transfers  all  assets  to  the  provided  to  address.  Notably  the  WETH  asset  is  unwraped  into Ether, the Ether is transferred in a call to the reciepient's address to. This call executes code at the contract.  3. At  the  specified  to  address  a  contract  exists.  This  contract  transfers  the  ownership  of  the  credit that  (newAddress)  Alice  controls.  This  means   to  another  address  account  onwards  creditAccounts[newAddress] will point to the credit account  4. The closure of the credit account continues as normal. All assets are transferred to address to, the  debt is repaid to the pool and the credit account is returned to the AccountFactory.  5. Next delete creditAccounts[borrower]; is executed, this should delete the assignment of this  credit  account  to  the  borrower.  However,  as  we  already  transferred  the  ownership  from borrower which is the contract address back to Alice, creditAccounts[borrower] contains no entry at this point and deleting it has no effect.  At the end of this sequence, the credit account has been returned to the AccountFactory but the entry creditAccounts[newAddress] in this CreditManager still points to this account.  The  next  time  this  CreditAccount  is  reused  at  the  same  CreditManager  by  a  new  user,  due  to  the entry  in  creditAccounts  Alice  will  still  have  access  to  this  account  and  can  collect  its  funds  by  e.g. closing or repaying the account.    transferAccountOwnership()  now  features  the  nonReentrant  modifier.  Hence,  the  reentrancy issue described is no longer possible.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.4   DoS of LeverageActions", "body": "  LeveragedActions can be blocked completely or for specific collaterals only in different ways:  1. When  opening  an  account  the  credit  manager  will  check  if  onBehalfOf  already  has  an account. In case a malicious user has already transferred the ownership of a credit account to the LeverageActions contract then the CreditManager will fail to open a new one:  function openCreditAccount(     ...     require(         !hasOpenedCreditAccount(onBehalfOf) && onBehalfOf != address(0),         Errors.CM_ZERO_ADDRESS_OR_USER_HAVE_ALREADY_OPEN_CREDIT_ACCOUNT     ); // T:[CM-3]     ...  2. Although this is more a theoretical attack, assume a credit manager which prohibits the user to invest more that A amount of tokens. A malicious user sends to the the contract A + 1 tokens. When the contract will try to open a leveraged position it will do so using the total balance of the token  it  holds.  If  this  amount  is  greater  than  the  allowed  one  the  account  opening  will  block. The snippets which dictate the above behavior are the following:  LeverageActions:  function _openLong(LongParameters calldata longParams, uint256 referralCode){  Gearbox Protocol - Gearbox -   14  DesignMediumVersion4CodeCorrected        \f    ...     uint256 amount = IERC20(collateral).balanceOf(address(this)); // M:[LA-1]     ... }  CreditManager:  function openCreditAccount(     ...     require(         amount >= minAmount &&             amount <= maxAmount &&             leverageFactor > 0 &&             leverageFactor <= maxLeverageFactor,         Errors.CM_INCORRECT_PARAMS     ); // T:[CM-2]     ... }    For the case #1, an allowance system was implemented for the transfer of credit account. In order to get a credit account transferred, the receiver needs to pre-approve the sender of the credit account. Hence one  can  no  longer  transfer  a  credit  account  to  the  LeveragedAction  contract  and  the  issue  no  longer exists.  To mitigate case #2 the LeveragedActions contract now uses the actual balance difference.  *Moreover, Gearbox Protocol pointed out a third way to use the attack described above. Specifically, a user  can  open  an  account  on  behalf  of  the  LeverageAccount  contract  which  would  result  in  a Denial-of-Service  for  the  LeverageAction  contract.  The  issue  has  been  resolved  by  also  restricting  the address on behalf of which the credit account is opened.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.5   Incorrect params.amountOutMinimum", "body": "  The  parameter  params.amountOutMinimum  passed  to  the  call  to  the  UniswapV3  adapter  in _openLong() is calculated incorrectly and does not include the leverage.  _openLong  executes  a  swap  using  the  funds  of  the  opened  leveraged  account  given  the  swap parameters in longParams. The relevant parameters for the swap are in bytes swapCalldata which are  first  extracted  and  prepared  for  the  call  to  the  swap  contract.  Note  however  the  parameters representing  amountIn  and  amountOutMinimum  extracted  from  swapCalldata  do  not  include  the leverage, hence the actual values for the swap have to be calculated:  else if (longParams.swapInterface == Constants.UNISWAP_V3) {     ISwapRouter.ExactInputParams memory params = abi.decode(         longParams.swapCalldata,         (ISwapRouter.ExactInputParams)     );      params.amountIn = leveragedAmount;     params.amountOutMinimum = params     .amountOutMinimum  Gearbox Protocol - Gearbox -   15  CorrectnessMediumVersion4CodeCorrected        \f    .mul(leveragedAmount)     .div(params.amountIn);     ISwapRouter(adapter).exactInput(params);     (, asset) = _extractTokensUniV3(params.path); }  First params.amountIn is overwritten with leveragedAmount. Next params.amountOutMinimum is calculated, this calculation uses params.amountIn which is equal to leveragedAmount at this point.  Hence  the  params.amountOutMinimum.mul(leveragedAmount).div(params.amountIn);  actually  params.amountOutMinimum.mul(leveragedAmount).div(leveragedAmount);  simplifies to params.amountOutMinimum.  calculation: is which  The leverage is not included in params.amountOutMinimum.    The calculation of the leveraged value for params.amountOutMinimum is now done correctly using the unchanged  value  of  to leveragedAmount afterwards.  the  decoded  params.amountIn.  params.amountIn   is  only  set   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.6   Contracts Implement Proxy Pattern", "body": "  All adapters and the YearnPriceFeed contract inherit from OpenZeppelin's abstract Proxy contract and implement an _implementation function pointing to the address of the 3rd party system contract the adapter connects to. However, this proxy functionality is not needed nor used. The intended functionality of the adapter is implemented in functions inside the adapter contract itself.  Inheriting the proxy contract, however, has serious consequences. Calls to non-existing functions in the contract  execute  the  fallback  function,  which  is  implemented  by  the  inherited  proxy.  This  function forwards the call by delegate-calling into the implementation contract. During a delegate-call, the code at the target is executed in the context of the caller. Notably, it is read from and written to the storage of the caller,  the  adapter  contract.  This  can  have  an  adverse  effect  on  the  stored  variables  of  the  adapter contract. For example the stored values for the creditManager or the creditFilter.    The adapter contracts were rewritten and the proxy pattern was removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.7   Trust Model of External Adapters", "body": "  The  trust  model  for  the  external  adapters  has  not  been  properly  specified.  Moreover,  all  four  available adapters behave differently and the assumptions these adapters rely on have not been documented.  After the action on the external system which is invoked by an adapter, there is a check on the collateral of the credit account. All currently available adapters use the following function which takes the following parameters:  Gearbox Protocol - Gearbox -   16  SecurityMediumVersion1CodeCorrectedDesignMediumVersion1Speci\ufb01cationChangedCodeCorrected                  \ffunction checkCollateralChange(     address creditAccount,     address tokenIn,     address tokenOut,     uint256 amountIn,     uint256 amountOut )  The  concern  is  about  what  is  passed  as  amount  especially  for  the  spent  asset.  It  is  vital  that  these amounts represent the actual state of the credit accounts holding or the check may be circumvented.  Some adapters rely on the values returned by the 3rd party system, some query the actual balance.  While  querying  the  actual  balance  for  the  assets  involved  in  the  action  is  the  safest  option,  it  may  be expensive  in  terms  of  gas.  However  note  that  in  the  current  implementation  of  the  EVM  (London hardfork), repeated access to the same contract/storage location got significantly cheaper the overhead in terms of gas may not be that big.  Using values returned by the call to the third-party contract may be an option if the third-party contract is fully  trusted  to  do  so  correctly.  Similarly,  this  holds  for  input  parameters.  This  critical  part  should  be documented  and  assessed  thoroughly.  In  case  of  doubts/uncertainties,  it  may  be  safer  to  query  the balances and calculate the delta of the balances and use this.  Regarding  the  YearnAdapter,  it  can  be  inspected  and  documented:  Querying  the  balances  could  be Vault.withdraw avoided  [https://github.com/yearn/yearn-vaults/blob/main/contracts/Vault.vy]  return  the  change  in  the  balance  of the tokens of interest. However, the current YearnAdapter does not do this but queries the balance and calculates the delta.  Vault.deposit   since   both   and   The  UniswapV3  Adapter  relies  on  the  returned  values  by  the  3rd  party  system.  However,  there  is  no documentation why this assumption holds.  Specification changed and code corrected:  A pattern of how all adapters should be built has been created. All existing adapters have been rewritten to adhere to this pattern: The balance is queried before and after the action and the difference is used for the check of the collateral change.  Note that due to the existing token allowances for the adapters from the credit accounts these checks are not 100% failsafe. It is vital that the 3rd party system is fully trusted to not transfer any other tokens of the credit  account.  The  system  performs  the  fast  check  only  for  the  tokens  passed  as  arguments  to  the check. Any other change in balance will be ignored.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.8   Users Can Avoid Paying Fees On Closure", "body": "  On  account  closure,  all  the  assets  held  by  the  account  are  converted  to  the  underlying  token  through defaultSwapContract which is set to be UniswapV2. For this conversion, the user defines a path of tokens to the underlying. This path can contain arbitrary tokens, tokens even controlled by the user. A check  in  _closeCreditAccountImpl  assures  that  the  closure  of  a  credit  account  will  not  lead  to losses for the protocol i.e., require(loss <= 1). On the closure of an account users are supposed to return to pool the amount they borrowed, the interest accrued for that amount and an extra amount for fees  namely,  feeSuccess  and  feeInterest.  It  is  important  to  note  that  if  the  funds  do  not  suffice totalFunds < amountToPool then only the borrowed amount with the interest accrued is returned and no fees are required to be paid. This means that draining a credit account to the point that does not make losses can allow a user to avoid paying fees to the protocol.  Gearbox Protocol - Gearbox -   17  DesignMediumVersion1CodeCorrected        \fCode Corrected:  A new check has been introduced which requires that remainingFunds > 0. This way it is guaranteed that the user has paid their fees. Due to this requirement, a closure that does not result in fee payout will be reverted. Hence, the only option for the users will be to repay.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.9   Wrong Approval To Pool", "body": "  *While the review was ongoing Gearbox Protocol informed us about this issue independently in parallel.  In the WETHGateway.repayCreditAccountETH an approval is given to the pool:  _checkAllowance(pool, amount); // T: [WG-11]  However, this approval is wrong and should be given to the credit manager who performs the transfer from the WETHGateway to the pool.    The code has been corrected in a further commit and the allowance is now given to the CreditManager instead of the pool in order for the credit manager to be able to transfer the tokens from the user to the pool.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.10   maxAmount Can Be Circumvented", "body": "  When opening a credit account, a check of the amount invested is performed:  require(     amount >= minAmount && amount <= maxAmount,     Errors.CM_INCORRECT_AMOUNT );  By limiting the amount originally invested, one can limit the amount of leverage that can be borrowed by the pool. However, this limitation can be circumvented as follows:  1. The user opens an account with an allowed account.  2. She calls CreditManager.addCollateral.  3. She calls increaseBorrowedAmount.  Note, that addCollateral does not perform any checks and increaseBorrowedAmount only checks that the borrowed amount does not turn the account unhealthy.  Code Corrected:  The  implementation  has  been  extended  to  prevent  increasing  the  borrowed  amount  more  than  the predetermined maximum:  Gearbox Protocol - Gearbox -   18  DesignMediumVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \frequire(      borrowedAmount.add(amount) <          maxAmount.mul(maxLeverageFactor).div(              Constants.LEVERAGE_DECIMALS          ),      Errors.CM_INCORRECT_AMOUNT  );  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.11   takeOut May Break the Account List", "body": "  The  configurator  can  take  out  an  account  by  calling  AccountFactory.takeOut().  During  account removal, there is no check whether this is the tail nor is the tail updated in case this account is taken out. Should the tail account be taken out this is problematic:  New  accounts  added  will  not  be  connected  to  the  original  list,  hence  they  cannot  be  taken  using takeCreditAccount() which takes the head of the original list.  Similarly,  returned  accounts  will  be  added  to  the  list  after  the  removed  tail  account  which  no  longer exists  in  the  list.  Again,  the  connection  to  the  original  list  starting  at  head  is  interrupted  and  these accounts cannot be used anymore.  Code Corrected:  The implementation has been extended to correctly update tail when the last account is taken out.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.12   Discrepancy Between openShortUniV2 and", "body": " openShortUniV3  LeverageAction.openShortUniV2  sets  the  deadline  for  the  short  swap  to  the  current  block timestamp:  bytes memory data = abi.encodeWithSelector(     bytes4(0x38ed1739), // \"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",     amountIn,     amountOutMin,     path,     address(this),     block.timestamp ); // M:[LA-5]  the  call  cannot   This  way  the  other  hand, LeverageAction.openShortUniV3  lets  users  define  the  deadline  themselves.  This  means  that  a transaction that takes long to be included into a block might fail.  to  a  passed  deadline.  On   fail  due     Gearbox Protocol - Gearbox -   19  DesignMediumVersion1CodeCorrectedDesignLowVersion4CodeCorrected                \fThe  code  of  openShortUniV2  was  changed  and  now  uses  the  user-specified  parameter  deadline instead  of  block.timestamp.  It's  the  caller's  responsibility  to  specify  a  proper  deadline.  With  this change, the behavior of the functions for UniV2 and V3 are now consistent.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.13   Use of transfer", "body": "  _returnTokenOrUnwrapWETH uses transfer instead of safeTransfer for transferring tokens. This call will fail for tokens which do not adhere to the ERC20 interface e.g., USDT.    The code was changed to use safeTransfer.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.14   Rounding Errors", "body": "  In CreditManager.increaseBorrowedAmount the following check is performed:  require(     borrowedAmount.add(amount) <         maxAmount.mul(maxLeverageFactor).div(             Constants.LEVERAGE_DECIMALS         ),     Errors.CM_INCORRECT_AMOUNT );  This check includes a division with Constants.LEVERAGE_DECIMALS which results in a rounding error. This error can be avoided, if one multiplies the left side of the inequality with the same value instead.  In  the  following  snippet  of  PoolService.expectedLiquidity  a  division  before  multiplication  takes place:  uint256 interestAccrued = totalBorrowed .mul(borrowAPY_RAY) .div(Constants.RAY) .mul(timeDifference) .div(Constants.SECONDS_PER_YEAR);  Division  before  multiplication  can  interestAccrued will be smaller.  result   in   rounding  errors.   In   this  particular  case,   the  Code Corrected:  Regarding the first issue, the division has been replaced with a multiplication. Regarding the second one, the order of operations has changed and the multiplications take place first.  Gearbox Protocol - Gearbox -   20  DesignLowVersion4CodeCorrectedDesignLowVersion2CodeCorrected                  \f6.15   Head Cannot Be Taken Out  Calling  AccountFactory.takeOut  requires  to  pass  the  previous  account  of  the  one  to  be  deleted (prev). This means that the head credit account of the list cannot be taken out since there is no prev defined for it.  Code Corrected:  The implementation has been extended to handle the removal of the head.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.16   Pointers Not Updated On takeOut", "body": "  A  credit  account  can  be  function AccountFactory.takeOut.  Under  normal  circumstances  this  account  cannot  be  accessed  again  by the function. However, consider the following scenario:  the  configurator  using   the  system  by   taken  out  of   1. The  controller  removes  the  head  account  (A1).  In  this  case,  the  head  is  just  updated  to  the second account (A2). Note that at the removal of the head, the pointers of the head account _nextCreditAccount[head] is not reset.  2. Later A2, the current head is also removed.  3. This  means  that  the  controller  can  take  out  A2  again  by  calling  takeOut(A1,  A2)  and  connect it to a new to address.  The  reason  for  the  above  is  that  _nextCreditAccount[A1]  is  not  updated  upon  removal  and  still points to A2 which has also been removed. The check  require(             _nextCreditAccount[prev] == creditAccount,             Errors.AF_CREDIT_ACCOUNT_NOT_IN_STOCK         );  is still satisfied despite the accounts being no longer part of the system.  Code Corrected:  The pointers are now updated correctly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.17   Redundant Multiplication", "body": "  In PoolService.removeLiquidity a part of the amount requested by the user is sent back to them determined by withdrawMultiplier and an amount determined by the withdrawFee is sent to the treasury.  that withdrawMultiplier + withdrawFee == PERCENTAGE_FACTOR. These two amounts should add up to underlyingTokensAmount. Hence, there is no need to perform two safe multiplications with both withdrawFee and withdrawMultiplier and the following multiplication is redundant:  construction   know   we   By   Gearbox Protocol - Gearbox -   21  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \fIERC20(underlyingToken).safeTransfer(     ...     underlyingTokensAmount.percentMul(withdrawFee) ); // T:[PS-3, 34]  Code Corrected:  The  issue  has  been  resolved.  In  the  current  implementation,  only  one  multiplication  takes  place.  The amount  from underlyingTokensAmount.  subtracting  amountSent   calculated  by   is  now   treasury   sent   the   to   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.18   Storage Optimizations", "body": "  There are various small optimizations that can be applied to the contracts of the system to improve gas efficiency:  1. Storage variable can be declared as constants: In GearToken contract totalSupply can be  declared as constant.  2. Some functions can be declared as external:   AccountFactory.countCreditAccountsInStock()   CreditFilter.checkCollateralChange(address,address,address,uint256,uint256)   CreditFilter.allowedContractsCount()   CreditFilter.allowedContracts(uint256)   GearToken.delegate(address)   GearToken.delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)   GearToken.getPriorVotes(address,uint256)  3. Dead code which can be removed:   BytesLib.slice(bytes,uint256,uint256)   BytesLib.toUint24(bytes,uint256)  Code Corrected:  Issues 1. and 2. have been resolved. Regarding 3., the client states:  BytesLib functions are used in support contracts which are not in the scope  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.19   Taking Out the First-Ever Created Account", "body": "  The configurator can call AccountFactory.takeOut to remove an account completely and connect it to an address of their choice. To do so, they provide the address of the account to be removed and the address of the previous account in the list of the available accounts. Let us consider the addition of the  Gearbox Protocol - Gearbox -   22  DesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                \ffirst-ever  created  account.  The  account  is  added  during  the  deployment  of  the  AccountFactory  i.e., when the constructor is invoked. At this point, both the head and the tail are 0. This means that in the following snippet, it holds _nextCreditAccount[0] == clonedAccount.  function addCreditAccount() public {     ...      _nextCreditAccount[tail] = clonedAccount; // T:[AF-2]      ...  first-ever  created  account.   Note that _nextCreditAccount[0] is never updated. This means that there is always a pointer at 0 to the  configurator  calls  takeOut  with  prev  ==  0x0  and the  creditAccount the first ever created account they can control it even though the account might be in use at the time of the call. In other words, there is always a pointer to the first ever created account even if the account is not in stock. The case above makes the following check in AccountFactory.takeOut and the error message emitted imprecise:  If   require(     _nextCreditAccount[prev] == creditAccount,     Errors.AF_CREDIT_ACCOUNT_NOT_IN_STOCK ); // T:[AF-15]  The check whether the account is in stock doesn't work as expected in the scenario described above.  Code Correct:  The  pointer  of  _nextCreditAccount[0]  now  points  to  address(0)  and  not  the  first-ever  created account.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.20   allowToken Can Be Blocked", "body": "  The purpose of creditFilter.allowToken is twofold. On one hand, it allows the system to use new tokens. On the other hand, in the case of an already registered token, it allows updating the liquidation threshold for this token.  Due to the bitmask optimization used, the following check assures that no more than 256 different tokens can be tracked by the system.  require(allowedTokens.length < 256, ...);  However,  in  the  unlikely  case  of  256  registered  tokens,  the  liquidation  threshold  cannot  be  updated anymore since the above check will fail, leading the transaction to revert.  Code Corrected:  The code has been corrected. The requirement will be satisfied when the function is called with a token for which tokenMasksMap[token] > 0 as shown in the following in snippet:  Gearbox Protocol - Gearbox -   23  DesignLowVersion1CodeCorrected        \frequire(     tokenMasksMap[token] > 0 || allowedTokens.length < 256, ... );  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.21   cancelAllowance Cannot Be Called", "body": "  When  an  account  is  closed,  it  is  returned  to  the  factory.  It  is  important  to  note,  however,  that  the allowances the account has given to other addresses remain in place. This can be dangerous in case of malfunctioning approved contracts. In order to mitigate this risk, the configurator is allowed to reduce or remove the allowances. This functionality is implemented by CreditManager.cancelAllowance. This function is supposed to be called by the factory. However, no function that calls cancelAllowance is implemented, thus the allowance cannot be revoked.  Code Corrected:  the  current  The  code  has  been  corrected.  AccountFactory.cancelAllowance which then calls CreditAccount.cancelAllowance.  implementation   the  configurator  can  call  In   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.22   connectCreditManager Access Control", "body": "  The  CreditFilter.connectCreditManager  function  does  not  implement  proper  access  control. The  first  caller  to  this  function  can  set  CreditManager  to  his  address.  This  does  not  pose  threat  to  the system but could lead to wasted deployments of the Credit Filter.  Code Corrected:  The code has been fixed, now only the configurator is allowed to set the creditManager for the filter.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "6.23   rayMul and rayDiv Are Used With No Ray", "body": " Values  PoolService.expectedLiquidity()  performs  a  multiplication  using  rayMul  passing totalBorrowed  as  a  parameter.  However  totalBorrowed  is  not  in  RAY  but  in  the  decimals  of  the underlying token.  uint256 interestAccrued = totalBorrowed.rayMul(     borrowAPY_RAY.mul(timeDifference).div(Constants.SECONDS_PER_YEAR) ); // T:[GM-1]  This contradicts the specification for rayMul which states the following:  * @dev Multiplies two ray, rounding half up to the nearest ray  Gearbox Protocol - Gearbox -   24  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \fSimilarly this applies for fromDiesel(). Additionally getDieselRate_RAY() uses and toDiesel() use rayDiv which is annotated with:  * @dev Divides two ray, rounding half up to the nearest ray    rayMul and rayDiv are now correctly used.  Gearbox Protocol - Gearbox -   25  \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "7.1   Blocking updateContributors", "body": "  block.   TokenDistributor.updateContributors  of can  TokenDistributor.updateVesting for each holder. Consider the following scenario: A receiver RA of  the  Vesting  contract  calls  setReceiver  to  an  address  RB  which  is  a  receiver  of  another  contract. Then for updateVesting(RA), it holds vestingContracts[RB].contractAddress != 0 which makes the transaction revert. This leads the execution of updateContributors to revert as well. Note that users do not have an incentive to change the receiver address to another's receiver address. Moreover, the  new  receiver  can  change  again  the  address  to  another  public  address  they  control.  This  would unblock the execution of TokenDistributor.updateContributors. However, it is up to the specific user to address the issue.  function  makes   The   use   This  just  affects  the  updateContributors  function  which  attempts  to  update  all  holders.  The unaffected holders can always be updated individually through updateVesting().  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "7.2   Handling Of Reward Tokens", "body": "  Users  of  the  Gearbox  system  are  allowed  to  trade  through  specific  adapters.  Moreover,  the  credit accounts  are  only  enabled  to  access  the  balance  of  the  enabled  tokens  which  are  specified  by  the governance.  However,  there  might  be  the  case  where  one  of  the  allowed  tokens  accrues  rewards  in another token which is not part of the enabled tokens. Currently, users can only collect their rewards by repaying their accounts and receive the tokens which accrue the rewards.  Furthermore, rewards may be accrued by the credit account address e.g., due to a user interacting with a certain third-party system. Such a reward may be only claimable in the future, notably e.g., after a credit account user returned his account to the factory. Such a reward may be claimable by the next user of this credit account.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "7.3   Liquidity Removal Not Always Possible", "body": "  Users can remove liquidity they have offered to the pool by calling PoolService.removeLiquidity. During this call, a transfer is performed from the pool to the msg.sender with the requested amount. It is important  to  be  aware  that  in  case  of  high  utilization  of  the  pool,  the  amount  requested  might  not  be available since it is used as leverage in some positions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "7.4   Oracles Do Not Handle Stale Prices", "body": "  Gearbox Protocol - Gearbox -   26  NoteVersion7NoteVersion1NoteVersion1NoteVersion1              \fThe Gearbox system relies on chainlink oracles to derive the value of the assets a credit account holds. The chainlink interface allows the consumers of the data to know whether a price returned is stale or not timestamps  https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata. based  on  However, Gearbox does not take advantage of these timestamps meaning that stale data could be used by the system.  the   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "7.5   Price Feeds Cannot Be Updated", "body": "  A price feed can be added by the configurator of the system by calling PriceOracle.addPriceFeed. The logic of the addition is implemented inside an if statement with the following condition:  if (priceFeeds[token] == address(0)) {  This  means  that  if  the  price  feed  for  a  token  T  is  already  defined  i.e.,  priceFeeds[T]  !=  0  then  it cannot be updated. This becomes important especially when it comes to custom price feed such as the yearn price feed which might require an upgrade at some point.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "7.6   Special ERC-20 Token Behavior May Be", "body": " Problematic  Some ERC-20 tokens have transfer fees. Supporting such tokens may lead to accounting errors as the actual amount received after a transfer may not match the expected amount, e.g. when funds are repaid to the pool.  Furthermore, note that the _convertAllAssetsToUnderlying() used during the closure of a credit account uses UniswapV2's swapExactTokensForTokens function which does not support token with transfer fees.  In general, when adding tokens to the system they should be carefully inspected for any special behavior such  as  hooks.  If  any  special  behavior  is  detected,  the  impact  on  the  system  should  be  evaluated carefully.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "7.7   Users Can Turn Their Account Liquidatable", "body": " Inadvertently  Gearbox uses fast check and health factor in order to prevent users from draining funds that should be returned back to the pool.  However  an  unaware  user  may  turn  his  account  into  a  liquidatable  state  inadvertently.  Consider  the following scenario:  Assume  that  a  healthy  account  holds  only  token  A  with  value  V_A  (in  the  underlying  token)  and  owes amount B. The health factor of the account is H_f = V_A * LT_A / B.  Now, this user trades the balance of A to token C, which is worth slightly when evaluated in the underlying asset.  After  the  trade  through  the  adapter  is  completed,  the  check  on  the  collateral  takes  place.  Let's assume  we're  eligible  for  the  fast  check  and  this  passes  as  the  value  in  terms  of  the  underlying  has increased.  Gearbox Protocol - Gearbox -   27  NoteVersion1NoteVersion1NoteVersion1            \fHowever,  it  could  be  that  the  liquidation  threshold  of  token  A  and  token  C  are  different,  e.g. LT_C << LT_A. This means that the health factor H_f' = V_C * LT_C / B may become less than 1 after the trade even though the value of the holdings has not been decreased.  Gearbox Protocol - Gearbox -   28  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/gearbox/"}, {"title": "5.1   Code Duplication Balance Getters", "body": "  The engine contract implements two functions: balanceRisky() and balanceStable() which return the balance of the engine for the respective token. These two functions implement the same functionality and have the same logic, therefore can be merged into a single function that takes the token address (for stable or risky) as an input parameter.  Acknowledged  The client prefers two separate functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "5.2   Event Optimization", "body": "  The  swap()  function  emits  two  events:  UpdatedTimestamp()  and  Swap()  which  can  be  integrated into one event to reduce the gas consumption.  Acknowledged  This behavior is desired by Primitive.  Primitive Finance - Core Engine -   9  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedAcknowledgedCodePartiallyCorrectedAcknowledgedAcknowledgedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                   \f5.3   Sanity Checks  When  depositing,  withdrawing,  allocating,  and  swapping  (VERSION4)  the  receiving  account  can  be chosen. No basic sanity check if it is accidentally address zero is performed. Additionally, the strike price could be validated if it is not zero in create.  Code partially corrected  A sanity check for the strike price in create is implemented but no checks for address zero are added.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "5.4   Unused Function getRiskyGivenStable", "body": "  The function getRiskyGivenStable is declared internal but not used in the code.  Acknowledged  Primitive Finance acknowledged the issue but communicated that the function is kept as it is for now.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "5.5   Unused Storage Fields", "body": "  The PrimitiveEngine contract is deployed by the PrimitiveFactory contract. The engine stores the  factory  address  as  state  variable  address  public  immutable  override  factory;  and  an owner but these variables are not used.  Acknowledged  Primtive acknowledged the behavior and informed us that this is intended.  Primitive Finance - Core Engine -   10  DesignLowVersion1CodePartiallyCorrectedDesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  7  7  9  -Severity Findings  -Severity Findings   Low Decimal Token Issues    Anyone Can Call the Repay Function After Pool's Maturity    Borrower Locks Liquidity in the Pool    Disable Unnecessary Functionalities After Expiry    Flawed Fee and Premium Structure    No Slippage Protection    Violation of Maximum Ratio of Float Liquidity   -Severity Findings   Token Decimal Validation    Explicitly Handling Positive Invariant Restriction   Incorrect Tracking of Cumulative Values for Pool Reserves    Liquidity Providers Get Rewards Without Supplying Float Liquidity    Possible Overflows    Possible to Frontrun on Claim Request    Redundant and Improper Revert Condition   -Severity Findings  Inconsistency of Input Parameters    Unused Error Definition    Redundant Storage Read    Code Duplication    Duplicated Calculation of Invariant   Implementation of getStableGivenRisky Function    Possible Gas Optimization in the Deposit Function    Return Value in safeTransfer    MANTISSA_INT Constant   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.1   Low Decimal Token Issues", "body": "  Primitive Finance - Core Engine -   11  CriticalHighCodeCorrectedSpeci\ufb01cationChangedSpeci\ufb01cationChangedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedSpeci\ufb01cationChangedMediumCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedLowCodeCorrectedCodeCorrectedSpeci\ufb01cationChangedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignHighVersion3CodeCorrected           \fThe  lower  the  decimals  of  a  token  are  and  the  higher  the  value,  the  more  severe  rounding  issues  will become. Simultaneously, the liquidity position accounting with 18 decimals will cause issues.  Examples issues are:  Burning one unit of a low decimal but high value token (in create) might be a huge loss for the user.  There  is  a  dependency  between  the  delta  when  creating  a  pool  and  the  decimals  of  a  token.  delta cannot be chosen freely because of this dependency (1e18 - delta) - 1e(18-decimals) needs to  be  bigger  than  1,  else  the  create  will  revert.  This  basically  eliminates  the  support  of  zero  decimal tokens (as the only viable option is delta = 0). Low decimals limit the range of delta and the step accuracy  with  which  the  risky  token  amount  is  calculated.  E.g.  the  maximum  value  of  delta  can  be 9e17  (should  be  1e18)  for  1  decimals,  99e16  for  2  decimals  and  so  on.  The  step  size  should  be accordingly high to increase the resulting delRisky one unit.  With decreasing decimals this calculation will lose precision if the token decimals are not dividable by the fraction delLiquidity / PRECISION with modulo zero.  delRisky = (delRisky * delLiquidity) / PRECISION; // liquidity has 1e18 precision, delRisky has native precision delStable = (delStable * delLiquidity) / PRECISION;  The  function  getAmounts  has  a  similar  problem  and  will  losing  precision.  This  can  be  exploited  in allocate  to  receive  more  liquidity  tokens  than  the  user  would  be  entitled  to  as  the  rounding  in allocate is in the user's favor.  Code corrected  The  issues  above  have  been  tackled  by  only  accepting  token  decimals  between  six  and  18.  Six  was chosen to support famous stable coins and did not lead to issues in tests. However, tests and fuzzing does not cover all possible states and due to the complex math, there might be a state that still results in issues regarding to the decimals.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.2   Anyone Can Call the Repay Function After", "body": " Pool's Maturity  After the pool's maturity has passed, i.e., the pool has expired, anyone can call the function repay() for any borrower and receive their premiums in case the borrower's possition yields profit. The first three lines of the function repay() allow any msg.sender to receive the premiums for any borrower:  Since the borrower is incentivized to call the function repay() only when there is profit, the function allows any attacker to collect the unclaimed profit of any borrower after the pool's maturity. Furthermore, if the legitimate borrwers calls the function repay() at the maturity of the pool, the attacker has still a possibility to frontrun the legitimate transaction.   Specification changed  This  version  of  the  code  introduces  a  grace  period,  around  24h,  to  permit  only  borrowers  calling  the function repay() after pool's maturity. In case a borrower does not call the function during this period, anyone can call the function repay() and exit the borrowers' positions, therefore releasing the locked liquidity.   Specification changed  The respective code has been removed according to the new specifications of   .  Primitive Finance - Core Engine -   12  DesignHighVersion1Speci\ufb01cationChangedVersion2Version3Version3        \f6.3   Borrower Locks Liquidity in the Pool  the  function  borrow()  with  a  given  delLiquidity   call Calling  reserve.borrowFloat() which decreases the amount of available float in the pool and increases the debt  of  the  pool  reserve  accordingly.  This  way,  the  borrower  locks  delLiquidity  from  the  available float in the pool reserve. Below is the borrowFloat function.  triggers   the   function borrowFloat(Data storage reserve, uint256 delLiquidity) internal {         reserve.float -= delLiquidity.toUint128();         reserve.debt += delLiquidity.toUint128(); }  A liquidity provider that has supplied its liquidity as float needs to first call the function claim() which converts the float into liquidity before removing the liquidity from the pool. However, the only way for all liquidity providers to claim all their float liquidities is if all borrowers call the function repay() which triggers a call to reserve.repayFloat():      function repayFloat(Data storage reserve, uint256 delLiquidity) internal {     reserve.float += delLiquidity.toUint128();     reserve.debt -= delLiquidity.toUint128(); }  But,  if  the  price  of  the  risky  token  is  below  the  strike  price,  the  borrower  has  no  incentive  to  call  the function  repay(),  therefore  potentially  keeping  locked  the  float  liquidity.  Moreover,  the  function repay() does not impose any time restriction to borrowers when they can exercise their option, i.e., the borrower  can  potentially  call  the  repay()  function  at  an  arbitrary  time  after  the  maturity.  This  puts pressure on the liquidity providers to call it themselves which is possible because in the current version of the  PrimitiveEngine  contract,  anyone  can  call  the  function  repay()  after  the  maturity  of  the pool. If liquidity provider have the burden to call the functions, they also bear the costs.   Specification changed  This  version  of  the  code  introduces  a  grace  period,  around  24h,  to  permit  only  borrowers  calling  the function repay() after pool's maturity. In case a borrower does not call the function during this period, anyone can call the function repay() and exit the borrowers' positions, therefore releasing the locked liquidity. Still, the additional costs need to be payed by the caller / LP if they call it to relase their funds.   Specification changed  The respective code has been removed according to the new specifications of   .  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.4   Disable Unnecessary Functionalities After", "body": " Expiry  In the current version of the PrimitiveEngine contract all functions, except function swap(), can be called after the pool has expired. For example, a liquidity provider could close the opened positions of borrowers,  claim  its  share  of  the  float  liquidity,  and  then  call  function  borrow()  for  the  remaining amount of float.  Primitive Finance - Core Engine -   13  DesignHighVersion1Speci\ufb01cationChangedVersion2Version3Version3DesignHighVersion1CodeCorrected                \fCode corrected  The updated version of the contract has new checks if the pool is still valid in the respective functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.5   Flawed Fee and Premium Structure", "body": "  When swapping, a fee is charged and borrows pay a premium on their position. Both amounts end up in the  pool  without  separate  accounting.  This  has  various  implication.  All  arising  from  the  fact  that  the underlying  calculation  are  based  on  the  pool's  reserve,  which  includes  the  fees  and  premiums.  All operations  that  pay  out  a  proportion  of  the  reserve  amounts  -  also  pay  out  parts  of  the  fees  and premiums. Hence, each time remove, repay, swap or borrow is called, fees and premiums are payed out. Regardless of the callee is entitled to receive these fees.  The  most  severe  issue  is  the  swap  function.  Swapping  on  the  pool's  reserve,  which  includes  the collected fees, will nullify all previous fees and prevent fee accumulation. Hence, liquidity providers will not earn fees collected during the lifetime of the pool, but only the fee from the last swap.  Other examples for issues are shared (even with non-eligible users) premiums and fees, participating on fees and premiums repeatedly. E.g. a liquidity provider that does not take the risk of lending their token gets  a  share  of  the  premium.  A  borrower  gets  part  of  the  premium  and  fees  of  others.  All  this  can  be leveraged through repeating the operation.   Specification changed  This version of the code introduces a novel fee structure.   Specification changed  The  respective  code  has  been  updated  according  to  the  new  specifications  of  fees only during swaps.    which  assume  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.6   No Slippage Protection", "body": "  All transactions have a lag between the time they are sent and the time they are executed as they remain in  the  mem  pool  for  some  time  prior  to  being  executed.  Between  sending  and  execution,  other transaction might change the contract's state. This is critical for all transaction where the user receives or  all action function in the Engine contract except for supply and claim do has to pay funds. In  not  offer  any  protection  against  slippage.  In  VERSION4  this  affects  allocate,  remove,  and  swap. Without  checking  if  the  transaction  is  still  executed  under  the  desired  conditions,  the  user  may  suffer losses.  This issue can be maliciously exploited by front running certain transactions. However, as the system is designed to interact with smart contracts, the slippage protection could be implemented on their side.  Code corrected  The user is now able to define the delta in and delta out when swapping. Hence, the user either gets the defined values or the swap will revert due to a violation of the invariant check. The check verifies that the invariant can only increase.  Primitive Finance - Core Engine -   14  DesignHighVersion1Speci\ufb01cationChangedVersion2Version3Version3DesignHighVersion1CodeCorrectedVersion1                \f6.7   Violation of Maximum Ratio of Float Liquidity  The amount of liquidity supplied as float should be less than a threshold value, hard coded to 80% in the current version of the contract. This restriction is enforced in the function addFloat() as follows:  function addFloat(Data storage reserve, uint256 delLiquidity) internal {         reserve.float += delLiquidity.toUint128();         if ((reserve.float * 1000) / reserve.liquidity > 800) revert LiquidityError();     }  This restriction is enforced only when a liquidity provider supplies its liquidity as float, but it does not hold always as any liquidity provider can freely remove available liquidity from the pool. For example, if the float  the function remove() to remove the 20% of the remaining liquidity, thus putting the pool reserve in a state with 100% of its liquidity as float.  liquidity  provider  could  call   (i.e.,  80%),  one   its  maximum   liquidity   is  at   level   function remove(         Data storage reserve,         uint256 delRisky,         uint256 delStable,         uint256 delLiquidity,         uint32 blockTimestamp     ) internal {         reserve.reserveRisky -= delRisky.toUint128();         reserve.reserveStable -= delStable.toUint128();         reserve.liquidity -= delLiquidity.toUint128();         update(reserve, blockTimestamp);     }   Code corrected  The Reserve library now defines a function checkUtilization() which checks if the invariant holds whenever float is added, float is payed, or the liquidity is removed.  :  Specification  changed  The  respective  code  has  been  removed  according  to  the  new  specifications of   .  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.8   Token Decimal Validation", "body": "  The engine contract supports tokens with different decimals. However, tokens with very few decimals and more than 18 decimals cause severe issues but are allowed to be deployed by the factory.  Code corrected  The  factory  now  validates  decimals  for  both  tokens  before  deploying  an  engine.  Tokens  with  6  to  18 decimals are supported.  Primitive Finance - Core Engine -   15  SecurityHighVersion1Speci\ufb01cationChangedVersion2Version3Version3DesignMediumVersion3CodeCorrected                  \f6.9   Explicitly Handling Positive Invariant Restriction  The current implementation checks that the invariant grows assuming it is negative and, when updated by a swap, grows closer to zero: if (invariant > nextInvariant && nextInvariant.sub(in variant) >= Units.MANTISSA_INT).  A  zero  invariant  implies  a  balanced  pool  at  the  time  of  the  swap.  Typically,  the  invariant  should  not become  positive  but  could  happen  in  specific  scenarios  such  as  high  trading  frequency  and  high  fee accumulation. If this is the case, besides major other problems, the pool cannot recover as the invariant needs to decrease back to zero to be in balance again. This is because of the check, that the invariant is only allowed to grow after a trade. However, in case of a positive invariant, it should not become more positive.  : Code changed  The updated version of the code checks explicitly if the invariant is positive and prevents the invariant to grow in the wrong direction.  :  Specification  and  code  changed  The  issue  theoretically  exists  in  version  3.  However, according to Primitive Finance, a positive invariant is not an undisired state any more and a swap should not lead to a decreasing invariant - even if it is positive.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.10   Incorrect Tracking of Cumulative Values for", "body": " Pool Reserves  Primitive  Finance  pointed  out  this  issues  while  the  audit  was  ongoing.  They  are  aware  that  calling  the function update() after the pool reserve values are updated, results in incorrect cumulative values.  Code corrected  The function update() is called before the new amounts have been applied to the pool reserves.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.11   Liquidity Providers Get Rewards Without", "body": " Supplying Float Liquidity  In order for users to borrow liquidity from the pools, liquidity providers should allocate liquidity to a pool and then supply it as float which can be borrowed. Users pay a premium when borrowing liquidity and the float liquidity of the pool reserve is deducted. After the borrowers pay their debt, the liquidity providers should claim at first their share of liquidity as float, and then remove it from the reserve.  Since the liquidity providers do not get tokens for their supplied liquidity, the premiums paid by borrowers go to the pool reserve. This way, all liquidity provider get tokens out according to their share of liquidity and independently if they have supplied float liquidity to the pool. Hence, a liquidity provider that supplies  Primitive Finance - Core Engine -   16  DesignMediumVersion1Speci\ufb01cationChangedVersion2Version3DesignMediumVersion1CodeCorrectedDesignMediumVersion1Speci\ufb01cationChanged                      \ffloat liquidity and is more exposed (cannot remove liquidity unless borrowers repay it, or the maturity has passed) do not get any additional reward.   Specification and code changed  Version  2  introduces  a  novel  fee  structure  that  collects  fees  when  borrow()  function  is  called  and distributes the collected fees to liquidity providers that have supplied float. In case of a positive invariant, swap fees are also distributed to float providers.   Specification changed  The respective code has been removed according to the new specifications of   .  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.12   Possible Overflows", "body": "  Primitive Finance pointed out these issues while the audit was ongoing. They are aware that the following expressions could overflow:  res.cumulativeRisky += res.reserveRisky * deltaTime; uint256 reserveRisky = (res.reserveRisky * 1e18) / res.liquidity;  Code corrected  The overflow is avoided by casting the variables to uint256 as follows:  res.cumulativeRisky += uint256(res.reserveRisky) * deltaTime; delRisky  =  (delLiquidity  *  reserve.reserveRisky)  /  reserve.liquidity;,  where delLiquidity is of type uint256.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.13   Possible to Frontrun on Claim Request", "body": "  In  some  situations,  e.g.,  the  price  of  the  underlying  token  changes  significantly,  one  (or  more)  liquidity providers might want to exit their positions and call function claim() to remove their liquidity from float. However, an attacker might frontrun this transaction and call function borrow() and prevent the liquidity provider from exiting their position.   Specification changed  The respective code has been removed according to the new specifications of   .  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.14   Redundant and Improper Revert Condition", "body": "  The  two  functions  balanceRisky()  and  balanceStable()  verify  if  the  call  returns  the  balance correctly by checking: if(!success && data.length < 32) and revert if the condition is true. This makes sense if success is false or the call did not return a value (data.length < 32). With using &&  instead  of  or  the  condition  would  not  revert  for  the  combination  of  success  =  false  and data.length > 32 (which is possible). As the function needs the balance to work properly, we do not see  a  case  where  this  should  not  revert  if  data.length  <  32.  The  data.length  check  is  also  Primitive Finance - Core Engine -   17  Version2Version3Version3SecurityMediumVersion1CodeCorrectedDesignMediumVersion1Speci\ufb01cationChangedVersion3Version3DesignMediumVersion1CodeCorrected                        \fredundant  because  it  is  also  performed  in  abi.decode(data,  (uint256)).  Additionally,  it  might make sense to reevaluate if the less than condition makes sense or an equal condition would be more suitable.  Code corrected  The client has updated the check as follows: if (!success || data.length < 32).  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.15   Inconsistency of Input Parameters", "body": "  The engine contract is not consistent on the number of decimals an input value should have when called externally.  More  precisely,  the  function  create()  expects  the  strike  price  to  have  18  decimals, independently from the decimals of the stable token. However, the function swap() expect the deltaIn to  have  the  same  decimals  as  the  token  being  swapped  in.  A  similar  format  is  expected  by  functions deposit() and withdraw().  Code corrected  The  function  create()  expects  the  strike  price  to  have  the  same  number  of  decimals  as  the  stable token. Also, the specification has been updated accordingly.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.16   Unused Error Definition", "body": "  The error ZeroLiquidityError is defined in IPrimitiveEngineErrors but not used.  Code corrected  The ZeroLiquidityError error is now used in remove and allocate.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.17   Redundant Storage Read", "body": "  Reading from state storage consumes more gas than reading from memory. The compiler often handles redundant  storage  reads.  To  avoid  paying  multiple  times  for  storage  reads,  storage  variables  can  be buffered  in  memory  if  used  more  than  once.  This  is  tha  case  for  precisionStable  and precisionRisky in create and swap as they are accessed more than once from storage.  Specification changed  The decimal accounting was changed in   . This issue does not exist anymore.  Primitive Finance - Core Engine -   18  DesignLowVersion3CodeCorrectedDesignLowVersion3CodeCorrectedDesignLowVersion2Speci\ufb01cationChangedVersion3                          \f6.18   Code Duplication  The following functions share the same code which could be reused:  In borrow, repay, remove and allocate:  delRisky = (delLiquidity * reserve.reserveRisky) / reserve.liquidity; // amount of risky from removing delStable = (delLiquidity * reserve.reserveStable) / reserve.liquidity; // amount of stable from removing  Code corrected  The duplicated statements are moved into a function getAmounts() in the Reserve library.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.19   Duplicated Calculation of Invariant", "body": "  The  function  swap()  after  updating  the  timestamp  of  the  pool,  calculates  the  invariant  for  the  new time  until  expiry  (tau):  int128  invariant  =  invariantOf(details.poolId);.  Afterwards, calls  either depending  on  getStableGivenRisky()  getRiskyGivenStable().  call function  invariantOf(),  which  recalculates  the  invariant  for  the  same  pool  and  the  same timestamp.  Although  recalculating  the  invariant  is  reasonable  for  external  calls,  it  increases  the  gas consumption for calls from the swap function.  value  of  riskyForStable  parameter,   functions   function   these   Both   the   the   or   Code corrected  The  updated  function  swap()  calls  the  getRiskyGivenStable()  and  getStableGivenRisky() functions  from  the  ReplicationMath  library  which  take  the  invariant  as  an  argument  and  do  not recalculate it.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.20   Implementation of getStableGivenRisky", "body": " Function  The function specification for calculating the stablePerLiquidity do not include the value of the last invariant. However, the function implementation adds the last invariant in the computed stables, therefore resulting in this formula: stablePerLiquidity = K*CDF(CDF^-1(1 - riskyPerLiquidity) -  sigma*sqrt(tau)) + invariantLastX64.  Code corrected  The code comment has been updated correctly.  Primitive Finance - Core Engine -   19  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f6.21   Possible Gas Optimization in the Deposit Function  The function deposit() in the engine contract allows users to deposit a single token to their margin account, therefore the function calls the balanceof() function only for the token with a positive delta. However,  after  the  callback  function  for  the  transfer  executes,  the  function  checks  the  balance  of  both tokens  (performs  two  balanceOf()  calls).  The  function  can  optimize  the  gas  consumption  again  by calling the balanceOf() only for the token added.  Code corrected  The updated version of the function deposit() now checks if the delta value is greater than 0 before reading the balance (before and after the transfer) for the stable and the risky tokens.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.22   Return Value in safeTransfer", "body": "  The function safeTransfer() in the library Transfers checks if an ERC20 token transfer completed successfully, otherwise the function reverts. Currently, the function returns a boolean value but it is never checked in the caller functions.  Code corrected  The return value in safeTransfer() has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "6.23   MANTISSA_INT Constant", "body": "  MANTISSA_INT is a constant defined in units library and its value in 64x64 format corresponds to 10x the value of the constant variable Mantissa in units library.  Code corrected  The unused MANTISSA_INT has been removed.  Primitive Finance - Core Engine -   20  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                      \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "7.1   Engine Shall Not Have Privileges in Other", "body": " Smart Contracts  With  the  current  setup,  for  security  reasons,  the  engine  contract  must  not  have  privileges  in  any  other smart contracts. The main reason is that the engine contract supports several callbacks which potentially could have the same function signature as a sensitive function in the contract being called.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "7.2   Limited Supported Token Pairs", "body": "  PrimitiveFactory  contract  deploys  a  unique  PrimitiveEngine  contract  for  a  pair  of  ERC20  tokens.  The function deploy() takes as arguments the addresses of the two ERC20 tokens and assumes that they  are  implemented  correctly  and  behave  as  expected.  The  function  deploy  checks  only  if  the provided  addresses  of  the  risky  token  and  the  stable  one  are  not  the  same  and  that  they  are  different from address(0).  Technically,  it  is  possible  to  deploy  a  PrimitiveEngine  with  any  arbitrary  pair  of  tokens,  such  as: compromised/malicious tokens, two risky tokens, two stable tokens, or with switched addresses for the risky and stable tokens. Therefore, the filtering of the bad or malicious engines and their respective pools should  happen  on  the  application  level  (outside  the  audited  smart  contracts)  in  order  to  protect  users from interacting with incorrect engines.  We explicitly mention that the contract ONLY works with standard ERC20 tokens that do not have any unusual  behavior  like  inflation,  deflation,  locking,  fees,  two  addresses  etc.  Users  needs  to  carefully evaluate if the pool's token fulfill the requirements!  A check in the factory before deploying the engine might at least prevent accidentally adding a token with unsupported decimals.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "7.3   More Testing for CDF", "body": "  The correctness of the cumulative normal distribution function and its inverse function are important for the whole protocol. The functions getCDF() and getInverseCDF() ensure that the pool maintains the correct values of stable and risky tokens at any time. Both functions compute approximate values and the current  testing  shows  that  the  error  falls  below  a  chosen  threshold.  However,  the  code  calls  these (refer  functions  to getRiskyGivenStable()  and  getStableGivenRisky()  is  highly recommended to expand the testing for checking how the combine error changes when the functions are called as in the above example.  getCDF(getInverseCDF(x)   volatility)   functions),   therefore   pattern   the   +   in   it   Primitive Finance - Core Engine -   21  NoteVersion1NoteVersion1NoteVersion1            \f7.4   Oracle Usage  In case any project uses the current marginal prices as oracles, the oracle price would be an easy target to price manipulation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "7.5   Stuck Funds", "body": "  When the PrimitiveEngine contract calls callbacks from other contracts to make a token transfer, the engine  only  checks  that  its  token  balance  increased  by  a  value  equal  or  greater  than  an  expected amount. Afterwards, the engine updates the reserve balances with the expected amount. However, if the external  contract  transfers  more  token  than  expected,  the  difference  (tokens  transferred  -  expected tokens)  are  locked  in  the  engine  contract  and  neither  pools,  nor  liquidity  providers  can  access  them. Below is a code example from the function create():  if (balanceRisky() < delRisky + balRisky) revert RiskyBalanceError(delRisky + balRisky, balanceRisky()); if (balanceStable() < delStable + balStable) revert StableBalanceError(delStable + balStable, balanceStable());  Funds can also be locked during liquidity allocation if either delRisky or delStable does not match the delLiquidity that the user intents to allocate. The function allocate() computes the respective delta liquidities for both tokens (risky and stable) and rewards the smallest delta liquidity to the user. The code is shown below:  uint256 liquidity0 = (delRisky * reserve.liquidity) / uint256(reserve.reserveRisky); uint256 liquidity1 = (delStable * reserve.liquidity) / uint256(reserve.reserveStable); delLiquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1; ... liquidity[recipient][poolId] += delLiquidity; // increase position liquidity  The same is true for all other funds that are accidentally send to the contract or intentionally forced into the contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "7.6   Timestamp Conversion Limit", "body": "  The  _blockTimestamp  function  converts  the  block.timestamp  from  a  uint256  to  a  uint32. Hence, limiting the maximum value for the timestamp to Sunday, February 7, 2106. This is in 84 years. The contract will have issues in case it is used this long at that point in time.  Primitive Finance - Core Engine -   22  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/primitive-finance-core-engine-smart-contracts/"}, {"title": "5.1   execute() Gas Calculation Can Underflow", "body": "  In  AccountImplementation,  execute()  subtracts  5000  from  gas()  using  assembly  subtraction.  If gas() is less than 5000, this will underflow and wrap around to a very high value.  The solidity overflow checks are disabled when using assembly, so this will not revert.  Risk accepted  Oasis accepts the risk of this underflow occurring and states that under normal use this will not happen, as the proxy is intended for state-changing operations and hence the delegate call should never cost less than 5000 gas to execute.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "5.2   Inefficient Boolean Mappings", "body": "  The AccountGuard has the following mappings:  mapping(address => mapping(address => bool)) private allowed; mapping(address => mapping(bool => bool)) private whitelisted;  Oasis - PositionManager -   10  DesignCorrectnessCriticalHighMediumRiskAcceptedLowCodePartiallyCorrectedAcknowledgedAcknowledgedCodePartiallyCorrectedAcknowledgedCodePartiallyCorrectedRiskAcceptedCodePartiallyCorrectedAcknowledgedCorrectnessMediumVersion1RiskAcceptedDesignLowVersion2CodePartiallyCorrectedAcknowledged                              \fMappings  that  contain  boolean  variables  are  inefficient  in  general,  as  the  Solidity  compiler  masks  the values when saving and loading these values from storage to prevent dirty bits from contaminating the values.  For  the  whitelisted  mapping,  there  is  a  superfluous  level  of  indirection.  The  (bool  =>  bool) mapping  could  be  replaced  by  a  different  type,  e.g.  an  enum  or  an  integer,  which  would  reduce  the number of SLOADs needed to retrieve an entry. Alternatively, two separate mappings could be used for the two whitelists.  Code partially corrected  The  type  of  the  whitelisted  mapping  was  changed  to  mapping(address  =>  uint8).  The allowed mapping was not modified.  Acknowledged  Note that reading and writing uint8 and bool values to and from storage results in inefficient bytecode, as the Solidity compiler masks the values to ensure no dirty bits are propagated. As there is no possibility of  writing  to  arbitrary  storage  locations,  these  checks  are  superfluous.  Using  mappings  that  store  the uint256 type eliminates these checks. Oasis has acknowledged this inefficiency.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "5.3   External Calls Could Be Avoided", "body": "  In  the  EVM,  external  calls  to  other  contracts  cost  more  gas  than  internal  calls  to  a  contract's  own functions.  The  AccountFactory  makes  external  calls  to  AccountGuard.  Both  contracts  are  dependent  on  one another - they need to know each other's addresses in order to set the owners of newly created proxies. This introduces a circular dependency.  As neither contract is upgradeable and neither contract allows setting a new address for the other, the increased gas cost and circular dependency could be avoided by combining both contracts' functions into a single contract. This also allows for the removal of some storage variables.  Acknowledged  Oasis has acknowledged the issue.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "5.4   Function Arguments Can Be In Calldata", "body": "  bytes   The  AccountImplementation.execute() can be in calldata instead of memory in order to save gas.  AccountImplementation.send()   arguments   memory   _data   in   and  Code partially corrected  The _data argument of the send() function was changed to bytes calldata.  Acknowledged  For execute(), Oasis acknowledged the issue and decided not to make code changes.  Oasis - PositionManager -   11  DesignLowVersion1AcknowledgedDesignLowVersion1CodePartiallyCorrectedAcknowledged                  \f5.5   Inefficiencies in execute()  The execute() function in AccountImplementation has multiple inefficiencies:   Only gas() - 5000 gas is passed to the delegate call. This may force users to attach more gas than  needed  to  their  calls.  While  it  does  guarantee  that  the  remaining  operations  after  the delegatecall  will  complete,  it  also  makes  it  more  likely  for  the  delegatecall  to  run  out  of  gas.  It  is simpler to just attach all the gas to the call and assume it returns before consuming all the gas.   execute() only returns 32 bytes of return data from the delegate call. If any contract that is called  returns more than 32 bytes of data, it will be lost.   The return data is not directly returned in the assembly block, but by the function itself. This means that  it  will  be  copied  before  returning,  which  expands  the  memory  and  costs  more  gas.  Instead,  it could be directly returned in the assembly block using a return call.   The switch condition can be changed to succeeded instead of iszero(succeeded). There is no  reason to invert the condition.  For  an  example  implementation  of  a  similar  function,  see  the  _delegate  function  in  OpenZeppelin's Proxy  contract.  It  allows  returning  more  than  32  bytes  of  data.  Note  that  its  functionality  may  not  be completely identical, so the code should not be directly copied.  Code partially corrected  The  return  data  is  now  directly  returned  in  the  assembly  block.  Additionally,  the  switch  condition  was changed to succeeded, eliminating the extra iszero operation.  The newly introduced line returndatacopy(0, 0, returndatasize()) is used to copy the revert data to memory in case of failure. It is redundant in the success case, as the delegatecall already copies the  first  word  of  returndata  to  memory.  If  the  delegate  call  returns  more  than  32  bytes  of  data,  it  will expand the memory unnecessarily.  Risk accepted  Oasis accepts the risks regarding users being forced to attach too much gas to their calls, and only being able  to  return  the  first  32  bytes  of  return  data.  These  issues  may  reduce  the  ways  in  which  users  can interact with the proxy contract.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "5.6   Various Event Issues", "body": "  Some event parameters are not indexed, even though they might be useful for filtering events.   AccountFactory: The AccountCreated event does not have an indexed proxy address.   AccountGuard: The OwnershipTransfered event does not have an indexed newOwner address.  The  OwnershipTransfered  event  is  very  similarly  named  to  the  OwnershipTransferred  event  which  it inherits from OpenZeppelin's Ownable contract. Consider renaming it so that these two events cannot be confused.  Lastly, the vaultId parameter of the AccountCreated event is confusingly named, as there is no other place in the code which refers to vaults. Renaming this to a more suitable description of the parameter should be considered.  Oasis - PositionManager -   12  DesignLowVersion1CodePartiallyCorrectedRiskAcceptedDesignLowVersion1CodePartiallyCorrectedAcknowledged                    \fCode partially corrected  The indexed keyword has been added to the addresses in the mentioned events.  OwnershipTransfered has been renamed to ProxyOwnershipTransfered.  Acknowledged  The vaultId parameter name is unchanged. The ProxyOwnershipTransfered event has a misspelling, it should be ProxyOwnershipTransferred.  Oasis - PositionManager -   13    \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  0  1  1  12  -Severity Findings  -Severity Findings  ImmutableProxy Is Unnecessary   -Severity Findings   New Owner Cannot Permit   -Severity Findings   AccountGuard Variable Could Be Immutable    Checking Conditions in AccountImplementation    Execute Does Not Forward Revert Reason    Floating Compiler and Dependency Versions    Function Visibility Can Save Gas   Incorrect Error Messages   Increment Can Be Done in Event to Save Gas    Missing Sanity Checks    Redundant Initializations    Separate Whitelists    Unnecessary Checks    Unused Imports   ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "6.1   ImmutableProxy Is Unnecessary", "body": "  The  ImmutableProxy  is  designed  as  a  small  proxy  contract  which  delegatecalls  into  a  fixed implementation  address.  Except  for  the  implementation()  getter,  its  functionality  is  identical  to  the minimal proxy contract described in EIP1167.  OpenZeppelin's Clones library, which is used to deploy clones of the ImmutableProxy contract, deploys clones by using the contract described in EIP1167 - so it simply deploys a contract which delegatecalls the target contract. All in all, this means that we have a minimal proxy, which calls the ImmutableProxy, which then calls the AccountImplementation. This double proxy setup is unnecessary and wastes gas.  Instead, it would be much simpler and cheaper to directly clone the AccountImplementation and discard the ImmutableProxy contract. The minimal proxy contract is hand-written bytecode which is designed to be as cheap as possible both to deploy and execute.  Oasis - PositionManager -   14  CriticalHighCodeCorrectedMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignHighVersion1CodeCorrected           \fCode corrected  The  ImmutableProxy  contract  was  removed.  Instead,  the  Clones  library  is  used  to  directly  clone  the AccountImplementation.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "6.2   New Owner Cannot Permit", "body": "  In  AccountGuard,  when  an  owner  is  initially  set  by  the  factory  they  also  receive  an  entry  in  the allowed[caller][target] mapping. However, when changeOwner() is called, the new owner only receives  an  entry  in  the  owners  mapping  but  is  not  added  to  the  allowed  mapping.  Hence,  the  new owner cannot call permit on the proxy they now own.  Note  that  not  even  someone  else  who  is  allowed  to  permit  on  the  proxy  can  admit  the  owner,  as permitting the owner will revert with \"account-guard/cant-deny-owner\". The only way to allow the new owner would be to transfer ownership to someone else who is already allowed to permit.  The owner would still be able to make transactions from the proxy, as canCall() always returns true for the owner, even if they are not allowed.  Code corrected  changeOwner now adds the new owner to the allowed addresses.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "6.3   AccountGuard Variable Could Be Immutable", "body": "  In  AccountFactory,  the  AccountGuard  variable  is  set  in  the  constructor  and  then  never  changed.  It could be made immutable to be more gas-efficient.  Code corrected  The variable has been made immutable.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "6.4   Checking Conditions in", "body": " AccountImplementation  When calling send() or execute() in the AccountImplementation, the following checks are performed:  1. First, the auth modifier checks that guard.canCall(address(this), msg.sender) returns  true.  2. Next, it is checked that _target != address(0).  3. Lastly, the condition guard.isWhitelisted(_target) is checked.  Here, the AccountGuard contract is called twice to check whether the call should be allowed. These calls could be combined into a single cross-contract call to reduce gas costs.  Assuming that address(0) is never whitelisted, the second check is redundant.  Oasis - PositionManager -   15  CorrectnessMediumVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                        \fNote  also  that  the  same  conditions  are  checked  in  both  cases,  hence  they  could  be  included  into  the auth modifier in order to reduce code duplication.  Code corrected  The  calls  to  AccountGuard  were  combined  into  a  single  call  of  the  new  canCallAndWhitelisted function and moved into the auth modifier. The _target != address(0) check was removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "6.5   Execute Does Not Forward Revert Reason", "body": "  In AccountImplementation, execute() reverts with (0,0) if the delegatecall fails. It does not revert with the revert reason from the delegatecall.  It would be easier for users to debug their reverted transactions if the revert reason contained information from the delegatecall.  Code corrected  The return data is now copied and returned. If the delegatecall fails, the revert reason will be returned.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "6.6   Floating Compiler and Dependency Versions", "body": "  Oasis  uses  the  floating  pragma  solidity  ^0.8.9.  Contracts  should  be  deployed  with  the  same compiler  version  and  flags  that  have  been  used  during  testing  and  audit.  Locking  the  pragma  helps  to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version negatively that  (https://github.com/SmartContractSecurity/SWC-registry/blob/b408709/entries/SWC-103.md).  introduce   contract   system   affect   might   bugs   that   the   In hardhat.config.ts, the compiler version 0.8.17 is specified.  The versions of the contract libraries in package.json are also not fixed. In particular:  \"@openzeppelin/contracts\": \"^4.7.3\"  The caret ^version will accept all future minor and patch versions while fixing the major version. With new versions being pushed to the dependency registry, the compiled smart contracts can change. This may lead to incompatibilities with older compiled contracts. If the imported and parent contracts change the  storage  slot  order  or  change  the  parameter  order,  the  child  contracts  might  have  different  storage slots or different interfaces due to inheritance.  In addition, this can lead to issues when trying to recreate the exact bytecode.  Code corrected  The Solidity compiler version has been specified as exactly 0.8.17 for all contracts in scope.  The OpenZeppelin version has been specified as exactly version 4.7.3 in package.json.  Oasis - PositionManager -   16  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                  \f6.7   Function Visibility Can Save Gas  Reducing a function's visibility from public to external saves gas. The following functions could be defined as external:   AccountFactory.createAccount()   AccountGuard.isWhitelisted()   AccountGuard.setWhitelist()   AccountGuard.initializeFactory()   AccountImplementation.send()   AccountImplementation.execute()   MakerMigrationsActions.migrateMaker()   MakerMigrationsActions.migrateAdditionalVaults()   McdView.getRatio()   McdView.getMakerProxy()  Additionally, the self storage variable in MakerMigrationsActions should not be public, as it only contains the address of the contract itself. Hence, making it private or internal reduces bytecode size as the getter is unnecessary.  Code corrected  The  mentioned  functions  in  AccountGuard,  AccountFactory,  and  AccountImplementation  have  been changed  to  external.  The  visibility  of  the  self  storage  variable  in  MakerMigrationsActions  was changed to private.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "6.8   Incorrect Error Messages", "body": "  The auth modifier in AccountImplementation and the permit() function in AccountGuard both revert with the error message \"account-guard/not-owner\".  However, the owner is actually not the only user that is checked for. In both cases, it is checked whether the msg.sender is the owner OR has been permitted. The error message makes it seem like only the owner is allowed to use these functions.  Also,  migrateAdditionalVaults  the  message \"factory/already-migrated\"  in  case  it  is  called  from  an  address  that  has  not  yet  migrated.  This  error message states the opposite of what actually happened.  in  MakerMigrationsActions   reverts  with   Code corrected  permit()   The  with \"account-guard/no-permit\".  The  revert  message  in  migrateAdditionalVaults  was  also changed.  authandWhitelisted  modifier   function   revert   now   and   Oasis - PositionManager -   17  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f6.9   Increment Can Be Done in Event to Save Gas  In  AccountFactory,  createAccount()  increments  the  accountGlobalCounter  variable.  Later,  it  is emitted in the AccountCreated event. This means it must be loaded from storage twice.  The  accountGlobalCounter  could  be  cached  or  incremented  in  the  event  emission,  which  would save one SLOAD operation and be more gas-efficient.  Code corrected  The value of the counter is now cached after being incremented.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "6.10   Missing Sanity Checks", "body": "  Sanity checks on values are missing in several places. This makes it more likely for incorrect values to accidentally be set.  In  AccountFactory.createAccount(address  user),  address(0).  it   is  possible   for  user   to  be  In  AccountGuard.changeOwner(address  newOwner,  address  target),  it  is  possible  for newOwner to be address(0).  In the AccountImplementation constructor, _guard could be address(0).  In the MakerMigrationsActions constructor, _serviceRegistry could be address(0).  Code corrected  Sanity checks have been added to all mentioned functions.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "6.11   Redundant Initializations", "body": "  Some storage variables are initialized to their default values, which is redundant and wastes gas.  In the AccountFactory constructor, accountsGlobalCounter is initialized to 0.  In AccountGuard, factory is initialized to address(0).  Code corrected  Both redundant initializations were removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "6.12   Separate Whitelists", "body": "  Oasis - PositionManager -   18  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                                    \fThe AccountImplementation allows calls and delegatecalls to any whitelisted contracts. Currently, there is just one whitelist for both cases. However, there may be some contracts that are safe to call but not delegatecall or vice versa.  Code corrected  The  whitelisted  mapping  of  the  AccountGuard  now  contains  a  (bool  =>  bool)  mapping.  This extra bool lookup parameter allows specifying whether a specific address is whitelisted for regular calls, delegatecalls, or both.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "6.13   Unnecessary Checks", "body": "  permit() in AccountGuard has the following check:  if (msg.sender == factory && allowance)  The AccountFactory only has one function that calls permit(). It always calls it with allowance set to true. Hence, just checking for msg.sender == factory is equivalent, as allowance is always true if this holds (unless AccountFactory is changed in the future).  There  are  also  unnecessary  checks  in  send()  and  execute()  in  AccountImplementation,  which  are described in Checking Conditions in AccountImplementation.  These checks can be removed to save gas.  Code corrected  The check for allowance has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "6.14   Unused Imports", "body": "  There are several imported files which are never used:  In AccountFactory:   \"./interfaces/IProxyRegistry.sol\"   \"./interfaces/ManagerLike.sol\"   \"./interfaces/IServiceRegistry.sol\"   \"./utils/Constants.sol\" (AccountFactory inherits from it but no values are used)  In AccountGuard:   \"@openzeppelin/contracts/proxy/Proxy.sol\"  Code corrected  The unused imports were removed.  Oasis - PositionManager -   19  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrected                \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "7.1   Permissions Stay When Changing Owner", "body": "  When  the  changeOwner()  function  of  AccountGuard  is  called,  the  permissions  of  the  old  owner  are revoked.  However,  the  permissions  of  all  other  addresses  are  unaffected.  Any  addresses  that  were permitted by the old owner will still have permissions unless the new owner calls permit() to remove them.  Anyone receiving ownership over a proxy should ensure they trust all permitted addresses before using it.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "7.2   Proxy Storage Layout", "body": "  The  AccountImplementation  allows  delegatecalls  into  arbitrary  whitelisted  contracts.  Such  a  contract could read/write to storage. If two different contracts are delegatecalled that both use the same storage slots, they may conflict with each other and read data written by the other contract.  The AccountGuard owner should keep this in mind when whitelisting contracts. They should either not whitelist  conflicting  contracts  or  explicitly  warn  users  not  to  use  multiple  contracts  that  use  the  same storage from the same proxy.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "7.3   send Function Name Is Confusing", "body": "  The send function of AccountImplementation has a lot more functionality than just sending ETH. It can be used to call arbitrary functions on any whitelisted contract.  This is not obvious from the function name and could be confusing to users.  Oasis - PositionManager -   20  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/oasis-position-manager/"}, {"title": "6.1   MkrNgt Converter Can Be Paused if MKR Is", "body": " Paused  The  MkrNgt  converter  itself  is  permissionless,  however,  if  MKR  token  is  paused,  the  converter  will  be indirectly paused as mint() and burn() will revert on MKR.  MakerDAO - NGT -   10  NoteVersion1  \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/maker-ngt/"}, {"title": "5.1   Funds Can Avoid Paying Protocol Fees", "body": "  Consider a fund that has not enabled autoProtocolFeeSharesBuyback and assume that over time the protocol fee reserve has accrued a sizeable amount of shares of this fund.  The fund, through its manager, can avoid paying protocol fees by employing the following vector:  1. Move  all  assets  of   the CompoundDebtPosition  available  as  an  external  position,  this  means  exchanging  all  of  the vaults holdings into a cToken and transferring it to the external position.  to  an  external  position.  Currently,  with  only   the  vault   2. Remove the external position. Note that, at this point, the GAV of the fund is close to 0.  3. Call buyBackProtocolFeeShares which calculates a really low price per share. This means that only a small amount of MLN tokens needs to be burnt to burn the protocol fee shares and, thus, pay back the fee.  4. Reactivate the external position and move the funds back.  Note that a similar vector can be used by the fund manager to avoid minting protocol fees while migrating or reconfiguration the fund.  The opportunistic behavior of the manager against the users of the fund is well documented. However, adversarial actions against the protocol are not mentioned.  Note that the underlying problem, a manipulated lower GAV due to hiding assets of the fund in a removed external position can also be abused by the fund manager to buy shares for a low price.  Acknowledged:  Avantgarde Finance - Enzyme Protocol v4 Sulu -   11  DesignCorrectnessCriticalHighMediumAcknowledgedLowCodePartiallyCorrectedAcknowledgedAcknowledgedDesignMediumVersion1Acknowledged          \fAvantgarde Finance responded:  As  the  audit  team  importantly  noted,  this  issue  only  potentially  affects  the  protocol  fee  amount ultimately burned, and does not impact end users of the protocol. Hence, rather than changing the core contracts for this release to protect against the reported deviant behavior, we have decided to combine the monitoring of blatant protocol fee violations with potential on- and off-chain penalties.  Deviant  behavior  can  monitored  off-chain  by  comparing  each  shares  buyback  event  with  the  last known share price.  If the Council assesses that there is a blatant attempt to evade protocol fees, it would be possible, for example,  to  restrict  buying  back  shares  by  upgrading  the  ProtocolFeeReserveProxy  contract  to disallow particular funds.  We  can  reevaluate  for  subsequent  releases  whether  or  not  to  prevent  this  behavior  at  the  core protocol level.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-protocol-v4-sulu/"}, {"title": "5.2   Untracked WETH", "body": "  A  fund  owner  can  withdraw  the  Ether  that  has  been  deposited  to  the  paymaster  account  by  calling GasRelayPaymasterLib.withdrawBalance. At this point Ether will be transferred to the vault and wrapped into WETH. However, there is no guarantee that WETH is a tracked asset for the fund.  Code Partially Corrected:  When  ComptrollerLib.shutdownGasRelayPaymaster  is  called,  WETH  is  added  to  the  tracked assets.  Avantgarde Finance responded:  It is highly unlikely that a fund using a paymaster would not have WETH as a tracked asset. Still, we have added a call to track WETH as a tracked asset when shutdownGasRelayPaymaster() is called from the ComptrollerProxy. It is more difficult - and best not - to attempt to validate whether WETH is a tracked asset when calling withdrawBalance() directly from the paymaster lib, since it can be called after a fund has migrated to a new release, at which point, the interface of its new VaultLib should not be assumed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-protocol-v4-sulu/"}, {"title": "5.3   AddressListRegistry Gas Inefficiency", "body": "  AddressListRegistry  stores  ListInfo  using  the  mapping  itemToIsInList.  The  type  of  the mapping is mapping(address => bool). However, it would be more gas efficient to set its type to address => uint256 which omits the masking operation required to handle the boolean values.  Acknowledged:  Avantgarde Finance responded:  We  acknowledge  the  technical  efficiency,  but  in  practice  the  gas  savings  is  insignificant  within  the context of the protocol, and the use of bool is more intuitive.  Avantgarde Finance - Enzyme Protocol v4 Sulu -   12  CorrectnessLowVersion2CodePartiallyCorrectedDesignLowVersion2Acknowledged                  \f5.4   Redundant Check  In FundDeployer.__redeemSharesSetup, the following snippet exists:     } else if (postFeesRedeemerSharesBalance < preFeesRedeemerSharesBalance) {         ...         preFeesRedeemerSharesBalance.sub(postFeesRedeemerSharesBalance)     ); }  Note  case  postFeesRedeemerSharesBalance < preFeesRedeemerSharesBalance.  redundant   that   use   this   the   sub   of   in   is   since   it   holds:  Acknowledged:  Avantgarde Finance responded:  Currently,  we  generally  use  SafeMath  for  math  operations  rather  than  making  judgements  about where or where not to use it.  Avantgarde Finance - Enzyme Protocol v4 Sulu -   13  DesignLowVersion1Acknowledged        \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings  -Severity Findings  -Severity Findings   redeemSharesForSpecificAssets Fails For Derivatives   -Severity Findings  Incorrect redemptionWindowBuffer Check    Shadowed Constant    Missing Indexes in Events   0  0  1  3  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-protocol-v4-sulu/"}, {"title": "6.1   redeemSharesForSpecificAssets Fails For", "body": " Derivatives  In Sulu, users are allowed to redeem specific assets. According to the documentation:  The redeemer specifies one or multiple of the VaultProxy's ERC20 holdings along with the relative values of each to receive (for a total of 100%).  However,  if  an  ERC20  token  which  represents  a  derivative  is  specified  as  a  payout  asset  then  the redemption will fail. The call in __payoutSpecifiedAssetPercentages fails for non primitive assets due  the the  valueInterpreter:  the  calcCanonicalAssetValue  of   require  statement  shown  below   to   in   payoutAmounts_[i] = IValueInterpreter(getValueInterpreter()).calcCanonicalAssetValue(     denominationAssetCopy,     _owedGav.mul(_payoutAssetPercentages[i]).div(ONE_HUNDRED_PERCENT),     _payoutAssets[i] );  function calcCanonicalAssetValue(     ...      require(         isSupportedPrimitiveAsset(_quoteAsset),         \"calcCanonicalAssetValue: Unsupported _quoteAsset\"     );      ...  Note that simply removing the requirement is not enough since the ValueInterpreter can only handle conversions to primitive assets due to the implicit requirement that the quote asset has a Chainlink price feed.  Avantgarde Finance - Enzyme Protocol v4 Sulu -   14  CriticalHighMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCorrectnessMediumVersion1CodeCorrected         \fCode Corrected:  ValueInterpreter.calcCanonicalAssetValue  now  supports  the  conversion  from  a  primative asset  to  a  derivative  asset.  This  is  done  by  calculating  the  price  of  the  derivative  asset  against  the primative one and the inverting.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-protocol-v4-sulu/"}, {"title": "6.2   Incorrect redemptionWindowBuffer Check", "body": "  Certain  actions  through  adapters  e.g.  exchanging  Synths  through  the  Synthetix  adapter  may  block  the transfer of the asset for a period of time. The GuaranteedRedemptionPolicy ensures that a redemption blocking  adapter  is  not  used  during  the  redemption  window  nor  a  buffer  period  before  the  start  of  the guaranteed redemption window. This ensures redemption is possible during a guaranteed time window every day.  uint256 latestRedemptionWindowStart = calcLatestRedemptionWindowStart(         redemptionWindow.startTimestamp     );  // A fund can't trade during its redemption window, nor in the buffer beforehand. // The lower bound is only relevant when the startTimestamp is in the future, // so we check it last. if (     block.timestamp >= latestRedemptionWindowStart.add(redemptionWindow.duration) ||     block.timestamp <= latestRedemptionWindowStart.sub(redemptionWindowBuffer) ) {     return true; } return false;  The comment describing the code is not entirely accurate. Three cases have to be distinguished  I. A fund can't trade during its redemption window  II.a. A fund can't trade in the buffer before the next redemption window  II.b.  If  startTimestamp  is  in  the  future,  a  fund  can't  trade  in  the  buffer  before  the  first  redemption window  Note  that  calcLatestRedemptionWindowStart()  returns  either  the  start  timestamp  of  the  latest redemption window or, in case startTimestamp is still in the future, the startTimestamp.  The  current  code  checks  condition  (I)  and  (IIb)  but  does  not  check  (IIa).  Hence,  in  case  we  are  past startTimestamp and there exists a latestRedemptionWindowStart timestamp in the past, a trade in the buffer window before the start of the next guaranteed redemption period is not prevented and such a trade may prevent redemption in the guaranteed redemption timeframe.  Code Corrected:  In  the  current  implementation,  the  startTimestamp  is  required  to  be  in  the  past.  Moreover,  the redemptionWindowBuffer  is  now  subtracted  from  the  latestRedemptionWindowStart  with  the addition of one day.  Avantgarde Finance - Enzyme Protocol v4 Sulu -   15  CorrectnessLowVersion2CodeCorrected           \fif (     block.timestamp > latestRedemptionWindowStart.add(redemptionWindow.duration) &&     block.timestamp < latestRedemptionWindowStart.add(ONE_DAY).sub(redemptionWindowBuffer) ) {     return true; }  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-protocol-v4-sulu/"}, {"title": "6.3   Shadowed Constant", "body": "  UniswapV2PoolPriceFeed  inherits  UniswapV2PoolTokenValueCalculator.  Both  contracts  define  a constant uint256 private constant POOL_TOKEN_UNIT = 10**18;.  Code Corrected:  The shadowing variable has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-protocol-v4-sulu/"}, {"title": "6.4   Missing Indexes in Events", "body": "  in  ComptrollerLib  could  use  The  PreRedeemSharesHookFailed  event  for address  of the  PreRedeemSharesHookFailed  and  BuyBackMaxProtocolFeeSharesFailed  could  be  indexed since it could facilitate queries for specific errors.  FailureReturnData   redeemer.   Moreover,   indexes   bytes   Code Corrected:  The missing indexes have been added.  Avantgarde Finance - Enzyme Protocol v4 Sulu -   16  DesignLowVersion2CodeCorrectedDesignLowVersion1CodeCorrected                \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-protocol-v4-sulu/"}, {"title": "7.1   Overestimation Of Fund's Value Under", "body": " Pending Liquidation  During  the  calculation  of  the  GAV  of  a  fund,  the  value  of  the  collateral  held  by  an  external  position  is taken into consideration. The calculation takes into account the fact that borrowed amount of an external position is to be returned and, thus, this amount is subtracted from the total collateral held. However, the calculation ignores a potential liquidation.  Assume  an  external  position  that  holds  100  cDAI  and  has  borrowed  75  dollars  worth  of  ETH  with  a collateral factor of 75%. Assume now that the value of ETH has increased so that the external owes 80 dollars.  When  the  GAV  is  calculated  the  external  position  will  be  evaluated  as  100  -  80  =  20  dollars. Since  the  position  is  undercollateralized,  a  liquidation  could  be  triggered.  Note  that  during  liquidations, users are incentivized to pay back the borrowed amount with an 8% discount for the collateral. When the liquidation takes place then the real value of the external position will be roughly 100 - 86.4 = 13.6. Users should be aware of that behavior which might lead to fluctuations in the GAV of the fund. Moreover, the front  end  of  Enzyme  should  indicate  potentially  undercollateralized  external  positions  to  users  prior  to investing.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-protocol-v4-sulu/"}, {"title": "7.2   Reverting Relayed Call Paid By The Fund", "body": "  According  to  the  GSN  protocol,  in  case  GasRelayPaymaster.preRelayedCall  fails  then  the execution is aborted. However, there might be the case where the preRelayedCall succeeds but the relayed  transaction  fails.  In  this  case,  the  fund  will  still  pay  for  the  gas.  An  interesting  case  is  the following.  The  preRelayCall  requires  the  original  _relayRequest.request.from  to  be  an authorised entity for the vault i.e., the owner or an asset manager or a migrator. However, some of the authorised calls allowed by the preRelayedCall further restrict the allowed entities. For example, a call to an integration is limited to only the owner and the asset manager. This means that in case the migrator tries  to  execute  this  function,  the  transaction  will  fail  but  paymaster  will  pay  for  the  gas.  We  assume, however, that the migrator is a trusted role who will not act against the system.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-protocol-v4-sulu/"}, {"title": "7.3   Sandwiching Authorized Actions", "body": "  An authorized user for a fund can use GSN to execute authorized actions. Is important to note that due to the fact that the relayer acts as an intermediary, it is easier for them to sandwich these transactions. For example,  a  relayer  can  sandwich  the  buyBackProtocolFeeShares  and  make  a  profit.  Notice  that when  buying  back  shares  the  value  of  the  shares  increases  since  the  shares  which  correspond  to  the protocol fee are burnt.  Avantgarde Finance - Enzyme Protocol v4 Sulu -   17  NoteVersion1NoteVersion1NoteVersion1          \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/enzyme-protocol-v4-sulu/"}, {"title": "5.1   Unkill Function Allows Claiming After Closing", "body": "  Function unKill(), only callable by the PlatformFactory contract owner, allows to reset isKilled to  false.  If  a  bribe  manager  calls  closeBribe()  while  the  Platform  is  killed,  and  the  platform  is  then unkilled, the bribe becomes claimable again, even though the left over funds have been transferred by closeBribe(). Users can claim their bribes and the funds will be taken from other bribes sharing the same tokens.  Risk accepted  StakeDao accepts the risk but already fixed the issue by removing the unkill function in the latest code version that was not included in the audit.  StakeDao - Bribe Platform -   9  SecurityDesignCorrectnessCriticalHighMediumRiskAcceptedRiskAcceptedRiskAcceptedRiskAcceptedLowAcknowledgedCodePartiallyCorrectedRiskAcceptedRiskAcceptedAcknowledgedAcknowledgedRiskAcceptedSecurityMediumVersion2RiskAccepted              \f5.2   Bribe Manager Can Deny Bribe by Decreasing maxRewardPerVote  The  bribe  manager  can  use  increaseBribeDuration()  to  queue  a  decrease  of maxRewardPerVote to close to 0 just before the start of a claiming period, to rug the expected bribe of users who have already voted.  Risk accepted  StakeDao states that they accept the risk.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-bribe-platform/"}, {"title": "5.3   GaugeController Not Checkpointed Before", "body": " First Period Update  The GaugeController is not checkpointed in _updateRewardPerToken(). If no vote has been cast on the gauge before the first period, _getAdjustedBias() will return 0 instead of the actual value, or might  revert  if  blacklisted  users  cause  an  underflow  to  happen.  This  can  cause  the  reward  to  become unclaimable for some voters.  Risk accepted  StakeDao states:  While it would cause an issue for the first period with old vote users not being able to claim their rewards, it would be solved by the next period with the rolling over.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-bribe-platform/"}, {"title": "5.4   Repeated Addresses in Bribe Blacklist Cause", "body": " Total Bias Under Estimation  in   the  blacklist,   Newly  created  bribes  can  have  repeated  addresses  in  the  blacklist.  If  an  address  is  present  multiple times  in _getAdjustedBias(),  and  the  function  might  return  a  value  smaller  than  the  cumulative  bias  of potential  claimers.  rewardPerToken  can  therefore  be  manipulated  upward  by  inserting  repeated addresses in the blacklist.  its  bias  will  be  deducted  multiple   total  bias   times   from   the   Risk accepted  StakeDao states that they accept the risk.  StakeDao - Bribe Platform -   10  SecurityMediumVersion1RiskAcceptedCorrectnessMediumVersion1RiskAcceptedSecurityMediumVersion1RiskAccepted                        \f5.5   Error Messages and Event Usage  1. In  PlatformFactory,  StakeDao  might  consider  adding  an  event  to  the  state  change  in  setFeeCollector.  2. In Platform, the error messages INVALID_GAUGE is not used.  Acknowldeged  StakeDao acknowledges the issue. No actions are taken.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-bribe-platform/"}, {"title": "5.6   Gas Optimizations", "body": "  1. Double external call to vote_user_slopes in _claim(), at line 385 - 387  2. The  function  getActivePeriod  is  redundant  since  activePeriod  is  already  public  and  will  implicitly define an external getter  3. _updateRewardPerToken  calls  getCurrentPeriod  which  was  in  both  execution  flows  called  right before in the parent function  4. getPeriodsLeft and getActivePeriodPerBribe copy the entire Bribe struct from storage to memory, but only use 2 of the fields from the struct. This causes unnecessary SLOAD operations to be performed, at a cost that scales linearly with the size of the blacklist.  Code partially corrected  getCurrentPeriod() is now only called once. The two other potential optimizations were not applied.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-bribe-platform/"}, {"title": "5.7   Incorrect User Bias Calculation", "body": "  The  internal  _getAddrBias()  function  returns  0  if  currentPeriod  +  _WEEK  >=  endLockTime. However, as long as endLockTime is bigger than currentPeriod the user has voting power. Indeed, in its time progression, a user bias will incorrectly go from slope * 3 * WEEK to slope * 2 * WEEK to 0 while skipping slope * 1 * WEEK.  Risk accepted  StakeDao is aware of the issue but decided to accept the risk and leave the code as it is.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-bribe-platform/"}, {"title": "5.8   Missing Sanity Checks", "body": "  The following arguments are not checked or are insufficiently checked if they make sense:  StakeDao - Bribe Platform -   11  DesignLowVersion1AcknowledgedDesignLowVersion1CodePartiallyCorrectedCorrectnessLowVersion1RiskAcceptedDesignLowVersion1RiskAccepted                              \fIn  Platform.createBribe  the  variable  manager  (address  zero  check),  maxRewardPerVote (zero  check)  and  a  check  for  rewardPerPeriod  as  it  could  be  zero  after  the  division  with numberOfPeriods  In Platform.updateManager there is no sanity check for address zero  In Platform._claim() it is not checked that the bribe exists  In  PlatformFactory  setting  the  fee  collector  and  transferring  the  owner  are  not  checked  for address zero  Risk accepted  StakeDao states that they accept the risk.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-bribe-platform/"}, {"title": "5.9   Naming Issues, NatSpec Missings, Incorrect", "body": " Comments, Typos  In Platform.sol:  1. line 104, missing @notice for Upgrade struct  2. line 126, incorrect grammar: Minimum duration a Bribe  3. line  158,  rewardPerToken  naming  is  ambiguous,  the  variable  value  is  better  understood  as  the  reward per vote not the reward per token.  4. line 254, Target bias for the gauge, incorrect NatSpec on parameter maxRewardPerVote  5. In createBribe() NatSpec, missing parameters upgradeable and manager.  6. line 503: comment says called once per Bribe, however the function is called multiple times  on the first period, but the condition is only true on first call.  7. line 640: _additionnalPeriods declaration contains a typo  8. getActivePeriod  and  getActivePeriodPerBribe  are  named  ambiguously,  they  do  very  different things but share almost the same name  Acknowldeged  StakeDao acknowledges the issue. No actions are taken.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-bribe-platform/"}, {"title": "5.10   Unused Imports", "body": "  The contract PlatformFactory imports ERC20 but does not use it.  Acknowldeged  StakeDao acknowledges the issue. No actions are taken.  StakeDao - Bribe Platform -   12  DesignLowVersion1AcknowledgedDesignLowVersion1Acknowledged                    \f5.11   safeTransfer Functions Do Not Check Contract Existence  The safeTransfer and safeTransferFrom functions of solmate's safeTransferLib do not check that the token contract actually exists. If called with a token address that doesn't contain code, the calls will succeed  even  if  no  transfer  is  performed.  This  could  be  an  issue  when  a  token  will  be  deployed  at  a predictable address.  Risk accepted  StakeDao states that they accept the risk.  StakeDao - Bribe Platform -   13  SecurityLowVersion1RiskAccepted          \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings   Adjusted Bias Measured Possibly Too Late   -Severity Findings   Queued Upgrade Still Taken in Account After Closing Bribe   -Severity Findings   closeBribe Does Not Refund Tokens Added in Upgrade   -Severity Findings  1  1  1  0  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-bribe-platform/"}, {"title": "6.1   Adjusted Bias Measured Possibly Too Late", "body": "  The  amount  of  excluded  votes  belonging  to  the  users  in  the  blacklist  are  counted  by  the  internal function  _getAdjustedBias  for  the  recently  concluded  period  when  _updateBribePeriod()  is called. However, the period update only happens when users interact with the contract. Between the start of  the  new  voting  period  (timestamp  /  WEEK  *  WEEK)  and  the  time  _updateBribePeriod()  is called,  a  blacklist  user  can  cast  a  new  vote  on  the  gauge,  which  is  incorrectly  counted  by ``_getAdjustedBias() as belonging to the previous period.  rewardPerToken at period T is computed as  rewardPerToken(T) = rewardPerPeriod / (total_bias(T) - omitted_reward(T_blacklisted_last_vote))  So the periods of total_bias and omitted_reward might not match.  Since the bribe creator has full control on who to include in the blacklist and what gauge to set the bribe on, they can make rewardPerToken as high as they desire by making the denominator arbitrarily small that with  bribe.totalRewardAmount is not exceeded when distributing the reward, a dishonest bribe creator can use this bug to steal funds from other bribes.  control.  Since  _claim()   blacklisted   doesn't   check   user   they   that   a   Code corrected  A  check  has  been  added  so  that  subtracting  the  bias  of  a  blacklisted  user  is  only  performed  if  the blacklisted user has voted before the start of the period. Otherwise bias is not deducted and rewarded users get a bit less.  _lastVote = gaugeController.last_user_vote(_addressesBlacklisted[i], gauge); if (period > _lastVote) {     _bias = _getAddrBias(userSlope.slope, userSlope.end, period);     gaugeBias -= _bias; }  StakeDao - Bribe Platform -   14  CriticalCodeCorrectedHighCodeCorrectedMediumCodeCorrectedLowSecurityCriticalVersion1CodeCorrected        \fA  check  is  also  bribe.totalRewardAmount.  introduced  so   that   the  cumulative  bribe  payout  never  exceeds   the  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-bribe-platform/"}, {"title": "6.2   Queued Upgrade Still Taken in Account After", "body": " Closing Bribe  A queued upgrade for a bribe can still be taken in account after the manager has closed the bribe with closeBribe. If it is the case, then part of the following rewards distributed are stolen from other bribes.  Once  the  bribe  is  closed  by  the  manager,  claiming  again  will  update  the  bribe  and  reset  the endTimestamp in the future, without taking in account the totalRewardAmount - amountClaimed amount withdrew by the manager.  Using this attack to steal all the funds of the contract is possible with no risks, but would necessitate at least the same amount of tokens that the attacker wants to steal and being able to lock them for multiple weeks.  Code corrected  The upgrade is now deleted from the queue when closeBribe() is called.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-bribe-platform/"}, {"title": "6.3   closeBribe Does Not Refund Tokens Added in", "body": " Upgrade  When a bribe is closed while an upgrade is queued, the unclaimed amount will be refunded to the bribe manager, but not the additional _increasedAmount added in the queued upgrade.  Code corrected  During  the  closing  of  a  bribe,  if  there  is  an  upgrade  in  the  queue,  instead  of  transferring  back total reward amount - amount claimed, the total amount after the upgrade is used.  StakeDao - Bribe Platform -   15  SecurityHighVersion1CodeCorrectedDesignMediumVersion1CodeCorrected                \f7   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-bribe-platform/"}, {"title": "7.1   Interface Definitions", "body": "  To indicate a file is an interface, the naming convention is to prepend an I to the file name. The interface SmartWalletChecker and VeToken is for test purposes only. Interfaces used only for test purposes are usually separated into test folders.  The following interfaces are defined but not used:  GaugeController:  In  gauge_relative_weight_write,  get_total_weight, get_gauge_weight, add_type (only in tests), admin.  gauge_relative_weight,   add_gauge   tests),   (only   for   WEIGHT_VOTE_DELAY, gauge_relative_weight,  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-bribe-platform/"}, {"title": "7.2   claimable() Might Return Incorrect Values", "body": "  Due  to  the  nature  of  view  functions  not  being  able  to  change  state,  the  claimable()  view  function doesn't  checkpoint  the  gauge  nor  it  updates  the  period,  so  the  value  it  returns  could  be  invalid.  This should be made clear in the natspec.  StakeDao - Bribe Platform -   16  NoteVersion1NoteVersion1      \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/stakedao-bribe-platform/"}, {"title": "5.1   Some CryptoSwap Pools Do Not Implement", "body": " the lp_price() Function  Not every CryptoSwap pool of the Curve protocol implements the lp_price() function that is used in the CurveNPAPTokensPriceProvider. The only exception that was added is the tricrypto2.  Acknowledged:  Silo Finance replied:  We will implement them if we need it. For now we need only tricrypto2.  Silo Finance - Curve & Convex Feature -   11  SecurityDesignCorrectnessCriticalHighMediumLowAcknowledgedCorrectnessLowVersion1Acknowledged             \f6   Resolved Findings  Here, we list findings that have been resolved during the course of the engagement. Their categories are explained in the Findings section.  Below we provide a numerical overview of the identified findings, split up by their severity.  -Severity Findings   Curve LP Oracle Is Vulnerable to Read-Only Reentrancy Attacks    CurvePriveProvider Uses the Spot Price   -Severity Findings   Collateral Token Transfers Are Not Taken Into Account   -Severity Findings   Missing Shutdown Logic   -Severity Findings   A Metapool Could Have More Than One Nested LP Token    Metapool Setup Recursion Lacks Sanity Check    Metapools With Two LP Underlying    Missing Events for State Modifying Actions    The Reward Integral Computation Can Overflow   IWrapperDepositor Not Implemented   2  1  1  6  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "6.1   Curve LP Oracle Is Vulnerable to Read-Only", "body": " Reentrancy Attacks  The Curve LP oracle smart contracts can be manipulated by using the read-only reentrancy vulnerability. This is because no checks are done regarding the reentrant state of the curve pool. For further details please see our blog post: https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/.    A protection mechanism has been implemented.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "6.2   CurvePriveProvider Uses the Spot Price", "body": "  The  CurvePriceProvider  smart  contract  uses  the  spot  price  of  the  curve  pool  to  get  the  price  of assets. This is done by calling the get_dy() function on the curve pool.  Silo Finance - Curve & Convex Feature -   12  CriticalCodeCorrectedCodeCorrectedHighCodeCorrectedMediumCodeCorrectedLowCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedCodeCorrectedDesignCriticalVersion1CodeCorrectedSecurityCriticalVersion1CodeCorrected                 \fHence, an attacker could easily manipulate the price with a flash loan or a lot of liquidity. If this oracle is used  as  a  source  of  truth  for  a  borrowing  or  liquidation  mechanism,  funds  could  be  stolen  from  the protocol.  Further note, that also the IPriceProvider's NatSpec is not accurate in that case as it specifies that the TWAP is calculated.  Code removed:  All related code has been removed. Curve is not used as a price provider anymore.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "6.3   Collateral Token Transfers Are Not Taken Into", "body": " Account  The balance used for payouts is the sum of the ERC-20 balance and the user's Silo collateral-only shares (converted to the ERC-20). Hence, each change in one of these balances must ensure the correctness of payouts. While the ConvexStakingWrapperSilo contract performs reward checkpointing for each ERC-20 balance change, the integration with the Silo fails to integrate such checkpoint fully, thus allowing both theft and loss of rewards.  A lack of checkpointing is present   When  a  user  transfers  the  collateral  tokens:  Transferring  collateral  tokens  does  not  trigger  any  checkpointing.   When a user uses the depositFor() function in the silo: The checkpointing will be done for the  transfer, however, minting collateral tokens will not checkpoint for the recipient.   When a user is being liquidated: The liquidated user will not be involved in checkpointing and loses  his rewards. The liquidator does not receive the rewards as a liquidation bonus.   When a user uses the router to withdraw the collateral: The router will be checkpointed. The user will  temporarily get a smaller balance accounted which will lead to unfair checkpointing for the user.  Most  notably,  the  collateral  token  transfers  would  allow  for  a  simple  attack  by  transferring  collateral tokens from address to address to claim rewards with each.  Further,  note  that  the  function  syncSilo()  could  change  the  silo  which  is  used  for  additional accounting. However, that could break the contract and unfairly distribute rewards.  To summarize, collateral token transfers do not checkpoint and transfers of tokens between the silo and a user, who was not the prior owner of these tokens, update the rewards only for the receiver.    Silo  Finance  has  added  a  Silo  type  called  SiloConvex  which  updates  reward  for  concerned  users before  any  actions.  Router,  current  silo  and  deprecated  silos  cannot  be  checkpointed  for  rewards anymore.  Further,  ShareCollateralTokenConvex  has  been  introduced  that  checkpoints  before  any  direct transfer between users.  Note that when the collateralVault variable is updated through syncSilo(), some rewards could still be lost, but this is now part of the specification.  Silo Finance - Curve & Convex Feature -   13  CorrectnessHighVersion1CodeCorrected          \f6.4   Missing Shutdown Logic  Each ConvexStakingWrapper smart contract can be shut down by the owner so that accounting of the rewards  stops  and  users  are  only  able  to  withdraw  their  shares  of  the  pool.  Rewards  will  not  be accounted  for  anymore  when  moving  wrapped  tokens  around  because  the  _checkpoint()  function does not apply any logic when the isShutdown flag is set to true.  However, the _checkpointAndClaim() function does not have any such check for the flag, meaning that  users  are  still  able  to  claim  their  rewards  after  the  shutdown.  Users  could  also  still  transfer  the wrapped tokens without the wrapper checkpointing it so an attacker could manipulate its balance to steal some rewards.    Both functions now implement the shutdown logic.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "6.5   A Metapool Could Have More Than One", "body": " Nested LP Token  The CurvePAPTokensPriceProvider retrieves all the underlying tokens for the LP token. For meta pools, the underlying LP token's coins are retrieved.  However, when the nested depth is equal to or greater than 2, it directly tries to fetch the price of the last lp token instead of continuing to fetch the underlying tokens.    Code  now  correctly  fetches  all  nested  tokens  recursively.  Note  that  if  the  total  amount  of  underlying tokens exceeds eight, the code will revert which is expected.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "6.6   Metapool Setup Recursion Lacks Sanity", "body": " Check  Metapools are StableSwap pools where at least one underlying is a Curve LP token. To set up such a metapool LP token, setupAsset() in CurvePAPTokensPriceProvider recursively sets up all underlying LP tokens. However, the recursive iterations of _setUp() lack the _MIN_COINS sanity check and the LPTokenEnabled event emission.  Code Corrected:  The  check  and  the  event  emission  are  now  in  the  _setUp()  function  which  is  used  for  recursively iterating over the potentially nested LP tokens.  Silo Finance - Curve & Convex Feature -   14  DesignMediumVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                        \f6.7   Metapools With Two LP Underlying  Note that Metapools can have only one LP underlying. However, the current design would allow for bad pools with two LP tokens as underlyings - one as a regular coin and one as the base asset.    The code now reverts if there are two lp underlyings.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "6.8   Missing Events for State Modifying Actions", "body": "  In ConvexStakingWrapper, some important state-modifying actions do not trigger events:   Shutting down a staking wrapper   Adding a reward token   Setting the hook   Checkpointing users  Emitting events could ease following the state of the contract.    Events have been added for all of the above.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "6.9   The Reward Integral Computation Can", "body": " Overflow  ConvexStakingWrapper  uses  solidity  0.6.12  which  can  overflow  on  arithmetic  operations.  The staking wrapper uses a variable called reward_integral to track each token reward by increasing it proportionally to the received rewards. Note that this variable should only be able to increase.  At line 275, it computes it in such a way:  reward.reward_integral = reward.reward_integral + uint128(bal.sub(reward.reward_remaining).mul(1e20).div(_supply));  The  addition  here  can  overflow  to  a  decrease  of reward_integral. A decrease in the variable would mean that some users would have their rewards locked forever in the smart contract.  in  some  conditions,  which  would   lead   Also  note  that  the  truncation  to  a  uint128  in  the  second  part  of  the  code  line  can  also  lead  to  a truncation overflow, which would miscompute the received rewards.  While the supply is low, the overflow can be triggered very easily. Using this capability, an attacker could grieve users from receiving rewards by pushing the users' reward integrals to the maximum so that the global reward integral cannot exceed the users' reward integral.  Silo Finance - Curve & Convex Feature -   15  DesignLowVersion1CodeCorrectedDesignLowVersion1CodeCorrectedCorrectnessLowVersion1CodeCorrected                      \f  The reward variables are now stored as uint256.  Silo Finance noted:  Contract is updated to store the rewards integral in 256 bits variables. This fix makes the integral overflow improbable for regular reward tokens, even if the total supply of the wrapped token is 1 wei.  Here  reward_integral  could  still  overflow  but  as  stated  by  Silo  Finance,  it  is  much  less  probable given that reward tokens should not be of very low value or with unusually high decimals.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "6.10   IWrapperDepositor Not Implemented", "body": "  Most  of  the  contracts  interact  with  each  other  based  on  the  interface  definitions.  However,  the ConvexStakingWrapperSilo contract itself does not implement the IWrapperDepositor. Without this,  there  are  no  compile-time  guarantees  that  the  contract  will  be  compatible  with  the  calls  to  the functions that the interface defines. This can lead to potential runtime errors and exceptions that are hard to debug. Explicitly defining that a contract implements an interface could minimize such errors.    ConvexSiloWrapper now implements IConvexSiloWrapper.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "6.11   A Collateral-Only Silo Can Have Its ", "body": " siloAsset Borrowed  During the audit, we uncovered that a silo with a collateral-only asset could still have this asset borrowed. More specifically, this can happen when tokens are sent directly to the silo. The collateral-only funds are not affected but the specification is violated.  /// @notice Modification of the Silo where a siloAsset can be deposited /// only as collateral only asset and can't be borrowed.    if (_isSiloAsset(_asset)) revert(); has been added to borrow() and borrowFor() in the specialized Silos for Curve and Convex. However, note that the exact mechanics are out of scope, and if there is alternative way to borrow, the issue could still persist.  Silo Finance - Curve & Convex Feature -   16  DesignLowVersion1CodeCorrectedInformationalVersion1CodeCorrected                \f6.12   Missing NatSpec  Most functions are provided with documentation. However, CurvePriceProviderETH does not have any  NatSpec  for ICurvePriceProvider's  getAssetPool()  and  isAssetPoolUint256()  functions.  Also, _getDy() in the CurvePriceProvider is not fully documented.  for  NULL_ADDRESS,  WETH  and  _getCoin().  Further,  NatSpec   lacks     The files have been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "6.13   Usage of registryId", "body": "  Pool.registryId is never used.    Silo Finance removed the registryId as it was unused.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "6.14   Variables Visibility", "body": "  In  CurveLPTokenDetailsBaseCache,  coins  is  public  and  has  hence  an  automatic  getter. However, getCoins() has the same behavior as the automatic getter and thus there is a double getter for the elements.  In CurvePriceProvider, NOT_FOUND_INDEX is public. However, it is only used for protocol internal logic.    getCoins() was removed. Hence, coins() remains the only public getter.  CurvePriceProvider has been removed.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "6.15   isMeta for Crypto Pools", "body": "  The isMeta flag is present for Curve crypto pools. However, note that these pools are not meta pools. The CurveCryptoSwapRegistryFetcher can set it to true. However, it has no effect.    Client added a sanity check to ensure the validity of the pools data returned by fetchers.  Silo Finance - Curve & Convex Feature -   17  InformationalVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrectedInformationalVersion1CodeCorrected                      \f7   Informational  We  utilize  this  section  to  point  out  informational  findings  that  are  less  severe  than  issues.  These informational issues allow us to point out more theoretical findings. Their explanation hopefully improves the overall understanding of the project's security. Furthermore, we point out findings which are unrelated to security.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "7.1   Balancer Oracles Are Deprecated", "body": "  During  the  audit  we  discovered  that  the  protocol  uses  the  Balancer  V2  oracles.  However,  note  that their  oracles  here:  https://docs.balancer.fi/products/oracles Balancer  discourages  (snapshot).  the  usage  of   Acknowledged:  Silo Finance replied:  The Silo team is aware of this  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "7.2   Code With No Effects", "body": "  The ConvexStakingWrapper smart contract contains code without any real effects.  On line 215:  if(registeredRewards[_token] == 0){         ... }else{         uint256 index = registeredRewards[_token];         if(index > 0){...} }  The second if will always be executed as index will always be greater than 0.  On lines 167, 169, 210: Token transfers to self has no effect.  Acknowledged:  Silo Finance replied:  We decided to make minimal changes in external contracts that we inherit. Refactoring is out of scope of this feature.  Silo Finance - Curve & Convex Feature -   18  InformationalVersion1AcknowledgedInformationalVersion1Acknowledged            \f7.3   Commented Code  The following comment contains a line of commented-out code.  // collateralVault = _vault;  Removing the line could improve readability.  Acknowledged:  Silo Finance replied:  We decided to make minimal changes in external contracts that we inherit. Refactoring is out of scope of this feature.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "7.4   Gas Inefficiencies", "body": "  The staking wrapper for convex contains several gas inefficiencies. The following is an incomplete list of examples:   More state variables could be constants and immutables.   \"Double-initialization\" performs some storage writes twice (e.g. setting the owner)   When adding rewards, the rewards length is always read from storage.   registeredRewards is read twice in the else branch of addTokenReward().   _calcRewardIntegral reads variables multiple times from storage (e.g. reward_remaining)  Acknowledged:  Silo Finance replied:  We decided to make minimal changes in external contracts that we inherit. Gas optimization in external contracts is out of scope of this feature.  Silo Finance - Curve & Convex Feature -   19  InformationalVersion1AcknowledgedInformationalVersion1Acknowledged          \f8   Notes  We  leverage  this  section  to  highlight  further  findings  that  are  not  necessarily  issues.  The  mentioned topics  serve  to  clarify  or  support  the  report,  but  do  not  require  an  immediate  modification  inside  the project. Instead, they should raise awareness in order to improve the overall understanding.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "8.1   Collateral-only Assets", "body": "  Neither  the  Curve  LP  tokens  nor  the  wrapped  Convex  tokens  are  suitable  for  borrowing  due  to  their prices  being  easily  but  legitimately  pushed  upwards.  Hence,  the  tokens  are  only  suitable  as  collateral assets.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "8.2   Convex DOS Potential", "body": "  In the convex staking wrapper contract, checkpointing could iterate over many tokens. If Convex adds too many reward tokens, the checkpointing could be DOSed. While Convex is trusted in that sense, users should be aware of such a possibility.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "8.3   Duplicate Tokens Undervalue Estimation of", "body": " Rewards  In  the  ConvexStakingWrapper  smart  contract,  extra  reward  tokens  are  queried  from  the  convex reward pool and can also be added manually by the owner.  If there is a case of a pool that receives rewards of the same token from two different reward pools, then only  one  of  these  will  be  queried  with  the  earned()  to  estimate  the  rewards  for  this  token  in  the earnedView() function of the staking wrapper, leading to low reward estimations.  Further  note  that  any  reward  token  that  has  no  reward_pool  associated  will  have  its  rewards undervalued in the view functions. However, note that Convex is not expected to behave in such a way.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "8.4   Function Interface Is Not Validated", "body": "  In  CurvePriceProvider,  the  manager  must  provide  a  GET_DY_INTERFACE  enum  due  to  the interfaces of the get_dy() function being different across curve pools. However, this enum is not sanity checked while most other set-up arguments are and a pool with the wrong interface could be saved to storage.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "8.5   Oracle Manipulation", "body": "  Silo Finance - Curve & Convex Feature -   20  NoteVersion1NoteVersion1NoteVersion1NoteVersion1NoteVersion1                  \fNote  that  any  on-chain  oracle  is  manipulatable  to  some  degree.  Hence,  the  prices  of  assets  could  be manipulable to some extent.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "8.6   Read-only Reentrancy Protection", "body": "  Users and Silo Finance should be careful when the gas costs of opcodes change in new hardforks as this could lead to breaking changes. Hence, this should be monitored. Further, the selection of parameters should be carried out with gas measurements on the pools since different Vyper versions and pools may need to different parameters.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "8.7   The Curve LP Oracles Fetch the Minimum", "body": " Price  The  Curve  lp  oracles  will  fetch  a  price  that  is  a  lower  bound  on  the  LP  token  price.  When  used  as  a collateral, users should know that this is the case and be extra careful to avoid unnecessary liquidations.  ", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}, {"title": "8.8   Unsupported Reward Tokens", "body": "  Users  should  be  aware  that  reward  tokens  that  can  change  the  amount  differently  from  the  amount transferred could unfairly distribute rewards and could break the contract.  Especially,  rebasing  tokens  could  break  the  contract  if  a  rebase  downwards  occurs.  Further,  reward tokens with transfer fees could create problems.  Silo Finance - Curve & Convex Feature -   21  NoteVersion1NoteVersion1NoteVersion1            \f", "labels": ["ChainSecurity"], "html_url": "https://chainsecurity.com/security-audit/silo-finance-curve-convex-feature/"}]