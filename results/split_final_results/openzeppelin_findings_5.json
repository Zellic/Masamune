[{"title": "Naming suggestions [core and samples]", "body": "To favor explicitness and readability, there are several locations in the contracts that may benefit from better naming. Our suggestions are:  In BaseAccount.sol:  The packSigTimeRange function is internal but is not prefixed with _. Consider renaming to _packSigTimeRange.  In BasePaymaster.sol:  The packSigTimeRange function is internal but is not prefixed with _. Consider renaming to _packSigTimeRange.  In BLSSignatureAggregator.sol:  Consider renaming all instances of hashPublicKey to publicKeyHash for consistency.  In EIP4337Manager.sol:  Consider renaming the local variable _msgSender to msgSender for consistency.  In IAggregator.sol:  Consider renaming the return value of the aggregateSignatures function from aggregatesSignature to aggregatedSignature.  In IEntryPoint.sol:  The ExecutionResult error uses validBefore instead of validUntil. For consistency, consider changing the parameter name to validUntil. The ReturnInfo structs documentation for the validAfter parameter indicates it is inclusive. Consider renaming it to validFrom throughout the entire codebase. In the AggregatorStakeInfo struct, consider renaming actualAggregator to aggregator (also in the comment here).  In SenderCreator.sol:  In the createSender function, consider renaming the initAddress variable to factory to be consistent with the EntryPoint contract.  In SimpleAccount.sol:  In the addDeposit function, consider renaming the req variable to success.  In StakeManager.sol:  internalIncrementDeposit is an internal function that uses internal as its prefix instead of _. Consider changing to _incrementDeposit. The getStakeInfo function is internal but not prefixed with _. Consider renaming the function to _getStakeInfo. Consider renaming the addr parameter of getStakeInfo to account. Consider removing the leading underscore from all instances of _unstakeDelaySec in StakeManager now that there is no longer a storage variable named unstakeDelaySec.  Update: Resolved in pull request #221 and merged at commit 7bd9909.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#naming-suggestions-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent ordering [core and samples]", "body": "The Solidity Style Guide specifies a recommended order for the layout of elements within a contract file in order to facilitate finding declarations grouped together in predictable locations. Within the codebase, this recommendation is not followed in several places:  In BLSAccount.sol: The PublicKeyChanged event is defined between two functions.  In BLSSignatureAggregator.sol: Constant value N is defined between two functions.  In IEntryPoint.sol: Starting at line 70, error and struct definitions are intermingled with function definitions.  In IPaymaster.sol: The PostOpMode enum is defined after all functions.  In SimpleAccount.sol: The _entryPoint variable, SimpleAccountInitialized event, and onlyOwner modifier are defined after several function definitions.  To improve the projects overall legibility, consider standardizing ordering throughout the codebase, as recommended by the Solidity Style Guide.  Update: Partially resolved in pull request #211 and merged at commit ca1b649. In IEntryPoint.sol, the error definitions were relocated but several struct definitions remain defined in between functions.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#inconsistent-ordering-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "Stake size inconsistency [core]", "body": "The StakeManager allows deposits up to the maximum uint112 value, but the stake must be strictly less than the maximum unit112 value. Consider using the same maximum in both cases for consistency.  Update: Resolved in pull request #209 at commit 419b7b0.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#stake-size-inconsistency-[core]", "labels": ["OpenZeppelin"]}, {"title": "TODO comments [core and samples]", "body": "The following instances of TODO comments were found in the codebase:  Line 305 in EntryPoint.sol  Line 52 in EIP4337Manager.sol  Line 57 in TokenPaymaster.sol  TODO comments are more likely to be overlooked and remain unresolved if they are not being tracked formally as issues. Over time, important information regarding the original motivation, plan, and supporting details may be lost. Consider removing all instances of TODO comments and tracking them in the issues backlog instead. Alternatively, consider linking each inline TODO to the corresponding issues backlog entry.  Update: Resolved in pull request #218 and merged at commit 80d5c89. The first example is obsolete. The other two are not TODOs and were changed to Note.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#todo-comments-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors [core and samples]", "body": "Consider addressing the following typographical errors:  In BaseAccount.sol:  Line 70: chain-id should be chain id. Line 76: The an account should be If an account.  In BLSAccount.sol:  Line 9: public-key should be public key in this context. Line 12: a BLS public should be a BLS public key. Line 19: Mutable values slots should be Mutable value slots.  In BLSAccountFactory.sol:  Line 11: Based n should be Based on. Line 27: public-key should be public key in this context.  In BLSHelper.sol:  Line 32: (x2 y2, z2) should be (x2, y2, z2).  Line 137: Doubles a points should be Doubles a point.  In BLSSignatureAggregator.sol:  Line 34: to short should be too short. Line 89: public-key should be public key in this context; remove 1 space between value and using. Line 155: remove 1 space between stake and or.  In DepositPaymaster.sol:  Line 14: deposit should be deposits.  In EIP4337Manager.sol:  Line 106: prevent mistaken replaceEIP4337Manager to disable should be prevents mistaken replaceEIP4337Manager from disabling.  In EntryPoint.sol:  Line 50: into into should be index into. Line 69: deliberately caused should be not deliberately caused. Line 80: UserOperation should be UserOperations or user operations. Line 180: except that should be except for. Line 180: Missing closing parenthesis. Line 522: if it is was should be if it was. Line 552: A50 should be AA50. Line 560: A51 should be AA51.  In IAccount.sol:  Line 29: The an account should be If an account.  In IAggregatedAccount.sol:  Line 9: account, that support should be account that supports. Line 11: valiate should be validate.  In IAggregator.sol:  Line 20: return should be returns. Line 20: Sentence ends with a colon. Line 23: Missing closing parenthesis.  In IEntryPoint.sol:  Line 118: factor should be factory. Line 129: factor should be factory.  In IPaymaster.sol:  Line 13: agree should be agrees. Line 24: validation,) should be validation). Line 48: Now its should be Now its.  In IStakeManager.sol:  Line 22: Docstring copy-paste error from line 29. Line 51: allow should be allows.  In SimpleAccount.sol:  Line 65: transaction should be transactions.  In TestAggregatedAccount.sol:  Line 18: Mutable values slots should be Mutable value slots.  In TestAggregatedAccountFactory.sol:  Line 10: Based n should be Based on.  In TokenPaymaster.sol:  Line 11: define itself should be defines itself. Line 14: Missing closing double quote on getTokenValueOfEth. Line 66: The sentence is incomplete.  In UserOperation.sol:  Line 16: field hold should be field holds. Line 16: paymaster-specific-data should be paymaster-specific data; also remove quotes around this phrase.  Update: Resolved in pull request #219 and merged at commit b4ce311.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#typographical-errors-[core-and-samples]", "labels": ["OpenZeppelin"]}, {"title": "Unused imports [samples]", "body": "Throughout the codebase imports on the following lines are unused and could be removed:  Import console of BLSSignatureAggregator.sol  Import EIP4337Manager of EIP4337Fallback.sol  Import Exec of GnosisAccountFactory.sol  Import IAggregator of IAggregatedAccount.sol  Import UserOperation of IAggregatedAccount.sol  Import Ownable of DepositPaymaster.sol  Import BaseAccount of TestAggregatedAccount.sol  Import SimpleAccount of TestSignatureAggregator.sol  Import console in TestSignatureAggregator.sol  Import SimpleAccount of TokenPaymaster.sol  Consider removing unused imports to avoid confusion that could reduce the overall clarity and readability of the codebase.  Update: Resolved in pull request #206 and merged at commit e019bbd.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#unused-imports-[samples]", "labels": ["OpenZeppelin"]}, {"title": "Unused interface [core]", "body": "The ICreate2Deployer.sol import was removed from EntryPoint.sol in pull request #144, but the file still exists in the interfaces directory. None of the contracts import this file.  Consider deleting the unused interface file.  Update: Resolved in pull request #205 and merged at commit 679ac11.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#unused-interface-[core]", "labels": ["OpenZeppelin"]}, {"title": "References to previously used \u201cwallet\u201d terminology [samples]", "body": "Throughout the codebase, an effort has been made to change the term wallet to account, e.g. SimpleWallet was renamed SimpleAccount. However, some wallet references remain in various comments:  Line 13 of BLSAccountFactory.sol  Line 9 of GnosisAccountFactory.sol  Line 12 of TestAggregatedAccountFactory.sol  Line 14 of VerifyingPaymaster.sol  Line 16 of VerifyingPaymaster.sol  To avoid confusion, consider replacing these instances of wallet with account.  Update: Resolved in pull request #210 and merged at commit d6a2db7.", "html_url": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit#references-to-previously-used-\u201cwallet\u201d-terminology-[samples]", "labels": ["OpenZeppelin"]}, {"title": "BaseBridgeReceiver can be rendered inoperable by incorrectly setting the localTimelock", "body": "The intricate relationship between the BaseBridgeReceiver and TimeLock contracts requires extra caution when updating the localTimelock in the BaseBridgeReceiver, as an incorrect update could render the entire contract inoperable. The following errors must be avoided:  Setting the new localTimelock value to an address that does not implement the Timelock interface (this includes sending the zero address by mistake)  Setting the localTimelock variable to an address that implements the Timelock interface, but with an admin (or pendingAdmin) variable that is not set to the address of the BaseBridgeReceiver contract  If either of these two events were to happen, the BaseBridgeReceiver contract would be unable to successfully send any new messages to the Timelock contract and, as a result, would not be able to update its own localTimelock variable to address this issue.  Update: Resolved in pull request 665 at commit 1ffc7e9.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#basebridgereceiver-can-be-rendered-inoperable-by-incorrectly-setting-the-localtimelock", "labels": ["OpenZeppelin"]}, {"title": "Proposals cannot be canceled", "body": "A proposal can queue its transactions in the Timelock contract by processing the message through the BaseBridgeReceiver contract.  However, even though the Timelock contract allows the admin address (in this case, the BaseBridgeReceiver contract) to cancel a certain transaction, the BaseBridgeReceiver contract does not implement the functionality to call that method.  This means that if a transaction needs to be canceled, a new proposal would need to be passed to change the admin address to an EOA or a contract that has the ability to cancel transactions. After the proposal is passed, it would need to be executed, and then the problematic transaction can finally be manually canceled.  Moreover, as the executeProposal function from the BaseBridgeReceiver contract is not access-controlled, any user may notice that a faulty or malicious transaction is queued and ready to be executed and the protocol will not have the option to stop them from executing it.  Consider implementing the functionality to cancel a transaction in the BaseBridgeReceiver contract.  Update: Acknowledged, not resolved. The Compound team stated:  L2Timelock proposals cannot be canceled by design.  Transactions begin as a proposal on L1. The L1 proposal is placed in the L1 Timelock (where it can be canceled), is queued for a period of time, and then is executed.  The execution of the L1 proposal results in the transaction being enqueued on the L2. It is in a pending state for a period of time, but as far as governance is concerned it is as though the proposal has already been executed.  We accept that once a transaction is enqueued on the L2, there is no way to cancel it.  Canceling an L2 proposal would require granting the authority to cancel to some entity on the L2; this is undesirable since the ability to cancel proposals is also a power that could be used maliciously.  Low Severity", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#proposals-cannot-be-canceled", "labels": ["OpenZeppelin"]}, {"title": "Reversions in Polygon will not be seen in Ethereum", "body": "The protocol implements the functionality to send sensitive governor actions from Ethereum to the Polygon network by using its bridge.  However, due to the unidirectional path of such instructions, the mainnet governor will always assume that orders sent to Polygon were submitted correctly. This means that in case of a reverted proposal when processing the message, the governor will not be aware of it and it will not allow to retry the same proposal without going through the entire lifecycle again.  Consider handling failed submissions of proposals and completing the loop back from Polygon to Ethereum to allow retriable proposals.  Update: Acknowledged, not resolved. The Compound team stated:  Comets approach to L2s is unidirectional by design. Creating an omnidirectional loop would increase complexity and potentially create additional vectors for malicious activity.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#reversions-in-polygon-will-not-be-seen-in-ethereum", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent transaction expiry", "body": "executeTransaction function from the  BaseBridgeReciever contract only considers a transaction valid if the transaction blocks timestamp is instead  Consider updating the contracts logic to agree on the expiration of a transaction.  Update: Resolved in pull request 666 at commit fcb9ef3.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#inconsistent-transaction-expiry", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent usage of uint across loops", "body": "In the BaseBridgeReceiver contract, the processMessage function uses a uint8 variable type to process a message and iterate over its targets.  However, when executing proposals, the for loop utilizes a uint variable type.  Even though the index of the for loop is not protected against overflow, in the unlikely case that more than 256 transactions are sent in a single proposal, the transaction would revert as there would be an identical transaction already queued.  Consider using the same type in both loops for consistency, or documenting the reason for having different implicit loop bounds. Additionally, consider removing the unchecked statement to reduce the attack vector when overflowing.  Update: Resolved in pull request 666 at commit 55712fb.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#inconsistent-usage-of-uint-across-loops", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed parameter", "body": "Within BaseBridgeReceiver.sol, line 20 does not have the event parameters indexed.  Consider indexing event parameters to improve the off-chain services ability to search and filter for specific events.  Update: Resolved in pull request 666 at commit 4b9bcb5.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#lack-of-indexed-parameter", "labels": ["OpenZeppelin"]}, {"title": "Missing distinction between queued and ready-to-execute state", "body": "In the BaseBridgeReceiver contract, the state function returns the state of a given proposal. Currently, the possible state values are: queued, expired, or executed.  However, it is important to distinguish between transactions that are still in queue and require more time before being executed, and those that can already be executed.  This is especially important as the executeProposal function checks that the proposal is in the queued state, but does not check if the proposal can already be executed. As a result, some transactions that are queued but not ready to be executed will pass the initial check, and the transaction will only revert once the executeTransaction function from the Timelock contract is called.  Consider adding another state that indicates that the proposal is queued and can already be executed.  Update: Acknowledged, not resolved. The Compound team stated:  The net benefit of this change would simply be that the error thrown would be thrown by the BaseBridgeReceiver instead of being thrown by the Timelock. These two approaches seem functionally equivalent; we will not make this update.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#missing-distinction-between-queued-and-ready-to-execute-state", "labels": ["OpenZeppelin"]}, {"title": "Identical transactions can be executed inside the same proposal", "body": "When a proposal is sent through the Polygon bridge, the BaseBridgeReceiver contract processes it by queuing all transactions that are included in the proposal to the Timelock contract.  The Timelock contract validates that each transaction is unique by using the hash of the parameters of the transaction as the identifier. However, it is possible to send a duplicated transaction because of how the signature parameter of the function signature is included in the data parameter.  This is caused by how the method abi.encode is used when queuing the transactions. It is possible to send an identical transaction twice by sending the first transaction with the function signature and a second one with the 4 bytes function selector attached to the data field. This would create two different hashes, which causes the requirement to be satisfied when the proposal is being executed, and as a result the same transaction would be executed twice.  When queuing transactions, consider using the packed callData output instead of relying on the signature and data fields for getting the txHash.  Update: Acknowledged, not resolved. The Compound team stated:  Executing identical transactions isnt a problem for us (theres nothing especially malicious that could be done by executing the same transaction twice. In fact, its a leftover limitation of the original Timelock implementation that youre unable to take the same action multiple times (though there isnt an obvious use case to do so). We are hoping to keep the L2 Timelock contracts as similar as possible to the version deployed to mainnet, so we will leave this code as it is.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#identical-transactions-can-be-executed-inside-the-same-proposal", "labels": ["OpenZeppelin"]}, {"title": "Unused return value from executeTransaction", "body": "The executeTransaction function from the Timelock contract has a return value that contains the output from the target.call call.  However, the return value is not used in the executeProposal function from the BaseBridgeReceiver contract. This makes it impossible to access the return value of a transaction that is executed by the BaseBridgeReceiver contract, which may be useful for debugging erratic or unintended behaviors.  Consider retrieving these outputs from the executeTransaction function calls in the executeProposal function.  Update: Acknowledged, not resolved. The Compound team stated:  Its unclear if exposing these return values would actually improve our ability to debug or monitor execution of transactions, especially given that reverted transactions wont emit any events or return any values. We will not make an update related to this recommendation.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#unused-return-value-from-executetransaction", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Nomenclature", "body": "There are a few instances where item names are inconsistent:  FXChild.sol contains an interface named IFxMessageProcessor. Consider matching the name of the interface with the files name.  The processMessageFromRoot function from the IFxMessageProcessor interface has a parameter named rootMessageSender. This interface is implemented in the PolygonBridgeReceiver contract but the parameters name has changed to messageSender. Consider being consistent when implementing the functionality.  Within the BaseBridgeReceiver contract, if a proposal is expired, an error is thrown labeled as ProposalNotQueued. The name of this error could be misleading to a viewer. Consider changing the name of the event to reflect the current behavior, or even better, consider adding a new event to reflect such status.  The Timelock allows the execution of a proposal after a certain delay but before a certain expiry time. This window is labeled as a GRACE_PERIOD, which is usually used to describe the time after a deadline but before penalties are enforced. This can be confusing. Consider using a different term such as EXECUTION_PERIOD to describe the window when proposal execution is allowed.  Update: Partially resolved in pull request 666 at commit ccba0d9. The Compound team stated:  GRACE_PERIOD: Will not update; we want to keep the Timelock interface as it is.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#inconsistent-nomenclature", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "The Timelock, ITimelock, FxChild, and PolygonBridgeReceiver contracts are missing documentation for their functions.  A lack of documentation hinders reviewers understanding of the codes intention which is fundamental to accurately assess not only security but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Partially resolved in pull request 666 at commit ccba0d9. The Compound team stated:  Timelock  No change; we want to keep Timelock as similar as possible to the existing implementationFxChild  Will not add docstrings; this is a vendor contract.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit imports are used", "body": "The use of non-explicit imports in the codebase can decrease the clarity of the code, and may create naming conflicts between locally defined and imported variables. This is particularly relevant when multiple contracts exist within the same Solidity files or when inheritance chains are long.  Throughout the codebase, global imports are being used. For instance:  line 4 of BaseBridgeReceiver.sol  line 4 of PolygonBridgeReceiver.sol  line 5 of PolygonBridgeReceiver.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged, not resolved. The Compound team stated:  Our existing codebase uses non-explicit imports exclusively. We will continue to use non-explicit imports for consistency.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Same configuration values as Mainnet deployment", "body": "The Polygon deployment configuration is almost an exact copy of the Mainnet deployment configuration.  One difference is that the Polygon configuration contains USDT. In the past, Compound has refrained from using USDT as collateral, which causes an inconsistency across the protocol.  Moreover, during the first stages of a deployment, it is recommended to use conservative and stable values for the economic dynamics. Using the same values as the already established mainnet market could cause instabilities when using those from scratch.  Consider reviewing the configuration to ensure such values are correct for the Polygon deployment.  Update: Acknowledged, will resolve. The Compound team stated:  Will update; the configuration values in #598 are not final.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#same-configuration-values-as-mainnet-deployment", "labels": ["OpenZeppelin"]}, {"title": "Inconsistency between backlog and implementation", "body": "The pull request 598 contains a comment specifying that the deployment configuration should have a supplyCap value of 0, while its current value is 500000e18.  It seems the Compound Team is aware of this and will make this change prior to deployment.  Consider updating the supplyCap from the Polygon deployment configuration to zero.  Update: Acknowledged, will resolve. The Compound team stated:  Will update; the configuration values in #598 are not final.", "html_url": "https://blog.openzeppelin.com/compound-polygon-bridge-receiver-audit#inconsistency-between-backlog-and-implementation", "labels": ["OpenZeppelin"]}, {"title": "Burn percentage applies retroactively", "body": "When creating an assertion, the minimum bond depends on the current value of the configurable burn percentage. Asserters and disputers would reasonably expect their reward to be the bond reduced by the burnedBondPercentage at the time the assertion was originally made. However, in contrast to other configurable parameters, the burn percentage is not cached, resulting in the actual reward being reduced by the most recent value at the time of settlement.  Consider caching the burn percentage and using it consistently throughout the life of an assertion.  Update: Acknowledged, not resolved. The UMA team stated:  Weve decided to not make this change. The implications of the issue presented here is that the voters vote to change the bond burn percentage after an assertion is disputed with the goal of stealing it from the disputer (for example setting the bond burn percentage to 100% after an assertion is made). We feel that this is a non-issue as the reputational damage of the DVM doing this would destroy the project and the cost to the protocol would be more than the value extracted from taking the reward.  Additionally, we are at the stack depth for the assertion object and adding an additional property to an assertion (bond burn percentage at assertion time) would require additional data structures or other refactors to accommodate this that we dont want to do at this time.  Low Severity", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#burn-percentage-applies-retroactively", "labels": ["OpenZeppelin"]}, {"title": "Arbitration resolution can be modified", "body": "setArbitrationResolution function in the  resolvedPrice result in the  Consider restricting the setArbitrationResolution function to only allow setting the resolution once per requestId.  Update: Resolved in pull request #4319 with commit 76bed2a.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#arbitration-resolution-can-be-modified", "labels": ["OpenZeppelin"]}, {"title": "Lack of access control on potentially sensitive functions", "body": "In the BaseEscalationManager contract, the following public functions may benefit from access control:  requestPrice  assertionResolvedCallback  assertionDisputedCallback  Currently anyone can call these functions, which can result in them executing state-changing logic in an unintended context.  Consider implementing appropriate access control on these functions so that only the expected instance(s) of the OptimisticAsserter contract can call them.  Update: Resolved in pull request #4334 with commit dd99434.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#lack-of-access-control-on-potentially-sensitive-functions", "labels": ["OpenZeppelin"]}, {"title": "Erroneous docstrings and comments", "body": "Consider fixing the following docstrings and inline comments:  In OptimisticAsserter.sol, the comment on line 88 claims the caller is the asserter, but that is not necessarily true.  In FullPolicyEscalationManager.sol, comments on line 161, line 171, and line 180 for the respective setDisputeCallerInWhitelist, setWhitelistedAssertingCallers, and setWhitelistedAsserters functions state Adds a \u2026 to the whitelist. In reality, the functions can both add and remove from the whitelists.  Update: Resolved in pull request #4320 with commit b943b23.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#erroneous-docstrings-and-comments", "labels": ["OpenZeppelin"]}, {"title": "Missing or incomplete docstrings", "body": "Several contracts and functions in the codebase lack complete documentation:  In BaseEscalationManager.sol:  assertionResolvedCallback has undocumented assertionId and assertedTruthfully parameters. assertionDisputedCallback has an undocumented assertionId parameter.  In EscalationManagerInterface.sol:  The interface is undocumented. All functions and structs are undocumented.  In FullPolicyEscalationManager.sol:  setDisputeCallerInWhitelist has an undocumented value parameter. setWhitelistedAssertingCallers has an undocumented value parameter. setWhitelistedAsserters has an undocumented value parameter.  In OptimisticAsserter.sol:  assertTruthWithDefaults has an undocumented asserter parameter. assertTruth has an undocumented return value. getCurrentTimestamp has an undocumented return value. Functions marked internal are undocumented.  In OptimisticAsserterInterface.sol:  The interface is undocumented. All functions are undocumented. The structs are only partially documented.  In OptimisticAsserterCallbackRecipientInterface.sol:  The interface is undocumented. All functions are undocumented.  Incomplete documentation hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and facilitate maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted.  Consider thoroughly documenting all functions and their parameters. When writing docstrings, especially for publicly-exposed functions, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in pull request #4342 with commit c831b8c.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#missing-or-incomplete-docstrings", "labels": ["OpenZeppelin"]}, {"title": "No check for final fee when adding currency to whitelist", "body": "When a currency is whitelisted and cached in the OptimisticAsserter contract, it is assumed that the Store contract will have a final fee set for the currency address. If the final fee has not been set, then assertions can be posted without a bond.  Prior to whitelisting a currency, consider adding a check that ensures the final fee from the Store contract is non-zero in the syncUmaParams and _validateAndCacheCurrency functions.  Update: Acknowledged, not resolved. The UMA team stated:  Weve decided to not make this change. There should never be collateral currencies added that dont have a final fee by DVM. If this was to occur, it would not pose too much of an issue within the system as 0 bonded assertions dont really enable you to do much other than spam the DVM. if you were to spam the DVM with this technique we can delete the requests at the DVM level.  Added to this (and more importantly) there is a feature of having zero-sized bonds in one important situation: testnets. It is really convenient to not have to force users on testnets to approve and pay collateral currencies when making simple tests as this strictly increases the friction with using the system.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#no-check-for-final-fee-when-adding-currency-to-whitelist", "labels": ["OpenZeppelin"]}, {"title": "BaseEscalationManager is not declared abstract", "body": "The requestPrice and getPrice functions in the BaseEscalationManager contract are stubs that do not perform any oracle actions. Additionally, the getPrice function has a return type of int256 but does not return any value. In its current state, this base contract does not implement a fully functional escalation manager.  Consider making the BaseEscalationManager contract abstract and removing the function body of the getPrice function to force implementation by derived contracts.  Update: Acknowledged, not resolved. The UMA team stated:  We think its better for this to not be abstract as it makes derived contracts easier and shorter to implement; if you dont care about a particular feature then you just do nothing and it defaults to the disabled/simple behavior. For example if you dont care about disabling disputes then the base implementation just returns true for isDisputeAllowed. By making this abstract wed force implementing contracts to have to declare and implement things, even if they dont care about that functionality.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#baseescalationmanager-is-not-declared-abstract", "labels": ["OpenZeppelin"]}, {"title": "Constant not using UPPER_CASE format", "body": "In OptimisticAsserter.sol, the defaultIdentifier constant is not declared using UPPER_CASE format.  According to the Solidity Style Guide, constants should be named in all capital letters with underscores separating words. For better readability, consider following this convention.  Update: Acknowledged, not resolved. The UMA team stated:  While it goes against the solidity styling guide, wed like to keep this lowercase so that the accessor function optimisticAsserter.defaultIdentifier() looks the same as the other assessors of similar type (optimisticAsserter.defaultCurrency() and optimisticAsserter.defaultLiveness()).", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#constant-not-using-upper_case-format", "labels": ["OpenZeppelin"]}, {"title": "Escalation managers are bound by DVM constraints", "body": "The OptimisticAsserter contract is designed to allow disputed assertions to be arbitrated by either the UMA Data Verification Mechanism (DVM) or an escalation manager contract specified by the asserter. The arbitrateViaEscalationManager setting controls whether the DVM or escalation manager will act as the oracle for arbitration.  Even when an escalation manager is chosen instead of the DVM, the assertTruth function still performs checks that are DVM-specific:  These are restrictions put in place in order to interact with the DVM, but they are not necessarily required by a generic escalation manager. These restrictions force all escalation managers to use the same currencies as the DVM for bond payment, and also impose a minimum bond amount based on the DVM final fee that is unrelated to each escalation managers costs. The identifiers supported by each escalation manager must also match those supported by the DVM.  Additionally, while the existing design allows the DVM to collect a fee for providing oracle services, it does not allow an escalation manager to collect any fee to cover its potential cost for providing the same service. Moreover, since the usage fee and burn amount are coupled, none of the bond is burned when the escalation manager is used as an oracle.  To provide a more generic and flexible design, consider uncoupling escalation managers from the constraints of the DVM and allowing all oracles to specify their supported identifiers, currencies, and fees. Applying an equal treatment to all oracles should allow for the removal of special-case logic for handling different oracle types.  Update: Resolved in pull request #4343 with commit 25d22a9. The oracleFee computed in settleAssertion is now collected in all dispute cases, even when the escalation manager is used as the oracle, to ensure that there is always a fee associated with any dispute. Additionally, the UMA team stated:  The feature of using escalation manager for dispute arbitration is designed only as a fallback mechanism to allow integrating partners to unplug from UMA DVM if it is considered under risk of being corrupted. This is not meant to be feature-full replacement of existing UMA Oracle system, thus we kept the same DVM constraints also when arbitrating disputes within the escalation manager. Otherwise it would require escalation managers to implement their own whitelisting and fee management mechanisms that is too much overhead just for the fallback scenario.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#escalation-managers-are-bound-by-dvm-constraints", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed parameters", "body": "Within the codebase, some events do not have their parameters indexed. Indexing event parameters facilitates the task of off-chain services searching and filtering for specific events. In particular, the following events may benefit from the addition of the indexed keyword to certain parameters:  In FullPolicyEscalationManager.sol:  DisputeCallerWhitelistSet event: Consider indexing address disputeCaller.  AssertingCallerWhitelistSet event: Consider indexing address assertingCaller.  AssertingWhitelistSet event: Consider indexing address asserter.  Update: Resolved in pull request #4323 with commit 6ad9643.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#lack-of-indexed-parameters", "labels": ["OpenZeppelin"]}, {"title": "Argument name mismatch between interface and implementation", "body": "getMinimumBond function in the  OptimisticAsserterInterface interface is named  OptimisticAsserter contract on  line 358.  For clarity, consider renaming one of the arguments so the interface matches the implementation.  Update: Resolved in pull request #4324 with commit dffb20e.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#argument-name-mismatch-between-interface-and-implementation", "labels": ["OpenZeppelin"]}, {"title": "Missing event parameter", "body": "In contrast to the AssertionMade and AssertionSettled events, the AssertionDisputed event does not emit the calling address. Consider including it for completeness.  Update: Resolved in pull request #4325 with commit 9c37198.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#missing-event-parameter", "labels": ["OpenZeppelin"]}, {"title": "Lack of SPDX license identifiers", "body": "All of the contract files in the escalation-manager directory lack SPDX license identifiers.  To avoid legal issues regarding copyright and follow best practices, consider adding SPDX license identifiers to files, as suggested by the Solidity documentation.  Update: Resolved in pull request #4326 with commit 5e36c85.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#lack-of-spdx-license-identifiers", "labels": ["OpenZeppelin"]}, {"title": "Multicall is payable", "body": "The multicall function of the MultiCaller contract is declared payable but does not accept any ETH. In the interest of clarity, consider removing the payable keyword.  Update: Resolved in pull request #4327 with commit 1d416c9.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#multicall-is-payable", "labels": ["OpenZeppelin"]}, {"title": "Missing check for non-zero address before calling external function", "body": "_isDisputeAllowed function in the  policy is to not validate disputers when no escalation manager is specified, so the function will  exit early instead of invoking a function on the zero address.  Nevertheless, in the interest of local reasoning, consider adding a zero-address check on the em address prior to using it to make external function calls. Also consider swapping line 449 and line 450 so that the em address assignment is only made when this variable is required.  Update: Resolved in pull request #4336 with commit 9543282.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#missing-check-for-non-zero-address-before-calling-external-function", "labels": ["OpenZeppelin"]}, {"title": "Redundant code", "body": "Consider addressing the following instances of redundant code within the codebase:  The override keyword can be removed from all functions in the BaseEscalationManager contract.  The requestId is computed on line 89 and line 155 in the FullPolicyEscalationManager contract. Consider deduplicating this code by creating a shared getRequestId function. Additionally, consider making this function publicly available for user convenience.  Within the FullPolicyEscalationManger contract, the require statement in the configureEscalationManager function can be simplified:require(!_blockByAsserter || (_blockByAsserter && _blockByAssertingCaller), \"Cannot block only by asserter\");Execution can only reach the (_blockByAsserter && _blockByAssertingCaller) condition if the first condition !_blockByAsserter evaluates to false, which means the second condition will always evaluate to (true && _blockByAssertingCaller). This further reduces to just _blockByAssertingCaller.  The lookup of assertions[assertionId].escalationManagerSettings.escalationManager happens on lines 435, 443, 449, 471, 472, 480, and 481 in the OptimisticAsserter contract. Consider modifying the existing _getEscalationManager function to return an address type, and using it in all the identified locations other than line 435 to perform the escalationManager lookup. This change would also enable the removal of the address() cast that occurs on line 414 where _getEscalationManager is currently used.  In the _callbackOnAssertionResolve and _callbackOnAssertionDispute functions within the OptimisticAsserter contract, the lookup of assertions[assertionId].callbackRecipient and assertions[assertionId].escalationManagerSettings.escalationManager happens twice within each functions scope. In each case, consider storing the value obtained from the first lookup in a local variable for reuse.  The return statement in the assertTruth function is redundant because assertionId is a named return variable in the function specification. Consider removing this return statement.  Update: Partially resolved in pull request #4335 with commit 59b13d3. The _isDisputeAllowed function still performs the lookup assertions[assertionId].escalationManagerSettings.escalationManager instead of using the _getEscalationManager function.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#redundant-code", "labels": ["OpenZeppelin"]}, {"title": "Public functions that could be declared external", "body": "In Solidity, functions with public visibility can be used both internally and externally. In the case a function is only ever used externally, it is best practice to limit the visibility to external rather than public. Below is a list of functions that have public visibility that can be limited to external visibility in the OptimisticAsserter contract:  assertTruthWithDefaults  disputeAssertion  settleAndGetAssertionResult  To improve the explicitness of the codebase, and to reduce gas usage, consider changing the visibility of these functions to external.  Update: Resolved in pull request #4337 with commit bbe05e1.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#public-functions-that-could-be-declared-external", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Consider correcting the following typographical errors:  In BaseEscalationManager.sol:  Line 34: if the dispute should be true if the dispute.  Line 55: Optimistic should be Optimistic Asserter.  In FullPolicyEscalationManager.sol:  Line 12: a whitelistedDisputeCallers should be whitelistedDisputeCallers.  Line 101: Assertor should be Asserter.  Line 161: disputerCaller should be disputeCaller.  In OptimisticAsserter.sol:  Line 122: security properties the assertion should be security properties for the assertion.  Line 128: Must be a pre-approved. is an incomplete sentence.  Line 132: should be bytes32 should be 0.  Line 180: Set should be set.  Line 218: cant should be cant.  In OptimisticAsserterInterface.sol:  Line 10: SS should be SSM.  Update: Resolved in pull request #4339 with commit 97be5e6.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unused import", "body": "In EscalationManagerInterface.sol, the import OptimisticAsserterInterface.sol is unused and could be removed.  Consider removing unused imports to avoid confusion that could reduce the overall clarity and readability of the codebase.  Update: Resolved in pull request #4338 with commit e4f47ee.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#unused-import", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent use of named return variables", "body": "stampAssertion,  getMinimumBond, and  getCurrentTime do not assign names. None of the internal functions use named variables, making them consistent with each other but inconsistent with the external/public functions. Additionally, the following functions have unused named variables:  assertTruthWithDefaults,  settleAndGetAssertionResult,  getAssertion, and  getAssertionResult.  When choosing to use named return variables, consider using them in a consistent manner throughout all functions within the same contract.  Update: Resolved in pull request #4341 with commit 59364ce. The unused named return variables were removed.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#inconsistent-use-of-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Use of magic numbers", "body": "The OptimisticAsserter and FullPolicyEscalationManager contracts use the constant value 1e18 in the settleAssertion and getPrice functions without documenting the values meaning.  Literal values in the codebase without an explained meaning make the code harder to understand and maintain, thus hindering the experience of developers, auditors, and external contributors alike. To improve the codes readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name.  Update: Resolved in pull request #4340 with commit 5ba00f8. The OptimisticAsserter and FullPolicyEscalationManager contracts now independently define a numericalTrue constant equal to 1e18 and provide an explanatory comment.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-asserter-audit#use-of-magic-numbers", "labels": ["OpenZeppelin"]}, {"title": "Useless Assertion Check", "body": "The assertEq function in the bootloader compares two values. If they are not equal, it throws an error. There are two issues with this implementation:  The function compares the value of the value1 parameter to itself, which means the comparison will always be true and the function serves no purpose.  The function header includes the value1 parameter twice, which causes a compile-time error when using a Solidity compiler such as solc.  Consider correcting the comparison by checking two distinct variables. Additionally, ensure that the custom zkEVM compiler throws an error when declaring two variables with the same name in the same scope.  Update: Resolved in pull request #133 at commit 6e3c054.  High Severity", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#useless-assertion-check", "labels": ["OpenZeppelin"]}, {"title": "Non-Standard Transaction Hash", "body": "The BootloaderUtilities contract generates transaction hashes for different types based on the transaction data, including the signature. The signature includes a v value that encodes a parity bit y for address recovery purposes. The way that the parity bit is encoded into v depends on the type of transaction:  For legacy transaction hashes, v can be either 27 + y, or 35 + chainid * 2 + y when the chainid is included (Ethereum Yellowpaper, page 5).  For EIP2930 and EIP1559 transactions, v is simply encoded as y (either 0 or 1).  v must be either 27 or 28. This causes problems in the legacy transaction hash function because, when the  35 + block.chainid * 2 is added to v. But, since  Additionally, in the EIP-2930 and EIP-1559 transaction hash functions, the v value is again fetched as either 27 or 28 and encoded as such, even though it should be 0 or 1 as defined by the standard. Hence, the transaction hashes generated by these functions are also non-standard.  Consider fixing this by deriving the correct value from the v value that is given or changing the way the v value is enforced in the first place.  Update: Resolved in pull request #157 at commits 3472d28 and 471a450.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#non-standard-transaction-hash", "labels": ["OpenZeppelin"]}, {"title": "Unbound RLP Length Encoding", "body": "The RLPEncoder library allows the encoding of bytes and list-type values. These dynamic types need to be prefixed to indicate the type and length of the data. The type is indicated through an offset:  0x80 for bytes  0xc0 for a list  The length encoding depends on the length itself:  Length < 56: The length is added onto the offset.  Bytes 1st byte range: [0x80, 0xb7] List 1st byte range: [0xc0, 0xf7]  Length \u2265 56: The length of the data is encoded between offset and data. The length of the length in bytes is added onto the offset.  Bytes 1st byte range: [0xb8, 0xbf] List 1st byte range: [0xf8, 0xff]  Visualization of 2.:  In the (2.) case, we can see that the encoding of the length can at most be 8 bytes long. However, in the RLP library a length of up to 32 bytes is taken as input to encode the length. Hence, when encoding a length equal or greater than 2**64, the length encoding requires 9 or more bytes. This bound violation ends up in a corrupted encoding. For instance, a byte encoding could thereby end up as a list encoding.  This issue was not identified as a problem for the codebase in scope, as the length to encode is based on transaction data, which is unlikely to be of size 2**64 or greater. However, as this library finds adoptions across other projects, the current implementation could lead to severe issues or introduction of vulnerabilities if not used properly.  Consider checking that the length to encode is bound to 2**64 - 1.  Update: Resolved in pull requests #134 and #160 at commits 61b8138 and 6e45486.  Medium Severity", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#unbound-rlp-length-encoding", "labels": ["OpenZeppelin"]}, {"title": "Overshadowing and Uncaptured Returns", "body": "In the bootloader contract, the function setTxOrigin has a return value success, which is overshadowed by a local variable of the same name within the function scope. In the solc Solidity compiler this triggers a compiler error.  Additionally, the setTxOrigin function is called from the top level without capturing its return value, which causes another compiler error in solc and might lead to unexpected outcomes when using other compilers.  The same issue applies to the precompileCall function, which has a return value that is not captured when it is called inside the nearCallPanic function.  To address these issues, consider removing all unused return values.  Update: Resolved in pull request #135 at commit 45c04f9.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#overshadowing-and-uncaptured-returns", "labels": ["OpenZeppelin"]}, {"title": "String Literal Exceeds 32 Bytes Limit", "body": "In the bootloader contract, the string literal Tx data offset is not in correct place is used as an input to the assertionError function. It exceeds the 32-byte limit for string literals in Yul, which leads to a compile error with the solc Solidity compiler. The usage of another compiler might lead to a similar error or silently discard parts of the string.  To avoid any possible compiler and runtime issues, consider making the string shorter by removing or abbreviating some of the words.  Update: Resolved in pull request #136 at commit d506790.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#string-literal-exceeds-32-bytes-limit", "labels": ["OpenZeppelin"]}, {"title": "Unprotected Initialization Function", "body": "In the L2EthToken contract, an unresolved comment acknowledges the fact that the initialization function is unprotected and anyone could set the l2Bridge address if they call the function before the legitimate operator. The comment describes the problem without presenting a solution.  Consider using the TypeScript-based templating system that is already present in the codebase to inject a constant address that limits the initialization call to one specific msg.sender.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We plan to rethink the approach of bridging ether in the new upgrade, the issue will be resolved there.  Low Severity", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#unprotected-initialization-function", "labels": ["OpenZeppelin"]}, {"title": "Documentation and Code Mismatch", "body": "In the bootloader contract a few instances of a mismatch between the contract and documentation were identified:  The MAX_POSTOP_SLOT constant is documented to account for 4 slots which are required for the encoding of the callPostOp call. However, the implementation accounts for 7 slots.  The MAX_MEM_SIZE constant is of size 2**24, while it is described as 2**16.  In the callPostOp function, the txResult parameter is described as 0 if successful and 1 otherwise. However, the txResult value is coming from low-level call that returns 1 if being successful and 0 otherwise. Proceeding forward, this result is correctly handled through the ExecutionResult enum, thereby affecting the documentation only.  The setErgsPrice function is incorrectly documented as Set the new value for the tx origin context value.  The lengthToWords function is implemented differently from what the name and documentation are indicating. From the description it suggest to return the number of words needed for a specified length of bytes. However, the implementation returns the next bigger bytes length of words that are needed. The implementation is also inefficient and can be simplified.  In the RLPEncoder library, the comment on line 7 describes the size as equal to 14 bytes (dec), while 0x14 bytes (hex) is the correct size.  In the BootloaderUtilities contract, the comment on line 21 refers to signedHash while signedTxHash is the correct identifier name.  In the L2EthToken contract, the transferFromTo function claims to rely on SameMath which is probably referring to a SafeMath library which is also not used in that function.  Consider correcting the above mismatches to be precise about the implementation and its documentation to ease code review.  Update: Resolved in pull requests #137 and #161 at commits 68f99cb, 7b66b8a, and e09b067.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#documentation-and-code-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Incompatible Function Syntax", "body": "In the bootloader contract, the function getFarCallABI is declared with a list of parameters ending with a trailing comma.  However, the Solidity compiler solc does not support the declaration of Yul functions with a parameter list containing a trailing comma.  Consider removing the trailing comma and ensure that your codebase maintains as much compatibility with the Solidity compiler whenever possible.  Update: Resolved in pull request #138 at commit 5e1cf33.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#incompatible-function-syntax", "labels": ["OpenZeppelin"]}, {"title": "Inexplicit Fail in Bridge Burn", "body": "The bridgeBurn function in the L2EthToken contract adjusts a users balance without checking their current balance first. This could result in an underflow error, which is providing insufficient information to the user.  To prevent this issue, consider adding a require statement to explicitly fail with a descriptive error string if the users balance is exceeded.  Update: Resolved in pull request #139 at commit 2053757.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#inexplicit-fail-in-bridge-burn", "labels": ["OpenZeppelin"]}, {"title": "Inexplicit Imports", "body": "In the BootloaderUtilities and MsgValueSimulator contract, the Constants.sol file inexplicitly imports all constants. This hinders the visibility of what other components are actually used within the contract.  Consider changing the imports to explicitly import specific constants for better code clarity.  Update: Resolved in pull request #156 at commit 94c79a5.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#inexplicit-imports", "labels": ["OpenZeppelin"]}, {"title": "Lack of Revert Messages", "body": "In the L2EthToken contract, the require statements in line 36-37, 42, and 54-58 lack an error message.  Consider adding the error message to fail more explicitly and ease debugging.  Update: Resolved in pull request #140 at commit be287c9.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#lack-of-revert-messages", "labels": ["OpenZeppelin"]}, {"title": "Mismatch Between Interface and Implementation", "body": "The BootloaderUtilities contract imports the IBootloaderUtilities interface, but the contract does not inherit from this interface. It appears that the intent may have been to inherit from the interface, but due to this oversight, there is a mismatch between the function names and return types in the interface and the contract.  In the interface, the function is defined as:  But in the contract, it is defined as:  This inconsistency may result in errors or unexpected behavior.  Consider inheriting from the IBootloaderUtilities interface in the BootloaderUtilities contract to ensure that the function names and return types are consistent and match the intended functionality. This will improve the reliability and maintainability of the codebase.  Update: Resolved in pull request #141 at commit 827aad6.  Missing Interface for L2EthToken  The L2EthToken contract implements two interfaces to enforce compliance with their respective functions. However, the contract also implements the standard ERC-20 functions name, symbol, decimals, and totalSupply.  Currently, nothing prevents misspellings and there is no convenient way to call these functions through address to interface conversion.  Consider either integrating them into one of the existing interfaces or defining an additional interface PartialERC20.  Update: Resolved in pull requests #142 and #162 at commits f6fbaa9 and 5082111.  Imprecise Naming of Transaction Struct Elements  In the bootloader contract, inside of the validateTypedTxStructure function, it is stated that the first and second reserved slots of the transaction struct are used to store the nonce and value, respectively. These values are common to all types of transactions and could also be stored as explicit elements of the transaction struct.  To improve the code clarity, consider adding dedicated entries to the transaction struct for these common elements.  Update: Resolved in pull request #143 at commits af4c5b9 and cd55ab2.  TypeScript Constant Names Are Inconsistent  The bootloader contract includes constants that are defined in TypeScript code with the format , and are replaced with their actual values during compilation. These constants, which are often used for selectors, may or may not be padded with zeros. However, the names of these constants do not consistently indicate whether they have been padded or not, which is important for determining the memory layout in the bootloader.  To improve the clarity and consistency of the codebase, consider using consistent naming conventions for constants that indicate whether they have been padded or not.  Update: Resolved in pull request #144 at commit 8ca44a7.  Unused Functions  The following internal functions are defined in the bootloader contract, but appear to be unused:  ETH_L2_TOKEN_ADDR  min  ETH_CALL_ERR_CODE  UNACCEPTABLE_ERGS_PRICE_ERR_CODE  TX_VALIDATION_FAILED_ERR_CODE  To improve the codebase, consider either using these functions or removing them. Removing unused functions can help to reduce clutter and make the code easier to understand.  Update: Resolved in pull request #145 at commit 316c54a. The Matter Labs team stated:  We removed all unused constants except _ERR_CODES, which are used in the server. We want to avoid any confusion when starting to use such error codes in bootloader.  Wrong EIP-712 Transaction Type Check  In the validateTypedTxStructure function of the bootloader, the EIP-712 txType is checked against 112, while it is supposed to be 113.  Following the execution flow, it can be seen in the getTransactionHashes function that a call reverts if the transaction type does not match one of 0, 1, 2, or 113. So for a transaction of type 113, the foreseen checks in the bootloader are skipped. This means the reserved slots can be arbitrary. However, no negative consequences were identified.  Consider correcting the transaction type check from 112 to 113. Further, consider implementing a default case and using the unused valid return variable to fail early if the transaction type does not match.  Update: Resolved in pull request #146 at commit c343256.  Notes & Additional Information  Code Redundancy  BootloaderUtilities contract, different types of transactions are encoded and hashed. These transaction types share similarities in their encoding which leads to redundancy of code. For instance, both the legacy and EIP-2930 type transaction have the consecutively encoded fields  Consider moving some parts of the encoding into a function to reuse the code for both transaction types.  Update: Acknowledged, not resolved. The Matter Labs team stated:  Specifically in the specified places, we choose readability over performance.  Commented-out Code  In the bootloader.yul file, the two constants in Solidity code format dummyAddress and BOOTLOADER_ADDRESS are commented out and seem obsolete.  Consider removing the commented-out code as well as the comments describing them.  Update: Resolved in pull request #147 at commit 7c344be. ", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#mismatch-between-interface-and-implementation", "labels": ["OpenZeppelin"]}, {"title": "Missing Interface for L2EthToken", "body": "Missing Interface for L2EthToken", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#missing-interface-for-l2ethtoken", "labels": ["OpenZeppelin"]}, {"title": "Imprecise Naming of Transaction Struct Elements", "body": "In the bootloader contract, inside of the validateTypedTxStructure function, it is stated that the first and second reserved slots of the transaction struct are used to store the nonce and value, respectively. These values are common to all types of transactions and could also be stored as explicit elements of the transaction struct.  To improve the code clarity, consider adding dedicated entries to the transaction struct for these common elements.  Update: Resolved in pull request #143 at commits af4c5b9 and cd55ab2.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#imprecise-naming-of-transaction-struct-elements", "labels": ["OpenZeppelin"]}, {"title": "TypeScript Constant Names Are Inconsistent", "body": "The bootloader contract includes constants that are defined in TypeScript code with the format , and are replaced with their actual values during compilation. These constants, which are often used for selectors, may or may not be padded with zeros. However, the names of these constants do not consistently indicate whether they have been padded or not, which is important for determining the memory layout in the bootloader.  To improve the clarity and consistency of the codebase, consider using consistent naming conventions for constants that indicate whether they have been padded or not.  Update: Resolved in pull request #144 at commit 8ca44a7.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#typescript-constant-names-are-inconsistent", "labels": ["OpenZeppelin"]}, {"title": "Unused Functions", "body": "The following internal functions are defined in the bootloader contract, but appear to be unused:  ETH_L2_TOKEN_ADDR  min  ETH_CALL_ERR_CODE  UNACCEPTABLE_ERGS_PRICE_ERR_CODE  TX_VALIDATION_FAILED_ERR_CODE  To improve the codebase, consider either using these functions or removing them. Removing unused functions can help to reduce clutter and make the code easier to understand.  Update: Resolved in pull request #145 at commit 316c54a. The Matter Labs team stated:  We removed all unused constants except _ERR_CODES, which are used in the server. We want to avoid any confusion when starting to use such error codes in bootloader.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#unused-functions", "labels": ["OpenZeppelin"]}, {"title": "Wrong EIP-712 Transaction Type Check", "body": "In the validateTypedTxStructure function of the bootloader, the EIP-712 txType is checked against 112, while it is supposed to be 113.  Following the execution flow, it can be seen in the getTransactionHashes function that a call reverts if the transaction type does not match one of 0, 1, 2, or 113. So for a transaction of type 113, the foreseen checks in the bootloader are skipped. This means the reserved slots can be arbitrary. However, no negative consequences were identified.  Consider correcting the transaction type check from 112 to 113. Further, consider implementing a default case and using the unused valid return variable to fail early if the transaction type does not match.  Update: Resolved in pull request #146 at commit c343256.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#wrong-eip-712-transaction-type-check", "labels": ["OpenZeppelin"]}, {"title": "Code Redundancy", "body": "BootloaderUtilities contract, different types of transactions are encoded and hashed. These transaction types share similarities in their encoding which leads to redundancy of code. For instance, both the legacy and EIP-2930 type transaction have the consecutively encoded fields  Consider moving some parts of the encoding into a function to reuse the code for both transaction types.  Update: Acknowledged, not resolved. The Matter Labs team stated:  Specifically in the specified places, we choose readability over performance.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#code-redundancy", "labels": ["OpenZeppelin"]}, {"title": "Commented-out Code", "body": "In the bootloader.yul file, the two constants in Solidity code format dummyAddress and BOOTLOADER_ADDRESS are commented out and seem obsolete.  Consider removing the commented-out code as well as the comments describing them.  Update: Resolved in pull request #147 at commit 7c344be.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#commented-out-code", "labels": ["OpenZeppelin"]}, {"title": "Extra Code", "body": "In the bootloader contract, the computation of a switch statement condition in the transaction processing includes unnecessary code that makes the code harder to read. The variables txType and isL1Tx are not used elsewhere in the function. Additionally, the FROM_L1_TX_TYPE variable appears to be a constant, but it is not declared as such.  To improve the clarity and readability of the code, consider simplifying the switch statement computation and properly declaring variables as constants if they are intended to be constant.  Update: Resolved in pull requests #148 and #158 at commits 613636f and cdc301f.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#extra-code", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Declaration of Constants", "body": "There is an inconsistency in the way constants are declared in the code, with some being declared as functions and others being declared as variables. This deviation from a consistent pattern can be confusing and make it difficult to understand the purpose and usage of these constants. The following constants are declared as variables:  TX_DESCRIPTION_SIZE  TXS_IN_BLOCK_LAST_PTR  Consider using a consistent method for declaring constants throughout the code as functions. This will improve the readability and understandability of the code and make it easier for others to work with it.  Update: Resolved in pull request #149 at commits c7042cd and fee4b5b.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#inconsistent-declaration-of-constants", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent Declaration of Integers", "body": "In the bootloader contract, there is an inconsistency in the way memory offsets are declared in the codebase, with some being expressed in decimal and others being expressed in hexadecimal. This deviation from a consistent notation can be confusing and make it difficult to understand the purpose and usage of these sizes. For instance:  add(0x20, txDataOffset) in line 291  add(0x20, txDataOffset) in line 300  mstore(txDataOffset, 0x20) in line 431  add(txDataOffset, 0x20) in line 797  add(txDataOffset, 0x20) in line 1170  add(dataPtr, 0x20) in line 1400  Consider using a consistent notation for expressing memory offsets throughout the codebase.  Update: Resolved in pull request #150 at commit ecdbebd.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#inconsistent-declaration-of-integers", "labels": ["OpenZeppelin"]}, {"title": "Performance Optimization", "body": "In the bootloader contract, we have identified several opportunities for performance optimization:  In the validateTypedTxStructure function, when checking if the reservedDynamicLength value is not zero, consider loading the length from the getReservedDynamicPtr pointer directly to skip the lengthToWords computation.  In the callAccountMethod function, consider using the existing txDataOffset pointer instead of advancing the txDataWithHashesOffset a second time to save an add.  In the function call to executeL1Tx, consider propagating the given innerTxDataOffset instead of recalculating it in the function itself.  In the getFarCallAbi function, dataOffset and memoryPage are zero and could be skipped. Consider starting with the shifted dataStart value instead.  The executeL2Tx function is only called within the ZKSYNC_NEAR_CALL_executeL2Tx() function where the from transaction value is present. Consider propagating that from value to the executeL2Tx call instead of recomputing it.  Update: Partially resolved in pull request #151 at commit fe92113. The Matter Labs team stated:  Partially fixed, we decided to keep better readability over performance in a place where optimization is hard to implement or may confuse the reader. Also, please note that the compiler could do such an optimization, because we have an LLVM backend.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#performance-optimization", "labels": ["OpenZeppelin"]}, {"title": "TODOs Are Present in the Codebase", "body": "In the bootloader contract, there are incomplete implementations and missing functionality in the codebase, as indicated by the presence of TODO comments. This can make it difficult to understand the intended functionality and behavior of the code, and may also make it difficult to properly test and maintain the codebase. For instance:  make user pay for sending back the L1 message  (SMA-1220): refunds are not supported as of now  (SMA-1220): support refunds [\u2026]  Consider completing the implementations and addressing the missing functionality. This will improve the overall quality and reliability of the codebase and make it easier for others to work with it.  Update: Acknowledged, not resolved. The Matter Labs team stated:  The issue will be resolved in upcoming upgrades.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#todos-are-present-in-the-codebase", "labels": ["OpenZeppelin"]}, {"title": "Typographical Errors", "body": "In the codebase the following typographical errors were identified:  shoud \u2192 should  Firsly \u2192 Firstly  succedes \u2192 succeeds  Reseting \u2192 Resetting  mainntet \u2192 mainnet  only one higher \u2192 only the first one above  again \u2192 against  Consider correcting these and any further issues.  Update: Resolved in pull request #152 at commits 9dd29e3 and 630625f.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unexpected Negation in Inclusion Logic", "body": "bootloader contract, the constant  line 1523, the inclusion of a block is determined by negating the value of  To improve readability, consider using the non-negated form exclusively to specify which code should be included. For example, using  to include the block when BOOTLOADER_TYPE is set to proved_block, and  to include the block when BOOTLOADER_TYPE is set to playground_block.  Update: Resolved in pull request #153 at commit 9b9d534.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#unexpected-negation-in-inclusion-logic", "labels": ["OpenZeppelin"]}, {"title": "Unintuitive Naming", "body": "In the bootloader contract, two occurrences of unintuitive variable naming were identified:  The naming of RESERVED_FREE_SLOTS is somewhat confusing, as it suggests that the slots are both reserved and free at the same time. In reality, the reserved slots may be free, but most of the slots will be pre-filled.  The terms txInnerDataOffset and innerTxDataOffset are both used for semantically similar parameters. This inconsistency in naming can be confusing and limit the ability to easily search for all occurrences.  Consider using more consistent and intuitive naming conventions for variables and terms in the codebase.  Update: Resolved in pull request #163 at commit 83931d4.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#unintuitive-naming", "labels": ["OpenZeppelin"]}, {"title": "Unused Imports", "body": "In the BootloaderUtilities contract the  IBootloaderUtilities interface,  SystemContractHelper library, and  Constants file  are imported but never used.  Consider using or removing them.  Update: Resolved in pull request #154 at commit 26523a2. The IBootloaderUtilities interface is now used as part of the L-06 fix.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused Variable", "body": "The encodedChainId variable in the BootloaderUtilities contract is unused.  Similarly, in the bootloader contract the variables from and ergsLimit remain unused within the ZKSYNC_NEAR_CALL_validateTx function.  Consider removing these unused variables.  Update: Resolved in pull request #155 at commit bca9d68.", "html_url": "https://blog.openzeppelin.com/zksync-bootloader-audit-report#unused-variable", "labels": ["OpenZeppelin"]}, {"title": "Potential DoS in rebalance feature", "body": "BullStrategy relies on a rebalancing mechanism coded into the  AuctionBull contract to rebalance the strategys ETH exposure against the Crab strategy and/or Eulers loan. The rebalancing mechanism works with a special EOA, namely the  auctionManager that calls either the  fullRebalance or  leverageRebalance functions in the contract. In the case of a  The full rebalance works by collecting signed user bids off-chain, and then relaying them to be processed on-chain as orders. Despite orders being validated off-chain, by the time they are actually processed and included in a block there could be many ways in which individual orders fail during a rebalance. Some of them are:  Lack of allowance in tokens transfer: the user might have provided a valid approval first, but then revoked it by front running the rebalance transaction.  Lack of funds: the user might have no funds when submitting the order, or might have transferred them away after right before the rebalance transaction takes places.  Wrong signature (the ECDSA check might fail).  Wrong order on-chain (orders are not finally ordered from best to worst).  Very tight expiration set: the order might be expired by the time its confirmed in high gas price scenarios.  Sending a certain amount of WETH to the AuctionBull contract when depositing into Crab might cause the formula that calculates how much WETH is needed from Uniswap to revert, since it can become a negative number, thus forcing the rebalance to revert. This can be fixed by keeping an internal accounting of how much WETH the contract got from the traders orders instead of checking the entire contract balance.  Signing a lot of valid orders with a competitive price will force the rebalance transaction to use up a lot of gas since there are many safety checks involved and transfers of funds. An attacker can craft enough valid orders from different wallets and IPs in order to build up a list of orders so large that it will use more than the maximum gas per block (30M gas units at the time of writing). Consider ordering Orders not only by price, but also keeping in mind the order quantity.  There is no check of whether all the funds pulled from traders are enough to cover the entire rebalance. It is assumed so, and it eventually reverts at the very end when not enough funds can be pulled into the proper contract. Consider checking if a partial rebalance can be achieved with the pulled orders while still keeping acceptable CR and delta values.  If anyone forces ETH into the BullStrategy contract, it will be converted into WETH and transferred into AuctionBull when performing a full rebalance that needs to withdraw from Crab. Additionally, if Eulers current collateral is larger than the target collateral, it will sell the entire WETH balance for USDC in order to repay some debt. The same effect can be achieved by sending USDC to the AuctionBull contract directly. If its higher than Eulers debt, repayments will never be possible on full rebalances when withdrawing from Crab and repaying Eulers debt. It doesnt need to be that large of an amount though, since some USDC will be bought via Uniswap. Consider checking how much unexpected WETH balance AuctionBull has, or implementing a farm function that will allow the owner to sweep the extra WETH.  The borrow operation from Euler can fail if theres not enough USDC available for borrowing. A third party can temporarily borrow enough from the lending pool prior to the rebalance in order to make sure there will never be enough USDC to rebalance the strategy. Theres no way to recover from this, apart from waiting / depositing more collateral from another account in order to increase available USDC to borrow. A similar approach was used recently by an attacker on Aave.  Given the different possibilities of how a rebalance can be forced to revert, consider taking all of them into account for the off-chain orders selection and ordering algorithms, but also when it comes to doing safety checks and operations on-chain.  Also consider always using a private transaction relay service (such as FlashBots) to broadcast the rebalance transaction in order to avoid these potential attacks.  Update: Partially resolved in PR #789 by implementing a farm function that allows the contract owner to retrieve any asset balance from AuctionBull, and expanding the pre-existing farm function within BullStrategy so ETH, WETH and USDC can also be recovered by the owner if necessary.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#potential-dos-in-rebalance-feature", "labels": ["OpenZeppelin"]}, {"title": "Artificial asset balance inflation", "body": "All the contracts in scope are susceptible to an asset balance inflation attack, where a user might send ETH or any ERC20 token directly to the protocol contracts.  For ETH specifically, the only way to do so is by making use of an intermediate contract that uses selfdestruct to force funds directly into any protocol contract, bypassing the receive require statements in place.  farm function can recover stray ERC20 token balances (except the  excluded ones), but there is no general way to withdraw ETH. One interesting side effect from the rebalancing mechanism is that  wrapping the entire ETH balance into  transferring it out of  AuctionBull.  How this can be exploited by a malicious third party is unclear, since the team did not find any attack vector that could exploit that. However, heavily relying on the use of balanceOf(address(this)) in many instances across the codebase might pose some risk of an inflation attack.  Consider whether it is safe to leave the doors open for such scenarios and whether it is relevant to include some mitigations, such as implementing a less strict farm function to be used across all contracts, or having a restricted function to retrieve stuck ETH.  Update: Partially resolved in PR #789 by implementing a farm function that allows the contract owner to retrieve any asset balance from AuctionBull, and expanding the pre-existing farm function within BullStrategy so ETH, WETH and USDC can also be recovered by the owner if necessary.  However, the farm function within BullStrategy should be restricted when attempting to recover ETH if the Squeeth controller is shut down, since all user funds will be sitting in ETH during that time.  Low Severity", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#artificial-asset-balance-inflation", "labels": ["OpenZeppelin"]}, {"title": "Rebalances are subject to sandwich attacks", "body": "Rebalancing transactions are very meaningful events within the strategy lifecycle. Potentially large amounts of WETH and USDC might be involved, and given the necessary use of Uniswap V3 pools in any scenario (apart from OTC auctions) there are two potential scenarios in which placing a transaction before and after the rebalancing might be beneficial for a third party:  In the case of a third party willing to profit off the protocol, a wethLimitPrice is specified in both the leverageRebalance and fullRebalance. This value determines the maximum slippage for each swap, so special care should be placed on the calculation of this value and the tolerance parameters in order to avoid being sandwiched out of this slippage.  A rebalancing event inevitably carries some costs for all the strategy depositors due to slippage, price impact and spread. This cost will always be a percentage of the entire strategy portfolio value. Any investor within the strategy can sandwich the rebalance transaction in order to exit before it happens, and re-enter it immediately afterwards. The incurred cost of doing so might be much lower than the rebalancing costs, so if executed correctly, they would avoid that extra cost at the expense of the rest of the depositors. Consider adding some restrictions in the depositing and withdrawing frequency (i.e. an individual user cannot deposit and withdraw on the same block).  In both cases, consider if these are relevant risks and always relay the rebalancing transaction through a private relay like FlashBots in order to avoid undesired reverts due to DoS attacks, and unexpected losses in slippage due to sandwich attacks.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#rebalances-are-subject-to-sandwich-attacks", "labels": ["OpenZeppelin"]}, {"title": "Duplicated code", "body": "There are instances of duplicated code within the codebase. This can lead to issues later on in the development lifecycle, and leaves the project more prone to the introduction of errors. Errors can inadvertently be introduced when functionality changes are not replicated across all instances of code that should be identical. One example of duplicated code is the function _calcWsqueethToMintAndFee which is defined both in the FlashBull and AuctionBull contracts.  Instead of duplicating code, consider having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#duplicated-code", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "Throughout the codebase there are several parts that do not have docstrings. Some examples are:  Line 408 of the AuctionBull contract  Line 96 of the LeverageBull contract  Line 105 of the LeverageBull contract  Line 121 of the LeverageBull contract  Additionally, the AuctionBull NatSpec documentation is incorrect, since it is referencing the FlashBull contract instead.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in PR #775, PR #776, PR #818 and PR #822.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Missing error messages in require statements", "body": "Throughout the codebase there are require statements that lack error messages. For instance:  The require statement on line 202 of AuctionBull.sol  The require statement on line 126 of FlashBull.sol  Contrast this with the BullStrategys identical line 90 require statement, which includes an error message.  Consider including specific, informative error messages in all require statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied. This should also improve consistency across several contracts.  Update: Resolved in PR #776.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#missing-error-messages-in-require-statements", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed parameters", "body": "Throughout the codebase, events do not have their parameters indexed. Some examples are:  line 139 of the AuctionBull contract  line 54 of the BullStrategy contract  line 101 of the FlashBull contract  line 59 of the LeverageBull contract  Consider indexing event parameters to avoid hindering off-chain services searching and filtering for specific events.  Update: Resolved in PR #748.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#lack-of-indexed-parameters", "labels": ["OpenZeppelin"]}, {"title": "Outdated solidity versions", "body": "Throughout the codebase there are pragma statements that use an outdated version of Solidity. For instance:  The pragma statement on line 2 of the AuctionBull contract  The pragma statement on line 2 of the BullStrategy contract  The pragma statement on line 2 of the EmergencyShutdown contract  The pragma statement on line 2 of the FlashBull contract  The pragma statement on line 2 of the LeverageBull contract  Consider taking advantage of the latest Solidity version to improve the overall readability and security of the codebase.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#outdated-solidity-versions", "labels": ["OpenZeppelin"]}, {"title": "Unused function parameter", "body": "Within the AuctionBull contract at the _pushFundsFromOrders function, the _isDepositingInCrab parameter is not used.  To improve the overall clarity, intentionality, and readability of the codebase, consider removing any unused function parameters.  Update: Resolved in PR #779.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#unused-function-parameter", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "Throughout the codebase, imports on the following lines are unused and could be removed:  Line 10 of the EmergencyShutdown.sol contract  Line 10 of the FlashBull.sol contract  Line 5 of the IBullStrategy.sol contract (eventually consider if the defined interface should extend from the imported one)  Consider removing unused imports to avoid confusion that could reduce the overall clarity and readability of the codebase.  Update: Resolved in commit ab8226c.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent event emission parameters", "body": "Throughout the codebase, some inconsistencies were found regarding event emission parameters.  Events presenting an incorrect parameter ordering include:  The SetCap event has its old and new value parameters in a different order than the SetShutdownContract event. This causes the setShutdownContract function to emit the event with the parameters in the wrong order.  This different parameter ordering issue also occurs within AuctionBulls setAuctionManager event.  Consider emitting both events with the same parameter ordering for consistency, and to avoid hindering the task of off-chain event analysis.  Additionally, events missing important parameters include:  When using the flashDeposit and flashWithdraw functions, both the Deposit and Withdraw events are fired specifying msg.sender as the depositor, which will always resolve to the FlashBull contract address.  The specific events FlashDeposit and FlashWithdraw do not contain any information about the actual user performing the flash deposit / withdrawal.  Consider refactoring the event emission logic for deposits and withdrawals so that information is complete and accurate.  Update: Partially resolved in PR #785. The Opyn team updated the specified setter events to follow a consistent parameter ordering, and added a parameter to both the FlashDeposit and FlashWithdraw events to indicate the user who performed the action. However, both the Deposit and Withdraw events still do not contain information about the original user, since they will always emit the FlashBull contract address as the from and to parameters respectively.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#inconsistent-event-emission-parameters", "labels": ["OpenZeppelin"]}, {"title": "Not checking ERC20 transfers return parameter", "body": "In the LeverageBull contract, there are several calls to the EIP20 standard transfer and transferFrom. These calls return a bool parameter that is not checked. In the scenarios that the team explored, this is not a security issue since every token involved provides reverts in the code for failing transfers.  However, as new tokens may be integrated in the future, usage of this pattern could cause issues because new tokens could lack this reverting behavior.  Consider always using the SafeERC20 contract from OpenZeppelin to wrap for such calls, or evaluating the return parameter to be true.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#not-checking-erc20-transfers-return-parameter", "labels": ["OpenZeppelin"]}, {"title": "Unnamed return parameters", "body": "There are many occurrences in the codebase where returned parameters are not named. Some examples are:  In the _calcWsqueethToMintAndFee, _calcSharesToMint and _getCrabVaultDetails functions of the FlashBull contract  In the _getCurrentDeltaAndCollatRatio, getCurrentDeltaAndCollatRatio, _calcWPowerPerpAmountFromCrab and _calcWsqueethToMintAndFee functions of the AuctionBull contract  Consider adding and using named return parameters to improve explicitness and readability.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#unnamed-return-parameters", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission for sensitive actions", "body": "In contrast to the Crab Strategy, Bull Strategy withdrawals performed when Squeeth contracts have been shutdown do not emit events.  Consider emitting descriptive events in order to properly track these sensitive actions.  Update: Resolved in PR #748.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#lack-of-event-emission-for-sensitive-actions", "labels": ["OpenZeppelin"]}, {"title": "Misleading parameter passing", "body": "When depositing into the strategy directly with Crab tokens, there is a mixed use of the variables _crabAmount and bullToMint. The first one refers to the amount of Crab tokens being deposited, while the latter represents the amount of Bull tokens to be minted.  There are a few occurrences around the code where these two variables are used indistinctly:  When total Bull supply is zero, the variable passed to the _mint function is _crabAmount, when it should be bullToMint.  When calling _leverageDeposit, the documentation states that the second parameter should be the amount of Crab tokens being deposited, but the passed parameter is bullToMint.  Even though these variables might have the exact same value, using them indistinctly hinders readability and is error-prone. Consider using the appropriate variable each time.  Update: Resolved in PR #778.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#misleading-parameter-passing", "labels": ["OpenZeppelin"]}, {"title": "Inconsistency in quote currency setup", "body": "Upon LeverageBull construction, USDC is defined as a state variable that will hold the quoteCurrency for the debt component within Euler. Its address is fetched via calling the quoteCurrency function within the controller, but the decimals difference between WETH and USDC is hardcoded to be 12 as a constant.  Within the Controller contract, it is not assumed nor stated that the quote currency is USDC.  Consider dynamically fetching the number of decimals of the quote currency and calculating the decimals difference against WETH.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#inconsistency-in-quote-currency-setup", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent coding style", "body": "The codebase presents some code style inconsistencies.  _checkFullRebalanceClearingPrice function is using  _checkRebalanceLimitPrice function.  Consider using the same math functions for both situations.  Update: Resolved in PR #780.  Enum null values are used with a meaningful purpose  Throughout the codebase, every enum definition matches the value 0 to some meaningful state.  Some examples can be found within the AuctionBull and FlashBull contracts.  When a variable using those enums is not set, they will default to the null value, potentially causing confusion over whether it is an actual value or a null state.  Consider using NULL as the first enum state in order to avoid using a meaningful state on null values.  Gas optimizations  Notable gas cost improvements were found throughout the codebase. Some examples include:  Order struct is not efficiently packed.  When the auction contract performs a fullRebalance in order to withdraw ETH from Crab, oSQTH is bought from traders, pulled into AuctionBull and then pulled from BullStrategy, which in turn approves CrabStrategy to pull them. Finally, CrabStrategy ends up executing a transferFrom to get them. Trader funds could be pulled directly into CrabStrategy to get significant gas savings on auctions.  When performing a leverageRebalance, given isSellingUsdc = true, WETH tokens are transferred from the Uniswap pool into the AuctionBull contract, only to have them pulled from BullStrategy so they can be deposited within Euler.  Consider refactoring the code, so that intermediate transfers and approvals can be removed in order to get significant gas savings.  Update: Partially resolved in PR #744 by granting infinite approval for the relevant tokens on both FlashBull and BullStrategy constructors instead of on every individual deposit and withdrawal. Additionally, a small gas optimization was added in PR #743 to avoid repeating the same function call several times. Notice that each individual point above still applies. Moreover, having infinite allowances must be weighted against potential bugs introduced in the future that might take advantage of such approvals.  Typo in event parameter names  In both the TransferToOrder and TransferFromOrder events, the second parameter should be named quantity instead of quanity.  Update: Resolved in PR #748.  Conclusions  No high or critical vulnerabilities have been found. Even though the system presents complex integrations and a non-trivial design, we are happy to see robustness and prevention of small edge cases and scenarios. Given the overall complexity and the out-of-scope parts of the project, we wanted to explicitly highlight the sensitive out-of-scope parts of the system that need special attention. Finally, we appreciated that the project came with a comprehensive test suite, and that the team provided detailed and specific documentation.  Update: The team resolved the majority of the issues and refactored the code, additionally changing the name of some contracts. We recommend ensuring that the new changes are properly tested and that overall coverage is not affected.  Appendix  Monitoring Recommendations  BullStrategy is a complex trading strategy that needs periodic rebalancing. Since these rebalancing events are critical for the strategy to work as expected, we recommend the following sensitive actions to be monitored:  Monitor all restricted functions (functions only called by the multisig owner) to ensure that all actions are authorized by the team and that the values they set are in line with their expectations (especially those related to the emergency shutdown protocol).  Monitor the functions flashDeposit, deposit, flashWithdraw and withdraw for large deposits / withdrawals.  This can also be extended by all privileged roles actions, so that the community can always check for unexpected special actions.  The liquidity pools used by the project are normal Uniswap v3 pools, and the TWAP oracle is used to retrieve price data from them. Monitoring pool activities for abnormal behaviours might be useful for the team in order to prevent unwanted scenarios in high volatility or manipulation attempts.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#inconsistent-coding-style", "labels": ["OpenZeppelin"]}, {"title": "Enum null values are used with a meaningful purpose", "body": "Enum null values are used with a meaningful purpose", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#enum-null-values-are-used-with-a-meaningful-purpose", "labels": ["OpenZeppelin"]}, {"title": "Gas optimizations", "body": "Notable gas cost improvements were found throughout the codebase. Some examples include:  Order struct is not efficiently packed.  When the auction contract performs a fullRebalance in order to withdraw ETH from Crab, oSQTH is bought from traders, pulled into AuctionBull and then pulled from BullStrategy, which in turn approves CrabStrategy to pull them. Finally, CrabStrategy ends up executing a transferFrom to get them. Trader funds could be pulled directly into CrabStrategy to get significant gas savings on auctions.  When performing a leverageRebalance, given isSellingUsdc = true, WETH tokens are transferred from the Uniswap pool into the AuctionBull contract, only to have them pulled from BullStrategy so they can be deposited within Euler.  Consider refactoring the code, so that intermediate transfers and approvals can be removed in order to get significant gas savings.  Update: Partially resolved in PR #744 by granting infinite approval for the relevant tokens on both FlashBull and BullStrategy constructors instead of on every individual deposit and withdrawal. Additionally, a small gas optimization was added in PR #743 to avoid repeating the same function call several times. Notice that each individual point above still applies. Moreover, having infinite allowances must be weighted against potential bugs introduced in the future that might take advantage of such approvals.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Typo in event parameter names", "body": "In both the TransferToOrder and TransferFromOrder events, the second parameter should be named quantity instead of quanity.  Update: Resolved in PR #748.", "html_url": "https://blog.openzeppelin.com/opyn-bull-strategy-contracts-audit#typo-in-event-parameter-names", "labels": ["OpenZeppelin"]}, {"title": "Funds held in ETHAdapter can be drained by anyone", "body": "Funds held in ETHAdapter can be drained by anyone", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#funds-held-in-ethadapter-can-be-drained-by-anyone", "labels": ["OpenZeppelin"]}, {"title": "Incorrect assetsOf calculation", "body": "Incorrect assetsOf calculation", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#incorrect-assetsof-calculation", "labels": ["OpenZeppelin"]}, {"title": "Incorrect recalculation of shares during deposit", "body": "When a user deposits to the STETHVault, the amount of shares they are expected to receive is recalculated after stETH is transferred from the depositor to the vault. Since the vaults idle assets have not yet been updated, the transferred stETH is incorrectly included in the conversion calculation. This may cause the spentCap to be incorrectly updated and the Deposit event to emit a smaller value of shares than what will actually be issued when the deposit is processed.  totalIdleAssets decrement and _restoreCap logic in the  refund function in  Update: Resolved in PR#118, with commit db0c86daa2d52d1f92e59ae852cade40be351b82 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#incorrect-recalculation-of-shares-during-deposit", "labels": ["OpenZeppelin"]}, {"title": "Negative rebase of stETH could prevent a round from ending", "body": "When a round ends, the amount of underlying assets currently in the vault is subtracted from the amount of assets the vault contained in the previous round. This calculation assumes a positive yield, but the underlying asset stETH is able to rebase in both a positive and negative direction due to the potential for slashing. In the case where Lido is slashed, totalAssets can be less than lastRoundAssets. Consequently, the subtraction would cause an underflow, which would prevent the controller from being able to end the round until totalAssets is greater than lastRoundAssets.  Consider placing the logic that calculates and transfers any investment yield generated by the vault in an if statement that only occurs when totalAssets is greater than lastRoundAssets. This allows any yield generated from the options strategy to still be transferred to the vault and prevents the accrued interest arithmetic from reverting.  Update: Resolved in PR#100, with commit a756b4d8ead7fce109e9daf51c218eb952454487 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#negative-rebase-of-steth-could-prevent-a-round-from-ending", "labels": ["OpenZeppelin"]}, {"title": "Non-standard ERC-4626 vault functionality", "body": "There are multiple locations in the ERC-4626 BaseVault that do not conform to ERC-4626 specifications:  previewWithdraw does not include withdrawal fees  maxDeposit does not return 0 when deposits are disabled  maxMint does not return 0 when withdrawals are disabled  maxWithdraw does not return 0 when withdrawals are disabled  Consider correcting the above issues to meet the ERC-4626 specifications, allowing future vault developers to expect certain protocol behaviors.  Update: Partially resolved in PR#132, with commit 87e7de33e0a7a699263624641305a8e06ec178b2 being the last one added. The issues regarding maxDeposit, maxMint, maxWithdraw and maxRedeem have been resolved and these functions now return 0 when deposits or withdrawals are disabled. The previewWithdraw function does not include withdrawal fees. However, we note that there is ambiguity in how fees on withdrawal should be implemented according to EIP-4626, and that previewWithdraw does return the correct number of shares that would be burned in a withdraw call. Docstrings have been added to previewWithdraw and withdraw to inform integrators of the presence of withdrawal fees.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#non-standard-erc-4626-vault-functionality", "labels": ["OpenZeppelin"]}, {"title": "Phantom permit functions callable from child vault", "body": "BaseVault implements a  mintWithPermit and  depositWithPermit function, even though the vaults underlying asset is intended to be  stETH, which does not have a  STETHVault to explicitly revert when called. In the  fallback function. However, this both provides a potentially inaccurate error message and is subject to different behavior if the stETH contract undergoes an upgrade. Further, tokens containing  phantom permit functions are known to exist, which would not revert on failure. Setting a precedent of explicitly reverting when calling unsupported  Update: Resolved in PR#123, with commit fd3ca22cedc414f9e6f5fbed34ad725ca509bff2 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#phantom-permit-functions-callable-from-child-vault", "labels": ["OpenZeppelin"]}, {"title": "Refunds will be over-credited in a negative yield event", "body": "Deposits added to the queue are point-in-time stETH balance amounts. The stETH token rebases to account for yield, and in the event of slashing, may be subject to a negative yield. In the event that a stETH token rebase is negative between the time a user deposits and calls for a refund, the vault will over credit the user by the rebase difference.  Consider handling the deposits in the queue in stETH share amounts to account for rebase changes on refunds.  Update: Acknowledged, not resolved. Pods Finance team stated:  Although we agree with the issue, we wont prioritize it right now. It would require us to implement a secondary share queue system that would require few parts of the code to change. We will prioritize this issue in a future version.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#refunds-will-be-over-credited-in-a-negative-yield-event", "labels": ["OpenZeppelin"]}, {"title": "Vault can be placed back into vulnerable low supply state", "body": "The BaseVault contract inherits an issue common to ERC-4626 implementations known as the donation attack. When shares are minted to users, they are calculated by multiplying the deposited assets by a ratio of the existing shares to current assets. The result of this calculation is then rounded down, following the ERC specifications. The problem arises when the value of totalAssets is manipulated to induce unfavorable rounding for new users depositing into the vault at the benefit of users who already own shares of the vault. Since totalAssets is calculated using the balance of underlying assets, it can be manipulated via direct transfers or donations of stETH to the vault. The most extreme example of this attack could occur when a user is the first to enter the vault, because when supply is sufficiently low, the capital requirement to perform an economically beneficial donation attack is also low.  The Pods Finance team is aware of this issue and has taken measures to make the attack more difficult to execute, such as by creating a minimum initial deposit requirement. While this does successfully enforce a minimum initial deposit for the first round, it does not prevent the total supply of shares from falling below the safety threshold throughout the life of the vault. For example, if an early user put forth the minimum initial deposit and then the rest of the queue held dust amounts, the same user could withdraw far below the minimum initial deposit amount in the next round and the vault would be back in a vulnerable state.  Consider taking steps to ensure the supply of vault shares does not go below the minimum initial deposit amount. One way to do this would be for the Pods Finance team to contribute their own initial deposit to the vault that they can guarantee will not be withdrawn. Discussions around other techniques used to protect from this attack can be seen in issue 3706 of the openzeppelin-contracts repository.  Update: Acknowledged, will resolve. Pods Finance team stated:  Pods Finance will follow the recommendations and will contribute their own initial deposit to the vault that they can guarantee will not be withdrawn.  Low Severity", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#vault-can-be-placed-back-into-vulnerable-low-supply-state", "labels": ["OpenZeppelin"]}, {"title": "Magic numbers are used", "body": "Although constants are generally used correctly throughout the codebase, there are a few occurrences of literal values being used with unexplained meaning inside of ETHAdapter. For example, the following blocks use hardcoded values:  In the constructor, the pools coins function is called with arguments 0 and 1.  In the functions convertToETH and convertToSTETH, the pools get_dy function is called with arguments 0 and 1 with no explanation.  In the deposit function, the pools exchange function is called with arguments 0 and 1 without explanation.  To improve the codes readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. Consider adding an inline comment explaining how the magic numbers are calculated or why they are chosen for complex values.  Update: Resolved in PR#103, with commit 87e7de33e0a7a699263624641305a8e06ec178b2 being the last one added.  Misplaced totalAssets function implementation  STETHVault contract implementation, the  totalAssets function is overridden and updated in order to account for the assets that have been transferred to the vault contract but have not  been processed yet. However, the accounting for idle assets within a vault is primarily implemented in the  BaseVault contract. Consequently, if a vault were to inherit the  default implementation of  Consider moving the implementation of totalAssets to the BaseVault contract. totalAssets can additionally be marked virtual so contracts that inherit BaseVault can optionally choose to implement their own functionality.  Update: Resolved in PR#117, with commit 2a82f1126c14c713b19a08cdf32690e52bb4c43d being the last one added.  Missing docstrings  Throughout the codebase, there are several parts that do not have docstrings. For instance:  Line 5 in IConfigurationManager  Lines 11-28 in IConfigurationManager  Line 5 in ICurvePool  Lines 12-19 in ICurvePool  Line 8 in IVault  Line 5 in CastUint  Line 7 in Capped  Line 11 in ETHAdapter  Line 28 in ETHAdapter  Line 32 in ETHAdapter  Line 40 in ETHAdapter  Line 52 in ETHAdapter  Line 66 in ETHAdapter  Line 77 in ETHAdapter  Line 91 in ETHAdapter  Line 11 in Migration  Line 26 in Migration  Line 47 in Migration  This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security but also correctness. Additionally, docstrings improve readability and maintenance.  Consider thoroughly inserting documentation above each contract, interface, library, function, state variable, event, and custom error. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in PR#122, with commit 32df444b20be010b5f1da7f42a69fcbeec61fdda being the last one added.  Missing ConfigurationManager check during vault initialization  constructor in the  state variable is set. However, there is no check to ensure the passed-in  VAULT_CONTROLLER parameter set for the vault contract that is being created. Having the  Consider adding a check in the constructor of the BaseVault contract to ensure calling getParameter with the address of the vault being created, and VAULT_CONTROLLER does not return the zero address.  Update: Acknowledged, not resolved. Pods Finance team stated:  Instead of enforcing it at the code level, that would require us to deploy the vault using CREATE2 in order to know in advance the vault address, we will monitor the VAULT_CONTROLLER variable to make sure that it was set after the deploy.  Share price calculations should never result in a zero value  The share price represents the amount of stETH needed to mint one vault share. When the number of vault shares that has been minted thus far is zero, the share price should simply be the ratio of the underlying assets decimals to the vaults decimals. There were multiple share price calculations in the STETHVault contract that incorrectly returned zero in this scenario:  the lastSharePrice instantiation in the _afterRoundStart function  the currentSharePrice calculation in the _afterRoundStart function  the lack of endSharePrice calculation when supply is zero in the _afterRoundEnd function  the startSharePrice calculation in the _afterRoundEnd function  convertToAssets function that is inherited from OpenZeppelins  ERC-4626 contract instead of the manual calculations, as it contains logic to handle this edge case. Additionally, when instantiating  Update: Resolved in PR#109, with commit 88e0b18fa497ce86194ab5ac8b9cc346ecfb3b75 being the last one added.  The sharePrice function should not revert  sharePrice function in the  calculates the amount of stETH needed in order to mint one vault share. However, the calculation does not take into account that  Consider calling convertToAssets(10**sharePriceDecimals) in the sharePrice function instead of using the manual calc", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#magic-numbers-are-used", "labels": ["OpenZeppelin"]}, {"title": "Misplaced totalAssets function implementation", "body": "Misplaced totalAssets function implementation", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#misplaced-totalassets-function-implementation", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "Throughout the codebase, there are several parts that do not have docstrings. For instance:  Line 5 in IConfigurationManager  Lines 11-28 in IConfigurationManager  Line 5 in ICurvePool  Lines 12-19 in ICurvePool  Line 8 in IVault  Line 5 in CastUint  Line 7 in Capped  Line 11 in ETHAdapter  Line 28 in ETHAdapter  Line 32 in ETHAdapter  Line 40 in ETHAdapter  Line 52 in ETHAdapter  Line 66 in ETHAdapter  Line 77 in ETHAdapter  Line 91 in ETHAdapter  Line 11 in Migration  Line 26 in Migration  Line 47 in Migration  This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security but also correctness. Additionally, docstrings improve readability and maintenance.  Consider thoroughly inserting documentation above each contract, interface, library, function, state variable, event, and custom error. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Resolved in PR#122, with commit 32df444b20be010b5f1da7f42a69fcbeec61fdda being the last one added.  Missing ConfigurationManager check during vault initialization  constructor in the  state variable is set. However, there is no check to ensure the passed-in  VAULT_CONTROLLER parameter set for the vault contract that is being created. Having the  Consider adding a check in the constructor of the BaseVault contract to ensure calling getParameter with the address of the vault being created, and VAULT_CONTROLLER does not return the zero address.  Update: Acknowledged, not resolved. Pods Finance team stated:  Instead of enforcing it at the code level, that would require us to deploy the vault using CREATE2 in order to know in advance the vault address, we will monitor the VAULT_CONTROLLER variable to make sure that it was set after the deploy.  Share price calculations should never result in a zero value  The share price represents the amount of stETH needed to mint one vault share. When the number of vault shares that has been minted thus far is zero, the share price should simply be the ratio of the underlying assets decimals to the vaults decimals. There were multiple share price calculations in the STETHVault contract that incorrectly returned zero in this scenario:  the lastSharePrice instantiation in the _afterRoundStart function  the currentSharePrice calculation in the _afterRoundStart function  the lack of endSharePrice calculation when supply is zero in the _afterRoundEnd function  the startSharePrice calculation in the _afterRoundEnd function  convertToAssets function that is inherited from OpenZeppelins  ERC-4626 contract instead of the manual calculations, as it contains logic to handle this edge case. Additionally, when instantiating  Update: Resolved in PR#109, with commit 88e0b18fa497ce86194ab5ac8b9cc346ecfb3b75 being the last one added.  The sharePrice function should not revert  sharePrice function in the  calculates the amount of stETH needed in order to mint one vault share. However, the calculation does not take into account that  Consider calling convertToAssets(10**sharePriceDecimals) in the sharePrice function instead of using the manual calculation, as convertToAssets handles the zero shares edge case.  Update: Resolved in PR#104, with commit 9264f9dc5a5676da381dc6e86768971ffd5415d8 being the last one added.  spentCap can be skewed due to rebasing tokens  Capped contract that is used to indicate how many shares have been minted. This variable is first updated when a user  deposits. However, shares are not issued for a user until their deposit has been  processed. The share conversion rate is subject to change during that time-frame due to stETH being a rebasing token. Therefore, when  _restoreCap is called during a withdraw, the number of shares accounted for in  Consider adding spentCap to the ConfigurationManager as a parameter, and updating calculations in Capped to add and subtract to that value instead of using a local state variable. This would allow the owner of the ConfigurationManager contract to adjust spentCap if the skew becomes too large.  Update: Acknowledged, not resolved. Pods Finance team stated:  The cap is a temporary feature. As of now, it is possible to workaround this issue and increase the cap through the ConfigurationManager if needed.  Use of deprecated function for setting token allowances  Throughout the codebase there were multiple locations where the deprecated safeApprove function was used to set allowances:  Line 352 in BaseVault  Line 35 in Migration  Line 57 in Migration  Line 43 in ETHAdapter  Line 112 in ETHAdapter  If in any of these locations an allowance is carried over for more than the duration of a transaction, safeApprove may revert in subsequent transactions. Consider replacing the instances of safeApprove with the recommended safeIncreaseAllowance or safeDecreaseAllowance instead.  Update: Res", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Missing ConfigurationManager check during vault initialization", "body": "Missing ConfigurationManager check during vault initialization", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#missing-configurationmanager-check-during-vault-initialization", "labels": ["OpenZeppelin"]}, {"title": "Share price calculations should never result in a zero value", "body": "The share price represents the amount of stETH needed to mint one vault share. When the number of vault shares that has been minted thus far is zero, the share price should simply be the ratio of the underlying assets decimals to the vaults decimals. There were multiple share price calculations in the STETHVault contract that incorrectly returned zero in this scenario:  the lastSharePrice instantiation in the _afterRoundStart function  the currentSharePrice calculation in the _afterRoundStart function  the lack of endSharePrice calculation when supply is zero in the _afterRoundEnd function  the startSharePrice calculation in the _afterRoundEnd function  convertToAssets function that is inherited from OpenZeppelins  ERC-4626 contract instead of the manual calculations, as it contains logic to handle this edge case. Additionally, when instantiating  Update: Resolved in PR#109, with commit 88e0b18fa497ce86194ab5ac8b9cc346ecfb3b75 being the last one added.  The sharePrice function should not revert  sharePrice function in the  calculates the amount of stETH needed in order to mint one vault share. However, the calculation does not take into account that  Consider calling convertToAssets(10**sharePriceDecimals) in the sharePrice function instead of using the manual calculation, as convertToAssets handles the zero shares edge case.  Update: Resolved in PR#104, with commit 9264f9dc5a5676da381dc6e86768971ffd5415d8 being the last one added.  spentCap can be skewed due to rebasing tokens  Capped contract that is used to indicate how many shares have been minted. This variable is first updated when a user  deposits. However, shares are not issued for a user until their deposit has been  processed. The share conversion rate is subject to change during that time-frame due to stETH being a rebasing token. Therefore, when  _restoreCap is called during a withdraw, the number of shares accounted for in  Consider adding spentCap to the ConfigurationManager as a parameter, and updating calculations in Capped to add and subtract to that value instead of using a local state variable. This would allow the owner of the ConfigurationManager contract to adjust spentCap if the skew becomes too large.  Update: Acknowledged, not resolved. Pods Finance team stated:  The cap is a temporary feature. As of now, it is possible to workaround this issue and increase the cap through the ConfigurationManager if needed.  Use of deprecated function for setting token allowances  Throughout the codebase there were multiple locations where the deprecated safeApprove function was used to set allowances:  Line 352 in BaseVault  Line 35 in Migration  Line 57 in Migration  Line 43 in ETHAdapter  Line 112 in ETHAdapter  If in any of these locations an allowance is carried over for more than the duration of a transaction, safeApprove may revert in subsequent transactions. Consider replacing the instances of safeApprove with the recommended safeIncreaseAllowance or safeDecreaseAllowance instead.  Update: Resolved in PR#105, with commit 7e6bdbcb3d1fff657c81810750521fa0278e4a07 being the last one added.  Notes & Additional Information  Inconsistent use of named return variables  Named return variables are a way to declare variables that are meant to be used inside a function body and returned at the end of the function. This is an alternative to the explicit return statement to provide function outputs.  Throughout the codebase, there are instances of inconsistent use of named return variables:  The deposit function in ETHAdapter has a named return variable declared that is not used.  The startRound function in IVault declares a named return variable, while its implementation in BaseVault does not.  The handleMigration function in IVault declares a named return variable, while its implementation in BaseVault does not.  Consider improving consistency and either using or removing any unused named return variables.  Update: Resolved in PR#110, with commit f2459432bbdc423c15c501cd277d72ae4fdefd70 being the last one added.  Inflexible initial deposit  The current minimum initial deposit is defined as 10**decimals of the underlying token. This strategy may be inflexible for certain edge-case tokens. For example, a vault that has an underlying asset of wBTC would require an initial deposit of $16,600 at todays market price. Additionally, if a vault were to have an underlying asset with very few decimals, it is possible that the capital requirement intended to prevent a donation attack may be insufficient.  If the Pods Finance team ever intends to offer vaults with wBTC or other edge case tokens as underlying assets, consider allowing the minimum initial deposit to be configurable at deployment.  Update: Acknowledged, not resolved. Pods Finance team stated:  As stated above, Pods Finance will contribute their own initial deposit to the vault that they can guarantee will not be withdrawn. Depositing one whole wBTC wont be a problem. For the small decimals tokens, Po", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#share-price-calculations-should-never-result-in-a-zero-value", "labels": ["OpenZeppelin"]}, {"title": "The sharePrice function should not revert", "body": "The sharePrice function should not revert", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#the-shareprice-function-should-not-revert", "labels": ["OpenZeppelin"]}, {"title": "spentCap can be skewed due to rebasing tokens", "body": "spentCap can be skewed due to rebasing tokens", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#spentcap-can-be-skewed-due-to-rebasing-tokens", "labels": ["OpenZeppelin"]}, {"title": "Use of deprecated function for setting token allowances", "body": "Throughout the codebase there were multiple locations where the deprecated safeApprove function was used to set allowances:  Line 352 in BaseVault  Line 35 in Migration  Line 57 in Migration  Line 43 in ETHAdapter  Line 112 in ETHAdapter  If in any of these locations an allowance is carried over for more than the duration of a transaction, safeApprove may revert in subsequent transactions. Consider replacing the instances of safeApprove with the recommended safeIncreaseAllowance or safeDecreaseAllowance instead.  Update: Resolved in PR#105, with commit 7e6bdbcb3d1fff657c81810750521fa0278e4a07 being the last one added.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#use-of-deprecated-function-for-setting-token-allowances", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent use of named return variables", "body": "Named return variables are a way to declare variables that are meant to be used inside a function body and returned at the end of the function. This is an alternative to the explicit return statement to provide function outputs.  Throughout the codebase, there are instances of inconsistent use of named return variables:  The deposit function in ETHAdapter has a named return variable declared that is not used.  The startRound function in IVault declares a named return variable, while its implementation in BaseVault does not.  The handleMigration function in IVault declares a named return variable, while its implementation in BaseVault does not.  Consider improving consistency and either using or removing any unused named return variables.  Update: Resolved in PR#110, with commit f2459432bbdc423c15c501cd277d72ae4fdefd70 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#inconsistent-use-of-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Inflexible initial deposit", "body": "The current minimum initial deposit is defined as 10**decimals of the underlying token. This strategy may be inflexible for certain edge-case tokens. For example, a vault that has an underlying asset of wBTC would require an initial deposit of $16,600 at todays market price. Additionally, if a vault were to have an underlying asset with very few decimals, it is possible that the capital requirement intended to prevent a donation attack may be insufficient.  If the Pods Finance team ever intends to offer vaults with wBTC or other edge case tokens as underlying assets, consider allowing the minimum initial deposit to be configurable at deployment.  Update: Acknowledged, not resolved. Pods Finance team stated:  As stated above, Pods Finance will contribute their own initial deposit to the vault that they can guarantee will not be withdrawn. Depositing one whole wBTC wont be a problem. For the small decimals tokens, Pods Finance team will deposit an initial deposit bigger than the minimum.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#inflexible-initial-deposit", "labels": ["OpenZeppelin"]}, {"title": "Lack of indexed parameters", "body": "The VaultAllowanceSet event in IConigurationManager does not have the newVault parameter indexed.  Consider indexing event parameters to avoid hindering the task of off-chain services searching and filtering for specific events.  Update: Resolved in PR#105, with commit 7e6bdbcb3d1fff657c81810750521fa0278e4a07 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#lack-of-indexed-parameters", "labels": ["OpenZeppelin"]}, {"title": "Lack of zero address checks", "body": "Throughout the codebase, there are several functions where the zero address could be passed as an argument but is not explicitly checked:  migrate function in BaseVault.sol  migrate function in Migration.sol  migrateWithPermit function in Migration.sol  setVaultMigration function in ConfigurationManager.sol  Zero address checks prevent operations from potentially occurring on the zero address, and allows developers to return clear error messages instead of having a function fail in a less-obvious way.  Consider adding zero address checks to the above functions.  Update: Resolved in PR#124 and PR#129, with commits bb7be233253bb96589486cc700a9889f716e34a1 and 771aa5bf7453405d91310035be65eab698ccfdb1 being the last ones added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#lack-of-zero-address-checks", "labels": ["OpenZeppelin"]}, {"title": "Mismatched event parameters", "body": "Multiple event definitions contain uint256 parameters for roundId, but the value emitted is a uint32:  RoundStarted in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  RoundEnded in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  DepositProcessed in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  DepositRefunded in IVault declares a uint256 parameter for roundId but emits the uint32 vaultState.currentRoundId.  For clearer code and potential gas savings, consider aligning variable types within event definitions and event emissions.  Update: Resolved in PR#113, with commit 135c912b843b64937f9eb4069e1c0fc8b312cd80 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#mismatched-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit imports are used", "body": "inside the codebase, which reduces code readability and could lead to conflicts between the names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Within ConfigurationManager, global imports are being used. For instance:  Line 5 in ConfigurationManager  Line 6 in ConfigurationManager  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Resolved in PR#102, with commit b059e07c90ae62b4a37ffd596ba05bcd997a16b8 being the last one added.  Use of uint32 for round timestamp limits vault lifetime  rounds end by placing the current  can begin. When  Consider expanding the round timestamp to a uint40 or larger to drastically increase the shelf life of the BaseVault.  Update: Resolved in PR#107, with commit d26b0ee274f4cec28fad2a9f0df3e340ee8fc887 being the last one added.  Conclusions  No critical or high severity issues were found in this second audit. Several medium severity issues were discovered, many of which stemmed from complications related to directly integrating with the rebasable stETH token. Overall, the codebase shows a marked improvement from the first audit. The Pods Finance team was able to leverage pre-existing OpenZeppelin contract implementations and other libraries as part of their fixes for the first audit, which helped reduce the attack surface of their contracts. Additional recommendations have been proposed to further reduce the attack surface of the contracts.  Appendix  Monitoring Recommendation  While audits help in identifying code-level issues in the current implementation and potentially the code deployed to production, we encourage the Pods Finance team to consider incorporating monitoring activities in the production environment. Ongoing monitoring of deployed contracts helps in identifying potential threats and issues that may affect the protocol. With the goal of providing a complete security assessment, we want to raise several actions addressing trust assumptions and out-of-scope components that may benefit from on-chain monitoring:  Minimum balance invariant of the stETHvv contract: consider monitoring the underlying balance of stETH in the vault contract to ensure it is always greater than or equal to the MIN_INITIAL_ASSETS balance. This can be done on a per-block basis by checking the stETH balance of the vault at a previous block number with the stETH balance of the vault at the most recent block number.  Low liquidity in the ETH/stETH Curve pool: consider monitoring the liquidity in the ETH/stETH Curve pool to ensure that the ETHAdapter contract does not encounter a situation where exchanges are failing or large slippage is occurring due to low liquidity in the corresponding Curve pool.  Negative rebase event of stETH due to the potential for Lido to be slashed: consider monitoring the balance of stETH in the stETHvv contract along with Withdraw, EndRoundData, and DepositRefunded events. The respective events indicate when stETH is transferred from the vault. If the balance of the contract were to decrease not as a direct result of any of the aforementioned events, it could be an indication of a negative stETH rebase event.  Privileged role activities such as those performed by the Owner of the ConfigurationManager contract, the controller of the vault, and the investor of the vault: consider monitoring events related, but not limited to, ownership changes, vault configuration modifications, and transfers initiated by the investor address to somewhere other than the vault as these may signal private key compromise of a privileged role.  Additionally, the team may wish to explore options for monitoring Lido node status so that they may be able to predict if a negative stETH rebase will occur in the near future.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Use of uint32 for round timestamp limits vault lifetime", "body": "Use of uint32 for round timestamp limits vault lifetime", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-2#use-of-uint32-for-round-timestamp-limits-vault-lifetime", "labels": ["OpenZeppelin"]}, {"title": "DepositQueue can become permanently locked", "body": "STETHVault, they first join a  DepositQueue. While being part of the  refund their deposit or wait until the round ends for their deposit to be  processed. Both of these actions will then call the underlying  remove function in order to restructure the  The issue is that the remove function performs gas-intensive operations that drastically limit the upper bound on the queue size, which we conservatively estimate to be in the magnitude of a few thousands. With a large enough queue, any transaction attempting to refund or process even a single deposit will exceed the block gas limit of 30,000,000 gas. This could occur due to organic user growth, or a malicious actor may choose to send dust amounts of stETH to the vault from different addresses to take up positions in the queue. Without the ability to process or refund users, all current and future deposits made to the vault would be locked in the DepositQueue.  Consider accounting for the gas usage of all queue operations and ensuring they cannot reasonably exceed the block gas limit. Some recommendations to consider:  Refactor the DepositQueue so that operations such as remove can be performed in significantly less (and preferably constant) gas  Introduce a maximum capacity to the DepositQueue size to guarantee it can be processed each round  Apply a minimum investment requirement to deter attackers from spamming the queue with dust amounts of stETH  Use a different data structure for the DepositQueue, such as an EnumerableMap, to reduce code maintenance overhead and ensure necessary operations can be performed in constant gas  Update: Fixed in commit e05f165.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#depositqueue-can-become-permanently-locked", "labels": ["OpenZeppelin"]}, {"title": "Miscounted assets breaking system invariants", "body": "When processing queued deposits, the amount of assets that have been processed are accounted for in the processedDeposits variable and used to calculate the amount of shares to be minted. This variable is reset to 0 at the beginning of each round.  removed from  totalAssets. When the queue is processed the next time, the  totalAssets value already contains the amount of assets processed during the round. By  adding the processedDeposits to the totalAssets again, the previously processed amount is double counted, which leads to an incorrect calculation for the amount of shares minted to the next depositor in the queue.  This penalizes depositors by minting fewer shares if they are not included in the first call of the processQueuedDeposits function. This issue is particularly severe if each deposit is processed individually. Hence it breaks the system invariant that the number of splits should not modify the result when processing the deposits.  Additionally, this means users not processed in the first round may receive fewer assets than they deposited when they redeem their shares. This breaks another important system invariant that 100% withdrawal in stETH should always be equal to or higher than the initial deposit amount.  Consider correcting the total asset calculation to ensure the processed amount is accounted for accurately.  Update: Fixed in PR#54, with commit 3ad9b76 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#miscounted-assets-breaking-system-invariants", "labels": ["OpenZeppelin"]}, {"title": "The vault can be drained one share at a time", "body": "During the withdrawal process, users can specify the amount of assets to withdraw, which is then rounded down to shares.  When the asset amount specified by the user is less than the minimum amount that can be converted to a unit share, the shares argument is zero in the internal withdraw function but the assets argument is not. Hence, with zero shares, all internal calls can succeed and a non-zero amount of asset token will be transferred out to the receiver without burning any shares. This process can be repeated many times to drain the entire vault. The attack can also be executed with any asset amount by burning a rounded-down amount of shares and extracting the excess assets.  Since the vault is expected to become more valuable over time due to its yield strategy, this could lead to a profitable attack when one share is worth more than the cost.  Consider rounding up the shares for a given amount of assets during withdrawal.  Update: Fixed in PR#46, with commit 5ac5e3c being the last one added.  High Severity  Function withdraw can disable endRound  endRound() function any time after a round starts to remove a portion of the accrued interest from the vault to the  _afterRoundEnd hook, the  _beforeWithdraw() hook, where the withdrawn shares are rounded down to the corresponding asset value, which is subsequently subtracted from the  This may cause the lastRoundAssets to be more than the totalAssets() when a user calls the withdraw function. This can result in a revert due to underflow. In such a case, the controller cannot end a round and must wait for the accrued interest to accumulate enough value.  Consider keeping track of the withdrawn asset directly. Also, consider making sure the key system functionality is not impeded by users actions.  Update: Fixed in PR#73, with commit b258ca9 being the last one added.  Reentrancy risk in depositing to the queue  The internal _deposit function handles user deposits, transferring a specified amount of stETH from msg.sender to the vault. Before moving the funds, it adds the deposit to the queue, which is processed later by the processQueuedDeposits function.  As the underlying token could have hooks that allow the token sender to execute code before the transfer (e.g., ERC777 standard), a malicious user could use those hooks to re-enter the deposit function multiple times.  This re-entrancy will result in an increment in the receiver balance on the queue, even though this balance will not correspond to the actual amount deposited into the vault.  In the current implementation, the _deposit function in the BaseVault contract is overridden by the implementation in the STETHVault, which has the correct order of operation. However, the BaseVault is likely to be inherited by future vaults, so it is crucial to have the correct _deposit implementation in this contract in case it is not overridden.  Consider reordering the calls, doing the transfer first, and then adding the receiver to the queue to prevent this reentrancy scenario. Also, consider using OpenZeppelins ERC4626 implementation, which already has this solution implemented.  Update: Fixed in PR#41, with commit 2ffcb1e being the last one added.  Rounding up in minting shares  When processing the queued deposits, shares are minted to the receiver in the queue according to the amount of assets deposited. However, the amount of shares minted is always rounded up. This means that one can always receive 1 vault share with a 1-wei deposit.  As the vault is expected to be increasing in value from yield rewards, 1 vault share will be worth more than 1 wei asset eventually. A malicious user can spam the deposit queue with 1-wei deposit from many accounts to get 1 share each and then redeem them for more assets when each share is worth more.  Consider rounding down when minting vault shares.  Update: Fixed in PR#46, with commit 5ac5e3c being the last one added.  Medium Severity  Non-existent permit function  mintWithPermit and  depositWithPermit function intended to allow users to transfer assets to the vault in a single transaction. However, the vaults underlying asset is intended to be  stETH which does not have a  fallback function.  Consider removing the mintWithPermit and depositWithPermit functions. We note that wstETH does have a permit function for future considerations.  Update: Acknowledged, and will not fix. Pods Finance teams statement for this issue:  We decided not to fix this issue because we may implement assets similar to LIDO as the yield source where they may have permit functionality (aTokens, for instance).  Funds held in ETHAdapter can be drained by anyone  ETHAdapter contract is used as a proxy to allow users to interact with the vault through sending and receiving ETH instead of stETH. The adapter achieves this by converting ETH and stETH through a curve pool and then forwarding interactions to and from the vault. In the course of a normal  withdrawal or  redemption transaction, the  converts al", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#the-vault-can-be-drained-one-share-at-a-time", "labels": ["OpenZeppelin"]}, {"title": "Function withdraw can disable endRound", "body": "Function withdraw can disable endRound", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#function-withdraw-can-disable-endround", "labels": ["OpenZeppelin"]}, {"title": "Reentrancy risk in depositing to the queue", "body": "The internal _deposit function handles user deposits, transferring a specified amount of stETH from msg.sender to the vault. Before moving the funds, it adds the deposit to the queue, which is processed later by the processQueuedDeposits function.  As the underlying token could have hooks that allow the token sender to execute code before the transfer (e.g., ERC777 standard), a malicious user could use those hooks to re-enter the deposit function multiple times.  This re-entrancy will result in an increment in the receiver balance on the queue, even though this balance will not correspond to the actual amount deposited into the vault.  In the current implementation, the _deposit function in the BaseVault contract is overridden by the implementation in the STETHVault, which has the correct order of operation. However, the BaseVault is likely to be inherited by future vaults, so it is crucial to have the correct _deposit implementation in this contract in case it is not overridden.  Consider reordering the calls, doing the transfer first, and then adding the receiver to the queue to prevent this reentrancy scenario. Also, consider using OpenZeppelins ERC4626 implementation, which already has this solution implemented.  Update: Fixed in PR#41, with commit 2ffcb1e being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#reentrancy-risk-in-depositing-to-the-queue", "labels": ["OpenZeppelin"]}, {"title": "Rounding up in minting shares", "body": "When processing the queued deposits, shares are minted to the receiver in the queue according to the amount of assets deposited. However, the amount of shares minted is always rounded up. This means that one can always receive 1 vault share with a 1-wei deposit.  As the vault is expected to be increasing in value from yield rewards, 1 vault share will be worth more than 1 wei asset eventually. A malicious user can spam the deposit queue with 1-wei deposit from many accounts to get 1 share each and then redeem them for more assets when each share is worth more.  Consider rounding down when minting vault shares.  Update: Fixed in PR#46, with commit 5ac5e3c being the last one added.  Medium Severity", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#rounding-up-in-minting-shares", "labels": ["OpenZeppelin"]}, {"title": "Non-existent permit function", "body": "mintWithPermit and  depositWithPermit function intended to allow users to transfer assets to the vault in a single transaction. However, the vaults underlying asset is intended to be  stETH which does not have a  fallback function.  Consider removing the mintWithPermit and depositWithPermit functions. We note that wstETH does have a permit function for future considerations.  Update: Acknowledged, and will not fix. Pods Finance teams statement for this issue:  We decided not to fix this issue because we may implement assets similar to LIDO as the yield source where they may have permit functionality (aTokens, for instance).", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#non-existent-permit-function", "labels": ["OpenZeppelin"]}, {"title": "Funds held in ETHAdapter can be drained by anyone", "body": "ETHAdapter contract is used as a proxy to allow users to interact with the vault through sending and receiving ETH instead of stETH. The adapter achieves this by converting ETH and stETH through a curve pool and then forwarding interactions to and from the vault. In the course of a normal  withdrawal or  redemption transaction, the  converts all of its stETH to ETH, and then sends its entire ETH balance to the receiving address.  The issue is that the ETHAdapter sends its full balance to the receiver each time, meaning any ETH or stETH that is mistakenly sent to it can be drained by any user who performs a withdrawal or redemption on the ETHAdapter. This is exacerbated by the fact that the vault is passed in as a parameter, potentially allowing a user to perform withdrawals and redemptions without interacting with the actual stETH vault.  Consider transferring out the exchanged balance from the curve pool to the receiver instead of the entire balance of the ETHAdapter. Also consider implementing a rescue or sweep function to allow the recovery of funds that are accidentally sent to the ETHAdapter.  Update: Acknowledged, will not fix. Pods Finance teams statement:  For now, we do not want to take action in case of funds sends by mistake to our contract. We see this as a low-priority issue.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#funds-held-in-ethadapter-can-be-drained-by-anyone", "labels": ["OpenZeppelin"]}, {"title": "Incorrect calculations", "body": "We found the following instances of incorrect calculations in view functions that are not currently called internally:  In the previewWithdraw function, the DENOMINATOR over invertedFee is always bigger than 1 when the fee is non-zero. Hence, the final returned shares are always an overestimate. Further, the withdrawFeeRatio is multiplied to shares instead of assets as in other instances such as _getFee. Consider correcting the withdrawal fee calculation.  The calculation in the assetsOf function over-estimates the actual commitment by an additional committedAssets. Consider removing the extra component.  Update: Partially fixed in commit 6d37029 in PR#75. previewWithdraw does not include fees as stated in the EIP.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#incorrect-calculations", "labels": ["OpenZeppelin"]}, {"title": "Math library is vulnerable to shadow overflow", "body": "The AuxMath library is a custom auxiliary math library that performs multiplication and division with rounding specifications.  mulDivUp and  mulDivDown first compute the multiplication of a  current implementation will not give the right result in such a case.  Consider using OpenZeppelins Math library which implements the mulDiv function that is developed especially considering these scenarios and is widely accepted in the ecosystem.  Update: Fixed in commit 2a8c58a.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#math-library-is-vulnerable-to-shadow-overflow", "labels": ["OpenZeppelin"]}, {"title": "Maximum mintable and depositable amounts returned are incorrect", "body": "availableCap. Similarly, the  maxMint and  maxDeposit functions do not account for the  EIP4626 standard, these functions must return the real amount that can be minted or deposited.  Consider changing the maxMint and maxDeposit functions to return a value that accounts for the availableCap.  Update: Fixed in PR#42, with commit 3159de5 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#maximum-mintable-and-depositable-amounts-returned-are-incorrect", "labels": ["OpenZeppelin"]}, {"title": "Refund does not restore the cap", "body": "When a user deposits into the vault by joining the deposit queue, the corresponding shares, yet to be minted, are deducted from the spending cap immediately. The spending cap is restored only at withdrawal when the shares are burned.  If one user decides to use the refund function to leave the queue before the round ends, the spending cap will not be restored. When the cap is not zero, a malicious user with a sufficiently large amount of assets could repeatedly deposit and refund to reach the cap limit and stop other eligible users from joining the queue.  Note that the spendCap variable cannot be manually restored, but the owner can reset the cap to a higher value to unlock the deposit.  Consider accounting for the available cap during refunds from the queue.  Update: Fixed in commit 4a2e475.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#refund-does-not-restore-the-cap", "labels": ["OpenZeppelin"]}, {"title": "Refund can be over-credited in a negative yield event", "body": "Deposits added to the queue are point in time stETH balance amounts. The stETH token balance rebases regularly to account for yield, and in the event of slashing, may be subject to a negative yield. In the event that a stETH token rebase is negative between the time a user deposits and calls for a refund, the vault will over credit the user by the rebase difference.  Consider handling the deposits in the queue in shares instead of balances to account for rebase changes on refunds.  Update: Acknowledged, will not fix. Pods Finance teams statement:  Although we agree with the issue, we wont prioritize it right now because of timing. In case of a slashing event, we can refund the vault, transferring funds directly to the contract.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#refund-can-be-over-credited-in-a-negative-yield-event", "labels": ["OpenZeppelin"]}, {"title": "Parallel share cap setting", "body": "The configuration manager determines the maximum vault shares available for minting. When setting a new cap through the setCap function, the target contract address is checked for the zero address, and a SetCap event is emitted.  However, the underlying setParameter function can be called directly to change the maximum vault shares available. This will bypass the zero address check and emit a ParameterSet event instead of the expected SetCap event.  Consider ensuring consistency between the two mechanisms in setting the share cap. Depending on the desired outcome, this could involve removing the setParameter function and adding individual get and set functions for all necessary configuration parameters.  Update: Fixed in commit cbe61d0.  Low Severity", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#parallel-share-cap-setting", "labels": ["OpenZeppelin"]}, {"title": "Gas inefficiencies", "body": "There are many instances throughout the codebase where changes can be made to improve gas consumption. For example:  public functions might consume more gas than external functions. This is because with public functions, the EVM copies inputs (especially dynamic-sized arrays) into memory, while it reads from calldata if the function is external, which is cheaper. Throughout the codebase there are public functions like mintWithPermit, convertToSTETH, convertToETH, decimals, symbol, name and assetsOf that might be declared as external. Consider reviewing the entire codebase for more instances.  The function toAddress has a conditional statement that returns the zero address if the value passed is equal to zero. This additional check increases the gas consumption and does not add any benefit even if the provided value is equal to zero.  Initializing a variable to its default value causes unnecessary gas expense. Consider correcting such instances in processedDeposits, isProcessingDeposits, roundAccruedInterest, endSharePrice and the while loop counter inside the remove function.  The for loop inside the refund function does not cache the result of depositQueue.size() and perform unnecessary operations on each iteration. The same issue occurs in the last while loop of the remove function.  Performing calculations for values that will not change is suboptimal. Some examples are: name, symbol and the operation 10**sharePriceDecimals.  Use shorter string messages for required statements or switch entirely to a custom errors implementation to save on deployment cost and failed execution gas cost.  When performing these changes, aim to reach an optimal tradeoff between gas optimization and readability. Having a codebase that is easy to understand reduces the chance of future errors and improves community transparency.  Update: Partially fixed in PR#81, with commit 6f1bb8e being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#gas-inefficiencies", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent name and symbol", "body": "BaseVault, passed to the  STETHVault implementation. All vaults that use the same underlying asset and inherit from  hashedName when calculating the domain separator by the  EIP712 standard. Although this does not represent a risk, it is  recommended that the name sent to the  Also, the name and symbol defined in the BaseVault constructor are inconsistently overridden in the STETHVault implementation.  To avoid complications and improve code clarity, consider passing both the name and symbol from the STETHVault contract as parameters to maintain consistency. This also saves calculating the name and symbol at every call, thus saving more gas.  Update: Fixed in commit 61a9996.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#inconsistent-name-and-symbol", "labels": ["OpenZeppelin"]}, {"title": "Misleading comments", "body": "Comments are meant to be helpful and describe the intent of the code block. However, in multiple parts of the codebase, comments are not consistent with the code that is written or do not add any value to the reader. These are some examples:  The function _deposit in both the STETHVault and BaseVault contracts does not create any shares even though the comments say so.  The description of each parameter on setParameter, getParameter and getGlobalParameter does not add any value to the reader.  The target parameter on setParameter has a wrong description.  The function _spendCap has the same description as availableCap.  Consider correcting the comments to not mislead users or developers and write comments that add value to the reader. This will improve code clarity and consistency between docstrings and contract implementations.  Update: Fixed in commit 3ad59d0.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#misleading-comments", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "Throughout the codebase, there are several files that do not have docstrings. For instance:  The ConfigurationManager contract has no docstrings for any of its state variables.  The IConfigurationManager interface does not have any docstrings.  Although the ICurvePool interface is for an external contract, docstrings need to be added to explain the interface purpose and why each function is used within the codebase.  The IERC4626 interface has no docstrings for the interface description and also for any of its events.  The IVault interface has no docstrings for the interface description and also for any of its events and errors.  The AuxMath library does not have any docstrings.  The CastUint library has no docstrings for the library description.  The DepositQueueLib library just has some inline comments inside the remove function.  The Capped contract has no docstrings for the contract description, state variables, constructor, and its custom error.  The ETHAdapter contract just has some inline comments for the receive function.  The Migration contract does not have any docstrings.  The BaseVault contract has no docstrings for some of its state variables (configuration, _asset, currentRoundId, isProcessingDeposits, EMERGENCY_INTERVAL, processedDeposits, _lastEndRound and depositQueue), the constructor, and the functions depositWithPermit and mintWithPermit.  The STETHVault contract has no docstrings for some of its state variables (sharePriceDecimals, lastRoundAssets, lastSharePrice, and investor) and the constructor. Adding comments in the internal function _afterRoundEnd can be beneficial for easy understanding of its purpose.  This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security but also correctness. Additionally, docstrings improve readability and easy maintenance.  Consider thoroughly inserting documentation above each contract, interface, library, function, state variable, event, and custom errors. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Processing order alters queue indexes", "body": "Any user may process deposits in the queue after a round ends. After deposits are processed, the section of the queue they were held in is removed. This means that any user who processes deposits will be changing the size and indexes of the queue for all others. This may lead to reverted transactions if an index that was previously thought to be in range no longer exists in the queue. It may also lead to some processing of unintended indexes and others missing their targeted indexes in the queue.  Consider having additional validations on the queue size and indexes to ensure the correct transactions are executed without going out of bounds.  Update: Fixed in commit e05f165.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#processing-order-alters-queue-indexes", "labels": ["OpenZeppelin"]}, {"title": "Refunds are subject to high gas costs and a potential DoS", "body": "Refunds are processed by searching the entire queue front to back for a users position. Currently, the gas price to refund increases linearly based on the users position in the queue. Users that have joined the queue later in the round will incur a more significant gas penalty and, in an extreme case, could be prevented from refunding.  Consider keeping track of a users queue position alongside other attributes for easier retrieval and update.  Update: Fixed in commit e05f165.  Remove function does not revert if startIndex is greater than or equal to endIndex  The remove function is responsible for removing records from the queue. When called, it checks if the endIndex is greater than the startIndex to execute the functions implementation. The issue is that if the condition is not met, the transaction is not reverted, and the code execution continues. This could cause processQueuedDeposits to fail silently when the indexes are not valid.  Although it does not currently cause any errors other than spending gas unnecessarily, consider rolling back the transaction if the condition is met to avoid unwanted behaviors.  Update: Fixed in commit e05f165.  Migration risks  The system allows users to migrate their shares to a new vault with the same underlying asset. There are a few risks regarding the current migration mechanism design.  Unclear migration path: Currently, two migration mechanisms exist. A user can either call the migrate function in the old vault or through the exclusive Migration contract. There is no clarity on which route is preferred as both essentially perform the same functionality. Consider removing duplicate actions that can lead to user confusion.  Incomplete migration: In both migration routes, users first redeem their shares from the old vault and then re-deposit the assets into the new vault. If the queueing system works the same way in the new vault, this only lets the user join the deposit queue. Hence the migration is not complete until the queued deposits are processed with the shares minted. Consider documenting this to make it clear to users who migrate.  Migration re-usability: The Migration contract sets both the old vault and the new vault addresses as immutable variables in the constructor. This limits its use case to one single migration. It would not be reusable across multiple vaults with the same underlying assets and different investment strategies.  Not robust against trapped funds: When assets are present in the Migration contract due to direct transfers or mistaken withdrawals, the entire balance of the contract will be deposited to the new vault by the next user. This design is not resistant to genuine user mistakes and prohibits recovering user funds. Consider using the returned value from the redeem function to migrate the correct amount of assets and establishing a sweep or rescue function for funds locked in the contract.  Update: Partially fixed in commit d97672d.  Unnecessarily complex code  The investmentYield and the investmentAmount are transferred back and forth from the vault to the same investor account. Instead of making two separate transactions, one can compare the two values and reach the final balance in one transaction.  Consider simplifying the code for clarity and readability.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We actively preferred to leave the code in the back-and-forth way, so its easier to understand the flow of funds of the operations.  Notes & Additional Information  Magic numbers are used  Although constants are generally used correctly throughout the codebase, there are a few occurrences of literal values being used with unexplained meaning. For example, the following blocks use hardcoded values:  In the constructor of the ETHAdapter contract, the pools coins method is called with arguments 0 and 1, with no explanation.  In the functions convertToETH and convertToSTETH, the pools get_dy method is called with arguments 0 and 1 with no explanation.  In the deposit function, the pools exchange method is called with arguments 0 and 1, with no explanation.  To improve the codes readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. Consider adding an inline comment explaining how they are calculated or why they are chosen for complex values.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.  Multiple conditions for error handling statements  Throughout the codebase there are require statements and custom error blocks that need multiple conditions to be satisfied. For instance:  In the constructor of the ETHAdapter contract there is a require statement that checks if coin 0 from the pool is equal to the ETH address and if coin 1 is equal to stETH address. If one of the conditions is not met, there is no error message to indicate why the transaction was reverted. ", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#refunds-are-subject-to-high-gas-costs-and-a-potential-dos", "labels": ["OpenZeppelin"]}, {"title": "Remove function does not revert if startIndex is greater than or equal to endIndex", "body": "Remove function does not revert if startIndex is greater than or equal to endIndex", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#remove-function-does-not-revert-if-startindex-is-greater-than-or-equal-to-endindex", "labels": ["OpenZeppelin"]}, {"title": "Migration risks", "body": "The system allows users to migrate their shares to a new vault with the same underlying asset. There are a few risks regarding the current migration mechanism design.  Unclear migration path: Currently, two migration mechanisms exist. A user can either call the migrate function in the old vault or through the exclusive Migration contract. There is no clarity on which route is preferred as both essentially perform the same functionality. Consider removing duplicate actions that can lead to user confusion.  Incomplete migration: In both migration routes, users first redeem their shares from the old vault and then re-deposit the assets into the new vault. If the queueing system works the same way in the new vault, this only lets the user join the deposit queue. Hence the migration is not complete until the queued deposits are processed with the shares minted. Consider documenting this to make it clear to users who migrate.  Migration re-usability: The Migration contract sets both the old vault and the new vault addresses as immutable variables in the constructor. This limits its use case to one single migration. It would not be reusable across multiple vaults with the same underlying assets and different investment strategies.  Not robust against trapped funds: When assets are present in the Migration contract due to direct transfers or mistaken withdrawals, the entire balance of the contract will be deposited to the new vault by the next user. This design is not resistant to genuine user mistakes and prohibits recovering user funds. Consider using the returned value from the redeem function to migrate the correct amount of assets and establishing a sweep or rescue function for funds locked in the contract.  Update: Partially fixed in commit d97672d.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#migration-risks", "labels": ["OpenZeppelin"]}, {"title": "Unnecessarily complex code", "body": "The investmentYield and the investmentAmount are transferred back and forth from the vault to the same investor account. Instead of making two separate transactions, one can compare the two values and reach the final balance in one transaction.  Consider simplifying the code for clarity and readability.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We actively preferred to leave the code in the back-and-forth way, so its easier to understand the flow of funds of the operations.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#unnecessarily-complex-code", "labels": ["OpenZeppelin"]}, {"title": "Magic numbers are used", "body": "Although constants are generally used correctly throughout the codebase, there are a few occurrences of literal values being used with unexplained meaning. For example, the following blocks use hardcoded values:  In the constructor of the ETHAdapter contract, the pools coins method is called with arguments 0 and 1, with no explanation.  In the functions convertToETH and convertToSTETH, the pools get_dy method is called with arguments 0 and 1 with no explanation.  In the deposit function, the pools exchange method is called with arguments 0 and 1, with no explanation.  To improve the codes readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. Consider adding an inline comment explaining how they are calculated or why they are chosen for complex values.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#magic-numbers-are-used", "labels": ["OpenZeppelin"]}, {"title": "Multiple conditions for error handling statements", "body": "Throughout the codebase there are require statements and custom error blocks that need multiple conditions to be satisfied. For instance:  In the constructor of the ETHAdapter contract there is a require statement that checks if coin 0 from the pool is equal to the ETH address and if coin 1 is equal to stETH address. If one of the conditions is not met, there is no error message to indicate why the transaction was reverted.  The migrate function in the BaseVault contract has a conditional block that checks if the vault is not allowed and if the destination vault does not have the same underlying asset as the current vault. Although the custom error that is thrown is not wrong, it might be better if these two validations are separated to return more specific error messages.  The onlyRoundStarter modifier has a custom error block that checks if less than a week has passed since the last end round and if the caller is different from the controller. If the conditions are met, the error returned is that the caller is not the controller. Consider separating both conditions in order to throw a more specific error message.  To simplify the codebase and to raise the most helpful error messages for failing blocks, consider having a single require statement with an appropriate error message or a single custom error block per condition.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#multiple-conditions-for-error-handling-statements", "labels": ["OpenZeppelin"]}, {"title": "Naming issues hinder code understanding and readability", "body": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  Function withdrawFeeRatio can be changed to getWithdrawFeeRatio. The current name suggests that the action is the withdrawal of fee ratio but what it actually does is to query the WITHDRAW_FEE_RATIO value.  Error ConfigurationManager__InvalidCapTarget can be changed to ConfigurationManager__TargetCannotBeTheZeroAddress or something similar, since the only invalid target is the zero address.  Update: Fixed in commit 88ce562.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#naming-issues-hinder-code-understanding-and-readability", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit imports are used", "body": "throughout the codebase, which reduces code readability and could lead to conflicts between names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long. For instance, but not limited to:  Lines 5-14 of BaseVault.sol  Lines 5-9 of EthAdapter.sol  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Outdated Solidity version", "body": "All contracts within the codebase use compiler version 0.8.9, an old version with various bugs that have been fixed in later releases.  Consider taking advantage of the latest Solidity version to improve the overall quality and security of the codebase.  Update: Fixed in commit 93956a9 in PR#66.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#outdated-solidity-version", "labels": ["OpenZeppelin"]}, {"title": "State variable visibility not explicitly declared", "body": "Throughout the codebase, there are state variables that lack explicitly declared visibility. For instance:  CAP in ConfigurationManager.sol  ETH_ADDRESS in ETHAdapter.sol  STETH_ADDRESS in ETHAdapter.sol  from in Migration.sol  to in Migration.sol  For clarity, consider always explicitly declaring the visibility of variables, even when the default visibility matches the intended visibility.  Update: Fixed in PR#64, with commit a3eb939 being the last one added.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#state-variable-visibility-not-explicitly-declared", "labels": ["OpenZeppelin"]}, {"title": "Style inconsistencies", "body": "can be seen throughout the codebase. For example:  Some functions use require statements for error handling and others use custom errors. In general custom errors are preferred over require statements.  The naming convention for events is not clear. Some use, like StartRound, the functions name with the first letter capitalized, and others, like FeeCollected, describe the action that was executed. Consider following only one convention on the entire codebase.  The constant investorRatio does not use all capital letters with underscores separating words but all other constants in the codebase do. Consider changing it to INVESTOR_RATIO.  Update: Fixed in commit cf6ae4d.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#style-inconsistencies", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Across the codebase, there are some typographical errors in the comments. Some examples are:  ConfiguratorManager should be ConfigurationManager.  MAX_WITDRAW_FEE should be MAX_WITHDRAW_FEE.  splitted should be split.  Consider correcting the above and any further typos in favor of correctness and readability.  Update: Fixed in PR#41 commit a515964 and PR#69 commit 4ec70cb.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary arguments", "body": "We found some internal functions with unused arguments in the implementation, hence are unnecessary to be defined in the base contract. For example:  The _afterRoundStart(uint256) function does not require an argument in the implementation but is defined with an argument in the base contract.  The _beforeWithdraw(uint256 shares, uint256) function does not require a second argument but is defined with a second argument in the base contract.  Consider removing unnecessary arguments for clarity and readability.  Update: Fixed in commit f100925.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#unnecessary-arguments", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary implementation", "body": "The following instances of internal virtual functions are implemented in BaseVault.sol, which are later overridden by a different implementation in STETHVault.sol.  The _withdraw function is overridden by the same implementation.  The _deposit function is overridden by a different implementation.  Consider removing unnecessary implementations for readability and maintenance.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#unnecessary-implementation", "labels": ["OpenZeppelin"]}, {"title": "Unused Code", "body": "The global address and the getGlobalParameter() function of the ConfigurationManager contract are supposed to manage global configurations that do not depend on a specific vault. However, the purpose of those entities is unclear, as they are not used anywhere in the codebase.  To avoid confusion and favor explicitness, consider documenting the purpose of these functions and variables. If they are not expected to be used, consider removing them from the codebase to reduce the codes size and attack surface.  Update: Acknowledged, will not fix. Pods Finance teams statement:  We didnt prioritize this because of time constraints.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#unused-code", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "Throughout the codebase imports on the following lines are unused and could be removed:  draft-IERC20Permit in BaseVault  IConfigurationManager in ETHAdapter  Consider removing unused imports to avoid confusion and improve the overall readability of the codebase.  Update: Fixed in commits b702189 and 89869ad.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused named return variable", "body": "Throughout the codebase, there are several occasions where named return variables are declared but not used. For instance:  newShares on migrate and migrateWithPermit functions  stETHAmount on convertToSTETH  ethAmount on convertToETH  depositedAssets on _deposit on both STETHVault and BaseVault  roundId on startRound  shares on maxMint, maxRedeem, deposit, convertToShares, and previewDeposit  assets on maxWithdraw, maxDeposit, convertToAssets, and previewMint  effectiveAmount on _stETHTransferFrom  Consider adding those variables to function implementations or remove them.  Update: Fixed in commit 1228184.", "html_url": "https://blog.openzeppelin.com/pods-finance-ethereum-volatility-vault-audit-1#unused-named-return-variable", "labels": ["OpenZeppelin"]}, {"title": "Storage collision leads to failure of the system", "body": "In the Storage.sol file, the AppStorage struct keeps track of all stored values for the layer 1 system as part of the Diamond proxy pattern. The first entry of this struct is the DiamondCutStorage struct for the deployed code version and the UpgradeStorage struct for the audited and to-be-upgraded version. Both are used to track upgrade data for the DiamondCut facet.  As seen by comparing their entries, the structs have changed in size. Originally, DiamondCutStorage occupied 7 storage slots, while UpgradeStorage only occupies 2. Respectively, the slots of all following variables in the AppStorage struct shift, thereby resulting in a storage collision. Due to this desynchronization of storage, the entire system functionality would break and come to a halt.  For instance, the new governor address slot would match the former lastDiamondFreezeTimestamp value. Hence, by applying the upgrade, the operator loses the governor privilege. As such, the ability to perform further upgrades is lost and no other mechanism of recovery is present in the system. Moreover, the new verifier mapping would match the old securityCouncilMembers mapping. Thus, former council members would become validators. Since all stored block info would be lost, the validators could not commit any new blocks anyways.  In order to apply the upgrade in spite of the storage collision, one could re-initialize the AppStorage during the initialization stage of the same exact Diamond upgrade. However, properly overwriting the mappings does not seem feasible from a gas consumption perspective. Additionally, it requires a diligent off-chain data collection of all mapping data in need of overwrites. In conclusion, missing this opportunity is very probably and likely to fail.  Consider leaving the former struct as is and only appending new data to the end of the AppStorage struct. Thoroughly document that while DiamondCutStorage is unused, it must remain a member of AppStorage. Additionally, create a machine-readable artefact describing the deployed AppStorage layout, and integrate a check against it in your CI system.  Update: Resolved in commit cd417be.  Medium Severity  Arbitrary l2Logs length can lead to unprovable blocks and log inclusion  In the ExecutorFacet contract, the layer 2 logs are processed as part of committing blocks to layer 1. These layer 2 logs have a structured format and are used to extract data of what happened on the layer 2 chain. The size of the layer 2 logs byte data should be fixed. However, this is not checked, which raises the following concerns:  All logs affect the commitment that is later used for proof verification. Any mismatched log data would result in an unprovable commitment and would need to be reverted.  In the Mailbox facet, it can be checked whether specific logs were emitted as part of a block by performing a Merkle inclusion check with a proof length of 9. In the event of more than 512 logs per block, their inclusion cannot be proven.  The constant L2_TO_L1_LOGS_COMMITMENT_BYTES is unused.  Consider making use of the constant to check the size of the layer 2 logs such that the aforementioned concerns are eliminated.  Update: Resolved in commits 39e83ee and 7dceb6b.  Governor can immediately execute diamond upgrades  In the executeUpgrade function of the DiamondCut facet, the Boolean value upgradeNoticePeriodPassed indicates whether the upgrade waiting period has passed. However, the value is never used, thereby allowing the governor role to propose and immediately execute a transparent proposal without the need of council approval. This could have a severe impact for a rogue governor.  Consider checking that the Boolean value holds true such that the implementation reflects the original intention.  Update: Resolved in commits ba31745 and 65ad664.  Low Severity  Missing error messages in require statements  Within Executor.sol there are multiple require statements that lack error messages. For instance:  The require statement on line 43  The require statement on line 45  The require statement on line 291  Consider including specific, informative error messages in require statements in order to improve code clarity and facilitate troubleshooting whenever a requirement is not satisfied.  Update: Resolved in commit 6f446e6.  Require statement with multiple conditions  There is a require statement in the AllowList contract that requires multiple conditions to be satisfied.  In order to simplify the codebase and raise the most helpful error messages for failing require statements, consider having a single require statement per condition.  Update: Resolved in commit 33cb3f5.  Lack of explicit proposal id  In the DiamondCut contract, the proposeShadowUpgrade function checks the equality of its parameter _proposalId to the current proposal id incremented by one. In contrast, the proposeTransparentUpgrade function auto increments the current proposal id obtained from storage and does not require passing an additional par", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#storage-collision-leads-to-failure-of-the-system", "labels": ["OpenZeppelin"]}, {"title": "Arbitrary l2Logs length can lead to unprovable blocks and log inclusion", "body": "Arbitrary l2Logs length can lead to unprovable blocks and log inclusion", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#arbitrary-l2logs-length-can-lead-to-unprovable-blocks-and-log-inclusion", "labels": ["OpenZeppelin"]}, {"title": "Governor can immediately execute diamond upgrades", "body": "In the executeUpgrade function of the DiamondCut facet, the Boolean value upgradeNoticePeriodPassed indicates whether the upgrade waiting period has passed. However, the value is never used, thereby allowing the governor role to propose and immediately execute a transparent proposal without the need of council approval. This could have a severe impact for a rogue governor.  Consider checking that the Boolean value holds true such that the implementation reflects the original intention.  Update: Resolved in commits ba31745 and 65ad664.  Low Severity", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#governor-can-immediately-execute-diamond-upgrades", "labels": ["OpenZeppelin"]}, {"title": "Missing error messages in require statements", "body": "Within Executor.sol there are multiple require statements that lack error messages. For instance:  The require statement on line 43  The require statement on line 45  The require statement on line 291  Consider including specific, informative error messages in require statements in order to improve code clarity and facilitate troubleshooting whenever a requirement is not satisfied.  Update: Resolved in commit 6f446e6.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#missing-error-messages-in-require-statements", "labels": ["OpenZeppelin"]}, {"title": "Require statement with multiple conditions", "body": "There is a require statement in the AllowList contract that requires multiple conditions to be satisfied.  In order to simplify the codebase and raise the most helpful error messages for failing require statements, consider having a single require statement per condition.  Update: Resolved in commit 33cb3f5.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#require-statement-with-multiple-conditions", "labels": ["OpenZeppelin"]}, {"title": "Lack of explicit proposal id", "body": "In the DiamondCut contract, the proposeShadowUpgrade function checks the equality of its parameter _proposalId to the current proposal id incremented by one. In contrast, the proposeTransparentUpgrade function auto increments the current proposal id obtained from storage and does not require passing an additional parameter.  Consider adding the _proposalId as an additional parameter to the proposeTransparentUpgrade function to provide a consistent proposal flow and avoid any confusion related to the proposal id.  Update: Resolved in commit c70dda0.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#lack-of-explicit-proposal-id", "labels": ["OpenZeppelin"]}, {"title": "Reimplementation of library functionality", "body": "Throughout the codebase we found two occurrences of re-implemented functionality that is available in community-vetted Solidity libraries:  The two-step ownable control flow implemented in the AllowList contract is equivalent to the functionality implemented in the OpenZeppelin Ownable2Step contract. Consider extending the Ownable2Step contract with the AllowList functionality.  The SafeCast library is a copied code snippet from the OpenZeppelin library. Consider replacing the imports and removing the custom SafeCast library.  In order to prevent implementation mistakes, consider applying the above changes, leveraging the community-vetted and battle-tested libraries.  Update: Resolved in commit 60b66b0.  Notes & Additional Information  NewOwner event should emit old and new state  The NewOwner event emits the new owner whenever the pending owner accepts ownership of the AllowList contract.  Consider emitting both the old and new owner to allow for better traceability of ownership changes via off-chain clients.  Update: Resolved. The Matter Labs team stated:  We implemented L04 and inherited the Ownable2Step contract so no change is needed.  Gas optimizations  A few places in the codebase could benefit from gas optimization, for example:  In the senderCanCallFunction modifier, instead of casting the function signature from msg.data, consider using msg.sig.  The loop in the Executor facet could have incremented currentTotalBlocksVerified once, instead of doing it twice in line 237 and line 250.  In the Executor facet, the proveBlocks() function performs a safety check to ensure that the number of verified blocks is smaller or equal to the total blocks committed. Consider to fail early by placing the require statement before the proof verification process, i.e., after the loop of committed block checks in line 252.  Consider optimizing these code sections to make them more gas efficient.  Update: Resolved in commit 894c0c8.  Invalid docstring  The interface IExecutor.sol specifies a docstring for the ergsPerPubdataByteInBlock variable, but this variable has already been removed in this code update.  Consider removing this docstring.  Update: Resolved in commit 9bdec5a.  Unused constants  Within the Config.sol file, there are a few constants that are defined but never used throughout the codebase. For instance:  L2_TO_L1_LOGS_COMMITMENT_BYTES  INITIAL_STORAGE_CHANGES_COMMITMENT_BYTES  REPEATED_STORAGE_CHANGES_COMMITMENT_BYTES  Consider either using these constants, documenting why they are left in the code, or removing them.  Update: Resolved in commit 526a3fe.  Files import non-existent contract  The files Storage.sol and IGovernance.sol import the file Verifier.sol, but the file does not exist.  Consider removing these imports.  Update: Resolved, not an issue. The Matter Labs team stated:  The Verifier.sol contract is generated by the server according to the public keys. So, the import file exists, but in a non-explicit way.  Indecisive licensing  Throughout the codebase there are several files that state an SPDX license identifier of MIT OR Apache-2.0.  Consider agreeing on one license per file to prevent confusion on how these files can be used.  Update: Resolved in commit a5fafe5.  Interface and implementation mismatch  In the Getters facet, the function isFacetFreezable is implemented even though it is not defined in the IGetters interface.  In the Governance facet, the function setPorterAvailability has the Boolean parameter _zkPorterIsAvailable while it is called _isPorterAvailable in the IGovernance interface.  Consider correcting the above differences.  Update: Resolved in commit 74eb251.  Non-explicit imports are used  Throughout the codebase, non-explicit imports are used, which reduces code readability and could lead to conflicts between the names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Following the principle that clearer code is better code, consider using a named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.  Typographical errors  In the AllowList contract a typographical error was identified where The address that the owner proposed as one that will replace its should be The address proposed by an owner to replace their address.  Consider fixing this error and any other typographical errors for readability and explicitness.  Update: Resolved in commit e337941.  Conclusions  This diff audit of the layer 1 contracts was conducted over the course of one week. We audited the latest changes to the codebase since the fix review process was completed by the Matter Labs team on October 19th, 2022. For the most part, the chang", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#reimplementation-of-library-functionality", "labels": ["OpenZeppelin"]}, {"title": "NewOwner event should emit old and new state", "body": "NewOwner event should emit old and new state", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#newowner-event-should-emit-old-and-new-state", "labels": ["OpenZeppelin"]}, {"title": "Gas optimizations", "body": "A few places in the codebase could benefit from gas optimization, for example:  In the senderCanCallFunction modifier, instead of casting the function signature from msg.data, consider using msg.sig.  The loop in the Executor facet could have incremented currentTotalBlocksVerified once, instead of doing it twice in line 237 and line 250.  In the Executor facet, the proveBlocks() function performs a safety check to ensure that the number of verified blocks is smaller or equal to the total blocks committed. Consider to fail early by placing the require statement before the proof verification process, i.e., after the loop of committed block checks in line 252.  Consider optimizing these code sections to make them more gas efficient.  Update: Resolved in commit 894c0c8.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Invalid docstring", "body": "The interface IExecutor.sol specifies a docstring for the ergsPerPubdataByteInBlock variable, but this variable has already been removed in this code update.  Consider removing this docstring.  Update: Resolved in commit 9bdec5a.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#invalid-docstring", "labels": ["OpenZeppelin"]}, {"title": "Unused constants", "body": "Within the Config.sol file, there are a few constants that are defined but never used throughout the codebase. For instance:  L2_TO_L1_LOGS_COMMITMENT_BYTES  INITIAL_STORAGE_CHANGES_COMMITMENT_BYTES  REPEATED_STORAGE_CHANGES_COMMITMENT_BYTES  Consider either using these constants, documenting why they are left in the code, or removing them.  Update: Resolved in commit 526a3fe.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#unused-constants", "labels": ["OpenZeppelin"]}, {"title": "Files import non-existent contract", "body": "The files Storage.sol and IGovernance.sol import the file Verifier.sol, but the file does not exist.  Consider removing these imports.  Update: Resolved, not an issue. The Matter Labs team stated:  The Verifier.sol contract is generated by the server according to the public keys. So, the import file exists, but in a non-explicit way.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#files-import-non-existent-contract", "labels": ["OpenZeppelin"]}, {"title": "Indecisive licensing", "body": "Throughout the codebase there are several files that state an SPDX license identifier of MIT OR Apache-2.0.  Consider agreeing on one license per file to prevent confusion on how these files can be used.  Update: Resolved in commit a5fafe5.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#indecisive-licensing", "labels": ["OpenZeppelin"]}, {"title": "Interface and implementation mismatch", "body": "In the Getters facet, the function isFacetFreezable is implemented even though it is not defined in the IGetters interface.  In the Governance facet, the function setPorterAvailability has the Boolean parameter _zkPorterIsAvailable while it is called _isPorterAvailable in the IGovernance interface.  Consider correcting the above differences.  Update: Resolved in commit 74eb251.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#interface-and-implementation-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit imports are used", "body": "Throughout the codebase, non-explicit imports are used, which reduces code readability and could lead to conflicts between the names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Following the principle that clearer code is better code, consider using a named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  Update: Acknowledged, not resolved. The Matter Labs team stated:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "In the AllowList contract a typographical error was identified where The address that the owner proposed as one that will replace its should be The address proposed by an owner to replace their address.  Consider fixing this error and any other typographical errors for readability and explicitness.  Update: Resolved in commit e337941.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-diff-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Lack of validation in EmergencyProposer setQuorum and setMinimumWaitTime", "body": "Lack of validation in EmergencyProposer setQuorum and setMinimumWaitTime", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#lack-of-validation-in-emergencyproposer-setquorum-and-setminimumwaittime", "labels": ["OpenZeppelin"]}, {"title": "Governor contract can create emergency proposals", "body": "The EmergencyProposal contract is used to construct an emergency recovery transaction that bypasses the standard voting process. The intention is to provide an alternate execution path that can be utilized to fix an incorrectly configured VotingV2 contract.  Any user can propose an emergency transaction via the emergencyPropose function, but the size of the required bond is expected to be large enough that it is unlikely that an individual or the UMA team would be able to sufficiently fund the bond amount on their own. Proposals are executed using the emergencyExecute function in the GovernorV2 contract. The executor address has the sole ability to call this function, giving it veto power over any proposal. The UMA team controls the executor address.  There is currently no restriction that would prevent using the standard voting process to create a transaction that results in the GovernorV2 contract calling the emergencyPropose function to create a proposal. While this is highly unlikely as this transaction would need to pass a standard voting process, this could potentially introduce undesired effects and deviate from the expected functioning of the contract.  An example of an unexpected interaction is that a GovernorV2 emergency proposal can not be slashed by using the slashProposal function, as the slash mechanism transfers the slashed amount to the GovernorV2 address.  To avoid unexpected or undesirable behavior, consider preventing the GovernorV2 contract from being able to execute the emergencyPropose function.  Update: Fixed as of commit 41a03995087d2e63d047075582ef49783074ba48 in PR #4151.  Incorrect public visibility  query and retrieve prices from a previous voting contract. However, the function  is defined with  _requireRegisteredContract check used by the  Consider changing the visibility of _getPriceFromPreviousVotingContract from public to private.  Update: Fixed as of commit 4f1c1d741d67959ab69acdf8ff70f7eb4d65f429 in PR #4154.  Lack of address validation in setExecutor  In the EmergencyProposal contract, the function setExecutor allows the owner of the contract to set a new executor. However, the function does not validate that the newExecutor address is not the zero address before updating the value.  Consider adding validation to prevent an unintended change that sets the executor to the zero address.  Update: Resolved, not an issue. Ability to set executor to zero is a feature of the UMA platform. UMAs statement:  The audit fix proposes adding address validation to the setExecutor function such that this value cant be set to the zero address. We choose to do nothing for this issue as being able to set the executor to the zero address is a feature: this acts to disable the emergencyProposer system, thereby disabling the emergency logic. This could be, for example, an upgrade path for the emergency proposal system or a path forward if governance deems the emergency proposal logic redundant.  Missing documentation  Several functions within the codebase have missing or incomplete documentation:  In PR #4110:  The _stakeTo function in the Staker contract has no docstring  In PR #4118:  The _previousVotingContract parameter has no corresponding @param line in the VotingV2 constructor docstring  The _getPriceFromPreviousVotingContract function in VotingV2 has no docstring  In PR #4128:  The emergencyPropose function in EmergencyProposer returns a value but its docstring has no corresponding @return line  In PR #4135:  The getCurrentTime function in VotingV2Test has no docstring  The commitVote function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The revealVote function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The commitAndEmitEncryptedVote function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The getPendingPriceRequestsArray function in VotingV2Test has no docstring  The getPriceRequestStatuses function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The retrieveRewardsOnMigratedVotingContract function in VotingV2 returns a value but its docstring has no corresponding @return line  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions that implement sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec). Also consider providing explanatory comments for all events, structs, and storage variables that indicate their intended purpose.  Update: Partially fixed as of commit e729b6ba86529598326ec80083cdfbaf8541b94c in PR #4155. UMAs statement:  It has been decided not to add docstring in the test contracts as this is not done through the rest of the repo.  Missing error messages in require statements  Within VotingV2.sol there are require statements that lack error messages. For instance:", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#governor-contract-can-create-emergency-proposals", "labels": ["OpenZeppelin"]}, {"title": "Incorrect public visibility", "body": "Incorrect public visibility", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#incorrect-public-visibility", "labels": ["OpenZeppelin"]}, {"title": "Lack of address validation in setExecutor", "body": "Lack of address validation in setExecutor", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#lack-of-address-validation-in-setexecutor", "labels": ["OpenZeppelin"]}, {"title": "Missing documentation", "body": "Several functions within the codebase have missing or incomplete documentation:  In PR #4110:  The _stakeTo function in the Staker contract has no docstring  In PR #4118:  The _previousVotingContract parameter has no corresponding @param line in the VotingV2 constructor docstring  The _getPriceFromPreviousVotingContract function in VotingV2 has no docstring  In PR #4128:  The emergencyPropose function in EmergencyProposer returns a value but its docstring has no corresponding @return line  In PR #4135:  The getCurrentTime function in VotingV2Test has no docstring  The commitVote function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The revealVote function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The commitAndEmitEncryptedVote function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The getPendingPriceRequestsArray function in VotingV2Test has no docstring  The getPriceRequestStatuses function in VotingV2Test lost its docstring when it was relocated from VotingV2.sol  The retrieveRewardsOnMigratedVotingContract function in VotingV2 returns a value but its docstring has no corresponding @return line  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions that implement sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec). Also consider providing explanatory comments for all events, structs, and storage variables that indicate their intended purpose.  Update: Partially fixed as of commit e729b6ba86529598326ec80083cdfbaf8541b94c in PR #4155. UMAs statement:  It has been decided not to add docstring in the test contracts as this is not done through the rest of the repo.  Missing error messages in require statements  Within VotingV2.sol there are require statements that lack error messages. For instance:  The require statement on line 257 of VotingV2.sol  The require statement on line 265 of VotingV2.sol  The require statement on line 486 of VotingV2.sol  The require statement on line 704 of VotingV2.sol  The require statement on line 928 of VotingV2.sol  The require statement on line 964 of VotingV2.sol  The require statement on line 971 of VotingV2.sol  We are aware error messages were removed to reduce the contract size, however their absence makes interacting or debugging the contract more difficult.  Consider including specific, informative error messages in require statements to improve overall code clarity and to facilitate troubleshooting whenever a requirement is not satisfied.  Update: Fixed as of commit a88a022a9a5b02c9cd0526c7fc2e72a094d02813 in PR #4173.  Missing modifier onlyIfNotMigrated enables new price requests on migrated contracts  onlyIfNotMigrated and its underlying private function  _requireNotMigrated are used to ensure that the voting contract being called is the most recent voting contract deployed. This prevents users from requesting prices and voting on price requests on an outdated voting contract. However,  requestGovernanceAction and  signalRequestsAsSpamForDeletion. Both of these functions will call  Consider adding the onlyIfNotMigrated modifier to the functions requestGovernanceAction and signalRequestsAsSpamForDeletion.  Update: Fixed as of commit e62b25249441fc827f3fd6a336ed31d887c93dad in PR #4157.  Missing test coverage  Pull request #4117 adds a new retrieveRewardsOnMigratedVotingContract function to the VotingV2 contract, in order to enable voters to claim their rewards from the previous voting contract. However, this pull request does not include any test coverage for the newly added function.  Without an automated test for this function, manual testing is required to determine if the current implementation matches the functionss expected behavior, which is error prone and deviates from the goal of continuous integration.  Consider adding test coverage for the new retrieveRewardsOnMigratedVotingContract function.  Update: Resolved, not an issue. Tests were included but fell outside the scope of the audit. UMAs statement:  Test coverage was actually already added for this function, but in a separate PR to when the logic was added. This was added in an adjacent PR where we proposed to decrease the contract bytecode. The test for this logic can be found here.  Nonintuitive behavior of payable transactions in executeEmergencyProposal  In the EmergencyProposal contract, the executeEmergencyProposal function iterates through the transactions submitted on the proposal and executes them. However, only the first element in the array is able to execute a payable transaction, as the first element of the proposed transactions will transfer the entirety of the contract ETH balance, meaning that subsequent transactions will have a value of zero.  Consider documenting this behavior thoroughly as it may not", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#missing-documentation", "labels": ["OpenZeppelin"]}, {"title": "Missing error messages in require statements", "body": "Missing error messages in require statements", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#missing-error-messages-in-require-statements", "labels": ["OpenZeppelin"]}, {"title": "Missing modifier onlyIfNotMigrated enables new price requests on migrated contracts", "body": "Missing modifier onlyIfNotMigrated enables new price requests on migrated contracts", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#missing-modifier-onlyifnotmigrated-enables-new-price-requests-on-migrated-contracts", "labels": ["OpenZeppelin"]}, {"title": "Missing test coverage", "body": "Pull request #4117 adds a new retrieveRewardsOnMigratedVotingContract function to the VotingV2 contract, in order to enable voters to claim their rewards from the previous voting contract. However, this pull request does not include any test coverage for the newly added function.  Without an automated test for this function, manual testing is required to determine if the current implementation matches the functionss expected behavior, which is error prone and deviates from the goal of continuous integration.  Consider adding test coverage for the new retrieveRewardsOnMigratedVotingContract function.  Update: Resolved, not an issue. Tests were included but fell outside the scope of the audit. UMAs statement:  Test coverage was actually already added for this function, but in a separate PR to when the logic was added. This was added in an adjacent PR where we proposed to decrease the contract bytecode. The test for this logic can be found here.  Nonintuitive behavior of payable transactions in executeEmergencyProposal  In the EmergencyProposal contract, the executeEmergencyProposal function iterates through the transactions submitted on the proposal and executes them. However, only the first element in the array is able to execute a payable transaction, as the first element of the proposed transactions will transfer the entirety of the contract ETH balance, meaning that subsequent transactions will have a value of zero.  Consider documenting this behavior thoroughly as it may not be obvious or intuitive to the proposal submitter.  Update: Fixed as of commit 3b6239aa8b38610247674c952ba7379de898d4b6 in PR #4158. Further clarification provided by UMA regarding the behavior of the executeEmergencyProposal function:  The emergency proposer forwards its entire balance (presumably the amount sent by the caller) to the governor in the first transaction. However, the governor could spend that balance over multiple transactions. The only requirement is that the execution transaction has the total of all ETH sent in all emergency execution transactions.  require statements with multiple conditions  Throughout the codebase there are require statements that contain multiple conditions. For instance:  The require statement on line 202 of Staker.sol  The require statement on line 267 of VotingV2.sol  The require statement on line 762 of VotingV2.sol  The require statement on line 801 of VotingV2.sol  The require statement on line 986 of VotingV2.sol  Bundling multiple conditions into a single require statement reduces the contract size, but also prevents being able to provide a separate error message for each failure case.  Consider isolating each condition in its own require statement, to facilitate specific user-friendly error messages for every required condition.  Update: Acknowledged, and will not fix. UMAs statement:  We wont add this suggestion because of bytecode limitations.  Unlocked Solidity version pragma  There are two locations where the Solidity version used is ^0.8.0:  PR #4128, EmergencyProposerTest.sol, line 2  PR #4121, VotingUpgraderV2.sol, line 2  This version string allows compilation with any version of Solidity from 0.8.0 up to the latest release. This may lead to unexpected behavior if the code is deployed with a different Solidity version than was used during testing. Further, allowing old versions of Solidity leaves the code potentially vulnerable to known security bugs which have already been patched. The official guidance is to always use the latest Solidity release when deploying contracts. When a bug is discovered that affects a range of Solidity versions, the general policy of the Solidity team is to only apply the fix to the latest release (i.e. no backporting of security updates).  Consider locking the version pragma to the same Solidity version used during development and testing. Also consider setting this version to be the latest release.  Update: Fixed as of commit abb30bb58fdf222a6d28363922b179043cea755c in PR #4159 and commit 3be4710c3868ca553e8ab87a815febf939fe021f in PR #4178._  Notes & Additional Information  Lack of immutable identifier  VotingUpgraderV2 contract, the mutable state variables  only set once within the constructor. Consider declaring these state variables as immutable to increase gas efficiency and enhance the clarity of your codebase.  Update: Fixed as of commit 1c77938f762f7bc55a387dbccab11b9a86a464bf in PR #4160.  Misleading documentation  The codebase contains several occurrences of misleading or incorrect documentation:  VotingUpgraderV2:  The comment on  line 41 Existing governor is the only one who can initiate the upgrade appears to be a copy & paste error from  line 38 which is identical. Consider rewriting the comment.  The comment on  line 52 Addresses to upgrade does not apply to the  line 53. Consider rewriting the comment.  The comment on  line 62 Removes an address from the whitelist does not apply to the  Update: Fixed as of commit 77c2370cd2d8692042", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#missing-test-coverage", "labels": ["OpenZeppelin"]}, {"title": "Nonintuitive behavior of payable transactions in executeEmergencyProposal", "body": "Nonintuitive behavior of payable transactions in executeEmergencyProposal", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#nonintuitive-behavior-of-payable-transactions-in-executeemergencyproposal", "labels": ["OpenZeppelin"]}, {"title": "require statements with multiple conditions", "body": "require statements with multiple conditions", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#require-statements-with-multiple-conditions", "labels": ["OpenZeppelin"]}, {"title": "Unlocked Solidity version pragma", "body": "There are two locations where the Solidity version used is ^0.8.0:  PR #4128, EmergencyProposerTest.sol, line 2  PR #4121, VotingUpgraderV2.sol, line 2  This version string allows compilation with any version of Solidity from 0.8.0 up to the latest release. This may lead to unexpected behavior if the code is deployed with a different Solidity version than was used during testing. Further, allowing old versions of Solidity leaves the code potentially vulnerable to known security bugs which have already been patched. The official guidance is to always use the latest Solidity release when deploying contracts. When a bug is discovered that affects a range of Solidity versions, the general policy of the Solidity team is to only apply the fix to the latest release (i.e. no backporting of security updates).  Consider locking the version pragma to the same Solidity version used during development and testing. Also consider setting this version to be the latest release.  Update: Fixed as of commit abb30bb58fdf222a6d28363922b179043cea755c in PR #4159 and commit 3be4710c3868ca553e8ab87a815febf939fe021f in PR #4178._  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#unlocked-solidity-version-pragma", "labels": ["OpenZeppelin"]}, {"title": "Lack of immutable identifier", "body": "VotingUpgraderV2 contract, the mutable state variables  only set once within the constructor. Consider declaring these state variables as immutable to increase gas efficiency and enhance the clarity of your codebase.  Update: Fixed as of commit 1c77938f762f7bc55a387dbccab11b9a86a464bf in PR #4160.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#lack-of-immutable-identifier", "labels": ["OpenZeppelin"]}, {"title": "Misleading documentation", "body": "The codebase contains several occurrences of misleading or incorrect documentation:  VotingUpgraderV2:  The comment on  line 41 Existing governor is the only one who can initiate the upgrade appears to be a copy & paste error from  line 38 which is identical. Consider rewriting the comment.  The comment on  line 52 Addresses to upgrade does not apply to the  line 53. Consider rewriting the comment.  The comment on  line 62 Removes an address from the whitelist does not apply to the  Update: Fixed as of commit 77c2370cd2d86920429e658c157941c019fbf697 in PR #4152 and commit 3be4710c3868ca553e8ab87a815febf939fe021f in PR #4178.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Non-explicit imports are used", "body": "inside the codebase, which reduces code readability and could lead to conflicts between names defined locally and the ones imported. This is especially important if many contracts are defined within the same Solidity files or the inheritance chains are long.  Following the principle that clearer code is better code, consider using named import syntax (import {A, B, C} from \"X\") to explicitly declare which contracts are being imported.  For example, the DesignatedVotingV2 contracts import block can be rewritten more explicitly as:  The usage of explicit imports makes it clear that StakerInterface is provided by Stakeable.sol, and that OracleInterfaces is provided by Constants.sol.  Update: Acknowledged, and will not fix. UMAs statement:  Although it is a good suggestion, we have decided not to incorporate it for consistency with the rest of the imports in the other contracts.  Unnecessary modifier in setDelegate and setDelegator  In the Staker contract, the functions setDelegate and setDelegator use the nonReentrant modifier. This is not required as these two functions are only updating the state and cannot be exploited through a reentrancy attack.  Consider removing the nonReentrant modifier from these functions.  Update: Fixed as of commit 04dac164d4c8b026403aecb75730c7bc24f4400c in PR #4156.  Redundant code  Consider making the following changes to eliminate unnecessary code:  In PR #4110, Staker.sol:  line 246: The override keyword can be removed from the withdrawAndRestake function  In PR #4135, VotingV2.sol:  lines 978-980: The uint256(i) casts can be replaced with the variable i because i is already declared as a uint256 type on line 976 line 1045: (rewards) can be changed to rewards  Update: Fixed as of commit d5ab183d3a37a2114db7c3a6269ae66c932d1286 in PR #4162.  Redundant event parameters  In the EmergencyProposer contract, the following events all contain a uint256 lockedTokens parameter:  EmergencyProposalRemoved  EmergencyProposalSlashed  EmergencyProposalExecuted  In each case, when these events are emitted, the value of lockedTokens remains constant for a given proposal, which effectively provides no information because the value never changes.  Update: Acknowledged, and will not fix. UMAs statement:  The value of lockedTokens is constant across all events of the same emergency proposal during its lifecycle. However, to facilitate individual reading of the events, we have opted to leave it as is.  Drift between test and production contracts  commitVote,  revealVote, and  commitAndEmitEncryptedVote functions. While these functions were removed from the version of the  added to the  Consider removing the functions added to the VotingV2Test contract that are no longer present in the VotingV2 contract, and update tests accordingly.  Update: Acknowledged, and will not fix. UMAs statement:  We have decided not to incorporate these changes. Updates to the tests could take a long time compared to the outcome.  Typographical errors  Consider addressing the following typographical errors:  In EmergencyProposer.sol (PR #4128):  line 82: action.. should be action.  In Staker.sol (PR #4110):  line 113: users wallet should be users wallet line 241: msg.sender(voter or delegate) should be msg.sender (voter or delegate) (add 1 space)  In VotingV2.sol (PR #4117):  line 962: be either a should be be either line 1119: removed from should be removed from (delete 1 space)  In VotingV2.sol (PR #4118):  line 249: Must be set to 0x0 for production environments that use live time. refers to the deleted _timerAddress parameter and should be deleted  In VotingV2.sol (PR #4139):  line 499: participates should be participant  In VotingV2.js (PR #4139):  line 3123: not posable should be not possible  Update: Fixed as of commit c311e0a53c8b3a0ddb00fcea79341baca42d142a in PR #4165.  Unnecessary non-empty return value on success  _getPriceOrError in the  returns three values: *  comment on  return a non-empty string even when the price was successfully retrieved. Because the string message  is only used in the error case, users will never see the Returned from previous contract string.  Consider returning an empty string when _getPriceOrError returns true.  Update: Fixed as of commit 0aef75d2fe05488c31b462484c57277ee30e9cb0 in PR #4163.  Unnecessary public visibility in executeEmergencyProposal  In the EmergencyProposer contract, the executeEmergencyProposal function has public visibility. This is not required as the function is not called within the contract.  Consider changing the visibility of the executeEmergencyProposal function to external.  Update: Fixed as of commit fd4813895c1f113f71b03ac9cf79c5ab22710514 in PR #4166.  Unused imports  In the EmergencyProposer contract, the following files are imported but not used:  Constants.sol  OracleAncillaryInterface.sol  AdminIdentifierLib.sol  To improve readability and avoid confusion, consider removing the unused imports.  Update: Fixed as of commit a16bed5abe1de184c689ece8b", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#non-explicit-imports-are-used", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary modifier in setDelegate and setDelegator", "body": "Unnecessary modifier in setDelegate and setDelegator", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#unnecessary-modifier-in-setdelegate-and-setdelegator", "labels": ["OpenZeppelin"]}, {"title": "Redundant code", "body": "Consider making the following changes to eliminate unnecessary code:  In PR #4110, Staker.sol:  line 246: The override keyword can be removed from the withdrawAndRestake function  In PR #4135, VotingV2.sol:  lines 978-980: The uint256(i) casts can be replaced with the variable i because i is already declared as a uint256 type on line 976 line 1045: (rewards) can be changed to rewards  Update: Fixed as of commit d5ab183d3a37a2114db7c3a6269ae66c932d1286 in PR #4162.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#redundant-code", "labels": ["OpenZeppelin"]}, {"title": "Redundant event parameters", "body": "In the EmergencyProposer contract, the following events all contain a uint256 lockedTokens parameter:  EmergencyProposalRemoved  EmergencyProposalSlashed  EmergencyProposalExecuted  In each case, when these events are emitted, the value of lockedTokens remains constant for a given proposal, which effectively provides no information because the value never changes.  Update: Acknowledged, and will not fix. UMAs statement:  The value of lockedTokens is constant across all events of the same emergency proposal during its lifecycle. However, to facilitate individual reading of the events, we have opted to leave it as is.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#redundant-event-parameters", "labels": ["OpenZeppelin"]}, {"title": "Drift between test and production contracts", "body": "commitVote,  revealVote, and  commitAndEmitEncryptedVote functions. While these functions were removed from the version of the  added to the  Consider removing the functions added to the VotingV2Test contract that are no longer present in the VotingV2 contract, and update tests accordingly.  Update: Acknowledged, and will not fix. UMAs statement:  We have decided not to incorporate these changes. Updates to the tests could take a long time compared to the outcome.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#drift-between-test-and-production-contracts", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Consider addressing the following typographical errors:  In EmergencyProposer.sol (PR #4128):  line 82: action.. should be action.  In Staker.sol (PR #4110):  line 113: users wallet should be users wallet line 241: msg.sender(voter or delegate) should be msg.sender (voter or delegate) (add 1 space)  In VotingV2.sol (PR #4117):  line 962: be either a should be be either line 1119: removed from should be removed from (delete 1 space)  In VotingV2.sol (PR #4118):  line 249: Must be set to 0x0 for production environments that use live time. refers to the deleted _timerAddress parameter and should be deleted  In VotingV2.sol (PR #4139):  line 499: participates should be participant  In VotingV2.js (PR #4139):  line 3123: not posable should be not possible  Update: Fixed as of commit c311e0a53c8b3a0ddb00fcea79341baca42d142a in PR #4165.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary non-empty return value on success", "body": "_getPriceOrError in the  returns three values: *  comment on  return a non-empty string even when the price was successfully retrieved. Because the string message  is only used in the error case, users will never see the Returned from previous contract string.  Consider returning an empty string when _getPriceOrError returns true.  Update: Fixed as of commit 0aef75d2fe05488c31b462484c57277ee30e9cb0 in PR #4163.  Unnecessary public visibility in executeEmergencyProposal  In the EmergencyProposer contract, the executeEmergencyProposal function has public visibility. This is not required as the function is not called within the contract.  Consider changing the visibility of the executeEmergencyProposal function to external.  Update: Fixed as of commit fd4813895c1f113f71b03ac9cf79c5ab22710514 in PR #4166.  Unused imports  In the EmergencyProposer contract, the following files are imported but not used:  Constants.sol  OracleAncillaryInterface.sol  AdminIdentifierLib.sol  To improve readability and avoid confusion, consider removing the unused imports.  Update: Fixed as of commit a16bed5abe1de184c689ece8bb5e56e3c183f3e8 in PR #4164.  Unused variables  Within the EmergencyProposer contract, several variables are defined but not used:  The finder state variable is initialized in the constructor, but otherwise is not used  The currentId state variable is never used  To improve readability and avoid confusion, consider removing the unused variables.  Update: Fixed as of commit 5f7567e7c9686ae68565a09fe4db49a2cd29a2f4 in PR #4167.  Conclusions  A single medium severity issue was found. Some recommendations were also made to improve the quality of the codebase.  There were multiple changes regarding VotingV2 that were done to reduce the contract bytecode size as it was reaching the limit. However, some of these changes included removing errors from require statements or grouping multiple conditions into a single statement. These changes make it more difficult for a user to debug failures when interacting with a contract and make the codebase less readable.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#unnecessary-non-empty-return-value-on-success", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary public visibility in executeEmergencyProposal", "body": "Unnecessary public visibility in executeEmergencyProposal", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#unnecessary-public-visibility-in-executeemergencyproposal", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "In the EmergencyProposer contract, the following files are imported but not used:  Constants.sol  OracleAncillaryInterface.sol  AdminIdentifierLib.sol  To improve readability and avoid confusion, consider removing the unused imports.  Update: Fixed as of commit a16bed5abe1de184c689ece8bb5e56e3c183f3e8 in PR #4164.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "Unused variables", "body": "Within the EmergencyProposer contract, several variables are defined but not used:  The finder state variable is initialized in the constructor, but otherwise is not used  The currentId state variable is never used  To improve readability and avoid confusion, consider removing the unused variables.  Update: Fixed as of commit 5f7567e7c9686ae68565a09fe4db49a2cd29a2f4 in PR #4167.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-incremental-audit#unused-variables", "labels": ["OpenZeppelin"]}, {"title": "Medium: Parasitic staking term issue", "body": "This issue allows for a parasitic staker to accumulate rewards without having to participate on a vote and without ever being slashed. The root cause of this is that the slashing mechanism only takes into account the activeStake of a staker while deciding to slash a user, while the rewards mechanism takes both activeStake and pendingStake into account.  Update: Fixed as of commit fd8cecc6719a7a69d44287b2096866686313593c of pull request #4168.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#medium:-parasitic-staking-term-issue", "labels": ["OpenZeppelin"]}, {"title": "Low: Unresolvable price request issue", "body": "This issue causes that a price request becomes unresolvable under very specific conditions: If a price request is made, then the price request rolls over, the only participant who voted on the request was not staked before the request and they had staked during the reveal phase post roll over.  Then the price request can only be resolved if another voter who staked before the request participates once the request rolls over again.  Update: Fixed as of commit 2d4fad7cb3525a7faeb88f07953907d3c4515796 of pull request #4139.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#low:-unresolvable-price-request-issue", "labels": ["OpenZeppelin"]}, {"title": "Findings", "body": "Here we present our findings.  Critical Severity", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#findings", "labels": ["OpenZeppelin"]}, {"title": "Slashing mechanism grants exponentially more rewards than expected", "body": "In the VotingV2 contract the function updateTrackers calls the internal function _updateAccountSlashingTrackers with parameter indexTo set to the priceRequestIds.length to process the slashing rewards and penalties associated with all resolved requests.  ensured that any  Additionally, the contract contains a function updateTrackersRange that is callable without authorization, with freely chosen parameters voterAddress and indexTo which are passed to _updateAccountSlashingTrackers. The use of this function is necessary whenever the potentially unbounded amount of requests to be processed within the for-loop exceeds the gas limit.  Consider modifying the respective update functions to ensure that slash values can only be applied round-wise. Additionally, consider implementing a monitoring solution that continuously checks whether the sum of all staked balances is equal to the amount of UMA contained within the contract and whether this value lies within an expected range. Finally, consider implementing an emergency mechanism to temporarily suspend the reward system without affecting the contracts functionality as a governance and voting system.  Update: Fixed as of commit 18aef110f2bc882a9bfe115bc4ca86f3681f2d4b in pull request #4067.  High Severity", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#slashing-mechanism-grants-exponentially-more-rewards-than-expected", "labels": ["OpenZeppelin"]}, {"title": "Duplicate Request Rewards", "body": "_updateAccountSlashingTrackers function contains an optimization that marks unresolved requests in a prior round (rolled votes) as deleted via an entry in the  line 860 enables future callers to skip an  However, the request processing logic within _updateAccountSlashingTrackers is not able to correctly handle multiple rolled votes that appear sequentually in the request array. Consider the following scenario:  The deletedRequests map is initially empty and the previous voting round contained three votes (limiting to 3 just for simplicity). In this example we will number these request indexes as 1, 2, 3. Assume the the first two votes (index 1 and 2) have not been resolved and are considered rolled, while index 3 is considered resolved. The first voter to call the _updateAccountSlashingTrackers function will go through the array of requests to process and cause a modification of the deletedRequests mapping to  and re-append each requests identifier to the priceRequestIds array. This creates index 4 and 5 in our example.  The next voter that calls this same function will not process request 1 due to the logic in line 845. Instead, the requestIndex will be updated to 2. However, there is no additional check ensuring that index 2 has not been deleted as well; the code assumes this is not the case and index 2 will be processed again instead of being skipped as intended.  line 858 the if-statement condition will fail thereby allowing the code to reach the break statement on  line 867. Consequently, the entire loop is terminated without increasing the voters  lines 865-866 indicates that if the  line 920.  Now, assuming both rolled requests are resolved in the following round, our previous voter calls (indirectly) this function again. Because lastRequestIndexConsidered was not updated, once again the processing starts at index 1, which is again skipped on line 845 when it is looked up in the deletedRequests map, and requestIndex is advanced to 2. Execution continues to line 854, which will evaluate to true because the corresponding request has been resolved, so slashing will be applied for index 2. On the next cycles of the for-loop, indices 3, 4, and 5 will be processed. Recall however that index 4 and 5 are re-queued elements that reference the same identifiers as index 1 and 2. Therefore, the slashing penalties for index 2 will be processed twice in this example. In this example all the requests were resolved, but if that had not been the case, additional duplications would have occurred each time a vote was rolled to the next round.  The underlying bug is the incorrect assumption on line 845 that assumes deletedRequests wont contain consecutive unresolved votes. There are several ways the fix can be approached depending on the tradeoff between simplicity vs efficiency. Consider some possible options:  A straightforward fix that sets requestIndex = deletedRequests[requestIndex] on line 845 (remove the + 1) and then inserts a continue statement. This would return execution back to line 843 where requestIndex would be incremented as before, but ensures that the deletedRequests[requestIndex] != 0 test on line 845 is applied to this new index.  A more complex but efficient fix would be to additionally store the inverse mapping to deletedRequest to enable jumping over adjacent skipped indices in one step by modifying the target of the first index.  Update: Fixed as of commit 8356375e8893d3b0375345b0464ef0fe10d15c26 in pull request #4064 by adopting the first recommendation.  Medium Severity", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#duplicate-request-rewards", "labels": ["OpenZeppelin"]}, {"title": "Incorrect refund of spamDeletionProposalBond", "body": "VotingV2.sol contract the  spamDeletionProposalBond determines the amount of  signalRequestsAsSpamForDeletion. An amount of  If the owner mistakenly calls setSpamDeletionProposalBond between a spam deletion request and its execution, the value of the refunded bond will differ from the originally submitted bond, thereby leading to a loss for either the original requester or the VotingV2 contract.  Consider adding a new uint256 bond parameter to the SpamDeletionRequest struct to record the bond amount at the time a specific request was submitted, and using this value during the call to executeSpamDeletion.  Update: Partially fixed in commit 52b32d4e1f6f7262228b7c3d7f1fa00b95c4d4b2 of pull request #4065. Our recommendation has been adopted in the case of a successful spamDeletionProposal. However, in the case of unsuccesful proposal, the amount sent to the store contract remains affected.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#incorrect-refund-of-spamdeletionproposalbond", "labels": ["OpenZeppelin"]}, {"title": "Incorrect math in slashing library comments", "body": "In the SlashingLibrary contract the functions calcWrongVoteSlashPerToken and calcNoVoteSlashPerToken are meant to return constants representing a slashing percentage per wrong vote or no vote that would counteract the 20% staking APY under the assumption of 120 yearly votes. Both functions contain commentary with an incorrect mathematical formula to counteract a 20% APY.  More specifically, the formula outlined in the inline comments  uses basic interest instead of compound interest and assumes that a 20% increase will be negated with a subsequent 20% loss. However, the correct formula to counteract a 20% APY over 120 votes would be  While the current deviation between both values is negligible, applying the correct formula becomes crucially important for a higher APY and more yearly votes.  Consider updating the documentation to include both the correct mathematical formula and an advisory to check the inequality  to prevent setting any incentives for staking without participating in votes.  Update: Fixed as of commit fed9d90bff9ec5052ced798e52ff36502f3cac1e of pull request #4066.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#incorrect-math-in-slashing-library-comments", "labels": ["OpenZeppelin"]}, {"title": "Stake can be withheld indefinitely", "body": "Staker contract the function  setUnstakeCoolDown allows the contract owner to set the  Giving the contract owner full control over setting unstakeCoolDown violates the trust assumptions typically present in a staking system. Namely, stakers expect to be able to retrieve their stake regardless of operator error or operator malice. Setting unstakeCoolDown to a very large value would render each users stake practically unretrievable.  The intended use of this contract is to be owned by the GovernorV2 contract thereby allowing the affected stakers to control the unstakeCoolDown through governance proposals, which reduce the likelihood of malice. However, voters who disagree with a legitimate majority vote to extend unstakeCoolDown will most likely not be able to leave the staking system before the changes take effect.  Consider validating the input of the setUnstakeCoolDown function against an acceptable maximum cooldown time. Also consider allowing the retroactive application of a new unstakeCoolDown value only in cases when it acts to decrease the cooldown time of users who are actively unstaking.  Update: Acknowledged. UMA indicated that the economic incentives between stakeholders make this scenario unlikely. The increased complexity and gas cost of the suggested recommendation does not appear justified.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#stake-can-be-withheld-indefinitely", "labels": ["OpenZeppelin"]}, {"title": "Limitations of contract migration", "body": "The VotingV2 contract includes a setMigrated administrative function that sets an associated migratedAddress which stores the address of a future version of the voting system (e.g. V3).  onlyIfNotMigrated and  onlyRegisteredContract modifiers which restrict its functionality in the event of a migration. The  However, there are several concerns with the existing migration design:  The onlyRegisteredContract modifier allows forwarding price requests from the contract deployed at migratedAddress to VotingV2 after migratedAddress has been set, but the onlyIfNotMigrated modifier prevents anyone from voting on those requests.  Voter tokens are staked on the VotingV2 contract and there is a GAT threshold for voting. If users are directed to migrate their staked tokens from VotingV2 to the new Voting contract, there may be a transition period where not enough users are staked on either contract to reach the GAT threshold for voting.  Ideally, contract migration would occur during a time window when there are no active requests. Attempting to upgrade the contract while price requests are active would result in it not being able to complete the voting process on those requests due to the disabled state of the commit and reveal functions. However a price request can occur at any time, and if demand for the voting system increases in the future, it will become more difficult to chance upon a time window where there is no activity in the voting system, and there is no guarantee that such a window will exist.  To avoid a situation where the voting system cannot be upgraded, consider introducing an upgrade mechanism that allows for migration in several distinct steps while ensuring that the voting system remains functional at each stage.  Update: Partially fixed in commit 852b60531bb1888d581046a3ccda3a68d4856f33 of pull request #4105. Forwarding price requests to the old contract have been fixed, while UMA indicated that additional measures to facilitate migration will be addressed in a future version.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#limitations-of-contract-migration", "labels": ["OpenZeppelin"]}, {"title": "Lack of emergency administration", "body": "The VotingV2 contract has several functions that are protected by the onlyOwner modifier:  requestGovernanceAction  setMigrated  setGat  setRewardsExpirationTimeout  setSlashingLibrary  setSpamDeletionProposalBond  setEmissionRate (inherited from Staker)  setUnstakeCoolDown (inherited from Staker)  propose function in the  calling the Ownable base contract function transferOwnership(), as demonstrated in the  This change of ownership means that the GovernorV2 contract also becomes the only valid caller for the setter functions in the list above. In order to call any of these functions, a governance action must be proposed with Transaction data that will invoke the target function, and subsequently executed via the executeProposal function.  The concern with this approach is that the voting system is potentially a single point of failure for administrative governance actions. Taking the setGat function as an example, if voter participation becomes insufficient to meet the GAT threshold and the GAT value needs to be lowered, a governance proposal to call setGat may be prevented from execution if the existing GAT value prevents that vote from succeeding. Furthermore, future versions of the DVM with new administrative functions may encounter the same problem where the current state of the Voting contract prevents a new corrective state from being applied.  To address this issue, consider developing an out-of-band system that allows UMA governance to execute emergency corrective actions for the voting system that do not rely on the voting system itself in order to succeed. For this approach, it is recommended to use a multisig wallet to control access to the onlyOwner-protected functions. Also consider implementing minimum and maximum values for each setter function that restrict governance changes to a safe range.  Update: Acknowledged. UMA acknowledges that emergency administration is a concern. However, due to the complexity and severity of changes it cannot be addressed as part of this audit.  Low Severity", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#lack-of-emergency-administration", "labels": ["OpenZeppelin"]}, {"title": "Staker contract should be declared abstract", "body": "The Staker contract contains the following internal virtual functions:  inActiveReveal which always returns false and is meant to return a boolean value that indicates whether or not the voting system is currently in a reveal phase  getStartingIndexForStaker which always returns 0 and is meant to return a uint64 value indicating the index of the first request from which slashing rewards and penalties apply to a new staker  Neither function is supposed to modify the contract state despite lacking a view identifier.  Further, the documentation of the inActiveReveal function states This function should be overridden by the child contract. This suggests the Staker contract is designed to always be inherited by a child contract which overrides both virtual functions, and never deployed as a standalone contract.  To enforce the intended design, prevent accidental deployments, and enhance the clarity of your code base, consider declaring the Staker contract with the abstract keyword and removing the function body of inActiveReveal and getStartingIndexForStaker in order to force their implementation by a derived contract. Additionally, consider adding the view modifier to both function declarations.  Update: Fixed as of commit 8b3084adcd51fba381e733d05b75345fa3db5e4d in pull request #4068.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#staker-contract-should-be-declared-abstract", "labels": ["OpenZeppelin"]}, {"title": "Duplicate function execution", "body": "VotingV2 contract the overloaded function  commitAndEmitEncryptedVote that is provided for backwards compatibility mistakenly calls  line 614, and an additional call is performed indirectly by the call to  line 616.  The duplicate call is an unnecessary gas expense and leads to an unintentional duplication of VoteCommitted event emission.  Consider removing the direct call to commitVote from the function body.  Update: Fixed as of commit 4cd15fceb99ab03ad978f1dd01a3d0d146b6253d in pull request #4069.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#duplicate-function-execution", "labels": ["OpenZeppelin"]}, {"title": "Imprecise function name", "body": "In the DesignatedVotingV2 contract, the retrieveRewards function name suggests that the caller will gain possession of the rewards; this assumption is further reinforced by the docstrings description of the return value as amount of rewards that the user should receive. However, instead of transferring rewards to the user, the retrieveRewards function restakes users rewards.  To avoid confusion, consider renaming the retrieveRewards function to withdrawAndRestakeRewards or some other name that more accurately describes its behavior.  Update: Fixed as of commit 284c6842ed05b13cfdc82cb3b5dd897507696e8f in pull request #4071.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#imprecise-function-name", "labels": ["OpenZeppelin"]}, {"title": "Incorrect documentation for voting commit hash", "body": "lines 559-563 of the  The structure of the commit hash is described in the docstrings of several functions within the DesignatedVotingV2 and VotingV2 contracts. However, none of these docstrings appears to describe the format of the hash correctly:  In DesignatedVotingV2.sol:  line 56: The commitVote docstring describes the input hash as the keccak256 hash of the price you want to vote for and a random integer salt value. This description omits the required voterAddress, time, ancillaryData, currentRoundId, and identifier. line 74: The commitAndEmitEncryptedVote docstring describes the input hash as keccak256 hash of the price you want to vote for and a int256 salt. This description omits the required voterAddress, time, ancillaryData, currentRoundId, and identifier. line 91: The revealVote docstring describes the input price as used along with the salt to produce the hash during the commit phase. This description is technically correct but implies these are the only two values required, omitting voterAddress, time, ancillaryData, currentRoundId, and identifier. line 92: The revealVote docstring describes the input salt as used along with the price to produce the hash during the commit phase. This description is technically correct but implies these are the only two values required, omitting voterAddress, time, ancillaryData, currentRoundId, and identifier.  In VotingV2.sol:  line 488 : The commitVote docstring describes the input hash as keccak256 hash of the price, salt, voter address, time, current roundId, and identifier. This description omits the required ancillaryData variable. line 526: The revealVote docstring states that The revealed price, salt, address, time, roundId, and identifier, must hash to the latest hash. This comment omits the requires ancillaryData variable.  Furthermore, while the type of all the encoded values can be deduced by examining the input parameters and body of the revealVote function, this type information is not explicitly provided to voters in the documentation of the commit functions where the hash is inputted.  An incorrectly formatted commit hash can lead to a voter being slashed when the revealVote function attempts to re-create the submitted hash and fails.  To avoid any misunderstanding about the hash encoding and the potential for unintentional wrong votes, consider carefully documenting the exact format of the commit hash in all docstrings where it is referenced.  Update: Fixed as of commit 4f8798aeb90b1b3419f6e6da3ae1531ef07c058b in pull request #4072.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#incorrect-documentation-for-voting-commit-hash", "labels": ["OpenZeppelin"]}, {"title": "Lack of input verification in library functions", "body": "In the SpamGuardIdentifierLib contract, the function _constructIdentifier does not document or enforce the range of allowed input values for its function parameter uint256 id.  Supplying a value of 10^11 or greater as parameter id will lead to silent unexpected behavior and potentially cause the generation of duplicate identifiers, because the concatenation of the decimal string AdminIdentifierLib._uintToUtf8(id) and the identifier SpamDeletionProposal  is limited to 32 bytes. While the current usage of SpamGuardIdentifierLib within VotingV2 appears safe, this might change due to future modifications of the code base.  Consider both explicitly documenting the valid range of the input parameter and including a require statement that enforces this range.  Update: Fixed as of commit 97ca84895e094a825c55c4b905e262c771a6c80a in pull request #4073 by reducing the input to uint32.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#lack-of-input-verification-in-library-functions", "labels": ["OpenZeppelin"]}, {"title": "Missing documentation", "body": "Many of the functions, events, and variables within the codebase lack documentation.  Contracts that do not have a docstring:  SlashingLibrary  SpamGuardIdentifierLib  Functions that do not have a docstring:  _getVotingContract in DesignatedVotingV2.sol  _executeCall, _getOracle, getIdentifierWhitelist in GovernorV2.sol  updateTrackers, getStartingIndexForStaker in Staker.sol  computeRoundToVoteOnPriceRequest in VoteTimingV2.sol  getNumberOfPriceRequests, _getPriceRequest, _encodePriceRequest, _freezeRoundVariables, _priceRequestResolved, _computeGat, _getRequestStatus, unsafe_inc, unsafe_inc_64, _getIdentifierWhitelist, _requireNotMigrated, _requireRegisteredContract in VotingV2.sol  Docstrings that are incomplete:  commitVote in DesignatedVotingV2.sol is missing the @param for ancillaryData  _constructIdentifier in SpamGuardIdentifierLib.sol is missing the @param for id  init in VoteTimingV2.sol is missing the @param documentation for all input parameters  getVoterFromDelegate in VotingV2.sol is missing the @param for caller  constructor in VotingV2.sol is missing the @param for _spamDeletionProposalBond and _startingRequestIndex  Many events and storage variables throughout the codebase also lack explanatory comments.  Finally, some useful documentation was recently removed:  Documentation for the NewProposal and ProposalExexcuted events in GovernorV2.sol  Documentation explaining the propose functions public visibility in GovernorV2.sol   hinder reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions that implement sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec). Also consider providing explanatory comments for all events, structs, and storage variables that indicate their intended purpose.  Update: Partially fixed as of commit 3d68ad7fa471d4d763ab3ae9e6e5052bad1dce8e in pull request #4077. The following functions still lack docstrings:  getIdentifierWhitelist in GovernorV2.sol  updateTrackers, getStartingIndexForStaker in Staker.sol  _requireRegisteredContract in VotingV2.sol", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#missing-documentation", "labels": ["OpenZeppelin"]}, {"title": "Missing error messages in require statements", "body": "Within the codebase, there are multiple require statements that lack error messages.  In VotingV2.sol:  The require statement on line 552 The require statement on line 771 The require statement on line 810 The require statement on line 961 The require statement on line 993 The require statement on line 999 The require statement on line 1188 The require statement on line 1192  In VoteTimingV2.sol:  The require statement on line 24 The require statement on line 25  Consider including specific, informative error messages in require statements to improve overall code clarity and to facilitate troubleshooting whenever a requirement is not satisfied.  Update: Fixed as of commit f29085860f7a32a480825e06b8f69c3456ea19dc in pull request #4074.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#missing-error-messages-in-require-statements", "labels": ["OpenZeppelin"]}, {"title": "Testcode in production", "body": "The ProposerV2 and GovernorV2 contracts inherit the Testable contract, which is meant to allow setting and providing the time via an additional external contract. During deployment to a production environment the inheritance of Testable is meant to be kept while disabling the external time setter by passing the zero address to the testable constructor.  This testing methodology increases both the code size and the risk of deployment mistakes. Further, it allows multiple time sources for different contracts within the projects test cases, thereby increasing the likelihood of erroneous tests.  Consider replacing the Testable contract with equivalent functionality provided by the projects test framework. For example, consider using evm_setNextBlockTimestamp in Hardhat or vm.warp in Foundry.  Update: Fixed as of commit 90b6634f6daebf02100f4a1b8aa6bca22bc64cc8 in pull request #4095.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#testcode-in-production", "labels": ["OpenZeppelin"]}, {"title": "Unlocked Solidity version pragma", "body": "Throughout the codebase, the Solidity version used is ^0.8.0, which allows compilation with any version of Solidity from 0.8.0 up to the latest release. This may lead to unexpected behavior if the code is deployed with a different Solidity version than was used during testing. Further, allowing old versions of Solidity leaves the code potentially vulnerable to known security bugs which have already been patched. The official guidance is to always use the latest Solidity release when deploying contracts. When a bug is discovered that affects a range of Solidity versions, the general policy of the Solidity team is to only apply the fix to the latest release (i.e. no backporting of security updates).  Consider locking the version pragma to the same Solidity version used during development and testing. Also consider setting this version to be the latest release.  Update: Partially fixed in commit 4f6cc15e0dd573095b8485e57ca91330bfc5bbdc within pull request #4075. The pragma has been updated to 0.8.15 in most contracts, however Staker, SlashingLibrary and SpamGuardIdentifierLib retain an unlocked pragma.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#unlocked-solidity-version-pragma", "labels": ["OpenZeppelin"]}, {"title": "Withdraw role is not configured", "body": "The DesignatedVotingV2Factory contract inherits from the Withdrawable contract, a base contract which provides the ability to create a Withdraw role and assign it to one or more addresses to grant them the ability to withdraw ETH or ERC20 tokens from the contract by using the corresponding withdraw and withdrawErc20 functions.  _createWithdrawRole and  setWithdrawRole, and the documentation for these functions indicates that one or the other must be called by the derived contract (  Given the intended purpose of the DesignatedVotingV2Factory contract, it does not appear that it requires the Withdrawable feature. Consider removing the inheritance from Withdrawable and the corresponding import of Withdrawable.sol.  Update: Fixed as of commit 88c79f4403d6f61715fab044c8933e8d90ca4366 in pull request #4078.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#withdraw-role-is-not-configured", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent usage of reentrancy protection", "body": "In the GovernorV2 contract, the function executeProposal is protected against reentrancy by the checks-effects-interactions pattern. In contrast, the ProposerV2 contract provides an additional layer of safety against re-entrancy attacks by importing the Lockable contract and using its modifiers.  Consider inheriting from Lockable and using the nonReentrant modifier as an additional precaution.  Update: Fixed as of commit 32e27d1ca004a33a8f0ac256ccfc4f526666eeb0 in pull request #4080. The nonReentrant modifier was applied to the executeProposal function as recommended. Additionally, the nonReentrant modifier was also applied to the following functions:  The propose function in GovernorV2.sol  The stake, requestUnstake, executeUnstake, withdrawRewards, and withdrawAndRestake in functions in Staker.sol  The requestPrice, commitVote, revealVote, setDelegate, setDelegator, signalRequestAsSpamForDeletion, and executeSpamDeletion functions in VotingV2", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#inconsistent-usage-of-reentrancy-protection", "labels": ["OpenZeppelin"]}, {"title": "Duplicate code", "body": "VotingV2 contract,  lines 1136-1140 in the  pendingPriceRequests array. The  lines 1010-1016, with the only difference being that  Consider moving this duplicated code into a new shared function.  Update: Fixed as of commit ce97e9124402996f77f2c8cf22c236f599de9456 in pull request #4081 by moving the duplicated code into a new shared function named _removeRequestFromPendingPriceRequests.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#duplicate-code", "labels": ["OpenZeppelin"]}, {"title": "Duplicate computations", "body": "In the ProposerV2 contract, the function resolveProposal performs two subsequent calls to AdminIdentifierLib._constructIdentifier(id) in line 91 and line 99 without storing the return value.  Consider performing only one call and capturing the return value to enhance the gas efficiency of your code.  Update: Fixed as of commit 4c116c98224c78ef866c9a8f960c4ac4a6c08ad2 in pull request #4082.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#duplicate-computations", "labels": ["OpenZeppelin"]}, {"title": "Erroneous imports", "body": "The ProposalV2 contract erroneously imports Voting.sol instead of VotingV2.sol.  Currently, all function signatures used within ProposalV2 are available in both Voting.sol and VotingV2.sol, thereby preventing any direct consequences.  Consider upgrading the import to VotingV2.sol for consistency.  Update: Fixed as of commit 0267ae4d344df061c9e392dc1cf862de82ff43d6 in pull request #4083 by replacing the Voting.sol import with OracleAncillaryInterface.sol, which provides an interface for the hasPrice and getPrice voting functions used by ProposerV2.sol.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#erroneous-imports", "labels": ["OpenZeppelin"]}, {"title": "WithdrawnRewards is emitted for zero rewards", "body": "withdrawRewards function in the  emits a  the if block that checks for a non-zero value of  Consider only emitting the WithdrawnRewards event if tokensToMint is not zero.  Update: Fixed as of commit 703662231d4399a869e4ce990868cb2061f9e402 in pull request #4084.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#withdrawnrewards-is-emitted-for-zero-rewards", "labels": ["OpenZeppelin"]}, {"title": "Lack of immutable identifier", "body": "In the ProposerV2 contract, the mutable state variables token, governor, and finder are only set once within the constructor.  In the Staker contract, the mutable state variable votingToken is only set once within the constructor. Consider declaring these state variables as immutableto increase gas efficiency and enhance the clarity of your code base.  Update: Fixed as of commit 8be5f9c16f27e283f5cd5654e168a28d17b9d655 in pull request #4085.  Inconsistent declarations for finder variable  Finder contract to lookup the addresses of other deployed UMA contracts. While most contracts in the DVM implementation store a  FinderInterface type in their  Proposer and  ProposerV2 contracts store a  Additionally, some contracts declare their finder variable with private visibility, while others declare finder as a public variable.  Consider making these declarations consistent within the codebase by uniformly applying the same contract type and visibility to all instances of the finder storage variable.  Update: Partially fixed as of commit 2f5f667994c96612e95417de24f526b94a37b6c0 in pull request #4086. In the VotingV2 contract, the finder variables visibility was changed from private to public, but there is still an inconsistent application of private and public visibility applied to this variable across ProposerV2 (public), GovernorV2 (private), DesignatedVotingV2 (private), and VotingV2 (public). Additionally, Proposer and ProposerV2 still use the Finder type.  Inconsistent function naming  Throughout the codebase, a leading underscore is used to denote private and internal functions. However, several functions that are marked internal do not follow this pattern. To avoid confusion, consider the following renaming suggestions:  In Staking.sol:  inActiveReveal should be _inActiveReveal getStartingIndexForStaker should be _getStartingIndexForStaker  In VotingV2.sol:  applySlashToVoter should be _applySlashToVoter  Update: Fixed as of commit 59c103a5a378505203a1fc78146e494ed26905bb in pull request #4087.  Inconsistent event indexing  VotingV2 contract, the  PriceRequestAdded event applies the  time variable but not the  requester variable. All other events within this contract that emit a  To use indexing consistently, in the PriceRequestAdded event consider removing the indexed keyword from time and adding it to requester.  Update: Fixed as of commit c6a8f7e088aefb5d5b5f77407e3ef400fe743d77 in pull request #4088.  Misleading variable name  In the updateTrackersRange function, the indexTo parameter is the last price request index to update the trackers for. On line 810 there is a check that indexTo <= priceRequestIds.length; at first glance this appears to be an off-by-one error because array indexing starts at index 0 and the index is considered out of bounds if it is greater than or equal to the length of the array.  However, in the _updateAccountSlashingTrackers function, the for-loop test condition ensures that the maximum index value used to access the priceRequestIds array is indexTo - 1, thereby preventing any out-of-bounds access. Thus the logic appears correct, but the name indexTo is misleading because it specifies the maximum element number to include in the update, not the maximum index number.  To avoid confusion, consider renaming the indexTo variable, or update the documentation to clarify that this is not an array index value.  Update: Acknowledged. UMAs statement for this issue:  We chose to not implement any change for this note.  Use of magic values  In the VotingV2 contract, the function executeSpamDeletion contains the magic value 1e18 which represents a successful vote in favor of a spam deletion request.  Using inline magic values hinders code legibility and increases the chance of introducing erroneous values.  Consider assigning all magic values to descriptive constants and replacing all semantically matching occurrences of the value with its respective constant.  Update: Fixed as of commit baf99022bb69c0744a5b13b26610245c49c74b93 in pull request #4089 by eliminating the magic value 1e18 and interpreting any non-zero price value as a yes vote. This behavior is consistent with the existing price validation that is performed in the executeProposal function.  Misleading documentation  The code base contains multiple occurrences of misleading or incorrect documentation:  In the contract DesignatedVotingV2, the comment on line 21 Is also permanently permissioned as the minter role appears to be a copy & paste error as a minting function is not part of the contract. Consider removing the comment.  In the contract SlashingLibrary, the docstring for calcSlashing on line 55 contains the erroneous expression cross-chain calls. Consider altering it to cross-contract calls.  In the contract VotingV2, the comment on line 161 describes the spamDeletionProposals variable as Maps round numbers to the spam deletion request. However, mapping indices to values is a property every array possesses. Consider revisi", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#lack-of-immutable-identifier", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent declarations for finder variable", "body": "Inconsistent declarations for finder variable", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#inconsistent-declarations-for-finder-variable", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent function naming", "body": "Throughout the codebase, a leading underscore is used to denote private and internal functions. However, several functions that are marked internal do not follow this pattern. To avoid confusion, consider the following renaming suggestions:  In Staking.sol:  inActiveReveal should be _inActiveReveal getStartingIndexForStaker should be _getStartingIndexForStaker  In VotingV2.sol:  applySlashToVoter should be _applySlashToVoter  Update: Fixed as of commit 59c103a5a378505203a1fc78146e494ed26905bb in pull request #4087.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#inconsistent-function-naming", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent event indexing", "body": "VotingV2 contract, the  PriceRequestAdded event applies the  time variable but not the  requester variable. All other events within this contract that emit a  To use indexing consistently, in the PriceRequestAdded event consider removing the indexed keyword from time and adding it to requester.  Update: Fixed as of commit c6a8f7e088aefb5d5b5f77407e3ef400fe743d77 in pull request #4088.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#inconsistent-event-indexing", "labels": ["OpenZeppelin"]}, {"title": "Misleading variable name", "body": "In the updateTrackersRange function, the indexTo parameter is the last price request index to update the trackers for. On line 810 there is a check that indexTo <= priceRequestIds.length; at first glance this appears to be an off-by-one error because array indexing starts at index 0 and the index is considered out of bounds if it is greater than or equal to the length of the array.  However, in the _updateAccountSlashingTrackers function, the for-loop test condition ensures that the maximum index value used to access the priceRequestIds array is indexTo - 1, thereby preventing any out-of-bounds access. Thus the logic appears correct, but the name indexTo is misleading because it specifies the maximum element number to include in the update, not the maximum index number.  To avoid confusion, consider renaming the indexTo variable, or update the documentation to clarify that this is not an array index value.  Update: Acknowledged. UMAs statement for this issue:  We chose to not implement any change for this note.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#misleading-variable-name", "labels": ["OpenZeppelin"]}, {"title": "Use of magic values", "body": "In the VotingV2 contract, the function executeSpamDeletion contains the magic value 1e18 which represents a successful vote in favor of a spam deletion request.  Using inline magic values hinders code legibility and increases the chance of introducing erroneous values.  Consider assigning all magic values to descriptive constants and replacing all semantically matching occurrences of the value with its respective constant.  Update: Fixed as of commit baf99022bb69c0744a5b13b26610245c49c74b93 in pull request #4089 by eliminating the magic value 1e18 and interpreting any non-zero price value as a yes vote. This behavior is consistent with the existing price validation that is performed in the executeProposal function.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#use-of-magic-values", "labels": ["OpenZeppelin"]}, {"title": "Misleading documentation", "body": "The code base contains multiple occurrences of misleading or incorrect documentation:  In the contract DesignatedVotingV2, the comment on line 21 Is also permanently permissioned as the minter role appears to be a copy & paste error as a minting function is not part of the contract. Consider removing the comment.  In the contract SlashingLibrary, the docstring for calcSlashing on line 55 contains the erroneous expression cross-chain calls. Consider altering it to cross-contract calls.  In the contract VotingV2, the comment on line 161 describes the spamDeletionProposals variable as Maps round numbers to the spam deletion request. However, mapping indices to values is a property every array possesses. Consider revising the comment to give a more contextual description of the identifier and its usage.  In the contract VotingV2, the docstring for getRoundEndTime on lines 716-719 appears to be a copy & paste error that duplicates the docstring of the getCurrentRoundId function. Consider rewriting the docstring.  In the contract VotingV2, the comment on line 767 This method is public because calldata structs are not currently supported by solidity. appears to be a copy & paste error, because no such struct is present in the functions arguments. Consider removing the comment.  Update: Fixed as of commit 6a4bd53200b18d25379ce9082922ba0eea286619 in pull request #4090.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Missing license identifier", "body": "The following files do not contain an SPDX License identifier:  SpamGuardIdentifierLib.sol  AdminIdentifierLib.sol  Missing license agreements can lead to legal disputes and undesired forms of code usage.  Consider adding a license identifier to all mentioned files.  Update: Fixed as of commit 2da561bcee2c72ae36eb4257f04c68537c6e2cd5 in pull request #4091.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#missing-license-identifier", "labels": ["OpenZeppelin"]}, {"title": "Missing Solidity version pragma", "body": "The SpamGuardIdentifierLibs.sol and AdminIdentifierLib.sol files do not define a Solidity version pragma.  It is considered good practice to always specify the desired compiler version by using the Solidity version pragma. If the contract contains non-trivial operations the resulting bytecode might differ between Solidity versions including security relevant breaking changes and non-trivial bug fixes.  Consider defining Solidity version pragmas for all Solidity source files in this project.  Update: Fixed as of commit 2da561bcee2c72ae36eb4257f04c68537c6e2cd5 in pull request #4091.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#missing-solidity-version-pragma", "labels": ["OpenZeppelin"]}, {"title": "Function with return type does not return value", "body": "In the DesignatedVotingV2 contract, both the signature of the retrieveRewards function and its docstring indicate that it returns a value, but the function has no return statement.  Consider adding the missing rewardsMinted return value in order to make the retrieveRewards function behavior match its public interface.  Update: Not fixed. The retreiveRewards function was renamed in pull request #4071 to withdrawAndRestakeRewards as suggested in issue L03, but the function still does not return a value.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#function-with-return-type-does-not-return-value", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent use of named return variables", "body": "There is an inconsistent usage of named return variables across the codebase.  Occurrences of named return values are:  The getResolvedPrice function in the ResultComputationV2 contract  The calcSlashing function in the SlashingLibrary library  The _getIdentifierWhitelist function in the GovernorV2 contract  The _getIdentifierWhitelist function in the VotingV2 contract  The propose function in the ProposerV2 contract  Consider adopting a consistent approach to return values by removing all named return variables.  Update: Fixed as of commit b62a8c90355b6e6c8643e65d354a9a253962073b in pull request #4092. For clarity, the UMA team has retained the use of named return values only for functions that return multiple values. As a result, the getResolvedPrice and calcSlashing functions were left unchanged.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#inconsistent-use-of-named-return-variables", "labels": ["OpenZeppelin"]}, {"title": "Naming issues", "body": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  In the VotingV2 contract, consider renaming the constant ancillaryBytesLimit to ANCILLARY_BYTES_LIMIT.  In the VotingV2 contract, the deletedRequests mapping is used to optimize the processing of the priceRequestIds array by skipping certain elements. The reason to skip an element could be deletion via the executeSpamDeletion function or the detection of a rolled vote within the _updateAccountSlashingTrackers function. The name deletedRequests is misleading as it only describes one of two origins for skips during request processing. Consider renaming the mapping to indicate the purpose of efficient request processing, e.g. skippedRequestIndexes.  In the VotingV2Interface interface, consider renaming the constant NUM_PHASES_PLACEHOLDER to NUM_PHASES.  Update: Fixed as of commit bf04d1dce70eadbdeeff4760fca1cae2ecc3651c in pull request #4094. All naming suggestions were implemented on the contracts in scope for this audit.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#naming-issues", "labels": ["OpenZeppelin"]}, {"title": "Public functions can be marked as external", "body": "The following functions are currently marked with public visibility, but can be declared external because they are never called internally by their own contracts or by child contracts:  In DesignatedVotingV2.sol:  retrieveRewards  In GovernorV2.sol:  propose  In Staker.sol:  requestUnstake executeUnstake withdrawAndRestake setEmissionRate setUnstakeCooldown  In VotingV2.sol:  commitVote (backwards compatible version only) commitAndEmitEncryptedVote (backwards compatible version only) executeSpamDeletion getCurrentRoundId getNumberOfPriceRequests getPendingRequests getPrice (backwards compatible version only) getPriceRequestStatuses (backwards compatible version only) getRoundEndTime getSpamDeletionRequest requestGovernanceAction requestPrice (backwards compatible version only) revealVote (backwards compatible version only) setDelegate setDelegator setGat setRewardsExpirationTimeout setSlashingLibrary signalRequestsAsSpamForDeletion updateTrackers updateTrackersRange  In SlashingLibrary.sol:  calcSlashing  Consider changing the visibility of these functions to external in order to reduce gas costs and clarify that these functions will only ever be called by external contracts.  Update: Fixed as of commit 940ccda23259963687988c3cf7ae954d599980e0 in pull request #4102. Note that the retrieveRewards function has been renamed to withdrawAndRestakeRewards.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#public-functions-can-be-marked-as-external", "labels": ["OpenZeppelin"]}, {"title": "Redundant code", "body": "Consider making the following changes to eliminate unnecessary code:  In Staker.sol:  line 26: The override keyword can be removed line 115: The override keyword can be removed line 151: The override keyword can be removed line 178: The override keyword can be removed line 199: The override keyword can be removed line 209: (tokensToMint) can be changed to tokensToMint  In VotingV2.sol:  lines 1005-1006: The uint256(i) casts can be changed to i  Update: Partially fixed as of commit 764d555eab7d58315561cd98904a06c24c980999 in pull request #4096. The changes in Staker.sol have been fully addressed, while the change to VotingV2.sol remains unaddressed. Also note that pull request #4096 inadvertently removes the immutable keyword that was added by pull request #4085 to the votingToken variable declaration in Staker.sol.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#redundant-code", "labels": ["OpenZeppelin"]}, {"title": "Amount to stake or unstake can be zero", "body": "Within the Staking contract, there are two functions that allow users to stake and unstake a specific amount of UMA tokens: stake and requestUnstake. Both functions have an amount parameter that specifies how many tokens to stake or unstake, but neither function checks whether this amount is zero. If the caller specifies an amount value of 0 for either function, all of the logic is still executed, wasting the users gas.  In both stake and requestUnstake, consider adding a check that amount is a non-zero value before proceeding.  Update: Acknowledged. UMAs statement for this issue:  We dont have any issue with a user unstaking 0, which is a no op.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#amount-to-stake-or-unstake-can-be-zero", "labels": ["OpenZeppelin"]}, {"title": "Too many digits in numeric literals", "body": "Within the SlashingLibrary contract, the functions calcWrongVoteSlashPerToken and calcNoVoteSlashPerToken both return a hard-coded value of 1600000000000000. Numeric literals with a large number of digits are more difficult to interpret, requiring the reader or reviewer to count the number of digits to ensure correctness.  Solidity supports scientific notation representation for large values. Consider replacing these integer values with their more compact equivalent representation 1.6e15.  Update: Fixed as of commit 1d11705161a9d2d49943eace26ab6239886c21e8 in pull request #4097.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#too-many-digits-in-numeric-literals", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Consider addressing the following typographical errors:  In DesignatedVotingV2.sol:  line 54: EG should be E.g. line 71: Eg: should be E.g. line 72: of for the price request should be of the price request line 75: voters should be voters line 89: EG should be E.g.  In GovernorV2.sol:  line 98: an an array should be an array  In ProposerV2.sol:  line 115: system, itself should be system itself  In SlashingLibrary.sol:  line 59: Remove space before wrongVoteSlashPerToken  In Staker.sol:  line 13: prorate should be pro rata line 53: voterPendingUnStake should be voterPendingUnstake line 91: prorate should be pro rata line 93: Remove erroneous comment line line 111: a active reveal should be an active reveal line 175-176: Remove the incomplete sentence that begins with Note that this\u2026 line 230: prorate should be pro rata line 231: prorate should be pro rata  In VoteTimingV2.sol:  line 31: roundID should be round ID line 44: round Id should be round ID (or roundId)  In VotingV2.sol:  line 26: UMAs DVM mechanism should be UMAs DVM (mechanism is redundant) line 52: UINT_MAX should be UINT64_MAX line 59: uint56 should be uint64 line 295: eg should be E.g. line 311: eg should be E.g. line 327: eg should be E.g. line 391: eg should be E.g. line 413: eg should be E.g. line 485: EG should be E.g. line 528: EG should be E.g. line 585: commits should be Commits line 588: Eg: should be E.g. line 589: of for the price request should be of the price request line 592: voters should be voters line 621: actors should be actions line 630: for delegator should be for the delegator line 631: two way should be two-way line 632: of the delegate should be of the delegator line 656: of type PendingRequest should be of type PendingRequestAncillary line 866: cant should be cant line 943: its should be its line 907: Remove blank line line 946: diregarded should be disregarded line 959: sequently should be sequential line 1134: pending request should be pending requests  Additionally, some errors were found in out-of-scope files:  In packages/core/README.md:  line 92: optimsim-up should be optimism-up  In packages/core/contracts/common/implementation/MultiCaller.sol:  line 1: Uniswapss should be Uniswaps  In packages/core/test/oracle/VotingV2.js:  line 2300: i.e should be i.e. line 2481: cant should be cant line 2482: cant should be cant line 2630: Dont should be Dont line 2708: cant should be cant line 2815: dont should be dont line 2857: i.e should be i.e.  Update: Fixed as of commit 69e9574f3ffb3b9085e58b731862c92728134710 in pull request #4098. All typos were corrected except for those identified in the VotingV2.js file, which was out of scope.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary use of SafeMath library", "body": "imports the OpenZeppelin  SafeMath library and uses the librarys  line 144. Solidity version  introduced default underflow/overflow checks on all arithmetic operations. Since the  Consider removing the SafeMath.sol import from GovernorV2 and replacing the sub function with the - operator.  Update: Fixed as of commit 9714b2df60965edd99bec6cb674f01f6d5fb141b in pull request #4099.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#unnecessary-use-of-safemath-library", "labels": ["OpenZeppelin"]}, {"title": "Unused function parameters", "body": "SlashingLibrary contract defines a standard interface for the  Although the unused parameters are harmless in this case, the goal should be to have zero compiler warnings, in order to prevent other warnings mixed in with these from going unnoticed during compilation. Consider adding the following block of no-op code to the body of each of the aforementioned functions in order to suppress the compiler warnings:  This code would then be removed at a later date when these variables are used to perform slashing calculations.  Update: Acknowledged. UMAs statement for this issue:  We are ok with the compiler warnings for this and are not too worried about this.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#unused-function-parameters", "labels": ["OpenZeppelin"]}, {"title": "Unused imports", "body": "The following files are imported but not used:  In the Staker contract, the Testable.sol contract  In the VotingV2 contract, the AncillaryData.sol library  In the VotingV2Interface contract, the FixedPoint.sol library  To improve readability and avoid confusion, consider removing the unused imports.  Update: Fixed as of commit 160c985d9560b78d41b2998d2ca40f4c1ef297b4 in pull request #4100 and commit 0f9bdee0d0584254a93c48fddf3987e2d8559a6e in pull request #4095.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#unused-imports", "labels": ["OpenZeppelin"]}, {"title": "State variable visibility not explicitly declared", "body": "Within VotingV2.sol the state variable spamDeletionProposalBond lacks an explicitly declared visibility.  For clarity, consider always explicitly declaring the visibility of variables, even when the default visibility matches the intended visibility.  Update: Fixed as of commit e3ae35386ddaa674145816c80a11b2117fff44ad in pull request #4101.", "html_url": "https://blog.openzeppelin.com/uma-dvm-2-0-audit#state-variable-visibility-not-explicitly-declared", "labels": ["OpenZeppelin"]}, {"title": " Issues", "body": "0 (0 resolved)  High Severity", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#-issues", "labels": ["OpenZeppelin"]}, {"title": "0 (0 resolved)", "body": "Medium Severity Issues  4 (4 resolved)  Low Severity Issues  16 (14 resolved)  Notes & Additional Information  15 (7 resolved, 1 partially resolved)  Scope  We audited the matter-labs/zksync-2-dev repository at the c05b49d7e303996f60a0e35f18ef224e45ee19f5 commit.  In scope were the following contracts:  System Overview  zkSync is a layer 2 scaling solution for Ethereum based on zero-knowledge rollup technology. The protocol aims to provide low transaction fees and high throughput while maintaining full EVM compatibility.  In zkSync users sign and send transactions to validators who process them, include them into blocks, and create a cryptographic commitment of the updated state. This commitment (root hash) is then transferred to a smart contract on layer 1 along with a cryptographic proof (SNARK) proving that this new state was correctly calculated based on applying transactions to a previous state. A compressed state update is also sent to layer 1, allowing anyone to reconstruct the state at any moment. The layer 1 contract validates both the state update and the cryptographic proof, assuring the validity of the transactions included in the block and the data availability.  zkSync protocol implements the Diamond Proxy EIP-2535 as an upgrade mechanism, thereby splitting its functionality into four different facets:  Executor: Processing rollups of layer 2 blocks  Mailbox: Bidirectional communication between layer 1 and layer 2  DiamondCut: Contract administration  Governance: Role management  Note that while the aforementioned EIP does not contain any known issues, it is not yet considered finalized.  Executor  The Executor component allows validators to commit, prove, and execute blocks. All blocks are tentative before execution and can be removed by any validator. This component is central in extending the security guarantees of layer 1 to transactions on layer 2 through rollups.  Mailbox  The Mailbox component handles bi-directional communications between layer 1 (L1) and layer 2 (L2). To request an L2 transaction from L1, the transaction data is appended to a queue and removed from it upon final inclusion of the L2-rollup into the L1 contract.  In contrast, communication from L2 to L1 is divided in two parts: Sending a transaction on L2 and reading it from L1. To send information from L2, a special opcode sendToL1 is implemented. Using this opcode, users can send logs or messages. Logs provide a key-value tuple of 32 bytes each to encode data while messages can be of arbitrary length. The transfer of messages is possible via a special system contract converting it into a log containing a hash-commitment. All logs are individually hashed to form the leaf nodes of a blocks fixed-size Merkle tree. The proof of inclusion is made available on L1 by checking against the Merkle tree root. Upon committing a block, verifications are performed to ensure data availability, enabling anyone to prove message inclusion without additional help from the operator.  DiamondCut  Note: For a comprehensive explanation of the diamond update mechanism please refer to EIP-2535.  This component manages upgrade-related operations and freezing/unfreezing of facets. The upgrade mechanism is comprised of three stages:  Upgrade proposal  In this stage, the governor commits both a sequence of changes (add/replace/remove) to the supported facet functions and the fixed address of an initializer contract.  Upgrade notice period  zkSync users are given a constant timeframe to withdraw their funds if they are against the proposed upgrade, unless the Security Council approves an immediate emergency upgrade, thereby skipping the execution delay.  Upgrade execution  The governor can execute the upgrade and provide additional calldata to the initializer contract.  Freezing Mechanism  Matter Labs team has implemented a freezing feature. When defining the facet through diamond cuts, each facet can be set as freezable or not. The governor can freeze the diamond as a whole which affects all freezable facets. Therefore, it is possible to designate parts that shall remain operational in an emergency situation. It is crucial for the DiamondCut facet to remain operational in order to enable the governor to unfreeze the Diamond Proxy after resolving the emergency situation.  Governance  The Governance component allows the governor to assign and remove the valdiator role from addresses. It further enables the transition of contract administration to a new governor by designating a pending governor who needs to accept his role in an additional step thereby removing the old governor.  Operation Modes  Regular Operation  This operation mode allows only registered validators to commit and execute blocks with rolled-up layer 2 transaction information. Thus, users are dependent on the validators to not censor their transactions. To protect against malfunction and malice a second operation mode exists.  Priority Mode  Under specific conditions the system can ", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#0-(0-resolved)", "labels": ["OpenZeppelin"]}, {"title": "Corruption of facets array on selector replacement", "body": "The Diamond library allows replacing a selectors facet with itself which is non-compliant with EIP-2535.  Moreover, an edge-case in which a facet only has one selector and this selectors facet is replaced with itself leads to corruption of the DiamondStorage.facets array. Consider the following scenario:  A facet has an array of selectors containing only one element [s1]. Through the function diamondCut a call to _replaceFunctions is initiated.  Inside of _replaceFunctions, the call to _saveFacetIfNew does not add any facet, because the facet is already registered.  Inside of the loop iterating through the selector array [s1], the call to _removeOneFunction triggers a call to _removeFacet due to the last selector being removed. This in turn removes the facet from the ds.facets array.  The subsequent call to _addOneFunction adds selector s1 back to the facet, while the facet remains deleted from the ds.facets array, thereby corrupting it.  To be fully compliant with the EIP-2535 spec and mitigate the edge-case leading to a corruption of the facets array, consider adding the requirement that _facet and oldFacet.facetAddress are distinct from each other.  Update: Fixed in commit f6cde78. The team mitigated this edge-case by rearranging the code. However, with the missing distinction check, the implementation is not fully EIP-2535 compliant.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#corruption-of-facets-array-on-selector-replacement", "labels": ["OpenZeppelin"]}, {"title": "Freezable property applies to individual selectors instead of facets", "body": "In the DiamondProxy contract, a selector is mapped to a facet via the mapping diamondStorage.selectorToFacet upon executing the fallback function. The received datastructure of type Diamond.SelectorToFacet contains the information  address  facetAddress  uint16  selectorPosition  bool  isFreezable  The flag isFreezable is used to determine whether the delegatecall of the given selector to the respective facet should be executed.  At the same time, it is the stated intent of the system to allow freezability on the granularity level of facets: While the Diamond shall have a global flag to determine whether it is frozen or not. Each facet shall be marked as either freezable or not.  An issue arises, because the selectorToFacet mapping allows different values for the flag isFreezable for different selectors of the same facet. Which would allow for freezability on the granularity of selectors instead of facets. Consider the following example of two different selectors, one freezable, one not, belonging to the same facet:  [selector1  = SelectorToFacet  (facet1  true  ) selectorToFacet  [selector2  = SelectorToFacet  (facet1  false  Moreover, the initialization of the selectorToFacet mapping within the Diamond library in function diamondCut actually allows the assignment of different values for isFreezable. Consider the following example for the facetCuts array:  (facet1  , Add  true  [selector1  ]),  (facet1  , Add  false  [selector2  ])  which will lead to an initialization of the selectorToFacet mapping given in the example above.  To prevent selector-level granularity of the freezabilitiy property, consider removing the isFreezable property from the Diamond.SelectorToFacet datatype and add it to a datatype describing only the facet thereby establishing a 1:1 mapping between facet and freezability.  Update: Fixed in commit e39eb07.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#freezable-property-applies-to-individual-selectors-instead-of-facets", "labels": ["OpenZeppelin"]}, {"title": "Merkle library verifies intermediate inputs", "body": "The Merkle library enables verification of a Merkle proof by performing an inclusion check of an input against a binary tree. This works by consecutively hashing concatenated sibling nodes until a root hash is generated. The input is one of the leaf hash values, while the proof is a path through the tree containing the missing hash information to regenerate the root.  An issue arises in this library, due to the arbitrary length of the proof. This allows shorter paths to resolve to the same root. Hence, the known hash of an intermediate node is a valid input as well. To visualize, considering the leaf nodes h0 and h1, the hashed concatenation hash(h0 || h1) of those hashes would be a valid input along a shorter path. An attacker could utilize the known pre-image to prove its inclusion in the tree. For the standalone library this is a critical problem.  In this particular codebase the Merkle library is solely used in the MailboxFacet contact to prove the inclusion of a transaction within a set of layer 2 logs. Thus, only inputs of type L2Log with a length of 88 bytes are legitimate, while the pre-images of size 64 bytes contained within the Merkle tree are not. However, any future usage on 64 bytes input would lead to a critical vulnerability.  It was also stated that the incomplete tree of fixed size is filled with the default hash hash(\"\"). This allows an attacker to prove the inclusion of empty bytes by default. Although, no threat was identified for the contracts in scope.  Consider strictly checking the path length of the proof against the desired Merkle tree depth to mitigate the first issue. Further, consider using a default leaf hash with unknown pre-image as countermeasure to the second attack. With respect to documentation, consider sticking to the leaf wording for variable naming.  Update: Fixed in commit 7eb51d9. Additional checks have been applied outside of the Merkle library to filter malicious inputs. The library itself remains vulnerable to the attack if used in a different context. A note about this problem was added to the function documentation with commit 5f02309.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#merkle-library-verifies-intermediate-inputs", "labels": ["OpenZeppelin"]}, {"title": "Proof replayability", "body": "In the proveBlocks function of the ExecutorFacet contract, there is no linkage between the committed blocks and the proof. The respective check is commented out in line 213. However, as it is commented out, the following is applicable.  The provided proof data is self-contained. Hence, the validator verifies that the given proof is valid in itself. Seeing the validator as a black box, it is assumed that there is no back checking against the committed blocks provided during the call. Therefore, the independence between the committed blocks and proof suggests a replay attack. By providing any formerly valid proof the previously committed blocks would be validated. Thus, all users could verify committed blocks, whether valid or not.  As documented in the code, the necessary check is there but commented out, which is based on the argument that the Verifier contract is not yet implemented. However, the commitment check between the blocks and proof has nothing to do with the Verifier. Therefore, consider incorporating this crucial check as part of the finalized codebase.  Update: Fixed in commit 64d6aec.  Low Severity  _proveBlock while loop could run out of gas  In the ExecutorFacet contract within the proveBlocks function, there is a while loop to skip already verified blocks. The loop condition is defined as:  while  (_hashStoredBlockInfo  (_committedBlocks  [i  ])  != firstUnverifiedBlockHash  Therefore, if the committed blocks do no contain the first unverified block, this loop will eventually run out of gas and revert.  Consider limiting the number of loop iterations to the length of the _committedBlocks array and reverting with an expressive error message in case the block was not found.  Update: Fixed in commit df107f0.  DiamondInit can be initialized itself  The DiamondInit contract is designed to initialize the DiamondProxy or any new facet via a delegatecall from the proxy contract. Therefore, the DiamondInit contract is deployed on its own with an unprotected initialize function.  Hence, anyone could initialize the deployed instance of the DiamondInit contract itself. While this isnt identified as a threat, it is good practice to prevent arbitrary callers from initializing contracts.  Consider initializing the DiamondInit contract via the constructor or adding a security mechanism to the initialize function.  Update: Fixed in commit c9089a5.  lastDiamondFreezeTimestamp is unused  In the DiamondCutFacet contract, the diamond can be frozen to allow inspection of the protocols security. Currently, as part of the emergencyFreezeDiamond function, s.diamondCutStorage.lastDiamondFreezeTimestamp is set but not used elsewhere in the code.  Consider either implementing a use-case for this variable or removing it.  Update: Acknowledged, not fixed. The Matter Labs team states:  While this feature was not included into this release we prefer to keep the variable to facilitate the rollout of the feature once it is ready.  Freezability differences between logical components  The usage of the Diamond Proxy pattern allows very modular changes to the system. The standard foresees moving individual selectors from facet to facet. Hence, one logical component (e.g. the ExecutorFacet) could be split into two facets, due to patching a single function and migrating the selector to the new facet, while the rest of the logic is kept in the old facet. As the first selector to the new facet defines the freezability, this could result in two different freeze capabilities for one high-level logical component (ExecutorFacet).  Implementing checks to cover the joint freezability for the logical facet would introduce additional overhead. Instead, consider extensively documenting this behavior in the DiamondCutFacet contract.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern and we are aware that overall documentation improvement is due. This has been in our backlog already and we have now adjusted the priority accordingly.  Gas optimizations  Throughout the codebase there are multiple instances where gas costs can be optimized:  In line 162 of the Diamond library the uint16 cast is unnecessary and can be removed.  Using the delete keyword instead of overwriting with the default value saves gas in these instances:  line 33 of Governance facet. line 119-121 of DiamondCutFacet contract.  In the approveEmergencyDiamondCutAsSecurityCouncilMember function, the s.diamondCutStorage.currentProposalId variable can be written to stack and reused.  In the ExecutorFacet contract on line 113 and 155 two bytes32 values are encoded and hashed. Consider using the abi.encode function for the encoding to be more gas efficient.  In the ExecutorFacet contract, consider writing the _maxU256 return value to stack to save on the following s.totalBlocksCommitted storage reads.  Consider applying the above changes to be more gas efficient.  Update: Fixed in commit 5a4e81a. However, the fix in", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#proof-replayability", "labels": ["OpenZeppelin"]}, {"title": "_proveBlock while loop could run out of gas", "body": "_proveBlock while loop could run out of gas", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#_proveblock-while-loop-could-run-out-of-gas", "labels": ["OpenZeppelin"]}, {"title": "DiamondInit can be initialized itself", "body": "DiamondInit can be initialized itself", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#diamondinit-can-be-initialized-itself", "labels": ["OpenZeppelin"]}, {"title": "lastDiamondFreezeTimestamp is unused", "body": "lastDiamondFreezeTimestamp is unused", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#lastdiamondfreezetimestamp-is-unused", "labels": ["OpenZeppelin"]}, {"title": "Freezability differences between logical components", "body": "The usage of the Diamond Proxy pattern allows very modular changes to the system. The standard foresees moving individual selectors from facet to facet. Hence, one logical component (e.g. the ExecutorFacet) could be split into two facets, due to patching a single function and migrating the selector to the new facet, while the rest of the logic is kept in the old facet. As the first selector to the new facet defines the freezability, this could result in two different freeze capabilities for one high-level logical component (ExecutorFacet).  Implementing checks to cover the joint freezability for the logical facet would introduce additional overhead. Instead, consider extensively documenting this behavior in the DiamondCutFacet contract.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern and we are aware that overall documentation improvement is due. This has been in our backlog already and we have now adjusted the priority accordingly.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#freezability-differences-between-logical-components", "labels": ["OpenZeppelin"]}, {"title": "Gas optimizations", "body": "Throughout the codebase there are multiple instances where gas costs can be optimized:  In line 162 of the Diamond library the uint16 cast is unnecessary and can be removed.  Using the delete keyword instead of overwriting with the default value saves gas in these instances:  line 33 of Governance facet. line 119-121 of DiamondCutFacet contract.  In the approveEmergencyDiamondCutAsSecurityCouncilMember function, the s.diamondCutStorage.currentProposalId variable can be written to stack and reused.  In the ExecutorFacet contract on line 113 and 155 two bytes32 values are encoded and hashed. Consider using the abi.encode function for the encoding to be more gas efficient.  In the ExecutorFacet contract, consider writing the _maxU256 return value to stack to save on the following s.totalBlocksCommitted storage reads.  Consider applying the above changes to be more gas efficient.  Update: Fixed in commit 5a4e81a. However, the fix introduced a redundant check of conditions within the function approveEmergencyDiamondCutAsSecurityCouncilMember.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#gas-optimizations", "labels": ["OpenZeppelin"]}, {"title": "Interface and contract function parameter mismatch", "body": "The revertBlocks function has a different parameter name in IExecutor compared to ExecutorFacet. While in the interface the _blocksToRevert parameter suggests reverting a relative amount of blocks, the logic sets an absolute _newLastBlock which is confusing.  Further, in the requestL2Transaction function two parameters have a mismatch between the MailboxFacet and the IMailbox interface.  Consider correcting the above mismatches in favor of consistency and clarity.  Update: Fixed in commit c0600e0.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#interface-and-contract-function-parameter-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Getter returns misleading value", "body": "In the GettersFacet contract, the function isFunctionFreezable returns a Boolean value indicating whether a given selector is freezable or not. This value is taken from storage without any prior validation. At the same time, any uninitialized storage in Solidity contains the default value zero/false.  Querying the function isFunctionFreezable for an unknown selector will return false, thereby misleading the user to believe that the selector is used within the Diamond and is not freezable.  Consider validating the existence of the selector by requiring that the facet address of the selector is registered.  Update: Fixed in commit cfe6f54.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#getter-returns-misleading-value", "labels": ["OpenZeppelin"]}, {"title": "Lack of Documentation", "body": "Docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned, and the events emitted. In the case of structs, docstrings should explain the overall purpose of the struct, each field contained in it, and clarify whether the struct is supposed to be persisted in storage or limited to memory and calldata. If the codebase does not have proper docstrings, it hinders reviewers understanding of the codes intention and increases the maintenance effort for contributors.  Throughout the zksync-2-dev codebase there are several parts that do not have docstrings. For instance:  In the Storage.sol contract the following identifiers lack sufficient documentation:  The DiamondCutStorage struct including all fields  The L2Log struct including all fields  The storage information of the L2Message struct as well as its txNumberInBlock field  In the IMailbox.sol interface the following constructs lack sufficient documentation:  The L2CanonicalTransaction struct including all fields  The NewPriorityRequest event including all fields  In the Mailbox.sol contract the following functions lack sufficient documentation:  The proveL2MessageInclusion function  The proveL2LogInclusion function  The l2TransactionBaseCost function  The requestL2Transaction function  The serializeL2Transaction function  In the IExecutor.sol interface the following structs lack sufficient documentation:  The StoredBlockInfo struct, especially fields blockHash, indexRepeatedStorageChanges, stateRoot  The CommitBlockInfo struct, especially field indexRepeatedStorageChanges  The ProofInput struct including all fields  In the DiamondCut.sol contract the following functions lack sufficient documentation:  The emergencyFreezeDiamond function  The unfreezeDiamond function  The approveEmergencyDiamondCutAsSecurityCouncilMember function  In the IGetters.sol interface the following structs lack sufficient documentation:  The Facet struct including all fields  SelectorExtended struct including all fields  FacetExtended struct including all fields  In the Diamond.sol library the following identifiers lack sufficient documentation:  The DiamondStorage struct and all of its fields  The FacetCut struct and all of its fields  The DiamondCutData struct and all of its fields  The diamondCut function  The getDiamondStorage function  In the PriorityQueue.sol library the following identifiers lack sufficient documentation:  The Queue struct and all its fields  The getLastProcessedPriorityTx function  The getTotalPriorityTxs function  The getSize function  The isEmpty function  The pushBack function  The front function  The popFront function  Consider thoroughly documenting all structs and functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec). While applying the NatSpec tags, make sure to be consistent with the usage of the respective tag. For instance, use @notice for a general description and @dev for technical aspects.  Update: Fixed in commit 8abb05c.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#lack-of-documentation", "labels": ["OpenZeppelin"]}, {"title": "Lack of event information", "body": "Throughout the codebase we found the following occurrences of state changes without event emission and event emissions with insufficient or incorrect information:  In the ExecutorFacet contract  the proveBlocks function does not emit an event after altering the storage variable s.totalBlocksVerified. Consider creating a new event that can emit both the old and new value of this variable. the BlocksRevert event is used as BlocksRevert(s.totalBlocksExecuted, s.totalBlocksCommitted) which differs from its definition BlocksRevert(uint256 totalBlocksVerified, uint256 totalBlocksCommitted) within the IExecutor interface. Consider replacing s.totalBlocksExecuted with s.totalBlocksVerified.  In the IExecutor interface  the BlockCommit event only contains the blockNumber, which might not be unique due to block reversion. Consider adding indexed fields for blockHash and commitment. the BlockExecution event only contains the blockNumber. Consider adding indexed fields for blockHash and commitment.  In the IGovernance interface the NewGovernor event emits the new governor. To ease tracking the responsibility of this important role, consider emitting both  the old and new governor  as indexed addresses.  In the IDiamondCut interface  the EmergencyDiamondCutApproved event only emits the address of the approver, but no information about the diamondcut proposal. Consider indexing the address field and adding the fields currentProposalId, securityCouncilEmergencyApprovals and the indexed field proposedDiamondCutHash. the Unfreeze event does not emit additional information. Consider adding the lastDiamondFreezeTimestamp as an event field. the DiamondCutProposalCancelation event does not emit additional information. Consider adding a currentProposalId field and the indexed field proposedDiamondCutHash.  Consider emitting events for all state changes and include all relevant state transition information in them to allow precise monitoring via off-chain systems. Consider indexing event fields to facilitate their usage as a search key.  Update: Fixed in commit 79fd845.  Lack of l2Logs validation  ExecutorFacet contract within the  _processL2Logs. While any L2 user can be the sender of  While the system implicitly assumes that exactly one L2Log of sender L2_SYSTEM_CONTEXT_ADDRESS is present in each block, this assumption is not enforced during block commitment.  Consider enforcing that only one L2Log with sender L2_SYSTEM_CONTEXT_ADDRESS is present in each block.  Update: Fixed in commit dfc6fe1.  Preimage hash collision protection for storage pointers  The Diamond Proxy makes use of the diamond storage pattern to track the facets and selectors in use. This is achieved through a DiamondStorage struct that contains the relevant facet and selector information. Because of the proxy setup, this struct is placed in an unstructured-storage-manner at a pseudo random storage slot calculated by hashing a hardcoded string.  In the event of introducing a dynamic slot calculation using hashing, the DiamondStorage storage slot could be specifically addressed to force a collision using the known input bytes from above.  To prevent this pre-image hash collision, consider applying a -1 offset to the hash.  Update: Fixed in commit 60b74e0.  Require statements with multiple conditions  Throughout the codebase there are require statements that require multiple conditions to be satisfied. For instance:  The require statement on line 37 of Executor.sol  The require statement on line 251 of Diamond.sol  The require statement on line 17 of Merkle.sol  To simplify the codebase and to raise the most helpful error messages for failing require statements, consider having a single require statement per condition.  Update: Fixed in commit b87267c.  Confusing event emission when executing diamond cut proposals  In the DiamondCutFacet contract, the executeDiamondCutProposal function is used to execute a previously proposed upgrade.  This function resets the scheduled diamond cut proposal, thereby re-purposing the _resetProposal function. When this function is successfully executed it triggers a DiamondCutProposalCancelation event. Afterwards, DiamondCutProposalExecution event is triggered by executeDiamondCutProposal function.  This dual event emission of cancellation followed by execution could lead to confusion in off-chain systems.  To prevent emitting a cancellation event during the execution of a diamond cut proposal, consider moving the emission of the DiamondCutProposalCancelation event from the _resetProposal function to the cancelDiamondCutProposal function.  Update: Fixed in commit fad57c5.  Unused input to commit blocks  In the ExecutorFacet contract, the _commitOneBlock function does not make use of the input _newBlock.priorityOperationsHash. Instead, a local variable priorityOperationsHash is calculated from the _newBlock.l2Logs and included in the block commitment.  Consider validating both values against each other.  Update: Fixed in commit 615b", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#lack-of-event-information", "labels": ["OpenZeppelin"]}, {"title": "Lack of l2Logs validation", "body": "Lack of l2Logs validation", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#lack-of-l2logs-validation", "labels": ["OpenZeppelin"]}, {"title": "Preimage hash collision protection for storage pointers", "body": "The Diamond Proxy makes use of the diamond storage pattern to track the facets and selectors in use. This is achieved through a DiamondStorage struct that contains the relevant facet and selector information. Because of the proxy setup, this struct is placed in an unstructured-storage-manner at a pseudo random storage slot calculated by hashing a hardcoded string.  In the event of introducing a dynamic slot calculation using hashing, the DiamondStorage storage slot could be specifically addressed to force a collision using the known input bytes from above.  To prevent this pre-image hash collision, consider applying a -1 offset to the hash.  Update: Fixed in commit 60b74e0.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#preimage-hash-collision-protection-for-storage-pointers", "labels": ["OpenZeppelin"]}, {"title": "Require statements with multiple conditions", "body": "Throughout the codebase there are require statements that require multiple conditions to be satisfied. For instance:  The require statement on line 37 of Executor.sol  The require statement on line 251 of Diamond.sol  The require statement on line 17 of Merkle.sol  To simplify the codebase and to raise the most helpful error messages for failing require statements, consider having a single require statement per condition.  Update: Fixed in commit b87267c.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#require-statements-with-multiple-conditions", "labels": ["OpenZeppelin"]}, {"title": "Confusing event emission when executing diamond cut proposals", "body": "In the DiamondCutFacet contract, the executeDiamondCutProposal function is used to execute a previously proposed upgrade.  This function resets the scheduled diamond cut proposal, thereby re-purposing the _resetProposal function. When this function is successfully executed it triggers a DiamondCutProposalCancelation event. Afterwards, DiamondCutProposalExecution event is triggered by executeDiamondCutProposal function.  This dual event emission of cancellation followed by execution could lead to confusion in off-chain systems.  To prevent emitting a cancellation event during the execution of a diamond cut proposal, consider moving the emission of the DiamondCutProposalCancelation event from the _resetProposal function to the cancelDiamondCutProposal function.  Update: Fixed in commit fad57c5.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#confusing-event-emission-when-executing-diamond-cut-proposals", "labels": ["OpenZeppelin"]}, {"title": "Unused input to commit blocks", "body": "In the ExecutorFacet contract, the _commitOneBlock function does not make use of the input _newBlock.priorityOperationsHash. Instead, a local variable priorityOperationsHash is calculated from the _newBlock.l2Logs and included in the block commitment.  Consider validating both values against each other.  Update: Fixed in commit 615b6a5.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#unused-input-to-commit-blocks", "labels": ["OpenZeppelin"]}, {"title": "Unused L2Messages can be committed to L1", "body": "ExecutorFacet contract the validator provides multiple blocks of type  CommitBlockInfo to the  commitBlocks function, which are validated in several steps including  _processL2Logs. In this function, the preimages contained in the  currentMessage is incremented only based on the  Consider the addition of a final check of currentMessage against the length of the _newBlock.l2ArbitraryLengthMessages array at the end of the _processL2Logs function to ensure that only relevant preimages have been included in the calldata.  Update: Fixed in commit 25913e7.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#unused-l2messages-can-be-committed-to-l1", "labels": ["OpenZeppelin"]}, {"title": "Unverified inputs during block commitment", "body": "In the ExecutorFacet contract the _commitOneBlock function takes the _newBlock parameter to validate, extract, and transform block information into a StoredBlockInfo struct, which is hashed and stored on chain as a commitment. With a valid zero-knowledge proof this data can later be verified and executed.  However, several fields of the _newBlock input parameter are not validated. This could lead to successful commitments of blocks that eventually will not be executable.  Consider preventing the commitment of unexecutable blocks by:  Validating the field numberOfLayer1Txs against the number of L2Logs with sender L2_BOOTLOADER_ADDRESS.  Validating the field l2LogsTreeRoot against a reconstruction of the Merkle tree from the l2Logs array.  Validating the field timestamp against the local variable blockTimestamp.  Update: Fixed in commit 230f400. The Matter Labs team states:  We have applied the recommendations #1 and #3. The recommendation #2 is redundant as it is already covered by zero knowledge proofs. Verifying this on Layer 1 would be too expensive so by design this is entrusted to zero knowledge cryptography.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#unverified-inputs-during-block-commitment", "labels": ["OpenZeppelin"]}, {"title": "AppStorage partially lacks getter functions", "body": "The GettersFacet contract does not expose the entire AppStorage via view functions. The following storage parts remain inconvenient to read for an outside actor:  Every aspect of diamondCutStorage  The pendingGovernor address  The storedBlockHashes mapping  The functions getSize and front of priorityQueue as well as a function to determine the position of elements within the queue  Additionally, there is an input size mismatch between the l2LogsRootHashes mapping, which takes an uint256 key, and the l2LogsRootHash getter function, which takes a uint32 parameter.  Consider exposing all relevant information via getter functions and ensure that function parameters and mapping keys are type-identical.  Update: Fixed in commit 6b99055.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#appstorage-partially-lacks-getter-functions", "labels": ["OpenZeppelin"]}, {"title": "Block info structs have redundant parameters", "body": "The structs StoredBlockInfo and CommitBlockInfo of the IExecutor interface have the following parameters in common:  blockNumber  indexRepeatedStorageChanges  numberOfLayer1Txs  priorityOperationsHash  l2LogsTreeRoot  timestamp  Consider moving these parameters to a separate BaseBlockInfo struct which is then included into StoredBlockInfo and CommitBlockInfo respectively. Note, this will affect the way the variables are accessed.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#block-info-structs-have-redundant-parameters", "labels": ["OpenZeppelin"]}, {"title": "Confusing identifier names", "body": "Throughout the codebase we found multiple occurrences of identifier names creating confusion:  In the IExecutor interface the parameter name used in the signature of the revertBlocks function is _blocksToRevert. However, the implementation of said function within ExecutorFacet calls the same parameter _newLastBlock which is consistent with its usage.  In the PriorityQueue library the variables head and tail account for where to add and remove items from the list. Unintuitively, the head points to the end of the queue and tail points to the front of the queue.  Consider renaming confusing identifiers to prevent misunderstandings and incorrect usage.  Update: Fixed in commit 03e04cb and c0600e0.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#confusing-identifier-names", "labels": ["OpenZeppelin"]}, {"title": "Direct usage of library struct fields", "body": "In the MailboxFacet contract, the function _requestL2Transaction reads the head of the priority queue via direct access to the respective field.  However, it is best practice to decouple the internal structure of a library from the functionality it exposes to other contracts through its functions.  Consider replacing the direct access of struct field head with a call to the getter function getTotalPriorityTxs that exposes the same information.  Update: Fixed in commit 8b97af.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#direct-usage-of-library-struct-fields", "labels": ["OpenZeppelin"]}, {"title": "Lack of ERC-165 support", "body": "External contracts and third-party integrations have no means to discover interfaces supported by the codebase.  Consider implementing the supportsInterface function of the ERC-165 standard to expose information about implemented interfaces.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern. It does not pose a security risk and comes with additional maintenance overhead if the system is expected to change in the future. We have added it to our development backlog to be addressed once we are out of alpha version.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#lack-of-erc-165-support", "labels": ["OpenZeppelin"]}, {"title": "File and contract name mismatch", "body": "There is a general mismatch between the facet contract names and their file names. While the contracts have a Facet suffix, the files have not. The following contracts are affected:  DiamondCutFacet  ExecutorFacet  GettersFacet  GovernanceFacet  MailboxFacet  Regarding the interfaces, the individual interface names are based on the filename, e.g. IDiamondCut, but instead should align with the contract name.  Consider following the best practice of having identical file and contract names as well as adjusting the interface naming.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#file-and-contract-name-mismatch", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent NatSpec tags", "body": "Throughout the codebase the NatSpec docstring tags @notice and @dev are used interchangeably. The Solidity NatSpec documentation describes the tags as the following:  @notice  Explain to an end user what this does  @dev  Explain to a developer any extra details  Consider applying the respective descriptions across the documentation to be consistent.  Update: Acknoledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concerns and we are aware that overall documentation improvement is due. This has been in our backlog already and we have now adjusted the priority accordingly.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#inconsistent-natspec-tags", "labels": ["OpenZeppelin"]}, {"title": "Misleading documentation", "body": "The docstring documentation of the _executeOneBlock function is misleading by stating the following:  Processes all pending operations (Send Exits, Complete priority requests)  However, sending exits is not part of the implementation. Consider revising the comments to accurately reflect the logic.  Update: Fixed in commit ce78828.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#misleading-documentation", "labels": ["OpenZeppelin"]}, {"title": "Uninformative reason strings", "body": "The codebase uses short alphanumeric codes instead of understandable reason strings in require statements.  Additionally, within ReentrancyGuard.sol there is a require statement on line 72 that lacks an error message completely.  Consider including specific, informative error messages in require statements to improve overall code clarity and to facilitate troubleshooting whenever a requirement is not satisfied.  Update: Partially fixed in commit 79f6a36 by adding the missing error message. In addition, the Matter Labs team states:  Improving the error messaging is a large effort that we have added to the backlog for now.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#uninformative-reason-strings", "labels": ["OpenZeppelin"]}, {"title": "Solidity compiler version is not pinned", "body": "Throughout the codebase there are pragma statements that allow multiple versions of the Solidity compiler, including outdated versions.  Consider taking advantage of the latest Solidity version to improve the overall readability and security of the codebase. Regardless of which version of Solidity is used, consider pinning the version consistently throughout the codebase to prevent bugs due to incompatible future releases and take into account the list of known compiler bugs.  Update: Acknowledged, not fixed. The Matter Labs team states:  The version is pinned, but not directly in the source files to speed up the development: https://github.com/matter-labs/zksync-2-dev/blob/openzeppelin-audit/contracts/ethereum/hardhat.config.ts#L82. It is in the backlog to pin it in the source files after the release.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#solidity-compiler-version-is-not-pinned", "labels": ["OpenZeppelin"]}, {"title": "TODO comments in the code base", "body": "We found the following instances of TODO comments in the codebase that should be tracked in the projects issues backlog and resolved before the system is deployed:  Line 17 of Config.sol  Line 50 of Storage.sol  Line 212 of Executor.sol  Lines 70, 94 and 136 of Mailbox.sol  Line 20 of IDiamondCut.sol  During development, having well described TODO comments will make the process of tracking and solving them easier. Without that information these comments might age and important information for the security of the system might be forgotten by the time it is released to production.  Consider tracking all instances of TODO comments in the issues backlog and linking each inline TODO to the corresponding backlog entry. Resolve all TODOs before deploying to a production environment.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concern. It does not pose a security risk, so we have added it to our development backlog.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#todo-comments-in-the-code-base", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "Throughout the codebase there were a few typographical errors. For instance:  line 105 of the Diamond library: Add facet to the list of facets if the facet address is a new one  line 192 of the Diamond library: It is expected but NOT enforced that _facet is a NON-ZERO address  line 295 of the ExecutorFacet contract: _blockAuxilaryOutput should be _blockAuxiliaryOutput  Consider correcting the above and any other typos in favor of correctness and readability.  Update: Acknowledged, not fixed. The Matter Labs team states:  We acknowledge that this issue raises a valid concerns and we are aware that overall documentation improvement is due. This has been in our backlog already and we have now adjusted the priority accordingly.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unorganized file layout", "body": "The Diamond library has an unorganized layout of code contents, which mixes functions, structs, enums, and events in no particular order. More specifically, we found the following code order in the file:  constants -> structs -> function -> enum -> structs -> function -> event -> functions  For readability, consider bundling these categories of content into separate code areas in the file.  Update: Fixed in commit 89953d2.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#unorganized-file-layout", "labels": ["OpenZeppelin"]}, {"title": "Unused named return variable", "body": "The requestL2Transaction function declares a named return variable bytes32 canonicalTxHash in its signature, but uses an explicit return statement in its body.  Consider either using or removing the named return as well as applying a consistent style of returning variables.  Update: Fixed in commit 923b3c3.", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#unused-named-return-variable", "labels": ["OpenZeppelin"]}, {"title": "Write array length to stack to save gas", "body": "Write array length to stack to save gas", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#write-array-length-to-stack-to-save-gas", "labels": ["OpenZeppelin"]}, {"title": "s", "body": "firt ecurity aement for zkSync 2.0 wa prepared by OpenZeppelin, a part of an ongoing ecurity partnerhip with Matter Lab.  Table of Content  Table of Content  Summary  Scope  Sytem Overview  Executor Mailbox DiamondCut Governance Operation Mode Privileged Role and Security Aumption  Medium Severity  Corruption of facet array on elector replacement Freezable property applie to individual elector intead of facet Merkle library verifie intermediate input Proof replayability  Low Severity  _proveBlock while loop could run out of ga DiamondInit can be initialized itelf latDiamondFreezeTimetamp i unued Freezability difference between logical component Ga optimization Interface and contract function parameter mimatch Getter return mileading value Lack of Documentation Lack of event information Lack of l2Log validation Preimage hah colliion protection for torage pointer Require tatement with multiple condition Confuing event emiion when executing diamond cut propoal Unued input to commit block Unued L2Meage can be committed to L1 Unverified input during block commitment  Note & Additional Information  AppStorage partially lack getter function Block info truct have redundant parameter Confuing identifier name Direct uage of library truct field Lack of ERC-165 upport File and contract name mimatch Inconitent NatSpec tag Mileading documentation Uninformative reaon tring Solidity compiler verion i not pinned TODO comment in the code bae Typographical error Unorganized file layout Unued named return variable Write array length to tack to ave ga  Concluion  Appendix  Monitoring Recommendation  Summary  Type  Rollup  Timeline  From 2022-09-05  To 2022-09-30  Language  Solidity  Total Iue  35 (25 reolved, 1 partially reolved)  Critical Severity Iue  0 (0 reolved)  High Severity Iue  0 (0 reolved)  Medium Severity Iue  4 (4 reolved)  Low Severity Iue  16 (14 reolved)  Note & Additional Information  15 (7 reolved, 1 partially reolved)  Scope  We audited the matter-lab/zkync-2-dev repoitory at the c05b49d7e303996f60a0e35f18ef224e45ee19f5 commit.  In cope were the following contract:  Sytem Overview  zkSync i a layer 2 caling olution for Ethereum baed on zero-knowledge rollup technology. The protocol aim to provide low tranaction fee and high throughput while maintaining full EVM compatibility.  In zkSync uer ign and end tranaction to validator who proce them, include them into block, and create a cryptographic commitment of the updated tate. Thi commitment (root hah) i then tranferred to a mart contract on layer 1 along with a cryptographic proof (SNARK) proving that thi new tate wa correctly calculated baed on applying tranaction to a previou tate. A compreed tate update i alo ent to layer 1, allowing anyone to recontruct the tate at any moment. The layer 1 contract validate both the tate update and the cryptographic proof, auring the validity of the tranaction included in the block and the data availability.  zkSync protocol implement the Diamond Proxy EIP-2535 a an upgrade mechanim, thereby plitting it functionality into four different facet:  Executor: Proceing rollup of layer 2 block  Mailbox: Bidirectional communication between layer 1 and layer 2  DiamondCut: Contract adminitration  Governance: Role management  Note that while the aforementioned EIP doe not contain any known iue, it i not yet conidered finalized.  Executor  The Executor component allow validator to commit, prove, and execute block. All block are tentative before execution and can be removed by any validator. Thi component i central in extending the ecurity guarantee of layer 1 to tranaction on layer 2 through rollup.  Mailbox  The Mailbox component handle bi-directional communication between layer 1 (L1) and layer 2 (L2). To requet an L2 tranaction from L1, the tranaction data i appended to a queue and removed from it upon final incluion of the L2-rollup into the L1 contract.  In contrat, communication from L2 to L1 i divided in two part: Sending a tranaction on L2 and reading it from L1. To end information from L2, a pecial opcode endToL1 i implemented. Uing thi opcode, uer can end log or meage. Log provide a key-value tuple of 32 byte each to encode data while meage can be of arbitrary length. The tranfer of meage i poible via a pecial ytem contract converting it into a log containing a hah-commitment. All log are individually hahed to form the leaf node of a block fixed-ize Merkle tree. The proof of incluion i made available on L1 by checking againt the Merkle tree root. Upon committing a block, verification are performed to enure data availability, enabling anyone to prove meage incluion without additional help from the operator.  DiamondCut  Note: For a comprehenive explanation of the diamond update mechanim pleae refer to EIP-2535.  Thi component manage upgrade-related operation and freezing/unfreezing of facet. The upgrade mechanim i compried of three tage:  Upgrade propoal  In thi tage, the governor commit both a equence of change (add/replace/r", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#s", "labels": ["OpenZeppelin"]}, {"title": "Appendix", "body": "Appendix", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#appendix", "labels": ["OpenZeppelin"]}, {"title": "Monitoring Recommendations", "body": "Monitoring Recommendations", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#monitoring-recommendations", "labels": ["OpenZeppelin"]}, {"title": "Summary", "body": "Type  Rollup  Timeline  From 2022-09-05  To 2022-09-30  Languages  Solidity  Total Issues  35 (25 resolved, 1 partially resolved)  Critical Severity Issues  0 (0 resolved)  High Severity Issues  0 (0 resolved)  Medium Severity Issues  4 (4 resolved)  Low Severity Issues  16 (14 resolved)  Notes & Additional Information  15 (7 resolved, 1 partially resolved)  Scope  We audited the matter-labs/zksync-2-dev repository at the c05b49d7e303996f60a0e35f18ef224e45ee19f5 commit.  In scope were the following contracts:  System Overview  zkSync is a layer 2 scaling solution for Ethereum based on zero-knowledge rollup technology. The protocol aims to provide low transaction fees and high throughput while maintaining full EVM compatibility.  In zkSync users sign and send transactions to validators who process them, include them into blocks, and create a cryptographic commitment of the updated state. This commitment (root hash) is then transferred to a smart contract on layer 1 along with a cryptographic proof (SNARK) proving that this new state was correctly calculated based on applying transactions to a previous state. A compressed state update is also sent to layer 1, allowing anyone to reconstruct the state at any moment. The layer 1 contract validates both the state update and the cryptographic proof, assuring the validity of the transactions included in the block and the data availability.  zkSync protocol implements the Diamond Proxy EIP-2535 as an upgrade mechanism, thereby splitting its functionality into four different facets:  Executor: Processing rollups of layer 2 blocks  Mailbox: Bidirectional communication between layer 1 and layer 2  DiamondCut: Contract administration  Governance: Role management  Note that while the aforementioned EIP does not contain any known issues, it is not yet considered finalized.  Executor  The Executor component allows validators to commit, prove, and execute blocks. All blocks are tentative before execution and can be removed by any validator. This component is central in extending the security guarantees of layer 1 to transactions on layer 2 through rollups.  Mailbox  The Mailbox component handles bi-directional communications between layer 1 (L1) and layer 2 (L2). To request an L2 transaction from L1, the transaction data is appended to a queue and removed from it upon final inclusion of the L2-rollup into the L1 contract.  In contrast, communication from L2 to L1 is divided in two parts: Sending a transaction on L2 and reading it from L1. To send information from L2, a special opcode sendToL1 is implemented. Using this opcode, users can send logs or messages. Logs provide a key-value tuple of 32 bytes each to encode data while messages can be of arbitrary length. The transfer of messages is possible via a special system contract converting it into a log containing a hash-commitment. All logs are individually hashed to form the leaf nodes of a blocks fixed-size Merkle tree. The proof of inclusion is made available on L1 by checking against the Merkle tree root. Upon committing a block, verifications are performed to ensure data availability, enabling anyone to prove message inclusion without additional help from the operator.  DiamondCut  Note: For a comprehensive explanation of the diamond update mechanism please refer to EIP-2535.  This component manages upgrade-related operations and freezing/unfreezing of facets. The upgrade mechanism is comprised of three stages:  Upgrade proposal  In this stage, the governor commits both a sequence of changes (add/replace/remove) to the supported facet functions and the fixed address of an initializer contract.  Upgrade notice period  zkSync users are given a constant timeframe to withdraw their funds if they are against the proposed upgrade, unless the Security Council approves an immediate emergency upgrade, thereby skipping the execution delay.  Upgrade execution  The governor can execute the upgrade and provide additional calldata to the initializer contract.  Freezing Mechanism  Matter Labs team has implemented a freezing feature. When defining the facet through diamond cuts, each facet can be set as freezable or not. The governor can freeze the diamond as a whole which affects all freezable facets. Therefore, it is possible to designate parts that shall remain operational in an emergency situation. It is crucial for the DiamondCut facet to remain operational in order to enable the governor to unfreeze the Diamond Proxy after resolving the emergency situation.  Governance  The Governance component allows the governor to assign and remove the valdiator role from addresses. It further enables the transition of contract administration to a new governor by designating a pending governor who needs to accept his role in an additional step thereby removing the old governor.  Operation Modes  Regular Operation  This operation mode allows only registered validators to commit and execute blocks with rolled-up layer 2 transaction information", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#summary", "labels": ["OpenZeppelin"]}, {"title": "Type", "body": "Type", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#type", "labels": ["OpenZeppelin"]}, {"title": "Rollup", "body": "Timeline  From 2022-09-05  To 2022-09-30  Languages  Solidity  Total Issues  35 (25 resolved, 1 partially resolved)  Critical Severity Issues  0 (0 resolved)  High Severity Issues  0 (0 resolved)  Medium Severity Issues  4 (4 resolved)  Low Severity Issues  16 (14 resolved)  Notes & Additional Information  15 (7 resolved, 1 partially resolved)  Scope  We audited the matter-labs/zksync-2-dev repository at the c05b49d7e303996f60a0e35f18ef224e45ee19f5 commit.  In scope were the following contracts:  System Overview  zkSync is a layer 2 scaling solution for Ethereum based on zero-knowledge rollup technology. The protocol aims to provide low transaction fees and high throughput while maintaining full EVM compatibility.  In zkSync users sign and send transactions to validators who process them, include them into blocks, and create a cryptographic commitment of the updated state. This commitment (root hash) is then transferred to a smart contract on layer 1 along with a cryptographic proof (SNARK) proving that this new state was correctly calculated based on applying transactions to a previous state. A compressed state update is also sent to layer 1, allowing anyone to reconstruct the state at any moment. The layer 1 contract validates both the state update and the cryptographic proof, assuring the validity of the transactions included in the block and the data availability.  zkSync protocol implements the Diamond Proxy EIP-2535 as an upgrade mechanism, thereby splitting its functionality into four different facets:  Executor: Processing rollups of layer 2 blocks  Mailbox: Bidirectional communication between layer 1 and layer 2  DiamondCut: Contract administration  Governance: Role management  Note that while the aforementioned EIP does not contain any known issues, it is not yet considered finalized.  Executor  The Executor component allows validators to commit, prove, and execute blocks. All blocks are tentative before execution and can be removed by any validator. This component is central in extending the security guarantees of layer 1 to transactions on layer 2 through rollups.  Mailbox  The Mailbox component handles bi-directional communications between layer 1 (L1) and layer 2 (L2). To request an L2 transaction from L1, the transaction data is appended to a queue and removed from it upon final inclusion of the L2-rollup into the L1 contract.  In contrast, communication from L2 to L1 is divided in two parts: Sending a transaction on L2 and reading it from L1. To send information from L2, a special opcode sendToL1 is implemented. Using this opcode, users can send logs or messages. Logs provide a key-value tuple of 32 bytes each to encode data while messages can be of arbitrary length. The transfer of messages is possible via a special system contract converting it into a log containing a hash-commitment. All logs are individually hashed to form the leaf nodes of a blocks fixed-size Merkle tree. The proof of inclusion is made available on L1 by checking against the Merkle tree root. Upon committing a block, verifications are performed to ensure data availability, enabling anyone to prove message inclusion without additional help from the operator.  DiamondCut  Note: For a comprehensive explanation of the diamond update mechanism please refer to EIP-2535.  This component manages upgrade-related operations and freezing/unfreezing of facets. The upgrade mechanism is comprised of three stages:  Upgrade proposal  In this stage, the governor commits both a sequence of changes (add/replace/remove) to the supported facet functions and the fixed address of an initializer contract.  Upgrade notice period  zkSync users are given a constant timeframe to withdraw their funds if they are against the proposed upgrade, unless the Security Council approves an immediate emergency upgrade, thereby skipping the execution delay.  Upgrade execution  The governor can execute the upgrade and provide additional calldata to the initializer contract.  Freezing Mechanism  Matter Labs team has implemented a freezing feature. When defining the facet through diamond cuts, each facet can be set as freezable or not. The governor can freeze the diamond as a whole which affects all freezable facets. Therefore, it is possible to designate parts that shall remain operational in an emergency situation. It is crucial for the DiamondCut facet to remain operational in order to enable the governor to unfreeze the Diamond Proxy after resolving the emergency situation.  Governance  The Governance component allows the governor to assign and remove the valdiator role from addresses. It further enables the transition of contract administration to a new governor by designating a pending governor who needs to accept his role in an additional step thereby removing the old governor.  Operation Modes  Regular Operation  This operation mode allows only registered validators to commit and execute blocks with rolled-up layer 2 transaction information. Thus, users ", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#rollup", "labels": ["OpenZeppelin"]}, {"title": "Timeline", "body": "Timeline", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#timeline", "labels": ["OpenZeppelin"]}, {"title": "From 2022-09-05", "body": "From 2022-09-05", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#from-2022-09-05", "labels": ["OpenZeppelin"]}, {"title": "To 2022-09-30", "body": "To 2022-09-30", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#to-2022-09-30", "labels": ["OpenZeppelin"]}, {"title": "Languages", "body": "Languages", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#languages", "labels": ["OpenZeppelin"]}, {"title": "Solidity", "body": "compiler version is not pinned TODO comments in the code base Typographical errors Unorganized file layout Unused named return variable Write array length to stack to save gas  Conclusions  Appendix  Monitoring Recommendations  Summary  Type  Rollup  Timeline  From 2022-09-05  To 2022-09-30  Languages    Total Issues  35 (25 resolved, 1 partially resolved)  Critical Severity Issues  0 (0 resolved)  High Severity Issues  0 (0 resolved)  Medium Severity Issues  4 (4 resolved)  Low Severity Issues  16 (14 resolved)  Notes & Additional Information  15 (7 resolved, 1 partially resolved)  Scope  We audited the matter-labs/zksync-2-dev repository at the c05b49d7e303996f60a0e35f18ef224e45ee19f5 commit.  In scope were the following contracts:  System Overview  zkSync is a layer 2 scaling solution for Ethereum based on zero-knowledge rollup technology. The protocol aims to provide low transaction fees and high throughput while maintaining full EVM compatibility.  In zkSync users sign and send transactions to validators who process them, include them into blocks, and create a cryptographic commitment of the updated state. This commitment (root hash) is then transferred to a smart contract on layer 1 along with a cryptographic proof (SNARK) proving that this new state was correctly calculated based on applying transactions to a previous state. A compressed state update is also sent to layer 1, allowing anyone to reconstruct the state at any moment. The layer 1 contract validates both the state update and the cryptographic proof, assuring the validity of the transactions included in the block and the data availability.  zkSync protocol implements the Diamond Proxy EIP-2535 as an upgrade mechanism, thereby splitting its functionality into four different facets:  Executor: Processing rollups of layer 2 blocks  Mailbox: Bidirectional communication between layer 1 and layer 2  DiamondCut: Contract administration  Governance: Role management  Note that while the aforementioned EIP does not contain any known issues, it is not yet considered finalized.  Executor  The Executor component allows validators to commit, prove, and execute blocks. All blocks are tentative before execution and can be removed by any validator. This component is central in extending the security guarantees of layer 1 to transactions on layer 2 through rollups.  Mailbox  The Mailbox component handles bi-directional communications between layer 1 (L1) and layer 2 (L2). To request an L2 transaction from L1, the transaction data is appended to a queue and removed from it upon final inclusion of the L2-rollup into the L1 contract.  In contrast, communication from L2 to L1 is divided in two parts: Sending a transaction on L2 and reading it from L1. To send information from L2, a special opcode sendToL1 is implemented. Using this opcode, users can send logs or messages. Logs provide a key-value tuple of 32 bytes each to encode data while messages can be of arbitrary length. The transfer of messages is possible via a special system contract converting it into a log containing a hash-commitment. All logs are individually hashed to form the leaf nodes of a blocks fixed-size Merkle tree. The proof of inclusion is made available on L1 by checking against the Merkle tree root. Upon committing a block, verifications are performed to ensure data availability, enabling anyone to prove message inclusion without additional help from the operator.  DiamondCut  Note: For a comprehensive explanation of the diamond update mechanism please refer to EIP-2535.  This component manages upgrade-related operations and freezing/unfreezing of facets. The upgrade mechanism is comprised of three stages:  Upgrade proposal  In this stage, the governor commits both a sequence of changes (add/replace/remove) to the supported facet functions and the fixed address of an initializer contract.  Upgrade notice period  zkSync users are given a constant timeframe to withdraw their funds if they are against the proposed upgrade, unless the Security Council approves an immediate emergency upgrade, thereby skipping the execution delay.  Upgrade execution  The governor can execute the upgrade and provide additional calldata to the initializer contract.  Freezing Mechanism  Matter Labs team has implemented a freezing feature. When defining the facet through diamond cuts, each facet can be set as freezable or not. The governor can freeze the diamond as a whole which affects all freezable facets. Therefore, it is possible to designate parts that shall remain operational in an emergency situation. It is crucial for the DiamondCut facet to remain operational in order to enable the governor to unfreeze the Diamond Proxy after resolving the emergency situation.  Governance  The Governance component allows the governor to assign and remove the valdiator role from addresses. It further enables the transition of contract administration to a new governor by designating a pending governor who needs to accept his", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#solidity", "labels": ["OpenZeppelin"]}, {"title": "Total Issues", "body": "Total Issues", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#total-issues", "labels": ["OpenZeppelin"]}, {"title": "35 (25 resolved, 1 partially resolved)", "body": "35 (25 resolved, 1 partially resolved)", "html_url": "https://blog.openzeppelin.com/zksync-layer-1-audit#35-(25-resolved,-1-partially-resolved)", "labels": ["OpenZeppelin"]}, {"title": "Implicit balances", "body": "There are several instances throughout the code base where the strategies use their token balance without validating it matches the expected value. This has two implications:  It does not account for tokens that could be sent to the contract directly.  It assumes the contract has received the expected number of tokens.  The most important example is both instances when the ConvexOUSDMetaStrategy attempts to burn all its OUSD tokens. This would fail if its balance exceeds the acceptable range, which could occur if someone sends OUSD directly to the strategy.  Additionally, in the interest of predictability:  When the amount of tokens to deposit is already known, that value can be used instead of the contracts balance. Alternatively, only the difference needs to be minted in the first place.  When the amount of tokens to receive is already known, it can be used as the minimum withdrawal amount.  Lastly, in the interest of local reasoning and robustness, consider explicitly confirming that the Curve protocol returns the expected number of tokens, rather than assuming it respects the stated minimum thresholds.  Update: Fixed in commit 290c68fd25a1f2967324948398227684ec834597. The Curve system is still assumed to return the expected number of tokens.  Low Severity", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#implicit-balances", "labels": ["OpenZeppelin"]}, {"title": "Complicated accounting", "body": "slightly overestimate the desired value,  determining the corresponding amount of stablecoin, and then  scaling down the LP amount linearly to match the required stablecoin value. Instead, consider directly querying the amount of LP tokens to burn with the  calc_token_amount function, and then adjusting for fees. If desired, the amount could be validated with the  calc_withdraw_one_coin function.  Update: Acknowledged, not resolved. The Origin team stated:  calc_token_amount does not account for curve fees. Correctly accounting for way curve fees are calculated ends up being more code than the current method.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#complicated-accounting", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent reference to pToken", "body": "The BaseCurveStrategy has two mechanisms to refer to the 3CRV token: the generic mapping it inherits from InitializableAbstractStrategy and its own local variable. We believe the local variable was introduced as a simplification, because all three assets correspond to the same platform token, but it is used inconsistently. In particular:  The withdraw function equivocates between the mapping and the local variable in the event emission and balance check.  The checkBalance function uses the mapping to retrieve the platform token balance but then assumes the asset is worth one third of the value. This only makes sense if there are three assets mapping to the same platform token.  There are code comments that explicitly account for the possibility that not all assets are mapped correctly.  Consider using the local variable throughout the contract and disabling the ability to set the mapping individually.  Update: Partially fixed in commit 49ee19e1d6bbc623bb88027c997658d21fe32390. Some functions (like safeApproveAllTokens) still use the mapping.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#inconsistent-reference-to-ptoken", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent rebase bound", "body": "When minting OUSD tokens, there will be a rebase if the amount equals the threshold. However, when redeeming or burning tokens, the amount needs to be strictly greater than the threshold. Consider using an exclusive (or inclusive) bound throughout the code base.  Update: Fixed in commit e574b38ba22ae95302b9386d06aed980337c07bc.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#inconsistent-rebase-bound", "labels": ["OpenZeppelin"]}, {"title": "Incorrect event parameter", "body": "Both  emissions of the  pTokenAddress variable instead.  Update: Fixed in commit 381fdfaed1ed247167f4f2182a52c27ed9b8dd05.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#incorrect-event-parameter", "labels": ["OpenZeppelin"]}, {"title": "Misleading comments", "body": "The code base contains several misleading comments:  The collectRewardTokens function of the BaseConvexMetaStrategy contract claims to send rewards to the vault, but it sends them to the harvester address.  The depositAll function of the BaseCurveStrategy contract does not accurately describe how all descendant contracts retrieve the 3CRV token address.  The comment explaining how much OUSD to add in the ConvexOUSDMetaStrategy states that it could mint less OUSD if the metapool has too much, but it always adds at least as much OUSD as 3CRV. Moreover, it claims the metapool will end up balanced. However it wont add more than twice as much OUSD (by value) than 3CRV, even if thats necessary to balance the metapool.  The mintForStrategy function of the VaultCore contract claims that it cannot use the nonReentrant modifier because it clashes with the BaseCurveStrategy contracts modifier. However, the two modifiers do not interact with each other. Instead, it is the nonReentrant modifier on the allocate function that would cause the conflict.  The @param comment describing the _lpWithdraw function of the ConvexOUSDMetaStrategy contract claims it is the number of Convex LP tokens to redeem, but it is the number of 3CRV tokens to retrieve.  Consider correcting these comments.  Update: Fixed in commit 4b7f103658656a16d160231f96f36ac1d4336dfd and commit d7ddbb3a2c261ed600d99bc73377de53b4859ad5.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#misleading-comments", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "The setMaxWithdrawalSlippage function of the BaseConvexMetaStrategy contract is missing its @param statement. Consider including it.  Update: Fixed in commit 689d527252ec78932d4bf422be3ac6b8245a777d.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Misusing safeApprove", "body": "The BaseCurveStrategy contract and the BaseConvexMetaStrategy contract provides functionality to grant addresses an infinite allowance. However, they bypass the safety mechanism in safeApprove that prevents changing the allowance between two non-zero values, which is intended to prevent front-running attacks that spend both allowances. In this case, since the intended allowance is unlimited, the possibility of front-running is irrelevant.  Nevertheless, we consider it bad practice to use a safety mechanism while bypassing its additional requirements. Consider using the standard approve function and validating that it succeeds.  Update: Acknowledged, not resolved. The Origin team stated:  We need to handle USDTs non-standard return value (no boolean), and safeApprove provides a clean way of doing this.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#misusing-safeapprove", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent storage gaps", "body": "When using the proxy pattern for upgrades, it is common practice to include storage gaps on parent contracts to reserve space for potential future variables. The size is typically chosen so that all contracts have the same number of variables (usually 50). However, the code base uses inconsistent sizes and does not always include a gap at all. In particular:  The InitializableAbstractStrategy contract reserves 98 slots, bringing the total storage usage up to 106.  The BaseCurveStrategy has no storage gaps.  The BaseConvexMetaStrategy contract reserves 30 slots, bringing the total storage usage up to 39.  Consider using consistently sized storage gaps in all contracts that have not yet been deployed. For contracts that cannot be changed, because they are ancestors of live contracts in the code base, consider documenting the unusual storage size to facilitate safe upgrades.  Update: Fixed in commit e30022cd9fb7e815cb16ffd09a21c276f3980250.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#inconsistent-storage-gaps", "labels": ["OpenZeppelin"]}, {"title": "Uninitialized implementations", "body": "The proxy contracts that represent the strategies should be initialized before they are used. However, it is good practice to initialize the implementation contracts as well to reduce the attack surface by preventing them from being initialized in the future. Consider adding a constructor that calls the initializer to the ConvexOUSDMetaStrategy and ConvexGeneralizedMetaStrategy contracts.  Update: Acknowledged, not resolved. The Origin team stated:  Our implementation contracts have the owner set in the constructor at creation and outsiders cannot initialize them. We will transfer ownership of implementation contracts to the governance system.  Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#uninitialized-implementations", "labels": ["OpenZeppelin"]}, {"title": "Constants not declared explicitly", "body": "There are some occurrences of literal values with unexplained meaning in Origins contracts. For example, line 135 in BaseConvexMetaStrategyand line 212 in BaseCurveStrategy.sol. Literal values in the code base without an explained meaning make the code harder to read, understand, and maintain. This makes the code harder to understand for developers, auditors, and external contributors alike.  Developers should define a constant variable for every magic value used (including booleans), giving it a clear and self-explanatory name. Additionally, for complex values, inline comments explaining how they were calculated or why they were chosen are highly recommended. Following Soliditys style guide, constants should be named in UPPER_CASE_WITH_UNDERSCORES format.  Update: Fixed in commit 46cfa3a8e0c9511b987234978178d80248215664.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#constants-not-declared-explicitly", "labels": ["OpenZeppelin"]}, {"title": "Implicit visibility", "body": "The state variables crvCoinIndex and mainCoinIndex in the BaseConvexMetaStrategy contract do not have an explicit visibility modifier. In the interest of clarity, consider including it.  Update: Fixed in commit 9d794d1e682dad35d61dd84b906b6168179a46ec.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#implicit-visibility", "labels": ["OpenZeppelin"]}, {"title": "Unindexed events", "body": "Consider indexing the VaultCore events to assist the task of off-chain services searching and filtering for specific events.  Update: Acknowledged, not resolved The Origin team stated:  Were going to keep our existing event signatures for backwards compatibility. For the new event (OusdMetaStrategyUpdated), well keep it consistent with the existing events.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#unindexed-events", "labels": ["OpenZeppelin"]}, {"title": "Unused import", "body": "The BaseCurveStrategy has an unnecessary import statement. Consider removing it.  Update: Fixed in commit ea5154feaa97b64a36bd49d83d38be6b9d526524.", "html_url": "https://blog.openzeppelin.com/origin-dollar-audit-2#unused-import", "labels": ["OpenZeppelin"]}, {"title": "Conflated staking pool reward balances", "body": "Each staking pool specifies its own reward token and corresponding balance in the same aggregate contract. When retrieving this value, the token balance of the aggregate contract is returned. Since there could be multiple staking pools with the same reward token, this could include balances from other pools. It could also include any reward token balances that were directly sent to the contract.  Moreover, current user rewards could also be overstated, which would prevent users from claiming the last rewards. Since rewards are claimed when withdrawing stake, anyone could prevent users from unstaking by directly sending reward tokens to the staking pool contract. Any non-zero amount would be sufficient to trigger this scenario. If this occurs, a recovery agent could still retrieve the funds from the aggregate pool contract and distribute them as desired, although it is not clear how they should distribute the remaining rewards.  Consider reading the pool balance from the saved record.  Update: Fixed as of commit 8b660b13cf9fbcde0bfedb3819dbb670ba74b09a in pull request #156.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#conflated-staking-pool-reward-balances", "labels": ["OpenZeppelin"]}, {"title": "Risk of insufficient liquidity", "body": "When purchasing a cover, the protocol ensures it has enough funds to pay out all potential claimants. The computation of the existing commitments includes all covers expiring in the next 3 months, since this is the maximum policy duration. However, some covers may expire in the fourth month and these would be excluded from the calculation. Therefore, the protocol could sell more insurance than it can support, and some valid claimants may be unable to retrieve their payment.  Consider including the extra month in the commitment computation.  Update: Fixed as of commit 63fce22c67f72cf090ffa124784a3d92935e2d66 in pull request #136.  Medium Severity", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#risk-of-insufficient-liquidity", "labels": ["OpenZeppelin"]}, {"title": "Unenforced staking requirement", "body": "Adding liquidity requires a liquidity provider to have at least a minimum amount of NPM tokens staked in the vault.  However, the purpose and usefulness of this requirement is unclear, since it can be bypassed. In particular:  there is no relationship between the amount of PODs created and the size of the stake  PODs are transferable to unstaked users, so users can provide liquidity without staking  staked users can exit their entire staked amount without redeeming any PODs by calling removeLiquidity with parameters podsToRedeem = 0, npmStakeToRemove = amount, and exit = 1; the exit = 1 is crucial as it allows execution of line 234 of VaultLibV1.sol  Consider documenting and enforcing the intended relationship between NPM staking and liquidity provision.  Update: Acknowledged, not fixed. The Neptune team stated:  Although we plan to redo the staking requirement logic from scratch, we wish to consider this risk as acceptable for the time being.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#unenforced-staking-requirement", "labels": ["OpenZeppelin"]}, {"title": "Potential token transfer from unrelated account", "body": "The CoverReassurance contract contains a mechanism to retrieve funds from an arbitrary account, as long as the account has provided a non-zero allowance. This would occur whenever a cover owner can front-run another cover owners reassurance transaction, allowing them to redirect the funds to their own cover.  Even without front-running, there are multiple reasons an account may have a non-zero allowance, including:  Their addReassurance transaction failed and they didnt revoke the allowance.  They made an unlimited approval.  They approved a higher allowance than the amount they eventually transferred.  In all cases, an attacker can retrieve those funds and direct them towards a cover.  A recovery agent could still retrieve the funds from the CoverReassurance contract and distribute them as desired, although it is unclear how they would distinguish a front-running attack from one where a cover owner legitimately transfers funds from a different account.  Consider retrieving the tokens from the message sender rather than an arbitrary account parameter.  Update: Fixed as of commit ca55b69c5cdd80bcccdc83dd5d569933f450fa6a in pull request #139.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#potential-token-transfer-from-unrelated-account", "labels": ["OpenZeppelin"]}, {"title": "Incorrect policy fee", "body": "There are two discrepancies when calculating a policy fee rate:  It is always strictly higher than the configured floor.  The amount of days charged does not account for a non-standard coverage lag period.  Consider updating the calculation accordingly.  Update: Fixed as of commit 84a6fc3167adfb61b6f16666f0ba422b60bc0b2c in pull request #159 and commit 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196. The Neptune team have chosen not to address the first bullet.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#incorrect-policy-fee", "labels": ["OpenZeppelin"]}, {"title": "Parallel access control", "body": "The Protocol contract inherits the OpenZeppelin AccessControl contract, and uses it to define the role hierarchy. It also provides a mechanism for the administrator to grant an existing role to a new address. However, this mechanism functions in parallel to the inherited mechanism for granting roles. This leads to two inconsistencies:  A role administrator can bypass the whenNotPaused restriction by using the inherited mechanism.  The NS_ROLES_ADMIN can use the new mechanism to grant the NS_ROLES_GOVERNANCE_AGENT, even though they do not directly administer that role.  Consider ensuring consistency between the two mechanisms. Depending on the desired outcome, this could involve relying on the original mechanism, changing the role relationships, or overriding the inherited grantRole function.  Update: Fixed as of commit 1d54d66493e3109c12d610f0231529cbd65b5ba9 in pull request #157 and commit 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#parallel-access-control", "labels": ["OpenZeppelin"]}, {"title": "Unable to unstake after finalization", "body": "Reporters on the winning camp can unstake their tokens even after the incident has been finalized, albeit with no reward. However, the resolution deadline is not specific to a particular incident and is reset to 0 during finalization. Since the deadline is checked during unstaking, the operation will fail. This means that some successful NPM stakers will be unable to retrieve their funds.  In this scenario, a recovery agent could still retrieve the funds from the Resolution contract and distribute them as desired.  Consider recording the resolution deadline with the incident date so it does not need to be cleared during finalization.  Update: Fixed as of commit 6cb6b6064eca18cccee8114cbcefd2455c286ce9 in pull request #132 and commit 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#unable-to-unstake-after-finalization", "labels": ["OpenZeppelin"]}, {"title": "Unexpected deployer privileges", "body": "recorded as a protocol member, which allows it to update the storage arbitrarily. The same address  is set as the contracts  pause and unpause storage updates. We believe these are intended to be the same role, but they are not programmatically connected. In particular, if the owner address is  renounced or transferred, the deployer will still be able to update storage.  Moreover, it is unclear why the Store owner or deployer requires the ability to modify storage arbitrarily.  Consider documenting the role in the Security overview if the role is required. Otherwise, consider renouncing protocol member privileges from the deployer address after the deployment is finished.  Update: Fixed as of commit 0b278019c01dbce22923d0bb6968ddb48bcc3e2d in pull request #123. The deployer address is removed as a protocol member, assuming the deployer is the address that calls the initialize function.  Low Severity", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#unexpected-deployer-privileges", "labels": ["OpenZeppelin"]}, {"title": "Able to close non-empty staking pool", "body": "A staking pool can be closed without checking if there is any remaining liquidity of either the staking token or the reward token. Once the pool is closed, neither deposit nor withdraw functions are allowed. Hence, users wont be able to access their funds. However a recovery agent is still able to retrieve both staking and reward tokens and distribute them as desired.  Consider checking for remaining liquidity before closing a pool.  Update: Fixed as of commit 86b0caa0995ffcdbb1deecf8547c9a3db8c23821 in pull request #160.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#able-to-close-non-empty-staking-pool", "labels": ["OpenZeppelin"]}, {"title": "Collision between constants", "body": "The NS_POOL_MAX_STAKE and NS_POOL_REWARD_TOKEN constants are defined to be the same string, which introduces the possibility of unexpected storage collisions. In the current code base they are used with non-overlapping data types, which are saved in different mappings. Nevertheless, in the interest of predictability, consider redefining the NS_POOL_MAX_STAKE constant to a unique string.  Update: Fixed as of commit 90f03dce0d24af3affc50d19ac81bbc12b524a4f in pull request #161.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#collision-between-constants", "labels": ["OpenZeppelin"]}, {"title": "Implicit timing assumptions", "body": "To account for the coverage delay, some valid cxTokens may be excluded from making claims. Any coverage that will become active within 14 days but before the incident resolution will be disregarded. This implicitly assumes that no valid cover starts after either of these deadlines (otherwise it should also be excluded). Since the coverage delay and resolution window are configurable parameters, the assumptions may not hold. Consider calculating exclusions based on the specific parameters that are relevant to the incident being processed.  Update: Fixed as of commit e00b4248768c196a2b5047dcc21d91a2503452ab in pull request #162 and commit 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#implicit-timing-assumptions", "labels": ["OpenZeppelin"]}, {"title": "Imprecise bounds", "body": "There are several examples where the time windows or value ranges are defined inconsistently. In particular:  The getWithdrawalInfoInternal function of the RoutineInvokerLibV1 library considers the end timestamp to be part of the withdrawal period but the mustBeDuringWithdrawalPeriod validation function does not.  The StakingPoolLibV1 library prevents withdrawals on the block height where withdrawals can start.  Neither the mustBeBeforeResolutionDeadline function nor the mustBeAfterResolutionDeadline function will succeed on the resolution deadline.  The flash loan fee calculation requires the loan to be strictly less than the available balance, even though the contract claims to loan out the whole balance.  Update: Fixed as of commit 3412b68b9d729d0bc5c3b5860ace7a38a06b9835 in pull request #167.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#imprecise-bounds", "labels": ["OpenZeppelin"]}, {"title": "Incorrect NPM threshold", "body": "Some operations require an NPM stake that must not exceed a threshold, currently set to 10 billion. However, the total NPM supply cannot exceed 1 billion, making the threshold non-functional. The Neptune team indicated the threshold should only be 10 million. Consider updating the constant accordingly.  Update: Fixed as of commit 78fafa7314793a3b6b5fe40e1c9129c8f8c4f813 in pull request #164.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#incorrect-npm-threshold", "labels": ["OpenZeppelin"]}, {"title": "Lack of input validation", "body": "The mustNotExceedNpmThreshold function should validate npmStakeToAdd instead of amount.  The setPolicyRatesByKey function in the PolicyAdmin contract does not check that ceiling is greater than floor, while a similar function setPolicyRates does.  The initialize function in the Protocol contract does not check the length of the input values array.  When computing unstaking rewards after an incident resolution, the sum of the toBurn and toReporter rates are not validated to be bounded above by ProtoUtilV1.MULTIPLIER.  Consider including the corresponding validations.  Update: Fixed as of commit 5ce4b8d3ff0b0a7eb4f0265b4201c93c43af4f30 in pull request #172 and commit 4b929c274100a981107e35d40fbf5b57fabc9be4 in pull request #196.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Missing event parameter", "body": "The PoolUpdated event does not include the stakingTarget parameter. Consider including it.  Update: Fixed as of commit 89d30f63d6c43dd3787cd291e31c03a2b712a0a2 in pull request #163.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#missing-event-parameter", "labels": ["OpenZeppelin"]}, {"title": "No unstaking window", "body": "After an incident is resolved, successful stakers can retrieve their rewards provided the incident has not been finalized. When the incident occurred, they will have at least the claim period. However, if the incident was successfully disputed, there is no claim period and the incident can be finalized immediately before stakers have been provided sufficient time to claim their rewards. Consider including an unstaking window for this scenario.  Update: Acknowledged, not fixed. The Neptune team stated:  For incidents resolved as false reporting, we intend to restore the cover status to operational as soon as possible. This flexibility allows us to accomplish a speedier finalization while still allowing the tokenholder community sufficient time to unstake their claim (with reward) on a case-by-case basis.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#no-unstaking-window", "labels": ["OpenZeppelin"]}, {"title": "Protocol administrator needs to handle external tokens", "body": "The protocol administrator is one of the most critical roles with immense privilege in the operation of the entire protocol. For example, only the administrator can re-initialize the protocol, grant key access control roles, as well as set up all staking and bonding pools.  However, when setting up a staking pool, a non-zero amount of reward tokens are required to be pre-transferred to the administrator account and pulled to the contract. This implies that the administrator needs to receive and approve the transaction a priori. This increases the attack surface and may not fit the intended security assumptions for a critical role.  Consider either using a less critical role to perform staking pool initialization or allowing pool initialization without any token transfer.  Update: Fixed as of commit 71fd05996061b9c438c557c92cd888f4f4c9c542 in pull request #173. The Liquidity Manager must now initialise and manage the staking pools. They must also set up the Bond pools.  The info parameter might lose information about an IPFS hash  The info parameter of the report, dispute, and other functions assume that the length of the IPFS hash is 32 bytes or shorter. However, that is not the case for CIDv1 where the hash can be longer than 32 bytes and also contain prefixes.  This leads to a data availability issue when NPM holders might be unable to retrieve the incident information from the smart contracts. Consequently, they are unable to decide whether to attest or refute the incident.  Consider using a different data structure for storing an IPFS hash.  Update: Fixed as of commit 5ebb130fe274f0237e368ceaac25751936c1b321 in pull request #165.  Incorrect individual liquidity share  The calculation of an individuals share of liquidity for a particular cover incorrectly uses values[5] instead of values[4] as the number of PODs. Since this is always zero, the returned share of liquidity will always be zero.  This has no implications within the current code base but would mislead external users that rely on it. Consider using the correct number of PODs in the calculation.  Update: Fixed as of commit 2192646ab5efa95a90521b986c81c05ed04fcd37 in pull request #166.  Variable outside store  In contrast to most of the code base, the last policy identifier is saved directly in the Policy contract. However, to maintain continuity and prevent conflicts, any new version will need to import the old value.  Consider saving it in the Store contract.  Update: Fixed as of commit 1826fa97f1b325d40b0b3446b384dac35074540f in pull request #168.  Notes & Additional Information  transfer and send calls are no longer considered best practice  When transfer or send calls are used to transfer Ether to an address, they forward only a limited amount of gas. This precludes destination addresses with complex fallback functions. Additionally, given that gas prices for EVM operations are sometimes repriced, code execution on the receiving end of these calls cannot be guaranteed in perpetuity.  There are multiple occurrences throughout the code base where transfer or send is used to transfer Ether. For instance:  On line 41 of StoreBase.sol Ether is transferred via transfer.  On line 19 of WithRecovery.sol Ether is transferred via transfer.  On line 23 of BaseLibV1.sol Ether is transferred via transfer.  Rather than using transfer or send, consider using address.call{value: amount}(\"\") or the sendValue function of the OpenZeppelin Address library to transfer Ether.  Update: Fixed as of commit adf8883628f94a27ae61376e98d112f998029e16 in pull request #187.  Anyone can temporarily DoS a fresh vault  Vaults are deployed by whitelisted cover creators with the addCover function. To prevent someone from unbalancing the POD-to-stablecoin ratio immediately after deployment, the Vault detects unmatched stablecoins and reverts on any attempt to add liquidity which effectively disables the vault.  A recovery agent could retrieve the excess funds to re-enable the contract. Nevertheless, to avoid this scenario, consider adding some liquidity in the same transaction as the deployment. Alternatively, consider tracking the stablecoin balance in a variable to mitigate issues caused by direct transfers.  Commit-Reveal voting  The Governance mechanism allows NPM token holders to vote on whether they believe a reported incident is valid. Typically, the rationale for using voting as an oracle is that token holders, who are incentivized to vote with the majority, will treat the truth as a natural Schelling Point. However, since token holders can review the running total, they may instead simply vote with the majority.  This is commonly mitigated with a commit-reveal voting scheme. However, it is also mitigated by the possibility of a governance administrator overruling the vote. We are just noting the practice for your consideration. If the commit-reveal scheme is adopted, votes that are not revealed should be considered incorrect so that users cannot selectively abstain ba", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#protocol-administrator-needs-to-handle-external-tokens", "labels": ["OpenZeppelin"]}, {"title": "The info parameter might lose information about an IPFS hash", "body": "The info parameter might lose information about an IPFS hash", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#the-info-parameter-might-lose-information-about-an-ipfs-hash", "labels": ["OpenZeppelin"]}, {"title": "Incorrect individual liquidity share", "body": "The calculation of an individuals share of liquidity for a particular cover incorrectly uses values[5] instead of values[4] as the number of PODs. Since this is always zero, the returned share of liquidity will always be zero.  This has no implications within the current code base but would mislead external users that rely on it. Consider using the correct number of PODs in the calculation.  Update: Fixed as of commit 2192646ab5efa95a90521b986c81c05ed04fcd37 in pull request #166.", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#incorrect-individual-liquidity-share", "labels": ["OpenZeppelin"]}, {"title": "Variable outside store", "body": "In contrast to most of the code base, the last policy identifier is saved directly in the Policy contract. However, to maintain continuity and prevent conflicts, any new version will need to import the old value.  Consider saving it in the Store contract.  Update: Fixed as of commit 1826fa97f1b325d40b0b3446b384dac35074540f in pull request #168.  Notes & Additional Information  transfer and send calls are no longer considered best practice  When transfer or send calls are used to transfer Ether to an address, they forward only a limited amount of gas. This precludes destination addresses with complex fallback functions. Additionally, given that gas prices for EVM operations are sometimes repriced, code execution on the receiving end of these calls cannot be guaranteed in perpetuity.  There are multiple occurrences throughout the code base where transfer or send is used to transfer Ether. For instance:  On line 41 of StoreBase.sol Ether is transferred via transfer.  On line 19 of WithRecovery.sol Ether is transferred via transfer.  On line 23 of BaseLibV1.sol Ether is transferred via transfer.  Rather than using transfer or send, consider using address.call{value: amount}(\"\") or the sendValue function of the OpenZeppelin Address library to transfer Ether.  Update: Fixed as of commit adf8883628f94a27ae61376e98d112f998029e16 in pull request #187.  Anyone can temporarily DoS a fresh vault  Vaults are deployed by whitelisted cover creators with the addCover function. To prevent someone from unbalancing the POD-to-stablecoin ratio immediately after deployment, the Vault detects unmatched stablecoins and reverts on any attempt to add liquidity which effectively disables the vault.  A recovery agent could retrieve the excess funds to re-enable the contract. Nevertheless, to avoid this scenario, consider adding some liquidity in the same transaction as the deployment. Alternatively, consider tracking the stablecoin balance in a variable to mitigate issues caused by direct transfers.  Commit-Reveal voting  The Governance mechanism allows NPM token holders to vote on whether they believe a reported incident is valid. Typically, the rationale for using voting as an oracle is that token holders, who are incentivized to vote with the majority, will treat the truth as a natural Schelling Point. However, since token holders can review the running total, they may instead simply vote with the majority.  This is commonly mitigated with a commit-reveal voting scheme. However, it is also mitigated by the possibility of a governance administrator overruling the vote. We are just noting the practice for your consideration. If the commit-reveal scheme is adopted, votes that are not revealed should be considered incorrect so that users cannot selectively abstain based on the running total.  Copied in dependencies  Dependencies in the lib directory, including openzeppelin-solidity, are copied in without any reference in .gitmodules. This makes it hard to keep track of the latest versions and easy to accidentally change the code inside.  Consider using forge install OpenZeppelin/openzeppelin-contracts for the latest version of the OpenZeppelin contracts.  Update: Fixed as of commit 80f024fb21389e5d29eff9e79a6d0248c6f61183 in pull request #188.  Docstrings not following NatSpec  Across the code base there are several examples of contracts not consistently following the Ethereum Natural Specification Format (NatSpec). Consider following this specification on everything that is part of the contracts public API.  Some examples include:  Missing NatSpec for productKey at line 151 of PolicyHelperV1.  Discrepancy between addCovers NatSpec in the Cover contract and the ICover interface the interfaces misses NatSpec for 8th and 9th parameters. Consider using @inheritdoc NatSpec tag.  Return variables are documented using @param instead of @return in Vault.getInfo.  Duplicate modifier  The unpause function of the ProtoBase contract has two whenPaused modifiers. Consider removing the first one.  Update: Fixed as of commit 290c68fd25a1f2967324948398227684ec834597 in pull request #183.  Duplicate token supply tracking  The NPM token tracks the number of tokens that have been issued. This should be identical to the total supply if the tokens are never burned. Its worth noting that the code base transfers funds to a burner address instead of reducing the supply.  Consider disabling the burn functionality so that the total issued amount does not need to be tracked and updated separately.  Update: Not an issue. The Neptune team stated:  Given that the NPM token and protocol will be deployed on different blockchains, this is the proper approach. Ethereum is the only chain where token burn occurs. The burned tokens are transferred to a specified address on each chain and then bridged back to Ethereum on a regular basis.  Excessive indirection and coupling  We found this audit to be significantly complicated by data storage reference patterns that hinder", "html_url": "https://blog.openzeppelin.com/neptune-mutual-audit#variable-outside-store", "labels": ["OpenZeppelin"]}, {"title": "reducedFraction does not reduce in the mathematical sense", "body": "reducedFraction does not reduce in the mathematical sense", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#reducedfraction-does-not-reduce-in-the-mathematical-sense", "labels": ["OpenZeppelin"]}, {"title": "weightedAverage calculation might overflow", "body": "weightedAverage calculation might overflow", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#weightedaverage-calculation-might-overflow", "labels": ["OpenZeppelin"]}, {"title": "calcExpDecayRewards is at risk of overflow reversions", "body": "calcExpDecayRewards is at risk of overflow reversions", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#calcexpdecayrewards-is-at-risk-of-overflow-reversions", "labels": ["OpenZeppelin"]}, {"title": "Lack of validation", "body": "Throughout the codebase, there are places where a proper input/output validation is lacking. In particular:  The inverse and fromFraction112 functions in FractionLibrary do not check if they were provided an invalid fraction.  The _mulMod, mulDivC, mulDivF functions in the MathEx library do not check that z in non-zero. In such cases they revert with a Panic, rather than a more helpful error message.  The isInRange and weightedAverage functions in the MathEx library do not check that the input fractions are valid. The latter also does not ensure it is returning a valid fraction.  A lack of validation on user-controlled parameters may result in erroneous or failing transactions that are difficult to debug. This is especially true in the case of libraries that are capable of being reused across different codebases. To avoid this, consider adding input and output validation to address the concerns raised above.  Update: Acknowledged without code changes. The client expressed that the lack of reversion on invalid inputs is intentional. In some cases it is desirable behavior to turn divide by zero inputs into zero outputs. In other cases, error messages will be raised somewhere else along the call chain in practice.  Low Severity", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#lack-of-validation", "labels": ["OpenZeppelin"]}, {"title": "Unbounded number of programs could result in errors", "body": "The programs function loops over a potentially unbounded list of programs/pools.  Relatedly, the pools function requires that all stored values associated with stored pools are first loaded into memory for the call to complete.  In either case, if too many programs are added to the protocol, these functions will run out of gas.  Although neither of these functions are used internally, should the number of programs grow too large, they could be problematic for external contracts that might rely on them.  Consider either adding a pagination mechanism to limit the number of stored values that must be loaded or adding some warning to the documentation about the need to keep the number of programs bounded to some safe level to avoid issues with these functions.  Update: Acknowledged. The client conveyed that simplicity of the external interface was an intentional design choice. If future on-chain usage becomes relevant the respective contract will be upgraded.", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#unbounded-number-of-programs-could-result-in-errors", "labels": ["OpenZeppelin"]}, {"title": "Duplicated code", "body": "The internal logic of the poolTokenAmountToBurn functions in the BNTPool and PoolCollection contracts are essentially duplicates.  Duplicating code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors. Such errors can inadvertently be introduced when functionality changes are not replicated across all instances of code that should be identical.  Rather than duplicating code, consider having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Acknowledged. The flexibility of independent upgrades is prioritized over re-use in this case. Clients response:  If the contracts are used for a while and the shared logic is kept in place without frequent changes, a shared logic component will be created, but for now flexibility is more important than code reusability, especially since these two contracts are very different conceptually.  uint32 times can overflow in the future  Throughout the AutoCompoundingRewards contract, all program start, end, and elapsed times are encoded as uint32 values. In the year 2106, this will be problematic in two ways.  Near the time when unix timestamps will begin to overflow the uint32 type, it will become difficult to create flat programs ending after the unix timestamp overflow event. Specifically, it will not be possible to call createFlatProgram with an endTime that overflows the uint32 type because it will appear to be less than the startTime. This will be a temporary inconvenience, because once the current time overflows the uint32 type it will be possible to create new flat programs as normal again.  The createExpDecayProgram does not expect an endTime input. Instead, a halfLife input parameter is specified. This will make it possible to call createExpDecayProgram even around the time that unix time will overflow the uint32 type. However, if a program is created before the overflow time, then after the overflow time, even if it should be a valid program, it would be treated as inactive and no rewards from the program could be processed. This, in turn, would prevent both processRewards and autoProcessRewards from processing rewards for that program. This would be more problematic and tight packing of the stored programs could make an update to remedy the situation more difficult.  Consider either increasing the bits available to store and evaluating timestamps to something larger than uint32 or adding a warning to the protocol documentation to upgrade the contract well before the overflow time will be reached.  Update: Acknowledged. Clients response:  The contracts are expected to change and evolve and new versions implemented way before the timestamps can overflow (at 2106).  Lack of event emissions after updating state  The following functions do not emit relevant events despite executing state-altering actions:  No event is emitted when the _autoProcessRewardsCount variable is first set during contract initialization. This is inconsistent with the fact that an event is emitted when the same value is updated via the setAutoProcessRewardsCount function.  There is no event emitted when _autoProcessRewardsIndex is updated despite the fact that this value influences the behavior of the external autoProcessRewards function.  In order to facilitate tracking and to notify off-chain clients following the contracts activity, consider emitting events whenever state-changing operations take place.  Update: Partially addressed in commit 5f223b2ff0f1f9fcdd92d89bc2e420c9d984cb5c. An event including the new value of _autoProcessRewardCount is now emitted during contract construction. However, the client considers _autoProcessRewardsIndex an non-public implementation detail which should not emit events upon alteration, despite its role in facilitating monitoring.  enableProgram is overloaded  In the AutoCompoundingRewards contract, the enableProgram function is used to enable or disable a program for a specific pool, depending on the bool status parameter. The function also emits a ProgramEnabled event, even in the instance where the program is being disabled (although the event details contain the correct updated status).  In order to avoid unnecessary confusion and to increase the overall readability of the codebase, consider renaming the function and event to something such as updateProgramStatus to better reflect the actual function operation.  Update: Acknowledged. Clients response:  This was a design decision in order to prioritize ease of consumption (single event) and binary size over readability.  Notes & Additional Information  Confusing use of assert statement  assert statement in the  calcFlatRewards function of the  RewardsMath library checks a condition that is impossible only because of how it is used within the  _tokenAmountToDistribute function. However, given the  To enforce input validation within the calcFlatRewards function, co", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#duplicated-code", "labels": ["OpenZeppelin"]}, {"title": "uint32 times can overflow in the future", "body": "uint32 times can overflow in the future", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#uint32-times-can-overflow-in-the-future", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emissions after updating state", "body": "The following functions do not emit relevant events despite executing state-altering actions:  No event is emitted when the _autoProcessRewardsCount variable is first set during contract initialization. This is inconsistent with the fact that an event is emitted when the same value is updated via the setAutoProcessRewardsCount function.  There is no event emitted when _autoProcessRewardsIndex is updated despite the fact that this value influences the behavior of the external autoProcessRewards function.  In order to facilitate tracking and to notify off-chain clients following the contracts activity, consider emitting events whenever state-changing operations take place.  Update: Partially addressed in commit 5f223b2ff0f1f9fcdd92d89bc2e420c9d984cb5c. An event including the new value of _autoProcessRewardCount is now emitted during contract construction. However, the client considers _autoProcessRewardsIndex an non-public implementation detail which should not emit events upon alteration, despite its role in facilitating monitoring.  enableProgram is overloaded  In the AutoCompoundingRewards contract, the enableProgram function is used to enable or disable a program for a specific pool, depending on the bool status parameter. The function also emits a ProgramEnabled event, even in the instance where the program is being disabled (although the event details contain the correct updated status).  In order to avoid unnecessary confusion and to increase the overall readability of the codebase, consider renaming the function and event to something such as updateProgramStatus to better reflect the actual function operation.  Update: Acknowledged. Clients response:  This was a design decision in order to prioritize ease of consumption (single event) and binary size over readability.  Notes & Additional Information  Confusing use of assert statement  assert statement in the  calcFlatRewards function of the  RewardsMath library checks a condition that is impossible only because of how it is used within the  _tokenAmountToDistribute function. However, given the  To enforce input validation within the calcFlatRewards function, consider changing the assert statement to a require, and providing an error message explaining the validation. Alternatively, consider moving the assert statement into the _tokenAmountToDistribute function to check that the invariant holds in that context.  Update: Remains unaddressed in commit b2224595afab14827ee065cb65a1444d61689fb3. While the documentation of the function improved in commit ce5d2e73b348fcc368157edd70a5e59d043d939d, the function still uses assert to check a condition that is not an invariant.  Unused import  In the AutoCompoundingRewards contract the AccessDenied import is unused.  Consider removing unused import statements to simplify the codebase and increase overall readability.  Update: Fixed as of commit 107b3aa85bc306a0d94705a0bd816e57267bd9f7 in pull request #430.  Missing docstrings  Throughout the codebase there are numerous functions missing or lacking documentation. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Acknowledged. The comments will be added in future versions of the codebase.  Conclusions  1 high and 3 medium severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#lack-of-event-emissions-after-updating-state", "labels": ["OpenZeppelin"]}, {"title": "enableProgram is overloaded", "body": "enableProgram is overloaded", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#enableprogram-is-overloaded", "labels": ["OpenZeppelin"]}, {"title": "Confusing use of assert statement", "body": "Confusing use of assert statement", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#confusing-use-of-assert-statement", "labels": ["OpenZeppelin"]}, {"title": "Unused import", "body": "In the AutoCompoundingRewards contract the AccessDenied import is unused.  Consider removing unused import statements to simplify the codebase and increase overall readability.  Update: Fixed as of commit 107b3aa85bc306a0d94705a0bd816e57267bd9f7 in pull request #430.", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#unused-import", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "Throughout the codebase there are numerous functions missing or lacking documentation. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Acknowledged. The comments will be added in future versions of the codebase.", "html_url": "https://blog.openzeppelin.com/bancor-compounding-rewards-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "[N01] Multiple Solidity versions in use", "body": "[N01] Multiple Solidity versions in use", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#[n01]-multiple-solidity-versions-in-use", "labels": ["OpenZeppelin"]}, {"title": "Throughout the code base there are different versions of Solidity being used. For example, the\u00a0StakedTokenV1\u00a0contract is specifically using\u00a0version 0.6.12\u00a0while other contracts allow compiling with\u00a0version 0.8.6.", "body": "Throughout the code base there are different versions of Solidity being used. For example, the\u00a0StakedTokenV1\u00a0contract is specifically using\u00a0version 0.6.12\u00a0while other contracts allow compiling with\u00a0version 0.8.6.", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#throughout-the-code-base-there-are-different-versions-of-solidity-being-used.-for-example,-the\u00a0stakedtokenv1\u00a0contract-is-specifically-using\u00a0version-0.6.12\u00a0while-other-contracts-allow-compiling-with\u00a0version-0.8.6.", "labels": ["OpenZeppelin"]}, {"title": "To avoid unexpected behaviors, all contracts in the code base should allow being compiled with the same Solidity version.", "body": "To avoid unexpected behaviors, all contracts in the code base should allow being compiled with the same Solidity version.", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#to-avoid-unexpected-behaviors,-all-contracts-in-the-code-base-should-allow-being-compiled-with-the-same-solidity-version.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Acknowledged.", "body": "Coinbase acknowledges that truncation can occur though has not fixed it as the maximum impact of the truncation would be a failed on-chain transaction and needing to reconfigure the caller.  Notes & Additional Information  [N01] Multiple Solidity versions in use  Throughout the code base there are different versions of Solidity being used. For example, the StakedTokenV1 contract is specifically using version 0.6.12 while other contracts allow compiling with version 0.8.6.  To avoid unexpected behaviors, all contracts in the code base should allow being compiled with the same Solidity version.    Coinbase acknowledges that multiple Solidity versions are being used. This was an intentional decision made to allow battle tested Solidity 0.6.12 USDC code reuse for both the FiatTokenProxy and StakedTokenV1 smart contracts. Weve used Solidity 0.8.6 for our new contracts.  [N02] Naming issue  In order to improve the readability, consider changing the name of the allowanceCurrent function on line 123 of RateLimit contract to currentAllowance to make the name coherent with the estimatedAllowance function on line 111 of RateLimit contract.  Update: Fixed as of commit e676460 in PR #1.  Conclusions  No critical or high severity issues were found in the codebase. Several minor vulnerabilities have been found and recommendations and fixes have been suggested.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#update:\u00a0acknowledged.", "labels": ["OpenZeppelin"]}, {"title": "Coinbase acknowledges that multiple Solidity versions are being used. This was an intentional decision made to allow battle tested Solidity 0.6.12 USDC code reuse for both the\u00a0FiatTokenProxy\u00a0and\u00a0StakedTokenV1\u00a0smart contracts. We\u2019ve used Solidity 0.8.6 for our new contracts.", "body": "Coinbase acknowledges that multiple Solidity versions are being used. This was an intentional decision made to allow battle tested Solidity 0.6.12 USDC code reuse for both the\u00a0FiatTokenProxy\u00a0and\u00a0StakedTokenV1\u00a0smart contracts. We\u2019ve used Solidity 0.8.6 for our new contracts.", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#coinbase-acknowledges-that-multiple-solidity-versions-are-being-used.-this-was-an-intentional-decision-made-to-allow-battle-tested-solidity-0.6.12-usdc-code-reuse-for-both-the\u00a0fiattokenproxy\u00a0and\u00a0stakedtokenv1\u00a0smart-contracts.-we\u2019ve-used-solidity-0.8.6-for-our-new-contracts.", "labels": ["OpenZeppelin"]}, {"title": "[N02] Naming issue", "body": "[N02] Naming issue", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#[n02]-naming-issue", "labels": ["OpenZeppelin"]}, {"title": "In order to improve the readability, consider changing the name of the\u00a0allowanceCurrent\u00a0function on line 123 of\u00a0RateLimit\u00a0contract to\u00a0currentAllowance\u00a0to make the name coherent with the\u00a0estimatedAllowance\u00a0function on line 111 of\u00a0RateLimit\u00a0contract.", "body": "In order to improve the readability, consider changing the name of the\u00a0allowanceCurrent\u00a0function on line 123 of\u00a0RateLimit\u00a0contract to\u00a0currentAllowance\u00a0to make the name coherent with the\u00a0estimatedAllowance\u00a0function on line 111 of\u00a0RateLimit\u00a0contract.", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#in-order-to-improve-the-readability,-consider-changing-the-name-of-the\u00a0allowancecurrent\u00a0function-on-line-123-of\u00a0ratelimit\u00a0contract-to\u00a0currentallowance\u00a0to-make-the-name-coherent-with-the\u00a0estimatedallowance\u00a0function-on-line-111-of\u00a0ratelimit\u00a0contract.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0e676460\u00a0in PR #1.", "body": "Update:\u00a0Fixed as of commit\u00a0e676460\u00a0in PR #1.", "html_url": "https://blog.openzeppelin.com/coinbase-liquid-staking-token-audit#update:\u00a0fixed-as-of-commit\u00a0e676460\u00a0in-pr-#1.", "labels": ["OpenZeppelin"]}, {"title": "Misconfiguration could lead to blocking bids", "body": "In the _processBid function of the AuctionBase contract the time details of the auction are checked. These times are:  extendableUntil  The time until an auction may be extended through late bids.  expirationTime  The time until an asset must be transferred. Otherwise, the payment can be refunded by the user afterwards.  The requirement of line 118 checks the following:  Here, the _SAFETY_TRANSFER_WINDOW is a constant value of two hours. Therefore, the auction must expire after the longest possible duration, including enough time to transfer the asset. Further, substituting the values of extendableUntil and expirationTime and simplifying the inequation we receive:  Both values, universeExtendableBy() and _paymentWindow, are configurable by the contract owner. In the case that the system accidentally is configured to never satisfy the above condition, the requirement would always fail and so would calls to bid. No bids on new auctions would be processed, shutting down all upcoming auctions.  Consider moving this requirement and adding additional checks when setting these configurations.  Update: Fixed with commit ef597b1 of PR#16.", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#misconfiguration-could-lead-to-blocking-bids", "labels": ["OpenZeppelin"]}, {"title": "Previous operator power is not revoked", "body": "_processBuyNow and bid action within  _processBid, the payment details are saved on-chain using the  In the case of an operator change, after the payment details have been written on-chain, there is no way to revoke the power of an operator. This means, if an operators key was compromised and that operator is saved as the operator in charge of a listing in the _payments mapping, they could still finalize a payment or auction with an untruthful transferResult.wasSuccessful outcome even after changing the current operator for the universe.  For instance, after the first bid on an auction and a consecutive operator change, the previous operator can bid and win the auction to then get the asset transferred. But during finalization they are able to sign that the asset transfer was not successful to also get the refund. Similarly, if the operator knows they are exchanged in the future, they can buy an asset or win an auction to then maliciously finalize the payment the same way.  Consider revoking the power of any previous operator, e.g., by fetching the current operator through the universeOperator function inside the _finalize function. The returned address can then be checked against the provided signature to assure that only the current operator can finalize a payment. In addition, remove the operator from the Payments struct.  Update: Fixed with commit ff4ff3b of PR#15.", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#previous-operator-power-is-not-revoked", "labels": ["OpenZeppelin"]}, {"title": "Seller\u2019s signature not required", "body": "In this protocol, listing an asset is simply having the operator sign either a BidInput or a BuyNowInput struct. From there, once a buyer either places a bid or completes a buy-it-now listing, the struct will be saved on-chain. When processing either type of struct, the only requirements around signing is a valid signature from the operator.  Nowhere in the process is it required for the seller to signal that they intend to sell their asset. Requiring the sellers signature over the listing would ensure that the origin of the listing was the seller itself. If a signature was not required, users could create phony listings that will never complete.  Since the seller is required to actually transfer an asset at the end of a listing, the worst situation that should arise would be a large number of listings that do not complete after they end, resulting in users funds being locked for small periods of time.  Consider requiring the sellers signature along with the operators when listing assets.  Update: Partially fixed with commit 097fa4c of PR#18. Seller validation is done with a signature over the paymentId, which does not remove the need for trust between operator and seller. However, the upgradability allowed via the EIP712 implementation contract allows for future updates which remedy this.  The Freeverse team states:  Following your suggestion, we decided to start, at least, with what we already have, and require the already-existing L2 sellerSignature to be provided to the payments contract. The data that makes paymentId is available off chain.  However, we also agreed with your point and decided that itll be nicer to move to a pattern where the seller signature is much closer to the others, so that the payments contract can verify the sellers intention pre-digest.  Thats why the PR intentionally provides an interface for verifySellerSignature where future upgrades of the verification contract (via the setEIP712 method) can include implementations where the verification of the sellerSig makes use of the entire BuyNow/Auction input struct, as suggested. (note that verifySellerSignature already takes as inputs the entire bidInput/buynowInput struct).  Since changing the L2 current signature will take time (we first need to fill in details such as the not 1-to-1 mapping, and upgrades require coordination with nodes, etc.), we plan to do it carefully, and incorporate the suggestion using the setEIP712 method in due time.  Low Severity", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#seller\u2019s-signature-not-required", "labels": ["OpenZeppelin"]}, {"title": "Events lack previous values", "body": "There are a couple instances of events which are emitted when the state of the contract is changed. Among these events, some only record the new value and omit recording the previous value.  Here are instances of this issue:  event EIP712  event PaymentWindow  event OnlyUserCanWithdraw  event DefaultFeesCollector  event UniverseFeesCollector  event DefaultOperator  event UniverseOperator  event DefaultAuctionConfig  event UniverseAuctionConfig  When using events to record state changes, it is recommended to record the previous value as well to document the entirety of the change. Consider including the previous state to any event that changes the state of the contract.  Update: Fixed with commit 6e02cc3 of PR#14.", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#events-lack-previous-values", "labels": ["OpenZeppelin"]}, {"title": "Loose restriction on fees", "body": "Currently, fees on buys and won auctions are not restricted and can be arbitrarily set for up to 100% via the assertBidInputsOK function in the BuyNowBase and AuctionBase contracts. Such feeBPS value is given through the input data that is signed by the operator.  Despite the trust assumption towards the operator, consider limiting the fee to a lower percentage or setting it on a contract level similar to the _paymentWindow. By doing so it is less likely that the seller gets less funds than intended due to an unexpectedly high fee.  Update: Fixed with commit bfa52af of PR#13.  Withdraw with finalBalance adds unnecessary complexity  BuyNowBase contract, the  _withdrawAmount function takes three arguments: The  Consider updating the balance by subtracting the withdrawn amount like _balanceOf[recipient] -= amount; in order to simplify the function.  Update: Fixed with commit d9bd95a of PR#12.  _acceptedCurrency could be misleading  Due to the support of ERC20s and blockchain native currencies, payments are settled through the currency indicated by the _acceptedCurrency variable that is set during deployment in the BuyNowBase constructor.  Since this variable is passed in rather than obtained via calling the name or symbol functions of the ERC20s, it is possible to have a different underlying currency than the one claimed to be supported, possibly resulting in an uncareful user accidentally paying an unexpected price.  Consider implementing the _acceptedCurrency through the symbol or name view function of the underlying ERC20 contract with a fallback to the native currency, as well as maintaining a manual method for cases of ERC20s that do not support those functions.  Update: Fixed with commit bd26283 of PR#17.  Gas optimization  _processBid function of the  AuctionBase contract, the  assertBidInputsOk function, where the inputs are sent via  IAuctionBase interface.  Consider changing both locations from memory to calldata to save gas.  In the assertBidInputsOk function of the AuctionBase contract, the bidInput requirements are checked. These checks include, whether the bidInput.deadline is met and if the bidInput.seller should be registered. Further checks are based on the state of a payment that is fetched from the state of the blockchain.  Consider moving line 229, to line 240 to save some gas getting the payment state if one of the two mentioned checks fail.  Update: Fixed with commit 00705cc of PR#11.  Inaccurate revert string  The withdrawTo function will revert with the message tx sender not authorized to withdraw on recipients behalf in the case that the given recipient is set to false in the onlyUserCanWithdraw mapping.  This function should not revert if the passed in recipient address is the same as the address calling the function.  Consider updating the logic to never revert when a user attempts to withdraw their own funds with the withdrawTo function.  Update: Fixed with commit b5db284 of PR#10.  Redundant check of unused and signed data  assertBidInputsOk function of the  AuctionBase contract, incoming bid data is checked and verified based on the state of the auction. In the case of  Both checks are redundant for two reasons:  The provided call values bidInput.feeBPS and bidInput.endsAt are not being used.  The operator signed these values so they are expected to match. This is contradictory and undermines the given strong trust assumption.  The checks are for user experience only, mainly to guarantee on a contract level that the user does not provide different values than the initial data. This could lead to a user paying a different fee than expected.  Consider moving these checks off-chain to save some gas and simplify the code.  Update: Fixed with commit 715f28a of PR#9.  Notes & Additional Information  Inconsistent buyer terminology  Throughout the codebase, there are two terms for the user who wants to acquire an asset: buyer and payer.  Consider sticking to the more frequent term buyer to be more explicit and precise about the involved roles.  Update: Fixed with commit 345c3c9 of PR#7.  Mismatch between documentation and implementation  In the AuctionBase contract, the _processBid function is documented to take parameter bidInput first and operator second, while the parameters are ordered the other way around in the actual function.  Consider swapping the order of the parameters in the documentation to match the implementation.  Update: Fixed with commit f6a2da5 of PR#5.  Revert strings lack explicitness  Throughout the codebase, the revert strings could be more explicit by following the pattern of \"<Contract-name>::<function-name>: <message>.  Consider updating the revert strings to know exactly where a transaction fails and ease debugging.  Update: Fixed with commit 9e604c1 of PR#4.  Typographical errors  During the audit of the codebase, some typographical errors were identified. For instance:  msg.sender must the the recipient should be msg.sender must be the recipient in lines 209 a", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#loose-restriction-on-fees", "labels": ["OpenZeppelin"]}, {"title": "Withdraw with finalBalance adds unnecessary complexity", "body": "Withdraw with finalBalance adds unnecessary complexity", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#withdraw-with-finalbalance-adds-unnecessary-complexity", "labels": ["OpenZeppelin"]}, {"title": "_acceptedCurrency could be misleading", "body": "_acceptedCurrency could be misleading", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#_acceptedcurrency-could-be-misleading", "labels": ["OpenZeppelin"]}, {"title": "Gas optimization", "body": "_processBid function of the  AuctionBase contract, the  assertBidInputsOk function, where the inputs are sent via  IAuctionBase interface.  Consider changing both locations from memory to calldata to save gas.  In the assertBidInputsOk function of the AuctionBase contract, the bidInput requirements are checked. These checks include, whether the bidInput.deadline is met and if the bidInput.seller should be registered. Further checks are based on the state of a payment that is fetched from the state of the blockchain.  Consider moving line 229, to line 240 to save some gas getting the payment state if one of the two mentioned checks fail.  Update: Fixed with commit 00705cc of PR#11.", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#gas-optimization", "labels": ["OpenZeppelin"]}, {"title": "Inaccurate revert string", "body": "The withdrawTo function will revert with the message tx sender not authorized to withdraw on recipients behalf in the case that the given recipient is set to false in the onlyUserCanWithdraw mapping.  This function should not revert if the passed in recipient address is the same as the address calling the function.  Consider updating the logic to never revert when a user attempts to withdraw their own funds with the withdrawTo function.  Update: Fixed with commit b5db284 of PR#10.", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#inaccurate-revert-string", "labels": ["OpenZeppelin"]}, {"title": "Redundant check of unused and signed data", "body": "assertBidInputsOk function of the  AuctionBase contract, incoming bid data is checked and verified based on the state of the auction. In the case of  Both checks are redundant for two reasons:  The provided call values bidInput.feeBPS and bidInput.endsAt are not being used.  The operator signed these values so they are expected to match. This is contradictory and undermines the given strong trust assumption.  The checks are for user experience only, mainly to guarantee on a contract level that the user does not provide different values than the initial data. This could lead to a user paying a different fee than expected.  Consider moving these checks off-chain to save some gas and simplify the code.  Update: Fixed with commit 715f28a of PR#9.  Notes & Additional Information  Inconsistent buyer terminology  Throughout the codebase, there are two terms for the user who wants to acquire an asset: buyer and payer.  Consider sticking to the more frequent term buyer to be more explicit and precise about the involved roles.  Update: Fixed with commit 345c3c9 of PR#7.  Mismatch between documentation and implementation  In the AuctionBase contract, the _processBid function is documented to take parameter bidInput first and operator second, while the parameters are ordered the other way around in the actual function.  Consider swapping the order of the parameters in the documentation to match the implementation.  Update: Fixed with commit f6a2da5 of PR#5.  Revert strings lack explicitness  Throughout the codebase, the revert strings could be more explicit by following the pattern of \"<Contract-name>::<function-name>: <message>.  Consider updating the revert strings to know exactly where a transaction fails and ease debugging.  Update: Fixed with commit 9e604c1 of PR#4.  Typographical errors  During the audit of the codebase, some typographical errors were identified. For instance:  msg.sender must the the recipient should be msg.sender must be the recipient in lines 209 and 234 of IBuyNowBase.  curretEndsAt should be currentEndsAt in line 173 of AuctionBase.  exisiting should be existing in line 40 and 57 of IAuctionERC20.  While the funds provided can by less than the bid amount should be While the funds provided can be less than the bid amount in line 46 of AuctionNative.  Consider correcting above errors and any other typographical errors throughout the codebase to guarantee explicitness and correctness in the documentation.  Update: Fixed with commit dab036d of PR#3 and commit 0543d30 of PR#19.  Unintuitive naming of withdrawTo  The withdrawTo function of the BuyNowBase contract enables users to withdraw funds of another user on their behalf. For example, user A calls the contract so the funds of user B get withdrawn to user B.  Unfortunately, the naming of withdrawTo is rather unintuitive as it suggests that the funds are withdrawn from user A to user B, which could lead to confusion and unexpected reverts.  Consider renaming the function to relayedWithdraw or withdrawOnBehalfOf to better match the naming with the implementation.  Update: Fixed with commit 56b6bb0 of PR#2.  Conclusion  The code of the Freeverse team is clean, thus no major issues were found. The use of simple and self contained functions and contracts really contributed to this outcome. We found some lower severity issues and suggested some best practices that could further contribute to the overall health of the codebase. We also communicated some architectural concerns, which were acknowledged, but unchanged. We enjoyed working with Freeverse as they provided thorough explanations for any questions that we had.  Appendix  Architectural Recommendation  The current design of the payments contracts plans on having one AuctionERC20 (including BuyNowERC20) contract per supported currency. These contracts allow the contract owner to set universe specific operators and auction configurations. This managing capability is fully coupled to that contract, so as soon as a new currency is supported, the whole setup of a universe would have to be reapplied to the new contract. While the design is simple in favor of readability and security, it does not scale very well.  It was suggested to decouple the managing functionality from the contract or to introduce some logic that supports multiple currencies from one contract. The concern was acknowledged by the Freeverse team.  Monitoring Recommendation  Due to the strong trust assumption towards the contract owner and operator role, we recommend implementing monitoring for all sensitive actions. For instance, to look out for suspicious inputs of the following functions:  BuyNowERC20.buyNow  BuyNowERC20.relayedBuyNow  BuyNowNative.buyNow  AuctionERC20.bid  AuctionERC20.relayedBid  AuctionNative.bid  Suspicious activity could include an unusually high amount or feeBPS or repetitively selling to the same seller. The following functions are also dependent on operator signatures:  BuyNowBase.finalize  BuyNowBase.fin", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#redundant-check-of-unused-and-signed-data", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent buyer terminology", "body": "Inconsistent buyer terminology", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#inconsistent-buyer-terminology", "labels": ["OpenZeppelin"]}, {"title": "Mismatch between documentation and implementation", "body": "In the AuctionBase contract, the _processBid function is documented to take parameter bidInput first and operator second, while the parameters are ordered the other way around in the actual function.  Consider swapping the order of the parameters in the documentation to match the implementation.  Update: Fixed with commit f6a2da5 of PR#5.", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#mismatch-between-documentation-and-implementation", "labels": ["OpenZeppelin"]}, {"title": "Revert strings lack explicitness", "body": "Throughout the codebase, the revert strings could be more explicit by following the pattern of \"<Contract-name>::<function-name>: <message>.  Consider updating the revert strings to know exactly where a transaction fails and ease debugging.  Update: Fixed with commit 9e604c1 of PR#4.", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#revert-strings-lack-explicitness", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "During the audit of the codebase, some typographical errors were identified. For instance:  msg.sender must the the recipient should be msg.sender must be the recipient in lines 209 and 234 of IBuyNowBase.  curretEndsAt should be currentEndsAt in line 173 of AuctionBase.  exisiting should be existing in line 40 and 57 of IAuctionERC20.  While the funds provided can by less than the bid amount should be While the funds provided can be less than the bid amount in line 46 of AuctionNative.  Consider correcting above errors and any other typographical errors throughout the codebase to guarantee explicitness and correctness in the documentation.  Update: Fixed with commit dab036d of PR#3 and commit 0543d30 of PR#19.  Unintuitive naming of withdrawTo  The withdrawTo function of the BuyNowBase contract enables users to withdraw funds of another user on their behalf. For example, user A calls the contract so the funds of user B get withdrawn to user B.  Unfortunately, the naming of withdrawTo is rather unintuitive as it suggests that the funds are withdrawn from user A to user B, which could lead to confusion and unexpected reverts.  Consider renaming the function to relayedWithdraw or withdrawOnBehalfOf to better match the naming with the implementation.  Update: Fixed with commit 56b6bb0 of PR#2.  Conclusion  The code of the Freeverse team is clean, thus no major issues were found. The use of simple and self contained functions and contracts really contributed to this outcome. We found some lower severity issues and suggested some best practices that could further contribute to the overall health of the codebase. We also communicated some architectural concerns, which were acknowledged, but unchanged. We enjoyed working with Freeverse as they provided thorough explanations for any questions that we had.  Appendix  Architectural Recommendation  The current design of the payments contracts plans on having one AuctionERC20 (including BuyNowERC20) contract per supported currency. These contracts allow the contract owner to set universe specific operators and auction configurations. This managing capability is fully coupled to that contract, so as soon as a new currency is supported, the whole setup of a universe would have to be reapplied to the new contract. While the design is simple in favor of readability and security, it does not scale very well.  It was suggested to decouple the managing functionality from the contract or to introduce some logic that supports multiple currencies from one contract. The concern was acknowledged by the Freeverse team.  Monitoring Recommendation  Due to the strong trust assumption towards the contract owner and operator role, we recommend implementing monitoring for all sensitive actions. For instance, to look out for suspicious inputs of the following functions:  BuyNowERC20.buyNow  BuyNowERC20.relayedBuyNow  BuyNowNative.buyNow  AuctionERC20.bid  AuctionERC20.relayedBid  AuctionNative.bid  Suspicious activity could include an unusually high amount or feeBPS or repetitively selling to the same seller. The following functions are also dependent on operator signatures:  BuyNowBase.finalize  BuyNowBase.finalizeAndWithdraw  Their transferResult input could be manipulated by the operator to maliciously claim that an asset was successfully traded when it wasnt. Thus, the input could be checked against off-chain data to verify the correctness of the provided data. Any suspicious activity could be an indication that the operator might be compromised. Further, all functions that are maintainable by the contract owner should be monitored, to also keep track of operator and configuration changes. The affected functions are listed under Trust Assumptions.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "Unintuitive naming of withdrawTo", "body": "Unintuitive naming of withdrawTo", "html_url": "https://blog.openzeppelin.com/freeverse-crypto-payments-audit#unintuitive-naming-of-withdrawto", "labels": ["OpenZeppelin"]}, {"title": "Anyone can prevent stakers from getting their rewards", "body": "The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStaked was already non-zero. This would cause _updateReward to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any stakedToken at all were actively being staked. Any stakedToken already in the contract would be locked.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input.  Update: Fixed as of commit 9652a990a14d00e4d47f9e4f3df2c422a6881d4a in pull request #6 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Low Severity  Incomplete and unindexed events  Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.  Events lacking indexed parameters include:  The TokenEnabledForStaking, RecoverErc20, Stake, Unstake, GetReward, and Exit events in the AcceleratingDistributor contract.  Event emissions which do not fully track state changes include:  The RecoverErc20 event does not emit the caller, which may be of interest to those interested in calls to the recoverErc20 function where the event is emitted.  The Stake, Unstake, and Exit events are emitted when a user calls the stake, unstake, or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services sea", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#anyone-can-prevent-stakers-from-getting-their-rewards", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0recoverErc20\u00a0function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the\u00a0AcceleratingDistributor\u00a0contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the\u00a0AcceleratingDistributor\u00a0contract to the owner of\u00a0AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are\u00a0stakedTokens that have already been initialized in the system.", "body": "The\u00a0recoverErc20\u00a0function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the\u00a0AcceleratingDistributor\u00a0contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the\u00a0AcceleratingDistributor\u00a0contract to the owner of\u00a0AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are\u00a0stakedTokens that have already been initialized in the system.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0recovererc20\u00a0function-is-meant-to-facilitate-the-recovery-of-any-erc20-tokens-that-may-be-mistakenly-sent-to-the\u00a0acceleratingdistributor\u00a0contract.-as-this-is-a-public-function-with-no-modifiers,-anyone-can-call-this-function-to-transfer-an-erc20-token-from-the\u00a0acceleratingdistributor\u00a0contract-to-the-owner-of\u00a0acceleratingdistributor.-the-only-erc20-tokens-that-are-explicitly-disallowed-from-being-recovered-are\u00a0stakedtokens-that-have-already-been-initialized-in-the-system.", "labels": ["OpenZeppelin"]}, {"title": "However, it is currently possible to recover the ERC20\u00a0rewardToken\u00a0using the\u00a0recoverErc20\u00a0function. Doing so would\u00a0transfer some specified\u00a0amount\u00a0of\u00a0rewardToken\u00a0from the\u00a0AcceleratingDistributor\u00a0contract to the contract\u2019s owner. This would, subsequently, prevent stakers from being able to access their rewards because\u00a0AcceleratingDistributor\u00a0could be left with an insufficient balance of\u00a0rewardTokens.", "body": "However, it is currently possible to recover the ERC20\u00a0rewardToken\u00a0using the\u00a0recoverErc20\u00a0function. Doing so would\u00a0transfer some specified\u00a0amount\u00a0of\u00a0rewardToken\u00a0from the\u00a0AcceleratingDistributor\u00a0contract to the contract\u2019s owner. This would, subsequently, prevent stakers from being able to access their rewards because\u00a0AcceleratingDistributor\u00a0could be left with an insufficient balance of\u00a0rewardTokens.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#however,-it-is-currently-possible-to-recover-the-erc20\u00a0rewardtoken\u00a0using-the\u00a0recovererc20\u00a0function.-doing-so-would\u00a0transfer-some-specified\u00a0amount\u00a0of\u00a0rewardtoken\u00a0from-the\u00a0acceleratingdistributor\u00a0contract-to-the-contract\u2019s-owner.-this-would,-subsequently,-prevent-stakers-from-being-able-to-access-their-rewards-because\u00a0acceleratingdistributor\u00a0could-be-left-with-an-insufficient-balance-of\u00a0rewardtokens.", "labels": ["OpenZeppelin"]}, {"title": "Even if the owner were to send\u00a0rewardTokens back to the\u00a0AcceleratingDistributor\u00a0contract, a malicious actor could immediately transfer all of the\u00a0rewardTokens\u00a0back to the owner. Redeployment would be necessary to fix the issue.", "body": "Even if the owner were to send\u00a0rewardTokens back to the\u00a0AcceleratingDistributor\u00a0contract, a malicious actor could immediately transfer all of the\u00a0rewardTokens\u00a0back to the owner. Redeployment would be necessary to fix the issue.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#even-if-the-owner-were-to-send\u00a0rewardtokens-back-to-the\u00a0acceleratingdistributor\u00a0contract,-a-malicious-actor-could-immediately-transfer-all-of-the\u00a0rewardtokens\u00a0back-to-the-owner.-redeployment-would-be-necessary-to-fix-the-issue.", "labels": ["OpenZeppelin"]}, {"title": "Consider disallowing recovery of the\u00a0rewardToken\u00a0within the\u00a0recoverErc20\u00a0function.", "body": "Consider disallowing recovery of the\u00a0rewardToken\u00a0within the\u00a0recoverErc20\u00a0function.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#consider-disallowing-recovery-of-the\u00a0rewardtoken\u00a0within-the\u00a0recovererc20\u00a0function.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0bcdabc06ca6d789b95c5b26d23f48dab8bfad277\u00a0in\u00a0pull request #5.", "body": "Update:\u00a0Fixed as of commit\u00a0bcdabc06ca6d789b95c5b26d23f48dab8bfad277\u00a0in\u00a0pull request #5.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a0bcdabc06ca6d789b95c5b26d23f48dab8bfad277\u00a0in\u00a0pull-request-#5.", "labels": ["OpenZeppelin"]}, {"title": "Medium Severity", "body": "Medium Severity", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#medium-severity", "labels": ["OpenZeppelin"]}, {"title": "Lack of input validation", "body": "The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStaked was already non-zero. This would cause _updateReward to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any stakedToken at all were actively being staked. Any stakedToken already in the contract would be locked.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input.  Update: Fixed as of commit 9652a990a14d00e4d47f9e4f3df2c422a6881d4a in pull request #6 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Low Severity  Incomplete and unindexed events  Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.  Events lacking indexed parameters include:  The TokenEnabledForStaking, RecoverErc20, Stake, Unstake, GetReward, and Exit events in the AcceleratingDistributor contract.  Event emissions which do not fully track state changes include:  The RecoverErc20 event does not emit the caller, which may be of interest to those interested in calls to the recoverErc20 function where the event is emitted.  The Stake, Unstake, and Exit events are emitted when a user calls the stake, unstake, or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.  Update: Fixed as of commit 71178ca0ce24633eb4644f64094f455862edf5e9 in pull request #7 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Recovery function is not robust  Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "The codebase generally lacks sufficient input validation.", "body": "The codebase generally lacks sufficient input validation.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-codebase-generally-lacks-sufficient-input-validation.", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0AcceleratingDistributor\u00a0contract, the\u00a0enableStaking\u00a0function allows the contract owner to configure several parameters associated with a\u00a0stakedToken. Several of these parameters have no input checking. Specifically:", "body": "In the\u00a0AcceleratingDistributor\u00a0contract, the\u00a0enableStaking\u00a0function allows the contract owner to configure several parameters associated with a\u00a0stakedToken. Several of these parameters have no input checking. Specifically:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#in-the\u00a0acceleratingdistributor\u00a0contract,-the\u00a0enablestaking\u00a0function-allows-the-contract-owner-to-configure-several-parameters-associated-with-a\u00a0stakedtoken.-several-of-these-parameters-have-no-input-checking.-specifically:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0maxMultiplier\u00a0parameter has no upper or lower bound.", "body": "The\u00a0maxMultiplier\u00a0parameter has no upper or lower bound.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0maxmultiplier\u00a0parameter-has-no-upper-or-lower-bound.", "labels": ["OpenZeppelin"]}, {"title": "It should be restricted to being larger than the \u201cbase multiplier\u201d of\u00a01e18, or else it can lead to users\u2019 staking rewards decreasing over time rather than increasing.", "body": "It should be restricted to being larger than the \u201cbase multiplier\u201d of\u00a01e18, or else it can lead to users\u2019 staking rewards decreasing over time rather than increasing.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#it-should-be-restricted-to-being-larger-than-the-\u201cbase-multiplier\u201d-of\u00a01e18,-or-else-it-can-lead-to-users\u2019-staking-rewards-decreasing-over-time-rather-than-increasing.", "labels": ["OpenZeppelin"]}, {"title": "It should also have an upper bound, because if it were to be set to some very large value it could cause the\u00a0getUserRewardMultiplier\u00a0function to\u00a0revert on overflow. This could, in turn, cause calls to the\u00a0getOutstandingRewards\u00a0and\u00a0_updateReward\u00a0functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the\u00a0enableStaking\u00a0function to update to a more reasonable\u00a0maxMultiplier.", "body": "It should also have an upper bound, because if it were to be set to some very large value it could cause the\u00a0getUserRewardMultiplier\u00a0function to\u00a0revert on overflow. This could, in turn, cause calls to the\u00a0getOutstandingRewards\u00a0and\u00a0_updateReward\u00a0functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the\u00a0enableStaking\u00a0function to update to a more reasonable\u00a0maxMultiplier.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#it-should-also-have-an-upper-bound,-because-if-it-were-to-be-set-to-some-very-large-value-it-could-cause-the\u00a0getuserrewardmultiplier\u00a0function-to\u00a0revert-on-overflow.-this-could,-in-turn,-cause-calls-to-the\u00a0getoutstandingrewards\u00a0and\u00a0_updatereward\u00a0functions-to-revert.-this-would-interfere-with-the-normal-operation-of-the-system.-however,-it-could-be-fixed-by-the-contract-owner-using-the\u00a0enablestaking\u00a0function-to-update-to-a-more-reasonable\u00a0maxmultiplier.", "labels": ["OpenZeppelin"]}, {"title": "Similarly, the\u00a0secondsToMaxMultiplier\u00a0parameter has no lower bound. If allowed to be zero then\u00a0getUserRewardMultiplier\u00a0could revert due to\u00a0division by zero. This could cause the\u00a0getOutstandingRewards\u00a0and\u00a0_updateReward\u00a0functions to revert as outlined above. The contract owner could put the system back into a stable state by making\u00a0secondsToMaxMultiplier\u00a0non-zero.", "body": "Similarly, the\u00a0secondsToMaxMultiplier\u00a0parameter has no lower bound. If allowed to be zero then\u00a0getUserRewardMultiplier\u00a0could revert due to\u00a0division by zero. This could cause the\u00a0getOutstandingRewards\u00a0and\u00a0_updateReward\u00a0functions to revert as outlined above. The contract owner could put the system back into a stable state by making\u00a0secondsToMaxMultiplier\u00a0non-zero.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#similarly,-the\u00a0secondstomaxmultiplier\u00a0parameter-has-no-lower-bound.-if-allowed-to-be-zero-then\u00a0getuserrewardmultiplier\u00a0could-revert-due-to\u00a0division-by-zero.-this-could-cause-the\u00a0getoutstandingrewards\u00a0and\u00a0_updatereward\u00a0functions-to-revert-as-outlined-above.-the-contract-owner-could-put-the-system-back-into-a-stable-state-by-making\u00a0secondstomaxmultiplier\u00a0non-zero.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0baseEmissionRate\u00a0parameter has no upper bound. If set too high then, as soon as\u00a0stakingToken.cumulativeStaked\u00a0were some non-zero value, the\u00a0baseRewardPerToken\u00a0function would always revert\u00a0due to an overflow. Importantly, this value could be set to a system destabilizing value even when\u00a0stakingToken.cumulativeStaked\u00a0was already non-zero. This would cause\u00a0_updateReward\u00a0to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any\u00a0stakedToken\u00a0at all were actively being staked. Any\u00a0stakedToken\u00a0already in the contract would be locked.", "body": "The\u00a0baseEmissionRate\u00a0parameter has no upper bound. If set too high then, as soon as\u00a0stakingToken.cumulativeStaked\u00a0were some non-zero value, the\u00a0baseRewardPerToken\u00a0function would always revert\u00a0due to an overflow. Importantly, this value could be set to a system destabilizing value even when\u00a0stakingToken.cumulativeStaked\u00a0was already non-zero. This would cause\u00a0_updateReward\u00a0to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any\u00a0stakedToken\u00a0at all were actively being staked. Any\u00a0stakedToken\u00a0already in the contract would be locked.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0baseemissionrate\u00a0parameter-has-no-upper-bound.-if-set-too-high-then,-as-soon-as\u00a0stakingtoken.cumulativestaked\u00a0were-some-non-zero-value,-the\u00a0baserewardpertoken\u00a0function-would-always-revert\u00a0due-to-an-overflow.-importantly,-this-value-could-be-set-to-a-system-destabilizing-value-even-when\u00a0stakingtoken.cumulativestaked\u00a0was-already-non-zero.-this-would-cause\u00a0_updatereward\u00a0to-revert-even-in-the-case-that-the-provided-account-was-the-zero-address.-this-detail-would-prevent-the-contract-owner-from-fixing-the-situation-without-a-complete-redeployment-of-the-system-if-any\u00a0stakedtoken\u00a0at-all-were-actively-being-staked.-any\u00a0stakedtoken\u00a0already-in-the-contract-would-be-locked.", "labels": ["OpenZeppelin"]}, {"title": "To avoid errors and unexpected system behavior, consider implementing\u00a0require\u00a0statements to validate\u00a0all\u00a0user-controlled input.", "body": "To avoid errors and unexpected system behavior, consider implementing\u00a0require\u00a0statements to validate\u00a0all\u00a0user-controlled input.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#to-avoid-errors-and-unexpected-system-behavior,-consider-implementing\u00a0require\u00a0statements-to-validate\u00a0all\u00a0user-controlled-input.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a09652a990a14d00e4d47f9e4f3df2c422a6881d4a\u00a0in\u00a0pull request #6\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "body": "Update:\u00a0Fixed as of commit\u00a09652a990a14d00e4d47f9e4f3df2c422a6881d4a\u00a0in\u00a0pull request #6\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a09652a990a14d00e4d47f9e4f3df2c422a6881d4a\u00a0in\u00a0pull-request-#6\u00a0and-commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull-request-#20.", "labels": ["OpenZeppelin"]}, {"title": "Low Severity", "body": "Low Severity", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#low-severity", "labels": ["OpenZeppelin"]}, {"title": "Incomplete and unindexed events", "body": "Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.  Events lacking indexed parameters include:  The TokenEnabledForStaking, RecoverErc20, Stake, Unstake, GetReward, and Exit events in the AcceleratingDistributor contract.  Event emissions which do not fully track state changes include:  The RecoverErc20 event does not emit the caller, which may be of interest to those interested in calls to the recoverErc20 function where the event is emitted.  The Stake, Unstake, and Exit events are emitted when a user calls the stake, unstake, or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.  Update: Fixed as of commit 71178ca0ce24633eb4644f64094f455862edf5e9 in pull request #7 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Recovery function is not robust  Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the cumulativeStaked amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.  Update: Fixed as of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull request #8.  Unhandled failures in token interactions  There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens ", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#incomplete-and-unindexed-events", "labels": ["OpenZeppelin"]}, {"title": "Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.", "body": "Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#throughout-the-codebase,-events-are-used-to-signify-when-changes-are-made-to-the-state-of-the-system.-however,-all-of-the-existing-events-lack-indexed-parameters.-some-events-are-missing-parameters-necessary-to-fully-indicate-how-the-state-was-modified-during-a-call.", "labels": ["OpenZeppelin"]}, {"title": "Events lacking indexed parameters include:", "body": "Events lacking indexed parameters include:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#events-lacking-indexed-parameters-include:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0TokenEnabledForStaking,\u00a0RecoverErc20,\u00a0Stake,\u00a0Unstake,\u00a0GetReward, and\u00a0Exit\u00a0events in the\u00a0AcceleratingDistributor\u00a0contract.", "body": "The\u00a0TokenEnabledForStaking,\u00a0RecoverErc20,\u00a0Stake,\u00a0Unstake,\u00a0GetReward, and\u00a0Exit\u00a0events in the\u00a0AcceleratingDistributor\u00a0contract.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0tokenenabledforstaking,\u00a0recovererc20,\u00a0stake,\u00a0unstake,\u00a0getreward,-and\u00a0exit\u00a0events-in-the\u00a0acceleratingdistributor\u00a0contract.", "labels": ["OpenZeppelin"]}, {"title": "Event emissions which do not fully track state changes include:", "body": "Event emissions which do not fully track state changes include:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#event-emissions-which-do-not-fully-track-state-changes-include:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0RecoverErc20\u00a0event does not emit the caller, which may be of interest to those interested in calls to the\u00a0recoverErc20\u00a0function where the event is emitted.", "body": "The\u00a0RecoverErc20\u00a0event does not emit the caller, which may be of interest to those interested in calls to the\u00a0recoverErc20\u00a0function where the event is emitted.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0recovererc20\u00a0event-does-not-emit-the-caller,-which-may-be-of-interest-to-those-interested-in-calls-to-the\u00a0recovererc20\u00a0function-where-the-event-is-emitted.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0Stake,\u00a0Unstake, and\u00a0Exit\u00a0events are emitted when a user calls the\u00a0stake,\u00a0unstake, or\u00a0exit\u00a0functions, respectively. These functions update the\u00a0stakedToken\u2018s\u00a0cumulativeStaked\u00a0value, but this is not emitted in the events. Similarly, these functions \u2013 as well as the\u00a0getReward\u00a0function \u2013 update a\u00a0stakedToken\u2018s\u00a0lastUpdateTime\u00a0and\u00a0rewardPerTokenStored\u00a0as well as a\u00a0userDeposit\u2018s\u00a0rewardsOutstanding\u00a0and\u00a0rewardsPaidPerToken\u00a0values, but these state changes are not captured by any associated event emissions.", "body": "The\u00a0Stake,\u00a0Unstake, and\u00a0Exit\u00a0events are emitted when a user calls the\u00a0stake,\u00a0unstake, or\u00a0exit\u00a0functions, respectively. These functions update the\u00a0stakedToken\u2018s\u00a0cumulativeStaked\u00a0value, but this is not emitted in the events. Similarly, these functions \u2013 as well as the\u00a0getReward\u00a0function \u2013 update a\u00a0stakedToken\u2018s\u00a0lastUpdateTime\u00a0and\u00a0rewardPerTokenStored\u00a0as well as a\u00a0userDeposit\u2018s\u00a0rewardsOutstanding\u00a0and\u00a0rewardsPaidPerToken\u00a0values, but these state changes are not captured by any associated event emissions.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0stake,\u00a0unstake,-and\u00a0exit\u00a0events-are-emitted-when-a-user-calls-the\u00a0stake,\u00a0unstake,-or\u00a0exit\u00a0functions,-respectively.-these-functions-update-the\u00a0stakedtoken\u2018s\u00a0cumulativestaked\u00a0value,-but-this-is-not-emitted-in-the-events.-similarly,-these-functions-\u2013-as-well-as-the\u00a0getreward\u00a0function-\u2013-update-a\u00a0stakedtoken\u2018s\u00a0lastupdatetime\u00a0and\u00a0rewardpertokenstored\u00a0as-well-as-a\u00a0userdeposit\u2018s\u00a0rewardsoutstanding\u00a0and\u00a0rewardspaidpertoken\u00a0values,-but-these-state-changes-are-not-captured-by-any-associated-event-emissions.", "labels": ["OpenZeppelin"]}, {"title": "Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.", "body": "Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#consider-completely-indexing-existing-events,-adding-new-indexed-parameters-where-they-are-lacking,-and/or-adding-new-events-to-facilitate-off-chain-services-searching-and-filtering-for-events.-consider-emitting-all-events-in-such-a-complete-manner-that-they-could-be-used-to-rebuild-the-state-of-the-contract.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a071178ca0ce24633eb4644f64094f455862edf5e9\u00a0in\u00a0pull request #7\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "body": "Update:\u00a0Fixed as of commit\u00a071178ca0ce24633eb4644f64094f455862edf5e9\u00a0in\u00a0pull request #7\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a071178ca0ce24633eb4644f64094f455862edf5e9\u00a0in\u00a0pull-request-#7\u00a0and-commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull-request-#20.", "labels": ["OpenZeppelin"]}, {"title": "Recovery function is not robust", "body": "Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the cumulativeStaked amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.  Update: Fixed as of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull request #8.  Unhandled failures in token interactions  There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor con", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#recovery-function-is-not-robust", "labels": ["OpenZeppelin"]}, {"title": "Within the\u00a0AcceleratingDistributor\u00a0contract, the\u00a0recoverErc20\u00a0function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.", "body": "Within the\u00a0AcceleratingDistributor\u00a0contract, the\u00a0recoverErc20\u00a0function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#within-the\u00a0acceleratingdistributor\u00a0contract,-the\u00a0recovererc20\u00a0function-is-intended-to-facilitate-the-recovery-of-tokens-which-may-have-been-sent-to-the-contract-in-error.-without-such-a-function,-tokens-sent-to-the-contract-in-error-would-generally-become-completely-inaccessible.", "labels": ["OpenZeppelin"]}, {"title": "However, the current implementation of the recovery function is less robust than may be desirable.", "body": "However, the current implementation of the recovery function is less robust than may be desirable.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#however,-the-current-implementation-of-the-recovery-function-is-less-robust-than-may-be-desirable.", "labels": ["OpenZeppelin"]}, {"title": "For instance, all recovered tokens are hard-coded to be sent to the contract\u2019s owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.", "body": "For instance, all recovered tokens are hard-coded to be sent to the contract\u2019s owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#for-instance,-all-recovered-tokens-are-hard-coded-to-be-sent-to-the-contract\u2019s-owner.-but-the-contract-also-has-the-ability-to-relinquish-ownership,-whereby-the-owner-is-set-to-the-zero-address.-after-ownership-is-relinquished-then,-the-recovery-function-can-no-longer-perform-its-intended-purpose.", "labels": ["OpenZeppelin"]}, {"title": "Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that\u00a0are or were\u00a0eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.", "body": "Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that\u00a0are or were\u00a0eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#additionally,-any-tokens-that-have-ever-been-enabled-for-staking-are-not-recoverable.-unfortunately,-it-is-precisely-tokens-that\u00a0are-or-were\u00a0eligible-to-be-staked-that-are-most-likely-to-be-sent-to-the-contract-in-error,-especially-by-users-trying-to-stake-with-the-protocol-in-an-incorrect-manner.", "labels": ["OpenZeppelin"]}, {"title": "To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the\u00a0cumulativeStaked\u00a0amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.", "body": "To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the\u00a0cumulativeStaked\u00a0amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#to-better-separate-concerns,-consider-having-tokens-recovered-to-a-recovery-address-that-is-independent-of-the-owner.-alternatively,-consider-explicitly-documenting-the-fact-that-token-recoverability-is-dependent-on-an-owner-address-that-can-be-controlled.-also,-since-the\u00a0cumulativestaked\u00a0amount-for-every-staking-token-is-already-accounted-for,-consider-using-it-to-allow-for-the-recovery-of-staking-tokens-which-were-sent-in-error-and-are,-as-a-result,-unaccounted-for.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a00cc740ecc30694077d44674d80b48c4e6d75ce31\u00a0in\u00a0pull request #8.", "body": "Update:\u00a0Fixed as of commit\u00a00cc740ecc30694077d44674d80b48c4e6d75ce31\u00a0in\u00a0pull request #8.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a00cc740ecc30694077d44674d80b48c4e6d75ce31\u00a0in\u00a0pull-request-#8.", "labels": ["OpenZeppelin"]}, {"title": "Unhandled failures in token interactions", "body": "There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to re", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#unhandled-failures-in-token-interactions", "labels": ["OpenZeppelin"]}, {"title": "There are ERC20\u00a0transfer\u00a0operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.", "body": "There are ERC20\u00a0transfer\u00a0operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#there-are-erc20\u00a0transfer\u00a0operations,-executed-over-potentially-untrusted-erc20-tokens,-which-are-not-correctly-wrapped-to-ensure-that-they-are-always-safe-and-behave-as-expected.", "labels": ["OpenZeppelin"]}, {"title": "Specifically, for the\u00a0transfer\u00a0on\u00a0line 177\u00a0of the\u00a0AcceleratingDistributor\u00a0contract, the current implementation does not handle a case where the call to\u00a0transfer\u00a0fails by returning a\u00a0false\u00a0boolean value (rather than reverting the transaction).", "body": "Specifically, for the\u00a0transfer\u00a0on\u00a0line 177\u00a0of the\u00a0AcceleratingDistributor\u00a0contract, the current implementation does not handle a case where the call to\u00a0transfer\u00a0fails by returning a\u00a0false\u00a0boolean value (rather than reverting the transaction).", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#specifically,-for-the\u00a0transfer\u00a0on\u00a0line-177\u00a0of-the\u00a0acceleratingdistributor\u00a0contract,-the-current-implementation-does-not-handle-a-case-where-the-call-to\u00a0transfer\u00a0fails-by-returning-a\u00a0false\u00a0boolean-value-(rather-than-reverting-the-transaction).", "labels": ["OpenZeppelin"]}, {"title": "For more predictable and consistent behavior, consider using the OpenZeppelin\u00a0SafeERC20\u00a0library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return\u00a0false\u00a0on failure.", "body": "For more predictable and consistent behavior, consider using the OpenZeppelin\u00a0SafeERC20\u00a0library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return\u00a0false\u00a0on failure.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#for-more-predictable-and-consistent-behavior,-consider-using-the-openzeppelin\u00a0safeerc20\u00a0library-which-is-used-for-other-transfers-throughout-the-codebase,-as-it-implements-wrappers-around-erc20-operations-that-return\u00a0false\u00a0on-failure.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a03722baff5cf0ee936b43ecf07ae47b44b3f5688d\u00a0in\u00a0pull request #9.", "body": "Update:\u00a0Fixed as of commit\u00a03722baff5cf0ee936b43ecf07ae47b44b3f5688d\u00a0in\u00a0pull request #9.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a03722baff5cf0ee936b43ecf07ae47b44b3f5688d\u00a0in\u00a0pull-request-#9.", "labels": ["OpenZeppelin"]}, {"title": "Unused inherited contracts", "body": "The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentati", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#unused-inherited-contracts", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0AcceleratingDistributor\u00a0contract\u00a0imports\u00a0and\u00a0inherits from\u00a0the\u00a0Pausable\u00a0contract but does not use any of the inherited functionality.", "body": "The\u00a0AcceleratingDistributor\u00a0contract\u00a0imports\u00a0and\u00a0inherits from\u00a0the\u00a0Pausable\u00a0contract but does not use any of the inherited functionality.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0acceleratingdistributor\u00a0contract\u00a0imports\u00a0and\u00a0inherits-from\u00a0the\u00a0pausable\u00a0contract-but-does-not-use-any-of-the-inherited-functionality.", "labels": ["OpenZeppelin"]}, {"title": "Consider either using the inherited\u00a0Pausable\u00a0functionality or else not inheriting from the\u00a0Pausable\u00a0contract.", "body": "Consider either using the inherited\u00a0Pausable\u00a0functionality or else not inheriting from the\u00a0Pausable\u00a0contract.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#consider-either-using-the-inherited\u00a0pausable\u00a0functionality-or-else-not-inheriting-from-the\u00a0pausable\u00a0contract.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0b511e0d96a18d1087da60e2e02ee18120eb0a291\u00a0in\u00a0pull request #10.", "body": "Update:\u00a0Fixed as of commit\u00a0b511e0d96a18d1087da60e2e02ee18120eb0a291\u00a0in\u00a0pull request #10.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a0b511e0d96a18d1087da60e2e02ee18120eb0a291\u00a0in\u00a0pull-request-#10.", "labels": ["OpenZeppelin"]}, {"title": "Notes & Additional Information", "body": "Notes & Additional Information", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#notes-&-additional-information", "labels": ["OpenZeppelin"]}, {"title": "Visibility unnecessarily permissive", "body": "mint and  burn functions of the  enableStaking,  stake,  getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent a", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#visibility-unnecessarily-permissive", "labels": ["OpenZeppelin"]}, {"title": "mint\u00a0and", "body": "mint\u00a0and", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#mint\u00a0and", "labels": ["OpenZeppelin"]}, {"title": "burn\u00a0functions of the", "body": "burn\u00a0functions of the", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#burn\u00a0functions-of-the", "labels": ["OpenZeppelin"]}, {"title": "enableStaking,", "body": "enableStaking,", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#enablestaking,", "labels": ["OpenZeppelin"]}, {"title": "stake,", "body": "and Exit events are emitted when a user calls the  un or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new indexed parameters where they are lacking, and/or adding new events to facilitate off-chain services searching and filtering for events. Consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract.  Update: Fixed as of commit 71178ca0ce24633eb4644f64094f455862edf5e9 in pull request #7 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Recovery function is not robust  Within the AcceleratingDistributor contract, the recoverErc20 function is intended to facilitate the recovery of tokens which may have been sent to the contract in error. Without such a function, tokens sent to the contract in error would generally become completely inaccessible.  However, the current implementation of the recovery function is less robust than may be desirable.  For instance, all recovered tokens are hard-coded to be sent to the contracts owner. But the contract also has the ability to relinquish ownership, whereby the owner is set to the zero address. After ownership is relinquished then, the recovery function can no longer perform its intended purpose.  Additionally, any tokens that have ever been enabled for staking are not recoverable. Unfortunately, it is precisely tokens that are or were eligible to be staked that are most likely to be sent to the contract in error, especially by users trying to stake with the protocol in an incorrect manner.  To better separate concerns, consider having tokens recovered to a recovery address that is independent of the owner. Alternatively, consider explicitly documenting the fact that token recoverability is dependent on an owner address that can be controlled. Also, since the cumulativeStaked amount for every staking token is already accounted for, consider using it to allow for the recovery of staking tokens which were sent in error and are, as a result, unaccounted for.  Update: Fixed as of commit 0cc740ecc30694077d44674d80b48c4e6d75ce31 in pull request #8.  Unhandled failures in token interactions  There are ERC20 transfer operations, executed over potentially untrusted ERC20 tokens, which are not correctly wrapped to ensure that they are always safe and behave as expected.  Specifically, for the transfer on line 177 of the AcceleratingDistributor contract, the current implementation does not handle a case where the call to transfer fails by returning a false boolean value (rather than reverting the transaction).  For more predictable and consistent behavior, consider using the OpenZeppelin SafeERC20 library which is used for other transfers throughout the codebase, as it implements wrappers around ERC20 operations that return false on failure.  Update: Fixed as of commit 3722baff5cf0ee936b43ecf07ae47b44b3f5688d in pull request #9.  Unused inherited contracts  The AcceleratingDistributor contract imports and inherits from the Pausable contract but does not use any of the inherited functionality.  Consider either using the inherited Pausable functionality or else not inheriting from the Pausable contract.  Update: Fixed as of commit b511e0d96a18d1087da60e2e02ee18120eb0a291 in pull request #10.  Notes & Additional Information  Visibility unnecessarily permissive  mint and  burn functions of the  enableStaking,    getCumulativeStaked, and  getUserStake of the  Update: Fixed as of commit 0f027e6cb8ae146a755de3041172efc76bb87d5f in pull request #11 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  System is incompatible with non-standard ERC20 tokens  Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict su", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#stake,", "labels": ["OpenZeppelin"]}, {"title": "getCumulativeStaked, and", "body": "getCumulativeStaked, and", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#getcumulativestaked,-and", "labels": ["OpenZeppelin"]}, {"title": "getUserStake\u00a0of the", "body": "getUserStake\u00a0of the", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#getuserstake\u00a0of-the", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a00f027e6cb8ae146a755de3041172efc76bb87d5f\u00a0in\u00a0pull request #11\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "body": "Update:\u00a0Fixed as of commit\u00a00f027e6cb8ae146a755de3041172efc76bb87d5f\u00a0in\u00a0pull request #11\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a00f027e6cb8ae146a755de3041172efc76bb87d5f\u00a0in\u00a0pull-request-#11\u00a0and-commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull-request-#20.", "labels": ["OpenZeppelin"]}, {"title": "System is incompatible with non-standard ERC20 tokens", "body": "Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:  The systems internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as Tether (USDT) (the most widely known asset with this feature). This means that such tokens transfer and transferFrom functions could potentially fail to increase the recipients balance by the amount that is actually transferred.If AcceleratingDistributor allows staking of tokens charging such transfer fees, then stakers would receive more rewards than intended.  The recoverErc20 function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case the current restrictions may not be sufficient to restrict such tokens recovery via the recoverErc20 function (e.g. Compound-TUSD Integration Issue Retrospective).  If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the recoverErc20 function so that is can only be called from trusted accounts.  Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the recoverErc20 function is left unrestricted, then consider moving it out of the ADMIN section of the codebase.  Update: Fixed as of commit 5ea4099a44e5edfa5e84cc65e744cf546d7f5957 in pull request #12 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Misleading function names  In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised co", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#system-is-incompatible-with-non-standard-erc20-tokens", "labels": ["OpenZeppelin"]}, {"title": "Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:", "body": "Currently, the system is incompatible with non-standard ERC20 tokens and enabling such tokens for staking could lead to loss of funds in the following ways:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#currently,-the-system-is-incompatible-with-non-standard-erc20-tokens-and-enabling-such-tokens-for-staking-could-lead-to-loss-of-funds-in-the-following-ways:", "labels": ["OpenZeppelin"]}, {"title": "The system\u2019s internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as\u00a0Tether (USDT)\u00a0(the most widely known asset with this feature). This means that such tokens\u2019\u00a0transfer\u00a0and\u00a0transferFrom\u00a0functions could potentially fail to increase the recipient\u2019s balance by the amount that is actually transferred.If\u00a0AcceleratingDistributor\u00a0allows staking of tokens charging such transfer fees,\u00a0then stakers would receive more rewards than intended.", "body": "The system\u2019s internal accounting mechanism does not currently support tokens that can charge fees on transfers, such as\u00a0Tether (USDT)\u00a0(the most widely known asset with this feature). This means that such tokens\u2019\u00a0transfer\u00a0and\u00a0transferFrom\u00a0functions could potentially fail to increase the recipient\u2019s balance by the amount that is actually transferred.If\u00a0AcceleratingDistributor\u00a0allows staking of tokens charging such transfer fees,\u00a0then stakers would receive more rewards than intended.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-system\u2019s-internal-accounting-mechanism-does-not-currently-support-tokens-that-can-charge-fees-on-transfers,-such-as\u00a0tether-(usdt)\u00a0(the-most-widely-known-asset-with-this-feature).-this-means-that-such-tokens\u2019\u00a0transfer\u00a0and\u00a0transferfrom\u00a0functions-could-potentially-fail-to-increase-the-recipient\u2019s-balance-by-the-amount-that-is-actually-transferred.if\u00a0acceleratingdistributor\u00a0allows-staking-of-tokens-charging-such-transfer-fees,\u00a0then-stakers-would-receive-more-rewards-than-intended.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0recoverErc20\u00a0function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case\u00a0the current restrictions\u00a0may not be sufficient to restrict such tokens\u2019 recovery via the\u00a0recoverErc20\u00a0function (e.g.\u00a0Compound-TUSD Integration Issue Retrospective).", "body": "The\u00a0recoverErc20\u00a0function is currently callable by any address. This could be problematic if the system were to allow staking of non-standard ERC20 tokens, particularly if those tokens were to have a double entry point. In such a case\u00a0the current restrictions\u00a0may not be sufficient to restrict such tokens\u2019 recovery via the\u00a0recoverErc20\u00a0function (e.g.\u00a0Compound-TUSD Integration Issue Retrospective).", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0recovererc20\u00a0function-is-currently-callable-by-any-address.-this-could-be-problematic-if-the-system-were-to-allow-staking-of-non-standard-erc20-tokens,-particularly-if-those-tokens-were-to-have-a-double-entry-point.-in-such-a-case\u00a0the-current-restrictions\u00a0may-not-be-sufficient-to-restrict-such-tokens\u2019-recovery-via-the\u00a0recovererc20\u00a0function-(e.g.\u00a0compound-tusd-integration-issue-retrospective).", "labels": ["OpenZeppelin"]}, {"title": "If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the\u00a0recoverErc20\u00a0function so that is can only be called from trusted accounts.", "body": "If the protocol is expected to be compatible with these types of non-standard ERC20 tokens, then consider modifying the internal accounting mechanisms so that they properly track the actual amount of assets deposited. Additionally, consider limiting the\u00a0recoverErc20\u00a0function so that is can only be called from trusted accounts.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#if-the-protocol-is-expected-to-be-compatible-with-these-types-of-non-standard-erc20-tokens,-then-consider-modifying-the-internal-accounting-mechanisms-so-that-they-properly-track-the-actual-amount-of-assets-deposited.-additionally,-consider-limiting-the\u00a0recovererc20\u00a0function-so-that-is-can-only-be-called-from-trusted-accounts.", "labels": ["OpenZeppelin"]}, {"title": "Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the\u00a0recoverErc20\u00a0function is left unrestricted, then consider moving it out of the\u00a0ADMIN\u00a0section of the codebase.", "body": "Alternatively, consider documenting that the system is incompatible with non-standard ERC20 tokens and ensuring the contract owner thoroughly vets any ERC20 tokens that are enabled for staking. If the\u00a0recoverErc20\u00a0function is left unrestricted, then consider moving it out of the\u00a0ADMIN\u00a0section of the codebase.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#alternatively,-consider-documenting-that-the-system-is-incompatible-with-non-standard-erc20-tokens-and-ensuring-the-contract-owner-thoroughly-vets-any-erc20-tokens-that-are-enabled-for-staking.-if-the\u00a0recovererc20\u00a0function-is-left-unrestricted,-then-consider-moving-it-out-of-the\u00a0admin\u00a0section-of-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a05ea4099a44e5edfa5e84cc65e744cf546d7f5957\u00a0in\u00a0pull request #12\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "body": "Update:\u00a0Fixed as of commit\u00a05ea4099a44e5edfa5e84cc65e744cf546d7f5957\u00a0in\u00a0pull request #12\u00a0and commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull request #20.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a05ea4099a44e5edfa5e84cc65e744cf546d7f5957\u00a0in\u00a0pull-request-#12\u00a0and-commit\u00a03a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27\u00a0in\u00a0pull-request-#20.", "labels": ["OpenZeppelin"]}, {"title": "Misleading function names", "body": "In the AcceleratingDistributor contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:  The function name enableStaking implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties baseEmissionRate, maxMultiplier or secondsToMaxMultiplier. Consider renaming the function to configureStakingToken.  The enableStaking function emits the event TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.  The function prefix get typically indicates a view function, however the function getReward transfers outstanding rewards to the caller. Consider renaming it to withdrawReward.  The function name getTimeFromLastDeposit implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to getTimeSinceAverageDeposit.  The variable name rewardsPaidPerToken appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the rewardsOustanding variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming rewardsPaidPerToken to rewardsAccumulatedPerToken.  Update: Fixed as of commit 5db3215559fad05ebf98ac9f2bd91187a1e442d7 in pull request #13.  Missing documentation details  In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionali", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#misleading-function-names", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0AcceleratingDistributor\u00a0contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:", "body": "In the\u00a0AcceleratingDistributor\u00a0contract there are multiple functions, storage variables, and events that have misleading names. These could potentially confuse users and lead to unintentional or unexpected consequences when interacting with the contract. For instance:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#in-the\u00a0acceleratingdistributor\u00a0contract-there-are-multiple-functions,-storage-variables,-and-events-that-have-misleading-names.-these-could-potentially-confuse-users-and-lead-to-unintentional-or-unexpected-consequences-when-interacting-with-the-contract.-for-instance:", "labels": ["OpenZeppelin"]}, {"title": "The function name\u00a0enableStaking\u00a0implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties\u00a0baseEmissionRate,\u00a0maxMultiplier\u00a0or\u00a0secondsToMaxMultiplier. Consider renaming the function to\u00a0configureStakingToken.", "body": "The function name\u00a0enableStaking\u00a0implies that it can only be used to enable a staking token. However, the function can be used to enable or disable a staking token, and/or modify the properties\u00a0baseEmissionRate,\u00a0maxMultiplier\u00a0or\u00a0secondsToMaxMultiplier. Consider renaming the function to\u00a0configureStakingToken.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-function-name\u00a0enablestaking\u00a0implies-that-it-can-only-be-used-to-enable-a-staking-token.-however,-the-function-can-be-used-to-enable-or-disable-a-staking-token,-and/or-modify-the-properties\u00a0baseemissionrate,\u00a0maxmultiplier\u00a0or\u00a0secondstomaxmultiplier.-consider-renaming-the-function-to\u00a0configurestakingtoken.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0enableStaking\u00a0function emits the event\u00a0TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.", "body": "The\u00a0enableStaking\u00a0function emits the event\u00a0TokenEnabledForStaking. Consider renaming the event to better reflect the actual use case of the emitting function as outlined in the above bullet point.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0enablestaking\u00a0function-emits-the-event\u00a0tokenenabledforstaking.-consider-renaming-the-event-to-better-reflect-the-actual-use-case-of-the-emitting-function-as-outlined-in-the-above-bullet-point.", "labels": ["OpenZeppelin"]}, {"title": "The function prefix\u00a0get\u00a0typically indicates a view function, however the function\u00a0getReward\u00a0transfers outstanding rewards to the caller. Consider renaming it to\u00a0withdrawReward.", "body": "The function prefix\u00a0get\u00a0typically indicates a view function, however the function\u00a0getReward\u00a0transfers outstanding rewards to the caller. Consider renaming it to\u00a0withdrawReward.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-function-prefix\u00a0get\u00a0typically-indicates-a-view-function,-however-the-function\u00a0getreward\u00a0transfers-outstanding-rewards-to-the-caller.-consider-renaming-it-to\u00a0withdrawreward.", "labels": ["OpenZeppelin"]}, {"title": "The function name\u00a0getTimeFromLastDeposit\u00a0implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to\u00a0getTimeSinceAverageDeposit.", "body": "The function name\u00a0getTimeFromLastDeposit\u00a0implies that a difference between the current time and the last time of deposit is returned. However, the difference is calculated using the weighted average deposit time. Consider renaming it to\u00a0getTimeSinceAverageDeposit.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-function-name\u00a0gettimefromlastdeposit\u00a0implies-that-a-difference-between-the-current-time-and-the-last-time-of-deposit-is-returned.-however,-the-difference-is-calculated-using-the-weighted-average-deposit-time.-consider-renaming-it-to\u00a0gettimesinceaveragedeposit.", "labels": ["OpenZeppelin"]}, {"title": "The variable name\u00a0rewardsPaidPerToken\u00a0appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the\u00a0rewardsOustanding\u00a0variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming\u00a0rewardsPaidPerToken\u00a0to\u00a0rewardsAccumulatedPerToken.", "body": "The variable name\u00a0rewardsPaidPerToken\u00a0appears to imply that the rewards contained can be distributed or have already been distributed to the individual user. However, this variable is used as a helper variable to allow accurate bookkeeping of the\u00a0rewardsOustanding\u00a0variable, which contains the funds that are actually withdrawable to the individual user. Consider renaming\u00a0rewardsPaidPerToken\u00a0to\u00a0rewardsAccumulatedPerToken.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-variable-name\u00a0rewardspaidpertoken\u00a0appears-to-imply-that-the-rewards-contained-can-be-distributed-or-have-already-been-distributed-to-the-individual-user.-however,-this-variable-is-used-as-a-helper-variable-to-allow-accurate-bookkeeping-of-the\u00a0rewardsoustanding\u00a0variable,-which-contains-the-funds-that-are-actually-withdrawable-to-the-individual-user.-consider-renaming\u00a0rewardspaidpertoken\u00a0to\u00a0rewardsaccumulatedpertoken.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a05db3215559fad05ebf98ac9f2bd91187a1e442d7\u00a0in\u00a0pull request #13.", "body": "Update:\u00a0Fixed as of commit\u00a05db3215559fad05ebf98ac9f2bd91187a1e442d7\u00a0in\u00a0pull request #13.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a05db3215559fad05ebf98ac9f2bd91187a1e442d7\u00a0in\u00a0pull-request-#13.", "labels": ["OpenZeppelin"]}, {"title": "Missing documentation details", "body": "In the AcceleratingDistributor contract several parts of the documentation contain missing or misleading details. For instance:  The functions getUserRewardMultiplier and baseRewardPerToken return ratios or multipliers represented by a uint256 value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.  The contract-level documentation refers to a maxEmissionRate. However, the implementation uses a maxMultiplier which is multiplied with a baseEmissionRate instead.  To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.  Update: Fixed as of commit e3e7cf1c46304accc73f25a70f14036841e81239 in pull request #14.  Not using immutable  In the AcceleratingDistributor contract the rewardToken variable could be marked immutable given that is only ever set in the constructor.  If rewardToken is never meant to be modifiable, then consider marking it immutable to better signal intent and reduce gas consumption.  Update: Fixed as of commit 973e002a92e646f5e3af74d235a1e77d03bd69a0 in pull request #15.  Test code in production could have security implications  As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity ", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#missing-documentation-details", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0AcceleratingDistributor\u00a0contract several parts of the documentation contain missing or misleading details. For instance:", "body": "In the\u00a0AcceleratingDistributor\u00a0contract several parts of the documentation contain missing or misleading details. For instance:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#in-the\u00a0acceleratingdistributor\u00a0contract-several-parts-of-the-documentation-contain-missing-or-misleading-details.-for-instance:", "labels": ["OpenZeppelin"]}, {"title": "The functions\u00a0getUserRewardMultiplier\u00a0and\u00a0baseRewardPerToken\u00a0return ratios or multipliers represented by a\u00a0uint256\u00a0value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.", "body": "The functions\u00a0getUserRewardMultiplier\u00a0and\u00a0baseRewardPerToken\u00a0return ratios or multipliers represented by a\u00a0uint256\u00a0value with a fixed precision of 18 decimals. However, the decimal precision used is not documented.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-functions\u00a0getuserrewardmultiplier\u00a0and\u00a0baserewardpertoken\u00a0return-ratios-or-multipliers-represented-by-a\u00a0uint256\u00a0value-with-a-fixed-precision-of-18-decimals.-however,-the-decimal-precision-used-is-not-documented.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0contract-level documentation\u00a0refers to a\u00a0maxEmissionRate. However, the implementation uses a\u00a0maxMultiplier\u00a0which is multiplied with a\u00a0baseEmissionRate\u00a0instead.", "body": "The\u00a0contract-level documentation\u00a0refers to a\u00a0maxEmissionRate. However, the implementation uses a\u00a0maxMultiplier\u00a0which is multiplied with a\u00a0baseEmissionRate\u00a0instead.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0contract-level-documentation\u00a0refers-to-a\u00a0maxemissionrate.-however,-the-implementation-uses-a\u00a0maxmultiplier\u00a0which-is-multiplied-with-a\u00a0baseemissionrate\u00a0instead.", "labels": ["OpenZeppelin"]}, {"title": "To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.", "body": "To increase the overall readability of the codebase and reduce potential confusion, consider clarifying the documentation and adding missing details where appropriate.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#to-increase-the-overall-readability-of-the-codebase-and-reduce-potential-confusion,-consider-clarifying-the-documentation-and-adding-missing-details-where-appropriate.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0e3e7cf1c46304accc73f25a70f14036841e81239\u00a0in\u00a0pull request #14.", "body": "Update:\u00a0Fixed as of commit\u00a0e3e7cf1c46304accc73f25a70f14036841e81239\u00a0in\u00a0pull request #14.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a0e3e7cf1c46304accc73f25a70f14036841e81239\u00a0in\u00a0pull-request-#14.", "labels": ["OpenZeppelin"]}, {"title": "Not using\u00a0immutable", "body": "Not using\u00a0immutable", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#not-using\u00a0immutable", "labels": ["OpenZeppelin"]}, {"title": "In the\u00a0AcceleratingDistributor\u00a0contract the\u00a0rewardToken\u00a0variable could be marked\u00a0immutable\u00a0given that is only ever set in the constructor.", "body": "In the\u00a0AcceleratingDistributor\u00a0contract the\u00a0rewardToken\u00a0variable could be marked\u00a0immutable\u00a0given that is only ever set in the constructor.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#in-the\u00a0acceleratingdistributor\u00a0contract-the\u00a0rewardtoken\u00a0variable-could-be-marked\u00a0immutable\u00a0given-that-is-only-ever-set-in-the-constructor.", "labels": ["OpenZeppelin"]}, {"title": "If\u00a0rewardToken\u00a0is never meant to be modifiable, then consider marking it\u00a0immutable\u00a0to better signal intent and reduce gas consumption.", "body": "If\u00a0rewardToken\u00a0is never meant to be modifiable, then consider marking it\u00a0immutable\u00a0to better signal intent and reduce gas consumption.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#if\u00a0rewardtoken\u00a0is-never-meant-to-be-modifiable,-then-consider-marking-it\u00a0immutable\u00a0to-better-signal-intent-and-reduce-gas-consumption.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0973e002a92e646f5e3af74d235a1e77d03bd69a0\u00a0in\u00a0pull request #15.", "body": "Update:\u00a0Fixed as of commit\u00a0973e002a92e646f5e3af74d235a1e77d03bd69a0\u00a0in\u00a0pull request #15.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a0973e002a92e646f5e3af74d235a1e77d03bd69a0\u00a0in\u00a0pull-request-#15.", "labels": ["OpenZeppelin"]}, {"title": "Test code in production could have security implications", "body": "As we have raised in prior audits (issue L12) test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:  The AcceleratingDistributor contract inherits from the Testable contract. This facilitates modification of the getCurrentTime functions behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter _timer during deployment will disable the testing module and return block.timestamp instead.  The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to unstake and getReward are guarded by a modifier which ensures only that a token had been enabled for staking at some time  not that it is currently enabled for staking. It does this by verifying the tokens lastUpdateTime is greater than zero. The contract owner is not meant to be able to set lastUpdateTime in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.  However, a malicious operator could deploy the code with the address _timer pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. Whats worse, the malicious operator could then steal all staked TVL via recoverERC20 (which would no longer recognize the staked token as such when their lastUpdateTime was equal to zero).  A potential risk here is that a third party could uses this exact code, misusing the Testable functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.  As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.  Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.  Update: Fixed as of commit 144293ec5b81c3367ad58738d7bca273b3e8a9e4 in pull request #16.  Typographical errors  The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract ", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#test-code-in-production-could-have-security-implications", "labels": ["OpenZeppelin"]}, {"title": "As we have\u00a0raised in prior audits (issue L12)\u00a0test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:", "body": "As we have\u00a0raised in prior audits (issue L12)\u00a0test code in production code is less than ideal. We will not simply rehash our previously raised concerns and suggestions, but we do feel it prudent to expound on some of the potential security implications of having test code in production in this particular case:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#as-we-have\u00a0raised-in-prior-audits-(issue-l12)\u00a0test-code-in-production-code-is-less-than-ideal.-we-will-not-simply-rehash-our-previously-raised-concerns-and-suggestions,-but-we-do-feel-it-prudent-to-expound-on-some-of-the-potential-security-implications-of-having-test-code-in-production-in-this-particular-case:", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0AcceleratingDistributor\u00a0contract inherits from the\u00a0Testable\u00a0contract. This facilitates modification of the\u00a0getCurrentTime\u00a0function\u2019s behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter\u00a0_timer\u00a0during deployment will disable the testing module and return\u00a0block.timestamp\u00a0instead.", "body": "The\u00a0AcceleratingDistributor\u00a0contract inherits from the\u00a0Testable\u00a0contract. This facilitates modification of the\u00a0getCurrentTime\u00a0function\u2019s behavior during testing. This inheritance is meant to be kept in production. This is considered safe because passing the zero address for the parameter\u00a0_timer\u00a0during deployment will disable the testing module and return\u00a0block.timestamp\u00a0instead.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the\u00a0acceleratingdistributor\u00a0contract-inherits-from-the\u00a0testable\u00a0contract.-this-facilitates-modification-of-the\u00a0getcurrenttime\u00a0function\u2019s-behavior-during-testing.-this-inheritance-is-meant-to-be-kept-in-production.-this-is-considered-safe-because-passing-the-zero-address-for-the-parameter\u00a0_timer\u00a0during-deployment-will-disable-the-testing-module-and-return\u00a0block.timestamp\u00a0instead.", "labels": ["OpenZeppelin"]}, {"title": "The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to\u00a0unstake\u00a0and\u00a0getReward\u00a0are guarded by a modifier which ensures only that a token had been enabled for staking at some time \u2013 not that it is\u00a0currently\u00a0enabled for staking. It does this by verifying the token\u2019s\u00a0lastUpdateTime\u00a0is greater than zero. The contract owner is not meant to be able to set\u00a0lastUpdateTime\u00a0in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.", "body": "The contract logic ensures that all staked tokens can be unstaked by their respective owners and that all rewards can be collected even if further staking is disabled by the contract owner. Calls to\u00a0unstake\u00a0and\u00a0getReward\u00a0are guarded by a modifier which ensures only that a token had been enabled for staking at some time \u2013 not that it is\u00a0currently\u00a0enabled for staking. It does this by verifying the token\u2019s\u00a0lastUpdateTime\u00a0is greater than zero. The contract owner is not meant to be able to set\u00a0lastUpdateTime\u00a0in production and it is guaranteed to be greater than zero for each token that has previously been enabled for staking.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-contract-logic-ensures-that-all-staked-tokens-can-be-unstaked-by-their-respective-owners-and-that-all-rewards-can-be-collected-even-if-further-staking-is-disabled-by-the-contract-owner.-calls-to\u00a0unstake\u00a0and\u00a0getreward\u00a0are-guarded-by-a-modifier-which-ensures-only-that-a-token-had-been-enabled-for-staking-at-some-time-\u2013-not-that-it-is\u00a0currently\u00a0enabled-for-staking.-it-does-this-by-verifying-the-token\u2019s\u00a0lastupdatetime\u00a0is-greater-than-zero.-the-contract-owner-is-not-meant-to-be-able-to-set\u00a0lastupdatetime\u00a0in-production-and-it-is-guaranteed-to-be-greater-than-zero-for-each-token-that-has-previously-been-enabled-for-staking.", "labels": ["OpenZeppelin"]}, {"title": "However, a malicious operator could deploy the code with the\u00a0address\u00a0_timer\u00a0pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. What\u2019s worse, the malicious operator could then steal all staked TVL via\u00a0recoverERC20\u00a0(which would no longer recognize the staked token as such when their\u00a0lastUpdateTime\u00a0was equal to zero).", "body": "However, a malicious operator could deploy the code with the\u00a0address\u00a0_timer\u00a0pointing to a smart contract that allows the attacker to arbitrarily change time. They could at first report accurate block times and then wait until a significant portion of staked TVL is accumulated. Later, they could change the reported time to zero. As a consequence, users would be unable to unstake or obtain rewards. What\u2019s worse, the malicious operator could then steal all staked TVL via\u00a0recoverERC20\u00a0(which would no longer recognize the staked token as such when their\u00a0lastUpdateTime\u00a0was equal to zero).", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#however,-a-malicious-operator-could-deploy-the-code-with-the\u00a0address\u00a0_timer\u00a0pointing-to-a-smart-contract-that-allows-the-attacker-to-arbitrarily-change-time.-they-could-at-first-report-accurate-block-times-and-then-wait-until-a-significant-portion-of-staked-tvl-is-accumulated.-later,-they-could-change-the-reported-time-to-zero.-as-a-consequence,-users-would-be-unable-to-unstake-or-obtain-rewards.-what\u2019s-worse,-the-malicious-operator-could-then-steal-all-staked-tvl-via\u00a0recovererc20\u00a0(which-would-no-longer-recognize-the-staked-token-as-such-when-their\u00a0lastupdatetime\u00a0was-equal-to-zero).", "labels": ["OpenZeppelin"]}, {"title": "A potential risk here is that a third party could uses this exact code, misusing the\u00a0Testable\u00a0functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.", "body": "A potential risk here is that a third party could uses this exact code, misusing the\u00a0Testable\u00a0functionality to be genuinely malicious. Since ecosystem tools such as Etherscan can do exact matching on bytecode, the malicious deployment could end up being directly linked to the Across protocol, which could lead to some loss of reputation.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#a-potential-risk-here-is-that-a-third-party-could-uses-this-exact-code,-misusing-the\u00a0testable\u00a0functionality-to-be-genuinely-malicious.-since-ecosystem-tools-such-as-etherscan-can-do-exact-matching-on-bytecode,-the-malicious-deployment-could-end-up-being-directly-linked-to-the-across-protocol,-which-could-lead-to-some-loss-of-reputation.", "labels": ["OpenZeppelin"]}, {"title": "As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.", "body": "As this is a fairly general-purpose, user-facing system, with an open source license, we can certainly imagine it being reused. The subtleties of the deployment can have drastic implications for the security model of the deployed system. Normalizing such designs can have unintended consequences for users, but also for projects that may inadvertently suffer from mere association with some malicious deployment.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#as-this-is-a-fairly-general-purpose,-user-facing-system,-with-an-open-source-license,-we-can-certainly-imagine-it-being-reused.-the-subtleties-of-the-deployment-can-have-drastic-implications-for-the-security-model-of-the-deployed-system.-normalizing-such-designs-can-have-unintended-consequences-for-users,-but-also-for-projects-that-may-inadvertently-suffer-from-mere-association-with-some-malicious-deployment.", "labels": ["OpenZeppelin"]}, {"title": "Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.", "body": "Consider better isolating test and production code where possible. When this is not possible, consider bolstering the warnings in the code so that even casual users could better understand the implications if system variables are are not set as intended in production.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#consider-better-isolating-test-and-production-code-where-possible.-when-this-is-not-possible,-consider-bolstering-the-warnings-in-the-code-so-that-even-casual-users-could-better-understand-the-implications-if-system-variables-are-are-not-set-as-intended-in-production.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0144293ec5b81c3367ad58738d7bca273b3e8a9e4\u00a0in\u00a0pull request #16.", "body": "Update:\u00a0Fixed as of commit\u00a0144293ec5b81c3367ad58738d7bca273b3e8a9e4\u00a0in\u00a0pull request #16.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a0144293ec5b81c3367ad58738d7bca273b3e8a9e4\u00a0in\u00a0pull-request-#16.", "labels": ["OpenZeppelin"]}, {"title": "Typographical errors", "body": "The codebase contains the following typographical errors:  In AcceleratingDistributor.sol:  On line 17 and line 89 pro-rate should be pro-rata.  On line 126, after the end of the staking program ends is ungrammatical.  On line 202, exists should be exits.  On line 203, callers should be caller's.  On line 228, the all information associated should be all the information associated.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 7975d8ad19a3766341a115fce83c7752412f837b in pull request #17.  Conclusions  0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#typographical-errors", "labels": ["OpenZeppelin"]}, {"title": "The codebase contains the following typographical errors:", "body": "The codebase contains the following typographical errors:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-codebase-contains-the-following-typographical-errors:", "labels": ["OpenZeppelin"]}, {"title": "In\u00a0AcceleratingDistributor.sol:", "body": "In\u00a0AcceleratingDistributor.sol:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#in\u00a0acceleratingdistributor.sol:", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 17\u00a0and\u00a0line 89\u00a0pro-rate\u00a0should be\u00a0pro-rata.", "body": "On\u00a0line 17\u00a0and\u00a0line 89\u00a0pro-rate\u00a0should be\u00a0pro-rata.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#on\u00a0line-17\u00a0and\u00a0line-89\u00a0pro-rate\u00a0should-be\u00a0pro-rata.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 126,\u00a0after the end of the staking program ends\u00a0is ungrammatical.", "body": "On\u00a0line 126,\u00a0after the end of the staking program ends\u00a0is ungrammatical.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#on\u00a0line-126,\u00a0after-the-end-of-the-staking-program-ends\u00a0is-ungrammatical.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 202,\u00a0exists\u00a0should be\u00a0exits.", "body": "On\u00a0line 202,\u00a0exists\u00a0should be\u00a0exits.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#on\u00a0line-202,\u00a0exists\u00a0should-be\u00a0exits.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 203,\u00a0callers\u00a0should be\u00a0caller's.", "body": "On\u00a0line 203,\u00a0callers\u00a0should be\u00a0caller's.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#on\u00a0line-203,\u00a0callers\u00a0should-be\u00a0caller's.", "labels": ["OpenZeppelin"]}, {"title": "On\u00a0line 228,\u00a0the all information associated\u00a0should be\u00a0all the information associated.", "body": "On\u00a0line 228,\u00a0the all information associated\u00a0should be\u00a0all the information associated.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#on\u00a0line-228,\u00a0the-all-information-associated\u00a0should-be\u00a0all-the-information-associated.", "labels": ["OpenZeppelin"]}, {"title": "Consider correcting these typos to improve the overall readability of the codebase.", "body": "Consider correcting these typos to improve the overall readability of the codebase.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#consider-correcting-these-typos-to-improve-the-overall-readability-of-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a07975d8ad19a3766341a115fce83c7752412f837b\u00a0in\u00a0pull request #17.", "body": "Update:\u00a0Fixed as of commit\u00a07975d8ad19a3766341a115fce83c7752412f837b\u00a0in\u00a0pull request #17.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#update:\u00a0fixed-as-of-commit\u00a07975d8ad19a3766341a115fce83c7752412f837b\u00a0in\u00a0pull-request-#17.", "labels": ["OpenZeppelin"]}, {"title": "Conclusions", "body": "0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational purposes.  Related Posts  ZK Stack VM1.5 Diff Audit  Smart contract Audit. We audited the change to the matter-labs/era-contracts repository between...  Security Audits  L2's  Solidity  Yul  Radiant Riz Audit  Smart contract audit. Audited the radiant-capital/riz repository originally at the v0.0.1-alpha...  Security Audits  Solidity  Across V3 and Oval Incremental Audit  smart contract audit. We audited the across-protocol/contracts repository at commit 95c4f92.  Security Audits  Solidit", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#conclusions", "labels": ["OpenZeppelin"]}, {"title": "0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.", "body": "0 critical and 1 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#0-critical-and-1-high-severity-issues-were-found.-some-changes-were-proposed-to-follow-best-practices-and-reduce-the-potential-attack-surface.", "labels": ["OpenZeppelin"]}, {"title": "Appendix", "body": "Appendix", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#appendix", "labels": ["OpenZeppelin"]}, {"title": "Severity Levels", "body": "Severity Levels", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#severity-levels", "labels": ["OpenZeppelin"]}, {"title": "Not using immutable", "body": "Not using immutable", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#not-using-immutable", "labels": ["OpenZeppelin"]}, {"title": "s", "body": "Token and Token Ditributor Audit  OpenZeppelin Security |  July 21, 2022  Security Audit  Solidity  Token  May 10th, 2022  Thi ecurity aement wa prepared by OpenZeppelin, protecting the open economy.  Table of Content  Table of Content  Summary  Scope  Sytem Overview  Privileged Role  Finding  High Severity  Anyone can prevent taker from getting their reward  Medium Severity  Lack of input validation  Low Severity  Incomplete and unindexed event Recovery function i not robut Unhandled failure in token interaction Unued inherited contract  Note & Additional Information  Viibility unnecearily permiive Sytem i incompatible with non-tandard ERC20 token Mileading function name Miing documentation detail Not uing immutable Tet code in production could have ecurity implication Typographical error  Concluion  Appendix  Severity Level  Summary  DeFi  From 2022-04-25  To 2022-05-10  Solidity  13 (13 reolved)  0 (0 reolved)  1 (1 reolved)  1 (1 reolved)  4 (4 reolved)  7 (7 reolved)  Scope  We audited the acro-protocol/acro-token repoitory at commit 42130387f81debf2a20d2f7b40d9f0ccc1dcd06a.  In cope were the following contract:  Sytem Overview  Sytem Overview  The ytem i compoed of the Acro token (ACX) and the Acro token ditributor. Together, thee are meant to facilitate a liquidity mining program that will accompany the launch of the mot recent verion of the Acro protocol.  The Acro token i an ERC20 compliant token.  The Acro token ditributor allow uer to take whitelited ERC20 token (LP token) to earn ACX reward. At depoit time depoitor earn a fixed bae emiion rate. The longer depoitor keep their token taked, the higher the reward rate they earn. The reward rate i capped at a value et by the owner of the ditributor. Sequential depoit reult in an average depoit time a a weighted average of previou depoit. If at any point the depoitor claim their reward or untake all LP token, then their reward emiion rate i reet to the bae rate. The contract i deigned to hold multiple LP token, each with independent parameterization for liquidity mining.  Privileged Role  Each contract ha only one privileged role, which i the contract repective owner.  The Acro token owner can mint and burn the token. The owner can alo renounce and tranfer ownerhip.  The Acro token ditributor owner can alo tranfer and renounce ownerhip. In addition, the owner i the only account which receive token recovered from the contract, which are compried of token which were mitakenly ent to and are retrievable from the contract. Finally, the owner can enable and diable token for taking and change parameter of enabled LP token. Thee parameter are et per-token and include the bae ACX emiion rate, an emiion rate cap, and time needed to reach the emiion rate cap.  Finding  Here we preent our finding.  High Severity  Anyone can prevent taker from getting their reward  The recoverErc20 function i meant to facilitate the recovery of any ERC20 token that may be mitakenly ent to the AcceleratingDitributor contract. A thi i a public function with no modifier, anyone can call thi function to tranfer an ERC20 token from the AcceleratingDitributor contract to the owner of AcceleratingDitributor. The only ERC20 token that are explicitly diallowed from being recovered are takedToken that have already been initialized in the ytem.  However, it i currently poible to recover the ERC20 rewardToken uing the recoverErc20 function. Doing o would tranfer ome pecified amount of rewardToken from the AcceleratingDitributor contract to the contract owner. Thi would, ubequently, prevent taker from being able to acce their reward becaue AcceleratingDitributor could be left with an inufficient balance of rewardToken.  Even if the owner were to end rewardToken back to the AcceleratingDitributor contract, a maliciou actor could immediately tranfer all of the rewardToken back to the owner. Redeployment would be neceary to fix the iue.  Conider diallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed a of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull requet #5.  Medium Severity  Lack of input validation  The codebae generally lack ufficient input validation.  In the AcceleratingDitributor contract, the enableStaking function allow the contract owner to configure everal parameter aociated with a takedToken. Several of thee parameter have no input checking. Specifically:  The maxMultiplier parameter ha no upper or lower bound.  It hould be retricted to being larger than the bae multiplier of 1e18, or ele it can lead to uer taking reward decreaing over time rather than increaing.  It hould alo have an upper bound, becaue if it were to be et to ome very large value it could caue the getUerRewardMultiplier function to revert on overflow. Thi could, in turn, caue call to the getOuttandingReward and _updateReward function to revert. Thi would interfere with the normal operation of the ytem. However, it could be fixed by the contract owner uing the enableStaking", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#s", "labels": ["OpenZeppelin"]}, {"title": "Summary", "body": "DeFi  From 2022-04-25  To 2022-05-10  Solidity  13 (13 resolved)  0 (0 resolved)  1 (1 resolved)  1 (1 resolved)  4 (4 resolved)  7 (7 resolved)  Scope  We audited the across-protocol/across-token repository at commit 42130387f81debf2a20d2f7b40d9f0ccc1dcd06a.  In scope were the following contracts:  System Overview  System Overview  The system is composed of the Across token (ACX) and the Across token distributor. Together, these are meant to facilitate a liquidity mining program that will accompany the launch of the most recent version of the Across protocol.  The Across token is an ERC20 compliant token.  The Across token distributor allows users to stake whitelisted ERC20 tokens (LP tokens) to earn ACX rewards. At deposit time depositors earn a fixed base emission rate. The longer depositors keep their tokens staked, the higher the reward rate they earn. The reward rate is capped at a value set by the owner of the distributor. Sequential deposits result in an average deposit time as a weighted average of previous deposits. If at any point the depositor claims their rewards or unstakes all LP tokens, then their rewards emission rate is reset to the base rate. The contract is designed to hold multiple LP tokens, each with independent parameterization for liquidity mining.  Privileged Roles  Each contract has only one privileged role, which is the contracts respective owner.  The Across tokens owner can mint and burn the token. The owner can also renounce and transfer ownership.  The Across token distributors owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.  Findings  Here we present our findings.  High Severity  Anyone can prevent stakers from getting their rewards  The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an ove", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#summary", "labels": ["OpenZeppelin"]}, {"title": "DeFi", "body": "DeFi", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#defi", "labels": ["OpenZeppelin"]}, {"title": "From 2022-04-25", "body": "From 2022-04-25", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#from-2022-04-25", "labels": ["OpenZeppelin"]}, {"title": "To 2022-05-10", "body": "To 2022-05-10", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#to-2022-05-10", "labels": ["OpenZeppelin"]}, {"title": "Solidity", "body": "13 (13 resolved)  0 (0 resolved)  1 (1 resolved)  1 (1 resolved)  4 (4 resolved)  7 (7 resolved)  Scope  We audited the across-protocol/across-token repository at commit 42130387f81debf2a20d2f7b40d9f0ccc1dcd06a.  In scope were the following contracts:  System Overview  System Overview  The system is composed of the Across token (ACX) and the Across token distributor. Together, these are meant to facilitate a liquidity mining program that will accompany the launch of the most recent version of the Across protocol.  The Across token is an ERC20 compliant token.  The Across token distributor allows users to stake whitelisted ERC20 tokens (LP tokens) to earn ACX rewards. At deposit time depositors earn a fixed base emission rate. The longer depositors keep their tokens staked, the higher the reward rate they earn. The reward rate is capped at a value set by the owner of the distributor. Sequential deposits result in an average deposit time as a weighted average of previous deposits. If at any point the depositor claims their rewards or unstakes all LP tokens, then their rewards emission rate is reset to the base rate. The contract is designed to hold multiple LP tokens, each with independent parameterization for liquidity mining.  Privileged Roles  Each contract has only one privileged role, which is the contracts respective owner.  The Across tokens owner can mint and burn the token. The owner can also renounce and transfer ownership.  The Across token distributors owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.  Findings  Here we present our findings.  High Severity  Anyone can prevent stakers from getting their rewards  The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#solidity", "labels": ["OpenZeppelin"]}, {"title": "13 (13 resolved)", "body": "13 (13 resolved)", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#13-(13-resolved)", "labels": ["OpenZeppelin"]}, {"title": "0 (0 resolved)", "body": "0 (0 resolved)", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#0-(0-resolved)", "labels": ["OpenZeppelin"]}, {"title": "1 (1 resolved)", "body": "4 (4 resolved)  7 (7 resolved)  Scope  We audited the across-protocol/across-token repository at commit 42130387f81debf2a20d2f7b40d9f0ccc1dcd06a.  In scope were the following contracts:  System Overview  System Overview  The system is composed of the Across token (ACX) and the Across token distributor. Together, these are meant to facilitate a liquidity mining program that will accompany the launch of the most recent version of the Across protocol.  The Across token is an ERC20 compliant token.  The Across token distributor allows users to stake whitelisted ERC20 tokens (LP tokens) to earn ACX rewards. At deposit time depositors earn a fixed base emission rate. The longer depositors keep their tokens staked, the higher the reward rate they earn. The reward rate is capped at a value set by the owner of the distributor. Sequential deposits result in an average deposit time as a weighted average of previous deposits. If at any point the depositor claims their rewards or unstakes all LP tokens, then their rewards emission rate is reset to the base rate. The contract is designed to hold multiple LP tokens, each with independent parameterization for liquidity mining.  Privileged Roles  Each contract has only one privileged role, which is the contracts respective owner.  The Across tokens owner can mint and burn the token. The owner can also renounce and transfer ownership.  The Across token distributors owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.  Findings  Here we present our findings.  High Severity  Anyone can prevent stakers from getting their rewards  The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStake", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#1-(1-resolved)", "labels": ["OpenZeppelin"]}, {"title": "4 (4 resolved)", "body": "4 (4 resolved)", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#4-(4-resolved)", "labels": ["OpenZeppelin"]}, {"title": "7 (7 resolved)", "body": "7 (7 resolved)", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#7-(7-resolved)", "labels": ["OpenZeppelin"]}, {"title": "Scope", "body": "We audited the across-protocol/across-token repository at commit 42130387f81debf2a20d2f7b40d9f0ccc1dcd06a.  In scope were the following contracts:  System Overview  System Overview  The system is composed of the Across token (ACX) and the Across token distributor. Together, these are meant to facilitate a liquidity mining program that will accompany the launch of the most recent version of the Across protocol.  The Across token is an ERC20 compliant token.  The Across token distributor allows users to stake whitelisted ERC20 tokens (LP tokens) to earn ACX rewards. At deposit time depositors earn a fixed base emission rate. The longer depositors keep their tokens staked, the higher the reward rate they earn. The reward rate is capped at a value set by the owner of the distributor. Sequential deposits result in an average deposit time as a weighted average of previous deposits. If at any point the depositor claims their rewards or unstakes all LP tokens, then their rewards emission rate is reset to the base rate. The contract is designed to hold multiple LP tokens, each with independent parameterization for liquidity mining.  Privileged Roles  Each contract has only one privileged role, which is the contracts respective owner.  The Across tokens owner can mint and burn the token. The owner can also renounce and transfer ownership.  The Across token distributors owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.  Findings  Here we present our findings.  High Severity  Anyone can prevent stakers from getting their rewards  The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStaked was already non-zero. This would caus", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#scope", "labels": ["OpenZeppelin"]}, {"title": "We audited the\u00a0across-protocol/across-token\u00a0repository at commit\u00a042130387f81debf2a20d2f7b40d9f0ccc1dcd06a.", "body": "We audited the\u00a0across-protocol/across-token\u00a0repository at commit\u00a042130387f81debf2a20d2f7b40d9f0ccc1dcd06a.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#we-audited-the\u00a0across-protocol/across-token\u00a0repository-at-commit\u00a042130387f81debf2a20d2f7b40d9f0ccc1dcd06a.", "labels": ["OpenZeppelin"]}, {"title": "In scope were the following contracts:", "body": "In scope were the following contracts:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#in-scope-were-the-following-contracts:", "labels": ["OpenZeppelin"]}, {"title": "System Overview", "body": "The system is composed of the Across token (ACX) and the Across token distributor. Together, these are meant to facilitate a liquidity mining program that will accompany the launch of the most recent version of the Across protocol.  The Across token is an ERC20 compliant token.  The Across token distributor allows users to stake whitelisted ERC20 tokens (LP tokens) to earn ACX rewards. At deposit time depositors earn a fixed base emission rate. The longer depositors keep their tokens staked, the higher the reward rate they earn. The reward rate is capped at a value set by the owner of the distributor. Sequential deposits result in an average deposit time as a weighted average of previous deposits. If at any point the depositor claims their rewards or unstakes all LP tokens, then their rewards emission rate is reset to the base rate. The contract is designed to hold multiple LP tokens, each with independent parameterization for liquidity mining.  Privileged Roles  Each contract has only one privileged role, which is the contracts respective owner.  The Across tokens owner can mint and burn the token. The owner can also renounce and transfer ownership.  The Across token distributors owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.  Findings  Here we present our findings.  High Severity  Anyone can prevent stakers from getting their rewards  The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStaked was already non-zero. This would cause _updateReward to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete r", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#system-overview", "labels": ["OpenZeppelin"]}, {"title": "The system is composed of the Across token (ACX) and the Across token distributor. Together, these are meant to facilitate a liquidity mining program that will accompany the launch of the most recent version of the Across protocol.", "body": "The system is composed of the Across token (ACX) and the Across token distributor. Together, these are meant to facilitate a liquidity mining program that will accompany the launch of the most recent version of the Across protocol.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-system-is-composed-of-the-across-token-(acx)-and-the-across-token-distributor.-together,-these-are-meant-to-facilitate-a-liquidity-mining-program-that-will-accompany-the-launch-of-the-most-recent-version-of-the-across-protocol.", "labels": ["OpenZeppelin"]}, {"title": "The Across token is an ERC20 compliant token.", "body": "The Across token is an ERC20 compliant token.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-across-token-is-an-erc20-compliant-token.", "labels": ["OpenZeppelin"]}, {"title": "The Across token distributor allows users to stake whitelisted ERC20 tokens (LP tokens) to earn ACX rewards. At deposit time depositors earn a fixed base emission rate. The longer depositors keep their tokens staked, the higher the reward rate they earn. The reward rate is capped at a value set by the owner of the distributor. Sequential deposits result in an average deposit time as a weighted average of previous deposits. If at any point the depositor claims their rewards or unstakes all LP tokens, then their rewards emission rate is reset to the base rate. The contract is designed to hold multiple LP tokens, each with independent parameterization for liquidity mining.", "body": "The Across token distributor allows users to stake whitelisted ERC20 tokens (LP tokens) to earn ACX rewards. At deposit time depositors earn a fixed base emission rate. The longer depositors keep their tokens staked, the higher the reward rate they earn. The reward rate is capped at a value set by the owner of the distributor. Sequential deposits result in an average deposit time as a weighted average of previous deposits. If at any point the depositor claims their rewards or unstakes all LP tokens, then their rewards emission rate is reset to the base rate. The contract is designed to hold multiple LP tokens, each with independent parameterization for liquidity mining.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-across-token-distributor-allows-users-to-stake-whitelisted-erc20-tokens-(lp-tokens)-to-earn-acx-rewards.-at-deposit-time-depositors-earn-a-fixed-base-emission-rate.-the-longer-depositors-keep-their-tokens-staked,-the-higher-the-reward-rate-they-earn.-the-reward-rate-is-capped-at-a-value-set-by-the-owner-of-the-distributor.-sequential-deposits-result-in-an-average-deposit-time-as-a-weighted-average-of-previous-deposits.-if-at-any-point-the-depositor-claims-their-rewards-or-unstakes-all-lp-tokens,-then-their-rewards-emission-rate-is-reset-to-the-base-rate.-the-contract-is-designed-to-hold-multiple-lp-tokens,-each-with-independent-parameterization-for-liquidity-mining.", "labels": ["OpenZeppelin"]}, {"title": "Privileged Roles", "body": "Each contract has only one privileged role, which is the contracts respective owner.  The Across tokens owner can mint and burn the token. The owner can also renounce and transfer ownership.  The Across token distributors owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.  Findings  Here we present our findings.  High Severity  Anyone can prevent stakers from getting their rewards  The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStaked was already non-zero. This would cause _updateReward to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any stakedToken at all were actively being staked. Any stakedToken already in the contract would be locked.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input.  Update: Fixed as of commit 9652a990a14d00e4d47f9e4f3df2c422a6881d4a in pull request #6 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Low Severity  Incomplete and unindexed events  Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.  Events lacking indexed parameters include:  The TokenEnabledForStaking, RecoverErc20, Stake, Unstake, GetReward, and Exit events in the AcceleratingDistributor contract.  Event emissions which do not fully track state changes include:", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#privileged-roles", "labels": ["OpenZeppelin"]}, {"title": "Each contract has only one privileged role, which is the contract\u2019s respective\u00a0owner.", "body": "Each contract has only one privileged role, which is the contract\u2019s respective\u00a0owner.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#each-contract-has-only-one-privileged-role,-which-is-the-contract\u2019s-respective\u00a0owner.", "labels": ["OpenZeppelin"]}, {"title": "The Across token\u2019s owner can mint and burn the token. The owner can also renounce and transfer ownership.", "body": "The Across token\u2019s owner can mint and burn the token. The owner can also renounce and transfer ownership.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-across-token\u2019s-owner-can-mint-and-burn-the-token.-the-owner-can-also-renounce-and-transfer-ownership.", "labels": ["OpenZeppelin"]}, {"title": "The Across token distributor\u2019s owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.", "body": "The Across token distributor\u2019s owner can also transfer and renounce ownership. In addition, the owner is the only account which receives tokens recovered from the contract, which are comprised of tokens which were mistakenly sent to and are retrievable from the contract. Finally, the owner can enable and disable tokens for staking and change parameters of enabled LP tokens. These parameters are set per-token and include the base ACX emission rate, an emission rate cap, and time needed to reach the emission rate cap.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#the-across-token-distributor\u2019s-owner-can-also-transfer-and-renounce-ownership.-in-addition,-the-owner-is-the-only-account-which-receives-tokens-recovered-from-the-contract,-which-are-comprised-of-tokens-which-were-mistakenly-sent-to-and-are-retrievable-from-the-contract.-finally,-the-owner-can-enable-and-disable-tokens-for-staking-and-change-parameters-of-enabled-lp-tokens.-these-parameters-are-set-per-token-and-include-the-base-acx-emission-rate,-an-emission-rate-cap,-and-time-needed-to-reach-the-emission-rate-cap.", "labels": ["OpenZeppelin"]}, {"title": "Findings", "body": "Here we present our findings.  High Severity  Anyone can prevent stakers from getting their rewards  The recoverErc20 function is meant to facilitate the recovery of any ERC20 tokens that may be mistakenly sent to the AcceleratingDistributor contract. As this is a public function with no modifiers, anyone can call this function to transfer an ERC20 token from the AcceleratingDistributor contract to the owner of AcceleratingDistributor. The only ERC20 tokens that are explicitly disallowed from being recovered are stakedTokens that have already been initialized in the system.  However, it is currently possible to recover the ERC20 rewardToken using the recoverErc20 function. Doing so would transfer some specified amount of rewardToken from the AcceleratingDistributor contract to the contracts owner. This would, subsequently, prevent stakers from being able to access their rewards because AcceleratingDistributor could be left with an insufficient balance of rewardTokens.  Even if the owner were to send rewardTokens back to the AcceleratingDistributor contract, a malicious actor could immediately transfer all of the rewardTokens back to the owner. Redeployment would be necessary to fix the issue.  Consider disallowing recovery of the rewardToken within the recoverErc20 function.  Update: Fixed as of commit bcdabc06ca6d789b95c5b26d23f48dab8bfad277 in pull request #5.  Medium Severity  Lack of input validation  The codebase generally lacks sufficient input validation.  In the AcceleratingDistributor contract, the enableStaking function allows the contract owner to configure several parameters associated with a stakedToken. Several of these parameters have no input checking. Specifically:  The maxMultiplier parameter has no upper or lower bound.  It should be restricted to being larger than the base multiplier of 1e18, or else it can lead to users staking rewards decreasing over time rather than increasing.  It should also have an upper bound, because if it were to be set to some very large value it could cause the getUserRewardMultiplier function to revert on overflow. This could, in turn, cause calls to the getOutstandingRewards and _updateReward functions to revert. This would interfere with the normal operation of the system. However, it could be fixed by the contract owner using the enableStaking function to update to a more reasonable maxMultiplier.  Similarly, the secondsToMaxMultiplier parameter has no lower bound. If allowed to be zero then getUserRewardMultiplier could revert due to division by zero. This could cause the getOutstandingRewards and _updateReward functions to revert as outlined above. The contract owner could put the system back into a stable state by making secondsToMaxMultiplier non-zero.  The baseEmissionRate parameter has no upper bound. If set too high then, as soon as stakingToken.cumulativeStaked were some non-zero value, the baseRewardPerToken function would always revert due to an overflow. Importantly, this value could be set to a system destabilizing value even when stakingToken.cumulativeStaked was already non-zero. This would cause _updateReward to revert even in the case that the provided account was the zero address. This detail would prevent the contract owner from fixing the situation without a complete redeployment of the system if any stakedToken at all were actively being staked. Any stakedToken already in the contract would be locked.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input.  Update: Fixed as of commit 9652a990a14d00e4d47f9e4f3df2c422a6881d4a in pull request #6 and commit 3a4a6382b88f40fa9d816e5e5b1d3a31a7b24f27 in pull request #20.  Low Severity  Incomplete and unindexed events  Throughout the codebase, events are used to signify when changes are made to the state of the system. However, all of the existing events lack indexed parameters. Some events are missing parameters necessary to fully indicate how the state was modified during a call.  Events lacking indexed parameters include:  The TokenEnabledForStaking, RecoverErc20, Stake, Unstake, GetReward, and Exit events in the AcceleratingDistributor contract.  Event emissions which do not fully track state changes include:  The RecoverErc20 event does not emit the caller, which may be of interest to those interested in calls to the recoverErc20 function where the event is emitted.  The Stake, Unstake, and Exit events are emitted when a user calls the stake, unstake, or exit functions, respectively. These functions update the stakedTokens cumulativeStaked value, but this is not emitted in the events. Similarly, these functions  as well as the getReward function  update a stakedTokens lastUpdateTime and rewardPerTokenStored as well as a userDeposits rewardsOutstanding and rewardsPaidPerToken values, but these state changes are not captured by any associated event emissions.  Consider completely indexing existing events, adding new ind", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#findings", "labels": ["OpenZeppelin"]}, {"title": "Here we present our findings.", "body": "Here we present our findings.", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#here-we-present-our-findings.", "labels": ["OpenZeppelin"]}, {"title": "High Severity", "body": "High Severity", "html_url": "https://blog.openzeppelin.com/across-token-and-token-distributor-audit#high-severity", "labels": ["OpenZeppelin"]}, {"title": "The issue puts a large number of users\u2019 sensitive information at risk, or is reasonably likely to lead to catastrophic impact for client\u2019s reputation or serious financial implications for client and users.", "body": "The issue puts a large number of users\u2019 sensitive information at risk, or is reasonably likely to lead to catastrophic impact for client\u2019s reputation or serious financial implications for client and users.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the-issue-puts-a-large-number-of-users\u2019-sensitive-information-at-risk,-or-is-reasonably-likely-to-lead-to-catastrophic-impact-for-client\u2019s-reputation-or-serious-financial-implications-for-client-and-users.", "labels": ["OpenZeppelin"]}, {"title": "Change of collateral could result in unintended bond value", "body": "The OptimisticGovernor contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.  To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely setBond to set the new amount and setCollateral to set the new ERC20 address of the bond token.  If the contract owner is an EOA, then setBond and setCollateral will be called in two separate transactions which allows a third party to call proposeTransactions in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.  Consider renaming setCollateral to setCollateralAndBond and updating both the bond value and the bond token address in the same function call.  Update: Fixed as of commit 5794c2040cc85aced20ef1145aa0329a1c8d8236 in pull request #3912.  Lack of event emission after sensitive actions  setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codeb", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#change-of-collateral-could-result-in-unintended-bond-value", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission after sensitive actions", "body": "setUp,  setBond,  setCollateral,  setRules,  setLiveness, and  setIdentifier functions do not emit relevant events after executing sensitive actions.  Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts activity.  Update: Fixed as of commit f6c3d17ae9e31d2f337d3f887647731959096663 in pull request #3913 and commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Lack of input validation  The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle a", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#lack-of-event-emission-after-sensitive-actions", "labels": ["OpenZeppelin"]}, {"title": "Lack of input validation", "body": "The OptimisticGovernor contract has a general lack of input validation. For instance, the setUp function does not validate that the _finder argument is non-zero, which can lead to a non-functional module instance. Nor does setUp validate that the _rules argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.  In the same function, _liveness is checked to be greater than zero, in line with the Optimistic Oracles lower bound requirement. However, setUp does not check that _liveness is less than 5200 weeks, which is the Optimistic Oracles upper bound requirement.  The setLiveness and setRules functions have the same sort of lacking input validation as setUp does.  Both the setUp and setBond functions allow a zero bond, which the OptimisticOracle will accept. However, because of the overall lack of input validation, it becomes difficult to discern if a zero bond is a legitimately acceptable value or simply an oversight of the validation logic.  To avoid errors and unexpected system behavior, consider implementing require statements to validate all user-controlled input. Where zero-values are acceptable, consider leaving inline documentation to that effect to avoid ambiguity.  Update: Fixed as of commit 661b984edcbab12b7e0ed9f9e9739169cb732c33 in pull request #3915, commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914, commit 55e8f77e748619052b885ce191fee18984a44f29 in pull request #3950 and commit f3d2431f5fb594b6dd5d3a92d6bb1b91d2a25cfe in pull request #3962.  Mismatches between UMIP and implementation  In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments ref", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#lack-of-input-validation", "labels": ["OpenZeppelin"]}, {"title": "Mismatches between UMIP and implementation", "body": "In UMIP-152, the documentation of several data structures is significantly different from their implementation in OptmisticGovenor.sol.  Differences can be found in the Transaction and Proposal structs as well as the data format of ancilliaryData.  Consider updating the documentation to correspond to the implementation. Additionally, in light of the removal of the module address from ancilliaryData, consider adding further documentation to explain how uniqueness of a proposal identifier across all users of the Optimistic Oracle is maintained.  Update: not fixed, UMAs reply: will be fixed in separate PR updating the UMIP after code is finalized.  Low Severity  Events lacking information  We identified two events which could benefit from being more complete. Specifically, the ProposalDeleted and TransactionsProposed events.  Currently, ProposalDeleted event emissions have an ambiguous interpretation. This is because such emissions can originate from either the deleteRejectedProposal function or the deleteProposal function under different circumstances. To reduce ambiguity, consider augmenting the event so that it also emits details about the proposal status and the msg.sender when a proposal is deleted.  The TransactionsProposed event currently emits the time at which a proposal is created, but it does not emit the liveness time the proposal is subject to or a timestamp that indicates when the proposal needs to be disputed by. As this is likely to be of interest at the time a proposal is created, consider emitting enough information to determine when a proposal must be disputed by.  Update: Fixed as of commit c3ae271a3e9a10dd69fe33ef44417633e53043ec in pull request #3916.  Duplicated code  There are instances of duplicated code within the codebase. Duplicated code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors later if functionality changes are not replicated across all instances of code that should be identical.  Within the OptimisticGovernor contract the setUp function repeats code found in several of the set* setter functions.  Rather than duplicating code, consider reusing existing functions as needed or having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.  Update: Fixed as of commit 9b5b6d3f4b1168157344c1b93a2c2aa695f19580 in pull request #3914.  Misleading inline documentation  There are instances of misleading or imprecise documentation throughout the codebase.  In particular, in OptimisticGovernor.sol:  The public sync function has a comment beneath it that reads, Sync the oracle contract addresses as well as the final fee. In fact, the function merely makes a call to the internal _sync function that then sets only the optimisticOracle address. No other address or final fee value is stored.  On line 69 the NatSpec states, Bond required (must be at least as large as final fee for collateral type). However, there is no comparison made.  The NatSpec of the _originalTime parameter of the deleteRejectedProposal function is a copy paste error from the line above describing the _proposalId parameter.  On line 246 and line 279 there is an inline comment that reads, This will revert if the price has not settled. This is not as nuanced as it could be. The calls the comments refer to will revert if the price has not and can not currently be settled; the calls can actually settle the the request if the price has not yet been settled but is settle-able.  Additionally, in OptimisticOracle.sol:  On line 172 the comment explains the inequality check that follows as: This ensures that the ancillary data is below the OO limit. In fact, the inequality test that the ancillary data is less than or equal to the Optimistic Oracle (OO) ancillary data limit.  Clear inline documentation is fundamental to outline the intentions of the code. Mismatches between them and the implementation can lead to serious misconceptions about how the system is expected to behave. Therefore, consider fixing these errors to avoid potential confusion for developers, users, auditors alike.  Update: Fixed as of commit 6a3e00d72832e663f191920a796b5cbe52aea774 in pull request #3917 and commit d1a6421e4331861708a5f5bb7b20072d042d17ff in pull request #3963.  Proposals can be deleted repeatedly  In the OptimisticGovernor contract there is no check that a proposal exists before it is deleted with the deleteProposal function. Similarly, a rejected proposal can be deleted repeatedly via the deleteRejectedProposal function.  Although there is no clear economic incentive to do delete a proposal numerous times  in fact it will waste gas  the repeated emission of identical ProposalDeleted events could be confusing for parties monitoring for such events.  Consider allowing proposals to be deleted only if they have not already been deleted.  Update: Fixed as of commit deeb7386be6d1f14c8999fe5316c9feb80b5d0d2 in pull", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#mismatches-between-umip-and-implementation", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0OptimisticGovernor\u00a0contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.", "body": "The\u00a0OptimisticGovernor\u00a0contract requires users to provide a preconfigured quantity of an ERC20 token as bond to propose a set of transactions. If the set of transactions is rejected, the proposer will lose their bond.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0optimisticgovernor\u00a0contract-requires-users-to-provide-a-preconfigured-quantity-of-an-erc20-token-as-bond-to-propose-a-set-of-transactions.-if-the-set-of-transactions-is-rejected,-the-proposer-will-lose-their-bond.", "labels": ["OpenZeppelin"]}, {"title": "To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely\u00a0setBond\u00a0to set the new amount and\u00a0setCollateral\u00a0to set the new ERC20 address of the bond token.", "body": "To change the collateral token address and its amount the contract owner will generally have to call two separate functions, namely\u00a0setBond\u00a0to set the new amount and\u00a0setCollateral\u00a0to set the new ERC20 address of the bond token.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#to-change-the-collateral-token-address-and-its-amount-the-contract-owner-will-generally-have-to-call-two-separate-functions,-namely\u00a0setbond\u00a0to-set-the-new-amount-and\u00a0setcollateral\u00a0to-set-the-new-erc20-address-of-the-bond-token.", "labels": ["OpenZeppelin"]}, {"title": "If the contract owner is an EOA, then\u00a0setBond\u00a0and\u00a0setCollateral\u00a0will be called in two separate transactions which allows a third party to call\u00a0proposeTransactions\u00a0in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.", "body": "If the contract owner is an EOA, then\u00a0setBond\u00a0and\u00a0setCollateral\u00a0will be called in two separate transactions which allows a third party to call\u00a0proposeTransactions\u00a0in between. This will lead to the creation of a proposal with an unintended bond value. In fact, the realized bond could potentially have a much lower value than intended.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#if-the-contract-owner-is-an-eoa,-then\u00a0setbond\u00a0and\u00a0setcollateral\u00a0will-be-called-in-two-separate-transactions-which-allows-a-third-party-to-call\u00a0proposetransactions\u00a0in-between.-this-will-lead-to-the-creation-of-a-proposal-with-an-unintended-bond-value.-in-fact,-the-realized-bond-could-potentially-have-a-much-lower-value-than-intended.", "labels": ["OpenZeppelin"]}, {"title": "Consider renaming\u00a0setCollateral\u00a0to\u00a0setCollateralAndBond\u00a0and updating both the bond value and the bond token address in the same function call.", "body": "Consider renaming\u00a0setCollateral\u00a0to\u00a0setCollateralAndBond\u00a0and updating both the bond value and the bond token address in the same function call.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-renaming\u00a0setcollateral\u00a0to\u00a0setcollateralandbond\u00a0and-updating-both-the-bond-value-and-the-bond-token-address-in-the-same-function-call.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a05794c2040cc85aced20ef1145aa0329a1c8d8236\u00a0in\u00a0pull request #3912.", "body": "Update:\u00a0Fixed as of commit\u00a05794c2040cc85aced20ef1145aa0329a1c8d8236\u00a0in\u00a0pull request #3912.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a05794c2040cc85aced20ef1145aa0329a1c8d8236\u00a0in\u00a0pull-request-#3912.", "labels": ["OpenZeppelin"]}, {"title": "setUp,", "body": "setUp,", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#setup,", "labels": ["OpenZeppelin"]}, {"title": "setBond,", "body": "setBond,", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#setbond,", "labels": ["OpenZeppelin"]}, {"title": "setCollateral,", "body": "setCollateral,", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#setcollateral,", "labels": ["OpenZeppelin"]}, {"title": "setRules,", "body": "setRules,", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#setrules,", "labels": ["OpenZeppelin"]}, {"title": "setLiveness, and", "body": "setIdentifier functions are marked  Consider declaring functions with only the most restrictive visibility required to reduce the overall surface for error and better reflect intent.  Update: Fixed as of commit 3fdebf2d48263f5ec9a73255853874535141e220 in pull request #3922.  Suboptimal struct packing  OptimisticGovernor contract the  Transaction  member labeled operation. This member is implicitly of type  to in order to take advantage of more efficient  Update: Fixed as of commit 556cd89217c3b96dde2f6dfc394f67a0742e48b3 in pull request #3923.  Typographical errors  The codebase contains the following typographical errors:  In OptimisticGovernor.sol:  On line 37, address need to should be address needs to.  On line 167, proposals should be proposal's.  On line 292, overriden should be overridden.  Consider correcting these typos to improve the overall readability of the codebase.  Update: Fixed as of commit 745a64aeb0c0b61b214931310d08fbe8ac155f0f in pull request #3924.  Undocumented implicit approval requirements  In the OptimisticGovernor contract, the proposeTransactions function implicitly assumes that it has been granted an appropriate allowance of collateral tokens from the proposer when it attempts to safeTransferFrom the totalBond.  In favor of explicitness and to improve the overall clarity of the codebase, consider documenting all approval requirements in the relevant functions inline documentation.  Update: Fixed as of commit c6bdb5e02b57d4f4135feca80d08671725141226 in pull request #3925.  Unexplained and unused constants  Throughout the OptimisticGovernor contract, to check if a proposal has been approved by the Optimistic Oracle the literal value int256 1e18 is used, where 1e18 signifies that a proposal was not rejected by the Optimistic Oracle.  Similarly, in the update to the OptimisticOracle contract the function proposedPrice uses a magic value type(int256).min to indicate that an event-based proposal cannot be resolved, because the event has not yet taken place.  Lastly, in the OptimisticOracle contract the MAX_ADDED_ANCILLARY_DATA constant is declared on line 129. On the next line the constant should be used, but instead the value of the constant is used directly to derive another constant.  To improve the overall readability of the codebase and to facilitate refactoring, consider defining a constant for every literal or magic value used, giving it a clear and self-explanatory name, and then using it in place of literal values. Also consider adding an inline comment explaining how literal values were calculated or why they were chosen.  Update: Fixed as of commit c7babc3d3082200b55901783f4ceabae82df1cea in pull request #3909.  Unnecessary cast  In the setUp function of the OptimisticGovernor contract, _collateral is unnecessarily cast to an address type.  To improve the overall legibility of the codebase, consider removing this unnecessary cast.  Update: Fixed as of commit 2819d071df9a3bbcc8a2d15700d6140ae8e5ad9d in pull request #3928.  Unnecessary imports  The codebase contains the following unnecessary imports:  In OptimisticGovernor.sol:  On line 13 OptimisticOracle.sol is unnecessarily imported.  Consider removing unnecessary imports to improve code clarity.  Update: Fixed as of commit 5833fce724930ba27a01855dcbaf03bcfe7fa7a2 in pull request #3927.  Unused using for directive  The OptimisticOracle contract includes the directive using AncillaryData for bytes, even though none of the library methods are ever used directly on a bytes value.  Consider removing the directive if it will remain unused.  Update: Fixed as of commit 2ee3f4b2affb7049a156c93705d9918ce5c3a670 in pull request #3910.  Conclusions  0 critical and 0 high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Appendix  Severity Levels  Critical Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  High Severity  The issue puts a large number of users sensitive information at risk, or is reasonably likely to lead to catastrophic impact for clients reputation or serious financial implications for client and users.  Medium Severity  The issue puts a subset of users sensitive information at risk, would be detrimental for the clients reputation if exploited, or is reasonably likely to lead to moderate financial impact.  Low Severity  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances.  Notes & Additional Information  The risk is relatively small and could not be exploited on a recurring basis, or is a risk that the client has indicated its low impact in view of the clients business circumstances. It may also include non-security-relevant content for purely informational ", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#setliveness,-and", "labels": ["OpenZeppelin"]}, {"title": "setIdentifier\u00a0functions do not emit relevant events after executing sensitive actions.", "body": "setIdentifier\u00a0functions do not emit relevant events after executing sensitive actions.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#setidentifier\u00a0functions-do-not-emit-relevant-events-after-executing-sensitive-actions.", "labels": ["OpenZeppelin"]}, {"title": "Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts\u2019 activity.", "body": "Consider emitting events after sensitive changes take place (including in the constructor and/or initializer), to facilitate tracking and notify off-chain clients following the contracts\u2019 activity.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#consider-emitting-events-after-sensitive-changes-take-place-(including-in-the-constructor-and/or-initializer),-to-facilitate-tracking-and-notify-off-chain-clients-following-the-contracts\u2019-activity.", "labels": ["OpenZeppelin"]}, {"title": "Update:\u00a0Fixed as of commit\u00a0f6c3d17ae9e31d2f337d3f887647731959096663\u00a0in\u00a0pull request #3913\u00a0and commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull request #3914.", "body": "Update:\u00a0Fixed as of commit\u00a0f6c3d17ae9e31d2f337d3f887647731959096663\u00a0in\u00a0pull request #3913\u00a0and commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull request #3914.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#update:\u00a0fixed-as-of-commit\u00a0f6c3d17ae9e31d2f337d3f887647731959096663\u00a0in\u00a0pull-request-#3913\u00a0and-commit\u00a09b5b6d3f4b1168157344c1b93a2c2aa695f19580\u00a0in\u00a0pull-request-#3914.", "labels": ["OpenZeppelin"]}, {"title": "The\u00a0OptimisticGovernor\u00a0contract has a general lack of input validation. For instance, the\u00a0setUp\u00a0function does not validate that the\u00a0_finder\u00a0argument is non-zero, which can lead to a non-functional module instance. Nor does\u00a0setUp\u00a0validate that the\u00a0_rules\u00a0argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.", "body": "The\u00a0OptimisticGovernor\u00a0contract has a general lack of input validation. For instance, the\u00a0setUp\u00a0function does not validate that the\u00a0_finder\u00a0argument is non-zero, which can lead to a non-functional module instance. Nor does\u00a0setUp\u00a0validate that the\u00a0_rules\u00a0argument is non-empty, which could lead to a loss of funds if optimistic governance proposals are the sole way to manage an Avatar.", "html_url": "https://blog.openzeppelin.com/uma-optimistic-governor-audit#the\u00a0optimisticgovernor\u00a0contract-has-a-general-lack-of-input-validation.-for-instance,-the\u00a0setup\u00a0function-does-not-validate-that-the\u00a0_finder\u00a0argument-is-non-zero,-which-can-lead-to-a-non-functional-module-instance.-nor-does\u00a0setup\u00a0validate-that-the\u00a0_rules\u00a0argument-is-non-empty,-which-could-lead-to-a-loss-of-funds-if-optimistic-governance-proposals-are-the-sole-way-to-manage-an-avatar.", "labels": ["OpenZeppelin"]}]